# ====================================================================
# FILE: samples/ConditionalFormatting/01_Basic_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-165 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     3| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     4| use PhpOffice\PhpSpreadsheet\Style\Color;
     5| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     6| use PhpOffice\PhpSpreadsheet\Style\Fill;
     7| use PhpOffice\PhpSpreadsheet\Style\Style;
     8| require __DIR__ . '/../Header.php';
     9| $helper->log('Create new Spreadsheet object');
    10| $spreadsheet = new Spreadsheet();
    11| $helper->log('Set document properties');
    12| $spreadsheet->getProperties()->setCreator('Mark Baker')
    13|     ->setLastModifiedBy('Mark Baker')
    14|     ->setTitle('PhpSpreadsheet Test Document')
    15|     ->setSubject('PhpSpreadsheet Test Document')
    16|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    17|     ->setKeywords('office PhpSpreadsheet php')
    18|     ->setCategory('Test result file');
    19| $helper->log('Add data');
    20| $spreadsheet->setActiveSheetIndex(0);
    21| $spreadsheet->getActiveSheet()
    22|     ->setCellValue('A1', 'Literal Value Comparison')
    23|     ->setCellValue('A9', 'Value Comparison with Absolute Cell Reference $H$9')
    24|     ->setCellValue('A17', 'Value Comparison with Relative Cell References')
    25|     ->setCellValue('A23', 'Value Comparison with Formula based on AVERAGE() ± STDEV()')
    26|     ->setCellValue('A30', 'Literal String Value Comparison');
    27| $dataArray = [
    28|     [-2, -1, 0, 1, 2],
    29|     [-1, 0, 1, 2, 3],
    30|     [0, 1, 2, 3, 4],
    31|     [1, 2, 3, 4, 5],
    32| ];
    33| $betweenDataArray = [
    34|     [2, 7, 6],
    35|     [9, 5, 1],
    36|     [4, 3, 8],
    37| ];
    38| $stringArray = [
    39|     ['I'],
    40|     ['Love'],
    41|     ['PHP'],
    42| ];
    43| $spreadsheet->getActiveSheet()
    44|     ->fromArray($dataArray, null, 'A2', true)
    45|     ->fromArray($dataArray, null, 'A10', true)
    46|     ->fromArray($betweenDataArray, null, 'A18', true)
    47|     ->fromArray($dataArray, null, 'A24', true)
    48|     ->fromArray($stringArray, null, 'A31', true)
    49|     ->setCellValue('H9', 1);
    50| $helper->log('Set title row bold');
    51| $spreadsheet->getActiveSheet()->getStyle('A1:E1')->getFont()->setBold(true);
    52| $spreadsheet->getActiveSheet()->getStyle('A9:E9')->getFont()->setBold(true);
    53| $spreadsheet->getActiveSheet()->getStyle('A17:E17')->getFont()->setBold(true);
    54| $spreadsheet->getActiveSheet()->getStyle('A23:E23')->getFont()->setBold(true);
    55| $spreadsheet->getActiveSheet()->getStyle('A30:E30')->getFont()->setBold(true);
    56| $helper->log('Define some styles for our Conditionals');
    57| $yellowStyle = new Style(false, true);
    58| $yellowStyle->getFill()
    59|     ->setFillType(Fill::FILL_SOLID)
    60|     ->getStartColor()->setARGB(Color::COLOR_YELLOW);
    61| $yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
    62| $greenStyle = new Style(false, true);
    63| $greenStyle->getFill()
    64|     ->setFillType(Fill::FILL_SOLID)
    65|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    66| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    67| $redStyle = new Style(false, true);
    68| $redStyle->getFill()
    69|     ->setFillType(Fill::FILL_SOLID)
    70|     ->getStartColor()->setARGB(Color::COLOR_RED);
    71| $redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
    72| $helper->log('Define conditional formatting and set styles');
    73| $cellRange = 'A2:E5';
    74| $conditionalStyles = [];
    75| $wizardFactory = new Wizard($cellRange);
    76| /** @var Wizard\CellValue $cellWizard */
    77| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
    78| $cellWizard->equals(0)
    79|     ->setStyle($yellowStyle);
    80| $conditionalStyles[] = $cellWizard->getConditional();
    81| $cellWizard->greaterThan(0)
    82|     ->setStyle($greenStyle);
    83| $conditionalStyles[] = $cellWizard->getConditional();
    84| $cellWizard->lessThan(0)
    85|     ->setStyle($redStyle);
    86| $conditionalStyles[] = $cellWizard->getConditional();
    87| $spreadsheet->getActiveSheet()
    88|     ->getStyle($cellWizard->getCellRange())
    89|     ->setConditionalStyles($conditionalStyles);
    90| $cellRange = 'A10:E13';
    91| $conditionalStyles = [];
    92| $wizardFactory = new Wizard($cellRange);
    93| /** @var Wizard\CellValue $cellWizard */
    94| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
    95| $cellWizard->equals('$H$9', Wizard::VALUE_TYPE_CELL)
    96|     ->setStyle($yellowStyle);
    97| $conditionalStyles[] = $cellWizard->getConditional();
    98| $cellWizard->greaterThan('$H$9', Wizard::VALUE_TYPE_CELL)
    99|     ->setStyle($greenStyle);
   100| $conditionalStyles[] = $cellWizard->getConditional();
   101| $cellWizard->lessThan('$H$9', Wizard::VALUE_TYPE_CELL)
   102|     ->setStyle($redStyle);
   103| $conditionalStyles[] = $cellWizard->getConditional();
   104| $spreadsheet->getActiveSheet()
   105|     ->getStyle($cellWizard->getCellRange())
   106|     ->setConditionalStyles($conditionalStyles);
   107| $cellRange = 'A18:A20';
   108| $conditionalStyles = [];
   109| $wizardFactory = new Wizard($cellRange);
   110| /** @var Wizard\CellValue $cellWizard */
   111| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
   112| $cellWizard->between('$B1', Wizard::VALUE_TYPE_CELL)
   113|     ->and('$C1', Wizard::VALUE_TYPE_CELL)
   114|     ->setStyle($greenStyle);
   115| $conditionalStyles[] = $cellWizard->getConditional();
   116| $spreadsheet->getActiveSheet()
   117|     ->getStyle($cellWizard->getCellRange())
   118|     ->setConditionalStyles($conditionalStyles);
   119| $cellRange = 'A24:E27';
   120| $formulaRange = implode(
   121|     ':',
   122|     array_map(
   123|         [Coordinate::class, 'absoluteCoordinate'],
   124|         Coordinate::splitRange($cellRange)[0]
   125|     )
   126| );
   127| $conditionalStyles = [];
   128| $wizardFactory = new Wizard($cellRange);
   129| /** @var Wizard\CellValue $cellWizard */
   130| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
   131| $cellWizard->between('AVERAGE(' . $formulaRange . ')-STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
   132|     ->and('AVERAGE(' . $formulaRange . ')+STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
   133|     ->setStyle($yellowStyle);
   134| $conditionalStyles[] = $cellWizard->getConditional();
   135| $cellWizard->greaterThan('AVERAGE(' . $formulaRange . ')+STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
   136|     ->setStyle($greenStyle);
   137| $conditionalStyles[] = $cellWizard->getConditional();
   138| $cellWizard->lessThan('AVERAGE(' . $formulaRange . ')-STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
   139|     ->setStyle($redStyle);
   140| $conditionalStyles[] = $cellWizard->getConditional();
   141| $spreadsheet->getActiveSheet()
   142|     ->getStyle($cellWizard->getCellRange())
   143|     ->setConditionalStyles($conditionalStyles);
   144| $cellRange = 'A31:A33';
   145| $formulaRange = implode(
   146|     ':',
   147|     array_map(
   148|         [Coordinate::class, 'absoluteCoordinate'],
   149|         Coordinate::splitRange($cellRange)[0]
   150|     )
   151| );
   152| $conditionalStyles = [];
   153| $wizardFactory = new Wizard($cellRange);
   154| /** @var Wizard\CellValue $cellWizard */
   155| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
   156| $cellWizard->equals('LOVE')
   157|     ->setStyle($redStyle);
   158| $conditionalStyles[] = $cellWizard->getConditional();
   159| $cellWizard->equals('PHP')
   160|     ->setStyle($greenStyle);
   161| $conditionalStyles[] = $cellWizard->getConditional();
   162| $spreadsheet->getActiveSheet()
   163|     ->getStyle($cellWizard->getCellRange())
   164|     ->setConditionalStyles($conditionalStyles);
   165| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/02_Text_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-175 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| use PhpOffice\PhpSpreadsheet\Style\Fill;
     6| use PhpOffice\PhpSpreadsheet\Style\Style;
     7| require __DIR__ . '/../Header.php';
     8| $helper->log('Create new Spreadsheet object');
     9| $spreadsheet = new Spreadsheet();
    10| $helper->log('Set document properties');
    11| $spreadsheet->getProperties()->setCreator('Mark Baker')
    12|     ->setLastModifiedBy('Mark Baker')
    13|     ->setTitle('PhpSpreadsheet Test Document')
    14|     ->setSubject('PhpSpreadsheet Test Document')
    15|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    16|     ->setKeywords('office PhpSpreadsheet php')
    17|     ->setCategory('Test result file');
    18| $helper->log('Add data');
    19| $spreadsheet->setActiveSheetIndex(0);
    20| $spreadsheet->getActiveSheet()
    21|     ->setCellValue('A1', 'Value Begins With Literal')
    22|     ->setCellValue('A7', 'Value Ends With Literal')
    23|     ->setCellValue('A13', 'Value Contains Literal')
    24|     ->setCellValue('A19', "Value Doesn't Contain Literal")
    25|     ->setCellValue('E1', 'Value Begins With using Cell Reference')
    26|     ->setCellValue('E7', 'Value Ends With using Cell Reference')
    27|     ->setCellValue('E13', 'Value Contains using Cell Reference')
    28|     ->setCellValue('E19', "Value Doesn't Contain using Cell Reference")
    29|     ->setCellValue('A25', 'Simple Comparison using Concatenation Formula');
    30| $dataArray = [
    31|     ['HELLO', 'WORLD'],
    32|     ['MELLOW', 'YELLOW'],
    33|     ['SLEEPY', 'HOLLOW'],
    34| ];
    35| $spreadsheet->getActiveSheet()
    36|     ->fromArray($dataArray, null, 'A2', true)
    37|     ->fromArray($dataArray, null, 'A8', true)
    38|     ->fromArray($dataArray, null, 'A14', true)
    39|     ->fromArray($dataArray, null, 'A20', true)
    40|     ->fromArray($dataArray, null, 'E2', true)
    41|     ->fromArray($dataArray, null, 'E8', true)
    42|     ->fromArray($dataArray, null, 'E14', true)
    43|     ->fromArray($dataArray, null, 'E20', true)
    44|     ->fromArray($dataArray, null, 'A26', true)
    45|     ->setCellValue('D1', 'H')
    46|     ->setCellValue('D7', 'OW')
    47|     ->setCellValue('D13', 'LL')
    48|     ->setCellValue('D19', 'EL')
    49|     ->setCellValue('C26', 'HELLO WORLD')
    50|     ->setCellValue('C27', 'SOYLENT GREEN')
    51|     ->setCellValue('C28', 'SLEEPY HOLLOW');
    52| $helper->log('Set title row bold');
    53| $spreadsheet->getActiveSheet()->getStyle('A1:G1')->getFont()->setBold(true);
    54| $spreadsheet->getActiveSheet()->getStyle('A7:G7')->getFont()->setBold(true);
    55| $spreadsheet->getActiveSheet()->getStyle('A13:G13')->getFont()->setBold(true);
    56| $spreadsheet->getActiveSheet()->getStyle('A19:G19')->getFont()->setBold(true);
    57| $spreadsheet->getActiveSheet()->getStyle('A25:C25')->getFont()->setBold(true);
    58| $helper->log('Define some styles for our Conditionals');
    59| $yellowStyle = new Style(false, true);
    60| $yellowStyle->getFill()
    61|     ->setFillType(Fill::FILL_SOLID)
    62|     ->getStartColor()->setARGB(Color::COLOR_YELLOW);
    63| $yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
    64| $greenStyle = new Style(false, true);
    65| $greenStyle->getFill()
    66|     ->setFillType(Fill::FILL_SOLID)
    67|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    68| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    69| $redStyle = new Style(false, true);
    70| $redStyle->getFill()
    71|     ->setFillType(Fill::FILL_SOLID)
    72|     ->getStartColor()->setARGB(Color::COLOR_RED);
    73| $redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
    74| $helper->log('Define conditional formatting and set styles');
    75| $cellRange = 'A2:B4';
    76| $conditionalStyles = [];
    77| $wizardFactory = new Wizard($cellRange);
    78| /** @var Wizard\TextValue $textWizard */
    79| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
    80| $textWizard->beginsWith('H')
    81|     ->setStyle($yellowStyle);
    82| $conditionalStyles[] = $textWizard->getConditional();
    83| $spreadsheet->getActiveSheet()
    84|     ->getStyle($textWizard->getCellRange())
    85|     ->setConditionalStyles($conditionalStyles);
    86| $cellRange = 'E2:F4';
    87| $conditionalStyles = [];
    88| $wizardFactory = new Wizard($cellRange);
    89| /** @var Wizard\TextValue $textWizard */
    90| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
    91| $textWizard->beginsWith('$D$1', Wizard::VALUE_TYPE_CELL)
    92|     ->setStyle($yellowStyle);
    93| $conditionalStyles[] = $textWizard->getConditional();
    94| $spreadsheet->getActiveSheet()
    95|     ->getStyle($textWizard->getCellRange())
    96|     ->setConditionalStyles($conditionalStyles);
    97| $cellRange = 'A8:B10';
    98| $conditionalStyles = [];
    99| $wizardFactory = new Wizard($cellRange);
   100| /** @var Wizard\TextValue $textWizard */
   101| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   102| $textWizard->endsWith('OW')
   103|     ->setStyle($yellowStyle);
   104| $conditionalStyles[] = $textWizard->getConditional();
   105| $spreadsheet->getActiveSheet()
   106|     ->getStyle($textWizard->getCellRange())
   107|     ->setConditionalStyles($conditionalStyles);
   108| $cellRange = 'E8:F10';
   109| $conditionalStyles = [];
   110| $wizardFactory = new Wizard($cellRange);
   111| /** @var Wizard\TextValue $textWizard */
   112| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   113| $textWizard->endsWith('$D$7', Wizard::VALUE_TYPE_CELL)
   114|     ->setStyle($yellowStyle);
   115| $conditionalStyles[] = $textWizard->getConditional();
   116| $spreadsheet->getActiveSheet()
   117|     ->getStyle($textWizard->getCellRange())
   118|     ->setConditionalStyles($conditionalStyles);
   119| $cellRange = 'A14:B16';
   120| $conditionalStyles = [];
   121| $wizardFactory = new Wizard($cellRange);
   122| /** @var Wizard\TextValue $textWizard */
   123| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   124| $textWizard->contains('LL')
   125|     ->setStyle($greenStyle);
   126| $conditionalStyles[] = $textWizard->getConditional();
   127| $spreadsheet->getActiveSheet()
   128|     ->getStyle($textWizard->getCellRange())
   129|     ->setConditionalStyles($conditionalStyles);
   130| $cellRange = 'E14:F16';
   131| $conditionalStyles = [];
   132| $wizardFactory = new Wizard($cellRange);
   133| /** @var Wizard\TextValue $textWizard */
   134| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   135| $textWizard->contains('$D$13', Wizard::VALUE_TYPE_CELL)
   136|     ->setStyle($greenStyle);
   137| $conditionalStyles[] = $textWizard->getConditional();
   138| $spreadsheet->getActiveSheet()
   139|     ->getStyle($textWizard->getCellRange())
   140|     ->setConditionalStyles($conditionalStyles);
   141| $cellRange = 'A20:B22';
   142| $conditionalStyles = [];
   143| $wizardFactory = new Wizard($cellRange);
   144| /** @var Wizard\TextValue $textWizard */
   145| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   146| $textWizard->doesNotContain('EL')
   147|     ->setStyle($redStyle);
   148| $conditionalStyles[] = $textWizard->getConditional();
   149| $spreadsheet->getActiveSheet()
   150|     ->getStyle($textWizard->getCellRange())
   151|     ->setConditionalStyles($conditionalStyles);
   152| $cellRange = 'E20:F22';
   153| $conditionalStyles = [];
   154| $wizardFactory = new Wizard($cellRange);
   155| /** @var Wizard\TextValue $textWizard */
   156| $textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
   157| $textWizard->doesNotContain('$D$19', Wizard::VALUE_TYPE_CELL)
   158|     ->setStyle($redStyle);
   159| $conditionalStyles[] = $textWizard->getConditional();
   160| $spreadsheet->getActiveSheet()
   161|     ->getStyle($textWizard->getCellRange())
   162|     ->setConditionalStyles($conditionalStyles);
   163| $cellRange = 'C26:C28';
   164| $conditionalStyles = [];
   165| $wizardFactory = new Wizard($cellRange);
   166| /** @var Wizard\CellValue $cellWizard */
   167| $cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
   168| $cellWizard->equals('CONCATENATE($A1," ",$B1)', Wizard::VALUE_TYPE_FORMULA)
   169|     ->setStyle($yellowStyle);
   170| $conditionalStyles[] = $cellWizard->getConditional();
   171| $spreadsheet->getActiveSheet()
   172|     ->getStyle($cellWizard->getCellRange())
   173|     ->setConditionalStyles($conditionalStyles);
   174| $spreadsheet->getActiveSheet()->getColumnDimension('C')->setAutoSize(true);
   175| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/03_Blank_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| use PhpOffice\PhpSpreadsheet\Style\Fill;
     6| use PhpOffice\PhpSpreadsheet\Style\Style;
     7| require __DIR__ . '/../Header.php';
     8| $helper->log('Create new Spreadsheet object');
     9| $spreadsheet = new Spreadsheet();
    10| $helper->log('Set document properties');
    11| $spreadsheet->getProperties()->setCreator('Mark Baker')
    12|     ->setLastModifiedBy('Mark Baker')
    13|     ->setTitle('PhpSpreadsheet Test Document')
    14|     ->setSubject('PhpSpreadsheet Test Document')
    15|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    16|     ->setKeywords('office PhpSpreadsheet php')
    17|     ->setCategory('Test result file');
    18| $helper->log('Add data');
    19| $spreadsheet->setActiveSheetIndex(0);
    20| $spreadsheet->getActiveSheet()
    21|     ->setCellValue('A1', 'Blank Comparison');
    22| $dataArray = [
    23|     ['HELLO', null],
    24|     [null, 'WORLD'],
    25| ];
    26| $spreadsheet->getActiveSheet()
    27|     ->fromArray($dataArray, null, 'A2', true);
    28| $helper->log('Set title row bold');
    29| $spreadsheet->getActiveSheet()->getStyle('A1:B1')->getFont()->setBold(true);
    30| $helper->log('Define some styles for our Conditionals');
    31| $greenStyle = new Style(false, true);
    32| $greenStyle->getFill()
    33|     ->setFillType(Fill::FILL_SOLID)
    34|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    35| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    36| $redStyle = new Style(false, true);
    37| $redStyle->getFill()
    38|     ->setFillType(Fill::FILL_SOLID)
    39|     ->getStartColor()->setARGB(Color::COLOR_RED);
    40| $redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
    41| $helper->log('Define conditional formatting and set styles');
    42| $cellRange = 'A2:B3';
    43| $conditionalStyles = [];
    44| $wizardFactory = new Wizard($cellRange);
    45| /** @var Wizard\Blanks $blanksWizard */
    46| $blanksWizard = $wizardFactory->newRule(Wizard::BLANKS);
    47| $blanksWizard->setStyle($redStyle);
    48| $conditionalStyles[] = $blanksWizard->getConditional();
    49| $blanksWizard->notBlank()
    50|     ->setStyle($greenStyle);
    51| $conditionalStyles[] = $blanksWizard->getConditional();
    52| $spreadsheet->getActiveSheet()
    53|     ->getStyle($blanksWizard->getCellRange())
    54|     ->setConditionalStyles($conditionalStyles);
    55| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/04_Error_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| use PhpOffice\PhpSpreadsheet\Style\Fill;
     6| use PhpOffice\PhpSpreadsheet\Style\Style;
     7| require __DIR__ . '/../Header.php';
     8| $helper->log('Create new Spreadsheet object');
     9| $spreadsheet = new Spreadsheet();
    10| $helper->log('Set document properties');
    11| $spreadsheet->getProperties()->setCreator('Mark Baker')
    12|     ->setLastModifiedBy('Mark Baker')
    13|     ->setTitle('PhpSpreadsheet Test Document')
    14|     ->setSubject('PhpSpreadsheet Test Document')
    15|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    16|     ->setKeywords('office PhpSpreadsheet php')
    17|     ->setCategory('Test result file');
    18| $helper->log('Add data');
    19| $spreadsheet->setActiveSheetIndex(0);
    20| $spreadsheet->getActiveSheet()
    21|     ->setCellValue('A1', 'Error Comparison');
    22| $dataArray = [
    23|     [5, -2, '=A2/B2'],
    24|     [5, -1, '=A3/B3'],
    25|     [5, 0, '=A4/B4'],
    26|     [5, 1, '=A5/B5'],
    27|     [5, 2, '=A6/B6'],
    28| ];
    29| $spreadsheet->getActiveSheet()
    30|     ->fromArray($dataArray, null, 'A2', true);
    31| $helper->log('Set title row bold');
    32| $spreadsheet->getActiveSheet()->getStyle('A1:C1')->getFont()->setBold(true);
    33| $helper->log('Define some styles for our Conditionals');
    34| $greenStyle = new Style(false, true);
    35| $greenStyle->getFill()
    36|     ->setFillType(Fill::FILL_SOLID)
    37|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    38| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    39| $redStyle = new Style(false, true);
    40| $redStyle->getFill()
    41|     ->setFillType(Fill::FILL_SOLID)
    42|     ->getStartColor()->setARGB(Color::COLOR_RED);
    43| $redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
    44| $helper->log('Define conditional formatting and set styles');
    45| $cellRange = 'C2:C6';
    46| $conditionalStyles = [];
    47| $wizardFactory = new Wizard($cellRange);
    48| /** @var Wizard\Errors $errorsWizard */
    49| $errorsWizard = $wizardFactory->newRule(Wizard::ERRORS);
    50| $errorsWizard->setStyle($redStyle);
    51| $conditionalStyles[] = $errorsWizard->getConditional();
    52| $errorsWizard->notError()
    53|     ->setStyle($greenStyle);
    54| $conditionalStyles[] = $errorsWizard->getConditional();
    55| $spreadsheet->getActiveSheet()
    56|     ->getStyle($errorsWizard->getCellRange())
    57|     ->setConditionalStyles($conditionalStyles);
    58| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/05_Date_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Alignment;
     4| use PhpOffice\PhpSpreadsheet\Style\Color;
     5| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     6| use PhpOffice\PhpSpreadsheet\Style\Fill;
     7| use PhpOffice\PhpSpreadsheet\Style\Style;
     8| require __DIR__ . '/../Header.php';
     9| $helper->log('Create new Spreadsheet object');
    10| $spreadsheet = new Spreadsheet();
    11| $helper->log('Set document properties');
    12| $spreadsheet->getProperties()->setCreator('Mark Baker')
    13|     ->setLastModifiedBy('Mark Baker')
    14|     ->setTitle('PhpSpreadsheet Test Document')
    15|     ->setSubject('PhpSpreadsheet Test Document')
    16|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    17|     ->setKeywords('office PhpSpreadsheet php')
    18|     ->setCategory('Test result file');
    19| $helper->log('Add data');
    20| $spreadsheet->setActiveSheetIndex(0);
    21| $spreadsheet->getActiveSheet()
    22|     ->setCellValue('B1', 'yesterday()')
    23|     ->setCellValue('C1', 'today()')
    24|     ->setCellValue('D1', 'tomorrow()')
    25|     ->setCellValue('E1', 'last7Days()')
    26|     ->setCellValue('F1', 'lastWeek()')
    27|     ->setCellValue('G1', 'thisWeek()')
    28|     ->setCellValue('H1', 'nextWeek()')
    29|     ->setCellValue('I1', 'lastMonth()')
    30|     ->setCellValue('J1', 'thisMonth()')
    31|     ->setCellValue('K1', 'nextMonth()');
    32| $dateFunctionArray = [
    33|     'yesterday()',
    34|     'today()',
    35|     'tomorrow()',
    36|     'last7Days()',
    37|     'lastWeek()',
    38|     'thisWeek()',
    39|     'nextWeek()',
    40|     'lastMonth()',
    41|     'thisMonth()',
    42|     'nextMonth()',
    43| ];
    44| $dateTitleArray = [
    45|     ['First day of last month'],
    46|     ['Last day of last month'],
    47|     ['Last Monday'],
    48|     ['Last Friday'],
    49|     ['Monday last week'],
    50|     ['Wednesday last week'],
    51|     ['Friday last week'],
    52|     ['Yesterday'],
    53|     ['Today'],
    54|     ['Tomorrow'],
    55|     ['Monday this week'],
    56|     ['Wednesday this week'],
    57|     ['Friday this week'],
    58|     ['Monday next week'],
    59|     ['Wednesday next week'],
    60|     ['Friday next week'],
    61|     ['First day of next month'],
    62|     ['Last day of next month'],
    63| ];
    64| $dataArray = [
    65|     ['=EOMONTH(TODAY(),-2)+1'],
    66|     ['=EOMONTH(TODAY(),-1)'],
    67|     ['=TODAY()-WEEKDAY(TODAY(),3)'],
    68|     ['=TODAY()-WEEKDAY(TODAY())-1'],
    69|     ['=2-WEEKDAY(TODAY())+TODAY()-7'],
    70|     ['=4-WEEKDAY(TODAY())+TODAY()-7'],
    71|     ['=6-WEEKDAY(TODAY())+TODAY()-7'],
    72|     ['=TODAY()-1'],
    73|     ['=TODAY()'],
    74|     ['=TODAY()+1'],
    75|     ['=2-WEEKDAY(TODAY())+TODAY()'],
    76|     ['=4-WEEKDAY(TODAY())+TODAY()'],
    77|     ['=6-WEEKDAY(TODAY())+TODAY()'],
    78|     ['=2-WEEKDAY(TODAY())+TODAY()+7'],
    79|     ['=4-WEEKDAY(TODAY())+TODAY()+7'],
    80|     ['=6-WEEKDAY(TODAY())+TODAY()+7'],
    81|     ['=EOMONTH(TODAY(),0)+1'],
    82|     ['=EOMONTH(TODAY(),1)'],
    83| ];
    84| $spreadsheet->getActiveSheet()
    85|     ->fromArray($dateFunctionArray, null, 'B1', true);
    86| $spreadsheet->getActiveSheet()
    87|     ->fromArray($dateTitleArray, null, 'A2', true);
    88| for ($column = 'B'; $column !== 'L'; ++$column) {
    89|     $spreadsheet->getActiveSheet()
    90|         ->fromArray($dataArray, null, "{$column}2", true);
    91| }
    92| $helper->log('Set title row bold');
    93| $spreadsheet->getActiveSheet()->getStyle('B1:K1')->getFont()->setBold(true);
    94| $spreadsheet->getActiveSheet()->getStyle('B1:K1')->getAlignment()->setHorizontal(Alignment::HORIZONTAL_RIGHT);
    95| $helper->log('Define some styles for our Conditionals');
    96| $yellowStyle = new Style(false, true);
    97| $yellowStyle->getFill()
    98|     ->setFillType(Fill::FILL_SOLID)
    99|     ->getStartColor()->setARGB(Color::COLOR_YELLOW);
   100| $yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
   101| $helper->log('Define conditional formatting and set styles');
   102| for ($column = 'B'; $column !== 'L'; ++$column) {
   103|     $wizardFactory = new Wizard("{$column}2:{$column}19");
   104|     /** @var Wizard\DateValue $dateWizard */
   105|     $dateWizard = $wizardFactory->newRule(Wizard::DATES_OCCURRING);
   106|     $conditionalStyles = [];
   107|     /** @var string */
   108|     $cellContents = $spreadsheet->getActiveSheet()->getCell("{$column}1")->getValue();
   109|     $methodName = trim($cellContents, '()');
   110|     $dateWizard->$methodName()
   111|         ->setStyle($yellowStyle);
   112|     $conditionalStyles[] = $dateWizard->getConditional();
   113|     $spreadsheet->getActiveSheet()
   114|         ->getStyle($dateWizard->getCellRange())
   115|         ->setConditionalStyles($conditionalStyles);
   116| }
   117| $helper->log('Set some additional styling for date formats');
   118| $spreadsheet->getActiveSheet()->getStyle('B:B')->getNumberFormat()->setFormatCode('ddd dd-mmm-yyyy');
   119| for ($column = 'A'; $column !== 'L'; ++$column) {
   120|     if ($column !== 'A') {
   121|         $spreadsheet->getActiveSheet()->getStyle("{$column}:{$column}")
   122|             ->getNumberFormat()->setFormatCode('ddd dd-mmm-yyyy');
   123|     }
   124|     $spreadsheet->getActiveSheet()->getColumnDimension($column)
   125|         ->setAutoSize(true);
   126| }
   127| $spreadsheet->getActiveSheet()->getStyle('A:A')->getFont()->setBold(true);
   128| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/06_Duplicate_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| use PhpOffice\PhpSpreadsheet\Style\Fill;
     6| use PhpOffice\PhpSpreadsheet\Style\Style;
     7| require __DIR__ . '/../Header.php';
     8| $helper->log('Create new Spreadsheet object');
     9| $spreadsheet = new Spreadsheet();
    10| $helper->log('Set document properties');
    11| $spreadsheet->getProperties()->setCreator('Mark Baker')
    12|     ->setLastModifiedBy('Mark Baker')
    13|     ->setTitle('PhpSpreadsheet Test Document')
    14|     ->setSubject('PhpSpreadsheet Test Document')
    15|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    16|     ->setKeywords('office PhpSpreadsheet php')
    17|     ->setCategory('Test result file');
    18| $helper->log('Add data');
    19| $spreadsheet->setActiveSheetIndex(0);
    20| $spreadsheet->getActiveSheet()
    21|     ->setCellValue('A1', 'Duplicates Comparison');
    22| $dataArray = [
    23|     [1, 0, 3],
    24|     [2, 1, 1],
    25|     [3, 1, 4],
    26|     [4, 2, 1],
    27|     [5, 3, 5],
    28|     [6, 5, 9],
    29|     [7, 8, 2],
    30|     [8, 13, 6],
    31|     [9, 21, 5],
    32|     [10, 34, 3],
    33|     [11, 55, 5],
    34| ];
    35| $spreadsheet->getActiveSheet()
    36|     ->fromArray($dataArray, null, 'A2', true);
    37| $helper->log('Set title row bold');
    38| $spreadsheet->getActiveSheet()->getStyle('A1:C1')->getFont()->setBold(true);
    39| $helper->log('Define some styles for our Conditionals');
    40| $yellowStyle = new Style(false, true);
    41| $yellowStyle->getFill()
    42|     ->setFillType(Fill::FILL_SOLID)
    43|     ->getStartColor()->setARGB(Color::COLOR_YELLOW);
    44| $yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
    45| $greenStyle = new Style(false, true);
    46| $greenStyle->getFill()
    47|     ->setFillType(Fill::FILL_SOLID)
    48|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    49| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    50| $helper->log('Define conditional formatting and set styles');
    51| $cellRange = 'A2:C12';
    52| $conditionalStyles = [];
    53| $wizardFactory = new Wizard($cellRange);
    54| /** @var Wizard\Duplicates $duplicatesWizard */
    55| $duplicatesWizard = $wizardFactory->newRule(Wizard::DUPLICATES);
    56| $duplicatesWizard->setStyle($yellowStyle);
    57| $conditionalStyles[] = $duplicatesWizard->getConditional();
    58| $duplicatesWizard->unique()
    59|     ->setStyle($greenStyle);
    60| $conditionalStyles[] = $duplicatesWizard->getConditional();
    61| $spreadsheet->getActiveSheet()
    62|     ->getStyle($duplicatesWizard->getCellRange())
    63|     ->setConditionalStyles($conditionalStyles);
    64| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/ConditionalFormatting/07_Expression_Comparisons.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-114 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| use PhpOffice\PhpSpreadsheet\Style\Fill;
     6| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
     7| use PhpOffice\PhpSpreadsheet\Style\Style;
     8| require __DIR__ . '/../Header.php';
     9| $helper->log('Create new Spreadsheet object');
    10| $spreadsheet = new Spreadsheet();
    11| $helper->log('Set document properties');
    12| $spreadsheet->getProperties()->setCreator('Mark Baker')
    13|     ->setLastModifiedBy('Mark Baker')
    14|     ->setTitle('PhpSpreadsheet Test Document')
    15|     ->setSubject('PhpSpreadsheet Test Document')
    16|     ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
    17|     ->setKeywords('office PhpSpreadsheet php')
    18|     ->setCategory('Test result file');
    19| $helper->log('Add data');
    20| $spreadsheet->setActiveSheetIndex(0);
    21| $spreadsheet->getActiveSheet()
    22|     ->setCellValue('A1', 'Odd/Even Expression Comparison')
    23|     ->setCellValue('A4', 'Note that these functions are not available for Xls files')
    24|     ->setCellValue('A15', 'Sales Grid Expression Comparison')
    25|     ->setCellValue('A25', 'Sales Grid Multiple Expression Comparison');
    26| $dataArray = [
    27|     [1, 0, 3],
    28|     [2, 1, 1],
    29|     [3, 1, 4],
    30|     [4, 2, 1],
    31|     [5, 3, 5],
    32|     [6, 5, 9],
    33|     [7, 8, 2],
    34|     [8, 13, 6],
    35|     [9, 21, 5],
    36|     [10, 34, 4],
    37| ];
    38| $salesGrid = [
    39|     ['Name', 'Sales', 'Country', 'Quarter'],
    40|     ['Smith', 16753, 'UK', 'Q3'],
    41|     ['Johnson', 14808, 'USA', 'Q4'],
    42|     ['Williams', 10644, 'UK', 'Q2'],
    43|     ['Jones', 1390, 'USA', 'Q3'],
    44|     ['Brown', 4865, 'USA', 'Q4'],
    45|     ['Williams', 12438, 'UK', 'Q2'],
    46| ];
    47| $spreadsheet->getActiveSheet()
    48|     ->fromArray($dataArray, null, 'A2', true);
    49| $spreadsheet->getActiveSheet()
    50|     ->fromArray($salesGrid, null, 'A16', true);
    51| $spreadsheet->getActiveSheet()
    52|     ->fromArray($salesGrid, null, 'A26', true);
    53| $helper->log('Set title row bold');
    54| $spreadsheet->getActiveSheet()->getStyle('A1:B1')->getFont()->setBold(true);
    55| $spreadsheet->getActiveSheet()->getStyle('A15:D16')->getFont()->setBold(true);
    56| $spreadsheet->getActiveSheet()->getStyle('A25:D26')->getFont()->setBold(true);
    57| $helper->log('Define some styles for our Conditionals');
    58| $yellowStyle = new Style(false, true);
    59| $yellowStyle->getFill()
    60|     ->setFillType(Fill::FILL_SOLID)
    61|     ->getStartColor()->setARGB(Color::COLOR_YELLOW);
    62| $yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
    63| $greenStyle = new Style(false, true);
    64| $greenStyle->getFill()
    65|     ->setFillType(Fill::FILL_SOLID)
    66|     ->getStartColor()->setARGB(Color::COLOR_GREEN);
    67| $greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
    68| $greenStyleMoney = clone $greenStyle;
    69| $greenStyleMoney->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
    70| $helper->log('Define conditional formatting and set styles');
    71| $cellRange = 'A2:C11';
    72| $conditionalStyles = [];
    73| $wizardFactory = new Wizard($cellRange);
    74| /** @var Wizard\Expression $expressionWizard */
    75| $expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
    76| $expressionWizard->expression('ISODD(A1)')
    77|     ->setStyle($greenStyle);
    78| $conditionalStyles[] = $expressionWizard->getConditional();
    79| $expressionWizard->expression('ISEVEN(A1)')
    80|     ->setStyle($yellowStyle);
    81| $conditionalStyles[] = $expressionWizard->getConditional();
    82| $spreadsheet->getActiveSheet()
    83|     ->getStyle($expressionWizard->getCellRange())
    84|     ->setConditionalStyles($conditionalStyles);
    85| $cellRange = 'A17:D22';
    86| $conditionalStyles = [];
    87| $wizardFactory = new Wizard($cellRange);
    88| /** @var Wizard\Expression $expressionWizard */
    89| $expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
    90| $expressionWizard->expression('$C1="USA"')
    91|     ->setStyle($greenStyleMoney);
    92| $conditionalStyles[] = $expressionWizard->getConditional();
    93| $spreadsheet->getActiveSheet()
    94|     ->getStyle($expressionWizard->getCellRange())
    95|     ->setConditionalStyles($conditionalStyles);
    96| $cellRange = 'A27:D32';
    97| $conditionalStyles = [];
    98| $wizardFactory = new Wizard($cellRange);
    99| /** @var Wizard\Expression $expressionWizard */
   100| $expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
   101| $expressionWizard->expression('AND($C1="USA",$D1="Q4")')
   102|     ->setStyle($greenStyleMoney);
   103| $conditionalStyles[] = $expressionWizard->getConditional();
   104| $spreadsheet->getActiveSheet()
   105|     ->getStyle($expressionWizard->getCellRange())
   106|     ->setConditionalStyles($conditionalStyles);
   107| $helper->log('Set some additional styling for money formats');
   108| $spreadsheet->getActiveSheet()->getStyle('B17:B22')
   109|     ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
   110| $spreadsheet->getActiveSheet()->getStyle('B27:B32')
   111|     ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
   112| $spreadsheet->getActiveSheet()->getColumnDimension('B')
   113|     ->setAutoSize(true);
   114| $helper->write($spreadsheet, __FILE__);


# ====================================================================
# FILE: samples/Financial2/DISC.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel\Helpers as DateHelper;
     3| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     4| require __DIR__ . '/../Header.php';
     5| $helper->log('Returns the Discount Rate for a security.');
     6| $spreadsheet = new Spreadsheet();
     7| $worksheet = $spreadsheet->getActiveSheet();
     8| $arguments = [
     9|     ['Settlement Date', DateHelper::getDateValue('01-Apr-2016')],
    10|     ['Maturity Date', DateHelper::getDateValue('31-Mar-2021')],
    11|     ['Par Value', 95.00],
    12|     ['Redemption Value', 100.00],
    13| ];
    14| $worksheet->fromArray($arguments, null, 'A1');
    15| $worksheet->getStyle('B1:B2')->getNumberFormat()->setFormatCode('dd-mmm-yyyy');
    16| $worksheet->getStyle('B3:B4')->getNumberFormat()->setFormatCode('$#,##0.00');
    17| $worksheet->setCellValue('B7', '=DISC(B1, B2, B3, B4)');
    18| $worksheet->getStyle('B7')->getNumberFormat()->setFormatCode('0.00%');
    19| $helper->log($worksheet->getCell('B7')->getValue());
    20| $helper->log('DISC() Result is ' . $worksheet->getCell('B7')->getFormattedValue());


# ====================================================================
# FILE: samples/Reader2/23_iterateRowsYield.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| <?php
     2| /**
     3|  * Use rangeToArrayYieldRows() to efficiently iterate over all rows.
     4|  */
     5| require __DIR__ . '/../Header.php';
     6| $inputFileName = __DIR__ . '/../Reader/sampleData/example1.xls';
     7| $spreadsheet = PhpOffice\PhpSpreadsheet\IOFactory::load(
     8|     $inputFileName,
     9|     PhpOffice\PhpSpreadsheet\Reader\IReader::READ_DATA_ONLY
    10| );
    11| $sheet = $spreadsheet->getSheet(0);
    12| $rowGenerator = $sheet->rangeToArrayYieldRows(
    13|     $spreadsheet->getActiveSheet()->calculateWorksheetDataDimension(),
    14|     null,
    15|     false,
    16|     false
    17| );
    18| foreach ($rowGenerator as $row) {
    19|     echo '| ' . $row[0] . ' | ' . $row[1] . "|\n";
    20| }


# ====================================================================
# FILE: samples/index.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php
     2| require_once 'Header.php';
     3| $requirements = [
     4|     'PHP 8.1' => version_compare(PHP_VERSION, '8.1', '>='),
     5|     'PHP extension XML' => extension_loaded('xml'),
     6|     'PHP extension xmlwriter' => extension_loaded('xmlwriter'),
     7|     'PHP extension mbstring' => extension_loaded('mbstring'),
     8|     'PHP extension ZipArchive' => extension_loaded('zip'),
     9|     'PHP extension GD (optional)' => extension_loaded('gd'),
    10|     'PHP extension dom (optional)' => extension_loaded('dom'),
    11| ];
    12| if (!$helper->isCli()) {
    13|     ?>
    14|     <div class="jumbotron">
    15|         <p>Welcome to PHPSpreadsheet, a library written in pure PHP and providing a set of classes that allow you to read from and to write to different spreadsheet file formats, like Excel and LibreOffice Calc.</p>
    16|         <p>&nbsp;</p>
    17|         <p>
    18|             <a class="btn btn-lg btn-primary" href="https://github.com/PHPOffice/PHPSpreadsheet" role="button"><i class="fa fa-github fa-lg" title="GitHub"></i>  Fork us on Github!</a>
    19|             <a class="btn btn-lg btn-primary" href="https://phpspreadsheet.readthedocs.io" role="button"><i class="fa fa-book fa-lg" title="Docs"></i>  Read the Docs</a>
    20|         </p>
    21|     </div>
    22|     <?php
    23|     echo '<h3>Requirement check</h3>';
    24|     echo '<ul>';
    25|     foreach ($requirements as $label => $result) {
    26|         $status = $result ? 'passed' : 'failed';
    27|         echo "<li>{$label} ... <span class='{$status}'>{$status}</span></li>";
    28|     }
    29|     echo '</ul>';
    30| } else {
    31|     echo 'Requirement check:' . PHP_EOL;
    32|     foreach ($requirements as $label => $result) {
    33|         $status = $result ? '32m passed' : '31m failed';
    34|         echo "{$label} ... \033[{$status}\033[0m" . PHP_EOL;
    35|     }
    36| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/Calculation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5141 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Engine\BranchPruner;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Engine\CyclicReferenceStack;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Engine\Logger;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Engine\Operands;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     8| use PhpOffice\PhpSpreadsheet\Calculation\Token\Stack;
     9| use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
    10| use PhpOffice\PhpSpreadsheet\Cell\Cell;
    11| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
    12| use PhpOffice\PhpSpreadsheet\Cell\DataType;
    13| use PhpOffice\PhpSpreadsheet\DefinedName;
    14| use PhpOffice\PhpSpreadsheet\NamedRange;
    15| use PhpOffice\PhpSpreadsheet\ReferenceHelper;
    16| use PhpOffice\PhpSpreadsheet\Shared;
    17| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    18| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    19| use ReflectionClassConstant;
    20| use ReflectionMethod;
    21| use ReflectionParameter;
    22| use Throwable;
    23| class Calculation
    24| {
    25|     /** Constants                */
    26|     /** Regular Expressions        */
    27|     const CALCULATION_REGEXP_NUMBER = '[-+]?\d*\.?\d+(e[-+]?\d+)?';
    28|     const CALCULATION_REGEXP_STRING = '"(?:[^"]|"")*"';
    29|     const CALCULATION_REGEXP_OPENBRACE = '\(';
    30|     const CALCULATION_REGEXP_FUNCTION = '@?(?:_xlfn\.)?(?:_xlws\.)?([\p{L}][\p{L}\p{N}\.]*)[\s]*\(';
    31|     const CALCULATION_REGEXP_STRIP_XLFN_XLWS = '/(_xlfn[.])?(_xlws[.])?(?=[\p{L}][\p{L}\p{N}\.]*[\s]*[(])/';
    32|     const CALCULATION_REGEXP_CELLREF = '((([^\s,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?\$?\b([a-z]{1,3})\$?(\d{1,7})(?![\w.])';
    33|     const CALCULATION_REGEXP_CELLREF_RELATIVE = '((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?(\$?\b[a-z]{1,3})(\$?\d{1,7})(?![\w.])';
    34|     const CALCULATION_REGEXP_COLUMN_RANGE = '(((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\".(?:[^\"]|\"[^!])?\"))!)?(\$?[a-z]{1,3})):(?![.*])';
    35|     const CALCULATION_REGEXP_ROW_RANGE = '(((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?(\$?[1-9][0-9]{0,6})):(?![.*])';
    36|     const CALCULATION_REGEXP_COLUMNRANGE_RELATIVE = '(\$?[a-z]{1,3}):(\$?[a-z]{1,3})';
    37|     const CALCULATION_REGEXP_ROWRANGE_RELATIVE = '(\$?\d{1,7}):(\$?\d{1,7})';
    38|     const CALCULATION_REGEXP_DEFINEDNAME = '((([^\s,!&%^\/\*\+<>=-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?([_\p{L}][_\p{L}\p{N}\.]*)';
    39|     const CALCULATION_REGEXP_STRUCTURED_REFERENCE = '([\p{L}_\\\\][\p{L}\p{N}\._]+)?(\[(?:[^\d\]+-])?)';
    40|     const CALCULATION_REGEXP_ERROR = '\#[A-Z][A-Z0_\/]*[!\?]?';
    41|     /** constants */
    42|     const RETURN_ARRAY_AS_ERROR = 'error';
    43|     const RETURN_ARRAY_AS_VALUE = 'value';
    44|     const RETURN_ARRAY_AS_ARRAY = 'array';
    45|     const FORMULA_OPEN_FUNCTION_BRACE = '(';
    46|     const FORMULA_CLOSE_FUNCTION_BRACE = ')';
    47|     const FORMULA_OPEN_MATRIX_BRACE = '{';
    48|     const FORMULA_CLOSE_MATRIX_BRACE = '}';
    49|     const FORMULA_STRING_QUOTE = '"';
    50|     private static string $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;
    51|     /**
    52|      * Instance of this class.
    53|      *
    54|      * @var ?Calculation
    55|      */
    56|     private static ?Calculation $instance = null;
    57|     /**
    58|      * Instance of the spreadsheet this Calculation Engine is using.
    59|      */
    60|     private ?Spreadsheet $spreadsheet;
    61|     /**
    62|      * Calculation cache.
    63|      */
    64|     private array $calculationCache = [];
    65|     /**
    66|      * Calculation cache enabled.
    67|      */
    68|     private bool $calculationCacheEnabled = true;
    69|     private BranchPruner $branchPruner;
    70|     private bool $branchPruningEnabled = true;
    71|     /**
    72|      * List of operators that can be used within formulae
    73|      * The true/false value indicates whether it is a binary operator or a unary operator.
    74|      */
    75|     private const CALCULATION_OPERATORS = [
    76|         '+' => true, '-' => true, '*' => true, '/' => true,
    77|         '^' => true, '&' => true, '%' => false, '~' => false,
    78|         '>' => true, '<' => true, '=' => true, '>=' => true,
    79|         '<=' => true, '<>' => true, '∩' => true, '∪' => true,
    80|         ':' => true,
    81|     ];
    82|     /**
    83|      * List of binary operators (those that expect two operands).
    84|      */
    85|     private const BINARY_OPERATORS = [
    86|         '+' => true, '-' => true, '*' => true, '/' => true,
    87|         '^' => true, '&' => true, '>' => true, '<' => true,
    88|         '=' => true, '>=' => true, '<=' => true, '<>' => true,
    89|         '∩' => true, '∪' => true, ':' => true,
    90|     ];
    91|     /**
    92|      * The debug log generated by the calculation engine.
    93|      */
    94|     private Logger $debugLog;
    95|     private bool $suppressFormulaErrors = false;
    96|     /**
    97|      * Error message for any error that was raised/thrown by the calculation engine.
    98|      */
    99|     public ?string $formulaError = null;
   100|     /**
   101|      * Reference Helper.
   102|      */
   103|     private static ReferenceHelper $referenceHelper;
   104|     /**
   105|      * An array of the nested cell references accessed by the calculation engine, used for the debug log.
   106|      */
   107|     private CyclicReferenceStack $cyclicReferenceStack;
   108|     private array $cellStack = [];
   109|     /**
   110|      * Current iteration counter for cyclic formulae
   111|      * If the value is 0 (or less) then cyclic formulae will throw an exception,
   112|      * otherwise they will iterate to the limit defined here before returning a result.
   113|      */
   114|     private int $cyclicFormulaCounter = 1;
   115|     private string $cyclicFormulaCell = '';
   116|     /**
   117|      * Number of iterations for cyclic formulae.
   118|      */
   119|     public int $cyclicFormulaCount = 1;
   120|     /**
   121|      * The current locale setting.
   122|      */
   123|     private static string $localeLanguage = 'en_us'; //    US English    (default locale)
   124|     /**
   125|      * List of available locale settings
   126|      * Note that this is read for the locale subdirectory only when requested.
   127|      *
   128|      * @var string[]
   129|      */
   130|     private static array $validLocaleLanguages = [
   131|         'en', //    English        (default language)
   132|     ];
   133|     /**
   134|      * Locale-specific argument separator for function arguments.
   135|      */
   136|     private static string $localeArgumentSeparator = ',';
   137|     private static array $localeFunctions = [];
   138|     /**
   139|      * Locale-specific translations for Excel constants (True, False and Null).
   140|      *
   141|      * @var array<string, string>
   142|      */
   143|     private static array $localeBoolean = [
   144|         'TRUE' => 'TRUE',
   145|         'FALSE' => 'FALSE',
   146|         'NULL' => 'NULL',
   147|     ];
   148|     public static function getLocaleBoolean(string $index): string
   149|     {
   150|         return self::$localeBoolean[$index];
   151|     }
   152|     /**
   153|      * Excel constant string translations to their PHP equivalents
   154|      * Constant conversion from text name/value to actual (datatyped) value.
   155|      *
   156|      * @var array<string, null|bool>
   157|      */
   158|     private static array $excelConstants = [
   159|         'TRUE' => true,
   160|         'FALSE' => false,
   161|         'NULL' => null,
   162|     ];
   163|     public static function keyInExcelConstants(string $key): bool
   164|     {
   165|         return array_key_exists($key, self::$excelConstants);
   166|     }
   167|     public static function getExcelConstants(string $key): bool|null
   168|     {
   169|         return self::$excelConstants[$key];
   170|     }
   171|     /**
   172|      * Array of functions usable on Spreadsheet.
   173|      * In theory, this could be const rather than static;
   174|      *   however, Phpstan breaks trying to analyze it when attempted.
   175|      */
   176|     private static array $phpSpreadsheetFunctions = [
   177|         'ABS' => [
   178|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   179|             'functionCall' => [MathTrig\Absolute::class, 'evaluate'],
   180|             'argumentCount' => '1',
   181|         ],
   182|         'ACCRINT' => [
   183|             'category' => Category::CATEGORY_FINANCIAL,
   184|             'functionCall' => [Financial\Securities\AccruedInterest::class, 'periodic'],
   185|             'argumentCount' => '4-8',
   186|         ],
   187|         'ACCRINTM' => [
   188|             'category' => Category::CATEGORY_FINANCIAL,
   189|             'functionCall' => [Financial\Securities\AccruedInterest::class, 'atMaturity'],
   190|             'argumentCount' => '3-5',
   191|         ],
   192|         'ACOS' => [
   193|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   194|             'functionCall' => [MathTrig\Trig\Cosine::class, 'acos'],
   195|             'argumentCount' => '1',
   196|         ],
   197|         'ACOSH' => [
   198|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   199|             'functionCall' => [MathTrig\Trig\Cosine::class, 'acosh'],
   200|             'argumentCount' => '1',
   201|         ],
   202|         'ACOT' => [
   203|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   204|             'functionCall' => [MathTrig\Trig\Cotangent::class, 'acot'],
   205|             'argumentCount' => '1',
   206|         ],
   207|         'ACOTH' => [
   208|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   209|             'functionCall' => [MathTrig\Trig\Cotangent::class, 'acoth'],
   210|             'argumentCount' => '1',
   211|         ],
   212|         'ADDRESS' => [
   213|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
   214|             'functionCall' => [LookupRef\Address::class, 'cell'],
   215|             'argumentCount' => '2-5',
   216|         ],
   217|         'AGGREGATE' => [
   218|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   219|             'functionCall' => [Functions::class, 'DUMMY'],
   220|             'argumentCount' => '3+',
   221|         ],
   222|         'AMORDEGRC' => [
   223|             'category' => Category::CATEGORY_FINANCIAL,
   224|             'functionCall' => [Financial\Amortization::class, 'AMORDEGRC'],
   225|             'argumentCount' => '6,7',
   226|         ],
   227|         'AMORLINC' => [
   228|             'category' => Category::CATEGORY_FINANCIAL,
   229|             'functionCall' => [Financial\Amortization::class, 'AMORLINC'],
   230|             'argumentCount' => '6,7',
   231|         ],
   232|         'ANCHORARRAY' => [
   233|             'category' => Category::CATEGORY_UNCATEGORISED,
   234|             'functionCall' => [Functions::class, 'DUMMY'],
   235|             'argumentCount' => '*',
   236|         ],
   237|         'AND' => [
   238|             'category' => Category::CATEGORY_LOGICAL,
   239|             'functionCall' => [Logical\Operations::class, 'logicalAnd'],
   240|             'argumentCount' => '1+',
   241|         ],
   242|         'ARABIC' => [
   243|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   244|             'functionCall' => [MathTrig\Arabic::class, 'evaluate'],
   245|             'argumentCount' => '1',
   246|         ],
   247|         'AREAS' => [
   248|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
   249|             'functionCall' => [Functions::class, 'DUMMY'],
   250|             'argumentCount' => '1',
   251|         ],
   252|         'ARRAYTOTEXT' => [
   253|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   254|             'functionCall' => [TextData\Text::class, 'fromArray'],
   255|             'argumentCount' => '1,2',
   256|         ],
   257|         'ASC' => [
   258|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   259|             'functionCall' => [Functions::class, 'DUMMY'],
   260|             'argumentCount' => '1',
   261|         ],
   262|         'ASIN' => [
   263|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   264|             'functionCall' => [MathTrig\Trig\Sine::class, 'asin'],
   265|             'argumentCount' => '1',
   266|         ],
   267|         'ASINH' => [
   268|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   269|             'functionCall' => [MathTrig\Trig\Sine::class, 'asinh'],
   270|             'argumentCount' => '1',
   271|         ],
   272|         'ATAN' => [
   273|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   274|             'functionCall' => [MathTrig\Trig\Tangent::class, 'atan'],
   275|             'argumentCount' => '1',
   276|         ],
   277|         'ATAN2' => [
   278|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   279|             'functionCall' => [MathTrig\Trig\Tangent::class, 'atan2'],
   280|             'argumentCount' => '2',
   281|         ],
   282|         'ATANH' => [
   283|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   284|             'functionCall' => [MathTrig\Trig\Tangent::class, 'atanh'],
   285|             'argumentCount' => '1',
   286|         ],
   287|         'AVEDEV' => [
   288|             'category' => Category::CATEGORY_STATISTICAL,
   289|             'functionCall' => [Statistical\Averages::class, 'averageDeviations'],
   290|             'argumentCount' => '1+',
   291|         ],
   292|         'AVERAGE' => [
   293|             'category' => Category::CATEGORY_STATISTICAL,
   294|             'functionCall' => [Statistical\Averages::class, 'average'],
   295|             'argumentCount' => '1+',
   296|         ],
   297|         'AVERAGEA' => [
   298|             'category' => Category::CATEGORY_STATISTICAL,
   299|             'functionCall' => [Statistical\Averages::class, 'averageA'],
   300|             'argumentCount' => '1+',
   301|         ],
   302|         'AVERAGEIF' => [
   303|             'category' => Category::CATEGORY_STATISTICAL,
   304|             'functionCall' => [Statistical\Conditional::class, 'AVERAGEIF'],
   305|             'argumentCount' => '2,3',
   306|         ],
   307|         'AVERAGEIFS' => [
   308|             'category' => Category::CATEGORY_STATISTICAL,
   309|             'functionCall' => [Statistical\Conditional::class, 'AVERAGEIFS'],
   310|             'argumentCount' => '3+',
   311|         ],
   312|         'BAHTTEXT' => [
   313|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   314|             'functionCall' => [Functions::class, 'DUMMY'],
   315|             'argumentCount' => '1',
   316|         ],
   317|         'BASE' => [
   318|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   319|             'functionCall' => [MathTrig\Base::class, 'evaluate'],
   320|             'argumentCount' => '2,3',
   321|         ],
   322|         'BESSELI' => [
   323|             'category' => Category::CATEGORY_ENGINEERING,
   324|             'functionCall' => [Engineering\BesselI::class, 'BESSELI'],
   325|             'argumentCount' => '2',
   326|         ],
   327|         'BESSELJ' => [
   328|             'category' => Category::CATEGORY_ENGINEERING,
   329|             'functionCall' => [Engineering\BesselJ::class, 'BESSELJ'],
   330|             'argumentCount' => '2',
   331|         ],
   332|         'BESSELK' => [
   333|             'category' => Category::CATEGORY_ENGINEERING,
   334|             'functionCall' => [Engineering\BesselK::class, 'BESSELK'],
   335|             'argumentCount' => '2',
   336|         ],
   337|         'BESSELY' => [
   338|             'category' => Category::CATEGORY_ENGINEERING,
   339|             'functionCall' => [Engineering\BesselY::class, 'BESSELY'],
   340|             'argumentCount' => '2',
   341|         ],
   342|         'BETADIST' => [
   343|             'category' => Category::CATEGORY_STATISTICAL,
   344|             'functionCall' => [Statistical\Distributions\Beta::class, 'distribution'],
   345|             'argumentCount' => '3-5',
   346|         ],
   347|         'BETA.DIST' => [
   348|             'category' => Category::CATEGORY_STATISTICAL,
   349|             'functionCall' => [Functions::class, 'DUMMY'],
   350|             'argumentCount' => '4-6',
   351|         ],
   352|         'BETAINV' => [
   353|             'category' => Category::CATEGORY_STATISTICAL,
   354|             'functionCall' => [Statistical\Distributions\Beta::class, 'inverse'],
   355|             'argumentCount' => '3-5',
   356|         ],
   357|         'BETA.INV' => [
   358|             'category' => Category::CATEGORY_STATISTICAL,
   359|             'functionCall' => [Statistical\Distributions\Beta::class, 'inverse'],
   360|             'argumentCount' => '3-5',
   361|         ],
   362|         'BIN2DEC' => [
   363|             'category' => Category::CATEGORY_ENGINEERING,
   364|             'functionCall' => [Engineering\ConvertBinary::class, 'toDecimal'],
   365|             'argumentCount' => '1',
   366|         ],
   367|         'BIN2HEX' => [
   368|             'category' => Category::CATEGORY_ENGINEERING,
   369|             'functionCall' => [Engineering\ConvertBinary::class, 'toHex'],
   370|             'argumentCount' => '1,2',
   371|         ],
   372|         'BIN2OCT' => [
   373|             'category' => Category::CATEGORY_ENGINEERING,
   374|             'functionCall' => [Engineering\ConvertBinary::class, 'toOctal'],
   375|             'argumentCount' => '1,2',
   376|         ],
   377|         'BINOMDIST' => [
   378|             'category' => Category::CATEGORY_STATISTICAL,
   379|             'functionCall' => [Statistical\Distributions\Binomial::class, 'distribution'],
   380|             'argumentCount' => '4',
   381|         ],
   382|         'BINOM.DIST' => [
   383|             'category' => Category::CATEGORY_STATISTICAL,
   384|             'functionCall' => [Statistical\Distributions\Binomial::class, 'distribution'],
   385|             'argumentCount' => '4',
   386|         ],
   387|         'BINOM.DIST.RANGE' => [
   388|             'category' => Category::CATEGORY_STATISTICAL,
   389|             'functionCall' => [Statistical\Distributions\Binomial::class, 'range'],
   390|             'argumentCount' => '3,4',
   391|         ],
   392|         'BINOM.INV' => [
   393|             'category' => Category::CATEGORY_STATISTICAL,
   394|             'functionCall' => [Statistical\Distributions\Binomial::class, 'inverse'],
   395|             'argumentCount' => '3',
   396|         ],
   397|         'BITAND' => [
   398|             'category' => Category::CATEGORY_ENGINEERING,
   399|             'functionCall' => [Engineering\BitWise::class, 'BITAND'],
   400|             'argumentCount' => '2',
   401|         ],
   402|         'BITOR' => [
   403|             'category' => Category::CATEGORY_ENGINEERING,
   404|             'functionCall' => [Engineering\BitWise::class, 'BITOR'],
   405|             'argumentCount' => '2',
   406|         ],
   407|         'BITXOR' => [
   408|             'category' => Category::CATEGORY_ENGINEERING,
   409|             'functionCall' => [Engineering\BitWise::class, 'BITXOR'],
   410|             'argumentCount' => '2',
   411|         ],
   412|         'BITLSHIFT' => [
   413|             'category' => Category::CATEGORY_ENGINEERING,
   414|             'functionCall' => [Engineering\BitWise::class, 'BITLSHIFT'],
   415|             'argumentCount' => '2',
   416|         ],
   417|         'BITRSHIFT' => [
   418|             'category' => Category::CATEGORY_ENGINEERING,
   419|             'functionCall' => [Engineering\BitWise::class, 'BITRSHIFT'],
   420|             'argumentCount' => '2',
   421|         ],
   422|         'BYCOL' => [
   423|             'category' => Category::CATEGORY_LOGICAL,
   424|             'functionCall' => [Functions::class, 'DUMMY'],
   425|             'argumentCount' => '*',
   426|         ],
   427|         'BYROW' => [
   428|             'category' => Category::CATEGORY_LOGICAL,
   429|             'functionCall' => [Functions::class, 'DUMMY'],
   430|             'argumentCount' => '*',
   431|         ],
   432|         'CEILING' => [
   433|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   434|             'functionCall' => [MathTrig\Ceiling::class, 'ceiling'],
   435|             'argumentCount' => '1-2', // 2 for Excel, 1-2 for Ods/Gnumeric
   436|         ],
   437|         'CEILING.MATH' => [
   438|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   439|             'functionCall' => [MathTrig\Ceiling::class, 'math'],
   440|             'argumentCount' => '1-3',
   441|         ],
   442|         'CEILING.PRECISE' => [
   443|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   444|             'functionCall' => [MathTrig\Ceiling::class, 'precise'],
   445|             'argumentCount' => '1,2',
   446|         ],
   447|         'CELL' => [
   448|             'category' => Category::CATEGORY_INFORMATION,
   449|             'functionCall' => [Functions::class, 'DUMMY'],
   450|             'argumentCount' => '1,2',
   451|         ],
   452|         'CHAR' => [
   453|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   454|             'functionCall' => [TextData\CharacterConvert::class, 'character'],
   455|             'argumentCount' => '1',
   456|         ],
   457|         'CHIDIST' => [
   458|             'category' => Category::CATEGORY_STATISTICAL,
   459|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionRightTail'],
   460|             'argumentCount' => '2',
   461|         ],
   462|         'CHISQ.DIST' => [
   463|             'category' => Category::CATEGORY_STATISTICAL,
   464|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionLeftTail'],
   465|             'argumentCount' => '3',
   466|         ],
   467|         'CHISQ.DIST.RT' => [
   468|             'category' => Category::CATEGORY_STATISTICAL,
   469|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionRightTail'],
   470|             'argumentCount' => '2',
   471|         ],
   472|         'CHIINV' => [
   473|             'category' => Category::CATEGORY_STATISTICAL,
   474|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseRightTail'],
   475|             'argumentCount' => '2',
   476|         ],
   477|         'CHISQ.INV' => [
   478|             'category' => Category::CATEGORY_STATISTICAL,
   479|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseLeftTail'],
   480|             'argumentCount' => '2',
   481|         ],
   482|         'CHISQ.INV.RT' => [
   483|             'category' => Category::CATEGORY_STATISTICAL,
   484|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseRightTail'],
   485|             'argumentCount' => '2',
   486|         ],
   487|         'CHITEST' => [
   488|             'category' => Category::CATEGORY_STATISTICAL,
   489|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'test'],
   490|             'argumentCount' => '2',
   491|         ],
   492|         'CHISQ.TEST' => [
   493|             'category' => Category::CATEGORY_STATISTICAL,
   494|             'functionCall' => [Statistical\Distributions\ChiSquared::class, 'test'],
   495|             'argumentCount' => '2',
   496|         ],
   497|         'CHOOSE' => [
   498|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
   499|             'functionCall' => [LookupRef\Selection::class, 'CHOOSE'],
   500|             'argumentCount' => '2+',
   501|         ],
   502|         'CHOOSECOLS' => [
   503|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   504|             'functionCall' => [Functions::class, 'DUMMY'],
   505|             'argumentCount' => '2+',
   506|         ],
   507|         'CHOOSEROWS' => [
   508|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   509|             'functionCall' => [Functions::class, 'DUMMY'],
   510|             'argumentCount' => '2+',
   511|         ],
   512|         'CLEAN' => [
   513|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   514|             'functionCall' => [TextData\Trim::class, 'nonPrintable'],
   515|             'argumentCount' => '1',
   516|         ],
   517|         'CODE' => [
   518|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   519|             'functionCall' => [TextData\CharacterConvert::class, 'code'],
   520|             'argumentCount' => '1',
   521|         ],
   522|         'COLUMN' => [
   523|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
   524|             'functionCall' => [LookupRef\RowColumnInformation::class, 'COLUMN'],
   525|             'argumentCount' => '-1',
   526|             'passCellReference' => true,
   527|             'passByReference' => [true],
   528|         ],
   529|         'COLUMNS' => [
   530|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
   531|             'functionCall' => [LookupRef\RowColumnInformation::class, 'COLUMNS'],
   532|             'argumentCount' => '1',
   533|         ],
   534|         'COMBIN' => [
   535|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   536|             'functionCall' => [MathTrig\Combinations::class, 'withoutRepetition'],
   537|             'argumentCount' => '2',
   538|         ],
   539|         'COMBINA' => [
   540|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   541|             'functionCall' => [MathTrig\Combinations::class, 'withRepetition'],
   542|             'argumentCount' => '2',
   543|         ],
   544|         'COMPLEX' => [
   545|             'category' => Category::CATEGORY_ENGINEERING,
   546|             'functionCall' => [Engineering\Complex::class, 'COMPLEX'],
   547|             'argumentCount' => '2,3',
   548|         ],
   549|         'CONCAT' => [
   550|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   551|             'functionCall' => [TextData\Concatenate::class, 'CONCATENATE'],
   552|             'argumentCount' => '1+',
   553|         ],
   554|         'CONCATENATE' => [
   555|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   556|             'functionCall' => [TextData\Concatenate::class, 'CONCATENATE'],
   557|             'argumentCount' => '1+',
   558|         ],
   559|         'CONFIDENCE' => [
   560|             'category' => Category::CATEGORY_STATISTICAL,
   561|             'functionCall' => [Statistical\Confidence::class, 'CONFIDENCE'],
   562|             'argumentCount' => '3',
   563|         ],
   564|         'CONFIDENCE.NORM' => [
   565|             'category' => Category::CATEGORY_STATISTICAL,
   566|             'functionCall' => [Statistical\Confidence::class, 'CONFIDENCE'],
   567|             'argumentCount' => '3',
   568|         ],
   569|         'CONFIDENCE.T' => [
   570|             'category' => Category::CATEGORY_STATISTICAL,
   571|             'functionCall' => [Functions::class, 'DUMMY'],
   572|             'argumentCount' => '3',
   573|         ],
   574|         'CONVERT' => [
   575|             'category' => Category::CATEGORY_ENGINEERING,
   576|             'functionCall' => [Engineering\ConvertUOM::class, 'CONVERT'],
   577|             'argumentCount' => '3',
   578|         ],
   579|         'CORREL' => [
   580|             'category' => Category::CATEGORY_STATISTICAL,
   581|             'functionCall' => [Statistical\Trends::class, 'CORREL'],
   582|             'argumentCount' => '2',
   583|         ],
   584|         'COS' => [
   585|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   586|             'functionCall' => [MathTrig\Trig\Cosine::class, 'cos'],
   587|             'argumentCount' => '1',
   588|         ],
   589|         'COSH' => [
   590|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   591|             'functionCall' => [MathTrig\Trig\Cosine::class, 'cosh'],
   592|             'argumentCount' => '1',
   593|         ],
   594|         'COT' => [
   595|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   596|             'functionCall' => [MathTrig\Trig\Cotangent::class, 'cot'],
   597|             'argumentCount' => '1',
   598|         ],
   599|         'COTH' => [
   600|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   601|             'functionCall' => [MathTrig\Trig\Cotangent::class, 'coth'],
   602|             'argumentCount' => '1',
   603|         ],
   604|         'COUNT' => [
   605|             'category' => Category::CATEGORY_STATISTICAL,
   606|             'functionCall' => [Statistical\Counts::class, 'COUNT'],
   607|             'argumentCount' => '1+',
   608|         ],
   609|         'COUNTA' => [
   610|             'category' => Category::CATEGORY_STATISTICAL,
   611|             'functionCall' => [Statistical\Counts::class, 'COUNTA'],
   612|             'argumentCount' => '1+',
   613|         ],
   614|         'COUNTBLANK' => [
   615|             'category' => Category::CATEGORY_STATISTICAL,
   616|             'functionCall' => [Statistical\Counts::class, 'COUNTBLANK'],
   617|             'argumentCount' => '1',
   618|         ],
   619|         'COUNTIF' => [
   620|             'category' => Category::CATEGORY_STATISTICAL,
   621|             'functionCall' => [Statistical\Conditional::class, 'COUNTIF'],
   622|             'argumentCount' => '2',
   623|         ],
   624|         'COUNTIFS' => [
   625|             'category' => Category::CATEGORY_STATISTICAL,
   626|             'functionCall' => [Statistical\Conditional::class, 'COUNTIFS'],
   627|             'argumentCount' => '2+',
   628|         ],
   629|         'COUPDAYBS' => [
   630|             'category' => Category::CATEGORY_FINANCIAL,
   631|             'functionCall' => [Financial\Coupons::class, 'COUPDAYBS'],
   632|             'argumentCount' => '3,4',
   633|         ],
   634|         'COUPDAYS' => [
   635|             'category' => Category::CATEGORY_FINANCIAL,
   636|             'functionCall' => [Financial\Coupons::class, 'COUPDAYS'],
   637|             'argumentCount' => '3,4',
   638|         ],
   639|         'COUPDAYSNC' => [
   640|             'category' => Category::CATEGORY_FINANCIAL,
   641|             'functionCall' => [Financial\Coupons::class, 'COUPDAYSNC'],
   642|             'argumentCount' => '3,4',
   643|         ],
   644|         'COUPNCD' => [
   645|             'category' => Category::CATEGORY_FINANCIAL,
   646|             'functionCall' => [Financial\Coupons::class, 'COUPNCD'],
   647|             'argumentCount' => '3,4',
   648|         ],
   649|         'COUPNUM' => [
   650|             'category' => Category::CATEGORY_FINANCIAL,
   651|             'functionCall' => [Financial\Coupons::class, 'COUPNUM'],
   652|             'argumentCount' => '3,4',
   653|         ],
   654|         'COUPPCD' => [
   655|             'category' => Category::CATEGORY_FINANCIAL,
   656|             'functionCall' => [Financial\Coupons::class, 'COUPPCD'],
   657|             'argumentCount' => '3,4',
   658|         ],
   659|         'COVAR' => [
   660|             'category' => Category::CATEGORY_STATISTICAL,
   661|             'functionCall' => [Statistical\Trends::class, 'COVAR'],
   662|             'argumentCount' => '2',
   663|         ],
   664|         'COVARIANCE.P' => [
   665|             'category' => Category::CATEGORY_STATISTICAL,
   666|             'functionCall' => [Statistical\Trends::class, 'COVAR'],
   667|             'argumentCount' => '2',
   668|         ],
   669|         'COVARIANCE.S' => [
   670|             'category' => Category::CATEGORY_STATISTICAL,
   671|             'functionCall' => [Functions::class, 'DUMMY'],
   672|             'argumentCount' => '2',
   673|         ],
   674|         'CRITBINOM' => [
   675|             'category' => Category::CATEGORY_STATISTICAL,
   676|             'functionCall' => [Statistical\Distributions\Binomial::class, 'inverse'],
   677|             'argumentCount' => '3',
   678|         ],
   679|         'CSC' => [
   680|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   681|             'functionCall' => [MathTrig\Trig\Cosecant::class, 'csc'],
   682|             'argumentCount' => '1',
   683|         ],
   684|         'CSCH' => [
   685|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   686|             'functionCall' => [MathTrig\Trig\Cosecant::class, 'csch'],
   687|             'argumentCount' => '1',
   688|         ],
   689|         'CUBEKPIMEMBER' => [
   690|             'category' => Category::CATEGORY_CUBE,
   691|             'functionCall' => [Functions::class, 'DUMMY'],
   692|             'argumentCount' => '?',
   693|         ],
   694|         'CUBEMEMBER' => [
   695|             'category' => Category::CATEGORY_CUBE,
   696|             'functionCall' => [Functions::class, 'DUMMY'],
   697|             'argumentCount' => '?',
   698|         ],
   699|         'CUBEMEMBERPROPERTY' => [
   700|             'category' => Category::CATEGORY_CUBE,
   701|             'functionCall' => [Functions::class, 'DUMMY'],
   702|             'argumentCount' => '?',
   703|         ],
   704|         'CUBERANKEDMEMBER' => [
   705|             'category' => Category::CATEGORY_CUBE,
   706|             'functionCall' => [Functions::class, 'DUMMY'],
   707|             'argumentCount' => '?',
   708|         ],
   709|         'CUBESET' => [
   710|             'category' => Category::CATEGORY_CUBE,
   711|             'functionCall' => [Functions::class, 'DUMMY'],
   712|             'argumentCount' => '?',
   713|         ],
   714|         'CUBESETCOUNT' => [
   715|             'category' => Category::CATEGORY_CUBE,
   716|             'functionCall' => [Functions::class, 'DUMMY'],
   717|             'argumentCount' => '?',
   718|         ],
   719|         'CUBEVALUE' => [
   720|             'category' => Category::CATEGORY_CUBE,
   721|             'functionCall' => [Functions::class, 'DUMMY'],
   722|             'argumentCount' => '?',
   723|         ],
   724|         'CUMIPMT' => [
   725|             'category' => Category::CATEGORY_FINANCIAL,
   726|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Cumulative::class, 'interest'],
   727|             'argumentCount' => '6',
   728|         ],
   729|         'CUMPRINC' => [
   730|             'category' => Category::CATEGORY_FINANCIAL,
   731|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Cumulative::class, 'principal'],
   732|             'argumentCount' => '6',
   733|         ],
   734|         'DATE' => [
   735|             'category' => Category::CATEGORY_DATE_AND_TIME,
   736|             'functionCall' => [DateTimeExcel\Date::class, 'fromYMD'],
   737|             'argumentCount' => '3',
   738|         ],
   739|         'DATEDIF' => [
   740|             'category' => Category::CATEGORY_DATE_AND_TIME,
   741|             'functionCall' => [DateTimeExcel\Difference::class, 'interval'],
   742|             'argumentCount' => '2,3',
   743|         ],
   744|         'DATESTRING' => [
   745|             'category' => Category::CATEGORY_DATE_AND_TIME,
   746|             'functionCall' => [Functions::class, 'DUMMY'],
   747|             'argumentCount' => '?',
   748|         ],
   749|         'DATEVALUE' => [
   750|             'category' => Category::CATEGORY_DATE_AND_TIME,
   751|             'functionCall' => [DateTimeExcel\DateValue::class, 'fromString'],
   752|             'argumentCount' => '1',
   753|         ],
   754|         'DAVERAGE' => [
   755|             'category' => Category::CATEGORY_DATABASE,
   756|             'functionCall' => [Database\DAverage::class, 'evaluate'],
   757|             'argumentCount' => '3',
   758|         ],
   759|         'DAY' => [
   760|             'category' => Category::CATEGORY_DATE_AND_TIME,
   761|             'functionCall' => [DateTimeExcel\DateParts::class, 'day'],
   762|             'argumentCount' => '1',
   763|         ],
   764|         'DAYS' => [
   765|             'category' => Category::CATEGORY_DATE_AND_TIME,
   766|             'functionCall' => [DateTimeExcel\Days::class, 'between'],
   767|             'argumentCount' => '2',
   768|         ],
   769|         'DAYS360' => [
   770|             'category' => Category::CATEGORY_DATE_AND_TIME,
   771|             'functionCall' => [DateTimeExcel\Days360::class, 'between'],
   772|             'argumentCount' => '2,3',
   773|         ],
   774|         'DB' => [
   775|             'category' => Category::CATEGORY_FINANCIAL,
   776|             'functionCall' => [Financial\Depreciation::class, 'DB'],
   777|             'argumentCount' => '4,5',
   778|         ],
   779|         'DBCS' => [
   780|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   781|             'functionCall' => [Functions::class, 'DUMMY'],
   782|             'argumentCount' => '1',
   783|         ],
   784|         'DCOUNT' => [
   785|             'category' => Category::CATEGORY_DATABASE,
   786|             'functionCall' => [Database\DCount::class, 'evaluate'],
   787|             'argumentCount' => '3',
   788|         ],
   789|         'DCOUNTA' => [
   790|             'category' => Category::CATEGORY_DATABASE,
   791|             'functionCall' => [Database\DCountA::class, 'evaluate'],
   792|             'argumentCount' => '3',
   793|         ],
   794|         'DDB' => [
   795|             'category' => Category::CATEGORY_FINANCIAL,
   796|             'functionCall' => [Financial\Depreciation::class, 'DDB'],
   797|             'argumentCount' => '4,5',
   798|         ],
   799|         'DEC2BIN' => [
   800|             'category' => Category::CATEGORY_ENGINEERING,
   801|             'functionCall' => [Engineering\ConvertDecimal::class, 'toBinary'],
   802|             'argumentCount' => '1,2',
   803|         ],
   804|         'DEC2HEX' => [
   805|             'category' => Category::CATEGORY_ENGINEERING,
   806|             'functionCall' => [Engineering\ConvertDecimal::class, 'toHex'],
   807|             'argumentCount' => '1,2',
   808|         ],
   809|         'DEC2OCT' => [
   810|             'category' => Category::CATEGORY_ENGINEERING,
   811|             'functionCall' => [Engineering\ConvertDecimal::class, 'toOctal'],
   812|             'argumentCount' => '1,2',
   813|         ],
   814|         'DECIMAL' => [
   815|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   816|             'functionCall' => [Functions::class, 'DUMMY'],
   817|             'argumentCount' => '2',
   818|         ],
   819|         'DEGREES' => [
   820|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   821|             'functionCall' => [MathTrig\Angle::class, 'toDegrees'],
   822|             'argumentCount' => '1',
   823|         ],
   824|         'DELTA' => [
   825|             'category' => Category::CATEGORY_ENGINEERING,
   826|             'functionCall' => [Engineering\Compare::class, 'DELTA'],
   827|             'argumentCount' => '1,2',
   828|         ],
   829|         'DEVSQ' => [
   830|             'category' => Category::CATEGORY_STATISTICAL,
   831|             'functionCall' => [Statistical\Deviations::class, 'sumSquares'],
   832|             'argumentCount' => '1+',
   833|         ],
   834|         'DGET' => [
   835|             'category' => Category::CATEGORY_DATABASE,
   836|             'functionCall' => [Database\DGet::class, 'evaluate'],
   837|             'argumentCount' => '3',
   838|         ],
   839|         'DISC' => [
   840|             'category' => Category::CATEGORY_FINANCIAL,
   841|             'functionCall' => [Financial\Securities\Rates::class, 'discount'],
   842|             'argumentCount' => '4,5',
   843|         ],
   844|         'DMAX' => [
   845|             'category' => Category::CATEGORY_DATABASE,
   846|             'functionCall' => [Database\DMax::class, 'evaluate'],
   847|             'argumentCount' => '3',
   848|         ],
   849|         'DMIN' => [
   850|             'category' => Category::CATEGORY_DATABASE,
   851|             'functionCall' => [Database\DMin::class, 'evaluate'],
   852|             'argumentCount' => '3',
   853|         ],
   854|         'DOLLAR' => [
   855|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   856|             'functionCall' => [TextData\Format::class, 'DOLLAR'],
   857|             'argumentCount' => '1,2',
   858|         ],
   859|         'DOLLARDE' => [
   860|             'category' => Category::CATEGORY_FINANCIAL,
   861|             'functionCall' => [Financial\Dollar::class, 'decimal'],
   862|             'argumentCount' => '2',
   863|         ],
   864|         'DOLLARFR' => [
   865|             'category' => Category::CATEGORY_FINANCIAL,
   866|             'functionCall' => [Financial\Dollar::class, 'fractional'],
   867|             'argumentCount' => '2',
   868|         ],
   869|         'DPRODUCT' => [
   870|             'category' => Category::CATEGORY_DATABASE,
   871|             'functionCall' => [Database\DProduct::class, 'evaluate'],
   872|             'argumentCount' => '3',
   873|         ],
   874|         'DROP' => [
   875|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   876|             'functionCall' => [Functions::class, 'DUMMY'],
   877|             'argumentCount' => '2-3',
   878|         ],
   879|         'DSTDEV' => [
   880|             'category' => Category::CATEGORY_DATABASE,
   881|             'functionCall' => [Database\DStDev::class, 'evaluate'],
   882|             'argumentCount' => '3',
   883|         ],
   884|         'DSTDEVP' => [
   885|             'category' => Category::CATEGORY_DATABASE,
   886|             'functionCall' => [Database\DStDevP::class, 'evaluate'],
   887|             'argumentCount' => '3',
   888|         ],
   889|         'DSUM' => [
   890|             'category' => Category::CATEGORY_DATABASE,
   891|             'functionCall' => [Database\DSum::class, 'evaluate'],
   892|             'argumentCount' => '3',
   893|         ],
   894|         'DURATION' => [
   895|             'category' => Category::CATEGORY_FINANCIAL,
   896|             'functionCall' => [Functions::class, 'DUMMY'],
   897|             'argumentCount' => '5,6',
   898|         ],
   899|         'DVAR' => [
   900|             'category' => Category::CATEGORY_DATABASE,
   901|             'functionCall' => [Database\DVar::class, 'evaluate'],
   902|             'argumentCount' => '3',
   903|         ],
   904|         'DVARP' => [
   905|             'category' => Category::CATEGORY_DATABASE,
   906|             'functionCall' => [Database\DVarP::class, 'evaluate'],
   907|             'argumentCount' => '3',
   908|         ],
   909|         'ECMA.CEILING' => [
   910|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   911|             'functionCall' => [Functions::class, 'DUMMY'],
   912|             'argumentCount' => '1,2',
   913|         ],
   914|         'EDATE' => [
   915|             'category' => Category::CATEGORY_DATE_AND_TIME,
   916|             'functionCall' => [DateTimeExcel\Month::class, 'adjust'],
   917|             'argumentCount' => '2',
   918|         ],
   919|         'EFFECT' => [
   920|             'category' => Category::CATEGORY_FINANCIAL,
   921|             'functionCall' => [Financial\InterestRate::class, 'effective'],
   922|             'argumentCount' => '2',
   923|         ],
   924|         'ENCODEURL' => [
   925|             'category' => Category::CATEGORY_WEB,
   926|             'functionCall' => [Web\Service::class, 'urlEncode'],
   927|             'argumentCount' => '1',
   928|         ],
   929|         'EOMONTH' => [
   930|             'category' => Category::CATEGORY_DATE_AND_TIME,
   931|             'functionCall' => [DateTimeExcel\Month::class, 'lastDay'],
   932|             'argumentCount' => '2',
   933|         ],
   934|         'ERF' => [
   935|             'category' => Category::CATEGORY_ENGINEERING,
   936|             'functionCall' => [Engineering\Erf::class, 'ERF'],
   937|             'argumentCount' => '1,2',
   938|         ],
   939|         'ERF.PRECISE' => [
   940|             'category' => Category::CATEGORY_ENGINEERING,
   941|             'functionCall' => [Engineering\Erf::class, 'ERFPRECISE'],
   942|             'argumentCount' => '1',
   943|         ],
   944|         'ERFC' => [
   945|             'category' => Category::CATEGORY_ENGINEERING,
   946|             'functionCall' => [Engineering\ErfC::class, 'ERFC'],
   947|             'argumentCount' => '1',
   948|         ],
   949|         'ERFC.PRECISE' => [
   950|             'category' => Category::CATEGORY_ENGINEERING,
   951|             'functionCall' => [Engineering\ErfC::class, 'ERFC'],
   952|             'argumentCount' => '1',
   953|         ],
   954|         'ERROR.TYPE' => [
   955|             'category' => Category::CATEGORY_INFORMATION,
   956|             'functionCall' => [ExcelError::class, 'type'],
   957|             'argumentCount' => '1',
   958|         ],
   959|         'EVEN' => [
   960|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   961|             'functionCall' => [MathTrig\Round::class, 'even'],
   962|             'argumentCount' => '1',
   963|         ],
   964|         'EXACT' => [
   965|             'category' => Category::CATEGORY_TEXT_AND_DATA,
   966|             'functionCall' => [TextData\Text::class, 'exact'],
   967|             'argumentCount' => '2',
   968|         ],
   969|         'EXP' => [
   970|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   971|             'functionCall' => [MathTrig\Exp::class, 'evaluate'],
   972|             'argumentCount' => '1',
   973|         ],
   974|         'EXPAND' => [
   975|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   976|             'functionCall' => [Functions::class, 'DUMMY'],
   977|             'argumentCount' => '2-4',
   978|         ],
   979|         'EXPONDIST' => [
   980|             'category' => Category::CATEGORY_STATISTICAL,
   981|             'functionCall' => [Statistical\Distributions\Exponential::class, 'distribution'],
   982|             'argumentCount' => '3',
   983|         ],
   984|         'EXPON.DIST' => [
   985|             'category' => Category::CATEGORY_STATISTICAL,
   986|             'functionCall' => [Statistical\Distributions\Exponential::class, 'distribution'],
   987|             'argumentCount' => '3',
   988|         ],
   989|         'FACT' => [
   990|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   991|             'functionCall' => [MathTrig\Factorial::class, 'fact'],
   992|             'argumentCount' => '1',
   993|         ],
   994|         'FACTDOUBLE' => [
   995|             'category' => Category::CATEGORY_MATH_AND_TRIG,
   996|             'functionCall' => [MathTrig\Factorial::class, 'factDouble'],
   997|             'argumentCount' => '1',
   998|         ],
   999|         'FALSE' => [
  1000|             'category' => Category::CATEGORY_LOGICAL,
  1001|             'functionCall' => [Logical\Boolean::class, 'FALSE'],
  1002|             'argumentCount' => '0',
  1003|         ],
  1004|         'FDIST' => [
  1005|             'category' => Category::CATEGORY_STATISTICAL,
  1006|             'functionCall' => [Functions::class, 'DUMMY'],
  1007|             'argumentCount' => '3',
  1008|         ],
  1009|         'F.DIST' => [
  1010|             'category' => Category::CATEGORY_STATISTICAL,
  1011|             'functionCall' => [Statistical\Distributions\F::class, 'distribution'],
  1012|             'argumentCount' => '4',
  1013|         ],
  1014|         'F.DIST.RT' => [
  1015|             'category' => Category::CATEGORY_STATISTICAL,
  1016|             'functionCall' => [Functions::class, 'DUMMY'],
  1017|             'argumentCount' => '3',
  1018|         ],
  1019|         'FILTER' => [
  1020|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1021|             'functionCall' => [LookupRef\Filter::class, 'filter'],
  1022|             'argumentCount' => '2-3',
  1023|         ],
  1024|         'FILTERXML' => [
  1025|             'category' => Category::CATEGORY_WEB,
  1026|             'functionCall' => [Functions::class, 'DUMMY'],
  1027|             'argumentCount' => '2',
  1028|         ],
  1029|         'FIND' => [
  1030|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1031|             'functionCall' => [TextData\Search::class, 'sensitive'],
  1032|             'argumentCount' => '2,3',
  1033|         ],
  1034|         'FINDB' => [
  1035|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1036|             'functionCall' => [TextData\Search::class, 'sensitive'],
  1037|             'argumentCount' => '2,3',
  1038|         ],
  1039|         'FINV' => [
  1040|             'category' => Category::CATEGORY_STATISTICAL,
  1041|             'functionCall' => [Functions::class, 'DUMMY'],
  1042|             'argumentCount' => '3',
  1043|         ],
  1044|         'F.INV' => [
  1045|             'category' => Category::CATEGORY_STATISTICAL,
  1046|             'functionCall' => [Functions::class, 'DUMMY'],
  1047|             'argumentCount' => '3',
  1048|         ],
  1049|         'F.INV.RT' => [
  1050|             'category' => Category::CATEGORY_STATISTICAL,
  1051|             'functionCall' => [Functions::class, 'DUMMY'],
  1052|             'argumentCount' => '3',
  1053|         ],
  1054|         'FISHER' => [
  1055|             'category' => Category::CATEGORY_STATISTICAL,
  1056|             'functionCall' => [Statistical\Distributions\Fisher::class, 'distribution'],
  1057|             'argumentCount' => '1',
  1058|         ],
  1059|         'FISHERINV' => [
  1060|             'category' => Category::CATEGORY_STATISTICAL,
  1061|             'functionCall' => [Statistical\Distributions\Fisher::class, 'inverse'],
  1062|             'argumentCount' => '1',
  1063|         ],
  1064|         'FIXED' => [
  1065|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1066|             'functionCall' => [TextData\Format::class, 'FIXEDFORMAT'],
  1067|             'argumentCount' => '1-3',
  1068|         ],
  1069|         'FLOOR' => [
  1070|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1071|             'functionCall' => [MathTrig\Floor::class, 'floor'],
  1072|             'argumentCount' => '1-2', // Excel requries 2, Ods/Gnumeric 1-2
  1073|         ],
  1074|         'FLOOR.MATH' => [
  1075|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1076|             'functionCall' => [MathTrig\Floor::class, 'math'],
  1077|             'argumentCount' => '1-3',
  1078|         ],
  1079|         'FLOOR.PRECISE' => [
  1080|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1081|             'functionCall' => [MathTrig\Floor::class, 'precise'],
  1082|             'argumentCount' => '1-2',
  1083|         ],
  1084|         'FORECAST' => [
  1085|             'category' => Category::CATEGORY_STATISTICAL,
  1086|             'functionCall' => [Statistical\Trends::class, 'FORECAST'],
  1087|             'argumentCount' => '3',
  1088|         ],
  1089|         'FORECAST.ETS' => [
  1090|             'category' => Category::CATEGORY_STATISTICAL,
  1091|             'functionCall' => [Functions::class, 'DUMMY'],
  1092|             'argumentCount' => '3-6',
  1093|         ],
  1094|         'FORECAST.ETS.CONFINT' => [
  1095|             'category' => Category::CATEGORY_STATISTICAL,
  1096|             'functionCall' => [Functions::class, 'DUMMY'],
  1097|             'argumentCount' => '3-6',
  1098|         ],
  1099|         'FORECAST.ETS.SEASONALITY' => [
  1100|             'category' => Category::CATEGORY_STATISTICAL,
  1101|             'functionCall' => [Functions::class, 'DUMMY'],
  1102|             'argumentCount' => '2-4',
  1103|         ],
  1104|         'FORECAST.ETS.STAT' => [
  1105|             'category' => Category::CATEGORY_STATISTICAL,
  1106|             'functionCall' => [Functions::class, 'DUMMY'],
  1107|             'argumentCount' => '3-6',
  1108|         ],
  1109|         'FORECAST.LINEAR' => [
  1110|             'category' => Category::CATEGORY_STATISTICAL,
  1111|             'functionCall' => [Statistical\Trends::class, 'FORECAST'],
  1112|             'argumentCount' => '3',
  1113|         ],
  1114|         'FORMULATEXT' => [
  1115|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1116|             'functionCall' => [LookupRef\Formula::class, 'text'],
  1117|             'argumentCount' => '1',
  1118|             'passCellReference' => true,
  1119|             'passByReference' => [true],
  1120|         ],
  1121|         'FREQUENCY' => [
  1122|             'category' => Category::CATEGORY_STATISTICAL,
  1123|             'functionCall' => [Functions::class, 'DUMMY'],
  1124|             'argumentCount' => '2',
  1125|         ],
  1126|         'FTEST' => [
  1127|             'category' => Category::CATEGORY_STATISTICAL,
  1128|             'functionCall' => [Functions::class, 'DUMMY'],
  1129|             'argumentCount' => '2',
  1130|         ],
  1131|         'F.TEST' => [
  1132|             'category' => Category::CATEGORY_STATISTICAL,
  1133|             'functionCall' => [Functions::class, 'DUMMY'],
  1134|             'argumentCount' => '2',
  1135|         ],
  1136|         'FV' => [
  1137|             'category' => Category::CATEGORY_FINANCIAL,
  1138|             'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'futureValue'],
  1139|             'argumentCount' => '3-5',
  1140|         ],
  1141|         'FVSCHEDULE' => [
  1142|             'category' => Category::CATEGORY_FINANCIAL,
  1143|             'functionCall' => [Financial\CashFlow\Single::class, 'futureValue'],
  1144|             'argumentCount' => '2',
  1145|         ],
  1146|         'GAMMA' => [
  1147|             'category' => Category::CATEGORY_STATISTICAL,
  1148|             'functionCall' => [Statistical\Distributions\Gamma::class, 'gamma'],
  1149|             'argumentCount' => '1',
  1150|         ],
  1151|         'GAMMADIST' => [
  1152|             'category' => Category::CATEGORY_STATISTICAL,
  1153|             'functionCall' => [Statistical\Distributions\Gamma::class, 'distribution'],
  1154|             'argumentCount' => '4',
  1155|         ],
  1156|         'GAMMA.DIST' => [
  1157|             'category' => Category::CATEGORY_STATISTICAL,
  1158|             'functionCall' => [Statistical\Distributions\Gamma::class, 'distribution'],
  1159|             'argumentCount' => '4',
  1160|         ],
  1161|         'GAMMAINV' => [
  1162|             'category' => Category::CATEGORY_STATISTICAL,
  1163|             'functionCall' => [Statistical\Distributions\Gamma::class, 'inverse'],
  1164|             'argumentCount' => '3',
  1165|         ],
  1166|         'GAMMA.INV' => [
  1167|             'category' => Category::CATEGORY_STATISTICAL,
  1168|             'functionCall' => [Statistical\Distributions\Gamma::class, 'inverse'],
  1169|             'argumentCount' => '3',
  1170|         ],
  1171|         'GAMMALN' => [
  1172|             'category' => Category::CATEGORY_STATISTICAL,
  1173|             'functionCall' => [Statistical\Distributions\Gamma::class, 'ln'],
  1174|             'argumentCount' => '1',
  1175|         ],
  1176|         'GAMMALN.PRECISE' => [
  1177|             'category' => Category::CATEGORY_STATISTICAL,
  1178|             'functionCall' => [Statistical\Distributions\Gamma::class, 'ln'],
  1179|             'argumentCount' => '1',
  1180|         ],
  1181|         'GAUSS' => [
  1182|             'category' => Category::CATEGORY_STATISTICAL,
  1183|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'gauss'],
  1184|             'argumentCount' => '1',
  1185|         ],
  1186|         'GCD' => [
  1187|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1188|             'functionCall' => [MathTrig\Gcd::class, 'evaluate'],
  1189|             'argumentCount' => '1+',
  1190|         ],
  1191|         'GEOMEAN' => [
  1192|             'category' => Category::CATEGORY_STATISTICAL,
  1193|             'functionCall' => [Statistical\Averages\Mean::class, 'geometric'],
  1194|             'argumentCount' => '1+',
  1195|         ],
  1196|         'GESTEP' => [
  1197|             'category' => Category::CATEGORY_ENGINEERING,
  1198|             'functionCall' => [Engineering\Compare::class, 'GESTEP'],
  1199|             'argumentCount' => '1,2',
  1200|         ],
  1201|         'GETPIVOTDATA' => [
  1202|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1203|             'functionCall' => [Functions::class, 'DUMMY'],
  1204|             'argumentCount' => '2+',
  1205|         ],
  1206|         'GROWTH' => [
  1207|             'category' => Category::CATEGORY_STATISTICAL,
  1208|             'functionCall' => [Statistical\Trends::class, 'GROWTH'],
  1209|             'argumentCount' => '1-4',
  1210|         ],
  1211|         'HARMEAN' => [
  1212|             'category' => Category::CATEGORY_STATISTICAL,
  1213|             'functionCall' => [Statistical\Averages\Mean::class, 'harmonic'],
  1214|             'argumentCount' => '1+',
  1215|         ],
  1216|         'HEX2BIN' => [
  1217|             'category' => Category::CATEGORY_ENGINEERING,
  1218|             'functionCall' => [Engineering\ConvertHex::class, 'toBinary'],
  1219|             'argumentCount' => '1,2',
  1220|         ],
  1221|         'HEX2DEC' => [
  1222|             'category' => Category::CATEGORY_ENGINEERING,
  1223|             'functionCall' => [Engineering\ConvertHex::class, 'toDecimal'],
  1224|             'argumentCount' => '1',
  1225|         ],
  1226|         'HEX2OCT' => [
  1227|             'category' => Category::CATEGORY_ENGINEERING,
  1228|             'functionCall' => [Engineering\ConvertHex::class, 'toOctal'],
  1229|             'argumentCount' => '1,2',
  1230|         ],
  1231|         'HLOOKUP' => [
  1232|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1233|             'functionCall' => [LookupRef\HLookup::class, 'lookup'],
  1234|             'argumentCount' => '3,4',
  1235|         ],
  1236|         'HOUR' => [
  1237|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1238|             'functionCall' => [DateTimeExcel\TimeParts::class, 'hour'],
  1239|             'argumentCount' => '1',
  1240|         ],
  1241|         'HSTACK' => [
  1242|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1243|             'functionCall' => [Functions::class, 'DUMMY'],
  1244|             'argumentCount' => '1+',
  1245|         ],
  1246|         'HYPERLINK' => [
  1247|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1248|             'functionCall' => [LookupRef\Hyperlink::class, 'set'],
  1249|             'argumentCount' => '1,2',
  1250|             'passCellReference' => true,
  1251|         ],
  1252|         'HYPGEOMDIST' => [
  1253|             'category' => Category::CATEGORY_STATISTICAL,
  1254|             'functionCall' => [Statistical\Distributions\HyperGeometric::class, 'distribution'],
  1255|             'argumentCount' => '4',
  1256|         ],
  1257|         'HYPGEOM.DIST' => [
  1258|             'category' => Category::CATEGORY_STATISTICAL,
  1259|             'functionCall' => [Functions::class, 'DUMMY'],
  1260|             'argumentCount' => '5',
  1261|         ],
  1262|         'IF' => [
  1263|             'category' => Category::CATEGORY_LOGICAL,
  1264|             'functionCall' => [Logical\Conditional::class, 'statementIf'],
  1265|             'argumentCount' => '2-3',
  1266|         ],
  1267|         'IFERROR' => [
  1268|             'category' => Category::CATEGORY_LOGICAL,
  1269|             'functionCall' => [Logical\Conditional::class, 'IFERROR'],
  1270|             'argumentCount' => '2',
  1271|         ],
  1272|         'IFNA' => [
  1273|             'category' => Category::CATEGORY_LOGICAL,
  1274|             'functionCall' => [Logical\Conditional::class, 'IFNA'],
  1275|             'argumentCount' => '2',
  1276|         ],
  1277|         'IFS' => [
  1278|             'category' => Category::CATEGORY_LOGICAL,
  1279|             'functionCall' => [Logical\Conditional::class, 'IFS'],
  1280|             'argumentCount' => '2+',
  1281|         ],
  1282|         'IMABS' => [
  1283|             'category' => Category::CATEGORY_ENGINEERING,
  1284|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMABS'],
  1285|             'argumentCount' => '1',
  1286|         ],
  1287|         'IMAGINARY' => [
  1288|             'category' => Category::CATEGORY_ENGINEERING,
  1289|             'functionCall' => [Engineering\Complex::class, 'IMAGINARY'],
  1290|             'argumentCount' => '1',
  1291|         ],
  1292|         'IMARGUMENT' => [
  1293|             'category' => Category::CATEGORY_ENGINEERING,
  1294|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMARGUMENT'],
  1295|             'argumentCount' => '1',
  1296|         ],
  1297|         'IMCONJUGATE' => [
  1298|             'category' => Category::CATEGORY_ENGINEERING,
  1299|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCONJUGATE'],
  1300|             'argumentCount' => '1',
  1301|         ],
  1302|         'IMCOS' => [
  1303|             'category' => Category::CATEGORY_ENGINEERING,
  1304|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOS'],
  1305|             'argumentCount' => '1',
  1306|         ],
  1307|         'IMCOSH' => [
  1308|             'category' => Category::CATEGORY_ENGINEERING,
  1309|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOSH'],
  1310|             'argumentCount' => '1',
  1311|         ],
  1312|         'IMCOT' => [
  1313|             'category' => Category::CATEGORY_ENGINEERING,
  1314|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOT'],
  1315|             'argumentCount' => '1',
  1316|         ],
  1317|         'IMCSC' => [
  1318|             'category' => Category::CATEGORY_ENGINEERING,
  1319|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCSC'],
  1320|             'argumentCount' => '1',
  1321|         ],
  1322|         'IMCSCH' => [
  1323|             'category' => Category::CATEGORY_ENGINEERING,
  1324|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMCSCH'],
  1325|             'argumentCount' => '1',
  1326|         ],
  1327|         'IMDIV' => [
  1328|             'category' => Category::CATEGORY_ENGINEERING,
  1329|             'functionCall' => [Engineering\ComplexOperations::class, 'IMDIV'],
  1330|             'argumentCount' => '2',
  1331|         ],
  1332|         'IMEXP' => [
  1333|             'category' => Category::CATEGORY_ENGINEERING,
  1334|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMEXP'],
  1335|             'argumentCount' => '1',
  1336|         ],
  1337|         'IMLN' => [
  1338|             'category' => Category::CATEGORY_ENGINEERING,
  1339|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMLN'],
  1340|             'argumentCount' => '1',
  1341|         ],
  1342|         'IMLOG10' => [
  1343|             'category' => Category::CATEGORY_ENGINEERING,
  1344|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMLOG10'],
  1345|             'argumentCount' => '1',
  1346|         ],
  1347|         'IMLOG2' => [
  1348|             'category' => Category::CATEGORY_ENGINEERING,
  1349|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMLOG2'],
  1350|             'argumentCount' => '1',
  1351|         ],
  1352|         'IMPOWER' => [
  1353|             'category' => Category::CATEGORY_ENGINEERING,
  1354|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMPOWER'],
  1355|             'argumentCount' => '2',
  1356|         ],
  1357|         'IMPRODUCT' => [
  1358|             'category' => Category::CATEGORY_ENGINEERING,
  1359|             'functionCall' => [Engineering\ComplexOperations::class, 'IMPRODUCT'],
  1360|             'argumentCount' => '1+',
  1361|         ],
  1362|         'IMREAL' => [
  1363|             'category' => Category::CATEGORY_ENGINEERING,
  1364|             'functionCall' => [Engineering\Complex::class, 'IMREAL'],
  1365|             'argumentCount' => '1',
  1366|         ],
  1367|         'IMSEC' => [
  1368|             'category' => Category::CATEGORY_ENGINEERING,
  1369|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMSEC'],
  1370|             'argumentCount' => '1',
  1371|         ],
  1372|         'IMSECH' => [
  1373|             'category' => Category::CATEGORY_ENGINEERING,
  1374|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMSECH'],
  1375|             'argumentCount' => '1',
  1376|         ],
  1377|         'IMSIN' => [
  1378|             'category' => Category::CATEGORY_ENGINEERING,
  1379|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMSIN'],
  1380|             'argumentCount' => '1',
  1381|         ],
  1382|         'IMSINH' => [
  1383|             'category' => Category::CATEGORY_ENGINEERING,
  1384|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMSINH'],
  1385|             'argumentCount' => '1',
  1386|         ],
  1387|         'IMSQRT' => [
  1388|             'category' => Category::CATEGORY_ENGINEERING,
  1389|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMSQRT'],
  1390|             'argumentCount' => '1',
  1391|         ],
  1392|         'IMSUB' => [
  1393|             'category' => Category::CATEGORY_ENGINEERING,
  1394|             'functionCall' => [Engineering\ComplexOperations::class, 'IMSUB'],
  1395|             'argumentCount' => '2',
  1396|         ],
  1397|         'IMSUM' => [
  1398|             'category' => Category::CATEGORY_ENGINEERING,
  1399|             'functionCall' => [Engineering\ComplexOperations::class, 'IMSUM'],
  1400|             'argumentCount' => '1+',
  1401|         ],
  1402|         'IMTAN' => [
  1403|             'category' => Category::CATEGORY_ENGINEERING,
  1404|             'functionCall' => [Engineering\ComplexFunctions::class, 'IMTAN'],
  1405|             'argumentCount' => '1',
  1406|         ],
  1407|         'INDEX' => [
  1408|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1409|             'functionCall' => [LookupRef\Matrix::class, 'index'],
  1410|             'argumentCount' => '2-4',
  1411|         ],
  1412|         'INDIRECT' => [
  1413|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1414|             'functionCall' => [LookupRef\Indirect::class, 'INDIRECT'],
  1415|             'argumentCount' => '1,2',
  1416|             'passCellReference' => true,
  1417|         ],
  1418|         'INFO' => [
  1419|             'category' => Category::CATEGORY_INFORMATION,
  1420|             'functionCall' => [Functions::class, 'DUMMY'],
  1421|             'argumentCount' => '1',
  1422|         ],
  1423|         'INT' => [
  1424|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1425|             'functionCall' => [MathTrig\IntClass::class, 'evaluate'],
  1426|             'argumentCount' => '1',
  1427|         ],
  1428|         'INTERCEPT' => [
  1429|             'category' => Category::CATEGORY_STATISTICAL,
  1430|             'functionCall' => [Statistical\Trends::class, 'INTERCEPT'],
  1431|             'argumentCount' => '2',
  1432|         ],
  1433|         'INTRATE' => [
  1434|             'category' => Category::CATEGORY_FINANCIAL,
  1435|             'functionCall' => [Financial\Securities\Rates::class, 'interest'],
  1436|             'argumentCount' => '4,5',
  1437|         ],
  1438|         'IPMT' => [
  1439|             'category' => Category::CATEGORY_FINANCIAL,
  1440|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'payment'],
  1441|             'argumentCount' => '4-6',
  1442|         ],
  1443|         'IRR' => [
  1444|             'category' => Category::CATEGORY_FINANCIAL,
  1445|             'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'rate'],
  1446|             'argumentCount' => '1,2',
  1447|         ],
  1448|         'ISBLANK' => [
  1449|             'category' => Category::CATEGORY_INFORMATION,
  1450|             'functionCall' => [Information\Value::class, 'isBlank'],
  1451|             'argumentCount' => '1',
  1452|         ],
  1453|         'ISERR' => [
  1454|             'category' => Category::CATEGORY_INFORMATION,
  1455|             'functionCall' => [Information\ErrorValue::class, 'isErr'],
  1456|             'argumentCount' => '1',
  1457|         ],
  1458|         'ISERROR' => [
  1459|             'category' => Category::CATEGORY_INFORMATION,
  1460|             'functionCall' => [Information\ErrorValue::class, 'isError'],
  1461|             'argumentCount' => '1',
  1462|         ],
  1463|         'ISEVEN' => [
  1464|             'category' => Category::CATEGORY_INFORMATION,
  1465|             'functionCall' => [Information\Value::class, 'isEven'],
  1466|             'argumentCount' => '1',
  1467|         ],
  1468|         'ISFORMULA' => [
  1469|             'category' => Category::CATEGORY_INFORMATION,
  1470|             'functionCall' => [Information\Value::class, 'isFormula'],
  1471|             'argumentCount' => '1',
  1472|             'passCellReference' => true,
  1473|             'passByReference' => [true],
  1474|         ],
  1475|         'ISLOGICAL' => [
  1476|             'category' => Category::CATEGORY_INFORMATION,
  1477|             'functionCall' => [Information\Value::class, 'isLogical'],
  1478|             'argumentCount' => '1',
  1479|         ],
  1480|         'ISNA' => [
  1481|             'category' => Category::CATEGORY_INFORMATION,
  1482|             'functionCall' => [Information\ErrorValue::class, 'isNa'],
  1483|             'argumentCount' => '1',
  1484|         ],
  1485|         'ISNONTEXT' => [
  1486|             'category' => Category::CATEGORY_INFORMATION,
  1487|             'functionCall' => [Information\Value::class, 'isNonText'],
  1488|             'argumentCount' => '1',
  1489|         ],
  1490|         'ISNUMBER' => [
  1491|             'category' => Category::CATEGORY_INFORMATION,
  1492|             'functionCall' => [Information\Value::class, 'isNumber'],
  1493|             'argumentCount' => '1',
  1494|         ],
  1495|         'ISO.CEILING' => [
  1496|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1497|             'functionCall' => [Functions::class, 'DUMMY'],
  1498|             'argumentCount' => '1,2',
  1499|         ],
  1500|         'ISODD' => [
  1501|             'category' => Category::CATEGORY_INFORMATION,
  1502|             'functionCall' => [Information\Value::class, 'isOdd'],
  1503|             'argumentCount' => '1',
  1504|         ],
  1505|         'ISOMITTED' => [
  1506|             'category' => Category::CATEGORY_INFORMATION,
  1507|             'functionCall' => [Functions::class, 'DUMMY'],
  1508|             'argumentCount' => '*',
  1509|         ],
  1510|         'ISOWEEKNUM' => [
  1511|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1512|             'functionCall' => [DateTimeExcel\Week::class, 'isoWeekNumber'],
  1513|             'argumentCount' => '1',
  1514|         ],
  1515|         'ISPMT' => [
  1516|             'category' => Category::CATEGORY_FINANCIAL,
  1517|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'schedulePayment'],
  1518|             'argumentCount' => '4',
  1519|         ],
  1520|         'ISREF' => [
  1521|             'category' => Category::CATEGORY_INFORMATION,
  1522|             'functionCall' => [Information\Value::class, 'isRef'],
  1523|             'argumentCount' => '1',
  1524|             'passCellReference' => true,
  1525|             'passByReference' => [true],
  1526|         ],
  1527|         'ISTEXT' => [
  1528|             'category' => Category::CATEGORY_INFORMATION,
  1529|             'functionCall' => [Information\Value::class, 'isText'],
  1530|             'argumentCount' => '1',
  1531|         ],
  1532|         'ISTHAIDIGIT' => [
  1533|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1534|             'functionCall' => [Functions::class, 'DUMMY'],
  1535|             'argumentCount' => '?',
  1536|         ],
  1537|         'JIS' => [
  1538|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1539|             'functionCall' => [Functions::class, 'DUMMY'],
  1540|             'argumentCount' => '1',
  1541|         ],
  1542|         'KURT' => [
  1543|             'category' => Category::CATEGORY_STATISTICAL,
  1544|             'functionCall' => [Statistical\Deviations::class, 'kurtosis'],
  1545|             'argumentCount' => '1+',
  1546|         ],
  1547|         'LAMBDA' => [
  1548|             'category' => Category::CATEGORY_LOGICAL,
  1549|             'functionCall' => [Functions::class, 'DUMMY'],
  1550|             'argumentCount' => '*',
  1551|         ],
  1552|         'LARGE' => [
  1553|             'category' => Category::CATEGORY_STATISTICAL,
  1554|             'functionCall' => [Statistical\Size::class, 'large'],
  1555|             'argumentCount' => '2',
  1556|         ],
  1557|         'LCM' => [
  1558|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1559|             'functionCall' => [MathTrig\Lcm::class, 'evaluate'],
  1560|             'argumentCount' => '1+',
  1561|         ],
  1562|         'LEFT' => [
  1563|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1564|             'functionCall' => [TextData\Extract::class, 'left'],
  1565|             'argumentCount' => '1,2',
  1566|         ],
  1567|         'LEFTB' => [
  1568|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1569|             'functionCall' => [TextData\Extract::class, 'left'],
  1570|             'argumentCount' => '1,2',
  1571|         ],
  1572|         'LEN' => [
  1573|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1574|             'functionCall' => [TextData\Text::class, 'length'],
  1575|             'argumentCount' => '1',
  1576|         ],
  1577|         'LENB' => [
  1578|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1579|             'functionCall' => [TextData\Text::class, 'length'],
  1580|             'argumentCount' => '1',
  1581|         ],
  1582|         'LET' => [
  1583|             'category' => Category::CATEGORY_LOGICAL,
  1584|             'functionCall' => [Functions::class, 'DUMMY'],
  1585|             'argumentCount' => '*',
  1586|         ],
  1587|         'LINEST' => [
  1588|             'category' => Category::CATEGORY_STATISTICAL,
  1589|             'functionCall' => [Statistical\Trends::class, 'LINEST'],
  1590|             'argumentCount' => '1-4',
  1591|         ],
  1592|         'LN' => [
  1593|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1594|             'functionCall' => [MathTrig\Logarithms::class, 'natural'],
  1595|             'argumentCount' => '1',
  1596|         ],
  1597|         'LOG' => [
  1598|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1599|             'functionCall' => [MathTrig\Logarithms::class, 'withBase'],
  1600|             'argumentCount' => '1,2',
  1601|         ],
  1602|         'LOG10' => [
  1603|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1604|             'functionCall' => [MathTrig\Logarithms::class, 'base10'],
  1605|             'argumentCount' => '1',
  1606|         ],
  1607|         'LOGEST' => [
  1608|             'category' => Category::CATEGORY_STATISTICAL,
  1609|             'functionCall' => [Statistical\Trends::class, 'LOGEST'],
  1610|             'argumentCount' => '1-4',
  1611|         ],
  1612|         'LOGINV' => [
  1613|             'category' => Category::CATEGORY_STATISTICAL,
  1614|             'functionCall' => [Statistical\Distributions\LogNormal::class, 'inverse'],
  1615|             'argumentCount' => '3',
  1616|         ],
  1617|         'LOGNORMDIST' => [
  1618|             'category' => Category::CATEGORY_STATISTICAL,
  1619|             'functionCall' => [Statistical\Distributions\LogNormal::class, 'cumulative'],
  1620|             'argumentCount' => '3',
  1621|         ],
  1622|         'LOGNORM.DIST' => [
  1623|             'category' => Category::CATEGORY_STATISTICAL,
  1624|             'functionCall' => [Statistical\Distributions\LogNormal::class, 'distribution'],
  1625|             'argumentCount' => '4',
  1626|         ],
  1627|         'LOGNORM.INV' => [
  1628|             'category' => Category::CATEGORY_STATISTICAL,
  1629|             'functionCall' => [Statistical\Distributions\LogNormal::class, 'inverse'],
  1630|             'argumentCount' => '3',
  1631|         ],
  1632|         'LOOKUP' => [
  1633|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1634|             'functionCall' => [LookupRef\Lookup::class, 'lookup'],
  1635|             'argumentCount' => '2,3',
  1636|         ],
  1637|         'LOWER' => [
  1638|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1639|             'functionCall' => [TextData\CaseConvert::class, 'lower'],
  1640|             'argumentCount' => '1',
  1641|         ],
  1642|         'MAKEARRAY' => [
  1643|             'category' => Category::CATEGORY_LOGICAL,
  1644|             'functionCall' => [Functions::class, 'DUMMY'],
  1645|             'argumentCount' => '*',
  1646|         ],
  1647|         'MAP' => [
  1648|             'category' => Category::CATEGORY_LOGICAL,
  1649|             'functionCall' => [Functions::class, 'DUMMY'],
  1650|             'argumentCount' => '*',
  1651|         ],
  1652|         'MATCH' => [
  1653|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1654|             'functionCall' => [LookupRef\ExcelMatch::class, 'MATCH'],
  1655|             'argumentCount' => '2,3',
  1656|         ],
  1657|         'MAX' => [
  1658|             'category' => Category::CATEGORY_STATISTICAL,
  1659|             'functionCall' => [Statistical\Maximum::class, 'max'],
  1660|             'argumentCount' => '1+',
  1661|         ],
  1662|         'MAXA' => [
  1663|             'category' => Category::CATEGORY_STATISTICAL,
  1664|             'functionCall' => [Statistical\Maximum::class, 'maxA'],
  1665|             'argumentCount' => '1+',
  1666|         ],
  1667|         'MAXIFS' => [
  1668|             'category' => Category::CATEGORY_STATISTICAL,
  1669|             'functionCall' => [Statistical\Conditional::class, 'MAXIFS'],
  1670|             'argumentCount' => '3+',
  1671|         ],
  1672|         'MDETERM' => [
  1673|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1674|             'functionCall' => [MathTrig\MatrixFunctions::class, 'determinant'],
  1675|             'argumentCount' => '1',
  1676|         ],
  1677|         'MDURATION' => [
  1678|             'category' => Category::CATEGORY_FINANCIAL,
  1679|             'functionCall' => [Functions::class, 'DUMMY'],
  1680|             'argumentCount' => '5,6',
  1681|         ],
  1682|         'MEDIAN' => [
  1683|             'category' => Category::CATEGORY_STATISTICAL,
  1684|             'functionCall' => [Statistical\Averages::class, 'median'],
  1685|             'argumentCount' => '1+',
  1686|         ],
  1687|         'MEDIANIF' => [
  1688|             'category' => Category::CATEGORY_STATISTICAL,
  1689|             'functionCall' => [Functions::class, 'DUMMY'],
  1690|             'argumentCount' => '2+',
  1691|         ],
  1692|         'MID' => [
  1693|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1694|             'functionCall' => [TextData\Extract::class, 'mid'],
  1695|             'argumentCount' => '3',
  1696|         ],
  1697|         'MIDB' => [
  1698|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1699|             'functionCall' => [TextData\Extract::class, 'mid'],
  1700|             'argumentCount' => '3',
  1701|         ],
  1702|         'MIN' => [
  1703|             'category' => Category::CATEGORY_STATISTICAL,
  1704|             'functionCall' => [Statistical\Minimum::class, 'min'],
  1705|             'argumentCount' => '1+',
  1706|         ],
  1707|         'MINA' => [
  1708|             'category' => Category::CATEGORY_STATISTICAL,
  1709|             'functionCall' => [Statistical\Minimum::class, 'minA'],
  1710|             'argumentCount' => '1+',
  1711|         ],
  1712|         'MINIFS' => [
  1713|             'category' => Category::CATEGORY_STATISTICAL,
  1714|             'functionCall' => [Statistical\Conditional::class, 'MINIFS'],
  1715|             'argumentCount' => '3+',
  1716|         ],
  1717|         'MINUTE' => [
  1718|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1719|             'functionCall' => [DateTimeExcel\TimeParts::class, 'minute'],
  1720|             'argumentCount' => '1',
  1721|         ],
  1722|         'MINVERSE' => [
  1723|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1724|             'functionCall' => [MathTrig\MatrixFunctions::class, 'inverse'],
  1725|             'argumentCount' => '1',
  1726|         ],
  1727|         'MIRR' => [
  1728|             'category' => Category::CATEGORY_FINANCIAL,
  1729|             'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'modifiedRate'],
  1730|             'argumentCount' => '3',
  1731|         ],
  1732|         'MMULT' => [
  1733|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1734|             'functionCall' => [MathTrig\MatrixFunctions::class, 'multiply'],
  1735|             'argumentCount' => '2',
  1736|         ],
  1737|         'MOD' => [
  1738|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1739|             'functionCall' => [MathTrig\Operations::class, 'mod'],
  1740|             'argumentCount' => '2',
  1741|         ],
  1742|         'MODE' => [
  1743|             'category' => Category::CATEGORY_STATISTICAL,
  1744|             'functionCall' => [Statistical\Averages::class, 'mode'],
  1745|             'argumentCount' => '1+',
  1746|         ],
  1747|         'MODE.MULT' => [
  1748|             'category' => Category::CATEGORY_STATISTICAL,
  1749|             'functionCall' => [Functions::class, 'DUMMY'],
  1750|             'argumentCount' => '1+',
  1751|         ],
  1752|         'MODE.SNGL' => [
  1753|             'category' => Category::CATEGORY_STATISTICAL,
  1754|             'functionCall' => [Statistical\Averages::class, 'mode'],
  1755|             'argumentCount' => '1+',
  1756|         ],
  1757|         'MONTH' => [
  1758|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1759|             'functionCall' => [DateTimeExcel\DateParts::class, 'month'],
  1760|             'argumentCount' => '1',
  1761|         ],
  1762|         'MROUND' => [
  1763|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1764|             'functionCall' => [MathTrig\Round::class, 'multiple'],
  1765|             'argumentCount' => '2',
  1766|         ],
  1767|         'MULTINOMIAL' => [
  1768|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1769|             'functionCall' => [MathTrig\Factorial::class, 'multinomial'],
  1770|             'argumentCount' => '1+',
  1771|         ],
  1772|         'MUNIT' => [
  1773|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1774|             'functionCall' => [MathTrig\MatrixFunctions::class, 'identity'],
  1775|             'argumentCount' => '1',
  1776|         ],
  1777|         'N' => [
  1778|             'category' => Category::CATEGORY_INFORMATION,
  1779|             'functionCall' => [Information\Value::class, 'asNumber'],
  1780|             'argumentCount' => '1',
  1781|         ],
  1782|         'NA' => [
  1783|             'category' => Category::CATEGORY_INFORMATION,
  1784|             'functionCall' => [ExcelError::class, 'NA'],
  1785|             'argumentCount' => '0',
  1786|         ],
  1787|         'NEGBINOMDIST' => [
  1788|             'category' => Category::CATEGORY_STATISTICAL,
  1789|             'functionCall' => [Statistical\Distributions\Binomial::class, 'negative'],
  1790|             'argumentCount' => '3',
  1791|         ],
  1792|         'NEGBINOM.DIST' => [
  1793|             'category' => Category::CATEGORY_STATISTICAL,
  1794|             'functionCall' => [Functions::class, 'DUMMY'],
  1795|             'argumentCount' => '4',
  1796|         ],
  1797|         'NETWORKDAYS' => [
  1798|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1799|             'functionCall' => [DateTimeExcel\NetworkDays::class, 'count'],
  1800|             'argumentCount' => '2-3',
  1801|         ],
  1802|         'NETWORKDAYS.INTL' => [
  1803|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1804|             'functionCall' => [Functions::class, 'DUMMY'],
  1805|             'argumentCount' => '2-4',
  1806|         ],
  1807|         'NOMINAL' => [
  1808|             'category' => Category::CATEGORY_FINANCIAL,
  1809|             'functionCall' => [Financial\InterestRate::class, 'nominal'],
  1810|             'argumentCount' => '2',
  1811|         ],
  1812|         'NORMDIST' => [
  1813|             'category' => Category::CATEGORY_STATISTICAL,
  1814|             'functionCall' => [Statistical\Distributions\Normal::class, 'distribution'],
  1815|             'argumentCount' => '4',
  1816|         ],
  1817|         'NORM.DIST' => [
  1818|             'category' => Category::CATEGORY_STATISTICAL,
  1819|             'functionCall' => [Statistical\Distributions\Normal::class, 'distribution'],
  1820|             'argumentCount' => '4',
  1821|         ],
  1822|         'NORMINV' => [
  1823|             'category' => Category::CATEGORY_STATISTICAL,
  1824|             'functionCall' => [Statistical\Distributions\Normal::class, 'inverse'],
  1825|             'argumentCount' => '3',
  1826|         ],
  1827|         'NORM.INV' => [
  1828|             'category' => Category::CATEGORY_STATISTICAL,
  1829|             'functionCall' => [Statistical\Distributions\Normal::class, 'inverse'],
  1830|             'argumentCount' => '3',
  1831|         ],
  1832|         'NORMSDIST' => [
  1833|             'category' => Category::CATEGORY_STATISTICAL,
  1834|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'cumulative'],
  1835|             'argumentCount' => '1',
  1836|         ],
  1837|         'NORM.S.DIST' => [
  1838|             'category' => Category::CATEGORY_STATISTICAL,
  1839|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'distribution'],
  1840|             'argumentCount' => '1,2',
  1841|         ],
  1842|         'NORMSINV' => [
  1843|             'category' => Category::CATEGORY_STATISTICAL,
  1844|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'inverse'],
  1845|             'argumentCount' => '1',
  1846|         ],
  1847|         'NORM.S.INV' => [
  1848|             'category' => Category::CATEGORY_STATISTICAL,
  1849|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'inverse'],
  1850|             'argumentCount' => '1',
  1851|         ],
  1852|         'NOT' => [
  1853|             'category' => Category::CATEGORY_LOGICAL,
  1854|             'functionCall' => [Logical\Operations::class, 'NOT'],
  1855|             'argumentCount' => '1',
  1856|         ],
  1857|         'NOW' => [
  1858|             'category' => Category::CATEGORY_DATE_AND_TIME,
  1859|             'functionCall' => [DateTimeExcel\Current::class, 'now'],
  1860|             'argumentCount' => '0',
  1861|         ],
  1862|         'NPER' => [
  1863|             'category' => Category::CATEGORY_FINANCIAL,
  1864|             'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'periods'],
  1865|             'argumentCount' => '3-5',
  1866|         ],
  1867|         'NPV' => [
  1868|             'category' => Category::CATEGORY_FINANCIAL,
  1869|             'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'presentValue'],
  1870|             'argumentCount' => '2+',
  1871|         ],
  1872|         'NUMBERSTRING' => [
  1873|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1874|             'functionCall' => [Functions::class, 'DUMMY'],
  1875|             'argumentCount' => '?',
  1876|         ],
  1877|         'NUMBERVALUE' => [
  1878|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1879|             'functionCall' => [TextData\Format::class, 'NUMBERVALUE'],
  1880|             'argumentCount' => '1+',
  1881|         ],
  1882|         'OCT2BIN' => [
  1883|             'category' => Category::CATEGORY_ENGINEERING,
  1884|             'functionCall' => [Engineering\ConvertOctal::class, 'toBinary'],
  1885|             'argumentCount' => '1,2',
  1886|         ],
  1887|         'OCT2DEC' => [
  1888|             'category' => Category::CATEGORY_ENGINEERING,
  1889|             'functionCall' => [Engineering\ConvertOctal::class, 'toDecimal'],
  1890|             'argumentCount' => '1',
  1891|         ],
  1892|         'OCT2HEX' => [
  1893|             'category' => Category::CATEGORY_ENGINEERING,
  1894|             'functionCall' => [Engineering\ConvertOctal::class, 'toHex'],
  1895|             'argumentCount' => '1,2',
  1896|         ],
  1897|         'ODD' => [
  1898|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1899|             'functionCall' => [MathTrig\Round::class, 'odd'],
  1900|             'argumentCount' => '1',
  1901|         ],
  1902|         'ODDFPRICE' => [
  1903|             'category' => Category::CATEGORY_FINANCIAL,
  1904|             'functionCall' => [Functions::class, 'DUMMY'],
  1905|             'argumentCount' => '8,9',
  1906|         ],
  1907|         'ODDFYIELD' => [
  1908|             'category' => Category::CATEGORY_FINANCIAL,
  1909|             'functionCall' => [Functions::class, 'DUMMY'],
  1910|             'argumentCount' => '8,9',
  1911|         ],
  1912|         'ODDLPRICE' => [
  1913|             'category' => Category::CATEGORY_FINANCIAL,
  1914|             'functionCall' => [Functions::class, 'DUMMY'],
  1915|             'argumentCount' => '7,8',
  1916|         ],
  1917|         'ODDLYIELD' => [
  1918|             'category' => Category::CATEGORY_FINANCIAL,
  1919|             'functionCall' => [Functions::class, 'DUMMY'],
  1920|             'argumentCount' => '7,8',
  1921|         ],
  1922|         'OFFSET' => [
  1923|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  1924|             'functionCall' => [LookupRef\Offset::class, 'OFFSET'],
  1925|             'argumentCount' => '3-5',
  1926|             'passCellReference' => true,
  1927|             'passByReference' => [true],
  1928|         ],
  1929|         'OR' => [
  1930|             'category' => Category::CATEGORY_LOGICAL,
  1931|             'functionCall' => [Logical\Operations::class, 'logicalOr'],
  1932|             'argumentCount' => '1+',
  1933|         ],
  1934|         'PDURATION' => [
  1935|             'category' => Category::CATEGORY_FINANCIAL,
  1936|             'functionCall' => [Financial\CashFlow\Single::class, 'periods'],
  1937|             'argumentCount' => '3',
  1938|         ],
  1939|         'PEARSON' => [
  1940|             'category' => Category::CATEGORY_STATISTICAL,
  1941|             'functionCall' => [Statistical\Trends::class, 'CORREL'],
  1942|             'argumentCount' => '2',
  1943|         ],
  1944|         'PERCENTILE' => [
  1945|             'category' => Category::CATEGORY_STATISTICAL,
  1946|             'functionCall' => [Statistical\Percentiles::class, 'PERCENTILE'],
  1947|             'argumentCount' => '2',
  1948|         ],
  1949|         'PERCENTILE.EXC' => [
  1950|             'category' => Category::CATEGORY_STATISTICAL,
  1951|             'functionCall' => [Functions::class, 'DUMMY'],
  1952|             'argumentCount' => '2',
  1953|         ],
  1954|         'PERCENTILE.INC' => [
  1955|             'category' => Category::CATEGORY_STATISTICAL,
  1956|             'functionCall' => [Statistical\Percentiles::class, 'PERCENTILE'],
  1957|             'argumentCount' => '2',
  1958|         ],
  1959|         'PERCENTRANK' => [
  1960|             'category' => Category::CATEGORY_STATISTICAL,
  1961|             'functionCall' => [Statistical\Percentiles::class, 'PERCENTRANK'],
  1962|             'argumentCount' => '2,3',
  1963|         ],
  1964|         'PERCENTRANK.EXC' => [
  1965|             'category' => Category::CATEGORY_STATISTICAL,
  1966|             'functionCall' => [Functions::class, 'DUMMY'],
  1967|             'argumentCount' => '2,3',
  1968|         ],
  1969|         'PERCENTRANK.INC' => [
  1970|             'category' => Category::CATEGORY_STATISTICAL,
  1971|             'functionCall' => [Statistical\Percentiles::class, 'PERCENTRANK'],
  1972|             'argumentCount' => '2,3',
  1973|         ],
  1974|         'PERMUT' => [
  1975|             'category' => Category::CATEGORY_STATISTICAL,
  1976|             'functionCall' => [Statistical\Permutations::class, 'PERMUT'],
  1977|             'argumentCount' => '2',
  1978|         ],
  1979|         'PERMUTATIONA' => [
  1980|             'category' => Category::CATEGORY_STATISTICAL,
  1981|             'functionCall' => [Statistical\Permutations::class, 'PERMUTATIONA'],
  1982|             'argumentCount' => '2',
  1983|         ],
  1984|         'PHONETIC' => [
  1985|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  1986|             'functionCall' => [Functions::class, 'DUMMY'],
  1987|             'argumentCount' => '1',
  1988|         ],
  1989|         'PHI' => [
  1990|             'category' => Category::CATEGORY_STATISTICAL,
  1991|             'functionCall' => [Functions::class, 'DUMMY'],
  1992|             'argumentCount' => '1',
  1993|         ],
  1994|         'PI' => [
  1995|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  1996|             'functionCall' => 'pi',
  1997|             'argumentCount' => '0',
  1998|         ],
  1999|         'PMT' => [
  2000|             'category' => Category::CATEGORY_FINANCIAL,
  2001|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Payments::class, 'annuity'],
  2002|             'argumentCount' => '3-5',
  2003|         ],
  2004|         'POISSON' => [
  2005|             'category' => Category::CATEGORY_STATISTICAL,
  2006|             'functionCall' => [Statistical\Distributions\Poisson::class, 'distribution'],
  2007|             'argumentCount' => '3',
  2008|         ],
  2009|         'POISSON.DIST' => [
  2010|             'category' => Category::CATEGORY_STATISTICAL,
  2011|             'functionCall' => [Statistical\Distributions\Poisson::class, 'distribution'],
  2012|             'argumentCount' => '3',
  2013|         ],
  2014|         'POWER' => [
  2015|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2016|             'functionCall' => [MathTrig\Operations::class, 'power'],
  2017|             'argumentCount' => '2',
  2018|         ],
  2019|         'PPMT' => [
  2020|             'category' => Category::CATEGORY_FINANCIAL,
  2021|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Payments::class, 'interestPayment'],
  2022|             'argumentCount' => '4-6',
  2023|         ],
  2024|         'PRICE' => [
  2025|             'category' => Category::CATEGORY_FINANCIAL,
  2026|             'functionCall' => [Financial\Securities\Price::class, 'price'],
  2027|             'argumentCount' => '6,7',
  2028|         ],
  2029|         'PRICEDISC' => [
  2030|             'category' => Category::CATEGORY_FINANCIAL,
  2031|             'functionCall' => [Financial\Securities\Price::class, 'priceDiscounted'],
  2032|             'argumentCount' => '4,5',
  2033|         ],
  2034|         'PRICEMAT' => [
  2035|             'category' => Category::CATEGORY_FINANCIAL,
  2036|             'functionCall' => [Financial\Securities\Price::class, 'priceAtMaturity'],
  2037|             'argumentCount' => '5,6',
  2038|         ],
  2039|         'PROB' => [
  2040|             'category' => Category::CATEGORY_STATISTICAL,
  2041|             'functionCall' => [Functions::class, 'DUMMY'],
  2042|             'argumentCount' => '3,4',
  2043|         ],
  2044|         'PRODUCT' => [
  2045|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2046|             'functionCall' => [MathTrig\Operations::class, 'product'],
  2047|             'argumentCount' => '1+',
  2048|         ],
  2049|         'PROPER' => [
  2050|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2051|             'functionCall' => [TextData\CaseConvert::class, 'proper'],
  2052|             'argumentCount' => '1',
  2053|         ],
  2054|         'PV' => [
  2055|             'category' => Category::CATEGORY_FINANCIAL,
  2056|             'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'presentValue'],
  2057|             'argumentCount' => '3-5',
  2058|         ],
  2059|         'QUARTILE' => [
  2060|             'category' => Category::CATEGORY_STATISTICAL,
  2061|             'functionCall' => [Statistical\Percentiles::class, 'QUARTILE'],
  2062|             'argumentCount' => '2',
  2063|         ],
  2064|         'QUARTILE.EXC' => [
  2065|             'category' => Category::CATEGORY_STATISTICAL,
  2066|             'functionCall' => [Functions::class, 'DUMMY'],
  2067|             'argumentCount' => '2',
  2068|         ],
  2069|         'QUARTILE.INC' => [
  2070|             'category' => Category::CATEGORY_STATISTICAL,
  2071|             'functionCall' => [Statistical\Percentiles::class, 'QUARTILE'],
  2072|             'argumentCount' => '2',
  2073|         ],
  2074|         'QUOTIENT' => [
  2075|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2076|             'functionCall' => [MathTrig\Operations::class, 'quotient'],
  2077|             'argumentCount' => '2',
  2078|         ],
  2079|         'RADIANS' => [
  2080|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2081|             'functionCall' => [MathTrig\Angle::class, 'toRadians'],
  2082|             'argumentCount' => '1',
  2083|         ],
  2084|         'RAND' => [
  2085|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2086|             'functionCall' => [MathTrig\Random::class, 'rand'],
  2087|             'argumentCount' => '0',
  2088|         ],
  2089|         'RANDARRAY' => [
  2090|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2091|             'functionCall' => [MathTrig\Random::class, 'randArray'],
  2092|             'argumentCount' => '0-5',
  2093|         ],
  2094|         'RANDBETWEEN' => [
  2095|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2096|             'functionCall' => [MathTrig\Random::class, 'randBetween'],
  2097|             'argumentCount' => '2',
  2098|         ],
  2099|         'RANK' => [
  2100|             'category' => Category::CATEGORY_STATISTICAL,
  2101|             'functionCall' => [Statistical\Percentiles::class, 'RANK'],
  2102|             'argumentCount' => '2,3',
  2103|         ],
  2104|         'RANK.AVG' => [
  2105|             'category' => Category::CATEGORY_STATISTICAL,
  2106|             'functionCall' => [Functions::class, 'DUMMY'],
  2107|             'argumentCount' => '2,3',
  2108|         ],
  2109|         'RANK.EQ' => [
  2110|             'category' => Category::CATEGORY_STATISTICAL,
  2111|             'functionCall' => [Statistical\Percentiles::class, 'RANK'],
  2112|             'argumentCount' => '2,3',
  2113|         ],
  2114|         'RATE' => [
  2115|             'category' => Category::CATEGORY_FINANCIAL,
  2116|             'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'rate'],
  2117|             'argumentCount' => '3-6',
  2118|         ],
  2119|         'RECEIVED' => [
  2120|             'category' => Category::CATEGORY_FINANCIAL,
  2121|             'functionCall' => [Financial\Securities\Price::class, 'received'],
  2122|             'argumentCount' => '4-5',
  2123|         ],
  2124|         'REDUCE' => [
  2125|             'category' => Category::CATEGORY_LOGICAL,
  2126|             'functionCall' => [Functions::class, 'DUMMY'],
  2127|             'argumentCount' => '*',
  2128|         ],
  2129|         'REPLACE' => [
  2130|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2131|             'functionCall' => [TextData\Replace::class, 'replace'],
  2132|             'argumentCount' => '4',
  2133|         ],
  2134|         'REPLACEB' => [
  2135|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2136|             'functionCall' => [TextData\Replace::class, 'replace'],
  2137|             'argumentCount' => '4',
  2138|         ],
  2139|         'REPT' => [
  2140|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2141|             'functionCall' => [TextData\Concatenate::class, 'builtinREPT'],
  2142|             'argumentCount' => '2',
  2143|         ],
  2144|         'RIGHT' => [
  2145|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2146|             'functionCall' => [TextData\Extract::class, 'right'],
  2147|             'argumentCount' => '1,2',
  2148|         ],
  2149|         'RIGHTB' => [
  2150|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2151|             'functionCall' => [TextData\Extract::class, 'right'],
  2152|             'argumentCount' => '1,2',
  2153|         ],
  2154|         'ROMAN' => [
  2155|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2156|             'functionCall' => [MathTrig\Roman::class, 'evaluate'],
  2157|             'argumentCount' => '1,2',
  2158|         ],
  2159|         'ROUND' => [
  2160|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2161|             'functionCall' => [MathTrig\Round::class, 'round'],
  2162|             'argumentCount' => '2',
  2163|         ],
  2164|         'ROUNDBAHTDOWN' => [
  2165|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2166|             'functionCall' => [Functions::class, 'DUMMY'],
  2167|             'argumentCount' => '?',
  2168|         ],
  2169|         'ROUNDBAHTUP' => [
  2170|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2171|             'functionCall' => [Functions::class, 'DUMMY'],
  2172|             'argumentCount' => '?',
  2173|         ],
  2174|         'ROUNDDOWN' => [
  2175|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2176|             'functionCall' => [MathTrig\Round::class, 'down'],
  2177|             'argumentCount' => '2',
  2178|         ],
  2179|         'ROUNDUP' => [
  2180|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2181|             'functionCall' => [MathTrig\Round::class, 'up'],
  2182|             'argumentCount' => '2',
  2183|         ],
  2184|         'ROW' => [
  2185|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2186|             'functionCall' => [LookupRef\RowColumnInformation::class, 'ROW'],
  2187|             'argumentCount' => '-1',
  2188|             'passCellReference' => true,
  2189|             'passByReference' => [true],
  2190|         ],
  2191|         'ROWS' => [
  2192|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2193|             'functionCall' => [LookupRef\RowColumnInformation::class, 'ROWS'],
  2194|             'argumentCount' => '1',
  2195|         ],
  2196|         'RRI' => [
  2197|             'category' => Category::CATEGORY_FINANCIAL,
  2198|             'functionCall' => [Financial\CashFlow\Single::class, 'interestRate'],
  2199|             'argumentCount' => '3',
  2200|         ],
  2201|         'RSQ' => [
  2202|             'category' => Category::CATEGORY_STATISTICAL,
  2203|             'functionCall' => [Statistical\Trends::class, 'RSQ'],
  2204|             'argumentCount' => '2',
  2205|         ],
  2206|         'RTD' => [
  2207|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2208|             'functionCall' => [Functions::class, 'DUMMY'],
  2209|             'argumentCount' => '1+',
  2210|         ],
  2211|         'SEARCH' => [
  2212|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2213|             'functionCall' => [TextData\Search::class, 'insensitive'],
  2214|             'argumentCount' => '2,3',
  2215|         ],
  2216|         'SCAN' => [
  2217|             'category' => Category::CATEGORY_LOGICAL,
  2218|             'functionCall' => [Functions::class, 'DUMMY'],
  2219|             'argumentCount' => '*',
  2220|         ],
  2221|         'SEARCHB' => [
  2222|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2223|             'functionCall' => [TextData\Search::class, 'insensitive'],
  2224|             'argumentCount' => '2,3',
  2225|         ],
  2226|         'SEC' => [
  2227|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2228|             'functionCall' => [MathTrig\Trig\Secant::class, 'sec'],
  2229|             'argumentCount' => '1',
  2230|         ],
  2231|         'SECH' => [
  2232|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2233|             'functionCall' => [MathTrig\Trig\Secant::class, 'sech'],
  2234|             'argumentCount' => '1',
  2235|         ],
  2236|         'SECOND' => [
  2237|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2238|             'functionCall' => [DateTimeExcel\TimeParts::class, 'second'],
  2239|             'argumentCount' => '1',
  2240|         ],
  2241|         'SEQUENCE' => [
  2242|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2243|             'functionCall' => [MathTrig\MatrixFunctions::class, 'sequence'],
  2244|             'argumentCount' => '1-4',
  2245|         ],
  2246|         'SERIESSUM' => [
  2247|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2248|             'functionCall' => [MathTrig\SeriesSum::class, 'evaluate'],
  2249|             'argumentCount' => '4',
  2250|         ],
  2251|         'SHEET' => [
  2252|             'category' => Category::CATEGORY_INFORMATION,
  2253|             'functionCall' => [Functions::class, 'DUMMY'],
  2254|             'argumentCount' => '0,1',
  2255|         ],
  2256|         'SHEETS' => [
  2257|             'category' => Category::CATEGORY_INFORMATION,
  2258|             'functionCall' => [Functions::class, 'DUMMY'],
  2259|             'argumentCount' => '0,1',
  2260|         ],
  2261|         'SIGN' => [
  2262|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2263|             'functionCall' => [MathTrig\Sign::class, 'evaluate'],
  2264|             'argumentCount' => '1',
  2265|         ],
  2266|         'SIN' => [
  2267|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2268|             'functionCall' => [MathTrig\Trig\Sine::class, 'sin'],
  2269|             'argumentCount' => '1',
  2270|         ],
  2271|         'SINGLE' => [
  2272|             'category' => Category::CATEGORY_UNCATEGORISED,
  2273|             'functionCall' => [Functions::class, 'DUMMY'],
  2274|             'argumentCount' => '*',
  2275|         ],
  2276|         'SINH' => [
  2277|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2278|             'functionCall' => [MathTrig\Trig\Sine::class, 'sinh'],
  2279|             'argumentCount' => '1',
  2280|         ],
  2281|         'SKEW' => [
  2282|             'category' => Category::CATEGORY_STATISTICAL,
  2283|             'functionCall' => [Statistical\Deviations::class, 'skew'],
  2284|             'argumentCount' => '1+',
  2285|         ],
  2286|         'SKEW.P' => [
  2287|             'category' => Category::CATEGORY_STATISTICAL,
  2288|             'functionCall' => [Functions::class, 'DUMMY'],
  2289|             'argumentCount' => '1+',
  2290|         ],
  2291|         'SLN' => [
  2292|             'category' => Category::CATEGORY_FINANCIAL,
  2293|             'functionCall' => [Financial\Depreciation::class, 'SLN'],
  2294|             'argumentCount' => '3',
  2295|         ],
  2296|         'SLOPE' => [
  2297|             'category' => Category::CATEGORY_STATISTICAL,
  2298|             'functionCall' => [Statistical\Trends::class, 'SLOPE'],
  2299|             'argumentCount' => '2',
  2300|         ],
  2301|         'SMALL' => [
  2302|             'category' => Category::CATEGORY_STATISTICAL,
  2303|             'functionCall' => [Statistical\Size::class, 'small'],
  2304|             'argumentCount' => '2',
  2305|         ],
  2306|         'SORT' => [
  2307|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2308|             'functionCall' => [LookupRef\Sort::class, 'sort'],
  2309|             'argumentCount' => '1-4',
  2310|         ],
  2311|         'SORTBY' => [
  2312|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2313|             'functionCall' => [LookupRef\Sort::class, 'sortBy'],
  2314|             'argumentCount' => '2+',
  2315|         ],
  2316|         'SQRT' => [
  2317|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2318|             'functionCall' => [MathTrig\Sqrt::class, 'sqrt'],
  2319|             'argumentCount' => '1',
  2320|         ],
  2321|         'SQRTPI' => [
  2322|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2323|             'functionCall' => [MathTrig\Sqrt::class, 'pi'],
  2324|             'argumentCount' => '1',
  2325|         ],
  2326|         'STANDARDIZE' => [
  2327|             'category' => Category::CATEGORY_STATISTICAL,
  2328|             'functionCall' => [Statistical\Standardize::class, 'execute'],
  2329|             'argumentCount' => '3',
  2330|         ],
  2331|         'STDEV' => [
  2332|             'category' => Category::CATEGORY_STATISTICAL,
  2333|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEV'],
  2334|             'argumentCount' => '1+',
  2335|         ],
  2336|         'STDEV.S' => [
  2337|             'category' => Category::CATEGORY_STATISTICAL,
  2338|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEV'],
  2339|             'argumentCount' => '1+',
  2340|         ],
  2341|         'STDEV.P' => [
  2342|             'category' => Category::CATEGORY_STATISTICAL,
  2343|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEVP'],
  2344|             'argumentCount' => '1+',
  2345|         ],
  2346|         'STDEVA' => [
  2347|             'category' => Category::CATEGORY_STATISTICAL,
  2348|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEVA'],
  2349|             'argumentCount' => '1+',
  2350|         ],
  2351|         'STDEVP' => [
  2352|             'category' => Category::CATEGORY_STATISTICAL,
  2353|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEVP'],
  2354|             'argumentCount' => '1+',
  2355|         ],
  2356|         'STDEVPA' => [
  2357|             'category' => Category::CATEGORY_STATISTICAL,
  2358|             'functionCall' => [Statistical\StandardDeviations::class, 'STDEVPA'],
  2359|             'argumentCount' => '1+',
  2360|         ],
  2361|         'STEYX' => [
  2362|             'category' => Category::CATEGORY_STATISTICAL,
  2363|             'functionCall' => [Statistical\Trends::class, 'STEYX'],
  2364|             'argumentCount' => '2',
  2365|         ],
  2366|         'SUBSTITUTE' => [
  2367|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2368|             'functionCall' => [TextData\Replace::class, 'substitute'],
  2369|             'argumentCount' => '3,4',
  2370|         ],
  2371|         'SUBTOTAL' => [
  2372|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2373|             'functionCall' => [MathTrig\Subtotal::class, 'evaluate'],
  2374|             'argumentCount' => '2+',
  2375|             'passCellReference' => true,
  2376|         ],
  2377|         'SUM' => [
  2378|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2379|             'functionCall' => [MathTrig\Sum::class, 'sumErroringStrings'],
  2380|             'argumentCount' => '1+',
  2381|         ],
  2382|         'SUMIF' => [
  2383|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2384|             'functionCall' => [Statistical\Conditional::class, 'SUMIF'],
  2385|             'argumentCount' => '2,3',
  2386|         ],
  2387|         'SUMIFS' => [
  2388|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2389|             'functionCall' => [Statistical\Conditional::class, 'SUMIFS'],
  2390|             'argumentCount' => '3+',
  2391|         ],
  2392|         'SUMPRODUCT' => [
  2393|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2394|             'functionCall' => [MathTrig\Sum::class, 'product'],
  2395|             'argumentCount' => '1+',
  2396|         ],
  2397|         'SUMSQ' => [
  2398|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2399|             'functionCall' => [MathTrig\SumSquares::class, 'sumSquare'],
  2400|             'argumentCount' => '1+',
  2401|         ],
  2402|         'SUMX2MY2' => [
  2403|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2404|             'functionCall' => [MathTrig\SumSquares::class, 'sumXSquaredMinusYSquared'],
  2405|             'argumentCount' => '2',
  2406|         ],
  2407|         'SUMX2PY2' => [
  2408|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2409|             'functionCall' => [MathTrig\SumSquares::class, 'sumXSquaredPlusYSquared'],
  2410|             'argumentCount' => '2',
  2411|         ],
  2412|         'SUMXMY2' => [
  2413|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2414|             'functionCall' => [MathTrig\SumSquares::class, 'sumXMinusYSquared'],
  2415|             'argumentCount' => '2',
  2416|         ],
  2417|         'SWITCH' => [
  2418|             'category' => Category::CATEGORY_LOGICAL,
  2419|             'functionCall' => [Logical\Conditional::class, 'statementSwitch'],
  2420|             'argumentCount' => '3+',
  2421|         ],
  2422|         'SYD' => [
  2423|             'category' => Category::CATEGORY_FINANCIAL,
  2424|             'functionCall' => [Financial\Depreciation::class, 'SYD'],
  2425|             'argumentCount' => '4',
  2426|         ],
  2427|         'T' => [
  2428|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2429|             'functionCall' => [TextData\Text::class, 'test'],
  2430|             'argumentCount' => '1',
  2431|         ],
  2432|         'TAKE' => [
  2433|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2434|             'functionCall' => [Functions::class, 'DUMMY'],
  2435|             'argumentCount' => '2-3',
  2436|         ],
  2437|         'TAN' => [
  2438|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2439|             'functionCall' => [MathTrig\Trig\Tangent::class, 'tan'],
  2440|             'argumentCount' => '1',
  2441|         ],
  2442|         'TANH' => [
  2443|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2444|             'functionCall' => [MathTrig\Trig\Tangent::class, 'tanh'],
  2445|             'argumentCount' => '1',
  2446|         ],
  2447|         'TBILLEQ' => [
  2448|             'category' => Category::CATEGORY_FINANCIAL,
  2449|             'functionCall' => [Financial\TreasuryBill::class, 'bondEquivalentYield'],
  2450|             'argumentCount' => '3',
  2451|         ],
  2452|         'TBILLPRICE' => [
  2453|             'category' => Category::CATEGORY_FINANCIAL,
  2454|             'functionCall' => [Financial\TreasuryBill::class, 'price'],
  2455|             'argumentCount' => '3',
  2456|         ],
  2457|         'TBILLYIELD' => [
  2458|             'category' => Category::CATEGORY_FINANCIAL,
  2459|             'functionCall' => [Financial\TreasuryBill::class, 'yield'],
  2460|             'argumentCount' => '3',
  2461|         ],
  2462|         'TDIST' => [
  2463|             'category' => Category::CATEGORY_STATISTICAL,
  2464|             'functionCall' => [Statistical\Distributions\StudentT::class, 'distribution'],
  2465|             'argumentCount' => '3',
  2466|         ],
  2467|         'T.DIST' => [
  2468|             'category' => Category::CATEGORY_STATISTICAL,
  2469|             'functionCall' => [Functions::class, 'DUMMY'],
  2470|             'argumentCount' => '3',
  2471|         ],
  2472|         'T.DIST.2T' => [
  2473|             'category' => Category::CATEGORY_STATISTICAL,
  2474|             'functionCall' => [Functions::class, 'DUMMY'],
  2475|             'argumentCount' => '2',
  2476|         ],
  2477|         'T.DIST.RT' => [
  2478|             'category' => Category::CATEGORY_STATISTICAL,
  2479|             'functionCall' => [Functions::class, 'DUMMY'],
  2480|             'argumentCount' => '2',
  2481|         ],
  2482|         'TEXT' => [
  2483|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2484|             'functionCall' => [TextData\Format::class, 'TEXTFORMAT'],
  2485|             'argumentCount' => '2',
  2486|         ],
  2487|         'TEXTAFTER' => [
  2488|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2489|             'functionCall' => [TextData\Extract::class, 'after'],
  2490|             'argumentCount' => '2-6',
  2491|         ],
  2492|         'TEXTBEFORE' => [
  2493|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2494|             'functionCall' => [TextData\Extract::class, 'before'],
  2495|             'argumentCount' => '2-6',
  2496|         ],
  2497|         'TEXTJOIN' => [
  2498|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2499|             'functionCall' => [TextData\Concatenate::class, 'TEXTJOIN'],
  2500|             'argumentCount' => '3+',
  2501|         ],
  2502|         'TEXTSPLIT' => [
  2503|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2504|             'functionCall' => [TextData\Text::class, 'split'],
  2505|             'argumentCount' => '2-6',
  2506|         ],
  2507|         'THAIDAYOFWEEK' => [
  2508|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2509|             'functionCall' => [Functions::class, 'DUMMY'],
  2510|             'argumentCount' => '?',
  2511|         ],
  2512|         'THAIDIGIT' => [
  2513|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2514|             'functionCall' => [Functions::class, 'DUMMY'],
  2515|             'argumentCount' => '?',
  2516|         ],
  2517|         'THAIMONTHOFYEAR' => [
  2518|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2519|             'functionCall' => [Functions::class, 'DUMMY'],
  2520|             'argumentCount' => '?',
  2521|         ],
  2522|         'THAINUMSOUND' => [
  2523|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2524|             'functionCall' => [Functions::class, 'DUMMY'],
  2525|             'argumentCount' => '?',
  2526|         ],
  2527|         'THAINUMSTRING' => [
  2528|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2529|             'functionCall' => [Functions::class, 'DUMMY'],
  2530|             'argumentCount' => '?',
  2531|         ],
  2532|         'THAISTRINGLENGTH' => [
  2533|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2534|             'functionCall' => [Functions::class, 'DUMMY'],
  2535|             'argumentCount' => '?',
  2536|         ],
  2537|         'THAIYEAR' => [
  2538|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2539|             'functionCall' => [Functions::class, 'DUMMY'],
  2540|             'argumentCount' => '?',
  2541|         ],
  2542|         'TIME' => [
  2543|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2544|             'functionCall' => [DateTimeExcel\Time::class, 'fromHMS'],
  2545|             'argumentCount' => '3',
  2546|         ],
  2547|         'TIMEVALUE' => [
  2548|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2549|             'functionCall' => [DateTimeExcel\TimeValue::class, 'fromString'],
  2550|             'argumentCount' => '1',
  2551|         ],
  2552|         'TINV' => [
  2553|             'category' => Category::CATEGORY_STATISTICAL,
  2554|             'functionCall' => [Statistical\Distributions\StudentT::class, 'inverse'],
  2555|             'argumentCount' => '2',
  2556|         ],
  2557|         'T.INV' => [
  2558|             'category' => Category::CATEGORY_STATISTICAL,
  2559|             'functionCall' => [Statistical\Distributions\StudentT::class, 'inverse'],
  2560|             'argumentCount' => '2',
  2561|         ],
  2562|         'T.INV.2T' => [
  2563|             'category' => Category::CATEGORY_STATISTICAL,
  2564|             'functionCall' => [Functions::class, 'DUMMY'],
  2565|             'argumentCount' => '2',
  2566|         ],
  2567|         'TODAY' => [
  2568|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2569|             'functionCall' => [DateTimeExcel\Current::class, 'today'],
  2570|             'argumentCount' => '0',
  2571|         ],
  2572|         'TOCOL' => [
  2573|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2574|             'functionCall' => [Functions::class, 'DUMMY'],
  2575|             'argumentCount' => '1-3',
  2576|         ],
  2577|         'TOROW' => [
  2578|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2579|             'functionCall' => [Functions::class, 'DUMMY'],
  2580|             'argumentCount' => '1-3',
  2581|         ],
  2582|         'TRANSPOSE' => [
  2583|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2584|             'functionCall' => [LookupRef\Matrix::class, 'transpose'],
  2585|             'argumentCount' => '1',
  2586|         ],
  2587|         'TREND' => [
  2588|             'category' => Category::CATEGORY_STATISTICAL,
  2589|             'functionCall' => [Statistical\Trends::class, 'TREND'],
  2590|             'argumentCount' => '1-4',
  2591|         ],
  2592|         'TRIM' => [
  2593|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2594|             'functionCall' => [TextData\Trim::class, 'spaces'],
  2595|             'argumentCount' => '1',
  2596|         ],
  2597|         'TRIMMEAN' => [
  2598|             'category' => Category::CATEGORY_STATISTICAL,
  2599|             'functionCall' => [Statistical\Averages\Mean::class, 'trim'],
  2600|             'argumentCount' => '2',
  2601|         ],
  2602|         'TRUE' => [
  2603|             'category' => Category::CATEGORY_LOGICAL,
  2604|             'functionCall' => [Logical\Boolean::class, 'TRUE'],
  2605|             'argumentCount' => '0',
  2606|         ],
  2607|         'TRUNC' => [
  2608|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2609|             'functionCall' => [MathTrig\Trunc::class, 'evaluate'],
  2610|             'argumentCount' => '1,2',
  2611|         ],
  2612|         'TTEST' => [
  2613|             'category' => Category::CATEGORY_STATISTICAL,
  2614|             'functionCall' => [Functions::class, 'DUMMY'],
  2615|             'argumentCount' => '4',
  2616|         ],
  2617|         'T.TEST' => [
  2618|             'category' => Category::CATEGORY_STATISTICAL,
  2619|             'functionCall' => [Functions::class, 'DUMMY'],
  2620|             'argumentCount' => '4',
  2621|         ],
  2622|         'TYPE' => [
  2623|             'category' => Category::CATEGORY_INFORMATION,
  2624|             'functionCall' => [Information\Value::class, 'type'],
  2625|             'argumentCount' => '1',
  2626|         ],
  2627|         'UNICHAR' => [
  2628|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2629|             'functionCall' => [TextData\CharacterConvert::class, 'character'],
  2630|             'argumentCount' => '1',
  2631|         ],
  2632|         'UNICODE' => [
  2633|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2634|             'functionCall' => [TextData\CharacterConvert::class, 'code'],
  2635|             'argumentCount' => '1',
  2636|         ],
  2637|         'UNIQUE' => [
  2638|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2639|             'functionCall' => [LookupRef\Unique::class, 'unique'],
  2640|             'argumentCount' => '1+',
  2641|         ],
  2642|         'UPPER' => [
  2643|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2644|             'functionCall' => [TextData\CaseConvert::class, 'upper'],
  2645|             'argumentCount' => '1',
  2646|         ],
  2647|         'USDOLLAR' => [
  2648|             'category' => Category::CATEGORY_FINANCIAL,
  2649|             'functionCall' => [Financial\Dollar::class, 'format'],
  2650|             'argumentCount' => '2',
  2651|         ],
  2652|         'VALUE' => [
  2653|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2654|             'functionCall' => [TextData\Format::class, 'VALUE'],
  2655|             'argumentCount' => '1',
  2656|         ],
  2657|         'VALUETOTEXT' => [
  2658|             'category' => Category::CATEGORY_TEXT_AND_DATA,
  2659|             'functionCall' => [TextData\Format::class, 'valueToText'],
  2660|             'argumentCount' => '1,2',
  2661|         ],
  2662|         'VAR' => [
  2663|             'category' => Category::CATEGORY_STATISTICAL,
  2664|             'functionCall' => [Statistical\Variances::class, 'VAR'],
  2665|             'argumentCount' => '1+',
  2666|         ],
  2667|         'VAR.P' => [
  2668|             'category' => Category::CATEGORY_STATISTICAL,
  2669|             'functionCall' => [Statistical\Variances::class, 'VARP'],
  2670|             'argumentCount' => '1+',
  2671|         ],
  2672|         'VAR.S' => [
  2673|             'category' => Category::CATEGORY_STATISTICAL,
  2674|             'functionCall' => [Statistical\Variances::class, 'VAR'],
  2675|             'argumentCount' => '1+',
  2676|         ],
  2677|         'VARA' => [
  2678|             'category' => Category::CATEGORY_STATISTICAL,
  2679|             'functionCall' => [Statistical\Variances::class, 'VARA'],
  2680|             'argumentCount' => '1+',
  2681|         ],
  2682|         'VARP' => [
  2683|             'category' => Category::CATEGORY_STATISTICAL,
  2684|             'functionCall' => [Statistical\Variances::class, 'VARP'],
  2685|             'argumentCount' => '1+',
  2686|         ],
  2687|         'VARPA' => [
  2688|             'category' => Category::CATEGORY_STATISTICAL,
  2689|             'functionCall' => [Statistical\Variances::class, 'VARPA'],
  2690|             'argumentCount' => '1+',
  2691|         ],
  2692|         'VDB' => [
  2693|             'category' => Category::CATEGORY_FINANCIAL,
  2694|             'functionCall' => [Functions::class, 'DUMMY'],
  2695|             'argumentCount' => '5-7',
  2696|         ],
  2697|         'VLOOKUP' => [
  2698|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2699|             'functionCall' => [LookupRef\VLookup::class, 'lookup'],
  2700|             'argumentCount' => '3,4',
  2701|         ],
  2702|         'VSTACK' => [
  2703|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2704|             'functionCall' => [Functions::class, 'DUMMY'],
  2705|             'argumentCount' => '1+',
  2706|         ],
  2707|         'WEBSERVICE' => [
  2708|             'category' => Category::CATEGORY_WEB,
  2709|             'functionCall' => [Web\Service::class, 'webService'],
  2710|             'argumentCount' => '1',
  2711|         ],
  2712|         'WEEKDAY' => [
  2713|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2714|             'functionCall' => [DateTimeExcel\Week::class, 'day'],
  2715|             'argumentCount' => '1,2',
  2716|         ],
  2717|         'WEEKNUM' => [
  2718|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2719|             'functionCall' => [DateTimeExcel\Week::class, 'number'],
  2720|             'argumentCount' => '1,2',
  2721|         ],
  2722|         'WEIBULL' => [
  2723|             'category' => Category::CATEGORY_STATISTICAL,
  2724|             'functionCall' => [Statistical\Distributions\Weibull::class, 'distribution'],
  2725|             'argumentCount' => '4',
  2726|         ],
  2727|         'WEIBULL.DIST' => [
  2728|             'category' => Category::CATEGORY_STATISTICAL,
  2729|             'functionCall' => [Statistical\Distributions\Weibull::class, 'distribution'],
  2730|             'argumentCount' => '4',
  2731|         ],
  2732|         'WORKDAY' => [
  2733|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2734|             'functionCall' => [DateTimeExcel\WorkDay::class, 'date'],
  2735|             'argumentCount' => '2-3',
  2736|         ],
  2737|         'WORKDAY.INTL' => [
  2738|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2739|             'functionCall' => [Functions::class, 'DUMMY'],
  2740|             'argumentCount' => '2-4',
  2741|         ],
  2742|         'WRAPCOLS' => [
  2743|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2744|             'functionCall' => [Functions::class, 'DUMMY'],
  2745|             'argumentCount' => '2-3',
  2746|         ],
  2747|         'WRAPROWS' => [
  2748|             'category' => Category::CATEGORY_MATH_AND_TRIG,
  2749|             'functionCall' => [Functions::class, 'DUMMY'],
  2750|             'argumentCount' => '2-3',
  2751|         ],
  2752|         'XIRR' => [
  2753|             'category' => Category::CATEGORY_FINANCIAL,
  2754|             'functionCall' => [Financial\CashFlow\Variable\NonPeriodic::class, 'rate'],
  2755|             'argumentCount' => '2,3',
  2756|         ],
  2757|         'XLOOKUP' => [
  2758|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2759|             'functionCall' => [Functions::class, 'DUMMY'],
  2760|             'argumentCount' => '3-6',
  2761|         ],
  2762|         'XNPV' => [
  2763|             'category' => Category::CATEGORY_FINANCIAL,
  2764|             'functionCall' => [Financial\CashFlow\Variable\NonPeriodic::class, 'presentValue'],
  2765|             'argumentCount' => '3',
  2766|         ],
  2767|         'XMATCH' => [
  2768|             'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
  2769|             'functionCall' => [Functions::class, 'DUMMY'],
  2770|             'argumentCount' => '2,3',
  2771|         ],
  2772|         'XOR' => [
  2773|             'category' => Category::CATEGORY_LOGICAL,
  2774|             'functionCall' => [Logical\Operations::class, 'logicalXor'],
  2775|             'argumentCount' => '1+',
  2776|         ],
  2777|         'YEAR' => [
  2778|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2779|             'functionCall' => [DateTimeExcel\DateParts::class, 'year'],
  2780|             'argumentCount' => '1',
  2781|         ],
  2782|         'YEARFRAC' => [
  2783|             'category' => Category::CATEGORY_DATE_AND_TIME,
  2784|             'functionCall' => [DateTimeExcel\YearFrac::class, 'fraction'],
  2785|             'argumentCount' => '2,3',
  2786|         ],
  2787|         'YIELD' => [
  2788|             'category' => Category::CATEGORY_FINANCIAL,
  2789|             'functionCall' => [Functions::class, 'DUMMY'],
  2790|             'argumentCount' => '6,7',
  2791|         ],
  2792|         'YIELDDISC' => [
  2793|             'category' => Category::CATEGORY_FINANCIAL,
  2794|             'functionCall' => [Financial\Securities\Yields::class, 'yieldDiscounted'],
  2795|             'argumentCount' => '4,5',
  2796|         ],
  2797|         'YIELDMAT' => [
  2798|             'category' => Category::CATEGORY_FINANCIAL,
  2799|             'functionCall' => [Financial\Securities\Yields::class, 'yieldAtMaturity'],
  2800|             'argumentCount' => '5,6',
  2801|         ],
  2802|         'ZTEST' => [
  2803|             'category' => Category::CATEGORY_STATISTICAL,
  2804|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'zTest'],
  2805|             'argumentCount' => '2-3',
  2806|         ],
  2807|         'Z.TEST' => [
  2808|             'category' => Category::CATEGORY_STATISTICAL,
  2809|             'functionCall' => [Statistical\Distributions\StandardNormal::class, 'zTest'],
  2810|             'argumentCount' => '2-3',
  2811|         ],
  2812|     ];
  2813|     /**
  2814|      *    Internal functions used for special control purposes.
  2815|      */
  2816|     private static array $controlFunctions = [
  2817|         'MKMATRIX' => [
  2818|             'argumentCount' => '*',
  2819|             'functionCall' => [Internal\MakeMatrix::class, 'make'],
  2820|         ],
  2821|         'NAME.ERROR' => [
  2822|             'argumentCount' => '*',
  2823|             'functionCall' => [ExcelError::class, 'NAME'],
  2824|         ],
  2825|         'WILDCARDMATCH' => [
  2826|             'argumentCount' => '2',
  2827|             'functionCall' => [Internal\WildcardMatch::class, 'compare'],
  2828|         ],
  2829|     ];
  2830|     public function __construct(?Spreadsheet $spreadsheet = null)
  2831|     {
  2832|         $this->spreadsheet = $spreadsheet;
  2833|         $this->cyclicReferenceStack = new CyclicReferenceStack();
  2834|         $this->debugLog = new Logger($this->cyclicReferenceStack);
  2835|         $this->branchPruner = new BranchPruner($this->branchPruningEnabled);
  2836|         self::$referenceHelper = ReferenceHelper::getInstance();
  2837|     }
  2838|     private static function loadLocales(): void
  2839|     {
  2840|         $localeFileDirectory = __DIR__ . '/locale/';
  2841|         $localeFileNames = glob($localeFileDirectory . '*', GLOB_ONLYDIR) ?: [];
  2842|         foreach ($localeFileNames as $filename) {
  2843|             $filename = substr($filename, strlen($localeFileDirectory));
  2844|             if ($filename != 'en') {
  2845|                 self::$validLocaleLanguages[] = $filename;
  2846|             }
  2847|         }
  2848|     }
  2849|     /**
  2850|      * Get an instance of this class.
  2851|      *
  2852|      * @param ?Spreadsheet $spreadsheet Injected spreadsheet for working with a PhpSpreadsheet Spreadsheet object,
  2853|      *                                    or NULL to create a standalone calculation engine
  2854|      */
  2855|     public static function getInstance(?Spreadsheet $spreadsheet = null): self
  2856|     {
  2857|         if ($spreadsheet !== null) {
  2858|             $instance = $spreadsheet->getCalculationEngine();
  2859|             if (isset($instance)) {
  2860|                 return $instance;
  2861|             }
  2862|         }
  2863|         if (!self::$instance) {
  2864|             self::$instance = new self();
  2865|         }
  2866|         return self::$instance;
  2867|     }
  2868|     /**
  2869|      * Flush the calculation cache for any existing instance of this class
  2870|      *        but only if a Calculation instance exists.
  2871|      */
  2872|     public function flushInstance(): void
  2873|     {
  2874|         $this->clearCalculationCache();
  2875|         $this->branchPruner->clearBranchStore();
  2876|     }
  2877|     /**
  2878|      * Get the Logger for this calculation engine instance.
  2879|      */
  2880|     public function getDebugLog(): Logger
  2881|     {
  2882|         return $this->debugLog;
  2883|     }
  2884|     /**
  2885|      * __clone implementation. Cloning should not be allowed in a Singleton!
  2886|      */
  2887|     final public function __clone()
  2888|     {
  2889|         throw new Exception('Cloning the calculation engine is not allowed!');
  2890|     }
  2891|     /**
  2892|      * Return the locale-specific translation of TRUE.
  2893|      *
  2894|      * @return string locale-specific translation of TRUE
  2895|      */
  2896|     public static function getTRUE(): string
  2897|     {
  2898|         return self::$localeBoolean['TRUE'];
  2899|     }
  2900|     /**
  2901|      * Return the locale-specific translation of FALSE.
  2902|      *
  2903|      * @return string locale-specific translation of FALSE
  2904|      */
  2905|     public static function getFALSE(): string
  2906|     {
  2907|         return self::$localeBoolean['FALSE'];
  2908|     }
  2909|     /**
  2910|      * Set the Array Return Type (Array or Value of first element in the array).
  2911|      *
  2912|      * @param string $returnType Array return type
  2913|      *
  2914|      * @return bool Success or failure
  2915|      */
  2916|     public static function setArrayReturnType(string $returnType): bool
  2917|     {
  2918|         if (
  2919|             ($returnType == self::RETURN_ARRAY_AS_VALUE)
  2920|             || ($returnType == self::RETURN_ARRAY_AS_ERROR)
  2921|             || ($returnType == self::RETURN_ARRAY_AS_ARRAY)
  2922|         ) {
  2923|             self::$returnArrayAsType = $returnType;
  2924|             return true;
  2925|         }
  2926|         return false;
  2927|     }
  2928|     /**
  2929|      * Return the Array Return Type (Array or Value of first element in the array).
  2930|      *
  2931|      * @return string $returnType Array return type
  2932|      */
  2933|     public static function getArrayReturnType(): string
  2934|     {
  2935|         return self::$returnArrayAsType;
  2936|     }
  2937|     /**
  2938|      * Is calculation caching enabled?
  2939|      */
  2940|     public function getCalculationCacheEnabled(): bool
  2941|     {
  2942|         return $this->calculationCacheEnabled;
  2943|     }
  2944|     /**
  2945|      * Enable/disable calculation cache.
  2946|      */
  2947|     public function setCalculationCacheEnabled(bool $calculationCacheEnabled): void
  2948|     {
  2949|         $this->calculationCacheEnabled = $calculationCacheEnabled;
  2950|         $this->clearCalculationCache();
  2951|     }
  2952|     /**
  2953|      * Enable calculation cache.
  2954|      */
  2955|     public function enableCalculationCache(): void
  2956|     {
  2957|         $this->setCalculationCacheEnabled(true);
  2958|     }
  2959|     /**
  2960|      * Disable calculation cache.
  2961|      */
  2962|     public function disableCalculationCache(): void
  2963|     {
  2964|         $this->setCalculationCacheEnabled(false);
  2965|     }
  2966|     /**
  2967|      * Clear calculation cache.
  2968|      */
  2969|     public function clearCalculationCache(): void
  2970|     {
  2971|         $this->calculationCache = [];
  2972|     }
  2973|     /**
  2974|      * Clear calculation cache for a specified worksheet.
  2975|      */
  2976|     public function clearCalculationCacheForWorksheet(string $worksheetName): void
  2977|     {
  2978|         if (isset($this->calculationCache[$worksheetName])) {
  2979|             unset($this->calculationCache[$worksheetName]);
  2980|         }
  2981|     }
  2982|     /**
  2983|      * Rename calculation cache for a specified worksheet.
  2984|      */
  2985|     public function renameCalculationCacheForWorksheet(string $fromWorksheetName, string $toWorksheetName): void
  2986|     {
  2987|         if (isset($this->calculationCache[$fromWorksheetName])) {
  2988|             $this->calculationCache[$toWorksheetName] = &$this->calculationCache[$fromWorksheetName];
  2989|             unset($this->calculationCache[$fromWorksheetName]);
  2990|         }
  2991|     }
  2992|     /**
  2993|      * Enable/disable calculation cache.
  2994|      */
  2995|     public function setBranchPruningEnabled(mixed $enabled): void
  2996|     {
  2997|         $this->branchPruningEnabled = $enabled;
  2998|         $this->branchPruner = new BranchPruner($this->branchPruningEnabled);
  2999|     }
  3000|     public function enableBranchPruning(): void
  3001|     {
  3002|         $this->setBranchPruningEnabled(true);
  3003|     }
  3004|     public function disableBranchPruning(): void
  3005|     {
  3006|         $this->setBranchPruningEnabled(false);
  3007|     }
  3008|     /**
  3009|      * Get the currently defined locale code.
  3010|      */
  3011|     public function getLocale(): string
  3012|     {
  3013|         return self::$localeLanguage;
  3014|     }
  3015|     private function getLocaleFile(string $localeDir, string $locale, string $language, string $file): string
  3016|     {
  3017|         $localeFileName = $localeDir . str_replace('_', DIRECTORY_SEPARATOR, $locale)
  3018|             . DIRECTORY_SEPARATOR . $file;
  3019|         if (!file_exists($localeFileName)) {
  3020|             $localeFileName = $localeDir . $language . DIRECTORY_SEPARATOR . $file;
  3021|             if (!file_exists($localeFileName)) {
  3022|                 throw new Exception('Locale file not found');
  3023|             }
  3024|         }
  3025|         return $localeFileName;
  3026|     }
  3027|     /**
  3028|      * Set the locale code.
  3029|      *
  3030|      * @param string $locale The locale to use for formula translation, eg: 'en_us'
  3031|      */
  3032|     public function setLocale(string $locale): bool
  3033|     {
  3034|         $language = $locale = strtolower($locale);
  3035|         if (str_contains($locale, '_')) {
  3036|             [$language] = explode('_', $locale);
  3037|         }
  3038|         if (count(self::$validLocaleLanguages) == 1) {
  3039|             self::loadLocales();
  3040|         }
  3041|         if (in_array($language, self::$validLocaleLanguages, true)) {
  3042|             self::$localeFunctions = [];
  3043|             self::$localeArgumentSeparator = ',';
  3044|             self::$localeBoolean = ['TRUE' => 'TRUE', 'FALSE' => 'FALSE', 'NULL' => 'NULL'];
  3045|             if ($locale !== 'en_us') {
  3046|                 $localeDir = implode(DIRECTORY_SEPARATOR, [__DIR__, 'locale', null]);
  3047|                 try {
  3048|                     $functionNamesFile = $this->getLocaleFile($localeDir, $locale, $language, 'functions');
  3049|                 } catch (Exception $e) {
  3050|                     return false;
  3051|                 }
  3052|                 $localeFunctions = file($functionNamesFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
  3053|                 foreach ($localeFunctions as $localeFunction) {
  3054|                     [$localeFunction] = explode('##', $localeFunction); //    Strip out comments
  3055|                     if (str_contains($localeFunction, '=')) {
  3056|                         [$fName, $lfName] = array_map('trim', explode('=', $localeFunction));
  3057|                         if ((str_starts_with($fName, '*') || isset(self::$phpSpreadsheetFunctions[$fName])) && ($lfName != '') && ($fName != $lfName)) {
  3058|                             self::$localeFunctions[$fName] = $lfName;
  3059|                         }
  3060|                     }
  3061|                 }
  3062|                 if (isset(self::$localeFunctions['TRUE'])) {
  3063|                     self::$localeBoolean['TRUE'] = self::$localeFunctions['TRUE'];
  3064|                 }
  3065|                 if (isset(self::$localeFunctions['FALSE'])) {
  3066|                     self::$localeBoolean['FALSE'] = self::$localeFunctions['FALSE'];
  3067|                 }
  3068|                 try {
  3069|                     $configFile = $this->getLocaleFile($localeDir, $locale, $language, 'config');
  3070|                 } catch (Exception) {
  3071|                     return false;
  3072|                 }
  3073|                 $localeSettings = file($configFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
  3074|                 foreach ($localeSettings as $localeSetting) {
  3075|                     [$localeSetting] = explode('##', $localeSetting); //    Strip out comments
  3076|                     if (str_contains($localeSetting, '=')) {
  3077|                         [$settingName, $settingValue] = array_map('trim', explode('=', $localeSetting));
  3078|                         $settingName = strtoupper($settingName);
  3079|                         if ($settingValue !== '') {
  3080|                             switch ($settingName) {
  3081|                                 case 'ARGUMENTSEPARATOR':
  3082|                                     self::$localeArgumentSeparator = $settingValue;
  3083|                                     break;
  3084|                             }
  3085|                         }
  3086|                     }
  3087|                 }
  3088|             }
  3089|             self::$functionReplaceFromExcel = self::$functionReplaceToExcel
  3090|             = self::$functionReplaceFromLocale = self::$functionReplaceToLocale = null;
  3091|             self::$localeLanguage = $locale;
  3092|             return true;
  3093|         }
  3094|         return false;
  3095|     }
  3096|     public static function translateSeparator(
  3097|         string $fromSeparator,
  3098|         string $toSeparator,
  3099|         string $formula,
  3100|         int &$inBracesLevel,
  3101|         string $openBrace = self::FORMULA_OPEN_FUNCTION_BRACE,
  3102|         string $closeBrace = self::FORMULA_CLOSE_FUNCTION_BRACE
  3103|     ): string {
  3104|         $strlen = mb_strlen($formula);
  3105|         for ($i = 0; $i < $strlen; ++$i) {
  3106|             $chr = mb_substr($formula, $i, 1);
  3107|             switch ($chr) {
  3108|                 case $openBrace:
  3109|                     ++$inBracesLevel;
  3110|                     break;
  3111|                 case $closeBrace:
  3112|                     --$inBracesLevel;
  3113|                     break;
  3114|                 case $fromSeparator:
  3115|                     if ($inBracesLevel > 0) {
  3116|                         $formula = mb_substr($formula, 0, $i) . $toSeparator . mb_substr($formula, $i + 1);
  3117|                     }
  3118|             }
  3119|         }
  3120|         return $formula;
  3121|     }
  3122|     private static function translateFormulaBlock(
  3123|         array $from,
  3124|         array $to,
  3125|         string $formula,
  3126|         int &$inFunctionBracesLevel,
  3127|         int &$inMatrixBracesLevel,
  3128|         string $fromSeparator,
  3129|         string $toSeparator
  3130|     ): string {
  3131|         $formula = (string) preg_replace($from, $to, $formula);
  3132|         $formula = self::translateSeparator(';', '|', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
  3133|         $formula = self::translateSeparator(',', '!', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
  3134|         $formula = self::translateSeparator($fromSeparator, $toSeparator, $formula, $inFunctionBracesLevel);
  3135|         $formula = self::translateSeparator('|', ';', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
  3136|         $formula = self::translateSeparator('!', ',', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
  3137|         return $formula;
  3138|     }
  3139|     private static function translateFormula(array $from, array $to, string $formula, string $fromSeparator, string $toSeparator): string
  3140|     {
  3141|         if (self::$localeLanguage !== 'en_us') {
  3142|             $inFunctionBracesLevel = 0;
  3143|             $inMatrixBracesLevel = 0;
  3144|             if (str_contains($formula, self::FORMULA_STRING_QUOTE)) {
  3145|                 $temp = explode(self::FORMULA_STRING_QUOTE, $formula);
  3146|                 $notWithinQuotes = false;
  3147|                 foreach ($temp as &$value) {
  3148|                     $notWithinQuotes = $notWithinQuotes === false;
  3149|                     if ($notWithinQuotes === true) {
  3150|                         $value = self::translateFormulaBlock($from, $to, $value, $inFunctionBracesLevel, $inMatrixBracesLevel, $fromSeparator, $toSeparator);
  3151|                     }
  3152|                 }
  3153|                 unset($value);
  3154|                 $formula = implode(self::FORMULA_STRING_QUOTE, $temp);
  3155|             } else {
  3156|                 $formula = self::translateFormulaBlock($from, $to, $formula, $inFunctionBracesLevel, $inMatrixBracesLevel, $fromSeparator, $toSeparator);
  3157|             }
  3158|         }
  3159|         return $formula;
  3160|     }
  3161|     /** @var ?array */
  3162|     private static ?array $functionReplaceFromExcel;
  3163|     /** @var ?array */
  3164|     private static ?array $functionReplaceToLocale;
  3165|     /**
  3166|      * @deprecated 1.30.0 use translateFormulaToLocale() instead
  3167|      *
  3168|      * @codeCoverageIgnore
  3169|      */
  3170|     public function _translateFormulaToLocale(string $formula): string
  3171|     {
  3172|         return $this->translateFormulaToLocale($formula);
  3173|     }
  3174|     public function translateFormulaToLocale(string $formula): string
  3175|     {
  3176|         $formula = preg_replace(self::CALCULATION_REGEXP_STRIP_XLFN_XLWS, '', $formula) ?? '';
  3177|         if (self::$functionReplaceFromExcel === null) {
  3178|             self::$functionReplaceFromExcel = [];
  3179|             foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
  3180|                 self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelFunctionName, '/') . '([\s]*\()/ui';
  3181|             }
  3182|             foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
  3183|                 self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/ui';
  3184|             }
  3185|         }
  3186|         if (self::$functionReplaceToLocale === null) {
  3187|             self::$functionReplaceToLocale = [];
  3188|             foreach (self::$localeFunctions as $localeFunctionName) {
  3189|                 self::$functionReplaceToLocale[] = '$1' . trim($localeFunctionName) . '$2';
  3190|             }
  3191|             foreach (self::$localeBoolean as $localeBoolean) {
  3192|                 self::$functionReplaceToLocale[] = '$1' . trim($localeBoolean) . '$2';
  3193|             }
  3194|         }
  3195|         return self::translateFormula(
  3196|             self::$functionReplaceFromExcel,
  3197|             self::$functionReplaceToLocale,
  3198|             $formula,
  3199|             ',',
  3200|             self::$localeArgumentSeparator
  3201|         );
  3202|     }
  3203|     /** @var ?array */
  3204|     private static ?array $functionReplaceFromLocale;
  3205|     /** @var ?array */
  3206|     private static ?array $functionReplaceToExcel;
  3207|     /**
  3208|      * @deprecated 1.30.0 use translateFormulaToEnglish() instead
  3209|      *
  3210|      * @codeCoverageIgnore
  3211|      */
  3212|     public function _translateFormulaToEnglish(string $formula): string
  3213|     {
  3214|         return $this->translateFormulaToEnglish($formula);
  3215|     }
  3216|     public function translateFormulaToEnglish(string $formula): string
  3217|     {
  3218|         if (self::$functionReplaceFromLocale === null) {
  3219|             self::$functionReplaceFromLocale = [];
  3220|             foreach (self::$localeFunctions as $localeFunctionName) {
  3221|                 self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($localeFunctionName, '/') . '([\s]*\()/ui';
  3222|             }
  3223|             foreach (self::$localeBoolean as $excelBoolean) {
  3224|                 self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/ui';
  3225|             }
  3226|         }
  3227|         if (self::$functionReplaceToExcel === null) {
  3228|             self::$functionReplaceToExcel = [];
  3229|             foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
  3230|                 self::$functionReplaceToExcel[] = '$1' . trim($excelFunctionName) . '$2';
  3231|             }
  3232|             foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
  3233|                 self::$functionReplaceToExcel[] = '$1' . trim($excelBoolean) . '$2';
  3234|             }
  3235|         }
  3236|         return self::translateFormula(self::$functionReplaceFromLocale, self::$functionReplaceToExcel, $formula, self::$localeArgumentSeparator, ',');
  3237|     }
  3238|     public static function localeFunc(string $function): string
  3239|     {
  3240|         if (self::$localeLanguage !== 'en_us') {
  3241|             $functionName = trim($function, '(');
  3242|             if (isset(self::$localeFunctions[$functionName])) {
  3243|                 $brace = ($functionName != $function);
  3244|                 $function = self::$localeFunctions[$functionName];
  3245|                 if ($brace) {
  3246|                     $function .= '(';
  3247|                 }
  3248|             }
  3249|         }
  3250|         return $function;
  3251|     }
  3252|     /**
  3253|      * Wrap string values in quotes.
  3254|      */
  3255|     public static function wrapResult(mixed $value): mixed
  3256|     {
  3257|         if (is_string($value)) {
  3258|             if (preg_match('/^' . self::CALCULATION_REGEXP_ERROR . '$/i', $value, $match)) {
  3259|                 return $value;
  3260|             }
  3261|             return self::FORMULA_STRING_QUOTE . $value . self::FORMULA_STRING_QUOTE;
  3262|         } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
  3263|             return ExcelError::NAN();
  3264|         }
  3265|         return $value;
  3266|     }
  3267|     /**
  3268|      * Remove quotes used as a wrapper to identify string values.
  3269|      */
  3270|     public static function unwrapResult(mixed $value): mixed
  3271|     {
  3272|         if (is_string($value)) {
  3273|             if ((isset($value[0])) && ($value[0] == self::FORMULA_STRING_QUOTE) && (substr($value, -1) == self::FORMULA_STRING_QUOTE)) {
  3274|                 return substr($value, 1, -1);
  3275|             }
  3276|         } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
  3277|             return ExcelError::NAN();
  3278|         }
  3279|         return $value;
  3280|     }
  3281|     /**
  3282|      * Calculate cell value (using formula from a cell ID)
  3283|      * Retained for backward compatibility.
  3284|      *
  3285|      * @param ?Cell $cell Cell to calculate
  3286|      */
  3287|     public function calculate(?Cell $cell = null): mixed
  3288|     {
  3289|         try {
  3290|             return $this->calculateCellValue($cell);
  3291|         } catch (\Exception $e) {
  3292|             throw new Exception($e->getMessage());
  3293|         }
  3294|     }
  3295|     /**
  3296|      * Calculate the value of a cell formula.
  3297|      *
  3298|      * @param ?Cell $cell Cell to calculate
  3299|      * @param bool $resetLog Flag indicating whether the debug log should be reset or not
  3300|      */
  3301|     public function calculateCellValue(?Cell $cell = null, bool $resetLog = true): mixed
  3302|     {
  3303|         if ($cell === null) {
  3304|             return null;
  3305|         }
  3306|         $returnArrayAsType = self::$returnArrayAsType;
  3307|         if ($resetLog) {
  3308|             $this->formulaError = null;
  3309|             $this->debugLog->clearLog();
  3310|             $this->cyclicReferenceStack->clear();
  3311|             $this->cyclicFormulaCounter = 1;
  3312|             self::$returnArrayAsType = self::RETURN_ARRAY_AS_ARRAY;
  3313|         }
  3314|         $this->cellStack[] = [
  3315|             'sheet' => $cell->getWorksheet()->getTitle(),
  3316|             'cell' => $cell->getCoordinate(),
  3317|         ];
  3318|         $cellAddressAttempted = false;
  3319|         $cellAddress = null;
  3320|         try {
  3321|             $result = self::unwrapResult($this->_calculateFormulaValue($cell->getValue(), $cell->getCoordinate(), $cell));
  3322|             if ($this->spreadsheet === null) {
  3323|                 throw new Exception('null spreadsheet in calculateCellValue');
  3324|             }
  3325|             $cellAddressAttempted = true;
  3326|             $cellAddress = array_pop($this->cellStack);
  3327|             if ($cellAddress === null) {
  3328|                 throw new Exception('null cellAddress in calculateCellValue');
  3329|             }
  3330|             $testSheet = $this->spreadsheet->getSheetByName($cellAddress['sheet']);
  3331|             if ($testSheet === null) {
  3332|                 throw new Exception('worksheet not found in calculateCellValue');
  3333|             }
  3334|             $testSheet->getCell($cellAddress['cell']);
  3335|         } catch (\Exception $e) {
  3336|             if (!$cellAddressAttempted) {
  3337|                 $cellAddress = array_pop($this->cellStack);
  3338|             }
  3339|             if ($this->spreadsheet !== null && is_array($cellAddress) && array_key_exists('sheet', $cellAddress)) {
  3340|                 $testSheet = $this->spreadsheet->getSheetByName($cellAddress['sheet']);
  3341|                 if ($testSheet !== null && array_key_exists('cell', $cellAddress)) {
  3342|                     $testSheet->getCell($cellAddress['cell']);
  3343|                 }
  3344|             }
  3345|             throw new Exception($e->getMessage(), $e->getCode(), $e);
  3346|         }
  3347|         if ((is_array($result)) && (self::$returnArrayAsType != self::RETURN_ARRAY_AS_ARRAY)) {
  3348|             self::$returnArrayAsType = $returnArrayAsType;
  3349|             $testResult = Functions::flattenArray($result);
  3350|             if (self::$returnArrayAsType == self::RETURN_ARRAY_AS_ERROR) {
  3351|                 return ExcelError::VALUE();
  3352|             }
  3353|             if (count($testResult) != 1) {
  3354|                 $r = array_keys($result);
  3355|                 $r = array_shift($r);
  3356|                 if (!is_numeric($r)) {
  3357|                     return ExcelError::VALUE();
  3358|                 }
  3359|                 if (is_array($result[$r])) {
  3360|                     $c = array_keys($result[$r]);
  3361|                     $c = array_shift($c);
  3362|                     if (!is_numeric($c)) {
  3363|                         return ExcelError::VALUE();
  3364|                     }
  3365|                 }
  3366|             }
  3367|             $result = array_shift($testResult);
  3368|         }
  3369|         self::$returnArrayAsType = $returnArrayAsType;
  3370|         if ($result === null && $cell->getWorksheet()->getSheetView()->getShowZeros()) {
  3371|             return 0;
  3372|         } elseif ((is_float($result)) && ((is_nan($result)) || (is_infinite($result)))) {
  3373|             return ExcelError::NAN();
  3374|         }
  3375|         return $result;
  3376|     }
  3377|     /**
  3378|      * Validate and parse a formula string.
  3379|      *
  3380|      * @param string $formula Formula to parse
  3381|      */
  3382|     public function parseFormula(string $formula): array|bool
  3383|     {
  3384|         $formula = trim($formula);
  3385|         if ((!isset($formula[0])) || ($formula[0] != '=')) {
  3386|             return [];
  3387|         }
  3388|         $formula = ltrim(substr($formula, 1));
  3389|         if (!isset($formula[0])) {
  3390|             return [];
  3391|         }
  3392|         return $this->internalParseFormula($formula);
  3393|     }
  3394|     /**
  3395|      * Calculate the value of a formula.
  3396|      *
  3397|      * @param string $formula Formula to parse
  3398|      * @param ?string $cellID Address of the cell to calculate
  3399|      * @param ?Cell $cell Cell to calculate
  3400|      */
  3401|     public function calculateFormula(string $formula, ?string $cellID = null, ?Cell $cell = null): mixed
  3402|     {
  3403|         $this->formulaError = null;
  3404|         $this->debugLog->clearLog();
  3405|         $this->cyclicReferenceStack->clear();
  3406|         $resetCache = $this->getCalculationCacheEnabled();
  3407|         if ($this->spreadsheet !== null && $cellID === null && $cell === null) {
  3408|             $cellID = 'A1';
  3409|             $cell = $this->spreadsheet->getActiveSheet()->getCell($cellID);
  3410|         } else {
  3411|             $this->calculationCacheEnabled = false;
  3412|         }
  3413|         try {
  3414|             $result = self::unwrapResult($this->_calculateFormulaValue($formula, $cellID, $cell));
  3415|         } catch (\Exception $e) {
  3416|             throw new Exception($e->getMessage());
  3417|         }
  3418|         if ($this->spreadsheet === null) {
  3419|             $this->calculationCacheEnabled = $resetCache;
  3420|         }
  3421|         return $result;
  3422|     }
  3423|     public function getValueFromCache(string $cellReference, mixed &$cellValue): bool
  3424|     {
  3425|         $this->debugLog->writeDebugLog('Testing cache value for cell %s', $cellReference);
  3426|         if (($this->calculationCacheEnabled) && (isset($this->calculationCache[$cellReference]))) {
  3427|             $this->debugLog->writeDebugLog('Retrieving value for cell %s from cache', $cellReference);
  3428|             $cellValue = $this->calculationCache[$cellReference];
  3429|             return true;
  3430|         }
  3431|         return false;
  3432|     }
  3433|     public function saveValueToCache(string $cellReference, mixed $cellValue): void
  3434|     {
  3435|         if ($this->calculationCacheEnabled) {
  3436|             $this->calculationCache[$cellReference] = $cellValue;
  3437|         }
  3438|     }
  3439|     /**
  3440|      * Parse a cell formula and calculate its value.
  3441|      *
  3442|      * @param string $formula The formula to parse and calculate
  3443|      * @param ?string $cellID The ID (e.g. A3) of the cell that we are calculating
  3444|      * @param ?Cell $cell Cell to calculate
  3445|      * @param bool $ignoreQuotePrefix If set to true, evaluate the formyla even if the referenced cell is quote prefixed
  3446|      */
  3447|     public function _calculateFormulaValue(string $formula, ?string $cellID = null, ?Cell $cell = null, bool $ignoreQuotePrefix = false): mixed
  3448|     {
  3449|         $cellValue = null;
  3450|         if ($cell !== null && $ignoreQuotePrefix === false && $cell->getStyle()->getQuotePrefix() === true) {
  3451|             return self::wrapResult((string) $formula);
  3452|         }
  3453|         if (preg_match('/^=\s*cmd\s*\|/miu', $formula) !== 0) {
  3454|             return self::wrapResult($formula);
  3455|         }
  3456|         $formula = trim($formula);
  3457|         if ($formula[0] != '=') {
  3458|             return self::wrapResult($formula);
  3459|         }
  3460|         $formula = ltrim(substr($formula, 1));
  3461|         if (!isset($formula[0])) {
  3462|             return self::wrapResult($formula);
  3463|         }
  3464|         $pCellParent = ($cell !== null) ? $cell->getWorksheet() : null;
  3465|         $wsTitle = ($pCellParent !== null) ? $pCellParent->getTitle() : "\x00Wrk";
  3466|         $wsCellReference = $wsTitle . '!' . $cellID;
  3467|         if (($cellID !== null) && ($this->getValueFromCache($wsCellReference, $cellValue))) {
  3468|             return $cellValue;
  3469|         }
  3470|         $this->debugLog->writeDebugLog('Evaluating formula for cell %s', $wsCellReference);
  3471|         if (($wsTitle[0] !== "\x00") && ($this->cyclicReferenceStack->onStack($wsCellReference))) {
  3472|             if ($this->cyclicFormulaCount <= 0) {
  3473|                 $this->cyclicFormulaCell = '';
  3474|                 return $this->raiseFormulaError('Cyclic Reference in Formula');
  3475|             } elseif ($this->cyclicFormulaCell === $wsCellReference) {
  3476|                 ++$this->cyclicFormulaCounter;
  3477|                 if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
  3478|                     $this->cyclicFormulaCell = '';
  3479|                     return $cellValue;
  3480|                 }
  3481|             } elseif ($this->cyclicFormulaCell == '') {
  3482|                 if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
  3483|                     return $cellValue;
  3484|                 }
  3485|                 $this->cyclicFormulaCell = $wsCellReference;
  3486|             }
  3487|         }
  3488|         $this->debugLog->writeDebugLog('Formula for cell %s is %s', $wsCellReference, $formula);
  3489|         $this->cyclicReferenceStack->push($wsCellReference);
  3490|         $cellValue = $this->processTokenStack($this->internalParseFormula($formula, $cell), $cellID, $cell);
  3491|         $this->cyclicReferenceStack->pop();
  3492|         if ($cellID !== null) {
  3493|             $this->saveValueToCache($wsCellReference, $cellValue);
  3494|         }
  3495|         return $cellValue;
  3496|     }
  3497|     /**
  3498|      * Ensure that paired matrix operands are both matrices and of the same size.
  3499|      *
  3500|      * @param mixed $operand1 First matrix operand
  3501|      * @param mixed $operand2 Second matrix operand
  3502|      * @param int $resize Flag indicating whether the matrices should be resized to match
  3503|      *                                        and (if so), whether the smaller dimension should grow or the
  3504|      *                                        larger should shrink.
  3505|      *                                            0 = no resize
  3506|      *                                            1 = shrink to fit
  3507|      *                                            2 = extend to fit
  3508|      */
  3509|     private static function checkMatrixOperands(mixed &$operand1, mixed &$operand2, int $resize = 1): array
  3510|     {
  3511|         if (!is_array($operand1)) {
  3512|             [$matrixRows, $matrixColumns] = self::getMatrixDimensions($operand2);
  3513|             $operand1 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand1));
  3514|             $resize = 0;
  3515|         } elseif (!is_array($operand2)) {
  3516|             [$matrixRows, $matrixColumns] = self::getMatrixDimensions($operand1);
  3517|             $operand2 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand2));
  3518|             $resize = 0;
  3519|         }
  3520|         [$matrix1Rows, $matrix1Columns] = self::getMatrixDimensions($operand1);
  3521|         [$matrix2Rows, $matrix2Columns] = self::getMatrixDimensions($operand2);
  3522|         if (($matrix1Rows == $matrix2Columns) && ($matrix2Rows == $matrix1Columns)) {
  3523|             $resize = 1;
  3524|         }
  3525|         if ($resize == 2) {
  3526|             self::resizeMatricesExtend($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
  3527|         } elseif ($resize == 1) {
  3528|             self::resizeMatricesShrink($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
  3529|         }
  3530|         [$matrix1Rows, $matrix1Columns] = self::getMatrixDimensions($operand1);
  3531|         [$matrix2Rows, $matrix2Columns] = self::getMatrixDimensions($operand2);
  3532|         return [$matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns];
  3533|     }
  3534|     /**
  3535|      * Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0.
  3536|      *
  3537|      * @param array $matrix matrix operand
  3538|      *
  3539|      * @return int[] An array comprising the number of rows, and number of columns
  3540|      */
  3541|     public static function getMatrixDimensions(array &$matrix): array
  3542|     {
  3543|         $matrixRows = count($matrix);
  3544|         $matrixColumns = 0;
  3545|         foreach ($matrix as $rowKey => $rowValue) {
  3546|             if (!is_array($rowValue)) {
  3547|                 $matrix[$rowKey] = [$rowValue];
  3548|                 $matrixColumns = max(1, $matrixColumns);
  3549|             } else {
  3550|                 $matrix[$rowKey] = array_values($rowValue);
  3551|                 $matrixColumns = max(count($rowValue), $matrixColumns);
  3552|             }
  3553|         }
  3554|         $matrix = array_values($matrix);
  3555|         return [$matrixRows, $matrixColumns];
  3556|     }
  3557|     /**
  3558|      * Ensure that paired matrix operands are both matrices of the same size.
  3559|      *
  3560|      * @param array $matrix1 First matrix operand
  3561|      * @param array $matrix2 Second matrix operand
  3562|      * @param int $matrix1Rows Row size of first matrix operand
  3563|      * @param int $matrix1Columns Column size of first matrix operand
  3564|      * @param int $matrix2Rows Row size of second matrix operand
  3565|      * @param int $matrix2Columns Column size of second matrix operand
  3566|      */
  3567|     private static function resizeMatricesShrink(array &$matrix1, array &$matrix2, int $matrix1Rows, int $matrix1Columns, int $matrix2Rows, int $matrix2Columns): void
  3568|     {
  3569|         if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
  3570|             if ($matrix2Rows < $matrix1Rows) {
  3571|                 for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {
  3572|                     unset($matrix1[$i]);
  3573|                 }
  3574|             }
  3575|             if ($matrix2Columns < $matrix1Columns) {
  3576|                 for ($i = 0; $i < $matrix1Rows; ++$i) {
  3577|                     for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
  3578|                         unset($matrix1[$i][$j]);
  3579|                     }
  3580|                 }
  3581|             }
  3582|         }
  3583|         if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
  3584|             if ($matrix1Rows < $matrix2Rows) {
  3585|                 for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {
  3586|                     unset($matrix2[$i]);
  3587|                 }
  3588|             }
  3589|             if ($matrix1Columns < $matrix2Columns) {
  3590|                 for ($i = 0; $i < $matrix2Rows; ++$i) {
  3591|                     for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
  3592|                         unset($matrix2[$i][$j]);
  3593|                     }
  3594|                 }
  3595|             }
  3596|         }
  3597|     }
  3598|     /**
  3599|      * Ensure that paired matrix operands are both matrices of the same size.
  3600|      *
  3601|      * @param array $matrix1 First matrix operand
  3602|      * @param array $matrix2 Second matrix operand
  3603|      * @param int $matrix1Rows Row size of first matrix operand
  3604|      * @param int $matrix1Columns Column size of first matrix operand
  3605|      * @param int $matrix2Rows Row size of second matrix operand
  3606|      * @param int $matrix2Columns Column size of second matrix operand
  3607|      */
  3608|     private static function resizeMatricesExtend(array &$matrix1, array &$matrix2, int $matrix1Rows, int $matrix1Columns, int $matrix2Rows, int $matrix2Columns): void
  3609|     {
  3610|         if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
  3611|             if ($matrix2Columns < $matrix1Columns) {
  3612|                 for ($i = 0; $i < $matrix2Rows; ++$i) {
  3613|                     $x = $matrix2[$i][$matrix2Columns - 1];
  3614|                     for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
  3615|                         $matrix2[$i][$j] = $x;
  3616|                     }
  3617|                 }
  3618|             }
  3619|             if ($matrix2Rows < $matrix1Rows) {
  3620|                 $x = $matrix2[$matrix2Rows - 1];
  3621|                 for ($i = 0; $i < $matrix1Rows; ++$i) {
  3622|                     $matrix2[$i] = $x;
  3623|                 }
  3624|             }
  3625|         }
  3626|         if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
  3627|             if ($matrix1Columns < $matrix2Columns) {
  3628|                 for ($i = 0; $i < $matrix1Rows; ++$i) {
  3629|                     $x = $matrix1[$i][$matrix1Columns - 1];
  3630|                     for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
  3631|                         $matrix1[$i][$j] = $x;
  3632|                     }
  3633|                 }
  3634|             }
  3635|             if ($matrix1Rows < $matrix2Rows) {
  3636|                 $x = $matrix1[$matrix1Rows - 1];
  3637|                 for ($i = 0; $i < $matrix2Rows; ++$i) {
  3638|                     $matrix1[$i] = $x;
  3639|                 }
  3640|             }
  3641|         }
  3642|     }
  3643|     /**
  3644|      * Format details of an operand for display in the log (based on operand type).
  3645|      *
  3646|      * @param mixed $value First matrix operand
  3647|      */
  3648|     private function showValue(mixed $value): mixed
  3649|     {
  3650|         if ($this->debugLog->getWriteDebugLog()) {
  3651|             $testArray = Functions::flattenArray($value);
  3652|             if (count($testArray) == 1) {
  3653|                 $value = array_pop($testArray);
  3654|             }
  3655|             if (is_array($value)) {
  3656|                 $returnMatrix = [];
  3657|                 $pad = $rpad = ', ';
  3658|                 foreach ($value as $row) {
  3659|                     if (is_array($row)) {
  3660|                         $returnMatrix[] = implode($pad, array_map([$this, 'showValue'], $row));
  3661|                         $rpad = '; ';
  3662|                     } else {
  3663|                         $returnMatrix[] = $this->showValue($row);
  3664|                     }
  3665|                 }
  3666|                 return '{ ' . implode($rpad, $returnMatrix) . ' }';
  3667|             } elseif (is_string($value) && (trim($value, self::FORMULA_STRING_QUOTE) == $value)) {
  3668|                 return self::FORMULA_STRING_QUOTE . $value . self::FORMULA_STRING_QUOTE;
  3669|             } elseif (is_bool($value)) {
  3670|                 return ($value) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
  3671|             } elseif ($value === null) {
  3672|                 return self::$localeBoolean['NULL'];
  3673|             }
  3674|         }
  3675|         return Functions::flattenSingleValue($value);
  3676|     }
  3677|     /**
  3678|      * Format type and details of an operand for display in the log (based on operand type).
  3679|      *
  3680|      * @param mixed $value First matrix operand
  3681|      */
  3682|     private function showTypeDetails(mixed $value): ?string
  3683|     {
  3684|         if ($this->debugLog->getWriteDebugLog()) {
  3685|             $testArray = Functions::flattenArray($value);
  3686|             if (count($testArray) == 1) {
  3687|                 $value = array_pop($testArray);
  3688|             }
  3689|             if ($value === null) {
  3690|                 return 'a NULL value';
  3691|             } elseif (is_float($value)) {
  3692|                 $typeString = 'a floating point number';
  3693|             } elseif (is_int($value)) {
  3694|                 $typeString = 'an integer number';
  3695|             } elseif (is_bool($value)) {
  3696|                 $typeString = 'a boolean';
  3697|             } elseif (is_array($value)) {
  3698|                 $typeString = 'a matrix';
  3699|             } else {
  3700|                 if ($value == '') {
  3701|                     return 'an empty string';
  3702|                 } elseif ($value[0] == '#') {
  3703|                     return 'a ' . $value . ' error';
  3704|                 }
  3705|                 $typeString = 'a string';
  3706|             }
  3707|             return $typeString . ' with a value of ' . $this->showValue($value);
  3708|         }
  3709|         return null;
  3710|     }
  3711|     /**
  3712|      * @return false|string False indicates an error
  3713|      */
  3714|     private function convertMatrixReferences(string $formula): false|string
  3715|     {
  3716|         static $matrixReplaceFrom = [self::FORMULA_OPEN_MATRIX_BRACE, ';', self::FORMULA_CLOSE_MATRIX_BRACE];
  3717|         static $matrixReplaceTo = ['MKMATRIX(MKMATRIX(', '),MKMATRIX(', '))'];
  3718|         if (str_contains($formula, self::FORMULA_OPEN_MATRIX_BRACE)) {
  3719|             if (str_contains($formula, self::FORMULA_STRING_QUOTE)) {
  3720|                 $temp = explode(self::FORMULA_STRING_QUOTE, $formula);
  3721|                 $openCount = $closeCount = 0;
  3722|                 $notWithinQuotes = false;
  3723|                 foreach ($temp as &$value) {
  3724|                     $notWithinQuotes = $notWithinQuotes === false;
  3725|                     if ($notWithinQuotes === true) {
  3726|                         $openCount += substr_count($value, self::FORMULA_OPEN_MATRIX_BRACE);
  3727|                         $closeCount += substr_count($value, self::FORMULA_CLOSE_MATRIX_BRACE);
  3728|                         $value = str_replace($matrixReplaceFrom, $matrixReplaceTo, $value);
  3729|                     }
  3730|                 }
  3731|                 unset($value);
  3732|                 $formula = implode(self::FORMULA_STRING_QUOTE, $temp);
  3733|             } else {
  3734|                 $openCount = substr_count($formula, self::FORMULA_OPEN_MATRIX_BRACE);
  3735|                 $closeCount = substr_count($formula, self::FORMULA_CLOSE_MATRIX_BRACE);
  3736|                 $formula = str_replace($matrixReplaceFrom, $matrixReplaceTo, $formula);
  3737|             }
  3738|             if ($openCount < $closeCount) {
  3739|                 if ($openCount > 0) {
  3740|                     return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '}'");
  3741|                 }
  3742|                 return $this->raiseFormulaError("Formula Error: Unexpected '}' encountered");
  3743|             } elseif ($openCount > $closeCount) {
  3744|                 if ($closeCount > 0) {
  3745|                     return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '{'");
  3746|                 }
  3747|                 return $this->raiseFormulaError("Formula Error: Unexpected '{' encountered");
  3748|             }
  3749|         }
  3750|         return $formula;
  3751|     }
  3752|     /**
  3753|      *    Binary Operators.
  3754|      *    These operators always work on two values.
  3755|      *    Array key is the operator, the value indicates whether this is a left or right associative operator.
  3756|      */
  3757|     private static array $operatorAssociativity = [
  3758|         '^' => 0, //    Exponentiation
  3759|         '*' => 0, '/' => 0, //    Multiplication and Division
  3760|         '+' => 0, '-' => 0, //    Addition and Subtraction
  3761|         '&' => 0, //    Concatenation
  3762|         '∪' => 0, '∩' => 0, ':' => 0, //    Union, Intersect and Range
  3763|         '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
  3764|     ];
  3765|     /**
  3766|      *    Comparison (Boolean) Operators.
  3767|      *    These operators work on two values, but always return a boolean result.
  3768|      */
  3769|     private static array $comparisonOperators = ['>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true];
  3770|     /**
  3771|      *    Operator Precedence.
  3772|      *    This list includes all valid operators, whether binary (including boolean) or unary (such as %).
  3773|      *    Array key is the operator, the value is its precedence.
  3774|      */
  3775|     private static array $operatorPrecedence = [
  3776|         ':' => 9, //    Range
  3777|         '∩' => 8, //    Intersect
  3778|         '∪' => 7, //    Union
  3779|         '~' => 6, //    Negation
  3780|         '%' => 5, //    Percentage
  3781|         '^' => 4, //    Exponentiation
  3782|         '*' => 3, '/' => 3, //    Multiplication and Division
  3783|         '+' => 2, '-' => 2, //    Addition and Subtraction
  3784|         '&' => 1, //    Concatenation
  3785|         '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
  3786|     ];
  3787|     /**
  3788|      * @return array<int, mixed>|false
  3789|      */
  3790|     private function internalParseFormula(string $formula, ?Cell $cell = null): bool|array
  3791|     {
  3792|         if (($formula = $this->convertMatrixReferences(trim($formula))) === false) {
  3793|             return false;
  3794|         }
  3795|         $pCellParent = ($cell !== null) ? $cell->getWorksheet() : null;
  3796|         $regexpMatchString = '/^((?<string>' . self::CALCULATION_REGEXP_STRING
  3797|                                 . ')|(?<function>' . self::CALCULATION_REGEXP_FUNCTION
  3798|                                 . ')|(?<cellRef>' . self::CALCULATION_REGEXP_CELLREF
  3799|                                 . ')|(?<colRange>' . self::CALCULATION_REGEXP_COLUMN_RANGE
  3800|                                 . ')|(?<rowRange>' . self::CALCULATION_REGEXP_ROW_RANGE
  3801|                                 . ')|(?<number>' . self::CALCULATION_REGEXP_NUMBER
  3802|                                 . ')|(?<openBrace>' . self::CALCULATION_REGEXP_OPENBRACE
  3803|                                 . ')|(?<structuredReference>' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE
  3804|                                 . ')|(?<definedName>' . self::CALCULATION_REGEXP_DEFINEDNAME
  3805|                                 . ')|(?<error>' . self::CALCULATION_REGEXP_ERROR
  3806|                                 . '))/sui';
  3807|         $index = 0;
  3808|         $stack = new Stack($this->branchPruner);
  3809|         $output = [];
  3810|         $expectingOperator = false; //    We use this test in syntax-checking the expression to determine when a
  3811|         $expectingOperand = false; //    We use this test in syntax-checking the expression to determine whether an operand
  3812|         while (true) {
  3813|             $this->branchPruner->initialiseForLoop();
  3814|             $opCharacter = $formula[$index]; //    Get the first character of the value at the current index position
  3815|             if ((isset(self::$comparisonOperators[$opCharacter])) && (strlen($formula) > $index) && isset($formula[$index + 1], self::$comparisonOperators[$formula[$index + 1]])) {
  3816|                 $opCharacter .= $formula[++$index];
  3817|             }
  3818|             $isOperandOrFunction = (bool) preg_match($regexpMatchString, substr($formula, $index), $match);
  3819|             $expectingOperatorCopy = $expectingOperator;
  3820|             if ($opCharacter === '-' && !$expectingOperator) {                //    Is it a negation instead of a minus?
  3821|                 $stack->push('Unary Operator', '~');
  3822|                 ++$index; //        and drop the negation symbol
  3823|             } elseif ($opCharacter === '%' && $expectingOperator) {
  3824|                 $stack->push('Unary Operator', '%');
  3825|                 ++$index;
  3826|             } elseif ($opCharacter === '+' && !$expectingOperator) {            //    Positive (unary plus rather than binary operator plus) can be discarded?
  3827|                 ++$index; //    Drop the redundant plus symbol
  3828|             } elseif ((($opCharacter === '~') || ($opCharacter === '∩') || ($opCharacter === '∪')) && (!$isOperandOrFunction)) {
  3829|                 return $this->raiseFormulaError("Formula Error: Illegal character '~'"); //        on the stack but not in the input expression
  3830|             } elseif ((isset(self::CALCULATION_OPERATORS[$opCharacter]) || $isOperandOrFunction) && $expectingOperator) {    //    Are we putting an operator on the stack?
  3831|                 while (
  3832|                     $stack->count() > 0
  3833|                     && ($o2 = $stack->last())
  3834|                     && isset(self::CALCULATION_OPERATORS[$o2['value']])
  3835|                     && @(self::$operatorAssociativity[$opCharacter] ? self::$operatorPrecedence[$opCharacter] < self::$operatorPrecedence[$o2['value']] : self::$operatorPrecedence[$opCharacter] <= self::$operatorPrecedence[$o2['value']])
  3836|                 ) {
  3837|                     $output[] = $stack->pop(); //    Swap operands and higher precedence operators from the stack to the output
  3838|                 }
  3839|                 $stack->push('Binary Operator', $opCharacter);
  3840|                 ++$index;
  3841|                 $expectingOperator = false;
  3842|             } elseif ($opCharacter === ')' && $expectingOperator) { //    Are we expecting to close a parenthesis?
  3843|                 $expectingOperand = false;
  3844|                 while (($o2 = $stack->pop()) && $o2['value'] !== '(') { //    Pop off the stack back to the last (
  3845|                     $output[] = $o2;
  3846|                 }
  3847|                 $d = $stack->last(2);
  3848|                 $this->branchPruner->decrementDepth();
  3849|                 if (is_array($d) && preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $d['value'], $matches)) {
  3850|                     try {
  3851|                         $this->branchPruner->closingBrace($d['value']);
  3852|                     } catch (Exception $e) {
  3853|                         return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
  3854|                     }
  3855|                     $functionName = $matches[1]; //    Get the function name
  3856|                     $d = $stack->pop();
  3857|                     $argumentCount = $d['value'] ?? 0; //    See how many arguments there were (argument count is the next value stored on the stack)
  3858|                     $output[] = $d; //    Dump the argument count on the output
  3859|                     $output[] = $stack->pop(); //    Pop the function and push onto the output
  3860|                     if (isset(self::$controlFunctions[$functionName])) {
  3861|                         $expectedArgumentCount = self::$controlFunctions[$functionName]['argumentCount'];
  3862|                     } elseif (isset(self::$phpSpreadsheetFunctions[$functionName])) {
  3863|                         $expectedArgumentCount = self::$phpSpreadsheetFunctions[$functionName]['argumentCount'];
  3864|                     } else {    // did we somehow push a non-function on the stack? this should never happen
  3865|                         return $this->raiseFormulaError('Formula Error: Internal error, non-function on stack');
  3866|                     }
  3867|                     $argumentCountError = false;
  3868|                     $expectedArgumentCountString = null;
  3869|                     if (is_numeric($expectedArgumentCount)) {
  3870|                         if ($expectedArgumentCount < 0) {
  3871|                             if ($argumentCount > abs($expectedArgumentCount)) {
  3872|                                 $argumentCountError = true;
  3873|                                 $expectedArgumentCountString = 'no more than ' . abs($expectedArgumentCount);
  3874|                             }
  3875|                         } else {
  3876|                             if ($argumentCount != $expectedArgumentCount) {
  3877|                                 $argumentCountError = true;
  3878|                                 $expectedArgumentCountString = $expectedArgumentCount;
  3879|                             }
  3880|                         }
  3881|                     } elseif ($expectedArgumentCount != '*') {
  3882|                         preg_match('/(\d*)([-+,])(\d*)/', $expectedArgumentCount, $argMatch);
  3883|                         switch ($argMatch[2] ?? '') {
  3884|                             case '+':
  3885|                                 if ($argumentCount < $argMatch[1]) {
  3886|                                     $argumentCountError = true;
  3887|                                     $expectedArgumentCountString = $argMatch[1] . ' or more ';
  3888|                                 }
  3889|                                 break;
  3890|                             case '-':
  3891|                                 if (($argumentCount < $argMatch[1]) || ($argumentCount > $argMatch[3])) {
  3892|                                     $argumentCountError = true;
  3893|                                     $expectedArgumentCountString = 'between ' . $argMatch[1] . ' and ' . $argMatch[3];
  3894|                                 }
  3895|                                 break;
  3896|                             case ',':
  3897|                                 if (($argumentCount != $argMatch[1]) && ($argumentCount != $argMatch[3])) {
  3898|                                     $argumentCountError = true;
  3899|                                     $expectedArgumentCountString = 'either ' . $argMatch[1] . ' or ' . $argMatch[3];
  3900|                                 }
  3901|                                 break;
  3902|                         }
  3903|                     }
  3904|                     if ($argumentCountError) {
  3905|                         return $this->raiseFormulaError("Formula Error: Wrong number of arguments for $functionName() function: $argumentCount given, " . $expectedArgumentCountString . ' expected');
  3906|                     }
  3907|                 }
  3908|                 ++$index;
  3909|             } elseif ($opCharacter === ',') { // Is this the separator for function arguments?
  3910|                 try {
  3911|                     $this->branchPruner->argumentSeparator();
  3912|                 } catch (Exception $e) {
  3913|                     return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
  3914|                 }
  3915|                 while (($o2 = $stack->pop()) && $o2['value'] !== '(') {        //    Pop off the stack back to the last (
  3916|                     $output[] = $o2; // pop the argument expression stuff and push onto the output
  3917|                 }
  3918|                 if (($expectingOperand) || (!$expectingOperator)) {
  3919|                     $output[] = $stack->getStackItem('Empty Argument', null, 'NULL');
  3920|                 }
  3921|                 $d = $stack->last(2);
  3922|                 if (!preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $d['value'] ?? '', $matches)) {
  3923|                     return $this->raiseFormulaError('Formula Error: Unexpected ,');
  3924|                 }
  3925|                 /** @var array $d */
  3926|                 $d = $stack->pop();
  3927|                 ++$d['value']; // increment the argument count
  3928|                 $stack->pushStackItem($d);
  3929|                 $stack->push('Brace', '('); // put the ( back on, we'll need to pop back to it again
  3930|                 $expectingOperator = false;
  3931|                 $expectingOperand = true;
  3932|                 ++$index;
  3933|             } elseif ($opCharacter === '(' && !$expectingOperator) {
  3934|                 $this->branchPruner->incrementDepth();
  3935|                 $stack->push('Brace', '(', null);
  3936|                 ++$index;
  3937|             } elseif ($isOperandOrFunction && !$expectingOperatorCopy) {
  3938|                 $expectingOperator = true;
  3939|                 $expectingOperand = false;
  3940|                 $val = $match[1];
  3941|                 $length = strlen($val);
  3942|                 if (preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $val, $matches)) {
  3943|                     $val = (string) preg_replace('/\s/u', '', $val);
  3944|                     if (isset(self::$phpSpreadsheetFunctions[strtoupper($matches[1])]) || isset(self::$controlFunctions[strtoupper($matches[1])])) {    // it's a function
  3945|                         $valToUpper = strtoupper($val);
  3946|                     } else {
  3947|                         $valToUpper = 'NAME.ERROR(';
  3948|                     }
  3949|                     $this->branchPruner->functionCall($valToUpper);
  3950|                     $stack->push('Function', $valToUpper);
  3951|                     $ax = preg_match('/^\s*\)/u', substr($formula, $index + $length));
  3952|                     if ($ax) {
  3953|                         $stack->push('Operand Count for Function ' . $valToUpper . ')', 0);
  3954|                         $expectingOperator = true;
  3955|                     } else {
  3956|                         $stack->push('Operand Count for Function ' . $valToUpper . ')', 1);
  3957|                         $expectingOperator = false;
  3958|                     }
  3959|                     $stack->push('Brace', '(');
  3960|                 } elseif (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $val, $matches)) {
  3961|                     $testPrevOp = $stack->last(1);
  3962|                     if ($testPrevOp !== null && $testPrevOp['value'] === ':') {
  3963|                         if ($matches[2] === '') {
  3964|                             $rangeStartCellRef = $output[count($output) - 1]['value'] ?? '';
  3965|                             if ($rangeStartCellRef === ':') {
  3966|                                 $rangeStartCellRef = $output[count($output) - 2]['value'] ?? '';
  3967|                             }
  3968|                             preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $rangeStartCellRef, $rangeStartMatches);
  3969|                             if (array_key_exists(2, $rangeStartMatches)) {
  3970|                                 if ($rangeStartMatches[2] > '') {
  3971|                                     $val = $rangeStartMatches[2] . '!' . $val;
  3972|                                 }
  3973|                             } else {
  3974|                                 $val = ExcelError::REF();
  3975|                             }
  3976|                         } else {
  3977|                             $rangeStartCellRef = $output[count($output) - 1]['value'] ?? '';
  3978|                             if ($rangeStartCellRef === ':') {
  3979|                                 $rangeStartCellRef = $output[count($output) - 2]['value'] ?? '';
  3980|                             }
  3981|                             preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $rangeStartCellRef, $rangeStartMatches);
  3982|                             if ($rangeStartMatches[2] !== $matches[2]) {
  3983|                                 return $this->raiseFormulaError('3D Range references are not yet supported');
  3984|                             }
  3985|                         }
  3986|                     } elseif (!str_contains($val, '!') && $pCellParent !== null) {
  3987|                         $worksheet = $pCellParent->getTitle();
  3988|                         $val = "'{$worksheet}'!{$val}";
  3989|                     }
  3990|                     $val = str_replace(["''", '""'], ["'", '"'], $val);
  3991|                     $outputItem = $stack->getStackItem('Cell Reference', $val, $val);
  3992|                     $output[] = $outputItem;
  3993|                 } elseif (preg_match('/^' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE . '$/miu', $val, $matches)) {
  3994|                     try {
  3995|                         $structuredReference = Operands\StructuredReference::fromParser($formula, $index, $matches);
  3996|                     } catch (Exception $e) {
  3997|                         return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
  3998|                     }
  3999|                     $val = $structuredReference->value();
  4000|                     $length = strlen($val);
  4001|                     $outputItem = $stack->getStackItem(Operands\StructuredReference::NAME, $structuredReference, null);
  4002|                     $output[] = $outputItem;
  4003|                     $expectingOperator = true;
  4004|                 } else {
  4005|                     $localeConstant = false;
  4006|                     $stackItemType = 'Value';
  4007|                     $stackItemReference = null;
  4008|                     $testPrevOp = $stack->last(1);
  4009|                     if ($testPrevOp !== null && $testPrevOp['value'] === ':') {
  4010|                         $stackItemType = 'Cell Reference';
  4011|                         if (
  4012|                             !is_numeric($val)
  4013|                             && ((ctype_alpha($val) === false || strlen($val) > 3))
  4014|                             && (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '$/mui', $val) !== false)
  4015|                             && ($this->spreadsheet === null || $this->spreadsheet->getNamedRange($val) !== null)
  4016|                         ) {
  4017|                             $namedRange = ($this->spreadsheet === null) ? null : $this->spreadsheet->getNamedRange($val);
  4018|                             if ($namedRange !== null) {
  4019|                                 $stackItemType = 'Defined Name';
  4020|                                 $address = str_replace('$', '', $namedRange->getValue());
  4021|                                 $stackItemReference = $val;
  4022|                                 if (str_contains($address, ':')) {
  4023|                                     $fromTo = explode(':', $address);
  4024|                                     $to = array_pop($fromTo);
  4025|                                     foreach ($fromTo as $from) {
  4026|                                         $output[] = $stack->getStackItem($stackItemType, $from, $stackItemReference);
  4027|                                         $output[] = $stack->getStackItem('Binary Operator', ':');
  4028|                                     }
  4029|                                     $address = $to;
  4030|                                 }
  4031|                                 $val = $address;
  4032|                             }
  4033|                         } elseif ($val === ExcelError::REF()) {
  4034|                             $stackItemReference = $val;
  4035|                         } else {
  4036|                             /** @var non-empty-string $startRowColRef */
  4037|                             $startRowColRef = $output[count($output) - 1]['value'] ?? '';
  4038|                             [$rangeWS1, $startRowColRef] = Worksheet::extractSheetTitle($startRowColRef, true);
  4039|                             $rangeSheetRef = $rangeWS1;
  4040|                             if ($rangeWS1 !== '') {
  4041|                                 $rangeWS1 .= '!';
  4042|                             }
  4043|                             $rangeSheetRef = trim($rangeSheetRef, "'");
  4044|                             [$rangeWS2, $val] = Worksheet::extractSheetTitle($val, true);
  4045|                             if ($rangeWS2 !== '') {
  4046|                                 $rangeWS2 .= '!';
  4047|                             } else {
  4048|                                 $rangeWS2 = $rangeWS1;
  4049|                             }
  4050|                             $refSheet = $pCellParent;
  4051|                             if ($pCellParent !== null && $rangeSheetRef !== '' && $rangeSheetRef !== $pCellParent->getTitle()) {
  4052|                                 $refSheet = $pCellParent->getParentOrThrow()->getSheetByName($rangeSheetRef);
  4053|                             }
  4054|                             if (ctype_digit($val) && $val <= 1048576) {
  4055|                                 $stackItemType = 'Row Reference';
  4056|                                 /** @var int $valx */
  4057|                                 $valx = $val;
  4058|                                 $endRowColRef = ($refSheet !== null) ? $refSheet->getHighestDataColumn($valx) : AddressRange::MAX_COLUMN; //    Max 16,384 columns for Excel2007
  4059|                                 $val = "{$rangeWS2}{$endRowColRef}{$val}";
  4060|                             } elseif (ctype_alpha($val) && strlen($val ?? '') <= 3) {
  4061|                                 $stackItemType = 'Column Reference';
  4062|                                 $endRowColRef = ($refSheet !== null) ? $refSheet->getHighestDataRow($val) : AddressRange::MAX_ROW; //    Max 1,048,576 rows for Excel2007
  4063|                                 $val = "{$rangeWS2}{$val}{$endRowColRef}";
  4064|                             }
  4065|                             $stackItemReference = $val;
  4066|                         }
  4067|                     } elseif ($opCharacter === self::FORMULA_STRING_QUOTE) {
  4068|                         $val = self::wrapResult(str_replace('""', self::FORMULA_STRING_QUOTE, self::unwrapResult($val)));
  4069|                     } elseif (isset(self::$excelConstants[trim(strtoupper($val))])) {
  4070|                         $stackItemType = 'Constant';
  4071|                         $excelConstant = trim(strtoupper($val));
  4072|                         $val = self::$excelConstants[$excelConstant];
  4073|                         $stackItemReference = $excelConstant;
  4074|                     } elseif (($localeConstant = array_search(trim(strtoupper($val)), self::$localeBoolean)) !== false) {
  4075|                         $stackItemType = 'Constant';
  4076|                         $val = self::$excelConstants[$localeConstant];
  4077|                         $stackItemReference = $localeConstant;
  4078|                     } elseif (
  4079|                         preg_match('/^' . self::CALCULATION_REGEXP_ROW_RANGE . '/miu', substr($formula, $index), $rowRangeReference)
  4080|                     ) {
  4081|                         $val = $rowRangeReference[1];
  4082|                         $length = strlen($rowRangeReference[1]);
  4083|                         $stackItemType = 'Row Reference';
  4084|                         $val = str_replace(["''", '""'], ["'", '"'], $val);
  4085|                         $column = 'A';
  4086|                         if (($testPrevOp !== null && $testPrevOp['value'] === ':') && $pCellParent !== null) {
  4087|                             $column = $pCellParent->getHighestDataColumn($val);
  4088|                         }
  4089|                         $val = "{$rowRangeReference[2]}{$column}{$rowRangeReference[7]}";
  4090|                         $stackItemReference = $val;
  4091|                     } elseif (
  4092|                         preg_match('/^' . self::CALCULATION_REGEXP_COLUMN_RANGE . '/miu', substr($formula, $index), $columnRangeReference)
  4093|                     ) {
  4094|                         $val = $columnRangeReference[1];
  4095|                         $length = strlen($val);
  4096|                         $stackItemType = 'Column Reference';
  4097|                         $val = str_replace(["''", '""'], ["'", '"'], $val);
  4098|                         $row = '1';
  4099|                         if (($testPrevOp !== null && $testPrevOp['value'] === ':') && $pCellParent !== null) {
  4100|                             $row = $pCellParent->getHighestDataRow($val);
  4101|                         }
  4102|                         $val = "{$val}{$row}";
  4103|                         $stackItemReference = $val;
  4104|                     } elseif (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '.*/miu', $val, $match)) {
  4105|                         $stackItemType = 'Defined Name';
  4106|                         $stackItemReference = $val;
  4107|                     } elseif (is_numeric($val)) {
  4108|                         if ((str_contains((string) $val, '.')) || (stripos((string) $val, 'e') !== false) || ($val > PHP_INT_MAX) || ($val < -PHP_INT_MAX)) {
  4109|                             $val = (float) $val;
  4110|                         } else {
  4111|                             $val = (int) $val;
  4112|                         }
  4113|                     }
  4114|                     $details = $stack->getStackItem($stackItemType, $val, $stackItemReference);
  4115|                     if ($localeConstant) {
  4116|                         $details['localeValue'] = $localeConstant;
  4117|                     }
  4118|                     $output[] = $details;
  4119|                 }
  4120|                 $index += $length;
  4121|             } elseif ($opCharacter === '$') { // absolute row or column range
  4122|                 ++$index;
  4123|             } elseif ($opCharacter === ')') { // miscellaneous error checking
  4124|                 if ($expectingOperand) {
  4125|                     $output[] = $stack->getStackItem('Empty Argument', null, 'NULL');
  4126|                     $expectingOperand = false;
  4127|                     $expectingOperator = true;
  4128|                 } else {
  4129|                     return $this->raiseFormulaError("Formula Error: Unexpected ')'");
  4130|                 }
  4131|             } elseif (isset(self::CALCULATION_OPERATORS[$opCharacter]) && !$expectingOperator) {
  4132|                 return $this->raiseFormulaError("Formula Error: Unexpected operator '$opCharacter'");
  4133|             } else {    // I don't even want to know what you did to get here
  4134|                 return $this->raiseFormulaError('Formula Error: An unexpected error occurred');
  4135|             }
  4136|             if ($index == strlen($formula)) {
  4137|                 if ((isset(self::CALCULATION_OPERATORS[$opCharacter])) && ($opCharacter != '%')) {
  4138|                     return $this->raiseFormulaError("Formula Error: Operator '$opCharacter' has no operands");
  4139|                 }
  4140|                 break;
  4141|             }
  4142|             while (($formula[$index] === "\n") || ($formula[$index] === "\r")) {
  4143|                 ++$index;
  4144|             }
  4145|             if ($formula[$index] === ' ') {
  4146|                 while ($formula[$index] === ' ') {
  4147|                     ++$index;
  4148|                 }
  4149|                 $countOutputMinus1 = count($output) - 1;
  4150|                 if (
  4151|                     ($expectingOperator)
  4152|                     && array_key_exists($countOutputMinus1, $output)
  4153|                     && is_array($output[$countOutputMinus1])
  4154|                     && array_key_exists('type', $output[$countOutputMinus1])
  4155|                     && (
  4156|                         (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '.*/miu', substr($formula, $index), $match))
  4157|                             && ($output[$countOutputMinus1]['type'] === 'Cell Reference')
  4158|                         || (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '.*/miu', substr($formula, $index), $match))
  4159|                             && ($output[$countOutputMinus1]['type'] === 'Defined Name' || $output[$countOutputMinus1]['type'] === 'Value')
  4160|                         || (preg_match('/^' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE . '.*/miu', substr($formula, $index), $match))
  4161|                             && ($output[$countOutputMinus1]['type'] === Operands\StructuredReference::NAME || $output[$countOutputMinus1]['type'] === 'Value')
  4162|                     )
  4163|                 ) {
  4164|                     while (
  4165|                         $stack->count() > 0
  4166|                         && ($o2 = $stack->last())
  4167|                         && isset(self::CALCULATION_OPERATORS[$o2['value']])
  4168|                         && @(self::$operatorAssociativity[$opCharacter] ? self::$operatorPrecedence[$opCharacter] < self::$operatorPrecedence[$o2['value']] : self::$operatorPrecedence[$opCharacter] <= self::$operatorPrecedence[$o2['value']])
  4169|                     ) {
  4170|                         $output[] = $stack->pop(); //    Swap operands and higher precedence operators from the stack to the output
  4171|                     }
  4172|                     $stack->push('Binary Operator', '∩'); //    Put an Intersect Operator on the stack
  4173|                     $expectingOperator = false;
  4174|                 }
  4175|             }
  4176|         }
  4177|         while (($op = $stack->pop()) !== null) {
  4178|             if ((is_array($op) && $op['value'] == '(')) {
  4179|                 return $this->raiseFormulaError("Formula Error: Expecting ')'"); // if there are any opening braces on the stack, then braces were unbalanced
  4180|             }
  4181|             $output[] = $op;
  4182|         }
  4183|         return $output;
  4184|     }
  4185|     private static function dataTestReference(array &$operandData): mixed
  4186|     {
  4187|         $operand = $operandData['value'];
  4188|         if (($operandData['reference'] === null) && (is_array($operand))) {
  4189|             $rKeys = array_keys($operand);
  4190|             $rowKey = array_shift($rKeys);
  4191|             if (is_array($operand[$rowKey]) === false) {
  4192|                 $operandData['value'] = $operand[$rowKey];
  4193|                 return $operand[$rowKey];
  4194|             }
  4195|             $cKeys = array_keys(array_keys($operand[$rowKey]));
  4196|             $colKey = array_shift($cKeys);
  4197|             if (ctype_upper("$colKey")) {
  4198|                 $operandData['reference'] = $colKey . $rowKey;
  4199|             }
  4200|         }
  4201|         return $operand;
  4202|     }
  4203|     /**
  4204|      * @return array<int, mixed>|false
  4205|      */
  4206|     private function processTokenStack(mixed $tokens, ?string $cellID = null, ?Cell $cell = null)
  4207|     {
  4208|         if ($tokens === false) {
  4209|             return false;
  4210|         }
  4211|         $pCellWorksheet = ($cell !== null) ? $cell->getWorksheet() : null;
  4212|         $pCellParent = ($cell !== null) ? $cell->getParent() : null;
  4213|         $stack = new Stack($this->branchPruner);
  4214|         $fakedForBranchPruning = [];
  4215|         $branchStore = [];
  4216|         foreach ($tokens as $tokenData) {
  4217|             $token = $tokenData['value'];
  4218|             $storeKey = $tokenData['storeKey'] ?? null;
  4219|             if ($this->branchPruningEnabled && isset($tokenData['onlyIf'])) {
  4220|                 $onlyIfStoreKey = $tokenData['onlyIf'];
  4221|                 $storeValue = $branchStore[$onlyIfStoreKey] ?? null;
  4222|                 $storeValueAsBool = ($storeValue === null)
  4223|                     ? true : (bool) Functions::flattenSingleValue($storeValue);
  4224|                 if (is_array($storeValue)) {
  4225|                     $wrappedItem = end($storeValue);
  4226|                     $storeValue = is_array($wrappedItem) ? end($wrappedItem) : $wrappedItem;
  4227|                 }
  4228|                 if (
  4229|                     (isset($storeValue) || $tokenData['reference'] === 'NULL')
  4230|                     && (!$storeValueAsBool || Information\ErrorValue::isError($storeValue) || ($storeValue === 'Pruned branch'))
  4231|                 ) {
  4232|                     if (!isset($fakedForBranchPruning['onlyIf-' . $onlyIfStoreKey])) {
  4233|                         $stack->push('Value', 'Pruned branch (only if ' . $onlyIfStoreKey . ') ' . $token);
  4234|                         $fakedForBranchPruning['onlyIf-' . $onlyIfStoreKey] = true;
  4235|                     }
  4236|                     if (isset($storeKey)) {
  4237|                         $branchStore[$storeKey] = 'Pruned branch';
  4238|                         $fakedForBranchPruning['onlyIfNot-' . $storeKey] = true;
  4239|                         $fakedForBranchPruning['onlyIf-' . $storeKey] = true;
  4240|                     }
  4241|                     continue;
  4242|                 }
  4243|             }
  4244|             if ($this->branchPruningEnabled && isset($tokenData['onlyIfNot'])) {
  4245|                 $onlyIfNotStoreKey = $tokenData['onlyIfNot'];
  4246|                 $storeValue = $branchStore[$onlyIfNotStoreKey] ?? null;
  4247|                 $storeValueAsBool = ($storeValue === null)
  4248|                     ? true : (bool) Functions::flattenSingleValue($storeValue);
  4249|                 if (is_array($storeValue)) {
  4250|                     $wrappedItem = end($storeValue);
  4251|                     $storeValue = is_array($wrappedItem) ? end($wrappedItem) : $wrappedItem;
  4252|                 }
  4253|                 if (
  4254|                     (isset($storeValue) || $tokenData['reference'] === 'NULL')
  4255|                     && ($storeValueAsBool || Information\ErrorValue::isError($storeValue) || ($storeValue === 'Pruned branch'))
  4256|                 ) {
  4257|                     if (!isset($fakedForBranchPruning['onlyIfNot-' . $onlyIfNotStoreKey])) {
  4258|                         $stack->push('Value', 'Pruned branch (only if not ' . $onlyIfNotStoreKey . ') ' . $token);
  4259|                         $fakedForBranchPruning['onlyIfNot-' . $onlyIfNotStoreKey] = true;
  4260|                     }
  4261|                     if (isset($storeKey)) {
  4262|                         $branchStore[$storeKey] = 'Pruned branch';
  4263|                         $fakedForBranchPruning['onlyIfNot-' . $storeKey] = true;
  4264|                         $fakedForBranchPruning['onlyIf-' . $storeKey] = true;
  4265|                     }
  4266|                     continue;
  4267|                 }
  4268|             }
  4269|             if ($token instanceof Operands\StructuredReference) {
  4270|                 if ($cell === null) {
  4271|                     return $this->raiseFormulaError('Structured References must exist in a Cell context');
  4272|                 }
  4273|                 try {
  4274|                     $cellRange = $token->parse($cell);
  4275|                     if (str_contains($cellRange, ':')) {
  4276|                         $this->debugLog->writeDebugLog('Evaluating Structured Reference %s as Cell Range %s', $token->value(), $cellRange);
  4277|                         $rangeValue = self::getInstance($cell->getWorksheet()->getParent())->_calculateFormulaValue("={$cellRange}", $cellRange, $cell);
  4278|                         $stack->push('Value', $rangeValue);
  4279|                         $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as value %s', $token->value(), $this->showValue($rangeValue));
  4280|                     } else {
  4281|                         $this->debugLog->writeDebugLog('Evaluating Structured Reference %s as Cell %s', $token->value(), $cellRange);
  4282|                         $cellValue = $cell->getWorksheet()->getCell($cellRange)->getCalculatedValue(false);
  4283|                         $stack->push('Cell Reference', $cellValue, $cellRange);
  4284|                         $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as value %s', $token->value(), $this->showValue($cellValue));
  4285|                     }
  4286|                 } catch (Exception $e) {
  4287|                     if ($e->getCode() === Exception::CALCULATION_ENGINE_PUSH_TO_STACK) {
  4288|                         $stack->push('Error', ExcelError::REF(), null);
  4289|                         $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as error value %s', $token->value(), ExcelError::REF());
  4290|                     } else {
  4291|                         return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
  4292|                     }
  4293|                 }
  4294|             } elseif (!is_numeric($token) && !is_object($token) && isset(self::BINARY_OPERATORS[$token])) {
  4295|                 $operand2Data = $stack->pop();
  4296|                 if ($operand2Data === null) {
  4297|                     return $this->raiseFormulaError('Internal error - Operand value missing from stack');
  4298|                 }
  4299|                 $operand1Data = $stack->pop();
  4300|                 if ($operand1Data === null) {
  4301|                     return $this->raiseFormulaError('Internal error - Operand value missing from stack');
  4302|                 }
  4303|                 $operand1 = self::dataTestReference($operand1Data);
  4304|                 $operand2 = self::dataTestReference($operand2Data);
  4305|                 if ($token == ':') {
  4306|                     $this->debugLog->writeDebugLog('Evaluating Range %s %s %s', $this->showValue($operand1Data['reference']), $token, $this->showValue($operand2Data['reference']));
  4307|                 } else {
  4308|                     $this->debugLog->writeDebugLog('Evaluating %s %s %s', $this->showValue($operand1), $token, $this->showValue($operand2));
  4309|                 }
  4310|                 switch ($token) {
  4311|                     case '>': // Greater than
  4312|                     case '<': // Less than
  4313|                     case '>=': // Greater than or Equal to
  4314|                     case '<=': // Less than or Equal to
  4315|                     case '=': // Equality
  4316|                     case '<>': // Inequality
  4317|                         $result = $this->executeBinaryComparisonOperation($operand1, $operand2, (string) $token, $stack);
  4318|                         if (isset($storeKey)) {
  4319|                             $branchStore[$storeKey] = $result;
  4320|                         }
  4321|                         break;
  4322|                     case ':': // Range
  4323|                         if ($operand1Data['type'] === 'Defined Name') {
  4324|                             if (preg_match('/$' . self::CALCULATION_REGEXP_DEFINEDNAME . '^/mui', $operand1Data['reference']) !== false && $this->spreadsheet !== null) {
  4325|                                 $definedName = $this->spreadsheet->getNamedRange($operand1Data['reference']);
  4326|                                 if ($definedName !== null) {
  4327|                                     $operand1Data['reference'] = $operand1Data['value'] = str_replace('$', '', $definedName->getValue());
  4328|                                 }
  4329|                             }
  4330|                         }
  4331|                         if (str_contains($operand1Data['reference'] ?? '', '!')) {
  4332|                             [$sheet1, $operand1Data['reference']] = Worksheet::extractSheetTitle($operand1Data['reference'], true);
  4333|                         } else {
  4334|                             $sheet1 = ($pCellWorksheet !== null) ? $pCellWorksheet->getTitle() : '';
  4335|                         }
  4336|                         $sheet1 ??= '';
  4337|                         [$sheet2, $operand2Data['reference']] = Worksheet::extractSheetTitle($operand2Data['reference'], true);
  4338|                         if (empty($sheet2)) {
  4339|                             $sheet2 = $sheet1;
  4340|                         }
  4341|                         if (trim($sheet1, "'") === trim($sheet2, "'")) {
  4342|                             if ($operand1Data['reference'] === null && $cell !== null) {
  4343|                                 if (is_array($operand1Data['value'])) {
  4344|                                     $operand1Data['reference'] = $cell->getCoordinate();
  4345|                                 } elseif ((trim($operand1Data['value']) != '') && (is_numeric($operand1Data['value']))) {
  4346|                                     $operand1Data['reference'] = $cell->getColumn() . $operand1Data['value'];
  4347|                                 } elseif (trim($operand1Data['value']) == '') {
  4348|                                     $operand1Data['reference'] = $cell->getCoordinate();
  4349|                                 } else {
  4350|                                     $operand1Data['reference'] = $operand1Data['value'] . $cell->getRow();
  4351|                                 }
  4352|                             }
  4353|                             if ($operand2Data['reference'] === null && $cell !== null) {
  4354|                                 if (is_array($operand2Data['value'])) {
  4355|                                     $operand2Data['reference'] = $cell->getCoordinate();
  4356|                                 } elseif ((trim($operand2Data['value']) != '') && (is_numeric($operand2Data['value']))) {
  4357|                                     $operand2Data['reference'] = $cell->getColumn() . $operand2Data['value'];
  4358|                                 } elseif (trim($operand2Data['value']) == '') {
  4359|                                     $operand2Data['reference'] = $cell->getCoordinate();
  4360|                                 } else {
  4361|                                     $operand2Data['reference'] = $operand2Data['value'] . $cell->getRow();
  4362|                                 }
  4363|                             }
  4364|                             $oData = array_merge(explode(':', $operand1Data['reference'] ?? ''), explode(':', $operand2Data['reference'] ?? ''));
  4365|                             $oCol = $oRow = [];
  4366|                             $breakNeeded = false;
  4367|                             foreach ($oData as $oDatum) {
  4368|                                 try {
  4369|                                     $oCR = Coordinate::coordinateFromString($oDatum);
  4370|                                     $oCol[] = Coordinate::columnIndexFromString($oCR[0]) - 1;
  4371|                                     $oRow[] = $oCR[1];
  4372|                                 } catch (\Exception) {
  4373|                                     $stack->push('Error', ExcelError::REF(), null);
  4374|                                     $breakNeeded = true;
  4375|                                     break;
  4376|                                 }
  4377|                             }
  4378|                             if ($breakNeeded) {
  4379|                                 break;
  4380|                             }
  4381|                             $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':' . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
  4382|                             if ($pCellParent !== null && $this->spreadsheet !== null) {
  4383|                                 $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($sheet1), false);
  4384|                             } else {
  4385|                                 return $this->raiseFormulaError('Unable to access Cell Reference');
  4386|                             }
  4387|                             $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellValue));
  4388|                             $stack->push('Cell Reference', $cellValue, $cellRef);
  4389|                         } else {
  4390|                             $this->debugLog->writeDebugLog('Evaluation Result is a #REF! Error');
  4391|                             $stack->push('Error', ExcelError::REF(), null);
  4392|                         }
  4393|                         break;
  4394|                     case '+':            //    Addition
  4395|                     case '-':            //    Subtraction
  4396|                     case '*':            //    Multiplication
  4397|                     case '/':            //    Division
  4398|                     case '^':            //    Exponential
  4399|                         $result = $this->executeNumericBinaryOperation($operand1, $operand2, $token, $stack);
  4400|                         if (isset($storeKey)) {
  4401|                             $branchStore[$storeKey] = $result;
  4402|                         }
  4403|                         break;
  4404|                     case '&':            //    Concatenation
  4405|                         $operand1 = self::boolToString($operand1);
  4406|                         $operand2 = self::boolToString($operand2);
  4407|                         if (is_array($operand1) || is_array($operand2)) {
  4408|                             if (is_string($operand1)) {
  4409|                                 $operand1 = self::unwrapResult($operand1);
  4410|                             }
  4411|                             if (is_string($operand2)) {
  4412|                                 $operand2 = self::unwrapResult($operand2);
  4413|                             }
  4414|                             [$rows, $columns] = self::checkMatrixOperands($operand1, $operand2, 2);
  4415|                             for ($row = 0; $row < $rows; ++$row) {
  4416|                                 for ($column = 0; $column < $columns; ++$column) {
  4417|                                     $op1x = self::boolToString($operand1[$row][$column]);
  4418|                                     $op2x = self::boolToString($operand2[$row][$column]);
  4419|                                     if (Information\ErrorValue::isError($op1x)) {
  4420|                                     } elseif (Information\ErrorValue::isError($op2x)) {
  4421|                                         $operand1[$row][$column] = $op2x;
  4422|                                     } else {
  4423|                                         $operand1[$row][$column]
  4424|                                             = Shared\StringHelper::substring(
  4425|                                                 $op1x . $op2x,
  4426|                                                 0,
  4427|                                                 DataType::MAX_STRING_LENGTH
  4428|                                             );
  4429|                                     }
  4430|                                 }
  4431|                             }
  4432|                             $result = $operand1;
  4433|                         } else {
  4434|                             if (Information\ErrorValue::isError($operand1)) {
  4435|                                 $result = $operand1;
  4436|                             } elseif (Information\ErrorValue::isError($operand2)) {
  4437|                                 $result = $operand2;
  4438|                             } else {
  4439|                                 $result = self::FORMULA_STRING_QUOTE . str_replace('""', self::FORMULA_STRING_QUOTE, self::unwrapResult($operand1) . self::unwrapResult($operand2)) . self::FORMULA_STRING_QUOTE;
  4440|                             }
  4441|                         }
  4442|                         $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
  4443|                         $stack->push('Value', $result);
  4444|                         if (isset($storeKey)) {
  4445|                             $branchStore[$storeKey] = $result;
  4446|                         }
  4447|                         break;
  4448|                     case '∩':            //    Intersect
  4449|                         $rowIntersect = array_intersect_key($operand1, $operand2);
  4450|                         $cellIntersect = $oCol = $oRow = [];
  4451|                         foreach (array_keys($rowIntersect) as $row) {
  4452|                             $oRow[] = $row;
  4453|                             foreach ($rowIntersect[$row] as $col => $data) {
  4454|                                 $oCol[] = Coordinate::columnIndexFromString($col) - 1;
  4455|                                 $cellIntersect[$row] = array_intersect_key($operand1[$row], $operand2[$row]);
  4456|                             }
  4457|                         }
  4458|                         if (count(Functions::flattenArray($cellIntersect)) === 0) {
  4459|                             $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellIntersect));
  4460|                             $stack->push('Error', ExcelError::null(), null);
  4461|                         } else {
  4462|                             $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':'
  4463|                                 . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
  4464|                             $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellIntersect));
  4465|                             $stack->push('Value', $cellIntersect, $cellRef);
  4466|                         }
  4467|                         break;
  4468|                 }
  4469|             } elseif (($token === '~') || ($token === '%')) {
  4470|                 if (($arg = $stack->pop()) === null) {
  4471|                     return $this->raiseFormulaError('Internal error - Operand value missing from stack');
  4472|                 }
  4473|                 $arg = $arg['value'];
  4474|                 if ($token === '~') {
  4475|                     $this->debugLog->writeDebugLog('Evaluating Negation of %s', $this->showValue($arg));
  4476|                     $multiplier = -1;
  4477|                 } else {
  4478|                     $this->debugLog->writeDebugLog('Evaluating Percentile of %s', $this->showValue($arg));
  4479|                     $multiplier = 0.01;
  4480|                 }
  4481|                 if (is_array($arg)) {
  4482|                     $operand2 = $multiplier;
  4483|                     $result = $arg;
  4484|                     [$rows, $columns] = self::checkMatrixOperands($result, $operand2, 0);
  4485|                     for ($row = 0; $row < $rows; ++$row) {
  4486|                         for ($column = 0; $column < $columns; ++$column) {
  4487|                             if (self::isNumericOrBool($result[$row][$column])) {
  4488|                                 $result[$row][$column] *= $multiplier;
  4489|                             } else {
  4490|                                 $result[$row][$column] = self::makeError($result[$row][$column]);
  4491|                             }
  4492|                         }
  4493|                     }
  4494|                     $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
  4495|                     $stack->push('Value', $result);
  4496|                     if (isset($storeKey)) {
  4497|                         $branchStore[$storeKey] = $result;
  4498|                     }
  4499|                 } else {
  4500|                     $this->executeNumericBinaryOperation($multiplier, $arg, '*', $stack);
  4501|                 }
  4502|             } elseif (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/i', $token ?? '', $matches)) {
  4503|                 $cellRef = null;
  4504|                 if (isset($matches[8])) {
  4505|                     if ($cell === null) {
  4506|                         $cellValue = ExcelError::REF();
  4507|                     } else {
  4508|                         $cellRef = $matches[6] . $matches[7] . ':' . $matches[9] . $matches[10];
  4509|                         if ($matches[2] > '') {
  4510|                             $matches[2] = trim($matches[2], "\"'");
  4511|                             if ((str_contains($matches[2], '[')) || (str_contains($matches[2], ']'))) {
  4512|                                 return $this->raiseFormulaError('Unable to access External Workbook');
  4513|                             }
  4514|                             $matches[2] = trim($matches[2], "\"'");
  4515|                             $this->debugLog->writeDebugLog('Evaluating Cell Range %s in worksheet %s', $cellRef, $matches[2]);
  4516|                             if ($pCellParent !== null && $this->spreadsheet !== null) {
  4517|                                 $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
  4518|                             } else {
  4519|                                 return $this->raiseFormulaError('Unable to access Cell Reference');
  4520|                             }
  4521|                             $this->debugLog->writeDebugLog('Evaluation Result for cells %s in worksheet %s is %s', $cellRef, $matches[2], $this->showTypeDetails($cellValue));
  4522|                         } else {
  4523|                             $this->debugLog->writeDebugLog('Evaluating Cell Range %s in current worksheet', $cellRef);
  4524|                             if ($pCellParent !== null) {
  4525|                                 $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
  4526|                             } else {
  4527|                                 return $this->raiseFormulaError('Unable to access Cell Reference');
  4528|                             }
  4529|                             $this->debugLog->writeDebugLog('Evaluation Result for cells %s is %s', $cellRef, $this->showTypeDetails($cellValue));
  4530|                         }
  4531|                     }
  4532|                 } else {
  4533|                     if ($cell === null) {
  4534|                         $cellValue = ExcelError::REF();
  4535|                     } else {
  4536|                         $cellRef = $matches[6] . $matches[7];
  4537|                         if ($matches[2] > '') {
  4538|                             $matches[2] = trim($matches[2], "\"'");
  4539|                             if ((str_contains($matches[2], '[')) || (str_contains($matches[2], ']'))) {
  4540|                                 return $this->raiseFormulaError('Unable to access External Workbook');
  4541|                             }
  4542|                             $this->debugLog->writeDebugLog('Evaluating Cell %s in worksheet %s', $cellRef, $matches[2]);
  4543|                             if ($pCellParent !== null && $this->spreadsheet !== null) {
  4544|                                 $cellSheet = $this->spreadsheet->getSheetByName($matches[2]);
  4545|                                 if ($cellSheet && $cellSheet->cellExists($cellRef)) {
  4546|                                     $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
  4547|                                     $cell->attach($pCellParent);
  4548|                                 } else {
  4549|                                     $cellRef = ($cellSheet !== null) ? "'{$matches[2]}'!{$cellRef}" : $cellRef;
  4550|                                     $cellValue = ($cellSheet !== null) ? null : ExcelError::REF();
  4551|                                 }
  4552|                             } else {
  4553|                                 return $this->raiseFormulaError('Unable to access Cell Reference');
  4554|                             }
  4555|                             $this->debugLog->writeDebugLog('Evaluation Result for cell %s in worksheet %s is %s', $cellRef, $matches[2], $this->showTypeDetails($cellValue));
  4556|                         } else {
  4557|                             $this->debugLog->writeDebugLog('Evaluating Cell %s in current worksheet', $cellRef);
  4558|                             if ($pCellParent !== null && $pCellParent->has($cellRef)) {
  4559|                                 $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
  4560|                                 $cell->attach($pCellParent);
  4561|                             } else {
  4562|                                 $cellValue = null;
  4563|                             }
  4564|                             $this->debugLog->writeDebugLog('Evaluation Result for cell %s is %s', $cellRef, $this->showTypeDetails($cellValue));
  4565|                         }
  4566|                     }
  4567|                 }
  4568|                 $stack->push('Cell Value', $cellValue, $cellRef);
  4569|                 if (isset($storeKey)) {
  4570|                     $branchStore[$storeKey] = $cellValue;
  4571|                 }
  4572|             } elseif (preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $token ?? '', $matches)) {
  4573|                 if ($cell !== null && $pCellParent !== null) {
  4574|                     $cell->attach($pCellParent);
  4575|                 }
  4576|                 $functionName = $matches[1];
  4577|                 $argCount = $stack->pop();
  4578|                 $argCount = $argCount['value'];
  4579|                 if ($functionName !== 'MKMATRIX') {
  4580|                     $this->debugLog->writeDebugLog('Evaluating Function %s() with %s argument%s', self::localeFunc($functionName), (($argCount == 0) ? 'no' : $argCount), (($argCount == 1) ? '' : 's'));
  4581|                 }
  4582|                 if ((isset(self::$phpSpreadsheetFunctions[$functionName])) || (isset(self::$controlFunctions[$functionName]))) {    // function
  4583|                     $passByReference = false;
  4584|                     $passCellReference = false;
  4585|                     $functionCall = null;
  4586|                     if (isset(self::$phpSpreadsheetFunctions[$functionName])) {
  4587|                         $functionCall = self::$phpSpreadsheetFunctions[$functionName]['functionCall'];
  4588|                         $passByReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference']);
  4589|                         $passCellReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passCellReference']);
  4590|                     } elseif (isset(self::$controlFunctions[$functionName])) {
  4591|                         $functionCall = self::$controlFunctions[$functionName]['functionCall'];
  4592|                         $passByReference = isset(self::$controlFunctions[$functionName]['passByReference']);
  4593|                         $passCellReference = isset(self::$controlFunctions[$functionName]['passCellReference']);
  4594|                     }
  4595|                     $args = $argArrayVals = [];
  4596|                     $emptyArguments = [];
  4597|                     for ($i = 0; $i < $argCount; ++$i) {
  4598|                         $arg = $stack->pop();
  4599|                         $a = $argCount - $i - 1;
  4600|                         if (
  4601|                             ($passByReference)
  4602|                             && (isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a]))
  4603|                             && (self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a])
  4604|                         ) {
  4605|                             if ($arg['reference'] === null) {
  4606|                                 $args[] = $cellID;
  4607|                                 if ($functionName !== 'MKMATRIX') {
  4608|                                     $argArrayVals[] = $this->showValue($cellID);
  4609|                                 }
  4610|                             } else {
  4611|                                 $args[] = $arg['reference'];
  4612|                                 if ($functionName !== 'MKMATRIX') {
  4613|                                     $argArrayVals[] = $this->showValue($arg['reference']);
  4614|                                 }
  4615|                             }
  4616|                         } else {
  4617|                             if ($arg['type'] === 'Empty Argument' && in_array($functionName, ['MIN', 'MINA', 'MAX', 'MAXA', 'IF'], true)) {
  4618|                                 $emptyArguments[] = false;
  4619|                                 $args[] = $arg['value'] = 0;
  4620|                                 $this->debugLog->writeDebugLog('Empty Argument reevaluated as 0');
  4621|                             } else {
  4622|                                 $emptyArguments[] = $arg['type'] === 'Empty Argument';
  4623|                                 $args[] = self::unwrapResult($arg['value']);
  4624|                             }
  4625|                             if ($functionName !== 'MKMATRIX') {
  4626|                                 $argArrayVals[] = $this->showValue($arg['value']);
  4627|                             }
  4628|                         }
  4629|                     }
  4630|                     krsort($args);
  4631|                     krsort($emptyArguments);
  4632|                     if ($argCount > 0 && is_array($functionCall)) {
  4633|                         $args = $this->addDefaultArgumentValues($functionCall, $args, $emptyArguments);
  4634|                     }
  4635|                     if (($passByReference) && ($argCount == 0)) {
  4636|                         $args[] = $cellID;
  4637|                         $argArrayVals[] = $this->showValue($cellID);
  4638|                     }
  4639|                     if ($functionName !== 'MKMATRIX') {
  4640|                         if ($this->debugLog->getWriteDebugLog()) {
  4641|                             krsort($argArrayVals);
  4642|                             $this->debugLog->writeDebugLog('Evaluating %s ( %s )', self::localeFunc($functionName), implode(self::$localeArgumentSeparator . ' ', Functions::flattenArray($argArrayVals)));
  4643|                         }
  4644|                     }
  4645|                     $args = $this->addCellReference($args, $passCellReference, $functionCall, $cell);
  4646|                     if (!is_array($functionCall)) {
  4647|                         foreach ($args as &$arg) {
  4648|                             $arg = Functions::flattenSingleValue($arg);
  4649|                         }
  4650|                         unset($arg);
  4651|                     }
  4652|                     $result = call_user_func_array($functionCall, $args);
  4653|                     if ($functionName !== 'MKMATRIX') {
  4654|                         $this->debugLog->writeDebugLog('Evaluation Result for %s() function call is %s', self::localeFunc($functionName), $this->showTypeDetails($result));
  4655|                     }
  4656|                     $stack->push('Value', self::wrapResult($result));
  4657|                     if (isset($storeKey)) {
  4658|                         $branchStore[$storeKey] = $result;
  4659|                     }
  4660|                 }
  4661|             } else {
  4662|                 if (isset(self::$excelConstants[strtoupper($token ?? '')])) {
  4663|                     $excelConstant = strtoupper($token);
  4664|                     $stack->push('Constant Value', self::$excelConstants[$excelConstant]);
  4665|                     if (isset($storeKey)) {
  4666|                         $branchStore[$storeKey] = self::$excelConstants[$excelConstant];
  4667|                     }
  4668|                     $this->debugLog->writeDebugLog('Evaluating Constant %s as %s', $excelConstant, $this->showTypeDetails(self::$excelConstants[$excelConstant]));
  4669|                 } elseif ((is_numeric($token)) || ($token === null) || (is_bool($token)) || ($token == '') || ($token[0] == self::FORMULA_STRING_QUOTE) || ($token[0] == '#')) {
  4670|                     $stack->push($tokenData['type'], $token, $tokenData['reference']);
  4671|                     if (isset($storeKey)) {
  4672|                         $branchStore[$storeKey] = $token;
  4673|                     }
  4674|                 } elseif (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $token, $matches)) {
  4675|                     $definedName = $matches[6];
  4676|                     if ($cell === null || $pCellWorksheet === null) {
  4677|                         return $this->raiseFormulaError("undefined name '$token'");
  4678|                     }
  4679|                     $this->debugLog->writeDebugLog('Evaluating Defined Name %s', $definedName);
  4680|                     $namedRange = DefinedName::resolveName($definedName, $pCellWorksheet);
  4681|                     if ($namedRange === null && $this->spreadsheet !== null) {
  4682|                         $table = $this->spreadsheet->getTableByName($definedName);
  4683|                         if ($table !== null) {
  4684|                             $tableRange = Coordinate::getRangeBoundaries($table->getRange());
  4685|                             if ($table->getShowHeaderRow()) {
  4686|                                 ++$tableRange[0][1];
  4687|                             }
  4688|                             if ($table->getShowTotalsRow()) {
  4689|                                 --$tableRange[1][1];
  4690|                             }
  4691|                             $tableRangeString
  4692|                                 = '$' . $tableRange[0][0]
  4693|                                 . '$' . $tableRange[0][1]
  4694|                                 . ':'
  4695|                                 . '$' . $tableRange[1][0]
  4696|                                 . '$' . $tableRange[1][1];
  4697|                             $namedRange = new NamedRange($definedName, $table->getWorksheet(), $tableRangeString);
  4698|                         }
  4699|                     }
  4700|                     if ($namedRange === null) {
  4701|                         return $this->raiseFormulaError("undefined name '$definedName'");
  4702|                     }
  4703|                     $result = $this->evaluateDefinedName($cell, $namedRange, $pCellWorksheet, $stack);
  4704|                     if (isset($storeKey)) {
  4705|                         $branchStore[$storeKey] = $result;
  4706|                     }
  4707|                 } else {
  4708|                     return $this->raiseFormulaError("undefined name '$token'");
  4709|                 }
  4710|             }
  4711|         }
  4712|         if ($stack->count() != 1) {
  4713|             return $this->raiseFormulaError('internal error');
  4714|         }
  4715|         $output = $stack->pop();
  4716|         $output = $output['value'];
  4717|         return $output;
  4718|     }
  4719|     private function validateBinaryOperand(mixed &$operand, mixed &$stack): bool
  4720|     {
  4721|         if (is_array($operand)) {
  4722|             if ((count($operand, COUNT_RECURSIVE) - count($operand)) == 1) {
  4723|                 do {
  4724|                     $operand = array_pop($operand);
  4725|                 } while (is_array($operand));
  4726|             }
  4727|         }
  4728|         if (is_string($operand)) {
  4729|             if ($operand > '' && $operand[0] == self::FORMULA_STRING_QUOTE) {
  4730|                 $operand = self::unwrapResult($operand);
  4731|             }
  4732|             if (!is_numeric($operand)) {
  4733|                 if ($operand > '' && $operand[0] == '#') {
  4734|                     $stack->push('Value', $operand);
  4735|                     $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($operand));
  4736|                     return false;
  4737|                 } elseif (Engine\FormattedNumber::convertToNumberIfFormatted($operand) === false) {
  4738|                     $stack->push('Error', '#VALUE!');
  4739|                     $this->debugLog->writeDebugLog('Evaluation Result is a %s', $this->showTypeDetails('#VALUE!'));
  4740|                     return false;
  4741|                 }
  4742|             }
  4743|         }
  4744|         return true;
  4745|     }
  4746|     private function executeArrayComparison(mixed $operand1, mixed $operand2, string $operation, Stack &$stack, bool $recursingArrays): array
  4747|     {
  4748|         $result = [];
  4749|         if (!is_array($operand2)) {
  4750|             foreach ($operand1 as $x => $operandData) {
  4751|                 $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operandData), $operation, $this->showValue($operand2));
  4752|                 $this->executeBinaryComparisonOperation($operandData, $operand2, $operation, $stack);
  4753|                 $r = $stack->pop();
  4754|                 $result[$x] = $r['value'];
  4755|             }
  4756|         } elseif (!is_array($operand1)) {
  4757|             foreach ($operand2 as $x => $operandData) {
  4758|                 $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operand1), $operation, $this->showValue($operandData));
  4759|                 $this->executeBinaryComparisonOperation($operand1, $operandData, $operation, $stack);
  4760|                 $r = $stack->pop();
  4761|                 $result[$x] = $r['value'];
  4762|             }
  4763|         } else {
  4764|             if (!$recursingArrays) {
  4765|                 self::checkMatrixOperands($operand1, $operand2, 2);
  4766|             }
  4767|             foreach ($operand1 as $x => $operandData) {
  4768|                 $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operandData), $operation, $this->showValue($operand2[$x]));
  4769|                 $this->executeBinaryComparisonOperation($operandData, $operand2[$x], $operation, $stack, true);
  4770|                 $r = $stack->pop();
  4771|                 $result[$x] = $r['value'];
  4772|             }
  4773|         }
  4774|         $this->debugLog->writeDebugLog('Comparison Evaluation Result is %s', $this->showTypeDetails($result));
  4775|         $stack->push('Array', $result);
  4776|         return $result;
  4777|     }
  4778|     private function executeBinaryComparisonOperation(mixed $operand1, mixed $operand2, string $operation, Stack &$stack, bool $recursingArrays = false): array|bool
  4779|     {
  4780|         if ((is_array($operand1)) || (is_array($operand2))) {
  4781|             return $this->executeArrayComparison($operand1, $operand2, $operation, $stack, $recursingArrays);
  4782|         }
  4783|         $result = BinaryComparison::compare($operand1, $operand2, $operation);
  4784|         $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
  4785|         $stack->push('Value', $result);
  4786|         return $result;
  4787|     }
  4788|     private function executeNumericBinaryOperation(mixed $operand1, mixed $operand2, string $operation, Stack &$stack): mixed
  4789|     {
  4790|         if (
  4791|             ($this->validateBinaryOperand($operand1, $stack) === false)
  4792|             || ($this->validateBinaryOperand($operand2, $stack) === false)
  4793|         ) {
  4794|             return false;
  4795|         }
  4796|         if (
  4797|             (Functions::getCompatibilityMode() != Functions::COMPATIBILITY_OPENOFFICE)
  4798|             && ((is_string($operand1) && !is_numeric($operand1) && $operand1 !== '')
  4799|                 || (is_string($operand2) && !is_numeric($operand2) && $operand2 !== ''))
  4800|         ) {
  4801|             $result = ExcelError::VALUE();
  4802|         } elseif (is_array($operand1) || is_array($operand2)) {
  4803|             if (is_array($operand1)) {
  4804|                 foreach ($operand1 as $key => $value) {
  4805|                     $operand1[$key] = Functions::flattenArray($value);
  4806|                 }
  4807|             }
  4808|             if (is_array($operand2)) {
  4809|                 foreach ($operand2 as $key => $value) {
  4810|                     $operand2[$key] = Functions::flattenArray($value);
  4811|                 }
  4812|             }
  4813|             [$rows, $columns] = self::checkMatrixOperands($operand1, $operand2, 2);
  4814|             for ($row = 0; $row < $rows; ++$row) {
  4815|                 for ($column = 0; $column < $columns; ++$column) {
  4816|                     if ($operand1[$row][$column] === null) {
  4817|                         $operand1[$row][$column] = 0;
  4818|                     } elseif (!self::isNumericOrBool($operand1[$row][$column])) {
  4819|                         $operand1[$row][$column] = self::makeError($operand1[$row][$column]);
  4820|                         continue;
  4821|                     }
  4822|                     if ($operand2[$row][$column] === null) {
  4823|                         $operand2[$row][$column] = 0;
  4824|                     } elseif (!self::isNumericOrBool($operand2[$row][$column])) {
  4825|                         $operand1[$row][$column] = self::makeError($operand2[$row][$column]);
  4826|                         continue;
  4827|                     }
  4828|                     switch ($operation) {
  4829|                         case '+':
  4830|                             $operand1[$row][$column] += $operand2[$row][$column];
  4831|                             break;
  4832|                         case '-':
  4833|                             $operand1[$row][$column] -= $operand2[$row][$column];
  4834|                             break;
  4835|                         case '*':
  4836|                             $operand1[$row][$column] *= $operand2[$row][$column];
  4837|                             break;
  4838|                         case '/':
  4839|                             if ($operand2[$row][$column] == 0) {
  4840|                                 $operand1[$row][$column] = ExcelError::DIV0();
  4841|                             } else {
  4842|                                 $operand1[$row][$column] /= $operand2[$row][$column];
  4843|                             }
  4844|                             break;
  4845|                         case '^':
  4846|                             $operand1[$row][$column] = $operand1[$row][$column] ** $operand2[$row][$column];
  4847|                             break;
  4848|                         default:
  4849|                             throw new Exception('Unsupported numeric binary operation');
  4850|                     }
  4851|                 }
  4852|             }
  4853|             $result = $operand1;
  4854|         } else {
  4855|             switch ($operation) {
  4856|                 case '+':
  4857|                     $result = $operand1 + $operand2;
  4858|                     break;
  4859|                 case '-':
  4860|                     $result = $operand1 - $operand2;
  4861|                     break;
  4862|                 case '*':
  4863|                     $result = $operand1 * $operand2;
  4864|                     break;
  4865|                 case '/':
  4866|                     if ($operand2 == 0) {
  4867|                         $stack->push('Error', ExcelError::DIV0());
  4868|                         $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails(ExcelError::DIV0()));
  4869|                         return false;
  4870|                     }
  4871|                     $result = $operand1 / $operand2;
  4872|                     break;
  4873|                 case '^':
  4874|                     $result = $operand1 ** $operand2;
  4875|                     break;
  4876|                 default:
  4877|                     throw new Exception('Unsupported numeric binary operation');
  4878|             }
  4879|         }
  4880|         $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
  4881|         $stack->push('Value', $result);
  4882|         return $result;
  4883|     }
  4884|     /**
  4885|      * Trigger an error, but nicely, if need be.
  4886|      *
  4887|      * @return false
  4888|      */
  4889|     protected function raiseFormulaError(string $errorMessage, int $code = 0, ?Throwable $exception = null): bool
  4890|     {
  4891|         $this->formulaError = $errorMessage;
  4892|         $this->cyclicReferenceStack->clear();
  4893|         $suppress = $this->suppressFormulaErrors;
  4894|         if (!$suppress) {
  4895|             throw new Exception($errorMessage, $code, $exception);
  4896|         }
  4897|         return false;
  4898|     }
  4899|     /**
  4900|      * Extract range values.
  4901|      *
  4902|      * @param string $range String based range representation
  4903|      * @param ?Worksheet $worksheet Worksheet
  4904|      * @param bool $resetLog Flag indicating whether calculation log should be reset or not
  4905|      *
  4906|      * @return array Array of values in range if range contains more than one element. Otherwise, a single value is returned.
  4907|      */
  4908|     public function extractCellRange(string &$range = 'A1', ?Worksheet $worksheet = null, bool $resetLog = true): array
  4909|     {
  4910|         $returnValue = [];
  4911|         if ($worksheet !== null) {
  4912|             $worksheetName = $worksheet->getTitle();
  4913|             if (str_contains($range, '!')) {
  4914|                 [$worksheetName, $range] = Worksheet::extractSheetTitle($range, true);
  4915|                 $worksheet = ($this->spreadsheet === null) ? null : $this->spreadsheet->getSheetByName($worksheetName);
  4916|             }
  4917|             $aReferences = Coordinate::extractAllCellReferencesInRange($range);
  4918|             $range = "'" . $worksheetName . "'" . '!' . $range;
  4919|             $currentCol = '';
  4920|             $currentRow = 0;
  4921|             if (!isset($aReferences[1])) {
  4922|                 sscanf($aReferences[0], '%[A-Z]%d', $currentCol, $currentRow);
  4923|                 if ($worksheet !== null && $worksheet->cellExists($aReferences[0])) {
  4924|                     $returnValue[$currentRow][$currentCol] = $worksheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
  4925|                 } else {
  4926|                     $returnValue[$currentRow][$currentCol] = null;
  4927|                 }
  4928|             } else {
  4929|                 foreach ($aReferences as $reference) {
  4930|                     sscanf($reference, '%[A-Z]%d', $currentCol, $currentRow);
  4931|                     if ($worksheet !== null && $worksheet->cellExists($reference)) {
  4932|                         $returnValue[$currentRow][$currentCol] = $worksheet->getCell($reference)->getCalculatedValue($resetLog);
  4933|                     } else {
  4934|                         $returnValue[$currentRow][$currentCol] = null;
  4935|                     }
  4936|                 }
  4937|             }
  4938|         }
  4939|         return $returnValue;
  4940|     }
  4941|     /**
  4942|      * Extract range values.
  4943|      *
  4944|      * @param string $range String based range representation
  4945|      * @param null|Worksheet $worksheet Worksheet
  4946|      * @param bool $resetLog Flag indicating whether calculation log should be reset or not
  4947|      *
  4948|      * @return array|string Array of values in range if range contains more than one element. Otherwise, a single value is returned.
  4949|      */
  4950|     public function extractNamedRange(string &$range = 'A1', ?Worksheet $worksheet = null, bool $resetLog = true): string|array
  4951|     {
  4952|         $returnValue = [];
  4953|         if ($worksheet !== null) {
  4954|             if (str_contains($range, '!')) {
  4955|                 [$worksheetName, $range] = Worksheet::extractSheetTitle($range, true);
  4956|                 $worksheet = ($this->spreadsheet === null) ? null : $this->spreadsheet->getSheetByName($worksheetName);
  4957|             }
  4958|             $namedRange = ($worksheet === null) ? null : DefinedName::resolveName($range, $worksheet);
  4959|             if ($namedRange === null) {
  4960|                 return ExcelError::REF();
  4961|             }
  4962|             $worksheet = $namedRange->getWorksheet();
  4963|             $range = $namedRange->getValue();
  4964|             $splitRange = Coordinate::splitRange($range);
  4965|             if ($worksheet !== null && ctype_alpha($splitRange[0][0])) {
  4966|                 $range = $splitRange[0][0] . '1:' . $splitRange[0][1] . $worksheet->getHighestRow();
  4967|             } elseif ($worksheet !== null && ctype_digit($splitRange[0][0])) {
  4968|                 $range = 'A' . $splitRange[0][0] . ':' . $worksheet->getHighestColumn() . $splitRange[0][1];
  4969|             }
  4970|             $aReferences = Coordinate::extractAllCellReferencesInRange($range);
  4971|             if (!isset($aReferences[1])) {
  4972|                 [$currentCol, $currentRow] = Coordinate::coordinateFromString($aReferences[0]);
  4973|                 if ($worksheet !== null && $worksheet->cellExists($aReferences[0])) {
  4974|                     $returnValue[$currentRow][$currentCol] = $worksheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
  4975|                 } else {
  4976|                     $returnValue[$currentRow][$currentCol] = null;
  4977|                 }
  4978|             } else {
  4979|                 foreach ($aReferences as $reference) {
  4980|                     [$currentCol, $currentRow] = Coordinate::coordinateFromString($reference);
  4981|                     if ($worksheet !== null && $worksheet->cellExists($reference)) {
  4982|                         $returnValue[$currentRow][$currentCol] = $worksheet->getCell($reference)->getCalculatedValue($resetLog);
  4983|                     } else {
  4984|                         $returnValue[$currentRow][$currentCol] = null;
  4985|                     }
  4986|                 }
  4987|             }
  4988|         }
  4989|         return $returnValue;
  4990|     }
  4991|     /**
  4992|      * Is a specific function implemented?
  4993|      *
  4994|      * @param string $function Function Name
  4995|      */
  4996|     public function isImplemented(string $function): bool
  4997|     {
  4998|         $function = strtoupper($function);
  4999|         $notImplemented = !isset(self::$phpSpreadsheetFunctions[$function]) || (is_array(self::$phpSpreadsheetFunctions[$function]['functionCall']) && self::$phpSpreadsheetFunctions[$function]['functionCall'][1] === 'DUMMY');
  5000|         return !$notImplemented;
  5001|     }
  5002|     /**
  5003|      * Get a list of all implemented functions as an array of function objects.
  5004|      */
  5005|     public static function getFunctions(): array
  5006|     {
  5007|         return self::$phpSpreadsheetFunctions;
  5008|     }
  5009|     /**
  5010|      * Get a list of implemented Excel function names.
  5011|      */
  5012|     public function getImplementedFunctionNames(): array
  5013|     {
  5014|         $returnValue = [];
  5015|         foreach (self::$phpSpreadsheetFunctions as $functionName => $function) {
  5016|             if ($this->isImplemented($functionName)) {
  5017|                 $returnValue[] = $functionName;
  5018|             }
  5019|         }
  5020|         return $returnValue;
  5021|     }
  5022|     private function addDefaultArgumentValues(array $functionCall, array $args, array $emptyArguments): array
  5023|     {
  5024|         $reflector = new ReflectionMethod($functionCall[0], $functionCall[1]);
  5025|         $methodArguments = $reflector->getParameters();
  5026|         if (count($methodArguments) > 0) {
  5027|             foreach ($emptyArguments as $argumentId => $isArgumentEmpty) {
  5028|                 if ($isArgumentEmpty === true) {
  5029|                     $reflectedArgumentId = count($args) - (int) $argumentId - 1;
  5030|                     if (
  5031|                         !array_key_exists($reflectedArgumentId, $methodArguments)
  5032|                         || $methodArguments[$reflectedArgumentId]->isVariadic()
  5033|                     ) {
  5034|                         break;
  5035|                     }
  5036|                     $args[$argumentId] = $this->getArgumentDefaultValue($methodArguments[$reflectedArgumentId]);
  5037|                 }
  5038|             }
  5039|         }
  5040|         return $args;
  5041|     }
  5042|     private function getArgumentDefaultValue(ReflectionParameter $methodArgument): mixed
  5043|     {
  5044|         $defaultValue = null;
  5045|         if ($methodArgument->isDefaultValueAvailable()) {
  5046|             $defaultValue = $methodArgument->getDefaultValue();
  5047|             if ($methodArgument->isDefaultValueConstant()) {
  5048|                 $constantName = $methodArgument->getDefaultValueConstantName() ?? '';
  5049|                 if (str_contains($constantName, '::')) {
  5050|                     [$className, $constantName] = explode('::', $constantName);
  5051|                     $constantReflector = new ReflectionClassConstant($className, $constantName);
  5052|                     return $constantReflector->getValue();
  5053|                 }
  5054|                 return constant($constantName);
  5055|             }
  5056|         }
  5057|         return $defaultValue;
  5058|     }
  5059|     /**
  5060|      * Add cell reference if needed while making sure that it is the last argument.
  5061|      */
  5062|     private function addCellReference(array $args, bool $passCellReference, array|string $functionCall, ?Cell $cell = null): array
  5063|     {
  5064|         if ($passCellReference) {
  5065|             if (is_array($functionCall)) {
  5066|                 $className = $functionCall[0];
  5067|                 $methodName = $functionCall[1];
  5068|                 $reflectionMethod = new ReflectionMethod($className, $methodName);
  5069|                 $argumentCount = count($reflectionMethod->getParameters());
  5070|                 while (count($args) < $argumentCount - 1) {
  5071|                     $args[] = null;
  5072|                 }
  5073|             }
  5074|             $args[] = $cell;
  5075|         }
  5076|         return $args;
  5077|     }
  5078|     private function evaluateDefinedName(Cell $cell, DefinedName $namedRange, Worksheet $cellWorksheet, Stack $stack): mixed
  5079|     {
  5080|         $definedNameScope = $namedRange->getScope();
  5081|         if ($definedNameScope !== null && $definedNameScope !== $cellWorksheet) {
  5082|             $result = ExcelError::REF();
  5083|             $stack->push('Error', $result, $namedRange->getName());
  5084|             return $result;
  5085|         }
  5086|         $definedNameValue = $namedRange->getValue();
  5087|         $definedNameType = $namedRange->isFormula() ? 'Formula' : 'Range';
  5088|         $definedNameWorksheet = $namedRange->getWorksheet();
  5089|         if ($definedNameValue[0] !== '=') {
  5090|             $definedNameValue = '=' . $definedNameValue;
  5091|         }
  5092|         $this->debugLog->writeDebugLog('Defined Name is a %s with a value of %s', $definedNameType, $definedNameValue);
  5093|         $originalCoordinate = $cell->getCoordinate();
  5094|         $recursiveCalculationCell = ($definedNameType !== 'Formula' && $definedNameWorksheet !== null && $definedNameWorksheet !== $cellWorksheet)
  5095|             ? $definedNameWorksheet->getCell('A1')
  5096|             : $cell;
  5097|         $recursiveCalculationCellAddress = $recursiveCalculationCell->getCoordinate();
  5098|         $definedNameValue = self::$referenceHelper->updateFormulaReferencesAnyWorksheet(
  5099|             $definedNameValue,
  5100|             Coordinate::columnIndexFromString($cell->getColumn()) - 1,
  5101|             $cell->getRow() - 1
  5102|         );
  5103|         $this->debugLog->writeDebugLog('Value adjusted for relative references is %s', $definedNameValue);
  5104|         $recursiveCalculator = new self($this->spreadsheet);
  5105|         $recursiveCalculator->getDebugLog()->setWriteDebugLog($this->getDebugLog()->getWriteDebugLog());
  5106|         $recursiveCalculator->getDebugLog()->setEchoDebugLog($this->getDebugLog()->getEchoDebugLog());
  5107|         $result = $recursiveCalculator->_calculateFormulaValue($definedNameValue, $recursiveCalculationCellAddress, $recursiveCalculationCell, true);
  5108|         $cellWorksheet->getCell($originalCoordinate);
  5109|         if ($this->getDebugLog()->getWriteDebugLog()) {
  5110|             $this->debugLog->mergeDebugLog(array_slice($recursiveCalculator->getDebugLog()->getLog(), 3));
  5111|             $this->debugLog->writeDebugLog('Evaluation Result for Named %s %s is %s', $definedNameType, $namedRange->getName(), $this->showTypeDetails($result));
  5112|         }
  5113|         $stack->push('Defined Name', $result, $namedRange->getName());
  5114|         return $result;
  5115|     }
  5116|     public function setSuppressFormulaErrors(bool $suppressFormulaErrors): void
  5117|     {
  5118|         $this->suppressFormulaErrors = $suppressFormulaErrors;
  5119|     }
  5120|     public function getSuppressFormulaErrors(): bool
  5121|     {
  5122|         return $this->suppressFormulaErrors;
  5123|     }
  5124|     private static function boolToString(mixed $operand1): mixed
  5125|     {
  5126|         if (is_bool($operand1)) {
  5127|             $operand1 = ($operand1) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
  5128|         } elseif ($operand1 === null) {
  5129|             $operand1 = '';
  5130|         }
  5131|         return $operand1;
  5132|     }
  5133|     private static function isNumericOrBool(mixed $operand): bool
  5134|     {
  5135|         return is_numeric($operand) || is_bool($operand);
  5136|     }
  5137|     private static function makeError(mixed $operand = ''): string
  5138|     {
  5139|         return Information\ErrorValue::isError($operand) ? $operand : ExcelError::VALUE();
  5140|     }
  5141| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/Functions.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-271 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation;
     3| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     4| use PhpOffice\PhpSpreadsheet\Shared\Date;
     5| class Functions
     6| {
     7|     const PRECISION = 8.88E-016;
     8|     /**
     9|      * 2 / PI.
    10|      */
    11|     const M_2DIVPI = 0.63661977236758134307553505349006;
    12|     const COMPATIBILITY_EXCEL = 'Excel';
    13|     const COMPATIBILITY_GNUMERIC = 'Gnumeric';
    14|     const COMPATIBILITY_OPENOFFICE = 'OpenOfficeCalc';
    15|     /** Use of RETURNDATE_PHP_NUMERIC is discouraged - not 32-bit Y2038-safe, no timezone. */
    16|     const RETURNDATE_PHP_NUMERIC = 'P';
    17|     /** Use of RETURNDATE_UNIX_TIMESTAMP is discouraged - not 32-bit Y2038-safe, no timezone. */
    18|     const RETURNDATE_UNIX_TIMESTAMP = 'P';
    19|     const RETURNDATE_PHP_OBJECT = 'O';
    20|     const RETURNDATE_PHP_DATETIME_OBJECT = 'O';
    21|     const RETURNDATE_EXCEL = 'E';
    22|     public const NOT_YET_IMPLEMENTED = '#Not Yet Implemented';
    23|     /**
    24|      * Compatibility mode to use for error checking and responses.
    25|      */
    26|     protected static string $compatibilityMode = self::COMPATIBILITY_EXCEL;
    27|     /**
    28|      * Data Type to use when returning date values.
    29|      */
    30|     protected static string $returnDateType = self::RETURNDATE_EXCEL;
    31|     /**
    32|      * Set the Compatibility Mode.
    33|      *
    34|      * @param string $compatibilityMode Compatibility Mode
    35|      *                                  Permitted values are:
    36|      *                                      Functions::COMPATIBILITY_EXCEL        'Excel'
    37|      *                                      Functions::COMPATIBILITY_GNUMERIC     'Gnumeric'
    38|      *                                      Functions::COMPATIBILITY_OPENOFFICE   'OpenOfficeCalc'
    39|      *
    40|      * @return bool (Success or Failure)
    41|      */
    42|     public static function setCompatibilityMode(string $compatibilityMode): bool
    43|     {
    44|         if (
    45|             ($compatibilityMode == self::COMPATIBILITY_EXCEL)
    46|             || ($compatibilityMode == self::COMPATIBILITY_GNUMERIC)
    47|             || ($compatibilityMode == self::COMPATIBILITY_OPENOFFICE)
    48|         ) {
    49|             self::$compatibilityMode = $compatibilityMode;
    50|             return true;
    51|         }
    52|         return false;
    53|     }
    54|     /**
    55|      * Return the current Compatibility Mode.
    56|      *
    57|      * @return string Compatibility Mode
    58|      *                Possible Return values are:
    59|      *                    Functions::COMPATIBILITY_EXCEL        'Excel'
    60|      *                    Functions::COMPATIBILITY_GNUMERIC     'Gnumeric'
    61|      *                    Functions::COMPATIBILITY_OPENOFFICE   'OpenOfficeCalc'
    62|      */
    63|     public static function getCompatibilityMode(): string
    64|     {
    65|         return self::$compatibilityMode;
    66|     }
    67|     /**
    68|      * Set the Return Date Format used by functions that return a date/time (Excel, PHP Serialized Numeric or PHP DateTime Object).
    69|      *
    70|      * @param string $returnDateType Return Date Format
    71|      *                               Permitted values are:
    72|      *                                   Functions::RETURNDATE_UNIX_TIMESTAMP       'P'
    73|      *                                   Functions::RETURNDATE_PHP_DATETIME_OBJECT  'O'
    74|      *                                   Functions::RETURNDATE_EXCEL                'E'
    75|      *
    76|      * @return bool Success or failure
    77|      */
    78|     public static function setReturnDateType(string $returnDateType): bool
    79|     {
    80|         if (
    81|             ($returnDateType == self::RETURNDATE_UNIX_TIMESTAMP)
    82|             || ($returnDateType == self::RETURNDATE_PHP_DATETIME_OBJECT)
    83|             || ($returnDateType == self::RETURNDATE_EXCEL)
    84|         ) {
    85|             self::$returnDateType = $returnDateType;
    86|             return true;
    87|         }
    88|         return false;
    89|     }
    90|     /**
    91|      * Return the current Return Date Format for functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object).
    92|      *
    93|      * @return string Return Date Format
    94|      *                Possible Return values are:
    95|      *                    Functions::RETURNDATE_UNIX_TIMESTAMP         'P'
    96|      *                    Functions::RETURNDATE_PHP_DATETIME_OBJECT    'O'
    97|      *                    Functions::RETURNDATE_EXCEL            '     'E'
    98|      */
    99|     public static function getReturnDateType(): string
   100|     {
   101|         return self::$returnDateType;
   102|     }
   103|     /**
   104|      * DUMMY.
   105|      *
   106|      * @return string #Not Yet Implemented
   107|      */
   108|     public static function DUMMY(): string
   109|     {
   110|         return self::NOT_YET_IMPLEMENTED;
   111|     }
   112|     public static function isMatrixValue(mixed $idx): bool
   113|     {
   114|         return (substr_count($idx, '.') <= 1) || (preg_match('/\.[A-Z]/', $idx) > 0);
   115|     }
   116|     public static function isValue(mixed $idx): bool
   117|     {
   118|         return substr_count($idx, '.') === 0;
   119|     }
   120|     public static function isCellValue(mixed $idx): bool
   121|     {
   122|         return substr_count($idx, '.') > 1;
   123|     }
   124|     public static function ifCondition(mixed $condition): string
   125|     {
   126|         $condition = self::flattenSingleValue($condition);
   127|         if ($condition === '' || $condition === null) {
   128|             return '=""';
   129|         }
   130|         if (!is_string($condition) || !in_array($condition[0], ['>', '<', '='], true)) {
   131|             $condition = self::operandSpecialHandling($condition);
   132|             if (is_bool($condition)) {
   133|                 return '=' . ($condition ? 'TRUE' : 'FALSE');
   134|             } elseif (!is_numeric($condition)) {
   135|                 if ($condition !== '""') { // Not an empty string
   136|                     $condition = (string) preg_replace('/"/ui', '""', $condition);
   137|                 }
   138|                 $condition = Calculation::wrapResult(strtoupper($condition));
   139|             }
   140|             return str_replace('""""', '""', '=' . $condition);
   141|         }
   142|         preg_match('/(=|<[>=]?|>=?)(.*)/', $condition, $matches);
   143|         [, $operator, $operand] = $matches;
   144|         $operand = self::operandSpecialHandling($operand);
   145|         if (is_numeric(trim($operand, '"'))) {
   146|             $operand = trim($operand, '"');
   147|         } elseif (!is_numeric($operand) && $operand !== 'FALSE' && $operand !== 'TRUE') {
   148|             $operand = str_replace('"', '""', $operand);
   149|             $operand = Calculation::wrapResult(strtoupper($operand));
   150|         }
   151|         return str_replace('""""', '""', $operator . $operand);
   152|     }
   153|     private static function operandSpecialHandling(mixed $operand): mixed
   154|     {
   155|         if (is_numeric($operand) || is_bool($operand)) {
   156|             return $operand;
   157|         } elseif (strtoupper($operand) === Calculation::getTRUE() || strtoupper($operand) === Calculation::getFALSE()) {
   158|             return strtoupper($operand);
   159|         }
   160|         if (preg_match('/^\-?\d*\.?\d*\s?\%$/', $operand)) {
   161|             return ((float) rtrim($operand, '%')) / 100;
   162|         }
   163|         if (($dateValueOperand = Date::stringToExcel($operand)) !== false) {
   164|             return $dateValueOperand;
   165|         }
   166|         return $operand;
   167|     }
   168|     /**
   169|      * Convert a multi-dimensional array to a simple 1-dimensional array.
   170|      *
   171|      * @param mixed $array Array to be flattened
   172|      *
   173|      * @return array Flattened array
   174|      */
   175|     public static function flattenArray(mixed $array): array
   176|     {
   177|         if (!is_array($array)) {
   178|             return (array) $array;
   179|         }
   180|         $flattened = [];
   181|         $stack = array_values($array);
   182|         while (!empty($stack)) {
   183|             $value = array_shift($stack);
   184|             if (is_array($value)) {
   185|                 array_unshift($stack, ...array_values($value));
   186|             } else {
   187|                 $flattened[] = $value;
   188|             }
   189|         }
   190|         return $flattened;
   191|     }
   192|     public static function scalar(mixed $value): mixed
   193|     {
   194|         if (!is_array($value)) {
   195|             return $value;
   196|         }
   197|         do {
   198|             $value = array_pop($value);
   199|         } while (is_array($value));
   200|         return $value;
   201|     }
   202|     /**
   203|      * Convert a multi-dimensional array to a simple 1-dimensional array, but retain an element of indexing.
   204|      *
   205|      * @param array|mixed $array Array to be flattened
   206|      *
   207|      * @return array Flattened array
   208|      */
   209|     public static function flattenArrayIndexed($array): array
   210|     {
   211|         if (!is_array($array)) {
   212|             return (array) $array;
   213|         }
   214|         $arrayValues = [];
   215|         foreach ($array as $k1 => $value) {
   216|             if (is_array($value)) {
   217|                 foreach ($value as $k2 => $val) {
   218|                     if (is_array($val)) {
   219|                         foreach ($val as $k3 => $v) {
   220|                             $arrayValues[$k1 . '.' . $k2 . '.' . $k3] = $v;
   221|                         }
   222|                     } else {
   223|                         $arrayValues[$k1 . '.' . $k2] = $val;
   224|                     }
   225|                 }
   226|             } else {
   227|                 $arrayValues[$k1] = $value;
   228|             }
   229|         }
   230|         return $arrayValues;
   231|     }
   232|     /**
   233|      * Convert an array to a single scalar value by extracting the first element.
   234|      *
   235|      * @param mixed $value Array or scalar value
   236|      */
   237|     public static function flattenSingleValue(mixed $value): mixed
   238|     {
   239|         while (is_array($value)) {
   240|             $value = array_shift($value);
   241|         }
   242|         return $value;
   243|     }
   244|     public static function expandDefinedName(string $coordinate, Cell $cell): string
   245|     {
   246|         $worksheet = $cell->getWorksheet();
   247|         $spreadsheet = $worksheet->getParentOrThrow();
   248|         $pCoordinatex = strtoupper($coordinate);
   249|         $pCoordinatex = (string) preg_replace('/^=/', '', $pCoordinatex);
   250|         $defined = $spreadsheet->getDefinedName($pCoordinatex, $worksheet);
   251|         if ($defined !== null) {
   252|             $worksheet2 = $defined->getWorkSheet();
   253|             if (!$defined->isFormula() && $worksheet2 !== null) {
   254|                 $coordinate = "'" . $worksheet2->getTitle() . "'!"
   255|                     . (string) preg_replace('/^=/', '', str_replace('$', '', $defined->getValue()));
   256|             }
   257|         }
   258|         return $coordinate;
   259|     }
   260|     public static function trimTrailingRange(string $coordinate): string
   261|     {
   262|         return (string) preg_replace('/:[\\w\$]+$/', '', $coordinate);
   263|     }
   264|     public static function trimSheetFromCellReference(string $coordinate): string
   265|     {
   266|         if (str_contains($coordinate, '!')) {
   267|             $coordinate = substr($coordinate, strrpos($coordinate, '!') + 1);
   268|         }
   269|         return $coordinate;
   270|     }
   271| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/Information/ErrorValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\Information;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     5| class ErrorValue
     6| {
     7|     use ArrayEnabled;
     8|     /**
     9|      * IS_ERR.
    10|      *
    11|      * @param mixed $value Value to check
    12|      *                      Or can be an array of values
    13|      *
    14|      * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
    15|      *            with the same dimensions
    16|      */
    17|     public static function isErr(mixed $value = ''): array|bool
    18|     {
    19|         if (is_array($value)) {
    20|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
    21|         }
    22|         return self::isError($value) && (!self::isNa(($value)));
    23|     }
    24|     /**
    25|      * IS_ERROR.
    26|      *
    27|      * @param mixed $value Value to check
    28|      *                      Or can be an array of values
    29|      *
    30|      * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
    31|      *            with the same dimensions
    32|      */
    33|     public static function isError(mixed $value = '', bool $tryNotImplemented = false): array|bool
    34|     {
    35|         if (is_array($value)) {
    36|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
    37|         }
    38|         if (!is_string($value)) {
    39|             return false;
    40|         }
    41|         if ($tryNotImplemented && $value === Functions::NOT_YET_IMPLEMENTED) {
    42|             return true;
    43|         }
    44|         return in_array($value, ExcelError::ERROR_CODES, true);
    45|     }
    46|     /**
    47|      * IS_NA.
    48|      *
    49|      * @param mixed $value Value to check
    50|      *                      Or can be an array of values
    51|      *
    52|      * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
    53|      *            with the same dimensions
    54|      */
    55|     public static function isNa(mixed $value = ''): array|bool
    56|     {
    57|         if (is_array($value)) {
    58|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
    59|         }
    60|         return $value === ExcelError::NA();
    61|     }
    62| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/LookupRef/Matrix.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-124 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\LookupRef;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     6| class Matrix
     7| {
     8|     use ArrayEnabled;
     9|     /**
    10|      * Helper function; NOT an implementation of any Excel Function.
    11|      */
    12|     public static function isColumnVector(array $values): bool
    13|     {
    14|         return count($values, COUNT_RECURSIVE) === (count($values, COUNT_NORMAL) * 2);
    15|     }
    16|     /**
    17|      * Helper function; NOT an implementation of any Excel Function.
    18|      */
    19|     public static function isRowVector(array $values): bool
    20|     {
    21|         return count($values, COUNT_RECURSIVE) > 1
    22|             && (count($values, COUNT_NORMAL) === 1 || count($values, COUNT_RECURSIVE) === count($values, COUNT_NORMAL));
    23|     }
    24|     /**
    25|      * TRANSPOSE.
    26|      *
    27|      * @param array|mixed $matrixData A matrix of values
    28|      */
    29|     public static function transpose($matrixData): array
    30|     {
    31|         $returnMatrix = [];
    32|         if (!is_array($matrixData)) {
    33|             $matrixData = [[$matrixData]];
    34|         }
    35|         $column = 0;
    36|         foreach ($matrixData as $matrixRow) {
    37|             $row = 0;
    38|             foreach ($matrixRow as $matrixCell) {
    39|                 $returnMatrix[$row][$column] = $matrixCell;
    40|                 ++$row;
    41|             }
    42|             ++$column;
    43|         }
    44|         return $returnMatrix;
    45|     }
    46|     /**
    47|      * INDEX.
    48|      *
    49|      * Uses an index to choose a value from a reference or array
    50|      *
    51|      * Excel Function:
    52|      *        =INDEX(range_array, row_num, [column_num], [area_num])
    53|      *
    54|      * @param mixed $matrix A range of cells or an array constant
    55|      * @param mixed $rowNum The row in the array or range from which to return a value.
    56|      *                          If row_num is omitted, column_num is required.
    57|      *                      Or can be an array of values
    58|      * @param mixed $columnNum The column in the array or range from which to return a value.
    59|      *                          If column_num is omitted, row_num is required.
    60|      *                      Or can be an array of values
    61|      *
    62|      * TODO Provide support for area_num, currently not supported
    63|      *
    64|      * @return mixed the value of a specified cell or array of cells
    65|      *         If an array of values is passed as the $rowNum and/or $columnNum arguments, then the returned result
    66|      *            will also be an array with the same dimensions
    67|      */
    68|     public static function index(mixed $matrix, mixed $rowNum = 0, mixed $columnNum = null): mixed
    69|     {
    70|         if (is_array($rowNum) || is_array($columnNum)) {
    71|             return self::evaluateArrayArgumentsSubsetFrom([self::class, __FUNCTION__], 1, $matrix, $rowNum, $columnNum);
    72|         }
    73|         $rowNum = $rowNum ?? 0;
    74|         $columnNum = $columnNum ?? 0;
    75|         try {
    76|             $rowNum = LookupRefValidations::validatePositiveInt($rowNum);
    77|             $columnNum = LookupRefValidations::validatePositiveInt($columnNum);
    78|         } catch (Exception $e) {
    79|             return $e->getMessage();
    80|         }
    81|         if (is_array($matrix) && count($matrix) === 1 && $rowNum > 1) {
    82|             $matrixKey = array_keys($matrix)[0];
    83|             if (is_array($matrix[$matrixKey])) {
    84|                 $tempMatrix = [];
    85|                 foreach ($matrix[$matrixKey] as $key => $value) {
    86|                     $tempMatrix[$key] = [$value];
    87|                 }
    88|                 $matrix = $tempMatrix;
    89|             }
    90|         }
    91|         if (!is_array($matrix) || ($rowNum > count($matrix))) {
    92|             return ExcelError::REF();
    93|         }
    94|         $rowKeys = array_keys($matrix);
    95|         $columnKeys = @array_keys($matrix[$rowKeys[0]]);
    96|         if ($columnNum > count($columnKeys)) {
    97|             return ExcelError::REF();
    98|         }
    99|         if ($columnNum === 0) {
   100|             return self::extractRowValue($matrix, $rowKeys, $rowNum);
   101|         }
   102|         $columnNum = $columnKeys[--$columnNum];
   103|         if ($rowNum === 0) {
   104|             return array_map(
   105|                 fn ($value): array => [$value],
   106|                 array_column($matrix, $columnNum)
   107|             );
   108|         }
   109|         $rowNum = $rowKeys[--$rowNum];
   110|         return $matrix[$rowNum][$columnNum];
   111|     }
   112|     private static function extractRowValue(array $matrix, array $rowKeys, int $rowNum): mixed
   113|     {
   114|         if ($rowNum === 0) {
   115|             return $matrix;
   116|         }
   117|         $rowNum = $rowKeys[--$rowNum];
   118|         $row = $matrix[$rowNum];
   119|         if (is_array($row)) {
   120|             return [$rowNum => $row];
   121|         }
   122|         return $row;
   123|     }
   124| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/MathTrig/Operations.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-131 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\MathTrig;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     7| class Operations
     8| {
     9|     use ArrayEnabled;
    10|     /**
    11|      * MOD.
    12|      *
    13|      * @param mixed $dividend Dividend
    14|      *                      Or can be an array of values
    15|      * @param mixed $divisor Divisor
    16|      *                      Or can be an array of values
    17|      *
    18|      * @return array|float|string Remainder, or a string containing an error
    19|      *         If an array of numbers is passed as an argument, then the returned result will also be an array
    20|      *            with the same dimensions
    21|      */
    22|     public static function mod(mixed $dividend, mixed $divisor): array|string|float
    23|     {
    24|         if (is_array($dividend) || is_array($divisor)) {
    25|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $dividend, $divisor);
    26|         }
    27|         try {
    28|             $dividend = Helpers::validateNumericNullBool($dividend);
    29|             $divisor = Helpers::validateNumericNullBool($divisor);
    30|             Helpers::validateNotZero($divisor);
    31|         } catch (Exception $e) {
    32|             return $e->getMessage();
    33|         }
    34|         if (($dividend < 0.0) && ($divisor > 0.0)) {
    35|             return $divisor - fmod(abs($dividend), $divisor);
    36|         }
    37|         if (($dividend > 0.0) && ($divisor < 0.0)) {
    38|             return $divisor + fmod($dividend, abs($divisor));
    39|         }
    40|         return fmod($dividend, $divisor);
    41|     }
    42|     /**
    43|      * POWER.
    44|      *
    45|      * Computes x raised to the power y.
    46|      *
    47|      * @param null|array|bool|float|int|string $x Or can be an array of values
    48|      * @param null|array|bool|float|int|string $y Or can be an array of values
    49|      *
    50|      * @return array|float|int|string The result, or a string containing an error
    51|      *         If an array of numbers is passed as an argument, then the returned result will also be an array
    52|      *            with the same dimensions
    53|      */
    54|     public static function power(null|array|bool|float|int|string $x, null|array|bool|float|int|string $y): array|float|int|string
    55|     {
    56|         if (is_array($x) || is_array($y)) {
    57|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $x, $y);
    58|         }
    59|         try {
    60|             $x = Helpers::validateNumericNullBool($x);
    61|             $y = Helpers::validateNumericNullBool($y);
    62|         } catch (Exception $e) {
    63|             return $e->getMessage();
    64|         }
    65|         if (!$x && !$y) {
    66|             return ExcelError::NAN();
    67|         }
    68|         if (!$x && $y < 0.0) {
    69|             return ExcelError::DIV0();
    70|         }
    71|         $result = $x ** $y;
    72|         return Helpers::numberOrNan($result);
    73|     }
    74|     /**
    75|      * PRODUCT.
    76|      *
    77|      * PRODUCT returns the product of all the values and cells referenced in the argument list.
    78|      *
    79|      * Excel Function:
    80|      *        PRODUCT(value1[,value2[, ...]])
    81|      *
    82|      * @param mixed ...$args Data values
    83|      */
    84|     public static function product(mixed ...$args): string|float
    85|     {
    86|         $args = array_filter(
    87|             Functions::flattenArray($args),
    88|             fn ($value): bool => $value !== null
    89|         );
    90|         $returnValue = (count($args) === 0) ? 0.0 : 1.0;
    91|         foreach ($args as $arg) {
    92|             if (is_numeric($arg)) {
    93|                 $returnValue *= $arg;
    94|             } else {
    95|                 return ExcelError::throwError($arg);
    96|             }
    97|         }
    98|         return (float) $returnValue;
    99|     }
   100|     /**
   101|      * QUOTIENT.
   102|      *
   103|      * QUOTIENT function returns the integer portion of a division. Numerator is the divided number
   104|      *        and denominator is the divisor.
   105|      *
   106|      * Excel Function:
   107|      *        QUOTIENT(value1,value2)
   108|      *
   109|      * @param mixed $numerator Expect float|int
   110|      *                      Or can be an array of values
   111|      * @param mixed $denominator Expect float|int
   112|      *                      Or can be an array of values
   113|      *
   114|      * @return array|int|string If an array of numbers is passed as an argument, then the returned result will also be an array
   115|      *            with the same dimensions
   116|      */
   117|     public static function quotient(mixed $numerator, mixed $denominator): array|string|int
   118|     {
   119|         if (is_array($numerator) || is_array($denominator)) {
   120|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $numerator, $denominator);
   121|         }
   122|         try {
   123|             $numerator = Helpers::validateNumericNullSubstitution($numerator, 0);
   124|             $denominator = Helpers::validateNumericNullSubstitution($denominator, 0);
   125|             Helpers::validateNotZero($denominator);
   126|         } catch (Exception $e) {
   127|             return $e->getMessage();
   128|         }
   129|         return (int) ($numerator / $denominator);
   130|     }
   131| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/CaseConvert.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     5| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     6| class CaseConvert
     7| {
     8|     use ArrayEnabled;
     9|     /**
    10|      * LOWERCASE.
    11|      *
    12|      * Converts a string value to upper case.
    13|      *
    14|      * @param mixed $mixedCaseValue The string value to convert to lower case
    15|      *                              Or can be an array of values
    16|      *
    17|      * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
    18|      *            with the same dimensions
    19|      */
    20|     public static function lower(mixed $mixedCaseValue): array|string
    21|     {
    22|         if (is_array($mixedCaseValue)) {
    23|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
    24|         }
    25|         try {
    26|             $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
    27|         } catch (CalcExp $e) {
    28|             return $e->getMessage();
    29|         }
    30|         return StringHelper::strToLower($mixedCaseValue);
    31|     }
    32|     /**
    33|      * UPPERCASE.
    34|      *
    35|      * Converts a string value to upper case.
    36|      *
    37|      * @param mixed $mixedCaseValue The string value to convert to upper case
    38|      *                              Or can be an array of values
    39|      *
    40|      * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
    41|      *            with the same dimensions
    42|      */
    43|     public static function upper(mixed $mixedCaseValue): array|string
    44|     {
    45|         if (is_array($mixedCaseValue)) {
    46|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
    47|         }
    48|         try {
    49|             $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
    50|         } catch (CalcExp $e) {
    51|             return $e->getMessage();
    52|         }
    53|         return StringHelper::strToUpper($mixedCaseValue);
    54|     }
    55|     /**
    56|      * PROPERCASE.
    57|      *
    58|      * Converts a string value to proper or title case.
    59|      *
    60|      * @param mixed $mixedCaseValue The string value to convert to title case
    61|      *                              Or can be an array of values
    62|      *
    63|      * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
    64|      *            with the same dimensions
    65|      */
    66|     public static function proper(mixed $mixedCaseValue): array|string
    67|     {
    68|         if (is_array($mixedCaseValue)) {
    69|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
    70|         }
    71|         try {
    72|             $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
    73|         } catch (CalcExp $e) {
    74|             return $e->getMessage();
    75|         }
    76|         return StringHelper::strToTitle($mixedCaseValue);
    77|     }
    78| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/CharacterConvert.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     7| class CharacterConvert
     8| {
     9|     use ArrayEnabled;
    10|     /**
    11|      * CHAR.
    12|      *
    13|      * @param mixed $character Integer Value to convert to its character representation
    14|      *                              Or can be an array of values
    15|      *
    16|      * @return array|string The character string
    17|      *         If an array of values is passed as the argument, then the returned result will also be an array
    18|      *            with the same dimensions
    19|      */
    20|     public static function character(mixed $character): array|string
    21|     {
    22|         if (is_array($character)) {
    23|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $character);
    24|         }
    25|         try {
    26|             $character = Helpers::validateInt($character, true);
    27|         } catch (CalcExp $e) {
    28|             return $e->getMessage();
    29|         }
    30|         $min = Functions::getCompatibilityMode() === Functions::COMPATIBILITY_OPENOFFICE ? 0 : 1;
    31|         if ($character < $min || $character > 255) {
    32|             return ExcelError::VALUE();
    33|         }
    34|         $result = iconv('UCS-4LE', 'UTF-8', pack('V', $character));
    35|         return ($result === false) ? '' : $result;
    36|     }
    37|     /**
    38|      * CODE.
    39|      *
    40|      * @param mixed $characters String character to convert to its ASCII value
    41|      *                              Or can be an array of values
    42|      *
    43|      * @return array|int|string A string if arguments are invalid
    44|      *         If an array of values is passed as the argument, then the returned result will also be an array
    45|      *            with the same dimensions
    46|      */
    47|     public static function code(mixed $characters): array|string|int
    48|     {
    49|         if (is_array($characters)) {
    50|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $characters);
    51|         }
    52|         try {
    53|             $characters = Helpers::extractString($characters, true);
    54|         } catch (CalcExp $e) {
    55|             return $e->getMessage();
    56|         }
    57|         if ($characters === '') {
    58|             return ExcelError::VALUE();
    59|         }
    60|         $character = $characters;
    61|         if (mb_strlen($characters, 'UTF-8') > 1) {
    62|             $character = mb_substr($characters, 0, 1, 'UTF-8');
    63|         }
    64|         return self::unicodeToOrd($character);
    65|     }
    66|     private static function unicodeToOrd(string $character): int
    67|     {
    68|         $retVal = 0;
    69|         $iconv = iconv('UTF-8', 'UCS-4LE', $character);
    70|         if ($iconv !== false) {
    71|             $result = unpack('V', $iconv);
    72|             if (is_array($result) && isset($result[1])) {
    73|                 $retVal = $result[1];
    74|             }
    75|         }
    76|         return $retVal;
    77|     }
    78| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Concatenate.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-116 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     7| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     8| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     9| class Concatenate
    10| {
    11|     use ArrayEnabled;
    12|     /**
    13|      * CONCATENATE.
    14|      *
    15|      * @param array $args
    16|      */
    17|     public static function CONCATENATE(...$args): string
    18|     {
    19|         $returnValue = '';
    20|         $aArgs = Functions::flattenArray($args);
    21|         foreach ($aArgs as $arg) {
    22|             $value = Helpers::extractString($arg);
    23|             if (ErrorValue::isError($value, true)) {
    24|                 $returnValue = $value;
    25|                 break;
    26|             }
    27|             $returnValue .= Helpers::extractString($arg);
    28|             if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
    29|                 $returnValue = ExcelError::CALC();
    30|                 break;
    31|             }
    32|         }
    33|         return $returnValue;
    34|     }
    35|     /**
    36|      * TEXTJOIN.
    37|      *
    38|      * @param mixed $delimiter The delimter to use between the joined arguments
    39|      *                         Or can be an array of values
    40|      * @param mixed $ignoreEmpty true/false Flag indicating whether empty arguments should be skipped
    41|      *                         Or can be an array of values
    42|      * @param mixed $args The values to join
    43|      *
    44|      * @return array|string The joined string
    45|      *         If an array of values is passed for the $delimiter or $ignoreEmpty arguments, then the returned result
    46|      *            will also be an array with matching dimensions
    47|      */
    48|     public static function TEXTJOIN(mixed $delimiter = '', mixed $ignoreEmpty = true, mixed ...$args): array|string
    49|     {
    50|         if (is_array($delimiter) || is_array($ignoreEmpty)) {
    51|             return self::evaluateArrayArgumentsSubset(
    52|                 [self::class, __FUNCTION__],
    53|                 2,
    54|                 $delimiter,
    55|                 $ignoreEmpty,
    56|                 ...$args
    57|             );
    58|         }
    59|         $delimiter ??= '';
    60|         $ignoreEmpty ??= true;
    61|         $aArgs = Functions::flattenArray($args);
    62|         $returnValue = self::evaluateTextJoinArray($ignoreEmpty, $aArgs);
    63|         $returnValue ??= implode($delimiter, $aArgs);
    64|         if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
    65|             $returnValue = ExcelError::CALC();
    66|         }
    67|         return $returnValue;
    68|     }
    69|     private static function evaluateTextJoinArray(bool $ignoreEmpty, array &$aArgs): ?string
    70|     {
    71|         foreach ($aArgs as $key => &$arg) {
    72|             $value = Helpers::extractString($arg);
    73|             if (ErrorValue::isError($value, true)) {
    74|                 return $value;
    75|             }
    76|             if ($ignoreEmpty === true && ((is_string($arg) && trim($arg) === '') || $arg === null)) {
    77|                 unset($aArgs[$key]);
    78|             } elseif (is_bool($arg)) {
    79|                 $arg = Helpers::convertBooleanValue($arg);
    80|             }
    81|         }
    82|         return null;
    83|     }
    84|     /**
    85|      * REPT.
    86|      *
    87|      * Returns the result of builtin function round after validating args.
    88|      *
    89|      * @param mixed $stringValue The value to repeat
    90|      *                         Or can be an array of values
    91|      * @param mixed $repeatCount The number of times the string value should be repeated
    92|      *                         Or can be an array of values
    93|      *
    94|      * @return array|string The repeated string
    95|      *         If an array of values is passed for the $stringValue or $repeatCount arguments, then the returned result
    96|      *            will also be an array with matching dimensions
    97|      */
    98|     public static function builtinREPT(mixed $stringValue, mixed $repeatCount): array|string
    99|     {
   100|         if (is_array($stringValue) || is_array($repeatCount)) {
   101|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $stringValue, $repeatCount);
   102|         }
   103|         $stringValue = Helpers::extractString($stringValue);
   104|         if (!is_numeric($repeatCount) || $repeatCount < 0) {
   105|             $returnValue = ExcelError::VALUE();
   106|         } elseif (ErrorValue::isError($stringValue, true)) {
   107|             $returnValue = $stringValue;
   108|         } else {
   109|             $returnValue = str_repeat($stringValue, (int) $repeatCount);
   110|             if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
   111|                 $returnValue = ExcelError::VALUE(); // note VALUE not CALC
   112|             }
   113|         }
   114|         return $returnValue;
   115|     }
   116| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Extract.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-244 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     7| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     8| class Extract
     9| {
    10|     use ArrayEnabled;
    11|     /**
    12|      * LEFT.
    13|      *
    14|      * @param mixed $value String value from which to extract characters
    15|      *                         Or can be an array of values
    16|      * @param mixed $chars The number of characters to extract (as an integer)
    17|      *                         Or can be an array of values
    18|      *
    19|      * @return array|string The joined string
    20|      *         If an array of values is passed for the $value or $chars arguments, then the returned result
    21|      *            will also be an array with matching dimensions
    22|      */
    23|     public static function left(mixed $value, mixed $chars = 1): array|string
    24|     {
    25|         if (is_array($value) || is_array($chars)) {
    26|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $chars);
    27|         }
    28|         try {
    29|             $value = Helpers::extractString($value, true);
    30|             $chars = Helpers::extractInt($chars, 0, 1);
    31|         } catch (CalcExp $e) {
    32|             return $e->getMessage();
    33|         }
    34|         return mb_substr($value, 0, $chars, 'UTF-8');
    35|     }
    36|     /**
    37|      * MID.
    38|      *
    39|      * @param mixed $value String value from which to extract characters
    40|      *                         Or can be an array of values
    41|      * @param mixed $start Integer offset of the first character that we want to extract
    42|      *                         Or can be an array of values
    43|      * @param mixed $chars The number of characters to extract (as an integer)
    44|      *                         Or can be an array of values
    45|      *
    46|      * @return array|string The joined string
    47|      *         If an array of values is passed for the $value, $start or $chars arguments, then the returned result
    48|      *            will also be an array with matching dimensions
    49|      */
    50|     public static function mid(mixed $value, mixed $start, mixed $chars): array|string
    51|     {
    52|         if (is_array($value) || is_array($start) || is_array($chars)) {
    53|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $start, $chars);
    54|         }
    55|         try {
    56|             $value = Helpers::extractString($value, true);
    57|             $start = Helpers::extractInt($start, 1);
    58|             $chars = Helpers::extractInt($chars, 0);
    59|         } catch (CalcExp $e) {
    60|             return $e->getMessage();
    61|         }
    62|         return mb_substr($value, --$start, $chars, 'UTF-8');
    63|     }
    64|     /**
    65|      * RIGHT.
    66|      *
    67|      * @param mixed $value String value from which to extract characters
    68|      *                         Or can be an array of values
    69|      * @param mixed $chars The number of characters to extract (as an integer)
    70|      *                         Or can be an array of values
    71|      *
    72|      * @return array|string The joined string
    73|      *         If an array of values is passed for the $value or $chars arguments, then the returned result
    74|      *            will also be an array with matching dimensions
    75|      */
    76|     public static function right(mixed $value, mixed $chars = 1): array|string
    77|     {
    78|         if (is_array($value) || is_array($chars)) {
    79|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $chars);
    80|         }
    81|         try {
    82|             $value = Helpers::extractString($value, true);
    83|             $chars = Helpers::extractInt($chars, 0, 1);
    84|         } catch (CalcExp $e) {
    85|             return $e->getMessage();
    86|         }
    87|         return mb_substr($value, mb_strlen($value, 'UTF-8') - $chars, $chars, 'UTF-8');
    88|     }
    89|     /**
    90|      * TEXTBEFORE.
    91|      *
    92|      * @param mixed $text the text that you're searching
    93|      *                    Or can be an array of values
    94|      * @param null|array|string $delimiter the text that marks the point before which you want to extract
    95|      *                                 Multiple delimiters can be passed as an array of string values
    96|      * @param mixed $instance The instance of the delimiter after which you want to extract the text.
    97|      *                            By default, this is the first instance (1).
    98|      *                            A negative value means start searching from the end of the text string.
    99|      *                        Or can be an array of values
   100|      * @param mixed $matchMode Determines whether the match is case-sensitive or not.
   101|      *                           0 - Case-sensitive
   102|      *                           1 - Case-insensitive
   103|      *                        Or can be an array of values
   104|      * @param mixed $matchEnd Treats the end of text as a delimiter.
   105|      *                          0 - Don't match the delimiter against the end of the text.
   106|      *                          1 - Match the delimiter against the end of the text.
   107|      *                        Or can be an array of values
   108|      * @param mixed $ifNotFound value to return if no match is found
   109|      *                             The default is a #N/A Error
   110|      *                          Or can be an array of values
   111|      *
   112|      * @return array|string the string extracted from text before the delimiter; or the $ifNotFound value
   113|      *         If an array of values is passed for any of the arguments, then the returned result
   114|      *            will also be an array with matching dimensions
   115|      */
   116|     public static function before(mixed $text, $delimiter, mixed $instance = 1, mixed $matchMode = 0, mixed $matchEnd = 0, mixed $ifNotFound = '#N/A'): array|string
   117|     {
   118|         if (is_array($text) || is_array($instance) || is_array($matchMode) || is_array($matchEnd) || is_array($ifNotFound)) {
   119|             return self::evaluateArrayArgumentsIgnore([self::class, __FUNCTION__], 1, $text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
   120|         }
   121|         try {
   122|             $text = Helpers::extractString($text ?? '', true);
   123|             Helpers::extractString(Functions::flattenSingleValue($delimiter ?? ''), true);
   124|         } catch (CalcExp $e) {
   125|             return $e->getMessage();
   126|         }
   127|         $instance = (int) $instance;
   128|         $matchMode = (int) $matchMode;
   129|         $matchEnd = (int) $matchEnd;
   130|         $split = self::validateTextBeforeAfter($text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
   131|         if (is_string($split)) {
   132|             return $split;
   133|         }
   134|         if (Helpers::extractString(Functions::flattenSingleValue($delimiter ?? '')) === '') {
   135|             return ($instance > 0) ? '' : $text;
   136|         }
   137|         $flags = self::matchFlags($matchMode);
   138|         $delimiter = self::buildDelimiter($delimiter);
   139|         $adjust = preg_match('/^' . $delimiter . "\$/{$flags}", $split[0]);
   140|         $oddReverseAdjustment = count($split) % 2;
   141|         $split = ($instance < 0)
   142|             ? array_slice($split, 0, max(count($split) - (abs($instance) * 2 - 1) - $adjust - $oddReverseAdjustment, 0))
   143|             : array_slice($split, 0, $instance * 2 - 1 - $adjust);
   144|         return implode('', $split);
   145|     }
   146|     /**
   147|      * TEXTAFTER.
   148|      *
   149|      * @param mixed $text the text that you're searching
   150|      * @param null|array|string $delimiter the text that marks the point before which you want to extract
   151|      *                                 Multiple delimiters can be passed as an array of string values
   152|      * @param mixed $instance The instance of the delimiter after which you want to extract the text.
   153|      *                          By default, this is the first instance (1).
   154|      *                          A negative value means start searching from the end of the text string.
   155|      *                        Or can be an array of values
   156|      * @param mixed $matchMode Determines whether the match is case-sensitive or not.
   157|      *                            0 - Case-sensitive
   158|      *                            1 - Case-insensitive
   159|      *                         Or can be an array of values
   160|      * @param mixed $matchEnd Treats the end of text as a delimiter.
   161|      *                          0 - Don't match the delimiter against the end of the text.
   162|      *                          1 - Match the delimiter against the end of the text.
   163|      *                        Or can be an array of values
   164|      * @param mixed $ifNotFound value to return if no match is found
   165|      *                             The default is a #N/A Error
   166|      *                          Or can be an array of values
   167|      *
   168|      * @return array|string the string extracted from text before the delimiter; or the $ifNotFound value
   169|      *         If an array of values is passed for any of the arguments, then the returned result
   170|      *            will also be an array with matching dimensions
   171|      */
   172|     public static function after(mixed $text, $delimiter, mixed $instance = 1, mixed $matchMode = 0, mixed $matchEnd = 0, mixed $ifNotFound = '#N/A'): array|string
   173|     {
   174|         if (is_array($text) || is_array($instance) || is_array($matchMode) || is_array($matchEnd) || is_array($ifNotFound)) {
   175|             return self::evaluateArrayArgumentsIgnore([self::class, __FUNCTION__], 1, $text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
   176|         }
   177|         try {
   178|             $text = Helpers::extractString($text ?? '', true);
   179|             Helpers::extractString(Functions::flattenSingleValue($delimiter ?? ''), true);
   180|         } catch (CalcExp $e) {
   181|             return $e->getMessage();
   182|         }
   183|         $instance = (int) $instance;
   184|         $matchMode = (int) $matchMode;
   185|         $matchEnd = (int) $matchEnd;
   186|         $split = self::validateTextBeforeAfter($text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
   187|         if (is_string($split)) {
   188|             return $split;
   189|         }
   190|         if (Helpers::extractString(Functions::flattenSingleValue($delimiter ?? '')) === '') {
   191|             return ($instance < 0) ? '' : $text;
   192|         }
   193|         $flags = self::matchFlags($matchMode);
   194|         $delimiter = self::buildDelimiter($delimiter);
   195|         $adjust = preg_match('/^' . $delimiter . "\$/{$flags}", $split[0]);
   196|         $oddReverseAdjustment = count($split) % 2;
   197|         $split = ($instance < 0)
   198|             ? array_slice($split, count($split) - ((int) abs($instance + 1) * 2) - $adjust - $oddReverseAdjustment)
   199|             : array_slice($split, $instance * 2 - $adjust);
   200|         return implode('', $split);
   201|     }
   202|     private static function validateTextBeforeAfter(string $text, null|array|string $delimiter, int $instance, int $matchMode, int $matchEnd, mixed $ifNotFound): array|string
   203|     {
   204|         $flags = self::matchFlags($matchMode);
   205|         $delimiter = self::buildDelimiter($delimiter);
   206|         if (preg_match('/' . $delimiter . "/{$flags}", $text) === 0 && $matchEnd === 0) {
   207|             return $ifNotFound;
   208|         }
   209|         $split = preg_split('/' . $delimiter . "/{$flags}", $text, 0, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);
   210|         if ($split === false) {
   211|             return ExcelError::NA();
   212|         }
   213|         if ($instance === 0 || abs($instance) > StringHelper::countCharacters($text)) {
   214|             return ExcelError::VALUE();
   215|         }
   216|         if ($matchEnd === 0 && (abs($instance) > floor(count($split) / 2))) {
   217|             return ExcelError::NA();
   218|         } elseif ($matchEnd !== 0 && (abs($instance) - 1 > ceil(count($split) / 2))) {
   219|             return ExcelError::NA();
   220|         }
   221|         return $split;
   222|     }
   223|     /**
   224|      * @param null|array|string $delimiter the text that marks the point before which you want to extract
   225|      *                                 Multiple delimiters can be passed as an array of string values
   226|      */
   227|     private static function buildDelimiter($delimiter): string
   228|     {
   229|         if (is_array($delimiter)) {
   230|             $delimiter = Functions::flattenArray($delimiter);
   231|             $quotedDelimiters = array_map(
   232|                 fn ($delimiter): string => preg_quote($delimiter ?? '', '/'),
   233|                 $delimiter
   234|             );
   235|             $delimiters = implode('|', $quotedDelimiters);
   236|             return '(' . $delimiters . ')';
   237|         }
   238|         return '(' . preg_quote($delimiter ?? '', '/') . ')';
   239|     }
   240|     private static function matchFlags(int $matchMode): string
   241|     {
   242|         return ($matchMode === 0) ? 'mu' : 'miu';
   243|     }
   244| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Format.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-282 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use DateTimeInterface;
     4| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     6| use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     8| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     9| use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
    10| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
    11| use PhpOffice\PhpSpreadsheet\Calculation\MathTrig;
    12| use PhpOffice\PhpSpreadsheet\RichText\RichText;
    13| use PhpOffice\PhpSpreadsheet\Shared\Date;
    14| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
    15| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    16| class Format
    17| {
    18|     use ArrayEnabled;
    19|     /**
    20|      * DOLLAR.
    21|      *
    22|      * This function converts a number to text using currency format, with the decimals rounded to the specified place.
    23|      * The format used is $#,##0.00_);($#,##0.00)..
    24|      *
    25|      * @param mixed $value The value to format
    26|      *                         Or can be an array of values
    27|      * @param mixed $decimals The number of digits to display to the right of the decimal point (as an integer).
    28|      *                            If decimals is negative, number is rounded to the left of the decimal point.
    29|      *                            If you omit decimals, it is assumed to be 2
    30|      *                         Or can be an array of values
    31|      *
    32|      * @return array|string If an array of values is passed for either of the arguments, then the returned result
    33|      *            will also be an array with matching dimensions
    34|      */
    35|     public static function DOLLAR(mixed $value = 0, mixed $decimals = 2)
    36|     {
    37|         if (is_array($value) || is_array($decimals)) {
    38|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimals);
    39|         }
    40|         try {
    41|             $value = Helpers::extractFloat($value);
    42|             $decimals = Helpers::extractInt($decimals, -100, 0, true);
    43|         } catch (CalcExp $e) {
    44|             return $e->getMessage();
    45|         }
    46|         $mask = '$#,##0';
    47|         if ($decimals > 0) {
    48|             $mask .= '.' . str_repeat('0', $decimals);
    49|         } else {
    50|             $round = 10 ** abs($decimals);
    51|             if ($value < 0) {
    52|                 $round = 0 - $round;
    53|             }
    54|             /** @var float|int|string */
    55|             $value = MathTrig\Round::multiple($value, $round);
    56|         }
    57|         $mask = "{$mask};-{$mask}";
    58|         return NumberFormat::toFormattedString($value, $mask);
    59|     }
    60|     /**
    61|      * FIXED.
    62|      *
    63|      * @param mixed $value The value to format
    64|      *                         Or can be an array of values
    65|      * @param mixed $decimals Integer value for the number of decimal places that should be formatted
    66|      *                         Or can be an array of values
    67|      * @param mixed $noCommas Boolean value indicating whether the value should have thousands separators or not
    68|      *                         Or can be an array of values
    69|      *
    70|      * @return array|string If an array of values is passed for either of the arguments, then the returned result
    71|      *            will also be an array with matching dimensions
    72|      */
    73|     public static function FIXEDFORMAT(mixed $value, mixed $decimals = 2, mixed $noCommas = false): array|string
    74|     {
    75|         if (is_array($value) || is_array($decimals) || is_array($noCommas)) {
    76|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimals, $noCommas);
    77|         }
    78|         try {
    79|             $value = Helpers::extractFloat($value);
    80|             $decimals = Helpers::extractInt($decimals, -100, 0, true);
    81|         } catch (CalcExp $e) {
    82|             return $e->getMessage();
    83|         }
    84|         $valueResult = round($value, $decimals);
    85|         if ($decimals < 0) {
    86|             $decimals = 0;
    87|         }
    88|         if ($noCommas === false) {
    89|             $valueResult = number_format(
    90|                 $valueResult,
    91|                 $decimals,
    92|                 StringHelper::getDecimalSeparator(),
    93|                 StringHelper::getThousandsSeparator()
    94|             );
    95|         }
    96|         return (string) $valueResult;
    97|     }
    98|     /**
    99|      * TEXT.
   100|      *
   101|      * @param mixed $value The value to format
   102|      *                         Or can be an array of values
   103|      * @param mixed $format A string with the Format mask that should be used
   104|      *                         Or can be an array of values
   105|      *
   106|      * @return array|string If an array of values is passed for either of the arguments, then the returned result
   107|      *            will also be an array with matching dimensions
   108|      */
   109|     public static function TEXTFORMAT(mixed $value, mixed $format): array|string
   110|     {
   111|         if (is_array($value) || is_array($format)) {
   112|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $format);
   113|         }
   114|         try {
   115|             $value = Helpers::extractString($value, true);
   116|             $format = Helpers::extractString($format, true);
   117|         } catch (CalcExp $e) {
   118|             return $e->getMessage();
   119|         }
   120|         $format = (string) NumberFormat::convertSystemFormats($format);
   121|         if (!is_numeric($value) && Date::isDateTimeFormatCode($format)) {
   122|             $value1 = DateTimeExcel\DateValue::fromString($value);
   123|             $value2 = DateTimeExcel\TimeValue::fromString($value);
   124|             /** @var float|int|string */
   125|             $value = (is_numeric($value1) && is_numeric($value2)) ? ($value1 + $value2) : (is_numeric($value1) ? $value2 : $value1);
   126|         }
   127|         return (string) NumberFormat::toFormattedString($value, $format);
   128|     }
   129|     /**
   130|      * @param mixed $value Value to check
   131|      */
   132|     private static function convertValue(mixed $value, bool $spacesMeanZero = false): mixed
   133|     {
   134|         $value = $value ?? 0;
   135|         if (is_bool($value)) {
   136|             if (Functions::getCompatibilityMode() === Functions::COMPATIBILITY_OPENOFFICE) {
   137|                 $value = (int) $value;
   138|             } else {
   139|                 throw new CalcExp(ExcelError::VALUE());
   140|             }
   141|         }
   142|         if (is_string($value)) {
   143|             $value = trim($value);
   144|             if (ErrorValue::isError($value, true)) {
   145|                 throw new CalcExp($value);
   146|             }
   147|             if ($spacesMeanZero && $value === '') {
   148|                 $value = 0;
   149|             }
   150|         }
   151|         return $value;
   152|     }
   153|     /**
   154|      * VALUE.
   155|      *
   156|      * @param mixed $value Value to check
   157|      *                         Or can be an array of values
   158|      *
   159|      * @return array|DateTimeInterface|float|int|string A string if arguments are invalid
   160|      *         If an array of values is passed for the argument, then the returned result
   161|      *            will also be an array with matching dimensions
   162|      */
   163|     public static function VALUE(mixed $value = '')
   164|     {
   165|         if (is_array($value)) {
   166|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
   167|         }
   168|         try {
   169|             $value = self::convertValue($value);
   170|         } catch (CalcExp $e) {
   171|             return $e->getMessage();
   172|         }
   173|         if (!is_numeric($value)) {
   174|             $numberValue = str_replace(
   175|                 StringHelper::getThousandsSeparator(),
   176|                 '',
   177|                 trim($value, " \t\n\r\0\x0B" . StringHelper::getCurrencyCode())
   178|             );
   179|             if ($numberValue === '') {
   180|                 return ExcelError::VALUE();
   181|             }
   182|             if (is_numeric($numberValue)) {
   183|                 return (float) $numberValue;
   184|             }
   185|             $dateSetting = Functions::getReturnDateType();
   186|             Functions::setReturnDateType(Functions::RETURNDATE_EXCEL);
   187|             if (str_contains($value, ':')) {
   188|                 $timeValue = Functions::scalar(DateTimeExcel\TimeValue::fromString($value));
   189|                 if ($timeValue !== ExcelError::VALUE()) {
   190|                     Functions::setReturnDateType($dateSetting);
   191|                     return $timeValue;
   192|                 }
   193|             }
   194|             $dateValue = Functions::scalar(DateTimeExcel\DateValue::fromString($value));
   195|             if ($dateValue !== ExcelError::VALUE()) {
   196|                 Functions::setReturnDateType($dateSetting);
   197|                 return $dateValue;
   198|             }
   199|             Functions::setReturnDateType($dateSetting);
   200|             return ExcelError::VALUE();
   201|         }
   202|         return (float) $value;
   203|     }
   204|     /**
   205|      * VALUETOTEXT.
   206|      *
   207|      * @param mixed $value The value to format
   208|      *                         Or can be an array of values
   209|      *
   210|      * @return array|string If an array of values is passed for either of the arguments, then the returned result
   211|      *            will also be an array with matching dimensions
   212|      */
   213|     public static function valueToText(mixed $value, mixed $format = false): array|string
   214|     {
   215|         if (is_array($value) || is_array($format)) {
   216|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $format);
   217|         }
   218|         $format = (bool) $format;
   219|         if (is_object($value) && $value instanceof RichText) {
   220|             $value = $value->getPlainText();
   221|         }
   222|         if (is_string($value)) {
   223|             $value = ($format === true) ? Calculation::wrapResult($value) : $value;
   224|             $value = str_replace("\n", '', $value);
   225|         } elseif (is_bool($value)) {
   226|             $value = Calculation::getLocaleBoolean($value ? 'TRUE' : 'FALSE');
   227|         }
   228|         return (string) $value;
   229|     }
   230|     private static function getDecimalSeparator(mixed $decimalSeparator): string
   231|     {
   232|         return empty($decimalSeparator) ? StringHelper::getDecimalSeparator() : (string) $decimalSeparator;
   233|     }
   234|     private static function getGroupSeparator(mixed $groupSeparator): string
   235|     {
   236|         return empty($groupSeparator) ? StringHelper::getThousandsSeparator() : (string) $groupSeparator;
   237|     }
   238|     /**
   239|      * NUMBERVALUE.
   240|      *
   241|      * @param mixed $value The value to format
   242|      *                         Or can be an array of values
   243|      * @param mixed $decimalSeparator A string with the decimal separator to use, defaults to locale defined value
   244|      *                         Or can be an array of values
   245|      * @param mixed $groupSeparator A string with the group/thousands separator to use, defaults to locale defined value
   246|      *                         Or can be an array of values
   247|      */
   248|     public static function NUMBERVALUE(mixed $value = '', mixed $decimalSeparator = null, mixed $groupSeparator = null): array|string|float
   249|     {
   250|         if (is_array($value) || is_array($decimalSeparator) || is_array($groupSeparator)) {
   251|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimalSeparator, $groupSeparator);
   252|         }
   253|         try {
   254|             $value = self::convertValue($value, true);
   255|             $decimalSeparator = self::getDecimalSeparator($decimalSeparator);
   256|             $groupSeparator = self::getGroupSeparator($groupSeparator);
   257|         } catch (CalcExp $e) {
   258|             return $e->getMessage();
   259|         }
   260|         if (!is_numeric($value)) {
   261|             $decimalPositions = preg_match_all('/' . preg_quote($decimalSeparator, '/') . '/', $value, $matches, PREG_OFFSET_CAPTURE);
   262|             if ($decimalPositions > 1) {
   263|                 return ExcelError::VALUE();
   264|             }
   265|             $decimalOffset = array_pop($matches[0])[1] ?? null;
   266|             if ($decimalOffset === null || strpos($value, $groupSeparator, $decimalOffset) !== false) {
   267|                 return ExcelError::VALUE();
   268|             }
   269|             $value = str_replace([$groupSeparator, $decimalSeparator], ['', '.'], $value);
   270|             $percentageString = rtrim($value, '%');
   271|             if (!is_numeric($percentageString)) {
   272|                 return ExcelError::VALUE();
   273|             }
   274|             $percentageAdjustment = strlen($value) - strlen($percentageString);
   275|             if ($percentageAdjustment) {
   276|                 $value = (float) $percentageString;
   277|                 $value /= 10 ** ($percentageAdjustment * 2);
   278|             }
   279|         }
   280|         return is_array($value) ? ExcelError::VALUE() : (float) $value;
   281|     }
   282| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Helpers.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     8| class Helpers
     9| {
    10|     public static function convertBooleanValue(bool $value): string
    11|     {
    12|         if (Functions::getCompatibilityMode() == Functions::COMPATIBILITY_OPENOFFICE) {
    13|             return $value ? '1' : '0';
    14|         }
    15|         return ($value) ? Calculation::getTRUE() : Calculation::getFALSE();
    16|     }
    17|     /**
    18|      * @param mixed $value String value from which to extract characters
    19|      */
    20|     public static function extractString(mixed $value, bool $throwIfError = false): string
    21|     {
    22|         if (is_bool($value)) {
    23|             return self::convertBooleanValue($value);
    24|         }
    25|         if ($throwIfError && is_string($value) && ErrorValue::isError($value, true)) {
    26|             throw new CalcExp($value);
    27|         }
    28|         return (string) $value;
    29|     }
    30|     public static function extractInt(mixed $value, int $minValue, int $gnumericNull = 0, bool $ooBoolOk = false): int
    31|     {
    32|         if ($value === null) {
    33|             $value = (Functions::getCompatibilityMode() === Functions::COMPATIBILITY_GNUMERIC) ? $gnumericNull : 0;
    34|         }
    35|         if (is_bool($value) && ($ooBoolOk || Functions::getCompatibilityMode() !== Functions::COMPATIBILITY_OPENOFFICE)) {
    36|             $value = (int) $value;
    37|         }
    38|         if (!is_numeric($value)) {
    39|             throw new CalcExp(ExcelError::VALUE());
    40|         }
    41|         $value = (int) $value;
    42|         if ($value < $minValue) {
    43|             throw new CalcExp(ExcelError::VALUE());
    44|         }
    45|         return (int) $value;
    46|     }
    47|     public static function extractFloat(mixed $value): float
    48|     {
    49|         if ($value === null) {
    50|             $value = 0.0;
    51|         }
    52|         if (is_bool($value)) {
    53|             $value = (float) $value;
    54|         }
    55|         if (!is_numeric($value)) {
    56|             if (is_string($value) && ErrorValue::isError($value, true)) {
    57|                 throw new CalcExp($value);
    58|             }
    59|             throw new CalcExp(ExcelError::VALUE());
    60|         }
    61|         return (float) $value;
    62|     }
    63|     public static function validateInt(mixed $value, bool $throwIfError = false): int
    64|     {
    65|         if ($value === null) {
    66|             $value = 0;
    67|         } elseif (is_bool($value)) {
    68|             $value = (int) $value;
    69|         } elseif ($throwIfError && is_string($value) && !is_numeric($value)) {
    70|             if (!ErrorValue::isError($value, true)) {
    71|                 $value = ExcelError::VALUE();
    72|             }
    73|             throw new CalcExp($value);
    74|         }
    75|         return (int) $value;
    76|     }
    77| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Search.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     6| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     7| class Search
     8| {
     9|     use ArrayEnabled;
    10|     /**
    11|      * FIND (case sensitive search).
    12|      *
    13|      * @param mixed $needle The string to look for
    14|      *                         Or can be an array of values
    15|      * @param mixed $haystack The string in which to look
    16|      *                         Or can be an array of values
    17|      * @param mixed $offset Integer offset within $haystack to start searching from
    18|      *                         Or can be an array of values
    19|      *
    20|      * @return array|int|string The offset where the first occurrence of needle was found in the haystack
    21|      *         If an array of values is passed for the $value or $chars arguments, then the returned result
    22|      *            will also be an array with matching dimensions
    23|      */
    24|     public static function sensitive(mixed $needle, mixed $haystack, mixed $offset = 1): array|string|int
    25|     {
    26|         if (is_array($needle) || is_array($haystack) || is_array($offset)) {
    27|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $needle, $haystack, $offset);
    28|         }
    29|         try {
    30|             $needle = Helpers::extractString($needle, true);
    31|             $haystack = Helpers::extractString($haystack, true);
    32|             $offset = Helpers::extractInt($offset, 1, 0, true);
    33|         } catch (CalcExp $e) {
    34|             return $e->getMessage();
    35|         }
    36|         if (StringHelper::countCharacters($haystack) >= $offset) {
    37|             if (StringHelper::countCharacters($needle) === 0) {
    38|                 return $offset;
    39|             }
    40|             $pos = mb_strpos($haystack, $needle, --$offset, 'UTF-8');
    41|             if ($pos !== false) {
    42|                 return ++$pos;
    43|             }
    44|         }
    45|         return ExcelError::VALUE();
    46|     }
    47|     /**
    48|      * SEARCH (case insensitive search).
    49|      *
    50|      * @param mixed $needle The string to look for
    51|      *                         Or can be an array of values
    52|      * @param mixed $haystack The string in which to look
    53|      *                         Or can be an array of values
    54|      * @param mixed $offset Integer offset within $haystack to start searching from
    55|      *                         Or can be an array of values
    56|      *
    57|      * @return array|int|string The offset where the first occurrence of needle was found in the haystack
    58|      *         If an array of values is passed for the $value or $chars arguments, then the returned result
    59|      *            will also be an array with matching dimensions
    60|      */
    61|     public static function insensitive(mixed $needle, mixed $haystack, mixed $offset = 1): array|string|int
    62|     {
    63|         if (is_array($needle) || is_array($haystack) || is_array($offset)) {
    64|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $needle, $haystack, $offset);
    65|         }
    66|         try {
    67|             $needle = Helpers::extractString($needle, true);
    68|             $haystack = Helpers::extractString($haystack, true);
    69|             $offset = Helpers::extractInt($offset, 1, 0, true);
    70|         } catch (CalcExp $e) {
    71|             return $e->getMessage();
    72|         }
    73|         if (StringHelper::countCharacters($haystack) >= $offset) {
    74|             if (StringHelper::countCharacters($needle) === 0) {
    75|                 return $offset;
    76|             }
    77|             $pos = mb_stripos($haystack, $needle, --$offset, 'UTF-8');
    78|             if ($pos !== false) {
    79|                 return ++$pos;
    80|             }
    81|         }
    82|         return ExcelError::VALUE();
    83|     }
    84| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/TextData/Text.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-213 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
     3| use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
     8| class Text
     9| {
    10|     use ArrayEnabled;
    11|     /**
    12|      * LEN.
    13|      *
    14|      * @param mixed $value String Value
    15|      *                         Or can be an array of values
    16|      *
    17|      * @return array|int|string If an array of values is passed for the argument, then the returned result
    18|      *            will also be an array with matching dimensions
    19|      */
    20|     public static function length(mixed $value = ''): array|int|string
    21|     {
    22|         if (is_array($value)) {
    23|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
    24|         }
    25|         try {
    26|             $value = Helpers::extractString($value, true);
    27|         } catch (CalcExp $e) {
    28|             return $e->getMessage();
    29|         }
    30|         return mb_strlen($value, 'UTF-8');
    31|     }
    32|     /**
    33|      * Compares two text strings and returns TRUE if they are exactly the same, FALSE otherwise.
    34|      * EXACT is case-sensitive but ignores formatting differences.
    35|      * Use EXACT to test text being entered into a document.
    36|      *
    37|      * @param mixed $value1 String Value
    38|      *                         Or can be an array of values
    39|      * @param mixed $value2 String Value
    40|      *                         Or can be an array of values
    41|      *
    42|      * @return array|bool|string If an array of values is passed for either of the arguments, then the returned result
    43|      *            will also be an array with matching dimensions
    44|      */
    45|     public static function exact(mixed $value1, mixed $value2): array|bool|string
    46|     {
    47|         if (is_array($value1) || is_array($value2)) {
    48|             return self::evaluateArrayArguments([self::class, __FUNCTION__], $value1, $value2);
    49|         }
    50|         try {
    51|             $value1 = Helpers::extractString($value1, true);
    52|             $value2 = Helpers::extractString($value2, true);
    53|         } catch (CalcExp $e) {
    54|             return $e->getMessage();
    55|         }
    56|         return $value2 === $value1;
    57|     }
    58|     /**
    59|      * T.
    60|      *
    61|      * @param mixed $testValue Value to check
    62|      *                         Or can be an array of values
    63|      *
    64|      * @return array|string If an array of values is passed for the argument, then the returned result
    65|      *            will also be an array with matching dimensions
    66|      */
    67|     public static function test(mixed $testValue = ''): array|string
    68|     {
    69|         if (is_array($testValue)) {
    70|             return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $testValue);
    71|         }
    72|         if (is_string($testValue)) {
    73|             return $testValue;
    74|         }
    75|         return '';
    76|     }
    77|     /**
    78|      * TEXTSPLIT.
    79|      *
    80|      * @param mixed $text the text that you're searching
    81|      * @param null|array|string $columnDelimiter The text that marks the point where to spill the text across columns.
    82|      *                          Multiple delimiters can be passed as an array of string values
    83|      * @param null|array|string $rowDelimiter The text that marks the point where to spill the text down rows.
    84|      *                          Multiple delimiters can be passed as an array of string values
    85|      * @param bool $ignoreEmpty Specify FALSE to create an empty cell when two delimiters are consecutive.
    86|      *                              true = create empty cells
    87|      *                              false = skip empty cells
    88|      *                              Defaults to TRUE, which creates an empty cell
    89|      * @param bool $matchMode Determines whether the match is case-sensitive or not.
    90|      *                              true = case-sensitive
    91|      *                              false = case-insensitive
    92|      *                         By default, a case-sensitive match is done.
    93|      * @param mixed $padding The value with which to pad the result.
    94|      *                              The default is #N/A.
    95|      *
    96|      * @return array|string the array built from the text, split by the row and column delimiters, or an error string
    97|      */
    98|     public static function split(mixed $text, $columnDelimiter = null, $rowDelimiter = null, bool $ignoreEmpty = false, bool $matchMode = true, mixed $padding = '#N/A'): array|string
    99|     {
   100|         $text = Functions::flattenSingleValue($text);
   101|         if (ErrorValue::isError($text, true)) {
   102|             return $text;
   103|         }
   104|         $flags = self::matchFlags($matchMode);
   105|         if ($rowDelimiter !== null) {
   106|             $delimiter = self::buildDelimiter($rowDelimiter);
   107|             $rows = ($delimiter === '()')
   108|                 ? [$text]
   109|                 : preg_split("/{$delimiter}/{$flags}", $text);
   110|         } else {
   111|             $rows = [$text];
   112|         }
   113|         /** @var array $rows */
   114|         if ($ignoreEmpty === true) {
   115|             $rows = array_values(array_filter(
   116|                 $rows,
   117|                 fn ($row): bool => $row !== ''
   118|             ));
   119|         }
   120|         if ($columnDelimiter !== null) {
   121|             $delimiter = self::buildDelimiter($columnDelimiter);
   122|             array_walk(
   123|                 $rows,
   124|                 function (&$row) use ($delimiter, $flags, $ignoreEmpty): void {
   125|                     $row = ($delimiter === '()')
   126|                         ? [$row]
   127|                         : preg_split("/{$delimiter}/{$flags}", $row);
   128|                     /** @var array $row */
   129|                     if ($ignoreEmpty === true) {
   130|                         $row = array_values(array_filter(
   131|                             $row,
   132|                             fn ($value): bool => $value !== ''
   133|                         ));
   134|                     }
   135|                 }
   136|             );
   137|             if ($ignoreEmpty === true) {
   138|                 $rows = array_values(array_filter(
   139|                     $rows,
   140|                     fn ($row): bool => $row !== [] && $row !== ['']
   141|                 ));
   142|             }
   143|         }
   144|         return self::applyPadding($rows, $padding);
   145|     }
   146|     private static function applyPadding(array $rows, mixed $padding): array
   147|     {
   148|         $columnCount = array_reduce(
   149|             $rows,
   150|             fn (int $counter, array $row): int => max($counter, count($row)),
   151|             0
   152|         );
   153|         return array_map(
   154|             function (array $row) use ($columnCount, $padding): array {
   155|                 return (count($row) < $columnCount)
   156|                     ? array_merge($row, array_fill(0, $columnCount - count($row), $padding))
   157|                     : $row;
   158|             },
   159|             $rows
   160|         );
   161|     }
   162|     /**
   163|      * @param null|array|string $delimiter the text that marks the point before which you want to split
   164|      *                                 Multiple delimiters can be passed as an array of string values
   165|      */
   166|     private static function buildDelimiter($delimiter): string
   167|     {
   168|         $valueSet = Functions::flattenArray($delimiter);
   169|         if (is_array($delimiter) && count($valueSet) > 1) {
   170|             $quotedDelimiters = array_map(
   171|                 fn ($delimiter): string => preg_quote($delimiter ?? '', '/'),
   172|                 $valueSet
   173|             );
   174|             $delimiters = implode('|', $quotedDelimiters);
   175|             return '(' . $delimiters . ')';
   176|         }
   177|         return '(' . preg_quote(Functions::flattenSingleValue($delimiter), '/') . ')';
   178|     }
   179|     private static function matchFlags(bool $matchMode): string
   180|     {
   181|         return ($matchMode === true) ? 'miu' : 'mu';
   182|     }
   183|     public static function fromArray(array $array, int $format = 0): string
   184|     {
   185|         $result = [];
   186|         foreach ($array as $row) {
   187|             $cells = [];
   188|             foreach ($row as $cellValue) {
   189|                 $value = ($format === 1) ? self::formatValueMode1($cellValue) : self::formatValueMode0($cellValue);
   190|                 $cells[] = $value;
   191|             }
   192|             $result[] = implode(($format === 1) ? ',' : ', ', $cells);
   193|         }
   194|         $result = implode(($format === 1) ? ';' : ', ', $result);
   195|         return ($format === 1) ? '{' . $result . '}' : $result;
   196|     }
   197|     private static function formatValueMode0(mixed $cellValue): string
   198|     {
   199|         if (is_bool($cellValue)) {
   200|             return Calculation::getLocaleBoolean($cellValue ? 'TRUE' : 'FALSE');
   201|         }
   202|         return (string) $cellValue;
   203|     }
   204|     private static function formatValueMode1(mixed $cellValue): string
   205|     {
   206|         if (is_string($cellValue) && ErrorValue::isError($cellValue) === false) {
   207|             return Calculation::FORMULA_STRING_QUOTE . $cellValue . Calculation::FORMULA_STRING_QUOTE;
   208|         } elseif (is_bool($cellValue)) {
   209|             return Calculation::getLocaleBoolean($cellValue ? 'TRUE' : 'FALSE');
   210|         }
   211|         return (string) $cellValue;
   212|     }
   213| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/AdvancedValueBinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-145 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Engine\FormattedNumber;
     5| use PhpOffice\PhpSpreadsheet\Shared\Date;
     6| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     7| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
     8| class AdvancedValueBinder extends DefaultValueBinder implements IValueBinder
     9| {
    10|     /**
    11|      * Bind value to a cell.
    12|      *
    13|      * @param Cell $cell Cell to bind value to
    14|      * @param mixed $value Value to bind in cell
    15|      */
    16|     public function bindValue(Cell $cell, mixed $value = null): bool
    17|     {
    18|         if ($value === null) {
    19|             return parent::bindValue($cell, $value);
    20|         } elseif (is_string($value)) {
    21|             $value = StringHelper::sanitizeUTF8($value);
    22|         }
    23|         $dataType = parent::dataTypeForValue($value);
    24|         if ($dataType === DataType::TYPE_STRING && is_string($value)) {
    25|             if (StringHelper::strToUpper($value) === Calculation::getTRUE()) {
    26|                 $cell->setValueExplicit(true, DataType::TYPE_BOOL);
    27|                 return true;
    28|             } elseif (StringHelper::strToUpper($value) === Calculation::getFALSE()) {
    29|                 $cell->setValueExplicit(false, DataType::TYPE_BOOL);
    30|                 return true;
    31|             }
    32|             if (preg_match('~^([+-]?)\s*(\d+)\s*/\s*(\d+)$~', $value, $matches)) {
    33|                 return $this->setProperFraction($matches, $cell);
    34|             } elseif (preg_match('~^([+-]?)(\d+)\s+(\d+)\s*/\s*(\d+)$~', $value, $matches)) {
    35|                 return $this->setImproperFraction($matches, $cell);
    36|             }
    37|             $decimalSeparatorNoPreg = StringHelper::getDecimalSeparator();
    38|             $decimalSeparator = preg_quote($decimalSeparatorNoPreg, '/');
    39|             $thousandsSeparator = preg_quote(StringHelper::getThousandsSeparator(), '/');
    40|             if (preg_match('/^\-?\d*' . $decimalSeparator . '?\d*\s?\%$/', (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value))) {
    41|                 return $this->setPercentage((string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value), $cell);
    42|             }
    43|             if (preg_match(FormattedNumber::currencyMatcherRegexp(), (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value), $matches, PREG_UNMATCHED_AS_NULL)) {
    44|                 $sign = ($matches['PrefixedSign'] ?? $matches['PrefixedSign2'] ?? $matches['PostfixedSign']) ?? null;
    45|                 $currencyCode = $matches['PrefixedCurrency'] ?? $matches['PostfixedCurrency'];
    46|                 /** @var string */
    47|                 $temp = str_replace([$decimalSeparatorNoPreg, $currencyCode, ' ', '-'], ['.', '', '', ''], (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value));
    48|                 $value = (float) ($sign . trim($temp));
    49|                 return $this->setCurrency($value, $cell, $currencyCode ?? '');
    50|             }
    51|             if (preg_match('/^(\d|[0-1]\d|2[0-3]):[0-5]\d$/', $value)) {
    52|                 return $this->setTimeHoursMinutes($value, $cell);
    53|             }
    54|             if (preg_match('/^(\d|[0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$/', $value)) {
    55|                 return $this->setTimeHoursMinutesSeconds($value, $cell);
    56|             }
    57|             if (($d = Date::stringToExcel($value)) !== false) {
    58|                 $cell->setValueExplicit($d, DataType::TYPE_NUMERIC);
    59|                 if (str_contains($value, ':')) {
    60|                     $formatCode = 'yyyy-mm-dd h:mm';
    61|                 } else {
    62|                     $formatCode = 'yyyy-mm-dd';
    63|                 }
    64|                 $cell->getWorksheet()->getStyle($cell->getCoordinate())
    65|                     ->getNumberFormat()->setFormatCode($formatCode);
    66|                 return true;
    67|             }
    68|             if (str_contains($value, "\n")) {
    69|                 $cell->setValueExplicit($value, DataType::TYPE_STRING);
    70|                 $cell->getWorksheet()->getStyle($cell->getCoordinate())
    71|                     ->getAlignment()->setWrapText(true);
    72|                 return true;
    73|             }
    74|         }
    75|         return parent::bindValue($cell, $value);
    76|     }
    77|     protected function setImproperFraction(array $matches, Cell $cell): bool
    78|     {
    79|         $value = $matches[2] + ($matches[3] / $matches[4]);
    80|         if ($matches[1] === '-') {
    81|             $value = 0 - $value;
    82|         }
    83|         $cell->setValueExplicit((float) $value, DataType::TYPE_NUMERIC);
    84|         $dividend = str_repeat('?', strlen($matches[3]));
    85|         $divisor = str_repeat('?', strlen($matches[4]));
    86|         $fractionMask = "# {$dividend}/{$divisor}";
    87|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
    88|             ->getNumberFormat()->setFormatCode($fractionMask);
    89|         return true;
    90|     }
    91|     protected function setProperFraction(array $matches, Cell $cell): bool
    92|     {
    93|         $value = $matches[2] / $matches[3];
    94|         if ($matches[1] === '-') {
    95|             $value = 0 - $value;
    96|         }
    97|         $cell->setValueExplicit((float) $value, DataType::TYPE_NUMERIC);
    98|         $dividend = str_repeat('?', strlen($matches[2]));
    99|         $divisor = str_repeat('?', strlen($matches[3]));
   100|         $fractionMask = "{$dividend}/{$divisor}";
   101|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
   102|             ->getNumberFormat()->setFormatCode($fractionMask);
   103|         return true;
   104|     }
   105|     protected function setPercentage(string $value, Cell $cell): bool
   106|     {
   107|         $value = ((float) str_replace('%', '', $value)) / 100;
   108|         $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
   109|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
   110|             ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_PERCENTAGE_00);
   111|         return true;
   112|     }
   113|     protected function setCurrency(float $value, Cell $cell, string $currencyCode): bool
   114|     {
   115|         $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
   116|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
   117|             ->getNumberFormat()->setFormatCode(
   118|                 str_replace('$', '[$' . $currencyCode . ']', NumberFormat::FORMAT_CURRENCY_USD)
   119|             );
   120|         return true;
   121|     }
   122|     protected function setTimeHoursMinutes(string $value, Cell $cell): bool
   123|     {
   124|         [$hours, $minutes] = explode(':', $value);
   125|         $hours = (int) $hours;
   126|         $minutes = (int) $minutes;
   127|         $days = ($hours / 24) + ($minutes / 1440);
   128|         $cell->setValueExplicit($days, DataType::TYPE_NUMERIC);
   129|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
   130|             ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_DATE_TIME3);
   131|         return true;
   132|     }
   133|     protected function setTimeHoursMinutesSeconds(string $value, Cell $cell): bool
   134|     {
   135|         [$hours, $minutes, $seconds] = explode(':', $value);
   136|         $hours = (int) $hours;
   137|         $minutes = (int) $minutes;
   138|         $seconds = (int) $seconds;
   139|         $days = ($hours / 24) + ($minutes / 1440) + ($seconds / 86400);
   140|         $cell->setValueExplicit($days, DataType::TYPE_NUMERIC);
   141|         $cell->getWorksheet()->getStyle($cell->getCoordinate())
   142|             ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_DATE_TIME4);
   143|         return true;
   144|     }
   145| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/Cell.php
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 26-67 ---
    26|      * Value of the cell.
    27|      */
    28|     private mixed $value;
    29|     /**
    30|      *    Calculated value of the cell (used for caching)
    31|      *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
    32|      *        create the original spreadsheet file.
    33|      *    Note that this value is not guaranteed to reflect the actual calculated value because it is
    34|      *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data
    35|      *        values used by the formula have changed since it was last calculated.
    36|      *
    37|      * @var mixed
    38|      */
    39|     private $calculatedValue;
    40|     /**
    41|      * Type of the cell data.
    42|      */
    43|     private string $dataType;
    44|     /**
    45|      * The collection of cells that this cell belongs to (i.e. The Cell Collection for the parent Worksheet).
    46|      *
    47|      * @var ?Cells
    48|      */
    49|     private ?Cells $parent;
    50|     /**
    51|      * Index to the cellXf reference for the styling of this cell.
    52|      */
    53|     private int $xfIndex = 0;
    54|     /**
    55|      * Attributes of the formula.
    56|      */
    57|     private mixed $formulaAttributes = null;
    58|     private IgnoredErrors $ignoredErrors;
    59|     /**
    60|      * Update the cell into the cell collection.
    61|      *
    62|      * @throws SpreadsheetException
    63|      */
    64|     public function updateInCollection(): self
    65|     {
    66|         $parent = $this->parent;
    67|         if ($parent === null) {

# --- HUNK 2: Lines 248-288 ---
   248|                 }
   249|                 $this->value = (string) $value;
   250|                 break;
   251|             case DataType::TYPE_BOOL:
   252|                 $this->value = (bool) $value;
   253|                 break;
   254|             case DataType::TYPE_ISO_DATE:
   255|                 $this->value = SharedDate::convertIsoDate($value);
   256|                 $dataType = DataType::TYPE_NUMERIC;
   257|                 break;
   258|             case DataType::TYPE_ERROR:
   259|                 $this->value = DataType::checkErrorCode($value);
   260|                 break;
   261|             default:
   262|                 throw new SpreadsheetException('Invalid datatype: ' . $dataType);
   263|         }
   264|         $this->dataType = $dataType;
   265|         $this->updateInCollection();
   266|         $cellCoordinate = $this->getCoordinate();
   267|         self::updateIfCellIsTableHeader($this->getParent()?->getParent(), $this, $oldValue, $value);
   268|         $this->getWorksheet()->applyStylesFromArray($cellCoordinate, ['quotePrefix' => $quotePrefix]);
   269|         return $this->getParent()?->get($cellCoordinate) ?? $this;
   270|     }
   271|     public const CALCULATE_DATE_TIME_ASIS = 0;
   272|     public const CALCULATE_DATE_TIME_FLOAT = 1;
   273|     public const CALCULATE_TIME_FLOAT = 2;
   274|     private static int $calculateDateTimeType = self::CALCULATE_DATE_TIME_ASIS;
   275|     public static function getCalculateDateTimeType(): int
   276|     {
   277|         return self::$calculateDateTimeType;
   278|     }
   279|     /** @throws CalculationException */
   280|     public static function setCalculateDateTimeType(int $calculateDateTimeType): void
   281|     {
   282|         self::$calculateDateTimeType = match ($calculateDateTimeType) {
   283|             self::CALCULATE_DATE_TIME_ASIS, self::CALCULATE_DATE_TIME_FLOAT, self::CALCULATE_TIME_FLOAT => $calculateDateTimeType,
   284|             default => throw new CalculationException("Invalid value $calculateDateTimeType for calculated date time type"),
   285|         };
   286|     }
   287|     /**
   288|      * Convert date, time, or datetime from int to float if desired.


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/Coordinate.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-592 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use PhpOffice\PhpSpreadsheet\Exception;
     4| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     5| /**
     6|  * Helper class to manipulate cell coordinates.
     7|  *
     8|  * Columns indexes and rows are always based on 1, **not** on 0. This match the behavior
     9|  * that Excel users are used to, and also match the Excel functions `COLUMN()` and `ROW()`.
    10|  */
    11| abstract class Coordinate
    12| {
    13|     public const A1_COORDINATE_REGEX = '/^(?<col>\$?[A-Z]{1,3})(?<row>\$?\d{1,7})$/i';
    14|     public const FULL_REFERENCE_REGEX = '/^(?:(?<worksheet>[^!]*)!)?(?<localReference>(?<firstCoordinate>[$]?[A-Z]{1,3}[$]?\d{1,7})(?:\:(?<secondCoordinate>[$]?[A-Z]{1,3}[$]?\d{1,7}))?)$/i';
    15|     /**
    16|      * Default range variable constant.
    17|      *
    18|      * @var string
    19|      */
    20|     const DEFAULT_RANGE = 'A1:A1';
    21|     /**
    22|      * Convert string coordinate to [0 => int column index, 1 => int row index].
    23|      *
    24|      * @param string $cellAddress eg: 'A1'
    25|      *
    26|      * @return array{0: string, 1: string} Array containing column and row (indexes 0 and 1)
    27|      */
    28|     public static function coordinateFromString(string $cellAddress): array
    29|     {
    30|         if (preg_match(self::A1_COORDINATE_REGEX, $cellAddress, $matches)) {
    31|             return [$matches['col'], $matches['row']];
    32|         } elseif (self::coordinateIsRange($cellAddress)) {
    33|             throw new Exception('Cell coordinate string can not be a range of cells');
    34|         } elseif ($cellAddress == '') {
    35|             throw new Exception('Cell coordinate can not be zero-length string');
    36|         }
    37|         throw new Exception('Invalid cell coordinate ' . $cellAddress);
    38|     }
    39|     /**
    40|      * Convert string coordinate to [0 => int column index, 1 => int row index, 2 => string column string].
    41|      *
    42|      * @param string $coordinates eg: 'A1', '$B$12'
    43|      *
    44|      * @return array{0: int, 1: int, 2: string} Array containing column and row index, and column string
    45|      */
    46|     public static function indexesFromString(string $coordinates): array
    47|     {
    48|         [$column, $row] = self::coordinateFromString($coordinates);
    49|         $column = ltrim($column, '$');
    50|         return [
    51|             self::columnIndexFromString($column),
    52|             (int) ltrim($row, '$'),
    53|             $column,
    54|         ];
    55|     }
    56|     /**
    57|      * Checks if a Cell Address represents a range of cells.
    58|      *
    59|      * @param string $cellAddress eg: 'A1' or 'A1:A2' or 'A1:A2,C1:C2'
    60|      *
    61|      * @return bool Whether the coordinate represents a range of cells
    62|      */
    63|     public static function coordinateIsRange(string $cellAddress): bool
    64|     {
    65|         return str_contains($cellAddress, ':') || str_contains($cellAddress, ',');
    66|     }
    67|     /**
    68|      * Make string row, column or cell coordinate absolute.
    69|      *
    70|      * @param int|string $cellAddress e.g. 'A' or '1' or 'A1'
    71|      *                    Note that this value can be a row or column reference as well as a cell reference
    72|      *
    73|      * @return string Absolute coordinate        e.g. '$A' or '$1' or '$A$1'
    74|      */
    75|     public static function absoluteReference(int|string $cellAddress): string
    76|     {
    77|         $cellAddress = (string) $cellAddress;
    78|         if (self::coordinateIsRange($cellAddress)) {
    79|             throw new Exception('Cell coordinate string can not be a range of cells');
    80|         }
    81|         [$worksheet, $cellAddress] = Worksheet::extractSheetTitle($cellAddress, true);
    82|         if ($worksheet > '') {
    83|             $worksheet .= '!';
    84|         }
    85|         $cellAddress = "$cellAddress";
    86|         if (ctype_digit($cellAddress)) {
    87|             return $worksheet . '$' . $cellAddress;
    88|         } elseif (ctype_alpha($cellAddress)) {
    89|             return $worksheet . '$' . strtoupper($cellAddress);
    90|         }
    91|         return $worksheet . self::absoluteCoordinate($cellAddress);
    92|     }
    93|     /**
    94|      * Make string coordinate absolute.
    95|      *
    96|      * @param string $cellAddress e.g. 'A1'
    97|      *
    98|      * @return string Absolute coordinate        e.g. '$A$1'
    99|      */
   100|     public static function absoluteCoordinate(string $cellAddress): string
   101|     {
   102|         if (self::coordinateIsRange($cellAddress)) {
   103|             throw new Exception('Cell coordinate string can not be a range of cells');
   104|         }
   105|         [$worksheet, $cellAddress] = Worksheet::extractSheetTitle($cellAddress, true);
   106|         if ($worksheet > '') {
   107|             $worksheet .= '!';
   108|         }
   109|         [$column, $row] = self::coordinateFromString($cellAddress ?? 'A1');
   110|         $column = ltrim($column, '$');
   111|         $row = ltrim($row, '$');
   112|         return $worksheet . '$' . $column . '$' . $row;
   113|     }
   114|     /**
   115|      * Split range into coordinate strings.
   116|      *
   117|      * @param string $range e.g. 'B4:D9' or 'B4:D9,H2:O11' or 'B4'
   118|      *
   119|      * @return array Array containing one or more arrays containing one or two coordinate strings
   120|      *                                e.g. ['B4','D9'] or [['B4','D9'], ['H2','O11']]
   121|      *                                        or ['B4']
   122|      */
   123|     public static function splitRange(string $range): array
   124|     {
   125|         if (empty($range)) {
   126|             $range = self::DEFAULT_RANGE;
   127|         }
   128|         $exploded = explode(',', $range);
   129|         $outArray = [];
   130|         foreach ($exploded as $value) {
   131|             $outArray[] = explode(':', $value);
   132|         }
   133|         return $outArray;
   134|     }
   135|     /**
   136|      * Build range from coordinate strings.
   137|      *
   138|      * @param array $range Array containing one or more arrays containing one or two coordinate strings
   139|      *
   140|      * @return string String representation of $pRange
   141|      */
   142|     public static function buildRange(array $range): string
   143|     {
   144|         if (empty($range) || !is_array($range[0])) {
   145|             throw new Exception('Range does not contain any information');
   146|         }
   147|         $counter = count($range);
   148|         for ($i = 0; $i < $counter; ++$i) {
   149|             $range[$i] = implode(':', $range[$i]);
   150|         }
   151|         return implode(',', $range);
   152|     }
   153|     /**
   154|      * Calculate range boundaries.
   155|      *
   156|      * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
   157|      *
   158|      * @return array Range coordinates [Start Cell, End Cell]
   159|      *                    where Start Cell and End Cell are arrays (Column Number, Row Number)
   160|      */
   161|     public static function rangeBoundaries(string $range): array
   162|     {
   163|         if (empty($range)) {
   164|             $range = self::DEFAULT_RANGE;
   165|         }
   166|         $range = strtoupper($range);
   167|         if (!str_contains($range, ':')) {
   168|             $rangeA = $rangeB = $range;
   169|         } else {
   170|             [$rangeA, $rangeB] = explode(':', $range);
   171|         }
   172|         if (is_numeric($rangeA) && is_numeric($rangeB)) {
   173|             $rangeA = 'A' . $rangeA;
   174|             $rangeB = AddressRange::MAX_COLUMN . $rangeB;
   175|         }
   176|         if (ctype_alpha($rangeA) && ctype_alpha($rangeB)) {
   177|             $rangeA = $rangeA . '1';
   178|             $rangeB = $rangeB . AddressRange::MAX_ROW;
   179|         }
   180|         $rangeStart = self::coordinateFromString($rangeA);
   181|         $rangeEnd = self::coordinateFromString($rangeB);
   182|         $rangeStart[0] = self::columnIndexFromString($rangeStart[0]);
   183|         $rangeEnd[0] = self::columnIndexFromString($rangeEnd[0]);
   184|         return [$rangeStart, $rangeEnd];
   185|     }
   186|     /**
   187|      * Calculate range dimension.
   188|      *
   189|      * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
   190|      *
   191|      * @return array Range dimension (width, height)
   192|      */
   193|     public static function rangeDimension(string $range): array
   194|     {
   195|         [$rangeStart, $rangeEnd] = self::rangeBoundaries($range);
   196|         return [($rangeEnd[0] - $rangeStart[0] + 1), ($rangeEnd[1] - $rangeStart[1] + 1)];
   197|     }
   198|     /**
   199|      * Calculate range boundaries.
   200|      *
   201|      * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
   202|      *
   203|      * @return array Range coordinates [Start Cell, End Cell]
   204|      *                    where Start Cell and End Cell are arrays [Column ID, Row Number]
   205|      */
   206|     public static function getRangeBoundaries(string $range): array
   207|     {
   208|         [$rangeA, $rangeB] = self::rangeBoundaries($range);
   209|         return [
   210|             [self::stringFromColumnIndex($rangeA[0]), $rangeA[1]],
   211|             [self::stringFromColumnIndex($rangeB[0]), $rangeB[1]],
   212|         ];
   213|     }
   214|     /**
   215|      * Check if cell or range reference is valid and return an array with type of reference (cell or range), worksheet (if it was given)
   216|      * and the coordinate or the first coordinate and second coordinate if it is a range.
   217|      *
   218|      * @param string $reference Coordinate or Range (e.g. A1:A1, B2, B:C, 2:3)
   219|      *
   220|      * @return array reference data
   221|      */
   222|     private static function validateReferenceAndGetData($reference): array
   223|     {
   224|         $data = [];
   225|         preg_match(self::FULL_REFERENCE_REGEX, $reference, $matches);
   226|         if (count($matches) === 0) {
   227|             return ['type' => 'invalid'];
   228|         }
   229|         if (isset($matches['secondCoordinate'])) {
   230|             $data['type'] = 'range';
   231|             $data['firstCoordinate'] = str_replace('$', '', $matches['firstCoordinate']);
   232|             $data['secondCoordinate'] = str_replace('$', '', $matches['secondCoordinate']);
   233|         } else {
   234|             $data['type'] = 'coordinate';
   235|             $data['coordinate'] = str_replace('$', '', $matches['firstCoordinate']);
   236|         }
   237|         $worksheet = $matches['worksheet'];
   238|         if ($worksheet !== '') {
   239|             if (substr($worksheet, 0, 1) === "'" && substr($worksheet, -1, 1) === "'") {
   240|                 $worksheet = substr($worksheet, 1, -1);
   241|             }
   242|             $data['worksheet'] = strtolower($worksheet);
   243|         }
   244|         $data['localReference'] = str_replace('$', '', $matches['localReference']);
   245|         return $data;
   246|     }
   247|     /**
   248|      * Check if coordinate is inside a range.
   249|      *
   250|      * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
   251|      * @param string $coordinate Cell coordinate (e.g. A1)
   252|      *
   253|      * @return bool true if coordinate is inside range
   254|      */
   255|     public static function coordinateIsInsideRange(string $range, string $coordinate): bool
   256|     {
   257|         $rangeData = self::validateReferenceAndGetData($range);
   258|         if ($rangeData['type'] === 'invalid') {
   259|             throw new Exception('First argument needs to be a range');
   260|         }
   261|         $coordinateData = self::validateReferenceAndGetData($coordinate);
   262|         if ($coordinateData['type'] === 'invalid') {
   263|             throw new Exception('Second argument needs to be a single coordinate');
   264|         }
   265|         if (isset($coordinateData['worksheet']) && !isset($rangeData['worksheet'])) {
   266|             return false;
   267|         }
   268|         if (!isset($coordinateData['worksheet']) && isset($rangeData['worksheet'])) {
   269|             return false;
   270|         }
   271|         if (isset($coordinateData['worksheet'], $rangeData['worksheet'])) {
   272|             if ($coordinateData['worksheet'] !== $rangeData['worksheet']) {
   273|                 return false;
   274|             }
   275|         }
   276|         $boundaries = self::rangeBoundaries($rangeData['localReference']);
   277|         $coordinates = self::indexesFromString($coordinateData['localReference']);
   278|         $columnIsInside = $boundaries[0][0] <= $coordinates[0] && $coordinates[0] <= $boundaries[1][0];
   279|         if (!$columnIsInside) {
   280|             return false;
   281|         }
   282|         $rowIsInside = $boundaries[0][1] <= $coordinates[1] && $coordinates[1] <= $boundaries[1][1];
   283|         if (!$rowIsInside) {
   284|             return false;
   285|         }
   286|         return true;
   287|     }
   288|     /**
   289|      * Column index from string.
   290|      *
   291|      * @param ?string $columnAddress eg 'A'
   292|      *
   293|      * @return int Column index (A = 1)
   294|      */
   295|     public static function columnIndexFromString(?string $columnAddress): int
   296|     {
   297|         static $indexCache = [];
   298|         $columnAddress = $columnAddress ?? '';
   299|         if (isset($indexCache[$columnAddress])) {
   300|             return $indexCache[$columnAddress];
   301|         }
   302|         static $columnLookup = [
   303|             'A' => 1, 'B' => 2, 'C' => 3, 'D' => 4, 'E' => 5, 'F' => 6, 'G' => 7, 'H' => 8, 'I' => 9, 'J' => 10,
   304|             'K' => 11, 'L' => 12, 'M' => 13, 'N' => 14, 'O' => 15, 'P' => 16, 'Q' => 17, 'R' => 18, 'S' => 19,
   305|             'T' => 20, 'U' => 21, 'V' => 22, 'W' => 23, 'X' => 24, 'Y' => 25, 'Z' => 26,
   306|             'a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5, 'f' => 6, 'g' => 7, 'h' => 8, 'i' => 9, 'j' => 10,
   307|             'k' => 11, 'l' => 12, 'm' => 13, 'n' => 14, 'o' => 15, 'p' => 16, 'q' => 17, 'r' => 18, 's' => 19,
   308|             't' => 20, 'u' => 21, 'v' => 22, 'w' => 23, 'x' => 24, 'y' => 25, 'z' => 26,
   309|         ];
   310|         if (isset($columnAddress[0])) {
   311|             if (!isset($columnAddress[1])) {
   312|                 $indexCache[$columnAddress] = $columnLookup[$columnAddress];
   313|                 return $indexCache[$columnAddress];
   314|             } elseif (!isset($columnAddress[2])) {
   315|                 $indexCache[$columnAddress] = $columnLookup[$columnAddress[0]] * 26
   316|                     + $columnLookup[$columnAddress[1]];
   317|                 return $indexCache[$columnAddress];
   318|             } elseif (!isset($columnAddress[3])) {
   319|                 $indexCache[$columnAddress] = $columnLookup[$columnAddress[0]] * 676
   320|                     + $columnLookup[$columnAddress[1]] * 26
   321|                     + $columnLookup[$columnAddress[2]];
   322|                 return $indexCache[$columnAddress];
   323|             }
   324|         }
   325|         throw new Exception(
   326|             'Column string index can not be ' . ((isset($columnAddress[0])) ? 'longer than 3 characters' : 'empty')
   327|         );
   328|     }
   329|     /**
   330|      * String from column index.
   331|      *
   332|      * @param int|numeric-string $columnIndex Column index (A = 1)
   333|      */
   334|     public static function stringFromColumnIndex(int|string $columnIndex): string
   335|     {
   336|         static $indexCache = [];
   337|         static $lookupCache = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ';
   338|         if (!isset($indexCache[$columnIndex])) {
   339|             $indexValue = $columnIndex;
   340|             $base26 = '';
   341|             do {
   342|                 $characterValue = ($indexValue % 26) ?: 26;
   343|                 $indexValue = ($indexValue - $characterValue) / 26;
   344|                 $base26 = $lookupCache[$characterValue] . $base26;
   345|             } while ($indexValue > 0);
   346|             $indexCache[$columnIndex] = $base26;
   347|         }
   348|         return $indexCache[$columnIndex];
   349|     }
   350|     /**
   351|      * Extract all cell references in range, which may be comprised of multiple cell ranges.
   352|      *
   353|      * @param string $cellRange Range: e.g. 'A1' or 'A1:C10' or 'A1:E10,A20:E25' or 'A1:E5 C3:G7' or 'A1:C1,A3:C3 B1:C3'
   354|      *
   355|      * @return array Array containing single cell references
   356|      */
   357|     public static function extractAllCellReferencesInRange(string $cellRange): array
   358|     {
   359|         if (substr_count($cellRange, '!') > 1) {
   360|             throw new Exception('3-D Range References are not supported');
   361|         }
   362|         [$worksheet, $cellRange] = Worksheet::extractSheetTitle($cellRange, true);
   363|         $quoted = '';
   364|         if ($worksheet) {
   365|             $quoted = Worksheet::nameRequiresQuotes($worksheet) ? "'" : '';
   366|             if (str_starts_with($worksheet, "'") && str_ends_with($worksheet, "'")) {
   367|                 $worksheet = substr($worksheet, 1, -1);
   368|             }
   369|             $worksheet = str_replace("'", "''", $worksheet);
   370|         }
   371|         [$ranges, $operators] = self::getCellBlocksFromRangeString($cellRange ?? 'A1');
   372|         $cells = [];
   373|         foreach ($ranges as $range) {
   374|             $cells[] = self::getReferencesForCellBlock($range);
   375|         }
   376|         $cells = self::processRangeSetOperators($operators, $cells);
   377|         if (empty($cells)) {
   378|             return [];
   379|         }
   380|         $cellList = array_merge(...$cells);
   381|         return array_map(
   382|             fn ($cellAddress) => ($worksheet !== '') ? "{$quoted}{$worksheet}{$quoted}!{$cellAddress}" : $cellAddress,
   383|             self::sortCellReferenceArray($cellList)
   384|         );
   385|     }
   386|     private static function processRangeSetOperators(array $operators, array $cells): array
   387|     {
   388|         $operatorCount = count($operators);
   389|         for ($offset = 0; $offset < $operatorCount; ++$offset) {
   390|             $operator = $operators[$offset];
   391|             if ($operator !== ' ') {
   392|                 continue;
   393|             }
   394|             $cells[$offset] = array_intersect($cells[$offset], $cells[$offset + 1]);
   395|             unset($operators[$offset], $cells[$offset + 1]);
   396|             $operators = array_values($operators);
   397|             $cells = array_values($cells);
   398|             --$offset;
   399|             --$operatorCount;
   400|         }
   401|         return $cells;
   402|     }
   403|     private static function sortCellReferenceArray(array $cellList): array
   404|     {
   405|         $sortKeys = [];
   406|         foreach ($cellList as $coordinate) {
   407|             $column = '';
   408|             $row = 0;
   409|             sscanf($coordinate, '%[A-Z]%d', $column, $row);
   410|             $key = (--$row * 16384) + self::columnIndexFromString((string) $column);
   411|             $sortKeys[$key] = $coordinate;
   412|         }
   413|         ksort($sortKeys);
   414|         return array_values($sortKeys);
   415|     }
   416|     /**
   417|      * Get all cell references applying union and intersection.
   418|      *
   419|      * @param string $cellBlock A cell range e.g. A1:B5,D1:E5 B2:C4
   420|      *
   421|      * @return string A string without intersection operator.
   422|      *   If there was no intersection to begin with, return original argument.
   423|      *   Otherwise, return cells and/or cell ranges in that range separated by comma.
   424|      */
   425|     public static function resolveUnionAndIntersection(string $cellBlock, string $implodeCharacter = ','): string
   426|     {
   427|         $cellBlock = preg_replace('/  +/', ' ', trim($cellBlock)) ?? $cellBlock;
   428|         $cellBlock = preg_replace('/ ,/', ',', $cellBlock) ?? $cellBlock;
   429|         $cellBlock = preg_replace('/, /', ',', $cellBlock) ?? $cellBlock;
   430|         $array1 = [];
   431|         $blocks = explode(',', $cellBlock);
   432|         foreach ($blocks as $block) {
   433|             $block0 = explode(' ', $block);
   434|             if (count($block0) === 1) {
   435|                 $array1 = array_merge($array1, $block0);
   436|             } else {
   437|                 $blockIdx = -1;
   438|                 $array2 = [];
   439|                 foreach ($block0 as $block00) {
   440|                     ++$blockIdx;
   441|                     if ($blockIdx === 0) {
   442|                         $array2 = self::getReferencesForCellBlock($block00);
   443|                     } else {
   444|                         $array2 = array_intersect($array2, self::getReferencesForCellBlock($block00));
   445|                     }
   446|                 }
   447|                 $array1 = array_merge($array1, $array2);
   448|             }
   449|         }
   450|         return implode($implodeCharacter, $array1);
   451|     }
   452|     /**
   453|      * Get all cell references for an individual cell block.
   454|      *
   455|      * @param string $cellBlock A cell range e.g. A4:B5
   456|      *
   457|      * @return array All individual cells in that range
   458|      */
   459|     private static function getReferencesForCellBlock(string $cellBlock): array
   460|     {
   461|         $returnValue = [];
   462|         if (!self::coordinateIsRange($cellBlock)) {
   463|             return (array) $cellBlock;
   464|         }
   465|         $ranges = self::splitRange($cellBlock);
   466|         foreach ($ranges as $range) {
   467|             if (!isset($range[1])) {
   468|                 $returnValue[] = $range[0];
   469|                 continue;
   470|             }
   471|             [$rangeStart, $rangeEnd] = $range;
   472|             [$startColumn, $startRow] = self::coordinateFromString($rangeStart);
   473|             [$endColumn, $endRow] = self::coordinateFromString($rangeEnd);
   474|             $startColumnIndex = self::columnIndexFromString($startColumn);
   475|             $endColumnIndex = self::columnIndexFromString($endColumn);
   476|             ++$endColumnIndex;
   477|             $currentColumnIndex = $startColumnIndex;
   478|             $currentRow = $startRow;
   479|             self::validateRange($cellBlock, $startColumnIndex, $endColumnIndex, (int) $currentRow, (int) $endRow);
   480|             while ($currentColumnIndex < $endColumnIndex) {
   481|                 while ($currentRow <= $endRow) {
   482|                     $returnValue[] = self::stringFromColumnIndex($currentColumnIndex) . $currentRow;
   483|                     ++$currentRow;
   484|                 }
   485|                 ++$currentColumnIndex;
   486|                 $currentRow = $startRow;
   487|             }
   488|         }
   489|         return $returnValue;
   490|     }
   491|     /**
   492|      * Convert an associative array of single cell coordinates to values to an associative array
   493|      * of cell ranges to values.  Only adjacent cell coordinates with the same
   494|      * value will be merged.  If the value is an object, it must implement the method getHashCode().
   495|      *
   496|      * For example, this function converts:
   497|      *
   498|      *    [ 'A1' => 'x', 'A2' => 'x', 'A3' => 'x', 'A4' => 'y' ]
   499|      *
   500|      * to:
   501|      *
   502|      *    [ 'A1:A3' => 'x', 'A4' => 'y' ]
   503|      *
   504|      * @param array $coordinateCollection associative array mapping coordinates to values
   505|      *
   506|      * @return array associative array mapping coordinate ranges to valuea
   507|      */
   508|     public static function mergeRangesInCollection(array $coordinateCollection): array
   509|     {
   510|         $hashedValues = [];
   511|         $mergedCoordCollection = [];
   512|         foreach ($coordinateCollection as $coord => $value) {
   513|             if (self::coordinateIsRange($coord)) {
   514|                 $mergedCoordCollection[$coord] = $value;
   515|                 continue;
   516|             }
   517|             [$column, $row] = self::coordinateFromString($coord);
   518|             $row = (int) (ltrim($row, '$'));
   519|             $hashCode = $column . '-' . ((is_object($value) && method_exists($value, 'getHashCode')) ? $value->getHashCode() : $value);
   520|             if (!isset($hashedValues[$hashCode])) {
   521|                 $hashedValues[$hashCode] = (object) [
   522|                     'value' => $value,
   523|                     'col' => $column,
   524|                     'rows' => [$row],
   525|                 ];
   526|             } else {
   527|                 $hashedValues[$hashCode]->rows[] = $row;
   528|             }
   529|         }
   530|         ksort($hashedValues);
   531|         foreach ($hashedValues as $hashedValue) {
   532|             sort($hashedValue->rows);
   533|             $rowStart = null;
   534|             $rowEnd = null;
   535|             $ranges = [];
   536|             foreach ($hashedValue->rows as $row) {
   537|                 if ($rowStart === null) {
   538|                     $rowStart = $row;
   539|                     $rowEnd = $row;
   540|                 } elseif ($rowEnd === $row - 1) {
   541|                     $rowEnd = $row;
   542|                 } else {
   543|                     if ($rowStart == $rowEnd) {
   544|                         $ranges[] = $hashedValue->col . $rowStart;
   545|                     } else {
   546|                         $ranges[] = $hashedValue->col . $rowStart . ':' . $hashedValue->col . $rowEnd;
   547|                     }
   548|                     $rowStart = $row;
   549|                     $rowEnd = $row;
   550|                 }
   551|             }
   552|             if ($rowStart !== null) {
   553|                 if ($rowStart == $rowEnd) {
   554|                     $ranges[] = $hashedValue->col . $rowStart;
   555|                 } else {
   556|                     $ranges[] = $hashedValue->col . $rowStart . ':' . $hashedValue->col . $rowEnd;
   557|                 }
   558|             }
   559|             foreach ($ranges as $range) {
   560|                 $mergedCoordCollection[$range] = $hashedValue->value;
   561|             }
   562|         }
   563|         return $mergedCoordCollection;
   564|     }
   565|     /**
   566|      * Get the individual cell blocks from a range string, removing any $ characters.
   567|      *      then splitting by operators and returning an array with ranges and operators.
   568|      *
   569|      * @return array[]
   570|      */
   571|     private static function getCellBlocksFromRangeString(string $rangeString): array
   572|     {
   573|         $rangeString = str_replace('$', '', strtoupper($rangeString));
   574|         $tokens = preg_split('/([ ,])/', $rangeString, -1, PREG_SPLIT_DELIM_CAPTURE) ?: [];
   575|         $split = array_chunk($tokens, 2);
   576|         $ranges = array_column($split, 0);
   577|         $operators = array_column($split, 1);
   578|         return [$ranges, $operators];
   579|     }
   580|     /**
   581|      * Check that the given range is valid, i.e. that the start column and row are not greater than the end column and
   582|      * row.
   583|      *
   584|      * @param string $cellBlock The original range, for displaying a meaningful error message
   585|      */
   586|     private static function validateRange(string $cellBlock, int $startColumnIndex, int $endColumnIndex, int $currentRow, int $endRow): void
   587|     {
   588|         if ($startColumnIndex >= $endColumnIndex || $currentRow > $endRow) {
   589|             throw new Exception('Invalid range: "' . $cellBlock . '"');
   590|         }
   591|     }
   592| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/DataType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     4| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     5| use Stringable;
     6| class DataType
     7| {
     8|     const TYPE_STRING2 = 'str';
     9|     const TYPE_STRING = 's';
    10|     const TYPE_FORMULA = 'f';
    11|     const TYPE_NUMERIC = 'n';
    12|     const TYPE_BOOL = 'b';
    13|     const TYPE_NULL = 'null';
    14|     const TYPE_INLINE = 'inlineStr';
    15|     const TYPE_ERROR = 'e';
    16|     const TYPE_ISO_DATE = 'd';
    17|     /**
    18|      * List of error codes.
    19|      *
    20|      * @var array<string, int>
    21|      */
    22|     private static array $errorCodes = [
    23|         '#NULL!' => 0,
    24|         '#DIV/0!' => 1,
    25|         '#VALUE!' => 2,
    26|         '#REF!' => 3,
    27|         '#NAME?' => 4,
    28|         '#NUM!' => 5,
    29|         '#N/A' => 6,
    30|         '#CALC!' => 7,
    31|     ];
    32|     public const MAX_STRING_LENGTH = 32767;
    33|     /**
    34|      * Get list of error codes.
    35|      *
    36|      * @return array<string, int>
    37|      */
    38|     public static function getErrorCodes(): array
    39|     {
    40|         return self::$errorCodes;
    41|     }
    42|     /**
    43|      * Check a string that it satisfies Excel requirements.
    44|      *
    45|      * @param null|RichText|string $textValue Value to sanitize to an Excel string
    46|      *
    47|      * @return RichText|string Sanitized value
    48|      */
    49|     public static function checkString(null|RichText|string $textValue): RichText|string
    50|     {
    51|         if ($textValue instanceof RichText) {
    52|             return $textValue;
    53|         }
    54|         $textValue = StringHelper::substring((string) $textValue, 0, self::MAX_STRING_LENGTH);
    55|         $textValue = str_replace(["\r\n", "\r"], "\n", $textValue);
    56|         return $textValue;
    57|     }
    58|     /**
    59|      * Check a value that it is a valid error code.
    60|      *
    61|      * @param mixed $value Value to sanitize to an Excel error code
    62|      *
    63|      * @return string Sanitized value
    64|      */
    65|     public static function checkErrorCode(mixed $value): string
    66|     {
    67|         $value = (is_scalar($value) || $value instanceof Stringable) ? ((string) $value) : '#NULL!';
    68|         if (!isset(self::$errorCodes[$value])) {
    69|             $value = '#NULL!';
    70|         }
    71|         return $value;
    72|     }
    73| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/DataValidator.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-101 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
     5| use PhpOffice\PhpSpreadsheet\Exception;
     6| /**
     7|  * Validate a cell value according to its validation rules.
     8|  */
     9| class DataValidator
    10| {
    11|     /**
    12|      * Does this cell contain valid value?
    13|      *
    14|      * @param Cell $cell Cell to check the value
    15|      */
    16|     public function isValid(Cell $cell): bool
    17|     {
    18|         if (!$cell->hasDataValidation() || $cell->getDataValidation()->getType() === DataValidation::TYPE_NONE) {
    19|             return true;
    20|         }
    21|         $cellValue = $cell->getValue();
    22|         $dataValidation = $cell->getDataValidation();
    23|         if (!$dataValidation->getAllowBlank() && ($cellValue === null || $cellValue === '')) {
    24|             return false;
    25|         }
    26|         $returnValue = false;
    27|         $type = $dataValidation->getType();
    28|         if ($type === DataValidation::TYPE_LIST) {
    29|             $returnValue = $this->isValueInList($cell);
    30|         } elseif ($type === DataValidation::TYPE_WHOLE) {
    31|             if (!is_numeric($cellValue) || fmod((float) $cellValue, 1) != 0) {
    32|                 $returnValue = false;
    33|             } else {
    34|                 $returnValue = $this->numericOperator($dataValidation, (int) $cellValue);
    35|             }
    36|         } elseif ($type === DataValidation::TYPE_DECIMAL || $type === DataValidation::TYPE_DATE || $type === DataValidation::TYPE_TIME) {
    37|             if (!is_numeric($cellValue)) {
    38|                 $returnValue = false;
    39|             } else {
    40|                 $returnValue = $this->numericOperator($dataValidation, (float) $cellValue);
    41|             }
    42|         } elseif ($type === DataValidation::TYPE_TEXTLENGTH) {
    43|             $returnValue = $this->numericOperator($dataValidation, mb_strlen($cell->getValueString()));
    44|         }
    45|         return $returnValue;
    46|     }
    47|     private function numericOperator(DataValidation $dataValidation, int|float $cellValue): bool
    48|     {
    49|         $operator = $dataValidation->getOperator();
    50|         $formula1 = $dataValidation->getFormula1();
    51|         $formula2 = $dataValidation->getFormula2();
    52|         $returnValue = false;
    53|         if ($operator === DataValidation::OPERATOR_BETWEEN) {
    54|             $returnValue = $cellValue >= $formula1 && $cellValue <= $formula2;
    55|         } elseif ($operator === DataValidation::OPERATOR_NOTBETWEEN) {
    56|             $returnValue = $cellValue < $formula1 || $cellValue > $formula2;
    57|         } elseif ($operator === DataValidation::OPERATOR_EQUAL) {
    58|             $returnValue = $cellValue == $formula1;
    59|         } elseif ($operator === DataValidation::OPERATOR_NOTEQUAL) {
    60|             $returnValue = $cellValue != $formula1;
    61|         } elseif ($operator === DataValidation::OPERATOR_LESSTHAN) {
    62|             $returnValue = $cellValue < $formula1;
    63|         } elseif ($operator === DataValidation::OPERATOR_LESSTHANOREQUAL) {
    64|             $returnValue = $cellValue <= $formula1;
    65|         } elseif ($operator === DataValidation::OPERATOR_GREATERTHAN) {
    66|             $returnValue = $cellValue > $formula1;
    67|         } elseif ($operator === DataValidation::OPERATOR_GREATERTHANOREQUAL) {
    68|             $returnValue = $cellValue >= $formula1;
    69|         }
    70|         return $returnValue;
    71|     }
    72|     /**
    73|      * Does this cell contain valid value, based on list?
    74|      *
    75|      * @param Cell $cell Cell to check the value
    76|      */
    77|     private function isValueInList(Cell $cell): bool
    78|     {
    79|         $cellValueString = $cell->getValueString();
    80|         $dataValidation = $cell->getDataValidation();
    81|         $formula1 = $dataValidation->getFormula1();
    82|         if (!empty($formula1)) {
    83|             if ($formula1[0] === '"') {
    84|                 return in_array(strtolower($cellValueString), explode(',', strtolower(trim($formula1, '"'))), true);
    85|             } elseif (strpos($formula1, ':') > 0) {
    86|                 $matchFormula = '=MATCH(' . $cell->getCoordinate() . ', ' . $formula1 . ', 0)';
    87|                 $calculation = Calculation::getInstance($cell->getWorksheet()->getParent());
    88|                 try {
    89|                     $result = $calculation->calculateFormula($matchFormula, $cell->getCoordinate(), $cell);
    90|                     while (is_array($result)) {
    91|                         $result = array_pop($result);
    92|                     }
    93|                     return $result !== ExcelError::NA();
    94|                 } catch (Exception) {
    95|                     return false;
    96|                 }
    97|             }
    98|         }
    99|         return true;
   100|     }
   101| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/DefaultValueBinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use DateTimeInterface;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalculationException;
     6| use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
     7| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     8| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     9| use Stringable;
    10| class DefaultValueBinder implements IValueBinder
    11| {
    12|     /**
    13|      * Bind value to a cell.
    14|      *
    15|      * @param Cell $cell Cell to bind value to
    16|      * @param mixed $value Value to bind in cell
    17|      */
    18|     public function bindValue(Cell $cell, mixed $value): bool
    19|     {
    20|         if (is_string($value)) {
    21|             $value = StringHelper::sanitizeUTF8($value);
    22|         } elseif ($value === null || is_scalar($value) || $value instanceof RichText) {
    23|         } elseif ($value instanceof DateTimeInterface) {
    24|             $value = $value->format('Y-m-d H:i:s');
    25|         } elseif ($value instanceof Stringable) {
    26|             $value = (string) $value;
    27|         } else {
    28|             throw new SpreadsheetException('Unable to bind unstringable ' . gettype($value));
    29|         }
    30|         $cell->setValueExplicit($value, static::dataTypeForValue($value));
    31|         return true;
    32|     }
    33|     /**
    34|      * DataType for value.
    35|      */
    36|     public static function dataTypeForValue(mixed $value): string
    37|     {
    38|         if ($value === null) {
    39|             return DataType::TYPE_NULL;
    40|         }
    41|         if (is_float($value) || is_int($value)) {
    42|             return DataType::TYPE_NUMERIC;
    43|         }
    44|         if (is_bool($value)) {
    45|             return DataType::TYPE_BOOL;
    46|         }
    47|         if ($value === '') {
    48|             return DataType::TYPE_STRING;
    49|         }
    50|         if ($value instanceof RichText) {
    51|             return DataType::TYPE_INLINE;
    52|         }
    53|         if ($value instanceof Stringable) {
    54|             $value = (string) $value;
    55|         }
    56|         if (!is_string($value)) {
    57|             $gettype = is_object($value) ? get_class($value) : gettype($value);
    58|             throw new SpreadsheetException("unusable type $gettype");
    59|         }
    60|         if (strlen($value) > 1 && $value[0] === '=') {
    61|             $calculation = new Calculation();
    62|             $calculation->disableBranchPruning();
    63|             try {
    64|                 if (empty($calculation->parseFormula($value))) {
    65|                     return DataType::TYPE_STRING;
    66|                 }
    67|             } catch (CalculationException $e) {
    68|                 $message = $e->getMessage();
    69|                 if (
    70|                     $message === 'Formula Error: An unexpected error occurred'
    71|                     || str_contains($message, 'has no operands')
    72|                 ) {
    73|                     return DataType::TYPE_STRING;
    74|                 }
    75|             }
    76|             return DataType::TYPE_FORMULA;
    77|         }
    78|         if (preg_match('/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/', $value)) {
    79|             $tValue = ltrim($value, '+-');
    80|             if (strlen($tValue) > 1 && $tValue[0] === '0' && $tValue[1] !== '.') {
    81|                 return DataType::TYPE_STRING;
    82|             } elseif ((!str_contains($value, '.')) && ($value > PHP_INT_MAX)) {
    83|                 return DataType::TYPE_STRING;
    84|             } elseif (!is_numeric($value)) {
    85|                 return DataType::TYPE_STRING;
    86|             }
    87|             return DataType::TYPE_NUMERIC;
    88|         }
    89|         $errorCodes = DataType::getErrorCodes();
    90|         if (isset($errorCodes[$value])) {
    91|             return DataType::TYPE_ERROR;
    92|         }
    93|         return DataType::TYPE_STRING;
    94|     }
    95| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/StringValueBinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Cell;
     3| use DateTimeInterface;
     4| use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
     5| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     6| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     7| use Stringable;
     8| class StringValueBinder extends DefaultValueBinder implements IValueBinder
     9| {
    10|     protected bool $convertNull = true;
    11|     protected bool $convertBoolean = true;
    12|     protected bool $convertNumeric = true;
    13|     protected bool $convertFormula = true;
    14|     public function setNullConversion(bool $suppressConversion = false): self
    15|     {
    16|         $this->convertNull = $suppressConversion;
    17|         return $this;
    18|     }
    19|     public function setBooleanConversion(bool $suppressConversion = false): self
    20|     {
    21|         $this->convertBoolean = $suppressConversion;
    22|         return $this;
    23|     }
    24|     public function getBooleanConversion(): bool
    25|     {
    26|         return $this->convertBoolean;
    27|     }
    28|     public function setNumericConversion(bool $suppressConversion = false): self
    29|     {
    30|         $this->convertNumeric = $suppressConversion;
    31|         return $this;
    32|     }
    33|     public function setFormulaConversion(bool $suppressConversion = false): self
    34|     {
    35|         $this->convertFormula = $suppressConversion;
    36|         return $this;
    37|     }
    38|     public function setConversionForAllValueTypes(bool $suppressConversion = false): self
    39|     {
    40|         $this->convertNull = $suppressConversion;
    41|         $this->convertBoolean = $suppressConversion;
    42|         $this->convertNumeric = $suppressConversion;
    43|         $this->convertFormula = $suppressConversion;
    44|         return $this;
    45|     }
    46|     /**
    47|      * Bind value to a cell.
    48|      *
    49|      * @param Cell $cell Cell to bind value to
    50|      * @param mixed $value Value to bind in cell
    51|      */
    52|     public function bindValue(Cell $cell, mixed $value): bool
    53|     {
    54|         if (is_object($value)) {
    55|             return $this->bindObjectValue($cell, $value);
    56|         }
    57|         if ($value !== null && !is_scalar($value)) {
    58|             throw new SpreadsheetException('Unable to bind unstringable ' . gettype($value));
    59|         }
    60|         if (is_string($value)) {
    61|             $value = StringHelper::sanitizeUTF8($value);
    62|         }
    63|         if ($value === null && $this->convertNull === false) {
    64|             $cell->setValueExplicit($value, DataType::TYPE_NULL);
    65|         } elseif (is_bool($value) && $this->convertBoolean === false) {
    66|             $cell->setValueExplicit($value, DataType::TYPE_BOOL);
    67|         } elseif ((is_int($value) || is_float($value)) && $this->convertNumeric === false) {
    68|             $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
    69|         } elseif (is_string($value) && strlen($value) > 1 && $value[0] === '=' && $this->convertFormula === false && parent::dataTypeForValue($value) === DataType::TYPE_FORMULA) {
    70|             $cell->setValueExplicit($value, DataType::TYPE_FORMULA);
    71|         } else {
    72|             $cell->setValueExplicit((string) $value, DataType::TYPE_STRING);
    73|         }
    74|         return true;
    75|     }
    76|     protected function bindObjectValue(Cell $cell, object $value): bool
    77|     {
    78|         if ($value instanceof DateTimeInterface) {
    79|             $value = $value->format('Y-m-d H:i:s');
    80|             $cell->setValueExplicit($value, DataType::TYPE_STRING);
    81|         } elseif ($value instanceof RichText) {
    82|             $cell->setValueExplicit($value, DataType::TYPE_INLINE);
    83|         } elseif ($value instanceof Stringable) {
    84|             $cell->setValueExplicit((string) $value, DataType::TYPE_STRING);
    85|         } else {
    86|             throw new SpreadsheetException('Unable to bind unstringable object of type ' . get_class($value));
    87|         }
    88|         return true;
    89|     }
    90| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Chart/Axis.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-295 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Chart;
     3| /**
     4|  * Created by PhpStorm.
     5|  * User: Wiktor Trzonkowski
     6|  * Date: 6/17/14
     7|  * Time: 12:11 PM.
     8|  */
     9| class Axis extends Properties
    10| {
    11|     const AXIS_TYPE_CATEGORY = 'catAx';
    12|     const AXIS_TYPE_DATE = 'dateAx';
    13|     const AXIS_TYPE_VALUE = 'valAx';
    14|     const TIME_UNIT_DAYS = 'days';
    15|     const TIME_UNIT_MONTHS = 'months';
    16|     const TIME_UNIT_YEARS = 'years';
    17|     public function __construct()
    18|     {
    19|         parent::__construct();
    20|         $this->fillColor = new ChartColor();
    21|     }
    22|     /**
    23|      * Chart Major Gridlines as.
    24|      */
    25|     private ?GridLines $majorGridlines = null;
    26|     /**
    27|      * Chart Minor Gridlines as.
    28|      */
    29|     private ?GridLines $minorGridlines = null;
    30|     /**
    31|      * Axis Number.
    32|      *
    33|      * @var array{format: string, source_linked: int, numeric: ?bool}
    34|      */
    35|     private array $axisNumber = [
    36|         'format' => self::FORMAT_CODE_GENERAL,
    37|         'source_linked' => 1,
    38|         'numeric' => null,
    39|     ];
    40|     private string $axisType = '';
    41|     private ?AxisText $axisText = null;
    42|     private ?Title $dispUnitsTitle = null;
    43|     /**
    44|      * Axis Options.
    45|      *
    46|      * @var array<string, null|string>
    47|      */
    48|     private array $axisOptions = [
    49|         'minimum' => null,
    50|         'maximum' => null,
    51|         'major_unit' => null,
    52|         'minor_unit' => null,
    53|         'orientation' => self::ORIENTATION_NORMAL,
    54|         'minor_tick_mark' => self::TICK_MARK_NONE,
    55|         'major_tick_mark' => self::TICK_MARK_NONE,
    56|         'axis_labels' => self::AXIS_LABELS_NEXT_TO,
    57|         'horizontal_crosses' => self::HORIZONTAL_CROSSES_AUTOZERO,
    58|         'horizontal_crosses_value' => null,
    59|         'textRotation' => null,
    60|         'hidden' => null,
    61|         'majorTimeUnit' => self::TIME_UNIT_YEARS,
    62|         'minorTimeUnit' => self::TIME_UNIT_MONTHS,
    63|         'baseTimeUnit' => self::TIME_UNIT_DAYS,
    64|         'logBase' => null,
    65|         'dispUnitsBuiltIn' => null,
    66|     ];
    67|     public const DISP_UNITS_HUNDREDS = 'hundreds';
    68|     public const DISP_UNITS_THOUSANDS = 'thousands';
    69|     public const DISP_UNITS_TEN_THOUSANDS = 'tenThousands';
    70|     public const DISP_UNITS_HUNDRED_THOUSANDS = 'hundredThousands';
    71|     public const DISP_UNITS_MILLIONS = 'millions';
    72|     public const DISP_UNITS_TEN_MILLIONS = 'tenMillions';
    73|     public const DISP_UNITS_HUNDRED_MILLIONS = 'hundredMillions';
    74|     public const DISP_UNITS_BILLIONS = 'billions';
    75|     public const DISP_UNITS_TRILLIONS = 'trillions';
    76|     public const TRILLION_INDEX = (PHP_INT_SIZE > 4) ? 1000000000000 : '1000000000000';
    77|     public const DISP_UNITS_BUILTIN_INT = [
    78|         100 => self::DISP_UNITS_HUNDREDS,
    79|         1000 => self::DISP_UNITS_THOUSANDS,
    80|         10000 => self::DISP_UNITS_TEN_THOUSANDS,
    81|         100000 => self::DISP_UNITS_HUNDRED_THOUSANDS,
    82|         1000000 => self::DISP_UNITS_MILLIONS,
    83|         10000000 => self::DISP_UNITS_TEN_MILLIONS,
    84|         100000000 => self::DISP_UNITS_HUNDRED_MILLIONS,
    85|         1000000000 => self::DISP_UNITS_BILLIONS,
    86|         self::TRILLION_INDEX => self::DISP_UNITS_TRILLIONS, // overflow for 32-bit
    87|     ];
    88|     /**
    89|      * Fill Properties.
    90|      */
    91|     private ChartColor $fillColor;
    92|     private const NUMERIC_FORMAT = [
    93|         Properties::FORMAT_CODE_NUMBER,
    94|         Properties::FORMAT_CODE_DATE,
    95|         Properties::FORMAT_CODE_DATE_ISO8601,
    96|     ];
    97|     private bool $noFill = false;
    98|     /**
    99|      * Get Series Data Type.
   100|      */
   101|     public function setAxisNumberProperties(string $format_code, ?bool $numeric = null, int $sourceLinked = 0): void
   102|     {
   103|         $format = $format_code;
   104|         $this->axisNumber['format'] = $format;
   105|         $this->axisNumber['source_linked'] = $sourceLinked;
   106|         if (is_bool($numeric)) {
   107|             $this->axisNumber['numeric'] = $numeric;
   108|         } elseif (in_array($format, self::NUMERIC_FORMAT, true)) {
   109|             $this->axisNumber['numeric'] = true;
   110|         }
   111|     }
   112|     /**
   113|      * Get Axis Number Format Data Type.
   114|      */
   115|     public function getAxisNumberFormat(): string
   116|     {
   117|         return $this->axisNumber['format'];
   118|     }
   119|     /**
   120|      * Get Axis Number Source Linked.
   121|      */
   122|     public function getAxisNumberSourceLinked(): string
   123|     {
   124|         return (string) $this->axisNumber['source_linked'];
   125|     }
   126|     public function getAxisIsNumericFormat(): bool
   127|     {
   128|         return $this->axisType === self::AXIS_TYPE_DATE || (bool) $this->axisNumber['numeric'];
   129|     }
   130|     public function setAxisOption(string $key, null|float|int|string $value): void
   131|     {
   132|         if ($value !== null && $value !== '') {
   133|             $this->axisOptions[$key] = (string) $value;
   134|         }
   135|     }
   136|     /**
   137|      * Set Axis Options Properties.
   138|      */
   139|     public function setAxisOptionsProperties(
   140|         string $axisLabels,
   141|         ?string $horizontalCrossesValue = null,
   142|         ?string $horizontalCrosses = null,
   143|         ?string $axisOrientation = null,
   144|         ?string $majorTmt = null,
   145|         ?string $minorTmt = null,
   146|         null|float|int|string $minimum = null,
   147|         null|float|int|string $maximum = null,
   148|         null|float|int|string $majorUnit = null,
   149|         null|float|int|string $minorUnit = null,
   150|         null|float|int|string $textRotation = null,
   151|         ?string $hidden = null,
   152|         ?string $baseTimeUnit = null,
   153|         ?string $majorTimeUnit = null,
   154|         ?string $minorTimeUnit = null,
   155|         null|float|int|string $logBase = null,
   156|         ?string $dispUnitsBuiltIn = null
   157|     ): void {
   158|         $this->axisOptions['axis_labels'] = $axisLabels;
   159|         $this->setAxisOption('horizontal_crosses_value', $horizontalCrossesValue);
   160|         $this->setAxisOption('horizontal_crosses', $horizontalCrosses);
   161|         $this->setAxisOption('orientation', $axisOrientation);
   162|         $this->setAxisOption('major_tick_mark', $majorTmt);
   163|         $this->setAxisOption('minor_tick_mark', $minorTmt);
   164|         $this->setAxisOption('minimum', $minimum);
   165|         $this->setAxisOption('maximum', $maximum);
   166|         $this->setAxisOption('major_unit', $majorUnit);
   167|         $this->setAxisOption('minor_unit', $minorUnit);
   168|         $this->setAxisOption('textRotation', $textRotation);
   169|         $this->setAxisOption('hidden', $hidden);
   170|         $this->setAxisOption('baseTimeUnit', $baseTimeUnit);
   171|         $this->setAxisOption('majorTimeUnit', $majorTimeUnit);
   172|         $this->setAxisOption('minorTimeUnit', $minorTimeUnit);
   173|         $this->setAxisOption('logBase', $logBase);
   174|         $this->setAxisOption('dispUnitsBuiltIn', $dispUnitsBuiltIn);
   175|     }
   176|     /**
   177|      * Get Axis Options Property.
   178|      */
   179|     public function getAxisOptionsProperty(string $property): ?string
   180|     {
   181|         if ($property === 'textRotation') {
   182|             if ($this->axisText !== null) {
   183|                 if ($this->axisText->getRotation() !== null) {
   184|                     return (string) $this->axisText->getRotation();
   185|                 }
   186|             }
   187|         }
   188|         return $this->axisOptions[$property];
   189|     }
   190|     /**
   191|      * Set Axis Orientation Property.
   192|      */
   193|     public function setAxisOrientation(string $orientation): void
   194|     {
   195|         $this->axisOptions['orientation'] = (string) $orientation;
   196|     }
   197|     public function getAxisType(): string
   198|     {
   199|         return $this->axisType;
   200|     }
   201|     public function setAxisType(string $type): self
   202|     {
   203|         if ($type === self::AXIS_TYPE_CATEGORY || $type === self::AXIS_TYPE_VALUE || $type === self::AXIS_TYPE_DATE) {
   204|             $this->axisType = $type;
   205|         } else {
   206|             $this->axisType = '';
   207|         }
   208|         return $this;
   209|     }
   210|     /**
   211|      * Set Fill Property.
   212|      */
   213|     public function setFillParameters(?string $color, ?int $alpha = null, ?string $AlphaType = ChartColor::EXCEL_COLOR_TYPE_RGB): void
   214|     {
   215|         $this->fillColor->setColorProperties($color, $alpha, $AlphaType);
   216|     }
   217|     /**
   218|      * Get Fill Property.
   219|      */
   220|     public function getFillProperty(string $property): string
   221|     {
   222|         return (string) $this->fillColor->getColorProperty($property);
   223|     }
   224|     public function getFillColorObject(): ChartColor
   225|     {
   226|         return $this->fillColor;
   227|     }
   228|     private string $crossBetween = ''; // 'between' or 'midCat' might be better
   229|     public function setCrossBetween(string $crossBetween): self
   230|     {
   231|         $this->crossBetween = $crossBetween;
   232|         return $this;
   233|     }
   234|     public function getCrossBetween(): string
   235|     {
   236|         return $this->crossBetween;
   237|     }
   238|     public function getMajorGridlines(): ?GridLines
   239|     {
   240|         return $this->majorGridlines;
   241|     }
   242|     public function getMinorGridlines(): ?GridLines
   243|     {
   244|         return $this->minorGridlines;
   245|     }
   246|     public function setMajorGridlines(?GridLines $gridlines): self
   247|     {
   248|         $this->majorGridlines = $gridlines;
   249|         return $this;
   250|     }
   251|     public function setMinorGridlines(?GridLines $gridlines): self
   252|     {
   253|         $this->minorGridlines = $gridlines;
   254|         return $this;
   255|     }
   256|     public function getAxisText(): ?AxisText
   257|     {
   258|         return $this->axisText;
   259|     }
   260|     public function setAxisText(?AxisText $axisText): self
   261|     {
   262|         $this->axisText = $axisText;
   263|         return $this;
   264|     }
   265|     public function setNoFill(bool $noFill): self
   266|     {
   267|         $this->noFill = $noFill;
   268|         return $this;
   269|     }
   270|     public function getNoFill(): bool
   271|     {
   272|         return $this->noFill;
   273|     }
   274|     public function setDispUnitsTitle(?Title $dispUnitsTitle): self
   275|     {
   276|         $this->dispUnitsTitle = $dispUnitsTitle;
   277|         return $this;
   278|     }
   279|     public function getDispUnitsTitle(): ?Title
   280|     {
   281|         return $this->dispUnitsTitle;
   282|     }
   283|     /**
   284|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   285|      */
   286|     public function __clone()
   287|     {
   288|         parent::__clone();
   289|         $this->majorGridlines = ($this->majorGridlines === null) ? null : clone $this->majorGridlines;
   290|         $this->majorGridlines = ($this->minorGridlines === null) ? null : clone $this->minorGridlines;
   291|         $this->axisText = ($this->axisText === null) ? null : clone $this->axisText;
   292|         $this->dispUnitsTitle = ($this->dispUnitsTitle === null) ? null : clone $this->dispUnitsTitle;
   293|         $this->fillColor = clone $this->fillColor;
   294|     }
   295| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Chart/DataSeriesValues.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-491 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Chart;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     5| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     6| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     7| class DataSeriesValues extends Properties
     8| {
     9|     const DATASERIES_TYPE_STRING = 'String';
    10|     const DATASERIES_TYPE_NUMBER = 'Number';
    11|     private const DATA_TYPE_VALUES = [
    12|         self::DATASERIES_TYPE_STRING,
    13|         self::DATASERIES_TYPE_NUMBER,
    14|     ];
    15|     /**
    16|      * Series Data Type.
    17|      */
    18|     private string $dataType;
    19|     /**
    20|      * Series Data Source.
    21|      */
    22|     private ?string $dataSource;
    23|     /**
    24|      * Format Code.
    25|      */
    26|     private ?string $formatCode;
    27|     /**
    28|      * Series Point Marker.
    29|      */
    30|     private ?string $pointMarker;
    31|     private ChartColor $markerFillColor;
    32|     private ChartColor $markerBorderColor;
    33|     /**
    34|      * Series Point Size.
    35|      */
    36|     private int $pointSize = 3;
    37|     /**
    38|      * Point Count (The number of datapoints in the dataseries).
    39|      */
    40|     private int $pointCount;
    41|     /**
    42|      * Data Values.
    43|      */
    44|     private ?array $dataValues;
    45|     /**
    46|      * Fill color (can be array with colors if dataseries have custom colors).
    47|      *
    48|      * @var null|ChartColor|ChartColor[]
    49|      */
    50|     private $fillColor;
    51|     private bool $scatterLines = true;
    52|     private bool $bubble3D = false;
    53|     private ?Layout $labelLayout = null;
    54|     /** @var TrendLine[] */
    55|     private array $trendLines = [];
    56|     /**
    57|      * Create a new DataSeriesValues object.
    58|      *
    59|      * @param null|ChartColor|ChartColor[]|string|string[] $fillColor
    60|      */
    61|     public function __construct(
    62|         string $dataType = self::DATASERIES_TYPE_NUMBER,
    63|         ?string $dataSource = null,
    64|         ?string $formatCode = null,
    65|         int $pointCount = 0,
    66|         ?array $dataValues = [],
    67|         ?string $marker = null,
    68|         null|ChartColor|array|string $fillColor = null,
    69|         int|string $pointSize = 3
    70|     ) {
    71|         parent::__construct();
    72|         $this->markerFillColor = new ChartColor();
    73|         $this->markerBorderColor = new ChartColor();
    74|         $this->setDataType($dataType);
    75|         $this->dataSource = $dataSource;
    76|         $this->formatCode = $formatCode;
    77|         $this->pointCount = $pointCount;
    78|         $this->dataValues = $dataValues;
    79|         $this->pointMarker = $marker;
    80|         if ($fillColor !== null) {
    81|             $this->setFillColor($fillColor);
    82|         }
    83|         if (is_numeric($pointSize)) {
    84|             $this->pointSize = (int) $pointSize;
    85|         }
    86|     }
    87|     /**
    88|      * Get Series Data Type.
    89|      */
    90|     public function getDataType(): string
    91|     {
    92|         return $this->dataType;
    93|     }
    94|     /**
    95|      * Set Series Data Type.
    96|      *
    97|      * @param string $dataType Datatype of this data series
    98|      *                                Typical values are:
    99|      *                                    DataSeriesValues::DATASERIES_TYPE_STRING
   100|      *                                        Normally used for axis point values
   101|      *                                    DataSeriesValues::DATASERIES_TYPE_NUMBER
   102|      *                                        Normally used for chart data values
   103|      *
   104|      * @return $this
   105|      */
   106|     public function setDataType(string $dataType): static
   107|     {
   108|         if (!in_array($dataType, self::DATA_TYPE_VALUES)) {
   109|             throw new Exception('Invalid datatype for chart data series values');
   110|         }
   111|         $this->dataType = $dataType;
   112|         return $this;
   113|     }
   114|     /**
   115|      * Get Series Data Source (formula).
   116|      */
   117|     public function getDataSource(): ?string
   118|     {
   119|         return $this->dataSource;
   120|     }
   121|     /**
   122|      * Set Series Data Source (formula).
   123|      *
   124|      * @return $this
   125|      */
   126|     public function setDataSource(?string $dataSource): static
   127|     {
   128|         $this->dataSource = $dataSource;
   129|         return $this;
   130|     }
   131|     /**
   132|      * Get Point Marker.
   133|      */
   134|     public function getPointMarker(): ?string
   135|     {
   136|         return $this->pointMarker;
   137|     }
   138|     /**
   139|      * Set Point Marker.
   140|      *
   141|      * @return $this
   142|      */
   143|     public function setPointMarker(string $marker): static
   144|     {
   145|         $this->pointMarker = $marker;
   146|         return $this;
   147|     }
   148|     public function getMarkerFillColor(): ChartColor
   149|     {
   150|         return $this->markerFillColor;
   151|     }
   152|     public function getMarkerBorderColor(): ChartColor
   153|     {
   154|         return $this->markerBorderColor;
   155|     }
   156|     /**
   157|      * Get Point Size.
   158|      */
   159|     public function getPointSize(): int
   160|     {
   161|         return $this->pointSize;
   162|     }
   163|     /**
   164|      * Set Point Size.
   165|      *
   166|      * @return $this
   167|      */
   168|     public function setPointSize(int $size = 3): static
   169|     {
   170|         $this->pointSize = $size;
   171|         return $this;
   172|     }
   173|     /**
   174|      * Get Series Format Code.
   175|      */
   176|     public function getFormatCode(): ?string
   177|     {
   178|         return $this->formatCode;
   179|     }
   180|     /**
   181|      * Set Series Format Code.
   182|      *
   183|      * @return $this
   184|      */
   185|     public function setFormatCode(string $formatCode): static
   186|     {
   187|         $this->formatCode = $formatCode;
   188|         return $this;
   189|     }
   190|     /**
   191|      * Get Series Point Count.
   192|      */
   193|     public function getPointCount(): int
   194|     {
   195|         return $this->pointCount;
   196|     }
   197|     /**
   198|      * Get fill color object.
   199|      *
   200|      * @return null|ChartColor|ChartColor[]
   201|      */
   202|     public function getFillColorObject()
   203|     {
   204|         return $this->fillColor;
   205|     }
   206|     private function stringToChartColor(string $fillString): ChartColor
   207|     {
   208|         $value = $type = '';
   209|         if (str_starts_with($fillString, '*')) {
   210|             $type = 'schemeClr';
   211|             $value = substr($fillString, 1);
   212|         } elseif (str_starts_with($fillString, '/')) {
   213|             $type = 'prstClr';
   214|             $value = substr($fillString, 1);
   215|         } elseif ($fillString !== '') {
   216|             $type = 'srgbClr';
   217|             $value = $fillString;
   218|             $this->validateColor($value);
   219|         }
   220|         return new ChartColor($value, null, $type);
   221|     }
   222|     private function chartColorToString(ChartColor $chartColor): string
   223|     {
   224|         $type = (string) $chartColor->getColorProperty('type');
   225|         $value = (string) $chartColor->getColorProperty('value');
   226|         if ($type === '' || $value === '') {
   227|             return '';
   228|         }
   229|         if ($type === 'schemeClr') {
   230|             return "*$value";
   231|         }
   232|         if ($type === 'prstClr') {
   233|             return "/$value";
   234|         }
   235|         return $value;
   236|     }
   237|     /**
   238|      * Get fill color.
   239|      *
   240|      * @return string|string[] HEX color or array with HEX colors
   241|      */
   242|     public function getFillColor(): string|array
   243|     {
   244|         if ($this->fillColor === null) {
   245|             return '';
   246|         }
   247|         if (is_array($this->fillColor)) {
   248|             $array = [];
   249|             foreach ($this->fillColor as $chartColor) {
   250|                 $array[] = $this->chartColorToString($chartColor);
   251|             }
   252|             return $array;
   253|         }
   254|         return $this->chartColorToString($this->fillColor);
   255|     }
   256|     /**
   257|      * Set fill color for series.
   258|      *
   259|      * @param ChartColor|ChartColor[]|string|string[] $color HEX color or array with HEX colors
   260|      *
   261|      * @return   $this
   262|      */
   263|     public function setFillColor($color): static
   264|     {
   265|         if (is_array($color)) {
   266|             $this->fillColor = [];
   267|             foreach ($color as $fillString) {
   268|                 if ($fillString instanceof ChartColor) {
   269|                     $this->fillColor[] = $fillString;
   270|                 } else {
   271|                     $this->fillColor[] = $this->stringToChartColor($fillString);
   272|                 }
   273|             }
   274|         } elseif ($color instanceof ChartColor) {
   275|             $this->fillColor = $color;
   276|         } else {
   277|             $this->fillColor = $this->stringToChartColor($color);
   278|         }
   279|         return $this;
   280|     }
   281|     /**
   282|      * Method for validating hex color.
   283|      *
   284|      * @param string $color value for color
   285|      *
   286|      * @return bool true if validation was successful
   287|      */
   288|     private function validateColor(string $color): bool
   289|     {
   290|         if (!preg_match('/^[a-f0-9]{6}$/i', $color)) {
   291|             throw new Exception(sprintf('Invalid hex color for chart series (color: "%s")', $color));
   292|         }
   293|         return true;
   294|     }
   295|     /**
   296|      * Get line width for series.
   297|      */
   298|     public function getLineWidth(): null|float|int
   299|     {
   300|         return $this->lineStyleProperties['width'];
   301|     }
   302|     /**
   303|      * Set line width for the series.
   304|      *
   305|      * @return $this
   306|      */
   307|     public function setLineWidth(null|float|int $width): static
   308|     {
   309|         $this->lineStyleProperties['width'] = $width;
   310|         return $this;
   311|     }
   312|     /**
   313|      * Identify if the Data Series is a multi-level or a simple series.
   314|      */
   315|     public function isMultiLevelSeries(): ?bool
   316|     {
   317|         if (!empty($this->dataValues)) {
   318|             return is_array(array_values($this->dataValues)[0]);
   319|         }
   320|         return null;
   321|     }
   322|     /**
   323|      * Return the level count of a multi-level Data Series.
   324|      */
   325|     public function multiLevelCount(): int
   326|     {
   327|         $levelCount = 0;
   328|         foreach (($this->dataValues ?? []) as $dataValueSet) {
   329|             $levelCount = max($levelCount, count($dataValueSet));
   330|         }
   331|         return $levelCount;
   332|     }
   333|     /**
   334|      * Get Series Data Values.
   335|      */
   336|     public function getDataValues(): ?array
   337|     {
   338|         return $this->dataValues;
   339|     }
   340|     /**
   341|      * Get the first Series Data value.
   342|      */
   343|     public function getDataValue(): mixed
   344|     {
   345|         if ($this->dataValues === null) {
   346|             return null;
   347|         }
   348|         $count = count($this->dataValues);
   349|         if ($count == 0) {
   350|             return null;
   351|         } elseif ($count == 1) {
   352|             return $this->dataValues[0];
   353|         }
   354|         return $this->dataValues;
   355|     }
   356|     /**
   357|      * Set Series Data Values.
   358|      *
   359|      * @return $this
   360|      */
   361|     public function setDataValues(array $dataValues): static
   362|     {
   363|         $this->dataValues = Functions::flattenArray($dataValues);
   364|         $this->pointCount = count($dataValues);
   365|         return $this;
   366|     }
   367|     public function refresh(Worksheet $worksheet, bool $flatten = true): void
   368|     {
   369|         if ($this->dataSource !== null) {
   370|             $calcEngine = Calculation::getInstance($worksheet->getParent());
   371|             $newDataValues = Calculation::unwrapResult(
   372|                 $calcEngine->_calculateFormulaValue(
   373|                     '=' . $this->dataSource,
   374|                     null,
   375|                     $worksheet->getCell('A1')
   376|                 )
   377|             );
   378|             if ($flatten) {
   379|                 $this->dataValues = Functions::flattenArray($newDataValues);
   380|                 foreach ($this->dataValues as &$dataValue) {
   381|                     if (is_string($dataValue) && !empty($dataValue) && $dataValue[0] == '#') {
   382|                         $dataValue = 0.0;
   383|                     }
   384|                 }
   385|                 unset($dataValue);
   386|             } else {
   387|                 [$worksheet, $cellRange] = Worksheet::extractSheetTitle($this->dataSource, true);
   388|                 $dimensions = Coordinate::rangeDimension(str_replace('$', '', $cellRange ?? ''));
   389|                 if (($dimensions[0] == 1) || ($dimensions[1] == 1)) {
   390|                     $this->dataValues = Functions::flattenArray($newDataValues);
   391|                 } else {
   392|                     /** @var array<int, array> */
   393|                     $newDataValuesx = $newDataValues;
   394|                     $newArray = array_values(array_shift($newDataValuesx) ?? []);
   395|                     foreach ($newArray as $i => $newDataSet) {
   396|                         $newArray[$i] = [$newDataSet];
   397|                     }
   398|                     foreach ($newDataValuesx as $newDataSet) {
   399|                         $i = 0;
   400|                         foreach ($newDataSet as $newDataVal) {
   401|                             array_unshift($newArray[$i++], $newDataVal);
   402|                         }
   403|                     }
   404|                     $this->dataValues = $newArray;
   405|                 }
   406|             }
   407|             $this->pointCount = count($this->dataValues);
   408|         }
   409|     }
   410|     public function getScatterLines(): bool
   411|     {
   412|         return $this->scatterLines;
   413|     }
   414|     public function setScatterLines(bool $scatterLines): self
   415|     {
   416|         $this->scatterLines = $scatterLines;
   417|         return $this;
   418|     }
   419|     public function getBubble3D(): bool
   420|     {
   421|         return $this->bubble3D;
   422|     }
   423|     public function setBubble3D(bool $bubble3D): self
   424|     {
   425|         $this->bubble3D = $bubble3D;
   426|         return $this;
   427|     }
   428|     /**
   429|      * Smooth Line. Must be specified for both DataSeries and DataSeriesValues.
   430|      */
   431|     private bool $smoothLine = false;
   432|     /**
   433|      * Get Smooth Line.
   434|      */
   435|     public function getSmoothLine(): bool
   436|     {
   437|         return $this->smoothLine;
   438|     }
   439|     /**
   440|      * Set Smooth Line.
   441|      *
   442|      * @return $this
   443|      */
   444|     public function setSmoothLine(bool $smoothLine): static
   445|     {
   446|         $this->smoothLine = $smoothLine;
   447|         return $this;
   448|     }
   449|     public function getLabelLayout(): ?Layout
   450|     {
   451|         return $this->labelLayout;
   452|     }
   453|     public function setLabelLayout(?Layout $labelLayout): self
   454|     {
   455|         $this->labelLayout = $labelLayout;
   456|         return $this;
   457|     }
   458|     public function setTrendLines(array $trendLines): self
   459|     {
   460|         $this->trendLines = $trendLines;
   461|         return $this;
   462|     }
   463|     public function getTrendLines(): array
   464|     {
   465|         return $this->trendLines;
   466|     }
   467|     /**
   468|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   469|      */
   470|     public function __clone()
   471|     {
   472|         parent::__clone();
   473|         $this->markerFillColor = clone $this->markerFillColor;
   474|         $this->markerBorderColor = clone $this->markerBorderColor;
   475|         if (is_array($this->fillColor)) {
   476|             $fillColor = $this->fillColor;
   477|             $this->fillColor = [];
   478|             foreach ($fillColor as $color) {
   479|                 $this->fillColor[] = clone $color;
   480|             }
   481|         } elseif ($this->fillColor instanceof ChartColor) {
   482|             $this->fillColor = clone $this->fillColor;
   483|         }
   484|         $this->labelLayout = ($this->labelLayout === null) ? null : clone $this->labelLayout;
   485|         $trendLines = $this->trendLines;
   486|         $this->trendLines = [];
   487|         foreach ($trendLines as $trendLine) {
   488|             $this->trendLines[] = clone $trendLine;
   489|         }
   490|     }
   491| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Chart/Properties.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-808 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Chart;
     3| /**
     4|  * Created by PhpStorm.
     5|  * User: nhw2h8s
     6|  * Date: 7/2/14
     7|  * Time: 5:45 PM.
     8|  */
     9| abstract class Properties
    10| {
    11|     const AXIS_LABELS_LOW = 'low';
    12|     const AXIS_LABELS_HIGH = 'high';
    13|     const AXIS_LABELS_NEXT_TO = 'nextTo';
    14|     const AXIS_LABELS_NONE = 'none';
    15|     const TICK_MARK_NONE = 'none';
    16|     const TICK_MARK_INSIDE = 'in';
    17|     const TICK_MARK_OUTSIDE = 'out';
    18|     const TICK_MARK_CROSS = 'cross';
    19|     const HORIZONTAL_CROSSES_AUTOZERO = 'autoZero';
    20|     const HORIZONTAL_CROSSES_MAXIMUM = 'max';
    21|     const FORMAT_CODE_GENERAL = 'General';
    22|     const FORMAT_CODE_NUMBER = '#,##0.00';
    23|     const FORMAT_CODE_CURRENCY = '$#,##0.00';
    24|     const FORMAT_CODE_ACCOUNTING = '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)';
    25|     const FORMAT_CODE_DATE = 'm/d/yyyy';
    26|     const FORMAT_CODE_DATE_ISO8601 = 'yyyy-mm-dd';
    27|     const FORMAT_CODE_TIME = '[$-F400]h:mm:ss AM/PM';
    28|     const FORMAT_CODE_PERCENTAGE = '0.00%';
    29|     const FORMAT_CODE_FRACTION = '# ?/?';
    30|     const FORMAT_CODE_SCIENTIFIC = '0.00E+00';
    31|     const FORMAT_CODE_TEXT = '@';
    32|     const FORMAT_CODE_SPECIAL = '00000';
    33|     const ORIENTATION_NORMAL = 'minMax';
    34|     const ORIENTATION_REVERSED = 'maxMin';
    35|     const LINE_STYLE_COMPOUND_SIMPLE = 'sng';
    36|     const LINE_STYLE_COMPOUND_DOUBLE = 'dbl';
    37|     const LINE_STYLE_COMPOUND_THICKTHIN = 'thickThin';
    38|     const LINE_STYLE_COMPOUND_THINTHICK = 'thinThick';
    39|     const LINE_STYLE_COMPOUND_TRIPLE = 'tri';
    40|     const LINE_STYLE_DASH_SOLID = 'solid';
    41|     const LINE_STYLE_DASH_ROUND_DOT = 'sysDot';
    42|     const LINE_STYLE_DASH_SQUARE_DOT = 'sysDash';
    43|     const LINE_STYPE_DASH_DASH = 'dash';
    44|     const LINE_STYLE_DASH_DASH_DOT = 'dashDot';
    45|     const LINE_STYLE_DASH_LONG_DASH = 'lgDash';
    46|     const LINE_STYLE_DASH_LONG_DASH_DOT = 'lgDashDot';
    47|     const LINE_STYLE_DASH_LONG_DASH_DOT_DOT = 'lgDashDotDot';
    48|     const LINE_STYLE_CAP_SQUARE = 'sq';
    49|     const LINE_STYLE_CAP_ROUND = 'rnd';
    50|     const LINE_STYLE_CAP_FLAT = 'flat';
    51|     const LINE_STYLE_JOIN_ROUND = 'round';
    52|     const LINE_STYLE_JOIN_MITER = 'miter';
    53|     const LINE_STYLE_JOIN_BEVEL = 'bevel';
    54|     const LINE_STYLE_ARROW_TYPE_NOARROW = null;
    55|     const LINE_STYLE_ARROW_TYPE_ARROW = 'triangle';
    56|     const LINE_STYLE_ARROW_TYPE_OPEN = 'arrow';
    57|     const LINE_STYLE_ARROW_TYPE_STEALTH = 'stealth';
    58|     const LINE_STYLE_ARROW_TYPE_DIAMOND = 'diamond';
    59|     const LINE_STYLE_ARROW_TYPE_OVAL = 'oval';
    60|     const LINE_STYLE_ARROW_SIZE_1 = 1;
    61|     const LINE_STYLE_ARROW_SIZE_2 = 2;
    62|     const LINE_STYLE_ARROW_SIZE_3 = 3;
    63|     const LINE_STYLE_ARROW_SIZE_4 = 4;
    64|     const LINE_STYLE_ARROW_SIZE_5 = 5;
    65|     const LINE_STYLE_ARROW_SIZE_6 = 6;
    66|     const LINE_STYLE_ARROW_SIZE_7 = 7;
    67|     const LINE_STYLE_ARROW_SIZE_8 = 8;
    68|     const LINE_STYLE_ARROW_SIZE_9 = 9;
    69|     const SHADOW_PRESETS_NOSHADOW = null;
    70|     const SHADOW_PRESETS_OUTER_BOTTTOM_RIGHT = 1;
    71|     const SHADOW_PRESETS_OUTER_BOTTOM = 2;
    72|     const SHADOW_PRESETS_OUTER_BOTTOM_LEFT = 3;
    73|     const SHADOW_PRESETS_OUTER_RIGHT = 4;
    74|     const SHADOW_PRESETS_OUTER_CENTER = 5;
    75|     const SHADOW_PRESETS_OUTER_LEFT = 6;
    76|     const SHADOW_PRESETS_OUTER_TOP_RIGHT = 7;
    77|     const SHADOW_PRESETS_OUTER_TOP = 8;
    78|     const SHADOW_PRESETS_OUTER_TOP_LEFT = 9;
    79|     const SHADOW_PRESETS_INNER_BOTTTOM_RIGHT = 10;
    80|     const SHADOW_PRESETS_INNER_BOTTOM = 11;
    81|     const SHADOW_PRESETS_INNER_BOTTOM_LEFT = 12;
    82|     const SHADOW_PRESETS_INNER_RIGHT = 13;
    83|     const SHADOW_PRESETS_INNER_CENTER = 14;
    84|     const SHADOW_PRESETS_INNER_LEFT = 15;
    85|     const SHADOW_PRESETS_INNER_TOP_RIGHT = 16;
    86|     const SHADOW_PRESETS_INNER_TOP = 17;
    87|     const SHADOW_PRESETS_INNER_TOP_LEFT = 18;
    88|     const SHADOW_PRESETS_PERSPECTIVE_BELOW = 19;
    89|     const SHADOW_PRESETS_PERSPECTIVE_UPPER_RIGHT = 20;
    90|     const SHADOW_PRESETS_PERSPECTIVE_UPPER_LEFT = 21;
    91|     const SHADOW_PRESETS_PERSPECTIVE_LOWER_RIGHT = 22;
    92|     const SHADOW_PRESETS_PERSPECTIVE_LOWER_LEFT = 23;
    93|     const POINTS_WIDTH_MULTIPLIER = 12700;
    94|     const ANGLE_MULTIPLIER = 60000; // direction and size-kx size-ky
    95|     const PERCENTAGE_MULTIPLIER = 100000; // size sx and sy
    96|     protected bool $objectState = false; // used only for minor gridlines
    97|     /** @var ?float */
    98|     protected ?float $glowSize = null;
    99|     protected ChartColor $glowColor;
   100|     protected array $softEdges = [
   101|         'size' => null,
   102|     ];
   103|     protected array $shadowProperties = self::PRESETS_OPTIONS[0];
   104|     protected ChartColor $shadowColor;
   105|     public function __construct()
   106|     {
   107|         $this->lineColor = new ChartColor();
   108|         $this->glowColor = new ChartColor();
   109|         $this->shadowColor = new ChartColor();
   110|         $this->shadowColor->setType(ChartColor::EXCEL_COLOR_TYPE_STANDARD);
   111|         $this->shadowColor->setValue('black');
   112|         $this->shadowColor->setAlpha(40);
   113|     }
   114|     /**
   115|      * Get Object State.
   116|      */
   117|     public function getObjectState(): bool
   118|     {
   119|         return $this->objectState;
   120|     }
   121|     /**
   122|      * Change Object State to True.
   123|      *
   124|      * @return $this
   125|      */
   126|     public function activateObject()
   127|     {
   128|         $this->objectState = true;
   129|         return $this;
   130|     }
   131|     public static function pointsToXml(float $width): string
   132|     {
   133|         return (string) (int) ($width * self::POINTS_WIDTH_MULTIPLIER);
   134|     }
   135|     public static function xmlToPoints(string $width): float
   136|     {
   137|         return ((float) $width) / self::POINTS_WIDTH_MULTIPLIER;
   138|     }
   139|     public static function angleToXml(float $angle): string
   140|     {
   141|         return (string) (int) ($angle * self::ANGLE_MULTIPLIER);
   142|     }
   143|     public static function xmlToAngle(string $angle): float
   144|     {
   145|         return ((float) $angle) / self::ANGLE_MULTIPLIER;
   146|     }
   147|     public static function tenthOfPercentToXml(float $value): string
   148|     {
   149|         return (string) (int) ($value * self::PERCENTAGE_MULTIPLIER);
   150|     }
   151|     public static function xmlToTenthOfPercent(string $value): float
   152|     {
   153|         return ((float) $value) / self::PERCENTAGE_MULTIPLIER;
   154|     }
   155|     protected function setColorProperties(?string $color, null|float|int|string $alpha, ?string $colorType): array
   156|     {
   157|         return [
   158|             'type' => $colorType,
   159|             'value' => $color,
   160|             'alpha' => ($alpha === null) ? null : (int) $alpha,
   161|         ];
   162|     }
   163|     protected const PRESETS_OPTIONS = [
   164|         0 => [
   165|             'presets' => self::SHADOW_PRESETS_NOSHADOW,
   166|             'effect' => null,
   167|             'size' => [
   168|                 'sx' => null,
   169|                 'sy' => null,
   170|                 'kx' => null,
   171|                 'ky' => null,
   172|             ],
   173|             'blur' => null,
   174|             'direction' => null,
   175|             'distance' => null,
   176|             'algn' => null,
   177|             'rotWithShape' => null,
   178|         ],
   179|         1 => [
   180|             'effect' => 'outerShdw',
   181|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   182|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   183|             'direction' => 2700000 / self::ANGLE_MULTIPLIER,
   184|             'algn' => 'tl',
   185|             'rotWithShape' => '0',
   186|         ],
   187|         2 => [
   188|             'effect' => 'outerShdw',
   189|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   190|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   191|             'direction' => 5400000 / self::ANGLE_MULTIPLIER,
   192|             'algn' => 't',
   193|             'rotWithShape' => '0',
   194|         ],
   195|         3 => [
   196|             'effect' => 'outerShdw',
   197|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   198|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   199|             'direction' => 8100000 / self::ANGLE_MULTIPLIER,
   200|             'algn' => 'tr',
   201|             'rotWithShape' => '0',
   202|         ],
   203|         4 => [
   204|             'effect' => 'outerShdw',
   205|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   206|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   207|             'algn' => 'l',
   208|             'rotWithShape' => '0',
   209|         ],
   210|         5 => [
   211|             'effect' => 'outerShdw',
   212|             'size' => [
   213|                 'sx' => 102000 / self::PERCENTAGE_MULTIPLIER,
   214|                 'sy' => 102000 / self::PERCENTAGE_MULTIPLIER,
   215|             ],
   216|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   217|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   218|             'algn' => 'ctr',
   219|             'rotWithShape' => '0',
   220|         ],
   221|         6 => [
   222|             'effect' => 'outerShdw',
   223|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   224|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   225|             'direction' => 10800000 / self::ANGLE_MULTIPLIER,
   226|             'algn' => 'r',
   227|             'rotWithShape' => '0',
   228|         ],
   229|         7 => [
   230|             'effect' => 'outerShdw',
   231|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   232|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   233|             'direction' => 18900000 / self::ANGLE_MULTIPLIER,
   234|             'algn' => 'bl',
   235|             'rotWithShape' => '0',
   236|         ],
   237|         8 => [
   238|             'effect' => 'outerShdw',
   239|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   240|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   241|             'direction' => 16200000 / self::ANGLE_MULTIPLIER,
   242|             'rotWithShape' => '0',
   243|         ],
   244|         9 => [
   245|             'effect' => 'outerShdw',
   246|             'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   247|             'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
   248|             'direction' => 13500000 / self::ANGLE_MULTIPLIER,
   249|             'algn' => 'br',
   250|             'rotWithShape' => '0',
   251|         ],
   252|         10 => [
   253|             'effect' => 'innerShdw',
   254|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   255|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   256|             'direction' => 2700000 / self::ANGLE_MULTIPLIER,
   257|         ],
   258|         11 => [
   259|             'effect' => 'innerShdw',
   260|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   261|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   262|             'direction' => 5400000 / self::ANGLE_MULTIPLIER,
   263|         ],
   264|         12 => [
   265|             'effect' => 'innerShdw',
   266|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   267|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   268|             'direction' => 8100000 / self::ANGLE_MULTIPLIER,
   269|         ],
   270|         13 => [
   271|             'effect' => 'innerShdw',
   272|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   273|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   274|         ],
   275|         14 => [
   276|             'effect' => 'innerShdw',
   277|             'blur' => 114300 / self::POINTS_WIDTH_MULTIPLIER,
   278|         ],
   279|         15 => [
   280|             'effect' => 'innerShdw',
   281|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   282|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   283|             'direction' => 10800000 / self::ANGLE_MULTIPLIER,
   284|         ],
   285|         16 => [
   286|             'effect' => 'innerShdw',
   287|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   288|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   289|             'direction' => 18900000 / self::ANGLE_MULTIPLIER,
   290|         ],
   291|         17 => [
   292|             'effect' => 'innerShdw',
   293|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   294|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   295|             'direction' => 16200000 / self::ANGLE_MULTIPLIER,
   296|         ],
   297|         18 => [
   298|             'effect' => 'innerShdw',
   299|             'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
   300|             'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
   301|             'direction' => 13500000 / self::ANGLE_MULTIPLIER,
   302|         ],
   303|         19 => [
   304|             'effect' => 'outerShdw',
   305|             'blur' => 152400 / self::POINTS_WIDTH_MULTIPLIER,
   306|             'distance' => 317500 / self::POINTS_WIDTH_MULTIPLIER,
   307|             'size' => [
   308|                 'sx' => 90000 / self::PERCENTAGE_MULTIPLIER,
   309|                 'sy' => -19000 / self::PERCENTAGE_MULTIPLIER,
   310|             ],
   311|             'direction' => 5400000 / self::ANGLE_MULTIPLIER,
   312|             'rotWithShape' => '0',
   313|         ],
   314|         20 => [
   315|             'effect' => 'outerShdw',
   316|             'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
   317|             'direction' => 18900000 / self::ANGLE_MULTIPLIER,
   318|             'size' => [
   319|                 'sy' => 23000 / self::PERCENTAGE_MULTIPLIER,
   320|                 'kx' => -1200000 / self::ANGLE_MULTIPLIER,
   321|             ],
   322|             'algn' => 'bl',
   323|             'rotWithShape' => '0',
   324|         ],
   325|         21 => [
   326|             'effect' => 'outerShdw',
   327|             'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
   328|             'direction' => 13500000 / self::ANGLE_MULTIPLIER,
   329|             'size' => [
   330|                 'sy' => 23000 / self::PERCENTAGE_MULTIPLIER,
   331|                 'kx' => 1200000 / self::ANGLE_MULTIPLIER,
   332|             ],
   333|             'algn' => 'br',
   334|             'rotWithShape' => '0',
   335|         ],
   336|         22 => [
   337|             'effect' => 'outerShdw',
   338|             'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
   339|             'distance' => 12700 / self::POINTS_WIDTH_MULTIPLIER,
   340|             'direction' => 2700000 / self::ANGLE_MULTIPLIER,
   341|             'size' => [
   342|                 'sy' => -23000 / self::PERCENTAGE_MULTIPLIER,
   343|                 'kx' => -800400 / self::ANGLE_MULTIPLIER,
   344|             ],
   345|             'algn' => 'bl',
   346|             'rotWithShape' => '0',
   347|         ],
   348|         23 => [
   349|             'effect' => 'outerShdw',
   350|             'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
   351|             'distance' => 12700 / self::POINTS_WIDTH_MULTIPLIER,
   352|             'direction' => 8100000 / self::ANGLE_MULTIPLIER,
   353|             'size' => [
   354|                 'sy' => -23000 / self::PERCENTAGE_MULTIPLIER,
   355|                 'kx' => 800400 / self::ANGLE_MULTIPLIER,
   356|             ],
   357|             'algn' => 'br',
   358|             'rotWithShape' => '0',
   359|         ],
   360|     ];
   361|     protected function getShadowPresetsMap(int $presetsOption): array
   362|     {
   363|         return self::PRESETS_OPTIONS[$presetsOption] ?? self::PRESETS_OPTIONS[0];
   364|     }
   365|     /**
   366|      * Get value of array element.
   367|      */
   368|     protected function getArrayElementsValue(array $properties, array|int|string $elements): mixed
   369|     {
   370|         $reference = &$properties;
   371|         if (!is_array($elements)) {
   372|             return $reference[$elements];
   373|         }
   374|         foreach ($elements as $keys) {
   375|             $reference = &$reference[$keys];
   376|         }
   377|         return $reference;
   378|     }
   379|     /**
   380|      * Set Glow Properties.
   381|      */
   382|     public function setGlowProperties(float $size, ?string $colorValue = null, ?int $colorAlpha = null, ?string $colorType = null): void
   383|     {
   384|         $this
   385|             ->activateObject()
   386|             ->setGlowSize($size);
   387|         $this->glowColor->setColorPropertiesArray(
   388|             [
   389|                 'value' => $colorValue,
   390|                 'type' => $colorType,
   391|                 'alpha' => $colorAlpha,
   392|             ]
   393|         );
   394|     }
   395|     /**
   396|      * Get Glow Property.
   397|      */
   398|     public function getGlowProperty(array|string $property): null|array|float|int|string
   399|     {
   400|         $retVal = null;
   401|         if ($property === 'size') {
   402|             $retVal = $this->glowSize;
   403|         } elseif ($property === 'color') {
   404|             $retVal = [
   405|                 'value' => $this->glowColor->getColorProperty('value'),
   406|                 'type' => $this->glowColor->getColorProperty('type'),
   407|                 'alpha' => $this->glowColor->getColorProperty('alpha'),
   408|             ];
   409|         } elseif (is_array($property) && count($property) >= 2 && $property[0] === 'color') {
   410|             $retVal = $this->glowColor->getColorProperty($property[1]);
   411|         }
   412|         return $retVal;
   413|     }
   414|     /**
   415|      * Get Glow Color Property.
   416|      */
   417|     public function getGlowColor(string $propertyName): null|int|string
   418|     {
   419|         return $this->glowColor->getColorProperty($propertyName);
   420|     }
   421|     public function getGlowColorObject(): ChartColor
   422|     {
   423|         return $this->glowColor;
   424|     }
   425|     /**
   426|      * Get Glow Size.
   427|      */
   428|     public function getGlowSize(): ?float
   429|     {
   430|         return $this->glowSize;
   431|     }
   432|     /**
   433|      * Set Glow Size.
   434|      *
   435|      * @return $this
   436|      */
   437|     protected function setGlowSize(?float $size)
   438|     {
   439|         $this->glowSize = $size;
   440|         return $this;
   441|     }
   442|     /**
   443|      * Set Soft Edges Size.
   444|      */
   445|     public function setSoftEdges(?float $size): void
   446|     {
   447|         if ($size !== null) {
   448|             $this->activateObject();
   449|             $this->softEdges['size'] = $size;
   450|         }
   451|     }
   452|     /**
   453|      * Get Soft Edges Size.
   454|      */
   455|     public function getSoftEdgesSize(): ?float
   456|     {
   457|         return $this->softEdges['size'];
   458|     }
   459|     public function setShadowProperty(string $propertyName, mixed $value): self
   460|     {
   461|         $this->activateObject();
   462|         if ($propertyName === 'color' && is_array($value)) {
   463|             $this->shadowColor->setColorPropertiesArray($value);
   464|         } else {
   465|             $this->shadowProperties[$propertyName] = $value;
   466|         }
   467|         return $this;
   468|     }
   469|     /**
   470|      * Set Shadow Properties.
   471|      */
   472|     public function setShadowProperties(int $presets, ?string $colorValue = null, ?string $colorType = null, null|float|int|string $colorAlpha = null, ?float $blur = null, ?int $angle = null, ?float $distance = null): void
   473|     {
   474|         $this->activateObject()->setShadowPresetsProperties((int) $presets);
   475|         if ($presets === 0) {
   476|             $this->shadowColor->setType(ChartColor::EXCEL_COLOR_TYPE_STANDARD);
   477|             $this->shadowColor->setValue('black');
   478|             $this->shadowColor->setAlpha(40);
   479|         }
   480|         if ($colorValue !== null) {
   481|             $this->shadowColor->setValue($colorValue);
   482|         }
   483|         if ($colorType !== null) {
   484|             $this->shadowColor->setType($colorType);
   485|         }
   486|         if (is_numeric($colorAlpha)) {
   487|             $this->shadowColor->setAlpha((int) $colorAlpha);
   488|         }
   489|         $this
   490|             ->setShadowBlur($blur)
   491|             ->setShadowAngle($angle)
   492|             ->setShadowDistance($distance);
   493|     }
   494|     /**
   495|      * Set Shadow Presets Properties.
   496|      *
   497|      * @return $this
   498|      */
   499|     protected function setShadowPresetsProperties(int $presets)
   500|     {
   501|         $this->shadowProperties['presets'] = $presets;
   502|         $this->setShadowPropertiesMapValues($this->getShadowPresetsMap($presets));
   503|         return $this;
   504|     }
   505|     protected const SHADOW_ARRAY_KEYS = ['size', 'color'];
   506|     /**
   507|      * Set Shadow Properties Values.
   508|      *
   509|      * @return $this
   510|      */
   511|     protected function setShadowPropertiesMapValues(array $propertiesMap, ?array &$reference = null)
   512|     {
   513|         $base_reference = $reference;
   514|         foreach ($propertiesMap as $property_key => $property_val) {
   515|             if (is_array($property_val)) {
   516|                 if (in_array($property_key, self::SHADOW_ARRAY_KEYS, true)) {
   517|                     $reference = &$this->shadowProperties[$property_key];
   518|                     $this->setShadowPropertiesMapValues($property_val, $reference);
   519|                 }
   520|             } else {
   521|                 if ($base_reference === null) {
   522|                     $this->shadowProperties[$property_key] = $property_val;
   523|                 } else {
   524|                     $reference[$property_key] = $property_val;
   525|                 }
   526|             }
   527|         }
   528|         return $this;
   529|     }
   530|     /**
   531|      * Set Shadow Blur.
   532|      *
   533|      * @return $this
   534|      */
   535|     protected function setShadowBlur(?float $blur)
   536|     {
   537|         if ($blur !== null) {
   538|             $this->shadowProperties['blur'] = $blur;
   539|         }
   540|         return $this;
   541|     }
   542|     /**
   543|      * Set Shadow Angle.
   544|      *
   545|      * @return $this
   546|      */
   547|     protected function setShadowAngle(null|float|int|string $angle)
   548|     {
   549|         if (is_numeric($angle)) {
   550|             $this->shadowProperties['direction'] = $angle;
   551|         }
   552|         return $this;
   553|     }
   554|     /**
   555|      * Set Shadow Distance.
   556|      *
   557|      * @return $this
   558|      */
   559|     protected function setShadowDistance(?float $distance)
   560|     {
   561|         if ($distance !== null) {
   562|             $this->shadowProperties['distance'] = $distance;
   563|         }
   564|         return $this;
   565|     }
   566|     public function getShadowColorObject(): ChartColor
   567|     {
   568|         return $this->shadowColor;
   569|     }
   570|     /**
   571|      * Get Shadow Property.
   572|      *
   573|      * @param string|string[] $elements
   574|      */
   575|     public function getShadowProperty($elements): array|string|null
   576|     {
   577|         if ($elements === 'color') {
   578|             return [
   579|                 'value' => $this->shadowColor->getValue(),
   580|                 'type' => $this->shadowColor->getType(),
   581|                 'alpha' => $this->shadowColor->getAlpha(),
   582|             ];
   583|         }
   584|         $retVal = $this->getArrayElementsValue($this->shadowProperties, $elements);
   585|         if (is_scalar($retVal)) {
   586|             $retVal = (string) $retVal;
   587|         } elseif ($retVal !== null && !is_array($retVal)) {
   588|             throw new Exception('Unexpected value for shadowProperty');
   589|         }
   590|         return $retVal;
   591|     }
   592|     public function getShadowArray(): array
   593|     {
   594|         $array = $this->shadowProperties;
   595|         if ($this->getShadowColorObject()->isUsable()) {
   596|             $array['color'] = $this->getShadowProperty('color');
   597|         }
   598|         return $array;
   599|     }
   600|     protected ChartColor $lineColor;
   601|     protected array $lineStyleProperties = [
   602|         'width' => null, //'9525',
   603|         'compound' => '', //self::LINE_STYLE_COMPOUND_SIMPLE,
   604|         'dash' => '', //self::LINE_STYLE_DASH_SOLID,
   605|         'cap' => '', //self::LINE_STYLE_CAP_FLAT,
   606|         'join' => '', //self::LINE_STYLE_JOIN_BEVEL,
   607|         'arrow' => [
   608|             'head' => [
   609|                 'type' => '', //self::LINE_STYLE_ARROW_TYPE_NOARROW,
   610|                 'size' => '', //self::LINE_STYLE_ARROW_SIZE_5,
   611|                 'w' => '',
   612|                 'len' => '',
   613|             ],
   614|             'end' => [
   615|                 'type' => '', //self::LINE_STYLE_ARROW_TYPE_NOARROW,
   616|                 'size' => '', //self::LINE_STYLE_ARROW_SIZE_8,
   617|                 'w' => '',
   618|                 'len' => '',
   619|             ],
   620|         ],
   621|     ];
   622|     public function copyLineStyles(self $otherProperties): void
   623|     {
   624|         $this->lineStyleProperties = $otherProperties->lineStyleProperties;
   625|         $this->lineColor = $otherProperties->lineColor;
   626|         $this->glowSize = $otherProperties->glowSize;
   627|         $this->glowColor = $otherProperties->glowColor;
   628|         $this->softEdges = $otherProperties->softEdges;
   629|         $this->shadowProperties = $otherProperties->shadowProperties;
   630|     }
   631|     public function getLineColor(): ChartColor
   632|     {
   633|         return $this->lineColor;
   634|     }
   635|     /**
   636|      * Set Line Color Properties.
   637|      */
   638|     public function setLineColorProperties(?string $value, ?int $alpha = null, ?string $colorType = null): void
   639|     {
   640|         $this->activateObject();
   641|         $this->lineColor->setColorPropertiesArray(
   642|             $this->setColorProperties(
   643|                 $value,
   644|                 $alpha,
   645|                 $colorType
   646|             )
   647|         );
   648|     }
   649|     /**
   650|      * Get Line Color Property.
   651|      */
   652|     public function getLineColorProperty(string $propertyName): null|int|string
   653|     {
   654|         return $this->lineColor->getColorProperty($propertyName);
   655|     }
   656|     /**
   657|      * Set Line Style Properties.
   658|      */
   659|     public function setLineStyleProperties(
   660|         null|float|int|string $lineWidth = null,
   661|         ?string $compoundType = '',
   662|         ?string $dashType = '',
   663|         ?string $capType = '',
   664|         ?string $joinType = '',
   665|         ?string $headArrowType = '',
   666|         int $headArrowSize = 0,
   667|         ?string $endArrowType = '',
   668|         int $endArrowSize = 0,
   669|         ?string $headArrowWidth = '',
   670|         ?string $headArrowLength = '',
   671|         ?string $endArrowWidth = '',
   672|         ?string $endArrowLength = ''
   673|     ): void {
   674|         $this->activateObject();
   675|         if (is_numeric($lineWidth)) {
   676|             $this->lineStyleProperties['width'] = $lineWidth;
   677|         }
   678|         if ($compoundType !== '') {
   679|             $this->lineStyleProperties['compound'] = $compoundType;
   680|         }
   681|         if ($dashType !== '') {
   682|             $this->lineStyleProperties['dash'] = $dashType;
   683|         }
   684|         if ($capType !== '') {
   685|             $this->lineStyleProperties['cap'] = $capType;
   686|         }
   687|         if ($joinType !== '') {
   688|             $this->lineStyleProperties['join'] = $joinType;
   689|         }
   690|         if ($headArrowType !== '') {
   691|             $this->lineStyleProperties['arrow']['head']['type'] = $headArrowType;
   692|         }
   693|         if (isset(self::ARROW_SIZES[$headArrowSize])) {
   694|             $this->lineStyleProperties['arrow']['head']['size'] = $headArrowSize;
   695|             $this->lineStyleProperties['arrow']['head']['w'] = self::ARROW_SIZES[$headArrowSize]['w'];
   696|             $this->lineStyleProperties['arrow']['head']['len'] = self::ARROW_SIZES[$headArrowSize]['len'];
   697|         }
   698|         if ($endArrowType !== '') {
   699|             $this->lineStyleProperties['arrow']['end']['type'] = $endArrowType;
   700|         }
   701|         if (isset(self::ARROW_SIZES[$endArrowSize])) {
   702|             $this->lineStyleProperties['arrow']['end']['size'] = $endArrowSize;
   703|             $this->lineStyleProperties['arrow']['end']['w'] = self::ARROW_SIZES[$endArrowSize]['w'];
   704|             $this->lineStyleProperties['arrow']['end']['len'] = self::ARROW_SIZES[$endArrowSize]['len'];
   705|         }
   706|         if ($headArrowWidth !== '') {
   707|             $this->lineStyleProperties['arrow']['head']['w'] = $headArrowWidth;
   708|         }
   709|         if ($headArrowLength !== '') {
   710|             $this->lineStyleProperties['arrow']['head']['len'] = $headArrowLength;
   711|         }
   712|         if ($endArrowWidth !== '') {
   713|             $this->lineStyleProperties['arrow']['end']['w'] = $endArrowWidth;
   714|         }
   715|         if ($endArrowLength !== '') {
   716|             $this->lineStyleProperties['arrow']['end']['len'] = $endArrowLength;
   717|         }
   718|     }
   719|     public function getLineStyleArray(): array
   720|     {
   721|         return $this->lineStyleProperties;
   722|     }
   723|     public function setLineStyleArray(array $lineStyleProperties = []): self
   724|     {
   725|         $this->activateObject();
   726|         $this->lineStyleProperties['width'] = $lineStyleProperties['width'] ?? null;
   727|         $this->lineStyleProperties['compound'] = $lineStyleProperties['compound'] ?? '';
   728|         $this->lineStyleProperties['dash'] = $lineStyleProperties['dash'] ?? '';
   729|         $this->lineStyleProperties['cap'] = $lineStyleProperties['cap'] ?? '';
   730|         $this->lineStyleProperties['join'] = $lineStyleProperties['join'] ?? '';
   731|         $this->lineStyleProperties['arrow']['head']['type'] = $lineStyleProperties['arrow']['head']['type'] ?? '';
   732|         $this->lineStyleProperties['arrow']['head']['size'] = $lineStyleProperties['arrow']['head']['size'] ?? '';
   733|         $this->lineStyleProperties['arrow']['head']['w'] = $lineStyleProperties['arrow']['head']['w'] ?? '';
   734|         $this->lineStyleProperties['arrow']['head']['len'] = $lineStyleProperties['arrow']['head']['len'] ?? '';
   735|         $this->lineStyleProperties['arrow']['end']['type'] = $lineStyleProperties['arrow']['end']['type'] ?? '';
   736|         $this->lineStyleProperties['arrow']['end']['size'] = $lineStyleProperties['arrow']['end']['size'] ?? '';
   737|         $this->lineStyleProperties['arrow']['end']['w'] = $lineStyleProperties['arrow']['end']['w'] ?? '';
   738|         $this->lineStyleProperties['arrow']['end']['len'] = $lineStyleProperties['arrow']['end']['len'] ?? '';
   739|         return $this;
   740|     }
   741|     public function setLineStyleProperty(string $propertyName, mixed $value): self
   742|     {
   743|         $this->activateObject();
   744|         $this->lineStyleProperties[$propertyName] = $value;
   745|         return $this;
   746|     }
   747|     /**
   748|      * Get Line Style Property.
   749|      */
   750|     public function getLineStyleProperty(array|string $elements): ?string
   751|     {
   752|         $retVal = $this->getArrayElementsValue($this->lineStyleProperties, $elements);
   753|         if (is_scalar($retVal)) {
   754|             $retVal = (string) $retVal;
   755|         } elseif ($retVal !== null) {
   756|             throw new Exception('Unexpected value for lineStyleProperty');
   757|         }
   758|         return $retVal;
   759|     }
   760|     protected const ARROW_SIZES = [
   761|         1 => ['w' => 'sm', 'len' => 'sm'],
   762|         2 => ['w' => 'sm', 'len' => 'med'],
   763|         3 => ['w' => 'sm', 'len' => 'lg'],
   764|         4 => ['w' => 'med', 'len' => 'sm'],
   765|         5 => ['w' => 'med', 'len' => 'med'],
   766|         6 => ['w' => 'med', 'len' => 'lg'],
   767|         7 => ['w' => 'lg', 'len' => 'sm'],
   768|         8 => ['w' => 'lg', 'len' => 'med'],
   769|         9 => ['w' => 'lg', 'len' => 'lg'],
   770|     ];
   771|     /**
   772|      * Get Line Style Arrow Size.
   773|      */
   774|     protected function getLineStyleArrowSize(int $arraySelector, string $arrayKaySelector): string
   775|     {
   776|         return self::ARROW_SIZES[$arraySelector][$arrayKaySelector] ?? '';
   777|     }
   778|     /**
   779|      * Get Line Style Arrow Parameters.
   780|      */
   781|     public function getLineStyleArrowParameters(string $arrowSelector, string $propertySelector): string
   782|     {
   783|         return $this->getLineStyleArrowSize($this->lineStyleProperties['arrow'][$arrowSelector]['size'], $propertySelector);
   784|     }
   785|     /**
   786|      * Get Line Style Arrow Width.
   787|      */
   788|     public function getLineStyleArrowWidth(string $arrow): ?string
   789|     {
   790|         return $this->getLineStyleProperty(['arrow', $arrow, 'w']);
   791|     }
   792|     /**
   793|      * Get Line Style Arrow Excel Length.
   794|      */
   795|     public function getLineStyleArrowLength(string $arrow): ?string
   796|     {
   797|         return $this->getLineStyleProperty(['arrow', $arrow, 'len']);
   798|     }
   799|     /**
   800|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   801|      */
   802|     public function __clone()
   803|     {
   804|         $this->lineColor = clone $this->lineColor;
   805|         $this->glowColor = clone $this->glowColor;
   806|         $this->shadowColor = clone $this->shadowColor;
   807|     }
   808| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Chart/Renderer/JpGraphRendererBase.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-704 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Chart\Renderer;
     3| use AccBarPlot;
     4| use AccLinePlot;
     5| use BarPlot;
     6| use ContourPlot;
     7| use Graph;
     8| use GroupBarPlot;
     9| use LinePlot;
    10| use PhpOffice\PhpSpreadsheet\Chart\Chart;
    11| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    12| use PieGraph;
    13| use PiePlot;
    14| use PiePlot3D;
    15| use PiePlotC;
    16| use RadarGraph;
    17| use RadarPlot;
    18| use ScatterPlot;
    19| use Spline;
    20| use StockPlot;
    21| /**
    22|  * Base class for different Jpgraph implementations as charts renderer.
    23|  */
    24| abstract class JpGraphRendererBase implements IRenderer
    25| {
    26|     private const DEFAULT_WIDTH = 640.0;
    27|     private const DEFAULT_HEIGHT = 480.0;
    28|     private static $colourSet = [
    29|         'mediumpurple1', 'palegreen3', 'gold1', 'cadetblue1',
    30|         'darkmagenta', 'coral', 'dodgerblue3', 'eggplant',
    31|         'mediumblue', 'magenta', 'sandybrown', 'cyan',
    32|         'firebrick1', 'forestgreen', 'deeppink4', 'darkolivegreen',
    33|         'goldenrod2',
    34|     ];
    35|     private static array $markSet;
    36|     private Chart $chart;
    37|     private $graph;
    38|     private static $plotColour = 0;
    39|     private static $plotMark = 0;
    40|     /**
    41|      * Create a new jpgraph.
    42|      */
    43|     public function __construct(Chart $chart)
    44|     {
    45|         static::init();
    46|         $this->graph = null;
    47|         $this->chart = $chart;
    48|         self::$markSet = [
    49|             'diamond' => MARK_DIAMOND,
    50|             'square' => MARK_SQUARE,
    51|             'triangle' => MARK_UTRIANGLE,
    52|             'x' => MARK_X,
    53|             'star' => MARK_STAR,
    54|             'dot' => MARK_FILLEDCIRCLE,
    55|             'dash' => MARK_DTRIANGLE,
    56|             'circle' => MARK_CIRCLE,
    57|             'plus' => MARK_CROSS,
    58|         ];
    59|     }
    60|     private function getGraphWidth(): float
    61|     {
    62|         return $this->chart->getRenderedWidth() ?? self::DEFAULT_WIDTH;
    63|     }
    64|     private function getGraphHeight(): float
    65|     {
    66|         return $this->chart->getRenderedHeight() ?? self::DEFAULT_HEIGHT;
    67|     }
    68|     /**
    69|      * This method should be overriden in descendants to do real JpGraph library initialization.
    70|      */
    71|     abstract protected static function init(): void;
    72|     private function formatPointMarker($seriesPlot, $markerID)
    73|     {
    74|         $plotMarkKeys = array_keys(self::$markSet);
    75|         if ($markerID === null) {
    76|             self::$plotMark %= count(self::$markSet);
    77|             $seriesPlot->mark->SetType(self::$markSet[$plotMarkKeys[self::$plotMark++]]);
    78|         } elseif ($markerID !== 'none') {
    79|             if (isset(self::$markSet[$markerID])) {
    80|                 $seriesPlot->mark->SetType(self::$markSet[$markerID]);
    81|             } else {
    82|                 self::$plotMark %= count(self::$markSet);
    83|                 $seriesPlot->mark->SetType(self::$markSet[$plotMarkKeys[self::$plotMark++]]);
    84|             }
    85|         } else {
    86|             $seriesPlot->mark->Hide();
    87|         }
    88|         $seriesPlot->mark->SetColor(self::$colourSet[self::$plotColour]);
    89|         $seriesPlot->mark->SetFillColor(self::$colourSet[self::$plotColour]);
    90|         $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
    91|         return $seriesPlot;
    92|     }
    93|     private function formatDataSetLabels(int $groupID, array $datasetLabels, $rotation = '')
    94|     {
    95|         $datasetLabelFormatCode = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getFormatCode() ?? '';
    96|         $datasetLabelFormatCode = stripslashes($datasetLabelFormatCode);
    97|         $testCurrentIndex = 0;
    98|         foreach ($datasetLabels as $i => $datasetLabel) {
    99|             if (is_array($datasetLabel)) {
   100|                 if ($rotation == 'bar') {
   101|                     $datasetLabels[$i] = implode(' ', $datasetLabel);
   102|                 } else {
   103|                     $datasetLabel = array_reverse($datasetLabel);
   104|                     $datasetLabels[$i] = implode("\n", $datasetLabel);
   105|                 }
   106|             } else {
   107|                 if ($datasetLabelFormatCode !== null) {
   108|                     $datasetLabels[$i] = NumberFormat::toFormattedString($datasetLabel, $datasetLabelFormatCode);
   109|                 }
   110|             }
   111|             ++$testCurrentIndex;
   112|         }
   113|         return $datasetLabels;
   114|     }
   115|     private function percentageSumCalculation(int $groupID, $seriesCount)
   116|     {
   117|         $sumValues = [];
   118|         for ($i = 0; $i < $seriesCount; ++$i) {
   119|             if ($i == 0) {
   120|                 $sumValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
   121|             } else {
   122|                 $nextValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
   123|                 foreach ($nextValues as $k => $value) {
   124|                     if (isset($sumValues[$k])) {
   125|                         $sumValues[$k] += $value;
   126|                     } else {
   127|                         $sumValues[$k] = $value;
   128|                     }
   129|                 }
   130|             }
   131|         }
   132|         return $sumValues;
   133|     }
   134|     private function percentageAdjustValues(array $dataValues, array $sumValues)
   135|     {
   136|         foreach ($dataValues as $k => $dataValue) {
   137|             $dataValues[$k] = $dataValue / $sumValues[$k] * 100;
   138|         }
   139|         return $dataValues;
   140|     }
   141|     private function getCaption($captionElement)
   142|     {
   143|         $caption = ($captionElement !== null) ? $captionElement->getCaption() : null;
   144|         if ($caption !== null) {
   145|             if (is_array($caption)) {
   146|                 $caption = implode('', $caption);
   147|             }
   148|         }
   149|         return $caption;
   150|     }
   151|     private function renderTitle(): void
   152|     {
   153|         $title = $this->getCaption($this->chart->getTitle());
   154|         if ($title !== null) {
   155|             $this->graph->title->Set($title);
   156|         }
   157|     }
   158|     private function renderLegend(): void
   159|     {
   160|         $legend = $this->chart->getLegend();
   161|         if ($legend !== null) {
   162|             $legendPosition = $legend->getPosition();
   163|             switch ($legendPosition) {
   164|                 case 'r':
   165|                     $this->graph->legend->SetPos(0.01, 0.5, 'right', 'center'); //    right
   166|                     $this->graph->legend->SetColumns(1);
   167|                     break;
   168|                 case 'l':
   169|                     $this->graph->legend->SetPos(0.01, 0.5, 'left', 'center'); //    left
   170|                     $this->graph->legend->SetColumns(1);
   171|                     break;
   172|                 case 't':
   173|                     $this->graph->legend->SetPos(0.5, 0.01, 'center', 'top'); //    top
   174|                     break;
   175|                 case 'b':
   176|                     $this->graph->legend->SetPos(0.5, 0.99, 'center', 'bottom'); //    bottom
   177|                     break;
   178|                 default:
   179|                     $this->graph->legend->SetPos(0.01, 0.01, 'right', 'top'); //    top-right
   180|                     $this->graph->legend->SetColumns(1);
   181|                     break;
   182|             }
   183|         } else {
   184|             $this->graph->legend->Hide();
   185|         }
   186|     }
   187|     private function renderCartesianPlotArea(string $type = 'textlin'): void
   188|     {
   189|         $this->graph = new Graph($this->getGraphWidth(), $this->getGraphHeight());
   190|         $this->graph->SetScale($type);
   191|         $this->renderTitle();
   192|         $rotation = $this->chart->getPlotArea()->getPlotGroupByIndex(0)->getPlotDirection();
   193|         $reverse = $rotation == 'bar';
   194|         $xAxisLabel = $this->chart->getXAxisLabel();
   195|         if ($xAxisLabel !== null) {
   196|             $title = $this->getCaption($xAxisLabel);
   197|             if ($title !== null) {
   198|                 $this->graph->xaxis->SetTitle($title, 'center');
   199|                 $this->graph->xaxis->title->SetMargin(35);
   200|                 if ($reverse) {
   201|                     $this->graph->xaxis->title->SetAngle(90);
   202|                     $this->graph->xaxis->title->SetMargin(90);
   203|                 }
   204|             }
   205|         }
   206|         $yAxisLabel = $this->chart->getYAxisLabel();
   207|         if ($yAxisLabel !== null) {
   208|             $title = $this->getCaption($yAxisLabel);
   209|             if ($title !== null) {
   210|                 $this->graph->yaxis->SetTitle($title, 'center');
   211|                 if ($reverse) {
   212|                     $this->graph->yaxis->title->SetAngle(0);
   213|                     $this->graph->yaxis->title->SetMargin(-55);
   214|                 }
   215|             }
   216|         }
   217|     }
   218|     private function renderPiePlotArea(): void
   219|     {
   220|         $this->graph = new PieGraph($this->getGraphWidth(), $this->getGraphHeight());
   221|         $this->renderTitle();
   222|     }
   223|     private function renderRadarPlotArea(): void
   224|     {
   225|         $this->graph = new RadarGraph($this->getGraphWidth(), $this->getGraphHeight());
   226|         $this->graph->SetScale('lin');
   227|         $this->renderTitle();
   228|     }
   229|     private function getDataLabel(int $groupId, int $index): mixed
   230|     {
   231|         $plotLabel = $this->chart->getPlotArea()->getPlotGroupByIndex($groupId)->getPlotLabelByIndex($index);
   232|         if (!$plotLabel) {
   233|             return '';
   234|         }
   235|         return $plotLabel->getDataValue();
   236|     }
   237|     private function renderPlotLine(int $groupID, bool $filled = false, bool $combination = false): void
   238|     {
   239|         $grouping = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotGrouping();
   240|         $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[0];
   241|         $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointCount();
   242|         if ($labelCount > 0) {
   243|             $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
   244|             $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
   245|             $this->graph->xaxis->SetTickLabels($datasetLabels);
   246|         }
   247|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   248|         $seriesPlots = [];
   249|         if ($grouping == 'percentStacked') {
   250|             $sumValues = $this->percentageSumCalculation($groupID, $seriesCount);
   251|         } else {
   252|             $sumValues = [];
   253|         }
   254|         for ($i = 0; $i < $seriesCount; ++$i) {
   255|             $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[$i];
   256|             $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getDataValues();
   257|             $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointMarker();
   258|             if ($grouping == 'percentStacked') {
   259|                 $dataValues = $this->percentageAdjustValues($dataValues, $sumValues);
   260|             }
   261|             $testCurrentIndex = 0;
   262|             foreach ($dataValues as $k => $dataValue) {
   263|                 while ($k != $testCurrentIndex) {
   264|                     $dataValues[$testCurrentIndex] = null;
   265|                     ++$testCurrentIndex;
   266|                 }
   267|                 ++$testCurrentIndex;
   268|             }
   269|             $seriesPlot = new LinePlot($dataValues);
   270|             if ($combination) {
   271|                 $seriesPlot->SetBarCenter();
   272|             }
   273|             if ($filled) {
   274|                 $seriesPlot->SetFilled(true);
   275|                 $seriesPlot->SetColor('black');
   276|                 $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour++]);
   277|             } else {
   278|                 $this->formatPointMarker($seriesPlot, $marker);
   279|             }
   280|             $seriesPlot->SetLegend($this->getDataLabel($groupID, $index));
   281|             $seriesPlots[] = $seriesPlot;
   282|         }
   283|         if ($grouping == 'standard') {
   284|             $groupPlot = $seriesPlots;
   285|         } else {
   286|             $groupPlot = new AccLinePlot($seriesPlots);
   287|         }
   288|         $this->graph->Add($groupPlot);
   289|     }
   290|     private function renderPlotBar(int $groupID, ?string $dimensions = '2d'): void
   291|     {
   292|         $rotation = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotDirection();
   293|         if (($groupID == 0) && ($rotation == 'bar')) {
   294|             $this->graph->Set90AndMargin();
   295|         }
   296|         $grouping = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotGrouping();
   297|         $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[0];
   298|         $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointCount();
   299|         if ($labelCount > 0) {
   300|             $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
   301|             $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels, $rotation);
   302|             if ($rotation == 'bar') {
   303|                 $datasetLabels = array_reverse($datasetLabels);
   304|                 $this->graph->yaxis->SetPos('max');
   305|                 $this->graph->yaxis->SetLabelAlign('center', 'top');
   306|                 $this->graph->yaxis->SetLabelSide(SIDE_RIGHT);
   307|             }
   308|             $this->graph->xaxis->SetTickLabels($datasetLabels);
   309|         }
   310|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   311|         $seriesPlots = [];
   312|         if ($grouping == 'percentStacked') {
   313|             $sumValues = $this->percentageSumCalculation($groupID, $seriesCount);
   314|         } else {
   315|             $sumValues = [];
   316|         }
   317|         for ($j = 0; $j < $seriesCount; ++$j) {
   318|             $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[$j];
   319|             $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getDataValues();
   320|             if ($grouping == 'percentStacked') {
   321|                 $dataValues = $this->percentageAdjustValues($dataValues, $sumValues);
   322|             }
   323|             $testCurrentIndex = 0;
   324|             foreach ($dataValues as $k => $dataValue) {
   325|                 while ($k != $testCurrentIndex) {
   326|                     $dataValues[$testCurrentIndex] = null;
   327|                     ++$testCurrentIndex;
   328|                 }
   329|                 ++$testCurrentIndex;
   330|             }
   331|             if ($rotation == 'bar') {
   332|                 $dataValues = array_reverse($dataValues);
   333|             }
   334|             $seriesPlot = new BarPlot($dataValues);
   335|             $seriesPlot->SetColor('black');
   336|             $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour++]);
   337|             if ($dimensions == '3d') {
   338|                 $seriesPlot->SetShadow();
   339|             }
   340|             $seriesPlot->SetLegend($this->getDataLabel($groupID, $j));
   341|             $seriesPlots[] = $seriesPlot;
   342|         }
   343|         if (($rotation == 'bar') && ($grouping != 'percentStacked')) {
   344|             $seriesPlots = array_reverse($seriesPlots);
   345|         }
   346|         if ($grouping == 'clustered') {
   347|             $groupPlot = new GroupBarPlot($seriesPlots);
   348|         } elseif ($grouping == 'standard') {
   349|             $groupPlot = new GroupBarPlot($seriesPlots);
   350|         } else {
   351|             $groupPlot = new AccBarPlot($seriesPlots);
   352|             if ($dimensions == '3d') {
   353|                 $groupPlot->SetShadow();
   354|             }
   355|         }
   356|         $this->graph->Add($groupPlot);
   357|     }
   358|     private function renderPlotScatter(int $groupID, bool $bubble): void
   359|     {
   360|         $scatterStyle = $bubbleSize = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
   361|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   362|         for ($i = 0; $i < $seriesCount; ++$i) {
   363|             $plotCategoryByIndex = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex($i);
   364|             if ($plotCategoryByIndex === false) {
   365|                 $plotCategoryByIndex = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0);
   366|             }
   367|             $dataValuesY = $plotCategoryByIndex->getDataValues();
   368|             $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
   369|             $redoDataValuesY = true;
   370|             if ($bubble) {
   371|                 if (!$bubbleSize) {
   372|                     $bubbleSize = '10';
   373|                 }
   374|                 $redoDataValuesY = false;
   375|                 foreach ($dataValuesY as $dataValueY) {
   376|                     if (!is_int($dataValueY) && !is_float($dataValueY)) {
   377|                         $redoDataValuesY = true;
   378|                         break;
   379|                     }
   380|                 }
   381|             }
   382|             if ($redoDataValuesY) {
   383|                 foreach ($dataValuesY as $k => $dataValueY) {
   384|                     $dataValuesY[$k] = $k;
   385|                 }
   386|             }
   387|             $seriesPlot = new ScatterPlot($dataValuesX, $dataValuesY);
   388|             if ($scatterStyle == 'lineMarker') {
   389|                 $seriesPlot->SetLinkPoints();
   390|                 $seriesPlot->link->SetColor(self::$colourSet[self::$plotColour]);
   391|             } elseif ($scatterStyle == 'smoothMarker') {
   392|                 $spline = new Spline($dataValuesY, $dataValuesX);
   393|                 [$splineDataY, $splineDataX] = $spline->Get(count($dataValuesX) * $this->getGraphWidth() / 20);
   394|                 $lplot = new LinePlot($splineDataX, $splineDataY);
   395|                 $lplot->SetColor(self::$colourSet[self::$plotColour]);
   396|                 $this->graph->Add($lplot);
   397|             }
   398|             if ($bubble) {
   399|                 $this->formatPointMarker($seriesPlot, 'dot');
   400|                 $seriesPlot->mark->SetColor('black');
   401|                 $seriesPlot->mark->SetSize($bubbleSize);
   402|             } else {
   403|                 $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getPointMarker();
   404|                 $this->formatPointMarker($seriesPlot, $marker);
   405|             }
   406|             $seriesPlot->SetLegend($this->getDataLabel($groupID, $i));
   407|             $this->graph->Add($seriesPlot);
   408|         }
   409|     }
   410|     private function renderPlotRadar(int $groupID): void
   411|     {
   412|         $radarStyle = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
   413|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   414|         for ($i = 0; $i < $seriesCount; ++$i) {
   415|             $dataValuesY = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex($i)->getDataValues();
   416|             $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
   417|             $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getPointMarker();
   418|             $dataValues = [];
   419|             foreach ($dataValuesY as $k => $dataValueY) {
   420|                 $dataValues[$k] = is_array($dataValueY) ? implode(' ', array_reverse($dataValueY)) : $dataValueY;
   421|             }
   422|             $tmp = array_shift($dataValues);
   423|             $dataValues[] = $tmp;
   424|             $tmp = array_shift($dataValuesX);
   425|             $dataValuesX[] = $tmp;
   426|             $this->graph->SetTitles(array_reverse($dataValues));
   427|             $seriesPlot = new RadarPlot(array_reverse($dataValuesX));
   428|             $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
   429|             if ($radarStyle == 'filled') {
   430|                 $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour]);
   431|             }
   432|             $this->formatPointMarker($seriesPlot, $marker);
   433|             $seriesPlot->SetLegend($this->getDataLabel($groupID, $i));
   434|             $this->graph->Add($seriesPlot);
   435|         }
   436|     }
   437|     private function renderPlotContour(int $groupID): void
   438|     {
   439|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   440|         $dataValues = [];
   441|         for ($i = 0; $i < $seriesCount; ++$i) {
   442|             $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
   443|             $dataValues[$i] = $dataValuesX;
   444|         }
   445|         $seriesPlot = new ContourPlot($dataValues);
   446|         $this->graph->Add($seriesPlot);
   447|     }
   448|     private function renderPlotStock(int $groupID): void
   449|     {
   450|         $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   451|         $plotOrder = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder();
   452|         $dataValues = [];
   453|         foreach ($plotOrder as $i => $v) {
   454|             $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($v);
   455|             if ($dataValuesX === false) {
   456|                 continue;
   457|             }
   458|             $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($v)->getDataValues();
   459|             foreach ($dataValuesX as $j => $dataValueX) {
   460|                 $dataValues[$plotOrder[$i]][$j] = $dataValueX;
   461|             }
   462|         }
   463|         if (empty($dataValues)) {
   464|             return;
   465|         }
   466|         $dataValuesPlot = [];
   467|         $jMax = count($dataValues[0]);
   468|         for ($j = 0; $j < $jMax; ++$j) {
   469|             for ($i = 0; $i < $seriesCount; ++$i) {
   470|                 $dataValuesPlot[] = $dataValues[$i][$j] ?? null;
   471|             }
   472|         }
   473|         $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex(0)->getPointCount();
   474|         if ($labelCount > 0) {
   475|             $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
   476|             $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
   477|             $this->graph->xaxis->SetTickLabels($datasetLabels);
   478|         }
   479|         $seriesPlot = new StockPlot($dataValuesPlot);
   480|         $seriesPlot->SetWidth(20);
   481|         $this->graph->Add($seriesPlot);
   482|     }
   483|     private function renderAreaChart($groupCount): void
   484|     {
   485|         $this->renderCartesianPlotArea();
   486|         for ($i = 0; $i < $groupCount; ++$i) {
   487|             $this->renderPlotLine($i, true, false);
   488|         }
   489|     }
   490|     private function renderLineChart($groupCount): void
   491|     {
   492|         $this->renderCartesianPlotArea();
   493|         for ($i = 0; $i < $groupCount; ++$i) {
   494|             $this->renderPlotLine($i, false, false);
   495|         }
   496|     }
   497|     private function renderBarChart($groupCount, ?string $dimensions = '2d'): void
   498|     {
   499|         $this->renderCartesianPlotArea();
   500|         for ($i = 0; $i < $groupCount; ++$i) {
   501|             $this->renderPlotBar($i, $dimensions);
   502|         }
   503|     }
   504|     private function renderScatterChart($groupCount): void
   505|     {
   506|         $this->renderCartesianPlotArea('linlin');
   507|         for ($i = 0; $i < $groupCount; ++$i) {
   508|             $this->renderPlotScatter($i, false);
   509|         }
   510|     }
   511|     private function renderBubbleChart($groupCount): void
   512|     {
   513|         $this->renderCartesianPlotArea('linlin');
   514|         for ($i = 0; $i < $groupCount; ++$i) {
   515|             $this->renderPlotScatter($i, true);
   516|         }
   517|     }
   518|     private function renderPieChart($groupCount, ?string $dimensions = '2d', bool $doughnut = false, bool $multiplePlots = false): void
   519|     {
   520|         $this->renderPiePlotArea();
   521|         $iLimit = ($multiplePlots) ? $groupCount : 1;
   522|         for ($groupID = 0; $groupID < $iLimit; ++$groupID) {
   523|             $exploded = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
   524|             $datasetLabels = [];
   525|             if ($groupID == 0) {
   526|                 $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex(0)->getPointCount();
   527|                 if ($labelCount > 0) {
   528|                     $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
   529|                     $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
   530|                 }
   531|             }
   532|             $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
   533|             $jLimit = ($multiplePlots) ? $seriesCount : 1;
   534|             for ($j = 0; $j < $jLimit; ++$j) {
   535|                 $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($j)->getDataValues();
   536|                 $testCurrentIndex = 0;
   537|                 foreach ($dataValues as $k => $dataValue) {
   538|                     while ($k != $testCurrentIndex) {
   539|                         $dataValues[$testCurrentIndex] = null;
   540|                         ++$testCurrentIndex;
   541|                     }
   542|                     ++$testCurrentIndex;
   543|                 }
   544|                 if ($dimensions == '3d') {
   545|                     $seriesPlot = new PiePlot3D($dataValues);
   546|                 } else {
   547|                     if ($doughnut) {
   548|                         $seriesPlot = new PiePlotC($dataValues);
   549|                     } else {
   550|                         $seriesPlot = new PiePlot($dataValues);
   551|                     }
   552|                 }
   553|                 if ($multiplePlots) {
   554|                     $seriesPlot->SetSize(($jLimit - $j) / ($jLimit * 4));
   555|                 }
   556|                 if ($doughnut && method_exists($seriesPlot, 'SetMidColor')) {
   557|                     $seriesPlot->SetMidColor('white');
   558|                 }
   559|                 $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
   560|                 if (count($datasetLabels) > 0) {
   561|                     $seriesPlot->SetLabels(array_fill(0, count($datasetLabels), ''));
   562|                 }
   563|                 if ($dimensions != '3d') {
   564|                     $seriesPlot->SetGuideLines(false);
   565|                 }
   566|                 if ($j == 0) {
   567|                     if ($exploded) {
   568|                         $seriesPlot->ExplodeAll();
   569|                     }
   570|                     $seriesPlot->SetLegends($datasetLabels);
   571|                 }
   572|                 $this->graph->Add($seriesPlot);
   573|             }
   574|         }
   575|     }
   576|     private function renderRadarChart($groupCount): void
   577|     {
   578|         $this->renderRadarPlotArea();
   579|         for ($groupID = 0; $groupID < $groupCount; ++$groupID) {
   580|             $this->renderPlotRadar($groupID);
   581|         }
   582|     }
   583|     private function renderStockChart($groupCount): void
   584|     {
   585|         $this->renderCartesianPlotArea('intint');
   586|         for ($groupID = 0; $groupID < $groupCount; ++$groupID) {
   587|             $this->renderPlotStock($groupID);
   588|         }
   589|     }
   590|     private function renderContourChart($groupCount): void
   591|     {
   592|         $this->renderCartesianPlotArea('intint');
   593|         for ($i = 0; $i < $groupCount; ++$i) {
   594|             $this->renderPlotContour($i);
   595|         }
   596|     }
   597|     private function renderCombinationChart($groupCount, $outputDestination): bool
   598|     {
   599|         $this->renderCartesianPlotArea();
   600|         for ($i = 0; $i < $groupCount; ++$i) {
   601|             $dimensions = null;
   602|             $chartType = $this->chart->getPlotArea()->getPlotGroupByIndex($i)->getPlotType();
   603|             switch ($chartType) {
   604|                 case 'area3DChart':
   605|                 case 'areaChart':
   606|                     $this->renderPlotLine($i, true, true);
   607|                     break;
   608|                 case 'bar3DChart':
   609|                     $dimensions = '3d';
   610|                 case 'barChart':
   611|                     $this->renderPlotBar($i, $dimensions);
   612|                     break;
   613|                 case 'line3DChart':
   614|                 case 'lineChart':
   615|                     $this->renderPlotLine($i, false, true);
   616|                     break;
   617|                 case 'scatterChart':
   618|                     $this->renderPlotScatter($i, false);
   619|                     break;
   620|                 case 'bubbleChart':
   621|                     $this->renderPlotScatter($i, true);
   622|                     break;
   623|                 default:
   624|                     $this->graph = null;
   625|                     return false;
   626|             }
   627|         }
   628|         $this->renderLegend();
   629|         $this->graph->Stroke($outputDestination);
   630|         return true;
   631|     }
   632|     public function render(?string $outputDestination): bool
   633|     {
   634|         self::$plotColour = 0;
   635|         $groupCount = $this->chart->getPlotArea()->getPlotGroupCount();
   636|         $dimensions = null;
   637|         if ($groupCount == 1) {
   638|             $chartType = $this->chart->getPlotArea()->getPlotGroupByIndex(0)->getPlotType();
   639|         } else {
   640|             $chartTypes = [];
   641|             for ($i = 0; $i < $groupCount; ++$i) {
   642|                 $chartTypes[] = $this->chart->getPlotArea()->getPlotGroupByIndex($i)->getPlotType();
   643|             }
   644|             $chartTypes = array_unique($chartTypes);
   645|             if (count($chartTypes) == 1) {
   646|                 $chartType = array_pop($chartTypes);
   647|             } elseif (count($chartTypes) == 0) {
   648|                 echo 'Chart is not yet implemented<br />';
   649|                 return false;
   650|             } else {
   651|                 return $this->renderCombinationChart($groupCount, $outputDestination);
   652|             }
   653|         }
   654|         switch ($chartType) {
   655|             case 'area3DChart':
   656|                 $dimensions = '3d';
   657|             case 'areaChart':
   658|                 $this->renderAreaChart($groupCount);
   659|                 break;
   660|             case 'bar3DChart':
   661|                 $dimensions = '3d';
   662|             case 'barChart':
   663|                 $this->renderBarChart($groupCount, $dimensions);
   664|                 break;
   665|             case 'line3DChart':
   666|                 $dimensions = '3d';
   667|             case 'lineChart':
   668|                 $this->renderLineChart($groupCount);
   669|                 break;
   670|             case 'pie3DChart':
   671|                 $dimensions = '3d';
   672|             case 'pieChart':
   673|                 $this->renderPieChart($groupCount, $dimensions, false, false);
   674|                 break;
   675|             case 'doughnut3DChart':
   676|                 $dimensions = '3d';
   677|             case 'doughnutChart':
   678|                 $this->renderPieChart($groupCount, $dimensions, true, true);
   679|                 break;
   680|             case 'scatterChart':
   681|                 $this->renderScatterChart($groupCount);
   682|                 break;
   683|             case 'bubbleChart':
   684|                 $this->renderBubbleChart($groupCount);
   685|                 break;
   686|             case 'radarChart':
   687|                 $this->renderRadarChart($groupCount);
   688|                 break;
   689|             case 'surface3DChart':
   690|             case 'surfaceChart':
   691|                 $this->renderContourChart($groupCount);
   692|                 break;
   693|             case 'stockChart':
   694|                 $this->renderStockChart($groupCount);
   695|                 break;
   696|             default:
   697|                 echo $chartType . ' is not yet implemented<br />';
   698|                 return false;
   699|         }
   700|         $this->renderLegend();
   701|         $this->graph->Stroke($outputDestination);
   702|         return true;
   703|     }
   704| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Collection/Cells.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-397 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Collection;
     3| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     4| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     5| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     6| use PhpOffice\PhpSpreadsheet\Settings;
     7| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     8| use Psr\SimpleCache\CacheInterface;
     9| class Cells
    10| {
    11|     protected const MAX_COLUMN_ID = 16384;
    12|     private CacheInterface $cache;
    13|     /**
    14|      * Parent worksheet.
    15|      */
    16|     private ?Worksheet $parent;
    17|     /**
    18|      * The currently active Cell.
    19|      */
    20|     private ?Cell $currentCell = null;
    21|     /**
    22|      * Coordinate of the currently active Cell.
    23|      */
    24|     private ?string $currentCoordinate = null;
    25|     /**
    26|      * Flag indicating whether the currently active Cell requires saving.
    27|      */
    28|     private bool $currentCellIsDirty = false;
    29|     /**
    30|      * An index of existing cells. int pointer to the coordinate (0-base-indexed row * 16,384 + 1-base indexed column)
    31|      *    indexed by their coordinate.
    32|      *
    33|      * @var int[]
    34|      */
    35|     private array $index = [];
    36|     /**
    37|      * Prefix used to uniquely identify cache data for this worksheet.
    38|      */
    39|     private string $cachePrefix;
    40|     /**
    41|      * Initialise this new cell collection.
    42|      *
    43|      * @param Worksheet $parent The worksheet for this cell collection
    44|      */
    45|     public function __construct(Worksheet $parent, CacheInterface $cache)
    46|     {
    47|         $this->parent = $parent;
    48|         $this->cache = $cache;
    49|         $this->cachePrefix = $this->getUniqueID();
    50|     }
    51|     /**
    52|      * Return the parent worksheet for this cell collection.
    53|      */
    54|     public function getParent(): ?Worksheet
    55|     {
    56|         return $this->parent;
    57|     }
    58|     /**
    59|      * Whether the collection holds a cell for the given coordinate.
    60|      *
    61|      * @param string $cellCoordinate Coordinate of the cell to check
    62|      */
    63|     public function has(string $cellCoordinate): bool
    64|     {
    65|         return ($cellCoordinate === $this->currentCoordinate) || isset($this->index[$cellCoordinate]);
    66|     }
    67|     /**
    68|      * Add or update a cell in the collection.
    69|      *
    70|      * @param Cell $cell Cell to update
    71|      */
    72|     public function update(Cell $cell): Cell
    73|     {
    74|         return $this->add($cell->getCoordinate(), $cell);
    75|     }
    76|     /**
    77|      * Delete a cell in cache identified by coordinate.
    78|      *
    79|      * @param string $cellCoordinate Coordinate of the cell to delete
    80|      */
    81|     public function delete(string $cellCoordinate): void
    82|     {
    83|         if ($cellCoordinate === $this->currentCoordinate && $this->currentCell !== null) {
    84|             $this->currentCell->detach();
    85|             $this->currentCoordinate = null;
    86|             $this->currentCell = null;
    87|             $this->currentCellIsDirty = false;
    88|         }
    89|         unset($this->index[$cellCoordinate]);
    90|         $this->cache->delete($this->cachePrefix . $cellCoordinate);
    91|     }
    92|     /**
    93|      * Get a list of all cell coordinates currently held in the collection.
    94|      *
    95|      * @return string[]
    96|      */
    97|     public function getCoordinates(): array
    98|     {
    99|         return array_keys($this->index);
   100|     }
   101|     /**
   102|      * Get a sorted list of all cell coordinates currently held in the collection by row and column.
   103|      *
   104|      * @return string[]
   105|      */
   106|     public function getSortedCoordinates(): array
   107|     {
   108|         asort($this->index);
   109|         return array_keys($this->index);
   110|     }
   111|     /**
   112|      * Get a sorted list of all cell coordinates currently held in the collection by index (16384*row+column).
   113|      *
   114|      * @return int[]
   115|      */
   116|     public function getSortedCoordinatesInt(): array
   117|     {
   118|         asort($this->index);
   119|         return array_values($this->index);
   120|     }
   121|     /**
   122|      * Return the cell coordinate of the currently active cell object.
   123|      */
   124|     public function getCurrentCoordinate(): ?string
   125|     {
   126|         return $this->currentCoordinate;
   127|     }
   128|     /**
   129|      * Return the column coordinate of the currently active cell object.
   130|      */
   131|     public function getCurrentColumn(): string
   132|     {
   133|         $column = 0;
   134|         $row = '';
   135|         sscanf($this->currentCoordinate ?? '', '%[A-Z]%d', $column, $row);
   136|         return (string) $column;
   137|     }
   138|     /**
   139|      * Return the row coordinate of the currently active cell object.
   140|      */
   141|     public function getCurrentRow(): int
   142|     {
   143|         $column = 0;
   144|         $row = '';
   145|         sscanf($this->currentCoordinate ?? '', '%[A-Z]%d', $column, $row);
   146|         return (int) $row;
   147|     }
   148|     /**
   149|      * Get highest worksheet column and highest row that have cell records.
   150|      *
   151|      * @return array Highest column name and highest row number
   152|      */
   153|     public function getHighestRowAndColumn(): array
   154|     {
   155|         $maxRow = $maxColumn = 1;
   156|         foreach ($this->index as $coordinate) {
   157|             $row = (int) floor(($coordinate - 1) / self::MAX_COLUMN_ID) + 1;
   158|             $maxRow = ($maxRow > $row) ? $maxRow : $row;
   159|             $column = ($coordinate % self::MAX_COLUMN_ID) ?: self::MAX_COLUMN_ID;
   160|             $maxColumn = ($maxColumn > $column) ? $maxColumn : $column;
   161|         }
   162|         return [
   163|             'row' => $maxRow,
   164|             'column' => Coordinate::stringFromColumnIndex($maxColumn),
   165|         ];
   166|     }
   167|     /**
   168|      * Get highest worksheet column.
   169|      *
   170|      * @param null|int|string $row Return the highest column for the specified row,
   171|      *                    or the highest column of any row if no row number is passed
   172|      *
   173|      * @return string Highest column name
   174|      */
   175|     public function getHighestColumn($row = null): string
   176|     {
   177|         if ($row === null) {
   178|             return $this->getHighestRowAndColumn()['column'];
   179|         }
   180|         $row = (int) $row;
   181|         if ($row <= 0) {
   182|             throw new PhpSpreadsheetException('Row number must be a positive integer');
   183|         }
   184|         $maxColumn = 1;
   185|         $toRow = $row * self::MAX_COLUMN_ID;
   186|         $fromRow = --$row * self::MAX_COLUMN_ID;
   187|         foreach ($this->index as $coordinate) {
   188|             if ($coordinate < $fromRow || $coordinate >= $toRow) {
   189|                 continue;
   190|             }
   191|             $column = ($coordinate % self::MAX_COLUMN_ID) ?: self::MAX_COLUMN_ID;
   192|             $maxColumn = $maxColumn > $column ? $maxColumn : $column;
   193|         }
   194|         return Coordinate::stringFromColumnIndex($maxColumn);
   195|     }
   196|     /**
   197|      * Get highest worksheet row.
   198|      *
   199|      * @param null|string $column Return the highest row for the specified column,
   200|      *                       or the highest row of any column if no column letter is passed
   201|      *
   202|      * @return int Highest row number
   203|      */
   204|     public function getHighestRow(?string $column = null): int
   205|     {
   206|         if ($column === null) {
   207|             return $this->getHighestRowAndColumn()['row'];
   208|         }
   209|         $maxRow = 1;
   210|         $columnIndex = Coordinate::columnIndexFromString($column);
   211|         foreach ($this->index as $coordinate) {
   212|             if ($coordinate % self::MAX_COLUMN_ID !== $columnIndex) {
   213|                 continue;
   214|             }
   215|             $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
   216|             $maxRow = ($maxRow > $row) ? $maxRow : $row;
   217|         }
   218|         return $maxRow;
   219|     }
   220|     /**
   221|      * Generate a unique ID for cache referencing.
   222|      *
   223|      * @return string Unique Reference
   224|      */
   225|     private function getUniqueID(): string
   226|     {
   227|         $cacheType = Settings::getCache();
   228|         return ($cacheType instanceof Memory\SimpleCache1 || $cacheType instanceof Memory\SimpleCache3)
   229|             ? random_bytes(7) . ':'
   230|             : uniqid('phpspreadsheet.', true) . '.';
   231|     }
   232|     /**
   233|      * Clone the cell collection.
   234|      */
   235|     public function cloneCellCollection(Worksheet $worksheet): static
   236|     {
   237|         $this->storeCurrentCell();
   238|         $newCollection = clone $this;
   239|         $newCollection->parent = $worksheet;
   240|         $newCollection->cachePrefix = $newCollection->getUniqueID();
   241|         foreach ($this->index as $key => $value) {
   242|             $newCollection->index[$key] = $value;
   243|             $stored = $newCollection->cache->set(
   244|                 $newCollection->cachePrefix . $key,
   245|                 clone $this->getCache($key)
   246|             );
   247|             if ($stored === false) {
   248|                 $this->destructIfNeeded($newCollection, 'Failed to copy cells in cache');
   249|             }
   250|         }
   251|         return $newCollection;
   252|     }
   253|     /**
   254|      * Remove a row, deleting all cells in that row.
   255|      *
   256|      * @param int|string $row Row number to remove
   257|      */
   258|     public function removeRow($row): void
   259|     {
   260|         $this->storeCurrentCell();
   261|         $row = (int) $row;
   262|         if ($row <= 0) {
   263|             throw new PhpSpreadsheetException('Row number must be a positive integer');
   264|         }
   265|         $toRow = $row * self::MAX_COLUMN_ID;
   266|         $fromRow = --$row * self::MAX_COLUMN_ID;
   267|         foreach ($this->index as $coordinate) {
   268|             if ($coordinate >= $fromRow && $coordinate < $toRow) {
   269|                 $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
   270|                 $column = Coordinate::stringFromColumnIndex($coordinate % self::MAX_COLUMN_ID);
   271|                 $this->delete("{$column}{$row}");
   272|             }
   273|         }
   274|     }
   275|     /**
   276|      * Remove a column, deleting all cells in that column.
   277|      *
   278|      * @param string $column Column ID to remove
   279|      */
   280|     public function removeColumn(string $column): void
   281|     {
   282|         $this->storeCurrentCell();
   283|         $columnIndex = Coordinate::columnIndexFromString($column);
   284|         foreach ($this->index as $coordinate) {
   285|             if ($coordinate % self::MAX_COLUMN_ID === $columnIndex) {
   286|                 $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
   287|                 $column = Coordinate::stringFromColumnIndex($coordinate % self::MAX_COLUMN_ID);
   288|                 $this->delete("{$column}{$row}");
   289|             }
   290|         }
   291|     }
   292|     /**
   293|      * Store cell data in cache for the current cell object if it's "dirty",
   294|      * and the 'nullify' the current cell object.
   295|      */
   296|     private function storeCurrentCell(): void
   297|     {
   298|         if ($this->currentCellIsDirty && isset($this->currentCoordinate, $this->currentCell)) {
   299|             $this->currentCell->detach();
   300|             $stored = $this->cache->set($this->cachePrefix . $this->currentCoordinate, $this->currentCell);
   301|             if ($stored === false) {
   302|                 $this->destructIfNeeded($this, "Failed to store cell {$this->currentCoordinate} in cache");
   303|             }
   304|             $this->currentCellIsDirty = false;
   305|         }
   306|         $this->currentCoordinate = null;
   307|         $this->currentCell = null;
   308|     }
   309|     private function destructIfNeeded(self $cells, string $message): void
   310|     {
   311|         $cells->__destruct();
   312|         throw new PhpSpreadsheetException($message);
   313|     }
   314|     /**
   315|      * Add or update a cell identified by its coordinate into the collection.
   316|      *
   317|      * @param string $cellCoordinate Coordinate of the cell to update
   318|      * @param Cell $cell Cell to update
   319|      */
   320|     public function add(string $cellCoordinate, Cell $cell): Cell
   321|     {
   322|         if ($cellCoordinate !== $this->currentCoordinate) {
   323|             $this->storeCurrentCell();
   324|         }
   325|         $column = 0;
   326|         $row = '';
   327|         sscanf($cellCoordinate, '%[A-Z]%d', $column, $row);
   328|         $this->index[$cellCoordinate] = (--$row * self::MAX_COLUMN_ID) + Coordinate::columnIndexFromString((string) $column);
   329|         $this->currentCoordinate = $cellCoordinate;
   330|         $this->currentCell = $cell;
   331|         $this->currentCellIsDirty = true;
   332|         return $cell;
   333|     }
   334|     /**
   335|      * Get cell at a specific coordinate.
   336|      *
   337|      * @param string $cellCoordinate Coordinate of the cell
   338|      *
   339|      * @return null|Cell Cell that was found, or null if not found
   340|      */
   341|     public function get(string $cellCoordinate): ?Cell
   342|     {
   343|         if ($cellCoordinate === $this->currentCoordinate) {
   344|             return $this->currentCell;
   345|         }
   346|         $this->storeCurrentCell();
   347|         if ($this->has($cellCoordinate) === false) {
   348|             return null;
   349|         }
   350|         $cell = $this->getcache($cellCoordinate);
   351|         $this->currentCoordinate = $cellCoordinate;
   352|         $this->currentCell = $cell;
   353|         $this->currentCell->attach($this);
   354|         return $this->currentCell;
   355|     }
   356|     /**
   357|      * Clear the cell collection and disconnect from our parent.
   358|      */
   359|     public function unsetWorksheetCells(): void
   360|     {
   361|         if ($this->currentCell !== null) {
   362|             $this->currentCell->detach();
   363|             $this->currentCell = null;
   364|             $this->currentCoordinate = null;
   365|         }
   366|         $this->__destruct();
   367|         $this->index = [];
   368|         $this->parent = null;
   369|     }
   370|     /**
   371|      * Destroy this cell collection.
   372|      */
   373|     public function __destruct()
   374|     {
   375|         $this->cache->deleteMultiple($this->getAllCacheKeys());
   376|         $this->parent = null;
   377|     }
   378|     /**
   379|      * Returns all known cache keys.
   380|      *
   381|      * @return iterable<string>
   382|      */
   383|     private function getAllCacheKeys(): iterable
   384|     {
   385|         foreach ($this->index as $coordinate => $value) {
   386|             yield $this->cachePrefix . $coordinate;
   387|         }
   388|     }
   389|     private function getCache(string $cellCoordinate): Cell
   390|     {
   391|         $cell = $this->cache->get($this->cachePrefix . $cellCoordinate);
   392|         if (!($cell instanceof Cell)) {
   393|             throw new PhpSpreadsheetException("Cell entry {$cellCoordinate} no longer exists in cache. This probably means that the cache was cleared by someone else.");
   394|         }
   395|         return $cell;
   396|     }
   397| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Comment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-300 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     4| use PhpOffice\PhpSpreadsheet\Helper\Size;
     5| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     6| use PhpOffice\PhpSpreadsheet\Shared\Drawing as SharedDrawing;
     7| use PhpOffice\PhpSpreadsheet\Style\Alignment;
     8| use PhpOffice\PhpSpreadsheet\Style\Color;
     9| use PhpOffice\PhpSpreadsheet\Worksheet\Drawing;
    10| use Stringable;
    11| class Comment implements IComparable, Stringable
    12| {
    13|     /**
    14|      * Author.
    15|      */
    16|     private string $author;
    17|     /**
    18|      * Rich text comment.
    19|      */
    20|     private RichText $text;
    21|     /**
    22|      * Comment width (CSS style, i.e. XXpx or YYpt).
    23|      */
    24|     private string $width = '96pt';
    25|     /**
    26|      * Left margin (CSS style, i.e. XXpx or YYpt).
    27|      */
    28|     private string $marginLeft = '59.25pt';
    29|     /**
    30|      * Top margin (CSS style, i.e. XXpx or YYpt).
    31|      */
    32|     private string $marginTop = '1.5pt';
    33|     /**
    34|      * Visible.
    35|      */
    36|     private bool $visible = false;
    37|     /**
    38|      * Comment height (CSS style, i.e. XXpx or YYpt).
    39|      */
    40|     private string $height = '55.5pt';
    41|     /**
    42|      * Comment fill color.
    43|      */
    44|     private Color $fillColor;
    45|     /**
    46|      * Alignment.
    47|      */
    48|     private string $alignment;
    49|     /**
    50|      * Background image in comment.
    51|      */
    52|     private Drawing $backgroundImage;
    53|     public const TEXTBOX_DIRECTION_RTL = 'rtl';
    54|     public const TEXTBOX_DIRECTION_LTR = 'ltr';
    55|     public const TEXTBOX_DIRECTION_AUTO = 'auto';
    56|     public const TEXTBOX_DIRECTION_CONTEXT = 'auto';
    57|     private string $textboxDirection = '';
    58|     /**
    59|      * Create a new Comment.
    60|      */
    61|     public function __construct()
    62|     {
    63|         $this->author = 'Author';
    64|         $this->text = new RichText();
    65|         $this->fillColor = new Color('FFFFFFE1');
    66|         $this->alignment = Alignment::HORIZONTAL_GENERAL;
    67|         $this->backgroundImage = new Drawing();
    68|     }
    69|     /**
    70|      * Get Author.
    71|      */
    72|     public function getAuthor(): string
    73|     {
    74|         return $this->author;
    75|     }
    76|     /**
    77|      * Set Author.
    78|      */
    79|     public function setAuthor(string $author): self
    80|     {
    81|         $this->author = $author;
    82|         return $this;
    83|     }
    84|     /**
    85|      * Get Rich text comment.
    86|      */
    87|     public function getText(): RichText
    88|     {
    89|         return $this->text;
    90|     }
    91|     /**
    92|      * Set Rich text comment.
    93|      */
    94|     public function setText(RichText $text): self
    95|     {
    96|         $this->text = $text;
    97|         return $this;
    98|     }
    99|     /**
   100|      * Get comment width (CSS style, i.e. XXpx or YYpt).
   101|      */
   102|     public function getWidth(): string
   103|     {
   104|         return $this->width;
   105|     }
   106|     /**
   107|      * Set comment width (CSS style, i.e. XXpx or YYpt). Default unit is pt.
   108|      */
   109|     public function setWidth(string $width): self
   110|     {
   111|         $width = new Size($width);
   112|         if ($width->valid()) {
   113|             $this->width = (string) $width;
   114|         }
   115|         return $this;
   116|     }
   117|     /**
   118|      * Get comment height (CSS style, i.e. XXpx or YYpt).
   119|      */
   120|     public function getHeight(): string
   121|     {
   122|         return $this->height;
   123|     }
   124|     /**
   125|      * Set comment height (CSS style, i.e. XXpx or YYpt). Default unit is pt.
   126|      */
   127|     public function setHeight(string $height): self
   128|     {
   129|         $height = new Size($height);
   130|         if ($height->valid()) {
   131|             $this->height = (string) $height;
   132|         }
   133|         return $this;
   134|     }
   135|     /**
   136|      * Get left margin (CSS style, i.e. XXpx or YYpt).
   137|      */
   138|     public function getMarginLeft(): string
   139|     {
   140|         return $this->marginLeft;
   141|     }
   142|     /**
   143|      * Set left margin (CSS style, i.e. XXpx or YYpt). Default unit is pt.
   144|      */
   145|     public function setMarginLeft(string $margin): self
   146|     {
   147|         $margin = new Size($margin);
   148|         if ($margin->valid()) {
   149|             $this->marginLeft = (string) $margin;
   150|         }
   151|         return $this;
   152|     }
   153|     /**
   154|      * Get top margin (CSS style, i.e. XXpx or YYpt).
   155|      */
   156|     public function getMarginTop(): string
   157|     {
   158|         return $this->marginTop;
   159|     }
   160|     /**
   161|      * Set top margin (CSS style, i.e. XXpx or YYpt). Default unit is pt.
   162|      */
   163|     public function setMarginTop(string $margin): self
   164|     {
   165|         $margin = new Size($margin);
   166|         if ($margin->valid()) {
   167|             $this->marginTop = (string) $margin;
   168|         }
   169|         return $this;
   170|     }
   171|     /**
   172|      * Is the comment visible by default?
   173|      */
   174|     public function getVisible(): bool
   175|     {
   176|         return $this->visible;
   177|     }
   178|     /**
   179|      * Set comment default visibility.
   180|      */
   181|     public function setVisible(bool $visibility): self
   182|     {
   183|         $this->visible = $visibility;
   184|         return $this;
   185|     }
   186|     /**
   187|      * Set fill color.
   188|      */
   189|     public function setFillColor(Color $color): self
   190|     {
   191|         $this->fillColor = $color;
   192|         return $this;
   193|     }
   194|     /**
   195|      * Get fill color.
   196|      */
   197|     public function getFillColor(): Color
   198|     {
   199|         return $this->fillColor;
   200|     }
   201|     public function setAlignment(string $alignment): self
   202|     {
   203|         $this->alignment = $alignment;
   204|         return $this;
   205|     }
   206|     public function getAlignment(): string
   207|     {
   208|         return $this->alignment;
   209|     }
   210|     public function setTextboxDirection(string $textboxDirection): self
   211|     {
   212|         $this->textboxDirection = $textboxDirection;
   213|         return $this;
   214|     }
   215|     public function getTextboxDirection(): string
   216|     {
   217|         return $this->textboxDirection;
   218|     }
   219|     /**
   220|      * Get hash code.
   221|      */
   222|     public function getHashCode(): string
   223|     {
   224|         return md5(
   225|             $this->author
   226|             . $this->text->getHashCode()
   227|             . $this->width
   228|             . $this->height
   229|             . $this->marginLeft
   230|             . $this->marginTop
   231|             . ($this->visible ? 1 : 0)
   232|             . $this->fillColor->getHashCode()
   233|             . $this->alignment
   234|             . $this->textboxDirection
   235|             . ($this->hasBackgroundImage() ? $this->backgroundImage->getHashCode() : '')
   236|             . __CLASS__
   237|         );
   238|     }
   239|     /**
   240|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   241|      */
   242|     public function __clone()
   243|     {
   244|         $vars = get_object_vars($this);
   245|         foreach ($vars as $key => $value) {
   246|             if (is_object($value)) {
   247|                 $this->$key = clone $value;
   248|             } else {
   249|                 $this->$key = $value;
   250|             }
   251|         }
   252|     }
   253|     /**
   254|      * Convert to string.
   255|      */
   256|     public function __toString(): string
   257|     {
   258|         return $this->text->getPlainText();
   259|     }
   260|     /**
   261|      * Check is background image exists.
   262|      */
   263|     public function hasBackgroundImage(): bool
   264|     {
   265|         $path = $this->backgroundImage->getPath();
   266|         if (empty($path)) {
   267|             return false;
   268|         }
   269|         return getimagesize($path) !== false;
   270|     }
   271|     /**
   272|      * Returns background image.
   273|      */
   274|     public function getBackgroundImage(): Drawing
   275|     {
   276|         return $this->backgroundImage;
   277|     }
   278|     /**
   279|      * Sets background image.
   280|      */
   281|     public function setBackgroundImage(Drawing $objDrawing): self
   282|     {
   283|         if (!array_key_exists($objDrawing->getType(), Drawing::IMAGE_TYPES_CONVERTION_MAP)) {
   284|             throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
   285|         }
   286|         $this->backgroundImage = $objDrawing;
   287|         return $this;
   288|     }
   289|     /**
   290|      * Sets size of comment as size of background image.
   291|      */
   292|     public function setSizeAsBackgroundImage(): self
   293|     {
   294|         if ($this->hasBackgroundImage()) {
   295|             $this->setWidth(SharedDrawing::pixelsToPoints($this->backgroundImage->getWidth()) . 'pt');
   296|             $this->setHeight(SharedDrawing::pixelsToPoints($this->backgroundImage->getHeight()) . 'pt');
   297|         }
   298|         return $this;
   299|     }
   300| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Helper/Html.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-798 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Helper;
     3| use DOMAttr;
     4| use DOMDocument;
     5| use DOMElement;
     6| use DOMNode;
     7| use DOMText;
     8| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     9| use PhpOffice\PhpSpreadsheet\Style\Color;
    10| use PhpOffice\PhpSpreadsheet\Style\Font;
    11| class Html
    12| {
    13|     private const COLOUR_MAP = [
    14|         'aliceblue' => 'f0f8ff',
    15|         'antiquewhite' => 'faebd7',
    16|         'antiquewhite1' => 'ffefdb',
    17|         'antiquewhite2' => 'eedfcc',
    18|         'antiquewhite3' => 'cdc0b0',
    19|         'antiquewhite4' => '8b8378',
    20|         'aqua' => '00ffff',
    21|         'aquamarine1' => '7fffd4',
    22|         'aquamarine2' => '76eec6',
    23|         'aquamarine4' => '458b74',
    24|         'azure1' => 'f0ffff',
    25|         'azure2' => 'e0eeee',
    26|         'azure3' => 'c1cdcd',
    27|         'azure4' => '838b8b',
    28|         'beige' => 'f5f5dc',
    29|         'bisque1' => 'ffe4c4',
    30|         'bisque2' => 'eed5b7',
    31|         'bisque3' => 'cdb79e',
    32|         'bisque4' => '8b7d6b',
    33|         'black' => '000000',
    34|         'blanchedalmond' => 'ffebcd',
    35|         'blue' => '0000ff',
    36|         'blue1' => '0000ff',
    37|         'blue2' => '0000ee',
    38|         'blue4' => '00008b',
    39|         'blueviolet' => '8a2be2',
    40|         'brown' => 'a52a2a',
    41|         'brown1' => 'ff4040',
    42|         'brown2' => 'ee3b3b',
    43|         'brown3' => 'cd3333',
    44|         'brown4' => '8b2323',
    45|         'burlywood' => 'deb887',
    46|         'burlywood1' => 'ffd39b',
    47|         'burlywood2' => 'eec591',
    48|         'burlywood3' => 'cdaa7d',
    49|         'burlywood4' => '8b7355',
    50|         'cadetblue' => '5f9ea0',
    51|         'cadetblue1' => '98f5ff',
    52|         'cadetblue2' => '8ee5ee',
    53|         'cadetblue3' => '7ac5cd',
    54|         'cadetblue4' => '53868b',
    55|         'chartreuse1' => '7fff00',
    56|         'chartreuse2' => '76ee00',
    57|         'chartreuse3' => '66cd00',
    58|         'chartreuse4' => '458b00',
    59|         'chocolate' => 'd2691e',
    60|         'chocolate1' => 'ff7f24',
    61|         'chocolate2' => 'ee7621',
    62|         'chocolate3' => 'cd661d',
    63|         'coral' => 'ff7f50',
    64|         'coral1' => 'ff7256',
    65|         'coral2' => 'ee6a50',
    66|         'coral3' => 'cd5b45',
    67|         'coral4' => '8b3e2f',
    68|         'cornflowerblue' => '6495ed',
    69|         'cornsilk1' => 'fff8dc',
    70|         'cornsilk2' => 'eee8cd',
    71|         'cornsilk3' => 'cdc8b1',
    72|         'cornsilk4' => '8b8878',
    73|         'cyan1' => '00ffff',
    74|         'cyan2' => '00eeee',
    75|         'cyan3' => '00cdcd',
    76|         'cyan4' => '008b8b',
    77|         'darkgoldenrod' => 'b8860b',
    78|         'darkgoldenrod1' => 'ffb90f',
    79|         'darkgoldenrod2' => 'eead0e',
    80|         'darkgoldenrod3' => 'cd950c',
    81|         'darkgoldenrod4' => '8b6508',
    82|         'darkgreen' => '006400',
    83|         'darkkhaki' => 'bdb76b',
    84|         'darkolivegreen' => '556b2f',
    85|         'darkolivegreen1' => 'caff70',
    86|         'darkolivegreen2' => 'bcee68',
    87|         'darkolivegreen3' => 'a2cd5a',
    88|         'darkolivegreen4' => '6e8b3d',
    89|         'darkorange' => 'ff8c00',
    90|         'darkorange1' => 'ff7f00',
    91|         'darkorange2' => 'ee7600',
    92|         'darkorange3' => 'cd6600',
    93|         'darkorange4' => '8b4500',
    94|         'darkorchid' => '9932cc',
    95|         'darkorchid1' => 'bf3eff',
    96|         'darkorchid2' => 'b23aee',
    97|         'darkorchid3' => '9a32cd',
    98|         'darkorchid4' => '68228b',
    99|         'darksalmon' => 'e9967a',
   100|         'darkseagreen' => '8fbc8f',
   101|         'darkseagreen1' => 'c1ffc1',
   102|         'darkseagreen2' => 'b4eeb4',
   103|         'darkseagreen3' => '9bcd9b',
   104|         'darkseagreen4' => '698b69',
   105|         'darkslateblue' => '483d8b',
   106|         'darkslategray' => '2f4f4f',
   107|         'darkslategray1' => '97ffff',
   108|         'darkslategray2' => '8deeee',
   109|         'darkslategray3' => '79cdcd',
   110|         'darkslategray4' => '528b8b',
   111|         'darkturquoise' => '00ced1',
   112|         'darkviolet' => '9400d3',
   113|         'deeppink1' => 'ff1493',
   114|         'deeppink2' => 'ee1289',
   115|         'deeppink3' => 'cd1076',
   116|         'deeppink4' => '8b0a50',
   117|         'deepskyblue1' => '00bfff',
   118|         'deepskyblue2' => '00b2ee',
   119|         'deepskyblue3' => '009acd',
   120|         'deepskyblue4' => '00688b',
   121|         'dimgray' => '696969',
   122|         'dodgerblue1' => '1e90ff',
   123|         'dodgerblue2' => '1c86ee',
   124|         'dodgerblue3' => '1874cd',
   125|         'dodgerblue4' => '104e8b',
   126|         'firebrick' => 'b22222',
   127|         'firebrick1' => 'ff3030',
   128|         'firebrick2' => 'ee2c2c',
   129|         'firebrick3' => 'cd2626',
   130|         'firebrick4' => '8b1a1a',
   131|         'floralwhite' => 'fffaf0',
   132|         'forestgreen' => '228b22',
   133|         'fuchsia' => 'ff00ff',
   134|         'gainsboro' => 'dcdcdc',
   135|         'ghostwhite' => 'f8f8ff',
   136|         'gold1' => 'ffd700',
   137|         'gold2' => 'eec900',
   138|         'gold3' => 'cdad00',
   139|         'gold4' => '8b7500',
   140|         'goldenrod' => 'daa520',
   141|         'goldenrod1' => 'ffc125',
   142|         'goldenrod2' => 'eeb422',
   143|         'goldenrod3' => 'cd9b1d',
   144|         'goldenrod4' => '8b6914',
   145|         'gray' => 'bebebe',
   146|         'gray1' => '030303',
   147|         'gray10' => '1a1a1a',
   148|         'gray11' => '1c1c1c',
   149|         'gray12' => '1f1f1f',
   150|         'gray13' => '212121',
   151|         'gray14' => '242424',
   152|         'gray15' => '262626',
   153|         'gray16' => '292929',
   154|         'gray17' => '2b2b2b',
   155|         'gray18' => '2e2e2e',
   156|         'gray19' => '303030',
   157|         'gray2' => '050505',
   158|         'gray20' => '333333',
   159|         'gray21' => '363636',
   160|         'gray22' => '383838',
   161|         'gray23' => '3b3b3b',
   162|         'gray24' => '3d3d3d',
   163|         'gray25' => '404040',
   164|         'gray26' => '424242',
   165|         'gray27' => '454545',
   166|         'gray28' => '474747',
   167|         'gray29' => '4a4a4a',
   168|         'gray3' => '080808',
   169|         'gray30' => '4d4d4d',
   170|         'gray31' => '4f4f4f',
   171|         'gray32' => '525252',
   172|         'gray33' => '545454',
   173|         'gray34' => '575757',
   174|         'gray35' => '595959',
   175|         'gray36' => '5c5c5c',
   176|         'gray37' => '5e5e5e',
   177|         'gray38' => '616161',
   178|         'gray39' => '636363',
   179|         'gray4' => '0a0a0a',
   180|         'gray40' => '666666',
   181|         'gray41' => '696969',
   182|         'gray42' => '6b6b6b',
   183|         'gray43' => '6e6e6e',
   184|         'gray44' => '707070',
   185|         'gray45' => '737373',
   186|         'gray46' => '757575',
   187|         'gray47' => '787878',
   188|         'gray48' => '7a7a7a',
   189|         'gray49' => '7d7d7d',
   190|         'gray5' => '0d0d0d',
   191|         'gray50' => '7f7f7f',
   192|         'gray51' => '828282',
   193|         'gray52' => '858585',
   194|         'gray53' => '878787',
   195|         'gray54' => '8a8a8a',
   196|         'gray55' => '8c8c8c',
   197|         'gray56' => '8f8f8f',
   198|         'gray57' => '919191',
   199|         'gray58' => '949494',
   200|         'gray59' => '969696',
   201|         'gray6' => '0f0f0f',
   202|         'gray60' => '999999',
   203|         'gray61' => '9c9c9c',
   204|         'gray62' => '9e9e9e',
   205|         'gray63' => 'a1a1a1',
   206|         'gray64' => 'a3a3a3',
   207|         'gray65' => 'a6a6a6',
   208|         'gray66' => 'a8a8a8',
   209|         'gray67' => 'ababab',
   210|         'gray68' => 'adadad',
   211|         'gray69' => 'b0b0b0',
   212|         'gray7' => '121212',
   213|         'gray70' => 'b3b3b3',
   214|         'gray71' => 'b5b5b5',
   215|         'gray72' => 'b8b8b8',
   216|         'gray73' => 'bababa',
   217|         'gray74' => 'bdbdbd',
   218|         'gray75' => 'bfbfbf',
   219|         'gray76' => 'c2c2c2',
   220|         'gray77' => 'c4c4c4',
   221|         'gray78' => 'c7c7c7',
   222|         'gray79' => 'c9c9c9',
   223|         'gray8' => '141414',
   224|         'gray80' => 'cccccc',
   225|         'gray81' => 'cfcfcf',
   226|         'gray82' => 'd1d1d1',
   227|         'gray83' => 'd4d4d4',
   228|         'gray84' => 'd6d6d6',
   229|         'gray85' => 'd9d9d9',
   230|         'gray86' => 'dbdbdb',
   231|         'gray87' => 'dedede',
   232|         'gray88' => 'e0e0e0',
   233|         'gray89' => 'e3e3e3',
   234|         'gray9' => '171717',
   235|         'gray90' => 'e5e5e5',
   236|         'gray91' => 'e8e8e8',
   237|         'gray92' => 'ebebeb',
   238|         'gray93' => 'ededed',
   239|         'gray94' => 'f0f0f0',
   240|         'gray95' => 'f2f2f2',
   241|         'gray97' => 'f7f7f7',
   242|         'gray98' => 'fafafa',
   243|         'gray99' => 'fcfcfc',
   244|         'green' => '00ff00',
   245|         'green1' => '00ff00',
   246|         'green2' => '00ee00',
   247|         'green3' => '00cd00',
   248|         'green4' => '008b00',
   249|         'greenyellow' => 'adff2f',
   250|         'honeydew1' => 'f0fff0',
   251|         'honeydew2' => 'e0eee0',
   252|         'honeydew3' => 'c1cdc1',
   253|         'honeydew4' => '838b83',
   254|         'hotpink' => 'ff69b4',
   255|         'hotpink1' => 'ff6eb4',
   256|         'hotpink2' => 'ee6aa7',
   257|         'hotpink3' => 'cd6090',
   258|         'hotpink4' => '8b3a62',
   259|         'indianred' => 'cd5c5c',
   260|         'indianred1' => 'ff6a6a',
   261|         'indianred2' => 'ee6363',
   262|         'indianred3' => 'cd5555',
   263|         'indianred4' => '8b3a3a',
   264|         'ivory1' => 'fffff0',
   265|         'ivory2' => 'eeeee0',
   266|         'ivory3' => 'cdcdc1',
   267|         'ivory4' => '8b8b83',
   268|         'khaki' => 'f0e68c',
   269|         'khaki1' => 'fff68f',
   270|         'khaki2' => 'eee685',
   271|         'khaki3' => 'cdc673',
   272|         'khaki4' => '8b864e',
   273|         'lavender' => 'e6e6fa',
   274|         'lavenderblush1' => 'fff0f5',
   275|         'lavenderblush2' => 'eee0e5',
   276|         'lavenderblush3' => 'cdc1c5',
   277|         'lavenderblush4' => '8b8386',
   278|         'lawngreen' => '7cfc00',
   279|         'lemonchiffon1' => 'fffacd',
   280|         'lemonchiffon2' => 'eee9bf',
   281|         'lemonchiffon3' => 'cdc9a5',
   282|         'lemonchiffon4' => '8b8970',
   283|         'light' => 'eedd82',
   284|         'lightblue' => 'add8e6',
   285|         'lightblue1' => 'bfefff',
   286|         'lightblue2' => 'b2dfee',
   287|         'lightblue3' => '9ac0cd',
   288|         'lightblue4' => '68838b',
   289|         'lightcoral' => 'f08080',
   290|         'lightcyan1' => 'e0ffff',
   291|         'lightcyan2' => 'd1eeee',
   292|         'lightcyan3' => 'b4cdcd',
   293|         'lightcyan4' => '7a8b8b',
   294|         'lightgoldenrod1' => 'ffec8b',
   295|         'lightgoldenrod2' => 'eedc82',
   296|         'lightgoldenrod3' => 'cdbe70',
   297|         'lightgoldenrod4' => '8b814c',
   298|         'lightgoldenrodyellow' => 'fafad2',
   299|         'lightgray' => 'd3d3d3',
   300|         'lightpink' => 'ffb6c1',
   301|         'lightpink1' => 'ffaeb9',
   302|         'lightpink2' => 'eea2ad',
   303|         'lightpink3' => 'cd8c95',
   304|         'lightpink4' => '8b5f65',
   305|         'lightsalmon1' => 'ffa07a',
   306|         'lightsalmon2' => 'ee9572',
   307|         'lightsalmon3' => 'cd8162',
   308|         'lightsalmon4' => '8b5742',
   309|         'lightseagreen' => '20b2aa',
   310|         'lightskyblue' => '87cefa',
   311|         'lightskyblue1' => 'b0e2ff',
   312|         'lightskyblue2' => 'a4d3ee',
   313|         'lightskyblue3' => '8db6cd',
   314|         'lightskyblue4' => '607b8b',
   315|         'lightslateblue' => '8470ff',
   316|         'lightslategray' => '778899',
   317|         'lightsteelblue' => 'b0c4de',
   318|         'lightsteelblue1' => 'cae1ff',
   319|         'lightsteelblue2' => 'bcd2ee',
   320|         'lightsteelblue3' => 'a2b5cd',
   321|         'lightsteelblue4' => '6e7b8b',
   322|         'lightyellow1' => 'ffffe0',
   323|         'lightyellow2' => 'eeeed1',
   324|         'lightyellow3' => 'cdcdb4',
   325|         'lightyellow4' => '8b8b7a',
   326|         'lime' => '00ff00',
   327|         'limegreen' => '32cd32',
   328|         'linen' => 'faf0e6',
   329|         'magenta' => 'ff00ff',
   330|         'magenta2' => 'ee00ee',
   331|         'magenta3' => 'cd00cd',
   332|         'magenta4' => '8b008b',
   333|         'maroon' => 'b03060',
   334|         'maroon1' => 'ff34b3',
   335|         'maroon2' => 'ee30a7',
   336|         'maroon3' => 'cd2990',
   337|         'maroon4' => '8b1c62',
   338|         'medium' => '66cdaa',
   339|         'mediumaquamarine' => '66cdaa',
   340|         'mediumblue' => '0000cd',
   341|         'mediumorchid' => 'ba55d3',
   342|         'mediumorchid1' => 'e066ff',
   343|         'mediumorchid2' => 'd15fee',
   344|         'mediumorchid3' => 'b452cd',
   345|         'mediumorchid4' => '7a378b',
   346|         'mediumpurple' => '9370db',
   347|         'mediumpurple1' => 'ab82ff',
   348|         'mediumpurple2' => '9f79ee',
   349|         'mediumpurple3' => '8968cd',
   350|         'mediumpurple4' => '5d478b',
   351|         'mediumseagreen' => '3cb371',
   352|         'mediumslateblue' => '7b68ee',
   353|         'mediumspringgreen' => '00fa9a',
   354|         'mediumturquoise' => '48d1cc',
   355|         'mediumvioletred' => 'c71585',
   356|         'midnightblue' => '191970',
   357|         'mintcream' => 'f5fffa',
   358|         'mistyrose1' => 'ffe4e1',
   359|         'mistyrose2' => 'eed5d2',
   360|         'mistyrose3' => 'cdb7b5',
   361|         'mistyrose4' => '8b7d7b',
   362|         'moccasin' => 'ffe4b5',
   363|         'navajowhite1' => 'ffdead',
   364|         'navajowhite2' => 'eecfa1',
   365|         'navajowhite3' => 'cdb38b',
   366|         'navajowhite4' => '8b795e',
   367|         'navy' => '000080',
   368|         'navyblue' => '000080',
   369|         'oldlace' => 'fdf5e6',
   370|         'olive' => '808000',
   371|         'olivedrab' => '6b8e23',
   372|         'olivedrab1' => 'c0ff3e',
   373|         'olivedrab2' => 'b3ee3a',
   374|         'olivedrab4' => '698b22',
   375|         'orange' => 'ffa500',
   376|         'orange1' => 'ffa500',
   377|         'orange2' => 'ee9a00',
   378|         'orange3' => 'cd8500',
   379|         'orange4' => '8b5a00',
   380|         'orangered1' => 'ff4500',
   381|         'orangered2' => 'ee4000',
   382|         'orangered3' => 'cd3700',
   383|         'orangered4' => '8b2500',
   384|         'orchid' => 'da70d6',
   385|         'orchid1' => 'ff83fa',
   386|         'orchid2' => 'ee7ae9',
   387|         'orchid3' => 'cd69c9',
   388|         'orchid4' => '8b4789',
   389|         'pale' => 'db7093',
   390|         'palegoldenrod' => 'eee8aa',
   391|         'palegreen' => '98fb98',
   392|         'palegreen1' => '9aff9a',
   393|         'palegreen2' => '90ee90',
   394|         'palegreen3' => '7ccd7c',
   395|         'palegreen4' => '548b54',
   396|         'paleturquoise' => 'afeeee',
   397|         'paleturquoise1' => 'bbffff',
   398|         'paleturquoise2' => 'aeeeee',
   399|         'paleturquoise3' => '96cdcd',
   400|         'paleturquoise4' => '668b8b',
   401|         'palevioletred' => 'db7093',
   402|         'palevioletred1' => 'ff82ab',
   403|         'palevioletred2' => 'ee799f',
   404|         'palevioletred3' => 'cd6889',
   405|         'palevioletred4' => '8b475d',
   406|         'papayawhip' => 'ffefd5',
   407|         'peachpuff1' => 'ffdab9',
   408|         'peachpuff2' => 'eecbad',
   409|         'peachpuff3' => 'cdaf95',
   410|         'peachpuff4' => '8b7765',
   411|         'pink' => 'ffc0cb',
   412|         'pink1' => 'ffb5c5',
   413|         'pink2' => 'eea9b8',
   414|         'pink3' => 'cd919e',
   415|         'pink4' => '8b636c',
   416|         'plum' => 'dda0dd',
   417|         'plum1' => 'ffbbff',
   418|         'plum2' => 'eeaeee',
   419|         'plum3' => 'cd96cd',
   420|         'plum4' => '8b668b',
   421|         'powderblue' => 'b0e0e6',
   422|         'purple' => 'a020f0',
   423|         'rebeccapurple' => '663399',
   424|         'purple1' => '9b30ff',
   425|         'purple2' => '912cee',
   426|         'purple3' => '7d26cd',
   427|         'purple4' => '551a8b',
   428|         'red' => 'ff0000',
   429|         'red1' => 'ff0000',
   430|         'red2' => 'ee0000',
   431|         'red3' => 'cd0000',
   432|         'red4' => '8b0000',
   433|         'rosybrown' => 'bc8f8f',
   434|         'rosybrown1' => 'ffc1c1',
   435|         'rosybrown2' => 'eeb4b4',
   436|         'rosybrown3' => 'cd9b9b',
   437|         'rosybrown4' => '8b6969',
   438|         'royalblue' => '4169e1',
   439|         'royalblue1' => '4876ff',
   440|         'royalblue2' => '436eee',
   441|         'royalblue3' => '3a5fcd',
   442|         'royalblue4' => '27408b',
   443|         'saddlebrown' => '8b4513',
   444|         'salmon' => 'fa8072',
   445|         'salmon1' => 'ff8c69',
   446|         'salmon2' => 'ee8262',
   447|         'salmon3' => 'cd7054',
   448|         'salmon4' => '8b4c39',
   449|         'sandybrown' => 'f4a460',
   450|         'seagreen1' => '54ff9f',
   451|         'seagreen2' => '4eee94',
   452|         'seagreen3' => '43cd80',
   453|         'seagreen4' => '2e8b57',
   454|         'seashell1' => 'fff5ee',
   455|         'seashell2' => 'eee5de',
   456|         'seashell3' => 'cdc5bf',
   457|         'seashell4' => '8b8682',
   458|         'sienna' => 'a0522d',
   459|         'sienna1' => 'ff8247',
   460|         'sienna2' => 'ee7942',
   461|         'sienna3' => 'cd6839',
   462|         'sienna4' => '8b4726',
   463|         'silver' => 'c0c0c0',
   464|         'skyblue' => '87ceeb',
   465|         'skyblue1' => '87ceff',
   466|         'skyblue2' => '7ec0ee',
   467|         'skyblue3' => '6ca6cd',
   468|         'skyblue4' => '4a708b',
   469|         'slateblue' => '6a5acd',
   470|         'slateblue1' => '836fff',
   471|         'slateblue2' => '7a67ee',
   472|         'slateblue3' => '6959cd',
   473|         'slateblue4' => '473c8b',
   474|         'slategray' => '708090',
   475|         'slategray1' => 'c6e2ff',
   476|         'slategray2' => 'b9d3ee',
   477|         'slategray3' => '9fb6cd',
   478|         'slategray4' => '6c7b8b',
   479|         'snow1' => 'fffafa',
   480|         'snow2' => 'eee9e9',
   481|         'snow3' => 'cdc9c9',
   482|         'snow4' => '8b8989',
   483|         'springgreen1' => '00ff7f',
   484|         'springgreen2' => '00ee76',
   485|         'springgreen3' => '00cd66',
   486|         'springgreen4' => '008b45',
   487|         'steelblue' => '4682b4',
   488|         'steelblue1' => '63b8ff',
   489|         'steelblue2' => '5cacee',
   490|         'steelblue3' => '4f94cd',
   491|         'steelblue4' => '36648b',
   492|         'tan' => 'd2b48c',
   493|         'tan1' => 'ffa54f',
   494|         'tan2' => 'ee9a49',
   495|         'tan3' => 'cd853f',
   496|         'tan4' => '8b5a2b',
   497|         'teal' => '008080',
   498|         'thistle' => 'd8bfd8',
   499|         'thistle1' => 'ffe1ff',
   500|         'thistle2' => 'eed2ee',
   501|         'thistle3' => 'cdb5cd',
   502|         'thistle4' => '8b7b8b',
   503|         'tomato1' => 'ff6347',
   504|         'tomato2' => 'ee5c42',
   505|         'tomato3' => 'cd4f39',
   506|         'tomato4' => '8b3626',
   507|         'turquoise' => '40e0d0',
   508|         'turquoise1' => '00f5ff',
   509|         'turquoise2' => '00e5ee',
   510|         'turquoise3' => '00c5cd',
   511|         'turquoise4' => '00868b',
   512|         'violet' => 'ee82ee',
   513|         'violetred' => 'd02090',
   514|         'violetred1' => 'ff3e96',
   515|         'violetred2' => 'ee3a8c',
   516|         'violetred3' => 'cd3278',
   517|         'violetred4' => '8b2252',
   518|         'wheat' => 'f5deb3',
   519|         'wheat1' => 'ffe7ba',
   520|         'wheat2' => 'eed8ae',
   521|         'wheat3' => 'cdba96',
   522|         'wheat4' => '8b7e66',
   523|         'white' => 'ffffff',
   524|         'whitesmoke' => 'f5f5f5',
   525|         'yellow' => 'ffff00',
   526|         'yellow1' => 'ffff00',
   527|         'yellow2' => 'eeee00',
   528|         'yellow3' => 'cdcd00',
   529|         'yellow4' => '8b8b00',
   530|         'yellowgreen' => '9acd32',
   531|     ];
   532|     /** @var ?string */
   533|     private ?string $face = null;
   534|     /** @var ?string */
   535|     private ?string $size = null;
   536|     /** @var ?string */
   537|     private ?string $color = null;
   538|     private bool $bold = false;
   539|     private bool $italic = false;
   540|     private bool $underline = false;
   541|     private bool $superscript = false;
   542|     private bool $subscript = false;
   543|     private bool $strikethrough = false;
   544|     /** @var callable[] */
   545|     private array $startTagCallbacks = [
   546|         'font' => [self::class, 'startFontTag'],
   547|         'b' => [self::class, 'startBoldTag'],
   548|         'strong' => [self::class, 'startBoldTag'],
   549|         'i' => [self::class, 'startItalicTag'],
   550|         'em' => [self::class, 'startItalicTag'],
   551|         'u' => [self::class, 'startUnderlineTag'],
   552|         'ins' => [self::class, 'startUnderlineTag'],
   553|         'del' => [self::class, 'startStrikethruTag'],
   554|         'sup' => [self::class, 'startSuperscriptTag'],
   555|         'sub' => [self::class, 'startSubscriptTag'],
   556|     ];
   557|     /** @var callable[] */
   558|     private array $endTagCallbacks = [
   559|         'font' => [self::class, 'endFontTag'],
   560|         'b' => [self::class, 'endBoldTag'],
   561|         'strong' => [self::class, 'endBoldTag'],
   562|         'i' => [self::class, 'endItalicTag'],
   563|         'em' => [self::class, 'endItalicTag'],
   564|         'u' => [self::class, 'endUnderlineTag'],
   565|         'ins' => [self::class, 'endUnderlineTag'],
   566|         'del' => [self::class, 'endStrikethruTag'],
   567|         'sup' => [self::class, 'endSuperscriptTag'],
   568|         'sub' => [self::class, 'endSubscriptTag'],
   569|         'br' => [self::class, 'breakTag'],
   570|         'p' => [self::class, 'breakTag'],
   571|         'h1' => [self::class, 'breakTag'],
   572|         'h2' => [self::class, 'breakTag'],
   573|         'h3' => [self::class, 'breakTag'],
   574|         'h4' => [self::class, 'breakTag'],
   575|         'h5' => [self::class, 'breakTag'],
   576|         'h6' => [self::class, 'breakTag'],
   577|     ];
   578|     private array $stack = [];
   579|     public string $stringData = '';
   580|     private RichText $richTextObject;
   581|     private bool $preserveWhiteSpace = false;
   582|     private function initialise(): void
   583|     {
   584|         $this->face = $this->size = $this->color = null;
   585|         $this->bold = $this->italic = $this->underline = $this->superscript = $this->subscript = $this->strikethrough = false;
   586|         $this->stack = [];
   587|         $this->stringData = '';
   588|     }
   589|     /**
   590|      * Parse HTML formatting and return the resulting RichText.
   591|      */
   592|     public function toRichTextObject(string $html, bool $preserveWhiteSpace = false): RichText
   593|     {
   594|         $this->initialise();
   595|         $dom = new DOMDocument();
   596|         $prefix = '<?xml encoding="UTF-8">';
   597|         @$dom->loadHTML($prefix . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
   598|         $dom->preserveWhiteSpace = false;
   599|         $this->richTextObject = new RichText();
   600|         $this->preserveWhiteSpace = $preserveWhiteSpace;
   601|         $this->parseElements($dom);
   602|         $this->preserveWhiteSpace = false;
   603|         $this->cleanWhitespace();
   604|         return $this->richTextObject;
   605|     }
   606|     private function cleanWhitespace(): void
   607|     {
   608|         foreach ($this->richTextObject->getRichTextElements() as $key => $element) {
   609|             $text = $element->getText();
   610|             if ($key == 0) {
   611|                 $text = ltrim($text);
   612|             }
   613|             $text = (string) preg_replace('/\n */mu', "\n", $text);
   614|             $element->setText($text);
   615|         }
   616|     }
   617|     private function buildTextRun(): void
   618|     {
   619|         $text = $this->stringData;
   620|         if (trim($text) === '') {
   621|             return;
   622|         }
   623|         $richtextRun = $this->richTextObject->createTextRun($this->stringData);
   624|         $font = $richtextRun->getFont();
   625|         if ($font !== null) {
   626|             if ($this->face) {
   627|                 $font->setName($this->face);
   628|             }
   629|             if ($this->size) {
   630|                 $font->setSize($this->size);
   631|             }
   632|             if ($this->color) {
   633|                 $font->setColor(new Color('ff' . $this->color));
   634|             }
   635|             if ($this->bold) {
   636|                 $font->setBold(true);
   637|             }
   638|             if ($this->italic) {
   639|                 $font->setItalic(true);
   640|             }
   641|             if ($this->underline) {
   642|                 $font->setUnderline(Font::UNDERLINE_SINGLE);
   643|             }
   644|             if ($this->superscript) {
   645|                 $font->setSuperscript(true);
   646|             }
   647|             if ($this->subscript) {
   648|                 $font->setSubscript(true);
   649|             }
   650|             if ($this->strikethrough) {
   651|                 $font->setStrikethrough(true);
   652|             }
   653|         }
   654|         $this->stringData = '';
   655|     }
   656|     private function rgbToColour(string $rgbValue): string
   657|     {
   658|         preg_match_all('/\d+/', $rgbValue, $values);
   659|         foreach ($values[0] as &$value) {
   660|             $value = str_pad(dechex((int) $value), 2, '0', STR_PAD_LEFT);
   661|         }
   662|         return implode('', $values[0]);
   663|     }
   664|     public static function colourNameLookup(string $colorName): string
   665|     {
   666|         return self::COLOUR_MAP[$colorName] ?? '';
   667|     }
   668|     protected function startFontTag(DOMElement $tag): void
   669|     {
   670|         $attrs = $tag->attributes;
   671|         if ($attrs !== null) {
   672|             /** @var DOMAttr $attribute */
   673|             foreach ($attrs as $attribute) {
   674|                 $attributeName = strtolower($attribute->name);
   675|                 $attributeName = preg_replace('/^html:/', '', $attributeName) ?? $attributeName; // in case from Xml spreadsheet
   676|                 $attributeValue = $attribute->value;
   677|                 if ($attributeName == 'color') {
   678|                     if (preg_match('/rgb\s*\(/', $attributeValue)) {
   679|                         $this->$attributeName = $this->rgbToColour($attributeValue);
   680|                     } elseif (str_starts_with(trim($attributeValue), '#')) {
   681|                         $this->$attributeName = ltrim($attributeValue, '#');
   682|                     } else {
   683|                         $this->$attributeName = static::colourNameLookup($attributeValue);
   684|                     }
   685|                 } else {
   686|                     $this->$attributeName = $attributeValue;
   687|                 }
   688|             }
   689|         }
   690|     }
   691|     protected function endFontTag(): void
   692|     {
   693|         $this->face = $this->size = $this->color = null;
   694|     }
   695|     protected function startBoldTag(): void
   696|     {
   697|         $this->bold = true;
   698|     }
   699|     protected function endBoldTag(): void
   700|     {
   701|         $this->bold = false;
   702|     }
   703|     protected function startItalicTag(): void
   704|     {
   705|         $this->italic = true;
   706|     }
   707|     protected function endItalicTag(): void
   708|     {
   709|         $this->italic = false;
   710|     }
   711|     protected function startUnderlineTag(): void
   712|     {
   713|         $this->underline = true;
   714|     }
   715|     protected function endUnderlineTag(): void
   716|     {
   717|         $this->underline = false;
   718|     }
   719|     protected function startSubscriptTag(): void
   720|     {
   721|         $this->subscript = true;
   722|     }
   723|     protected function endSubscriptTag(): void
   724|     {
   725|         $this->subscript = false;
   726|     }
   727|     protected function startSuperscriptTag(): void
   728|     {
   729|         $this->superscript = true;
   730|     }
   731|     protected function endSuperscriptTag(): void
   732|     {
   733|         $this->superscript = false;
   734|     }
   735|     protected function startStrikethruTag(): void
   736|     {
   737|         $this->strikethrough = true;
   738|     }
   739|     protected function endStrikethruTag(): void
   740|     {
   741|         $this->strikethrough = false;
   742|     }
   743|     public function breakTag(): void
   744|     {
   745|         $this->stringData .= "\n";
   746|     }
   747|     private function parseTextNode(DOMText $textNode): void
   748|     {
   749|         if ($this->preserveWhiteSpace) {
   750|             $domText = $textNode->nodeValue ?? '';
   751|         } else {
   752|             $domText = (string) preg_replace(
   753|                 '/\s+/u',
   754|                 ' ',
   755|                 str_replace(["\r", "\n"], ' ', $textNode->nodeValue ?? '')
   756|             );
   757|         }
   758|         $this->stringData .= $domText;
   759|         $this->buildTextRun();
   760|     }
   761|     public function addStartTagCallback(string $tag, callable $callback): void
   762|     {
   763|         $this->startTagCallbacks[$tag] = $callback;
   764|     }
   765|     public function addEndTagCallback(string $tag, callable $callback): void
   766|     {
   767|         $this->endTagCallbacks[$tag] = $callback;
   768|     }
   769|     /** @param callable[] $callbacks */
   770|     private function handleCallback(DOMElement $element, string $callbackTag, array $callbacks): void
   771|     {
   772|         if (isset($callbacks[$callbackTag])) {
   773|             $elementHandler = $callbacks[$callbackTag];
   774|             if (is_callable($elementHandler)) {
   775|                 call_user_func($elementHandler, $element, $this);
   776|             }
   777|         }
   778|     }
   779|     private function parseElementNode(DOMElement $element): void
   780|     {
   781|         $callbackTag = strtolower($element->nodeName);
   782|         $this->stack[] = $callbackTag;
   783|         $this->handleCallback($element, $callbackTag, $this->startTagCallbacks);
   784|         $this->parseElements($element);
   785|         array_pop($this->stack);
   786|         $this->handleCallback($element, $callbackTag, $this->endTagCallbacks);
   787|     }
   788|     private function parseElements(DOMNode $element): void
   789|     {
   790|         foreach ($element->childNodes as $child) {
   791|             if ($child instanceof DOMText) {
   792|                 $this->parseTextNode($child);
   793|             } elseif ($child instanceof DOMElement) {
   794|                 $this->parseElementNode($child);
   795|             }
   796|         }
   797|     }
   798| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Helper/Sample.php
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Helper;
     3| use PhpOffice\PhpSpreadsheet\Chart\Chart;
     4| use PhpOffice\PhpSpreadsheet\Chart\Renderer\MtJpGraphRenderer;
     5| use PhpOffice\PhpSpreadsheet\IOFactory;
     6| use PhpOffice\PhpSpreadsheet\Settings;
     7| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     8| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     9| use PhpOffice\PhpSpreadsheet\Writer\IWriter;
    10| use RecursiveDirectoryIterator;
    11| use RecursiveIteratorIterator;
    12| use RecursiveRegexIterator;
    13| use ReflectionClass;
    14| use RegexIterator;
    15| use RuntimeException;
    16| use Throwable;
    17| /**
    18|  * Helper class to be used in sample code.
    19|  */
    20| class Sample
    21| {
    22|     /**
    23|      * Returns whether we run on CLI or browser.
    24|      */
    25|     public function isCli(): bool
    26|     {
    27|         return PHP_SAPI === 'cli';
    28|     }
    29|     /**

# --- HUNK 2: Lines 89-129 ---
    89|         return $files;
    90|     }
    91|     /**
    92|      * Write documents.
    93|      *
    94|      * @param string[] $writers
    95|      */
    96|     public function write(Spreadsheet $spreadsheet, string $filename, array $writers = ['Xlsx', 'Xls'], bool $withCharts = false, ?callable $writerCallback = null, bool $resetActiveSheet = true): void
    97|     {
    98|         if ($resetActiveSheet) {
    99|             $spreadsheet->setActiveSheetIndex(0);
   100|         }
   101|         foreach ($writers as $writerType) {
   102|             $path = $this->getFilename($filename, mb_strtolower($writerType));
   103|             $writer = IOFactory::createWriter($spreadsheet, $writerType);
   104|             $writer->setIncludeCharts($withCharts);
   105|             if ($writerCallback !== null) {
   106|                 $writerCallback($writer);
   107|             }
   108|             $callStartTime = microtime(true);
   109|             $writer->save($path);
   110|             $this->logWrite($writer, $path, $callStartTime);
   111|             if ($this->isCli() === false) {
   112|                 echo '<a href="/download.php?type=' . pathinfo($path, PATHINFO_EXTENSION) . '&name=' . basename($path) . '">Download ' . basename($path) . '</a><br />';
   113|             }
   114|         }
   115|         $this->logEndingNotes();
   116|     }
   117|     protected function isDirOrMkdir(string $folder): bool
   118|     {
   119|         return \is_dir($folder) || \mkdir($folder);
   120|     }
   121|     /**
   122|      * Returns the temporary directory and make sure it exists.
   123|      */
   124|     public function getTemporaryFolder(): string
   125|     {
   126|         $tempFolder = sys_get_temp_dir() . '/phpspreadsheet';
   127|         if (!$this->isDirOrMkdir($tempFolder)) {
   128|             throw new RuntimeException(sprintf('Directory "%s" was not created', $tempFolder));
   129|         }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/BaseReader.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-199 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     4| use PhpOffice\PhpSpreadsheet\Reader\Exception as ReaderException;
     5| use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
     6| use PhpOffice\PhpSpreadsheet\Shared\File;
     7| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     8| abstract class BaseReader implements IReader
     9| {
    10|     /**
    11|      * Read data only?
    12|      * Identifies whether the Reader should only read data values for cells, and ignore any formatting information;
    13|      *        or whether it should read both data and formatting.
    14|      */
    15|     protected bool $readDataOnly = false;
    16|     /**
    17|      * Read empty cells?
    18|      * Identifies whether the Reader should read data values for cells all cells, or should ignore cells containing
    19|      *         null value or empty string.
    20|      */
    21|     protected bool $readEmptyCells = true;
    22|     /**
    23|      * Read charts that are defined in the workbook?
    24|      * Identifies whether the Reader should read the definitions for any charts that exist in the workbook;.
    25|      */
    26|     protected bool $includeCharts = false;
    27|     /**
    28|      * Restrict which sheets should be loaded?
    29|      * This property holds an array of worksheet names to be loaded. If null, then all worksheets will be loaded.
    30|      * This property is ignored for Csv, Html, and Slk.
    31|      *
    32|      * @var null|string[]
    33|      */
    34|     protected ?array $loadSheetsOnly = null;
    35|     /**
    36|      * Ignore rows with no cells?
    37|      * Identifies whether the Reader should ignore rows with no cells.
    38|      *        Currently implemented only for Xlsx.
    39|      */
    40|     protected bool $ignoreRowsWithNoCells = false;
    41|     /**
    42|      * IReadFilter instance.
    43|      */
    44|     protected IReadFilter $readFilter;
    45|     /** @var resource */
    46|     protected $fileHandle;
    47|     protected ?XmlScanner $securityScanner = null;
    48|     public function __construct()
    49|     {
    50|         $this->readFilter = new DefaultReadFilter();
    51|     }
    52|     public function getReadDataOnly(): bool
    53|     {
    54|         return $this->readDataOnly;
    55|     }
    56|     public function setReadDataOnly(bool $readCellValuesOnly): self
    57|     {
    58|         $this->readDataOnly = $readCellValuesOnly;
    59|         return $this;
    60|     }
    61|     public function getReadEmptyCells(): bool
    62|     {
    63|         return $this->readEmptyCells;
    64|     }
    65|     public function setReadEmptyCells(bool $readEmptyCells): self
    66|     {
    67|         $this->readEmptyCells = $readEmptyCells;
    68|         return $this;
    69|     }
    70|     public function getIgnoreRowsWithNoCells(): bool
    71|     {
    72|         return $this->ignoreRowsWithNoCells;
    73|     }
    74|     public function setIgnoreRowsWithNoCells(bool $ignoreRowsWithNoCells): self
    75|     {
    76|         $this->ignoreRowsWithNoCells = $ignoreRowsWithNoCells;
    77|         return $this;
    78|     }
    79|     public function getIncludeCharts(): bool
    80|     {
    81|         return $this->includeCharts;
    82|     }
    83|     public function setIncludeCharts(bool $includeCharts): self
    84|     {
    85|         $this->includeCharts = $includeCharts;
    86|         return $this;
    87|     }
    88|     public function getLoadSheetsOnly(): ?array
    89|     {
    90|         return $this->loadSheetsOnly;
    91|     }
    92|     public function setLoadSheetsOnly(string|array|null $sheetList): self
    93|     {
    94|         if ($sheetList === null) {
    95|             return $this->setLoadAllSheets();
    96|         }
    97|         $this->loadSheetsOnly = is_array($sheetList) ? $sheetList : [$sheetList];
    98|         return $this;
    99|     }
   100|     public function setLoadAllSheets(): self
   101|     {
   102|         $this->loadSheetsOnly = null;
   103|         return $this;
   104|     }
   105|     public function getReadFilter(): IReadFilter
   106|     {
   107|         return $this->readFilter;
   108|     }
   109|     public function setReadFilter(IReadFilter $readFilter): self
   110|     {
   111|         $this->readFilter = $readFilter;
   112|         return $this;
   113|     }
   114|     public function getSecurityScanner(): ?XmlScanner
   115|     {
   116|         return $this->securityScanner;
   117|     }
   118|     public function getSecurityScannerOrThrow(): XmlScanner
   119|     {
   120|         if ($this->securityScanner === null) {
   121|             throw new ReaderException('Security scanner is unexpectedly null');
   122|         }
   123|         return $this->securityScanner;
   124|     }
   125|     protected function processFlags(int $flags): void
   126|     {
   127|         if (((bool) ($flags & self::LOAD_WITH_CHARTS)) === true) {
   128|             $this->setIncludeCharts(true);
   129|         }
   130|         if (((bool) ($flags & self::READ_DATA_ONLY)) === true) {
   131|             $this->setReadDataOnly(true);
   132|         }
   133|         if (((bool) ($flags & self::SKIP_EMPTY_CELLS) || (bool) ($flags & self::IGNORE_EMPTY_CELLS)) === true) {
   134|             $this->setReadEmptyCells(false);
   135|         }
   136|         if (((bool) ($flags & self::IGNORE_ROWS_WITH_NO_CELLS)) === true) {
   137|             $this->setIgnoreRowsWithNoCells(true);
   138|         }
   139|     }
   140|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   141|     {
   142|         throw new PhpSpreadsheetException('Reader classes must implement their own loadSpreadsheetFromFile() method');
   143|     }
   144|     /**
   145|      * Loads Spreadsheet from file.
   146|      *
   147|      * @param int $flags the optional second parameter flags may be used to identify specific elements
   148|      *                       that should be loaded, but which won't be loaded by default, using these values:
   149|      *                            IReader::LOAD_WITH_CHARTS - Include any charts that are defined in the loaded file
   150|      */
   151|     public function load(string $filename, int $flags = 0): Spreadsheet
   152|     {
   153|         $this->processFlags($flags);
   154|         try {
   155|             return $this->loadSpreadsheetFromFile($filename);
   156|         } catch (ReaderException $e) {
   157|             throw $e;
   158|         }
   159|     }
   160|     /**
   161|      * Open file for reading.
   162|      */
   163|     protected function openFile(string $filename): void
   164|     {
   165|         $fileHandle = false;
   166|         if ($filename) {
   167|             File::assertFile($filename);
   168|             $fileHandle = fopen($filename, 'rb');
   169|         }
   170|         if ($fileHandle === false) {
   171|             throw new ReaderException('Could not open file ' . $filename . ' for reading.');
   172|         }
   173|         $this->fileHandle = $fileHandle;
   174|     }
   175|     /**
   176|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   177|      */
   178|     public function listWorksheetInfo(string $filename): array
   179|     {
   180|         throw new PhpSpreadsheetException('Reader classes must implement their own listWorksheetInfo() method');
   181|     }
   182|     /**
   183|      * Returns names of the worksheets from a file,
   184|      * possibly without parsing the whole file to a Spreadsheet object.
   185|      * Readers will often have a more efficient method with which
   186|      * they can override this method.
   187|      */
   188|     public function listWorksheetNames(string $filename): array
   189|     {
   190|         $returnArray = [];
   191|         $info = $this->listWorksheetInfo($filename);
   192|         foreach ($info as $infoArray) {
   193|             if (isset($infoArray['worksheetName'])) {
   194|                 $returnArray[] = $infoArray['worksheetName'];
   195|             }
   196|         }
   197|         return $returnArray;
   198|     }
   199| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Csv.php
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 35-76 ---
    35|      */
    36|     private string $fallbackEncoding = self::DEFAULT_FALLBACK_ENCODING;
    37|     /**
    38|      * Delimiter.
    39|      */
    40|     private ?string $delimiter = null;
    41|     /**
    42|      * Enclosure.
    43|      */
    44|     private string $enclosure = '"';
    45|     /**
    46|      * Sheet index to read.
    47|      */
    48|     private int $sheetIndex = 0;
    49|     /**
    50|      * Load rows contiguously.
    51|      */
    52|     private bool $contiguous = false;
    53|     /**
    54|      * The character that can escape the enclosure.
    55|      */
    56|     private string $escapeCharacter = '\\';
    57|     /**
    58|      * Callback for setting defaults in construction.
    59|      *
    60|      * @var ?callable
    61|      */
    62|     private static $constructorCallback;
    63|     /**
    64|      * Attempt autodetect line endings (deprecated after PHP8.1)?
    65|      */
    66|     private bool $testAutodetect = true;
    67|     protected bool $castFormattedNumberToNumeric = false;
    68|     protected bool $preserveNumericFormatting = false;
    69|     private bool $preserveNullString = false;
    70|     private bool $sheetNameIsFileName = false;
    71|     private string $getTrue = 'true';
    72|     private string $getFalse = 'false';
    73|     private string $thousandsSeparator = ',';
    74|     private string $decimalSeparator = '.';
    75|     /**
    76|      * Create a new CSV Reader instance.

# --- HUNK 2: Lines 131-204 ---
   131|     protected function checkSeparator(): void
   132|     {
   133|         $line = fgets($this->fileHandle);
   134|         if ($line === false) {
   135|             return;
   136|         }
   137|         if ((strlen(trim($line, "\r\n")) == 5) && (stripos($line, 'sep=') === 0)) {
   138|             $this->delimiter = substr($line, 4, 1);
   139|             return;
   140|         }
   141|         $this->skipBOM();
   142|     }
   143|     /**
   144|      * Infer the separator if it isn't explicitly set in the file or specified by the user.
   145|      */
   146|     protected function inferSeparator(): void
   147|     {
   148|         if ($this->delimiter !== null) {
   149|             return;
   150|         }
   151|         $inferenceEngine = new Delimiter($this->fileHandle, $this->escapeCharacter, $this->enclosure);
   152|         if ($inferenceEngine->linesCounted() === 0) {
   153|             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
   154|             $this->skipBOM();
   155|             return;
   156|         }
   157|         $this->delimiter = $inferenceEngine->infer();
   158|         if ($this->delimiter === null) {
   159|             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
   160|         }
   161|         $this->skipBOM();
   162|     }
   163|     /**
   164|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   165|      */
   166|     public function listWorksheetInfo(string $filename): array
   167|     {
   168|         $this->openFileOrMemory($filename);
   169|         $fileHandle = $this->fileHandle;
   170|         $this->skipBOM();
   171|         $this->checkSeparator();
   172|         $this->inferSeparator();
   173|         $worksheetInfo = [];
   174|         $worksheetInfo[0]['worksheetName'] = 'Worksheet';
   175|         $worksheetInfo[0]['lastColumnLetter'] = 'A';
   176|         $worksheetInfo[0]['lastColumnIndex'] = 0;
   177|         $worksheetInfo[0]['totalRows'] = 0;
   178|         $worksheetInfo[0]['totalColumns'] = 0;
   179|         $delimiter = $this->delimiter ?? '';
   180|         $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   181|         while (is_array($rowData)) {
   182|             ++$worksheetInfo[0]['totalRows'];
   183|             $worksheetInfo[0]['lastColumnIndex'] = max($worksheetInfo[0]['lastColumnIndex'], count($rowData) - 1);
   184|             $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   185|         }
   186|         $worksheetInfo[0]['lastColumnLetter'] = Coordinate::stringFromColumnIndex($worksheetInfo[0]['lastColumnIndex'] + 1);
   187|         $worksheetInfo[0]['totalColumns'] = $worksheetInfo[0]['lastColumnIndex'] + 1;
   188|         fclose($fileHandle);
   189|         return $worksheetInfo;
   190|     }
   191|     /**
   192|      * Loads Spreadsheet from file.
   193|      */
   194|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   195|     {
   196|         $spreadsheet = new Spreadsheet();
   197|         return $this->loadIntoExisting($filename, $spreadsheet);
   198|     }
   199|     /**
   200|      * Loads Spreadsheet from string.
   201|      */
   202|     public function loadSpreadsheetFromString(string $contents): Spreadsheet
   203|     {
   204|         $spreadsheet = new Spreadsheet();

# --- HUNK 3: Lines 275-350 ---
   275|         $iniset = $this->setAutoDetect('1');
   276|         if ($dataUri) {
   277|             $this->openDataUri($filename);
   278|         } else {
   279|             $this->openFileOrMemory($filename);
   280|         }
   281|         $fileHandle = $this->fileHandle;
   282|         $this->skipBOM();
   283|         $this->checkSeparator();
   284|         $this->inferSeparator();
   285|         while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
   286|             $spreadsheet->createSheet();
   287|         }
   288|         $sheet = $spreadsheet->setActiveSheetIndex($this->sheetIndex);
   289|         if ($this->sheetNameIsFileName) {
   290|             $sheet->setTitle(substr(basename($filename, '.csv'), 0, Worksheet::SHEET_TITLE_MAXIMUM_LENGTH));
   291|         }
   292|         $currentRow = 1;
   293|         $outRow = 0;
   294|         $delimiter = $this->delimiter ?? '';
   295|         $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   296|         $valueBinder = Cell::getValueBinder();
   297|         $preserveBooleanString = method_exists($valueBinder, 'getBooleanConversion') && $valueBinder->getBooleanConversion();
   298|         $this->getTrue = Calculation::getTRUE();
   299|         $this->getFalse = Calculation::getFALSE();
   300|         $this->thousandsSeparator = StringHelper::getThousandsSeparator();
   301|         $this->decimalSeparator = StringHelper::getDecimalSeparator();
   302|         while (is_array($rowData)) {
   303|             $noOutputYet = true;
   304|             $columnLetter = 'A';
   305|             foreach ($rowData as $rowDatum) {
   306|                 if ($preserveBooleanString) {
   307|                     $rowDatum = $rowDatum ?? '';
   308|                 } else {
   309|                     $this->convertBoolean($rowDatum);
   310|                 }
   311|                 $numberFormatMask = $this->castFormattedNumberToNumeric ? $this->convertFormattedNumber($rowDatum) : '';
   312|                 if (($rowDatum !== '' || $this->preserveNullString) && $this->readFilter->readCell($columnLetter, $currentRow)) {
   313|                     if ($this->contiguous) {
   314|                         if ($noOutputYet) {
   315|                             $noOutputYet = false;
   316|                             ++$outRow;
   317|                         }
   318|                     } else {
   319|                         $outRow = $currentRow;
   320|                     }
   321|                     if ($numberFormatMask !== '') {
   322|                         $sheet->getStyle($columnLetter . $outRow)
   323|                             ->getNumberFormat()
   324|                             ->setFormatCode($numberFormatMask);
   325|                     }
   326|                     $sheet->getCell($columnLetter . $outRow)->setValue($rowDatum);
   327|                 }
   328|                 ++$columnLetter;
   329|             }
   330|             $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   331|             ++$currentRow;
   332|         }
   333|         fclose($fileHandle);
   334|         $this->setAutoDetect($iniset);
   335|         return $spreadsheet;
   336|     }
   337|     /**
   338|      * Convert string true/false to boolean, and null to null-string.
   339|      */
   340|     private function convertBoolean(mixed &$rowDatum): void
   341|     {
   342|         if (is_string($rowDatum)) {
   343|             if (strcasecmp($this->getTrue, $rowDatum) === 0 || strcasecmp('true', $rowDatum) === 0) {
   344|                 $rowDatum = true;
   345|             } elseif (strcasecmp($this->getFalse, $rowDatum) === 0 || strcasecmp('false', $rowDatum) === 0) {
   346|                 $rowDatum = false;
   347|             }
   348|         } else {
   349|             $rowDatum = $rowDatum ?? '';
   350|         }

# --- HUNK 4: Lines 398-445 ---
   398|         return $this;
   399|     }
   400|     public function getSheetIndex(): int
   401|     {
   402|         return $this->sheetIndex;
   403|     }
   404|     public function setSheetIndex(int $indexValue): self
   405|     {
   406|         $this->sheetIndex = $indexValue;
   407|         return $this;
   408|     }
   409|     public function setContiguous(bool $contiguous): self
   410|     {
   411|         $this->contiguous = $contiguous;
   412|         return $this;
   413|     }
   414|     public function getContiguous(): bool
   415|     {
   416|         return $this->contiguous;
   417|     }
   418|     public function setEscapeCharacter(string $escapeCharacter): self
   419|     {
   420|         $this->escapeCharacter = $escapeCharacter;
   421|         return $this;
   422|     }
   423|     public function getEscapeCharacter(): string
   424|     {
   425|         return $this->escapeCharacter;
   426|     }
   427|     /**
   428|      * Can the current IReader read the file?
   429|      */
   430|     public function canRead(string $filename): bool
   431|     {
   432|         try {
   433|             $this->openFile($filename);
   434|         } catch (ReaderException) {
   435|             return false;
   436|         }
   437|         fclose($this->fileHandle);
   438|         $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
   439|         if (in_array($extension, ['csv', 'tsv'])) {
   440|             return true;
   441|         }
   442|         $type = mime_content_type($filename);
   443|         $supportedTypes = [
   444|             'application/csv',
   445|             'text/csv',

# --- HUNK 5: Lines 497-517 ---
   497|         $encoding = self::guessEncodingBom($filename);
   498|         if ($encoding === '') {
   499|             $encoding = self::guessEncodingNoBom($filename);
   500|         }
   501|         return ($encoding === '') ? $dflt : $encoding;
   502|     }
   503|     public function setPreserveNullString(bool $value): self
   504|     {
   505|         $this->preserveNullString = $value;
   506|         return $this;
   507|     }
   508|     public function getPreserveNullString(): bool
   509|     {
   510|         return $this->preserveNullString;
   511|     }
   512|     public function setSheetNameIsFileName(bool $sheetNameIsFileName): self
   513|     {
   514|         $this->sheetNameIsFileName = $sheetNameIsFileName;
   515|         return $this;
   516|     }
   517| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Html.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-945 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use DOMAttr;
     4| use DOMDocument;
     5| use DOMElement;
     6| use DOMNode;
     7| use DOMText;
     8| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     9| use PhpOffice\PhpSpreadsheet\Cell\DataType;
    10| use PhpOffice\PhpSpreadsheet\Comment;
    11| use PhpOffice\PhpSpreadsheet\Document\Properties;
    12| use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
    13| use PhpOffice\PhpSpreadsheet\Helper\Dimension as CssDimension;
    14| use PhpOffice\PhpSpreadsheet\Helper\Html as HelperHtml;
    15| use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
    16| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    17| use PhpOffice\PhpSpreadsheet\Style\Border;
    18| use PhpOffice\PhpSpreadsheet\Style\Color;
    19| use PhpOffice\PhpSpreadsheet\Style\Fill;
    20| use PhpOffice\PhpSpreadsheet\Style\Font;
    21| use PhpOffice\PhpSpreadsheet\Style\Style;
    22| use PhpOffice\PhpSpreadsheet\Worksheet\Drawing;
    23| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    24| use Throwable;
    25| class Html extends BaseReader
    26| {
    27|     /**
    28|      * Sample size to read to determine if it's HTML or not.
    29|      */
    30|     const TEST_SAMPLE_SIZE = 2048;
    31|     private const STARTS_WITH_BOM = '/^(?:\xfe\xff|\xff\xfe|\xEF\xBB\xBF)/';
    32|     private const DECLARES_CHARSET = '/ charset=/i';
    33|     /**
    34|      * Input encoding.
    35|      */
    36|     protected string $inputEncoding = 'ANSI';
    37|     /**
    38|      * Sheet index to read.
    39|      */
    40|     protected int $sheetIndex = 0;
    41|     /**
    42|      * Formats.
    43|      */
    44|     protected array $formats = [
    45|         'h1' => [
    46|             'font' => [
    47|                 'bold' => true,
    48|                 'size' => 24,
    49|             ],
    50|         ], //    Bold, 24pt
    51|         'h2' => [
    52|             'font' => [
    53|                 'bold' => true,
    54|                 'size' => 18,
    55|             ],
    56|         ], //    Bold, 18pt
    57|         'h3' => [
    58|             'font' => [
    59|                 'bold' => true,
    60|                 'size' => 13.5,
    61|             ],
    62|         ], //    Bold, 13.5pt
    63|         'h4' => [
    64|             'font' => [
    65|                 'bold' => true,
    66|                 'size' => 12,
    67|             ],
    68|         ], //    Bold, 12pt
    69|         'h5' => [
    70|             'font' => [
    71|                 'bold' => true,
    72|                 'size' => 10,
    73|             ],
    74|         ], //    Bold, 10pt
    75|         'h6' => [
    76|             'font' => [
    77|                 'bold' => true,
    78|                 'size' => 7.5,
    79|             ],
    80|         ], //    Bold, 7.5pt
    81|         'a' => [
    82|             'font' => [
    83|                 'underline' => true,
    84|                 'color' => [
    85|                     'argb' => Color::COLOR_BLUE,
    86|                 ],
    87|             ],
    88|         ], //    Blue underlined
    89|         'hr' => [
    90|             'borders' => [
    91|                 'bottom' => [
    92|                     'borderStyle' => Border::BORDER_THIN,
    93|                     'color' => [
    94|                         Color::COLOR_BLACK,
    95|                     ],
    96|                 ],
    97|             ],
    98|         ], //    Bottom border
    99|         'strong' => [
   100|             'font' => [
   101|                 'bold' => true,
   102|             ],
   103|         ], //    Bold
   104|         'b' => [
   105|             'font' => [
   106|                 'bold' => true,
   107|             ],
   108|         ], //    Bold
   109|         'i' => [
   110|             'font' => [
   111|                 'italic' => true,
   112|             ],
   113|         ], //    Italic
   114|         'em' => [
   115|             'font' => [
   116|                 'italic' => true,
   117|             ],
   118|         ], //    Italic
   119|     ];
   120|     protected array $rowspan = [];
   121|     /**
   122|      * Create a new HTML Reader instance.
   123|      */
   124|     public function __construct()
   125|     {
   126|         parent::__construct();
   127|         $this->securityScanner = XmlScanner::getInstance($this);
   128|     }
   129|     /**
   130|      * Validate that the current file is an HTML file.
   131|      */
   132|     public function canRead(string $filename): bool
   133|     {
   134|         try {
   135|             $this->openFile($filename);
   136|         } catch (Exception) {
   137|             return false;
   138|         }
   139|         $beginning = preg_replace(self::STARTS_WITH_BOM, '', $this->readBeginning()) ?? '';
   140|         $startWithTag = self::startsWithTag($beginning);
   141|         $containsTags = self::containsTags($beginning);
   142|         $endsWithTag = self::endsWithTag($this->readEnding());
   143|         fclose($this->fileHandle);
   144|         return $startWithTag && $containsTags && $endsWithTag;
   145|     }
   146|     private function readBeginning(): string
   147|     {
   148|         fseek($this->fileHandle, 0);
   149|         return (string) fread($this->fileHandle, self::TEST_SAMPLE_SIZE);
   150|     }
   151|     private function readEnding(): string
   152|     {
   153|         $meta = stream_get_meta_data($this->fileHandle);
   154|         $filename = $meta['uri']; //@phpstan-ignore-line
   155|         $size = (int) filesize($filename);
   156|         if ($size === 0) {
   157|             return '';
   158|         }
   159|         $blockSize = self::TEST_SAMPLE_SIZE;
   160|         if ($size < $blockSize) {
   161|             $blockSize = $size;
   162|         }
   163|         fseek($this->fileHandle, $size - $blockSize);
   164|         return (string) fread($this->fileHandle, $blockSize);
   165|     }
   166|     private static function startsWithTag(string $data): bool
   167|     {
   168|         return str_starts_with(trim($data), '<');
   169|     }
   170|     private static function endsWithTag(string $data): bool
   171|     {
   172|         return str_ends_with(trim($data), '>');
   173|     }
   174|     private static function containsTags(string $data): bool
   175|     {
   176|         return strlen($data) !== strlen(strip_tags($data));
   177|     }
   178|     /**
   179|      * Loads Spreadsheet from file.
   180|      */
   181|     public function loadSpreadsheetFromFile(string $filename): Spreadsheet
   182|     {
   183|         $spreadsheet = new Spreadsheet();
   184|         return $this->loadIntoExisting($filename, $spreadsheet);
   185|     }
   186|     protected array $dataArray = [];
   187|     protected int $tableLevel = 0;
   188|     protected array $nestedColumn = ['A'];
   189|     protected function setTableStartColumn(string $column): string
   190|     {
   191|         if ($this->tableLevel == 0) {
   192|             $column = 'A';
   193|         }
   194|         ++$this->tableLevel;
   195|         $this->nestedColumn[$this->tableLevel] = $column;
   196|         return $this->nestedColumn[$this->tableLevel];
   197|     }
   198|     protected function getTableStartColumn(): string
   199|     {
   200|         return $this->nestedColumn[$this->tableLevel];
   201|     }
   202|     protected function releaseTableStartColumn(): string
   203|     {
   204|         --$this->tableLevel;
   205|         return array_pop($this->nestedColumn);
   206|     }
   207|     /**
   208|      * Flush cell.
   209|      */
   210|     protected function flushCell(Worksheet $sheet, string $column, int|string $row, mixed &$cellContent, array $attributeArray): void
   211|     {
   212|         if (is_string($cellContent)) {
   213|             if (trim($cellContent) > '') {
   214|                 if (isset($attributeArray['data-type'])) {
   215|                     $datatype = $attributeArray['data-type'];
   216|                     if (in_array($datatype, [DataType::TYPE_STRING, DataType::TYPE_STRING2, DataType::TYPE_INLINE])) {
   217|                         if (str_starts_with($cellContent, '=')) {
   218|                             $sheet->getCell($column . $row)
   219|                                 ->getStyle()
   220|                                 ->setQuotePrefix(true);
   221|                         }
   222|                     }
   223|                     try {
   224|                         $sheet->setCellValueExplicit($column . $row, $cellContent, $attributeArray['data-type']);
   225|                     } catch (SpreadsheetException) {
   226|                         $sheet->setCellValue($column . $row, $cellContent);
   227|                     }
   228|                 } else {
   229|                     $sheet->setCellValue($column . $row, $cellContent);
   230|                 }
   231|                 $this->dataArray[$row][$column] = $cellContent;
   232|             }
   233|         } else {
   234|             $this->dataArray[$row][$column] = 'RICH TEXT: ' . $cellContent;
   235|         }
   236|         $cellContent = (string) '';
   237|     }
   238|     private function processDomElementBody(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child): void
   239|     {
   240|         $attributeArray = [];
   241|         /** @var DOMAttr $attribute */
   242|         foreach ($child->attributes as $attribute) {
   243|             $attributeArray[$attribute->name] = $attribute->value;
   244|         }
   245|         if ($child->nodeName === 'body') {
   246|             $row = 1;
   247|             $column = 'A';
   248|             $cellContent = '';
   249|             $this->tableLevel = 0;
   250|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   251|         } else {
   252|             $this->processDomElementTitle($sheet, $row, $column, $cellContent, $child, $attributeArray);
   253|         }
   254|     }
   255|     private function processDomElementTitle(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   256|     {
   257|         if ($child->nodeName === 'title') {
   258|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   259|             try {
   260|                 $sheet->setTitle($cellContent, true, true);
   261|             } catch (SpreadsheetException) {
   262|             }
   263|             $cellContent = '';
   264|         } else {
   265|             $this->processDomElementSpanEtc($sheet, $row, $column, $cellContent, $child, $attributeArray);
   266|         }
   267|     }
   268|     private const SPAN_ETC = ['span', 'div', 'font', 'i', 'em', 'strong', 'b'];
   269|     private function processDomElementSpanEtc(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   270|     {
   271|         if (in_array((string) $child->nodeName, self::SPAN_ETC, true)) {
   272|             if (isset($attributeArray['class']) && $attributeArray['class'] === 'comment') {
   273|                 $sheet->getComment($column . $row)
   274|                     ->getText()
   275|                     ->createTextRun($child->textContent);
   276|                 if (isset($attributeArray['dir']) && $attributeArray['dir'] === 'rtl') {
   277|                     $sheet->getComment($column . $row)->setTextboxDirection(Comment::TEXTBOX_DIRECTION_RTL);
   278|                 }
   279|                 if (isset($attributeArray['style'])) {
   280|                     $alignStyle = $attributeArray['style'];
   281|                     if (preg_match('/\\btext-align:\\s*(left|right|center|justify)\\b/', $alignStyle, $matches) === 1) {
   282|                         $sheet->getComment($column . $row)->setAlignment($matches[1]);
   283|                     }
   284|                 }
   285|             } else {
   286|                 $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   287|             }
   288|             if (isset($this->formats[$child->nodeName])) {
   289|                 $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
   290|             }
   291|         } else {
   292|             $this->processDomElementHr($sheet, $row, $column, $cellContent, $child, $attributeArray);
   293|         }
   294|     }
   295|     private function processDomElementHr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   296|     {
   297|         if ($child->nodeName === 'hr') {
   298|             $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   299|             ++$row;
   300|             if (isset($this->formats[$child->nodeName])) {
   301|                 $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
   302|             }
   303|             ++$row;
   304|         }
   305|         $this->processDomElementBr($sheet, $row, $column, $cellContent, $child, $attributeArray);
   306|     }
   307|     private function processDomElementBr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   308|     {
   309|         if ($child->nodeName === 'br' || $child->nodeName === 'hr') {
   310|             if ($this->tableLevel > 0) {
   311|                 $cellContent .= "\n";
   312|                 $sheet->getStyle($column . $row)->getAlignment()->setWrapText(true);
   313|             } else {
   314|                 $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   315|                 ++$row;
   316|             }
   317|         } else {
   318|             $this->processDomElementA($sheet, $row, $column, $cellContent, $child, $attributeArray);
   319|         }
   320|     }
   321|     private function processDomElementA(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   322|     {
   323|         if ($child->nodeName === 'a') {
   324|             foreach ($attributeArray as $attributeName => $attributeValue) {
   325|                 switch ($attributeName) {
   326|                     case 'href':
   327|                         $sheet->getCell($column . $row)->getHyperlink()->setUrl($attributeValue);
   328|                         if (isset($this->formats[$child->nodeName])) {
   329|                             $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
   330|                         }
   331|                         break;
   332|                     case 'class':
   333|                         if ($attributeValue === 'comment-indicator') {
   334|                             break; // Ignore - it's just a red square.
   335|                         }
   336|                 }
   337|             }
   338|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   339|         } else {
   340|             $this->processDomElementH1Etc($sheet, $row, $column, $cellContent, $child, $attributeArray);
   341|         }
   342|     }
   343|     private const H1_ETC = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'p'];
   344|     private function processDomElementH1Etc(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   345|     {
   346|         if (in_array((string) $child->nodeName, self::H1_ETC, true)) {
   347|             if ($this->tableLevel > 0) {
   348|                 $cellContent .= $cellContent ? "\n" : '';
   349|                 $sheet->getStyle($column . $row)->getAlignment()->setWrapText(true);
   350|                 $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   351|             } else {
   352|                 if ($cellContent > '') {
   353|                     $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   354|                     ++$row;
   355|                 }
   356|                 $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   357|                 $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   358|                 if (isset($this->formats[$child->nodeName])) {
   359|                     $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
   360|                 }
   361|                 ++$row;
   362|                 $column = 'A';
   363|             }
   364|         } else {
   365|             $this->processDomElementLi($sheet, $row, $column, $cellContent, $child, $attributeArray);
   366|         }
   367|     }
   368|     private function processDomElementLi(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   369|     {
   370|         if ($child->nodeName === 'li') {
   371|             if ($this->tableLevel > 0) {
   372|                 $cellContent .= $cellContent ? "\n" : '';
   373|                 $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   374|             } else {
   375|                 if ($cellContent > '') {
   376|                     $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   377|                 }
   378|                 ++$row;
   379|                 $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   380|                 $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   381|                 $column = 'A';
   382|             }
   383|         } else {
   384|             $this->processDomElementImg($sheet, $row, $column, $cellContent, $child, $attributeArray);
   385|         }
   386|     }
   387|     private function processDomElementImg(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   388|     {
   389|         if ($child->nodeName === 'img') {
   390|             $this->insertImage($sheet, $column, $row, $attributeArray);
   391|         } else {
   392|             $this->processDomElementTable($sheet, $row, $column, $cellContent, $child, $attributeArray);
   393|         }
   394|     }
   395|     private string $currentColumn = 'A';
   396|     private function processDomElementTable(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   397|     {
   398|         if ($child->nodeName === 'table') {
   399|             $this->currentColumn = 'A';
   400|             $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   401|             $column = $this->setTableStartColumn($column);
   402|             if ($this->tableLevel > 1 && $row > 1) {
   403|                 --$row;
   404|             }
   405|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   406|             $column = $this->releaseTableStartColumn();
   407|             if ($this->tableLevel > 1) {
   408|                 ++$column;
   409|             } else {
   410|                 ++$row;
   411|             }
   412|         } else {
   413|             $this->processDomElementTr($sheet, $row, $column, $cellContent, $child, $attributeArray);
   414|         }
   415|     }
   416|     private function processDomElementTr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   417|     {
   418|         if ($child->nodeName === 'col') {
   419|             $this->applyInlineStyle($sheet, -1, $this->currentColumn, $attributeArray);
   420|             ++$this->currentColumn;
   421|         } elseif ($child->nodeName === 'tr') {
   422|             $column = $this->getTableStartColumn();
   423|             $cellContent = '';
   424|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   425|             if (isset($attributeArray['height'])) {
   426|                 $sheet->getRowDimension($row)->setRowHeight($attributeArray['height']);
   427|             }
   428|             ++$row;
   429|         } else {
   430|             $this->processDomElementThTdOther($sheet, $row, $column, $cellContent, $child, $attributeArray);
   431|         }
   432|     }
   433|     private function processDomElementThTdOther(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   434|     {
   435|         if ($child->nodeName !== 'td' && $child->nodeName !== 'th') {
   436|             $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   437|         } else {
   438|             $this->processDomElementThTd($sheet, $row, $column, $cellContent, $child, $attributeArray);
   439|         }
   440|     }
   441|     private function processDomElementBgcolor(Worksheet $sheet, int $row, string $column, array $attributeArray): void
   442|     {
   443|         if (isset($attributeArray['bgcolor'])) {
   444|             $sheet->getStyle("$column$row")->applyFromArray(
   445|                 [
   446|                     'fill' => [
   447|                         'fillType' => Fill::FILL_SOLID,
   448|                         'color' => ['rgb' => $this->getStyleColor($attributeArray['bgcolor'])],
   449|                     ],
   450|                 ]
   451|             );
   452|         }
   453|     }
   454|     private function processDomElementWidth(Worksheet $sheet, string $column, array $attributeArray): void
   455|     {
   456|         if (isset($attributeArray['width'])) {
   457|             $sheet->getColumnDimension($column)->setWidth((new CssDimension($attributeArray['width']))->width());
   458|         }
   459|     }
   460|     private function processDomElementHeight(Worksheet $sheet, int $row, array $attributeArray): void
   461|     {
   462|         if (isset($attributeArray['height'])) {
   463|             $sheet->getRowDimension($row)->setRowHeight((new CssDimension($attributeArray['height']))->height());
   464|         }
   465|     }
   466|     private function processDomElementAlign(Worksheet $sheet, int $row, string $column, array $attributeArray): void
   467|     {
   468|         if (isset($attributeArray['align'])) {
   469|             $sheet->getStyle($column . $row)->getAlignment()->setHorizontal($attributeArray['align']);
   470|         }
   471|     }
   472|     private function processDomElementVAlign(Worksheet $sheet, int $row, string $column, array $attributeArray): void
   473|     {
   474|         if (isset($attributeArray['valign'])) {
   475|             $sheet->getStyle($column . $row)->getAlignment()->setVertical($attributeArray['valign']);
   476|         }
   477|     }
   478|     private function processDomElementDataFormat(Worksheet $sheet, int $row, string $column, array $attributeArray): void
   479|     {
   480|         if (isset($attributeArray['data-format'])) {
   481|             $sheet->getStyle($column . $row)->getNumberFormat()->setFormatCode($attributeArray['data-format']);
   482|         }
   483|     }
   484|     private function processDomElementThTd(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
   485|     {
   486|         while (isset($this->rowspan[$column . $row])) {
   487|             ++$column;
   488|         }
   489|         $this->processDomElement($child, $sheet, $row, $column, $cellContent);
   490|         $this->applyInlineStyle($sheet, $row, $column, $attributeArray);
   491|         $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
   492|         $this->processDomElementBgcolor($sheet, $row, $column, $attributeArray);
   493|         $this->processDomElementWidth($sheet, $column, $attributeArray);
   494|         $this->processDomElementHeight($sheet, $row, $attributeArray);
   495|         $this->processDomElementAlign($sheet, $row, $column, $attributeArray);
   496|         $this->processDomElementVAlign($sheet, $row, $column, $attributeArray);
   497|         $this->processDomElementDataFormat($sheet, $row, $column, $attributeArray);
   498|         if (isset($attributeArray['rowspan'], $attributeArray['colspan'])) {
   499|             $columnTo = $column;
   500|             for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
   501|                 ++$columnTo;
   502|             }
   503|             $range = $column . $row . ':' . $columnTo . ($row + (int) $attributeArray['rowspan'] - 1);
   504|             foreach (Coordinate::extractAllCellReferencesInRange($range) as $value) {
   505|                 $this->rowspan[$value] = true;
   506|             }
   507|             $sheet->mergeCells($range);
   508|             $column = $columnTo;
   509|         } elseif (isset($attributeArray['rowspan'])) {
   510|             $range = $column . $row . ':' . $column . ($row + (int) $attributeArray['rowspan'] - 1);
   511|             foreach (Coordinate::extractAllCellReferencesInRange($range) as $value) {
   512|                 $this->rowspan[$value] = true;
   513|             }
   514|             $sheet->mergeCells($range);
   515|         } elseif (isset($attributeArray['colspan'])) {
   516|             $columnTo = $column;
   517|             for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
   518|                 ++$columnTo;
   519|             }
   520|             $sheet->mergeCells($column . $row . ':' . $columnTo . $row);
   521|             $column = $columnTo;
   522|         }
   523|         ++$column;
   524|     }
   525|     protected function processDomElement(DOMNode $element, Worksheet $sheet, int &$row, string &$column, string &$cellContent): void
   526|     {
   527|         foreach ($element->childNodes as $child) {
   528|             if ($child instanceof DOMText) {
   529|                 $domText = (string) preg_replace('/\s+/u', ' ', trim($child->nodeValue ?? ''));
   530|                 if (is_string($cellContent)) {
   531|                     $cellContent .= $domText;
   532|                 }
   533|             } elseif ($child instanceof DOMElement) {
   534|                 $this->processDomElementBody($sheet, $row, $column, $cellContent, $child);
   535|             }
   536|         }
   537|     }
   538|     /**
   539|      * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
   540|      */
   541|     public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
   542|     {
   543|         if (!$this->canRead($filename)) {
   544|             throw new Exception($filename . ' is an Invalid HTML file.');
   545|         }
   546|         $dom = new DOMDocument();
   547|         try {
   548|             $convert = $this->getSecurityScannerOrThrow()->scanFile($filename);
   549|             $convert = self::replaceNonAsciiIfNeeded($convert);
   550|             $loaded = ($convert === null) ? false : $dom->loadHTML($convert);
   551|         } catch (Throwable $e) {
   552|             $loaded = false;
   553|         }
   554|         if ($loaded === false) {
   555|             throw new Exception('Failed to load ' . $filename . ' as a DOM Document', 0, $e ?? null);
   556|         }
   557|         self::loadProperties($dom, $spreadsheet);
   558|         return $this->loadDocument($dom, $spreadsheet);
   559|     }
   560|     private static function loadProperties(DOMDocument $dom, Spreadsheet $spreadsheet): void
   561|     {
   562|         $properties = $spreadsheet->getProperties();
   563|         foreach ($dom->getElementsByTagName('meta') as $meta) {
   564|             $metaContent = (string) $meta->getAttribute('content');
   565|             if ($metaContent !== '') {
   566|                 $metaName = (string) $meta->getAttribute('name');
   567|                 switch ($metaName) {
   568|                     case 'author':
   569|                         $properties->setCreator($metaContent);
   570|                         break;
   571|                     case 'category':
   572|                         $properties->setCategory($metaContent);
   573|                         break;
   574|                     case 'company':
   575|                         $properties->setCompany($metaContent);
   576|                         break;
   577|                     case 'created':
   578|                         $properties->setCreated($metaContent);
   579|                         break;
   580|                     case 'description':
   581|                         $properties->setDescription($metaContent);
   582|                         break;
   583|                     case 'keywords':
   584|                         $properties->setKeywords($metaContent);
   585|                         break;
   586|                     case 'lastModifiedBy':
   587|                         $properties->setLastModifiedBy($metaContent);
   588|                         break;
   589|                     case 'manager':
   590|                         $properties->setManager($metaContent);
   591|                         break;
   592|                     case 'modified':
   593|                         $properties->setModified($metaContent);
   594|                         break;
   595|                     case 'subject':
   596|                         $properties->setSubject($metaContent);
   597|                         break;
   598|                     case 'title':
   599|                         $properties->setTitle($metaContent);
   600|                         break;
   601|                     case 'viewport':
   602|                         $properties->setViewport($metaContent);
   603|                         break;
   604|                     default:
   605|                         if (preg_match('/^custom[.](bool|date|float|int|string)[.](.+)$/', $metaName, $matches) === 1) {
   606|                             match ($matches[1]) {
   607|                                 'bool' => $properties->setCustomProperty($matches[2], (bool) $metaContent, Properties::PROPERTY_TYPE_BOOLEAN),
   608|                                 'float' => $properties->setCustomProperty($matches[2], (float) $metaContent, Properties::PROPERTY_TYPE_FLOAT),
   609|                                 'int' => $properties->setCustomProperty($matches[2], (int) $metaContent, Properties::PROPERTY_TYPE_INTEGER),
   610|                                 'date' => $properties->setCustomProperty($matches[2], $metaContent, Properties::PROPERTY_TYPE_DATE),
   611|                                 default => $properties->setCustomProperty($matches[2], $metaContent, Properties::PROPERTY_TYPE_STRING),
   612|                             };
   613|                         }
   614|                 }
   615|             }
   616|         }
   617|         if (!empty($dom->baseURI)) {
   618|             $properties->setHyperlinkBase($dom->baseURI);
   619|         }
   620|     }
   621|     private static function replaceNonAscii(array $matches): string
   622|     {
   623|         return '&#' . mb_ord($matches[0], 'UTF-8') . ';';
   624|     }
   625|     private static function replaceNonAsciiIfNeeded(string $convert): ?string
   626|     {
   627|         if (preg_match(self::STARTS_WITH_BOM, $convert) !== 1 && preg_match(self::DECLARES_CHARSET, $convert) !== 1) {
   628|             $lowend = "\u{80}";
   629|             $highend = "\u{10ffff}";
   630|             $regexp = "/[$lowend-$highend]/u";
   631|             /** @var callable $callback */
   632|             $callback = [self::class, 'replaceNonAscii'];
   633|             $convert = preg_replace_callback($regexp, $callback, $convert);
   634|         }
   635|         return $convert;
   636|     }
   637|     /**
   638|      * Spreadsheet from content.
   639|      */
   640|     public function loadFromString(string $content, ?Spreadsheet $spreadsheet = null): Spreadsheet
   641|     {
   642|         $dom = new DOMDocument();
   643|         try {
   644|             $convert = $this->getSecurityScannerOrThrow()->scan($content);
   645|             $convert = self::replaceNonAsciiIfNeeded($convert);
   646|             $loaded = ($convert === null) ? false : $dom->loadHTML($convert);
   647|         } catch (Throwable $e) {
   648|             $loaded = false;
   649|         }
   650|         if ($loaded === false) {
   651|             throw new Exception('Failed to load content as a DOM Document', 0, $e ?? null);
   652|         }
   653|         $spreadsheet = $spreadsheet ?? new Spreadsheet();
   654|         self::loadProperties($dom, $spreadsheet);
   655|         return $this->loadDocument($dom, $spreadsheet);
   656|     }
   657|     /**
   658|      * Loads PhpSpreadsheet from DOMDocument into PhpSpreadsheet instance.
   659|      */
   660|     private function loadDocument(DOMDocument $document, Spreadsheet $spreadsheet): Spreadsheet
   661|     {
   662|         while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
   663|             $spreadsheet->createSheet();
   664|         }
   665|         $spreadsheet->setActiveSheetIndex($this->sheetIndex);
   666|         $document->preserveWhiteSpace = false;
   667|         $row = 0;
   668|         $column = 'A';
   669|         $content = '';
   670|         $this->rowspan = [];
   671|         $this->processDomElement($document, $spreadsheet->getActiveSheet(), $row, $column, $content);
   672|         return $spreadsheet;
   673|     }
   674|     /**
   675|      * Get sheet index.
   676|      */
   677|     public function getSheetIndex(): int
   678|     {
   679|         return $this->sheetIndex;
   680|     }
   681|     /**
   682|      * Set sheet index.
   683|      *
   684|      * @param int $sheetIndex Sheet index
   685|      *
   686|      * @return $this
   687|      */
   688|     public function setSheetIndex(int $sheetIndex): static
   689|     {
   690|         $this->sheetIndex = $sheetIndex;
   691|         return $this;
   692|     }
   693|     /**
   694|      * Apply inline css inline style.
   695|      *
   696|      * NOTES :
   697|      * Currently only intended for td & th element,
   698|      * and only takes 'background-color' and 'color'; property with HEX color
   699|      *
   700|      * TODO :
   701|      * - Implement to other propertie, such as border
   702|      */
   703|     private function applyInlineStyle(Worksheet &$sheet, int $row, string $column, array $attributeArray): void
   704|     {
   705|         if (!isset($attributeArray['style'])) {
   706|             return;
   707|         }
   708|         if ($row <= 0 || $column === '') {
   709|             $cellStyle = new Style();
   710|         } elseif (isset($attributeArray['rowspan'], $attributeArray['colspan'])) {
   711|             $columnTo = $column;
   712|             for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
   713|                 ++$columnTo;
   714|             }
   715|             $range = $column . $row . ':' . $columnTo . ($row + (int) $attributeArray['rowspan'] - 1);
   716|             $cellStyle = $sheet->getStyle($range);
   717|         } elseif (isset($attributeArray['rowspan'])) {
   718|             $range = $column . $row . ':' . $column . ($row + (int) $attributeArray['rowspan'] - 1);
   719|             $cellStyle = $sheet->getStyle($range);
   720|         } elseif (isset($attributeArray['colspan'])) {
   721|             $columnTo = $column;
   722|             for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
   723|                 ++$columnTo;
   724|             }
   725|             $range = $column . $row . ':' . $columnTo . $row;
   726|             $cellStyle = $sheet->getStyle($range);
   727|         } else {
   728|             $cellStyle = $sheet->getStyle($column . $row);
   729|         }
   730|         $styles = explode(';', $attributeArray['style']);
   731|         foreach ($styles as $st) {
   732|             $value = explode(':', $st);
   733|             $styleName = isset($value[0]) ? trim($value[0]) : null;
   734|             $styleValue = isset($value[1]) ? trim($value[1]) : null;
   735|             $styleValueString = (string) $styleValue;
   736|             if (!$styleName) {
   737|                 continue;
   738|             }
   739|             switch ($styleName) {
   740|                 case 'background':
   741|                 case 'background-color':
   742|                     $styleColor = $this->getStyleColor($styleValueString);
   743|                     if (!$styleColor) {
   744|                         continue 2;
   745|                     }
   746|                     $cellStyle->applyFromArray(['fill' => ['fillType' => Fill::FILL_SOLID, 'color' => ['rgb' => $styleColor]]]);
   747|                     break;
   748|                 case 'color':
   749|                     $styleColor = $this->getStyleColor($styleValueString);
   750|                     if (!$styleColor) {
   751|                         continue 2;
   752|                     }
   753|                     $cellStyle->applyFromArray(['font' => ['color' => ['rgb' => $styleColor]]]);
   754|                     break;
   755|                 case 'border':
   756|                     $this->setBorderStyle($cellStyle, $styleValueString, 'allBorders');
   757|                     break;
   758|                 case 'border-top':
   759|                     $this->setBorderStyle($cellStyle, $styleValueString, 'top');
   760|                     break;
   761|                 case 'border-bottom':
   762|                     $this->setBorderStyle($cellStyle, $styleValueString, 'bottom');
   763|                     break;
   764|                 case 'border-left':
   765|                     $this->setBorderStyle($cellStyle, $styleValueString, 'left');
   766|                     break;
   767|                 case 'border-right':
   768|                     $this->setBorderStyle($cellStyle, $styleValueString, 'right');
   769|                     break;
   770|                 case 'font-size':
   771|                     $cellStyle->getFont()->setSize(
   772|                         (float) $styleValue
   773|                     );
   774|                     break;
   775|                 case 'font-weight':
   776|                     if ($styleValue === 'bold' || $styleValue >= 500) {
   777|                         $cellStyle->getFont()->setBold(true);
   778|                     }
   779|                     break;
   780|                 case 'font-style':
   781|                     if ($styleValue === 'italic') {
   782|                         $cellStyle->getFont()->setItalic(true);
   783|                     }
   784|                     break;
   785|                 case 'font-family':
   786|                     $cellStyle->getFont()->setName(str_replace('\'', '', $styleValueString));
   787|                     break;
   788|                 case 'text-decoration':
   789|                     switch ($styleValue) {
   790|                         case 'underline':
   791|                             $cellStyle->getFont()->setUnderline(Font::UNDERLINE_SINGLE);
   792|                             break;
   793|                         case 'line-through':
   794|                             $cellStyle->getFont()->setStrikethrough(true);
   795|                             break;
   796|                     }
   797|                     break;
   798|                 case 'text-align':
   799|                     $cellStyle->getAlignment()->setHorizontal($styleValueString);
   800|                     break;
   801|                 case 'vertical-align':
   802|                     $cellStyle->getAlignment()->setVertical($styleValueString);
   803|                     break;
   804|                 case 'width':
   805|                     if ($column !== '') {
   806|                         $sheet->getColumnDimension($column)->setWidth(
   807|                             (new CssDimension($styleValue ?? ''))->width()
   808|                         );
   809|                     }
   810|                     break;
   811|                 case 'height':
   812|                     if ($row > 0) {
   813|                         $sheet->getRowDimension($row)->setRowHeight(
   814|                             (new CssDimension($styleValue ?? ''))->height()
   815|                         );
   816|                     }
   817|                     break;
   818|                 case 'word-wrap':
   819|                     $cellStyle->getAlignment()->setWrapText(
   820|                         $styleValue === 'break-word'
   821|                     );
   822|                     break;
   823|                 case 'text-indent':
   824|                     $cellStyle->getAlignment()->setIndent(
   825|                         (int) str_replace(['px'], '', $styleValueString)
   826|                     );
   827|                     break;
   828|             }
   829|         }
   830|     }
   831|     /**
   832|      * Check if has #, so we can get clean hex.
   833|      */
   834|     public function getStyleColor(?string $value): string
   835|     {
   836|         $value = (string) $value;
   837|         if (str_starts_with($value, '#')) {
   838|             return substr($value, 1);
   839|         }
   840|         return HelperHtml::colourNameLookup($value);
   841|     }
   842|     private function insertImage(Worksheet $sheet, string $column, int $row, array $attributes): void
   843|     {
   844|         if (!isset($attributes['src'])) {
   845|             return;
   846|         }
   847|         $src = urldecode($attributes['src']);
   848|         $width = isset($attributes['width']) ? (float) $attributes['width'] : null;
   849|         $height = isset($attributes['height']) ? (float) $attributes['height'] : null;
   850|         $name = $attributes['alt'] ?? null;
   851|         $drawing = new Drawing();
   852|         $drawing->setPath($src);
   853|         $drawing->setWorksheet($sheet);
   854|         $drawing->setCoordinates($column . $row);
   855|         $drawing->setOffsetX(0);
   856|         $drawing->setOffsetY(10);
   857|         $drawing->setResizeProportional(true);
   858|         if ($name) {
   859|             $drawing->setName($name);
   860|         }
   861|         if ($width) {
   862|             $drawing->setWidth((int) $width);
   863|         }
   864|         if ($height) {
   865|             $drawing->setHeight((int) $height);
   866|         }
   867|         $sheet->getColumnDimension($column)->setWidth(
   868|             $drawing->getWidth() / 6
   869|         );
   870|         $sheet->getRowDimension($row)->setRowHeight(
   871|             $drawing->getHeight() * 0.9
   872|         );
   873|     }
   874|     private const BORDER_MAPPINGS = [
   875|         'dash-dot' => Border::BORDER_DASHDOT,
   876|         'dash-dot-dot' => Border::BORDER_DASHDOTDOT,
   877|         'dashed' => Border::BORDER_DASHED,
   878|         'dotted' => Border::BORDER_DOTTED,
   879|         'double' => Border::BORDER_DOUBLE,
   880|         'hair' => Border::BORDER_HAIR,
   881|         'medium' => Border::BORDER_MEDIUM,
   882|         'medium-dashed' => Border::BORDER_MEDIUMDASHED,
   883|         'medium-dash-dot' => Border::BORDER_MEDIUMDASHDOT,
   884|         'medium-dash-dot-dot' => Border::BORDER_MEDIUMDASHDOTDOT,
   885|         'none' => Border::BORDER_NONE,
   886|         'slant-dash-dot' => Border::BORDER_SLANTDASHDOT,
   887|         'solid' => Border::BORDER_THIN,
   888|         'thick' => Border::BORDER_THICK,
   889|     ];
   890|     public static function getBorderMappings(): array
   891|     {
   892|         return self::BORDER_MAPPINGS;
   893|     }
   894|     /**
   895|      * Map html border style to PhpSpreadsheet border style.
   896|      */
   897|     public function getBorderStyle(string $style): ?string
   898|     {
   899|         return self::BORDER_MAPPINGS[$style] ?? null;
   900|     }
   901|     private function setBorderStyle(Style $cellStyle, string $styleValue, string $type): void
   902|     {
   903|         if (trim($styleValue) === Border::BORDER_NONE) {
   904|             $borderStyle = Border::BORDER_NONE;
   905|             $color = null;
   906|         } else {
   907|             $borderArray = explode(' ', $styleValue);
   908|             $borderCount = count($borderArray);
   909|             if ($borderCount >= 3) {
   910|                 $borderStyle = $borderArray[1];
   911|                 $color = $borderArray[2];
   912|             } else {
   913|                 $borderStyle = $borderArray[0];
   914|                 $color = $borderArray[1] ?? null;
   915|             }
   916|         }
   917|         $cellStyle->applyFromArray([
   918|             'borders' => [
   919|                 $type => [
   920|                     'borderStyle' => $this->getBorderStyle($borderStyle),
   921|                     'color' => ['rgb' => $this->getStyleColor($color)],
   922|                 ],
   923|             ],
   924|         ]);
   925|     }
   926|     /**
   927|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   928|      */
   929|     public function listWorksheetInfo(string $filename): array
   930|     {
   931|         $info = [];
   932|         $spreadsheet = new Spreadsheet();
   933|         $this->loadIntoExisting($filename, $spreadsheet);
   934|         foreach ($spreadsheet->getAllSheets() as $sheet) {
   935|             $newEntry = ['worksheetName' => $sheet->getTitle()];
   936|             $newEntry['lastColumnLetter'] = $sheet->getHighestDataColumn();
   937|             $newEntry['lastColumnIndex'] = Coordinate::columnIndexFromString($sheet->getHighestDataColumn()) - 1;
   938|             $newEntry['totalRows'] = $sheet->getHighestDataRow();
   939|             $newEntry['totalColumns'] = $newEntry['lastColumnIndex'] + 1;
   940|             $info[] = $newEntry;
   941|         }
   942|         $spreadsheet->disconnectWorksheets();
   943|         return $info;
   944|     }
   945| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/IReader.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-106 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     4| interface IReader
     5| {
     6|     public const LOAD_WITH_CHARTS = 1;
     7|     public const READ_DATA_ONLY = 2;
     8|     public const SKIP_EMPTY_CELLS = 4;
     9|     public const IGNORE_EMPTY_CELLS = 4;
    10|     public const IGNORE_ROWS_WITH_NO_CELLS = 8;
    11|     public function __construct();
    12|     /**
    13|      * Can the current IReader read the file?
    14|      */
    15|     public function canRead(string $filename): bool;
    16|     /**
    17|      * Read data only?
    18|      *        If this is true, then the Reader will only read data values for cells, it will not read any formatting
    19|      *           or structural information (like merges).
    20|      *        If false (the default) it will read data and formatting.
    21|      */
    22|     public function getReadDataOnly(): bool;
    23|     /**
    24|      * Set read data only
    25|      *        Set to true, to advise the Reader only to read data values for cells, and to ignore any formatting
    26|      *            or structural information (like merges).
    27|      *        Set to false (the default) to advise the Reader to read both data and formatting for cells.
    28|      *
    29|      * @return $this
    30|      */
    31|     public function setReadDataOnly(bool $readDataOnly): self;
    32|     /**
    33|      * Read empty cells?
    34|      *        If this is true (the default), then the Reader will read data values for all cells, irrespective of value.
    35|      *        If false it will not read data for cells containing a null value or an empty string.
    36|      */
    37|     public function getReadEmptyCells(): bool;
    38|     /**
    39|      * Set read empty cells
    40|      *        Set to true (the default) to advise the Reader read data values for all cells, irrespective of value.
    41|      *        Set to false to advise the Reader to ignore cells containing a null value or an empty string.
    42|      *
    43|      * @return $this
    44|      */
    45|     public function setReadEmptyCells(bool $readEmptyCells): self;
    46|     /**
    47|      * Read charts in workbook?
    48|      *      If this is true, then the Reader will include any charts that exist in the workbook.
    49|      *         Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
    50|      *      If false (the default) it will ignore any charts defined in the workbook file.
    51|      */
    52|     public function getIncludeCharts(): bool;
    53|     /**
    54|      * Set read charts in workbook
    55|      *     Set to true, to advise the Reader to include any charts that exist in the workbook.
    56|      *         Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
    57|      *     Set to false (the default) to discard charts.
    58|      *
    59|      * @return $this
    60|      */
    61|     public function setIncludeCharts(bool $includeCharts): self;
    62|     /**
    63|      * Get which sheets to load
    64|      * Returns either an array of worksheet names (the list of worksheets that should be loaded), or a null
    65|      *        indicating that all worksheets in the workbook should be loaded.
    66|      */
    67|     public function getLoadSheetsOnly(): ?array;
    68|     /**
    69|      * Set which sheets to load.
    70|      *
    71|      * @param null|array|string $value This should be either an array of worksheet names to be loaded,
    72|      *          or a string containing a single worksheet name. If NULL, then it tells the Reader to
    73|      *          read all worksheets in the workbook
    74|      *
    75|      * @return $this
    76|      */
    77|     public function setLoadSheetsOnly(string|array|null $value): self;
    78|     /**
    79|      * Set all sheets to load
    80|      *        Tells the Reader to load all worksheets from the workbook.
    81|      *
    82|      * @return $this
    83|      */
    84|     public function setLoadAllSheets(): self;
    85|     /**
    86|      * Read filter.
    87|      */
    88|     public function getReadFilter(): IReadFilter;
    89|     /**
    90|      * Set read filter.
    91|      *
    92|      * @return $this
    93|      */
    94|     public function setReadFilter(IReadFilter $readFilter): self;
    95|     /**
    96|      * Loads PhpSpreadsheet from file.
    97|      *
    98|      * @param string $filename The name of the file to load
    99|      * @param int $flags Flags that can change the behaviour of the Writer:
   100|      *            self::LOAD_WITH_CHARTS    Load any charts that are defined (if the Reader supports Charts)
   101|      *            self::READ_DATA_ONLY      Read only data, not style or structure information, from the file
   102|      *            self::SKIP_EMPTY_CELLS    Don't read empty cells (cells that contain a null value,
   103|      *                                      empty string, or a string containing only whitespace characters)
   104|      */
   105|     public function load(string $filename, int $flags = 0): Spreadsheet;
   106| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Ods.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-649 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use DOMAttr;
     4| use DOMDocument;
     5| use DOMElement;
     6| use DOMNode;
     7| use DOMText;
     8| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     9| use PhpOffice\PhpSpreadsheet\Cell\DataType;
    10| use PhpOffice\PhpSpreadsheet\Helper\Dimension as HelperDimension;
    11| use PhpOffice\PhpSpreadsheet\Reader\Ods\AutoFilter;
    12| use PhpOffice\PhpSpreadsheet\Reader\Ods\DefinedNames;
    13| use PhpOffice\PhpSpreadsheet\Reader\Ods\FormulaTranslator;
    14| use PhpOffice\PhpSpreadsheet\Reader\Ods\PageSettings;
    15| use PhpOffice\PhpSpreadsheet\Reader\Ods\Properties as DocumentProperties;
    16| use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
    17| use PhpOffice\PhpSpreadsheet\RichText\RichText;
    18| use PhpOffice\PhpSpreadsheet\Settings;
    19| use PhpOffice\PhpSpreadsheet\Shared\Date;
    20| use PhpOffice\PhpSpreadsheet\Shared\File;
    21| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    22| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    23| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    24| use Throwable;
    25| use XMLReader;
    26| use ZipArchive;
    27| class Ods extends BaseReader
    28| {
    29|     const INITIAL_FILE = 'content.xml';
    30|     /**
    31|      * Create a new Ods Reader instance.
    32|      */
    33|     public function __construct()
    34|     {
    35|         parent::__construct();
    36|         $this->securityScanner = XmlScanner::getInstance($this);
    37|     }
    38|     /**
    39|      * Can the current IReader read the file?
    40|      */
    41|     public function canRead(string $filename): bool
    42|     {
    43|         $mimeType = 'UNKNOWN';
    44|         if (File::testFileNoThrow($filename, '')) {
    45|             $zip = new ZipArchive();
    46|             if ($zip->open($filename) === true) {
    47|                 $stat = $zip->statName('mimetype');
    48|                 if (!empty($stat) && ($stat['size'] <= 255)) {
    49|                     $mimeType = $zip->getFromName($stat['name']);
    50|                 } elseif ($zip->statName('META-INF/manifest.xml')) {
    51|                     $xml = simplexml_load_string(
    52|                         $this->getSecurityScannerOrThrow()->scan($zip->getFromName('META-INF/manifest.xml')),
    53|                         'SimpleXMLElement',
    54|                         Settings::getLibXmlLoaderOptions()
    55|                     );
    56|                     if ($xml !== false) {
    57|                         $namespacesContent = $xml->getNamespaces(true);
    58|                         if (isset($namespacesContent['manifest'])) {
    59|                             $manifest = $xml->children($namespacesContent['manifest']);
    60|                             foreach ($manifest as $manifestDataSet) {
    61|                                 $manifestAttributes = $manifestDataSet->attributes($namespacesContent['manifest']);
    62|                                 if ($manifestAttributes && $manifestAttributes->{'full-path'} == '/') {
    63|                                     $mimeType = (string) $manifestAttributes->{'media-type'};
    64|                                     break;
    65|                                 }
    66|                             }
    67|                         }
    68|                     }
    69|                 }
    70|                 $zip->close();
    71|             }
    72|         }
    73|         return $mimeType === 'application/vnd.oasis.opendocument.spreadsheet';
    74|     }
    75|     /**
    76|      * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
    77|      *
    78|      * @return string[]
    79|      */
    80|     public function listWorksheetNames(string $filename): array
    81|     {
    82|         File::assertFile($filename, self::INITIAL_FILE);
    83|         $worksheetNames = [];
    84|         $xml = new XMLReader();
    85|         $xml->xml(
    86|             $this->getSecurityScannerOrThrow()->scanFile('zip://' . realpath($filename) . '#' . self::INITIAL_FILE),
    87|             null,
    88|             Settings::getLibXmlLoaderOptions()
    89|         );
    90|         $xml->setParserProperty(2, true);
    91|         $xml->read();
    92|         while ($xml->read()) {
    93|             while (self::getXmlName($xml) !== 'office:body') {
    94|                 if ($xml->isEmptyElement) {
    95|                     $xml->read();
    96|                 } else {
    97|                     $xml->next();
    98|                 }
    99|             }
   100|             while ($xml->read()) {
   101|                 $xmlName = self::getXmlName($xml);
   102|                 if ($xmlName == 'table:table' && $xml->nodeType == XMLReader::ELEMENT) {
   103|                     do {
   104|                         $worksheetName = $xml->getAttribute('table:name');
   105|                         if (!empty($worksheetName)) {
   106|                             $worksheetNames[] = $worksheetName;
   107|                         }
   108|                         $xml->next();
   109|                     } while (self::getXmlName($xml) == 'table:table' && $xml->nodeType == XMLReader::ELEMENT);
   110|                 }
   111|             }
   112|         }
   113|         return $worksheetNames;
   114|     }
   115|     /**
   116|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   117|      */
   118|     public function listWorksheetInfo(string $filename): array
   119|     {
   120|         File::assertFile($filename, self::INITIAL_FILE);
   121|         $worksheetInfo = [];
   122|         $xml = new XMLReader();
   123|         $xml->xml(
   124|             $this->getSecurityScannerOrThrow()->scanFile('zip://' . realpath($filename) . '#' . self::INITIAL_FILE),
   125|             null,
   126|             Settings::getLibXmlLoaderOptions()
   127|         );
   128|         $xml->setParserProperty(2, true);
   129|         $xml->read();
   130|         while ($xml->read()) {
   131|             while (self::getXmlName($xml) !== 'office:body') {
   132|                 if ($xml->isEmptyElement) {
   133|                     $xml->read();
   134|                 } else {
   135|                     $xml->next();
   136|                 }
   137|             }
   138|             while ($xml->read()) {
   139|                 if (self::getXmlName($xml) == 'table:table' && $xml->nodeType == XMLReader::ELEMENT) {
   140|                     $worksheetNames[] = $xml->getAttribute('table:name');
   141|                     $tmpInfo = [
   142|                         'worksheetName' => $xml->getAttribute('table:name'),
   143|                         'lastColumnLetter' => 'A',
   144|                         'lastColumnIndex' => 0,
   145|                         'totalRows' => 0,
   146|                         'totalColumns' => 0,
   147|                     ];
   148|                     $currCells = 0;
   149|                     do {
   150|                         $xml->read();
   151|                         if (self::getXmlName($xml) == 'table:table-row' && $xml->nodeType == XMLReader::ELEMENT) {
   152|                             $rowspan = $xml->getAttribute('table:number-rows-repeated');
   153|                             $rowspan = empty($rowspan) ? 1 : $rowspan;
   154|                             $tmpInfo['totalRows'] += $rowspan;
   155|                             $tmpInfo['totalColumns'] = max($tmpInfo['totalColumns'], $currCells);
   156|                             $currCells = 0;
   157|                             $xml->read();
   158|                             do {
   159|                                 $doread = true;
   160|                                 if (self::getXmlName($xml) == 'table:table-cell' && $xml->nodeType == XMLReader::ELEMENT) {
   161|                                     if (!$xml->isEmptyElement) {
   162|                                         ++$currCells;
   163|                                         $xml->next();
   164|                                         $doread = false;
   165|                                     }
   166|                                 } elseif (self::getXmlName($xml) == 'table:covered-table-cell' && $xml->nodeType == XMLReader::ELEMENT) {
   167|                                     $mergeSize = $xml->getAttribute('table:number-columns-repeated');
   168|                                     $currCells += (int) $mergeSize;
   169|                                 }
   170|                                 if ($doread) {
   171|                                     $xml->read();
   172|                                 }
   173|                             } while (self::getXmlName($xml) != 'table:table-row');
   174|                         }
   175|                     } while (self::getXmlName($xml) != 'table:table');
   176|                     $tmpInfo['totalColumns'] = max($tmpInfo['totalColumns'], $currCells);
   177|                     $tmpInfo['lastColumnIndex'] = $tmpInfo['totalColumns'] - 1;
   178|                     $tmpInfo['lastColumnLetter'] = Coordinate::stringFromColumnIndex($tmpInfo['lastColumnIndex'] + 1);
   179|                     $worksheetInfo[] = $tmpInfo;
   180|                 }
   181|             }
   182|         }
   183|         return $worksheetInfo;
   184|     }
   185|     /**
   186|      * Counteract Phpstan caching.
   187|      *
   188|      * @phpstan-impure
   189|      */
   190|     private static function getXmlName(XMLReader $xml): string
   191|     {
   192|         return $xml->name;
   193|     }
   194|     /**
   195|      * Loads PhpSpreadsheet from file.
   196|      */
   197|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   198|     {
   199|         $spreadsheet = new Spreadsheet();
   200|         $spreadsheet->removeSheetByIndex(0);
   201|         return $this->loadIntoExisting($filename, $spreadsheet);
   202|     }
   203|     /**
   204|      * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
   205|      */
   206|     public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
   207|     {
   208|         File::assertFile($filename, self::INITIAL_FILE);
   209|         $zip = new ZipArchive();
   210|         $zip->open($filename);
   211|         $xml = @simplexml_load_string(
   212|             $this->getSecurityScannerOrThrow()->scan($zip->getFromName('meta.xml')),
   213|             'SimpleXMLElement',
   214|             Settings::getLibXmlLoaderOptions()
   215|         );
   216|         if ($xml === false) {
   217|             throw new Exception('Unable to read data from {$pFilename}');
   218|         }
   219|         $namespacesMeta = $xml->getNamespaces(true);
   220|         (new DocumentProperties($spreadsheet))->load($xml, $namespacesMeta);
   221|         $dom = new DOMDocument('1.01', 'UTF-8');
   222|         $dom->loadXML(
   223|             $this->getSecurityScannerOrThrow()->scan($zip->getFromName('styles.xml')),
   224|             Settings::getLibXmlLoaderOptions()
   225|         );
   226|         $pageSettings = new PageSettings($dom);
   227|         $dom = new DOMDocument('1.01', 'UTF-8');
   228|         $dom->loadXML(
   229|             $this->getSecurityScannerOrThrow()->scan($zip->getFromName(self::INITIAL_FILE)),
   230|             Settings::getLibXmlLoaderOptions()
   231|         );
   232|         $officeNs = (string) $dom->lookupNamespaceUri('office');
   233|         $tableNs = (string) $dom->lookupNamespaceUri('table');
   234|         $textNs = (string) $dom->lookupNamespaceUri('text');
   235|         $xlinkNs = (string) $dom->lookupNamespaceUri('xlink');
   236|         $styleNs = (string) $dom->lookupNamespaceUri('style');
   237|         $pageSettings->readStyleCrossReferences($dom);
   238|         $autoFilterReader = new AutoFilter($spreadsheet, $tableNs);
   239|         $definedNameReader = new DefinedNames($spreadsheet, $tableNs);
   240|         $columnWidths = [];
   241|         $automaticStyle0 = $dom->getElementsByTagNameNS($officeNs, 'automatic-styles')->item(0);
   242|         $automaticStyles = ($automaticStyle0 === null) ? [] : $automaticStyle0->getElementsByTagNameNS($styleNs, 'style');
   243|         foreach ($automaticStyles as $automaticStyle) {
   244|             $styleName = $automaticStyle->getAttributeNS($styleNs, 'name');
   245|             $styleFamily = $automaticStyle->getAttributeNS($styleNs, 'family');
   246|             if ($styleFamily === 'table-column') {
   247|                 $tcprops = $automaticStyle->getElementsByTagNameNS($styleNs, 'table-column-properties');
   248|                 if ($tcprops !== null) {
   249|                     $tcprop = $tcprops->item(0);
   250|                     if ($tcprop !== null) {
   251|                         $columnWidth = $tcprop->getAttributeNs($styleNs, 'column-width');
   252|                         $columnWidths[$styleName] = $columnWidth;
   253|                     }
   254|                 }
   255|             }
   256|         }
   257|         $item0 = $dom->getElementsByTagNameNS($officeNs, 'body')->item(0);
   258|         $spreadsheets = ($item0 === null) ? [] : $item0->getElementsByTagNameNS($officeNs, 'spreadsheet');
   259|         foreach ($spreadsheets as $workbookData) {
   260|             /** @var DOMElement $workbookData */
   261|             $tables = $workbookData->getElementsByTagNameNS($tableNs, 'table');
   262|             $worksheetID = 0;
   263|             foreach ($tables as $worksheetDataSet) {
   264|                 /** @var DOMElement $worksheetDataSet */
   265|                 $worksheetName = $worksheetDataSet->getAttributeNS($tableNs, 'name');
   266|                 if (
   267|                     $this->loadSheetsOnly !== null
   268|                     && $worksheetName
   269|                     && !in_array($worksheetName, $this->loadSheetsOnly)
   270|                 ) {
   271|                     continue;
   272|                 }
   273|                 $worksheetStyleName = $worksheetDataSet->getAttributeNS($tableNs, 'style-name');
   274|                 $spreadsheet->createSheet();
   275|                 $spreadsheet->setActiveSheetIndex($worksheetID);
   276|                 if ($worksheetName || is_numeric($worksheetName)) {
   277|                     $spreadsheet->getActiveSheet()->setTitle((string) $worksheetName, false, false);
   278|                 }
   279|                 $rowID = 1;
   280|                 $tableColumnIndex = 1;
   281|                 foreach ($worksheetDataSet->childNodes as $childNode) {
   282|                     /** @var DOMElement $childNode */
   283|                     if ($childNode->namespaceURI != $tableNs) {
   284|                         continue;
   285|                     }
   286|                     $key = $childNode->nodeName;
   287|                     if (str_contains($key, ':')) {
   288|                         $keyChunks = explode(':', $key);
   289|                         $key = array_pop($keyChunks);
   290|                     }
   291|                     switch ($key) {
   292|                         case 'table-header-rows':
   293|                             break;
   294|                         case 'table-column':
   295|                             if ($childNode->hasAttributeNS($tableNs, 'number-columns-repeated')) {
   296|                                 $rowRepeats = (int) $childNode->getAttributeNS($tableNs, 'number-columns-repeated');
   297|                             } else {
   298|                                 $rowRepeats = 1;
   299|                             }
   300|                             $tableStyleName = $childNode->getAttributeNS($tableNs, 'style-name');
   301|                             if (isset($columnWidths[$tableStyleName])) {
   302|                                 $columnWidth = new HelperDimension($columnWidths[$tableStyleName]);
   303|                                 $tableColumnString = Coordinate::stringFromColumnIndex($tableColumnIndex);
   304|                                 for ($rowRepeats2 = $rowRepeats; $rowRepeats2 > 0; --$rowRepeats2) {
   305|                                     $spreadsheet->getActiveSheet()
   306|                                         ->getColumnDimension($tableColumnString)
   307|                                         ->setWidth($columnWidth->toUnit('cm'), 'cm');
   308|                                     ++$tableColumnString;
   309|                                 }
   310|                             }
   311|                             $tableColumnIndex += $rowRepeats;
   312|                             break;
   313|                         case 'table-row':
   314|                             if ($childNode->hasAttributeNS($tableNs, 'number-rows-repeated')) {
   315|                                 $rowRepeats = (int) $childNode->getAttributeNS($tableNs, 'number-rows-repeated');
   316|                             } else {
   317|                                 $rowRepeats = 1;
   318|                             }
   319|                             $columnID = 'A';
   320|                             /** @var DOMElement|DOMText $cellData */
   321|                             foreach ($childNode->childNodes as $cellData) {
   322|                                 if ($cellData instanceof DOMText) {
   323|                                     continue; // should just be whitespace
   324|                                 }
   325|                                 if ($this->getReadFilter() !== null) {
   326|                                     if (!$this->getReadFilter()->readCell($columnID, $rowID, $worksheetName)) {
   327|                                         if ($cellData->hasAttributeNS($tableNs, 'number-columns-repeated')) {
   328|                                             $colRepeats = (int) $cellData->getAttributeNS($tableNs, 'number-columns-repeated');
   329|                                         } else {
   330|                                             $colRepeats = 1;
   331|                                         }
   332|                                         for ($i = 0; $i < $colRepeats; ++$i) {
   333|                                             ++$columnID;
   334|                                         }
   335|                                         continue;
   336|                                     }
   337|                                 }
   338|                                 $formatting = $hyperlink = null;
   339|                                 $hasCalculatedValue = false;
   340|                                 $cellDataFormula = '';
   341|                                 if ($cellData->hasAttributeNS($tableNs, 'formula')) {
   342|                                     $cellDataFormula = $cellData->getAttributeNS($tableNs, 'formula');
   343|                                     $hasCalculatedValue = true;
   344|                                 }
   345|                                 $annotation = $cellData->getElementsByTagNameNS($officeNs, 'annotation');
   346|                                 if ($annotation->length > 0 && $annotation->item(0) !== null) {
   347|                                     $textNode = $annotation->item(0)->getElementsByTagNameNS($textNs, 'p');
   348|                                     $textNodeLength = $textNode->length;
   349|                                     $newLineOwed = false;
   350|                                     for ($textNodeIndex = 0; $textNodeIndex < $textNodeLength; ++$textNodeIndex) {
   351|                                         $textNodeItem = $textNode->item($textNodeIndex);
   352|                                         if ($textNodeItem !== null) {
   353|                                             $text = $this->scanElementForText($textNodeItem);
   354|                                             if ($newLineOwed) {
   355|                                                 $spreadsheet->getActiveSheet()
   356|                                                     ->getComment($columnID . $rowID)
   357|                                                     ->getText()
   358|                                                     ->createText("\n");
   359|                                             }
   360|                                             $newLineOwed = true;
   361|                                             $spreadsheet->getActiveSheet()
   362|                                                 ->getComment($columnID . $rowID)
   363|                                                 ->getText()
   364|                                                 ->createText($this->parseRichText($text));
   365|                                         }
   366|                                     }
   367|                                 }
   368|                                 /** @var DOMElement[] $paragraphs */
   369|                                 $paragraphs = [];
   370|                                 foreach ($cellData->childNodes as $item) {
   371|                                     /** @var DOMElement $item */
   372|                                     if ($item->nodeName == 'text:p') {
   373|                                         $paragraphs[] = $item;
   374|                                     }
   375|                                 }
   376|                                 if (count($paragraphs) > 0) {
   377|                                     $dataArray = [];
   378|                                     foreach ($paragraphs as $pData) {
   379|                                         $dataArray[] = $this->scanElementForText($pData);
   380|                                     }
   381|                                     $allCellDataText = implode("\n", $dataArray);
   382|                                     $type = $cellData->getAttributeNS($officeNs, 'value-type');
   383|                                     switch ($type) {
   384|                                         case 'string':
   385|                                             $type = DataType::TYPE_STRING;
   386|                                             $dataValue = $allCellDataText;
   387|                                             foreach ($paragraphs as $paragraph) {
   388|                                                 $link = $paragraph->getElementsByTagNameNS($textNs, 'a');
   389|                                                 if ($link->length > 0 && $link->item(0) !== null) {
   390|                                                     $hyperlink = $link->item(0)->getAttributeNS($xlinkNs, 'href');
   391|                                                 }
   392|                                             }
   393|                                             break;
   394|                                         case 'boolean':
   395|                                             $type = DataType::TYPE_BOOL;
   396|                                             $dataValue = ($cellData->getAttributeNS($officeNs, 'boolean-value') === 'true') ? true : false;
   397|                                             break;
   398|                                         case 'percentage':
   399|                                             $type = DataType::TYPE_NUMERIC;
   400|                                             $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
   401|                                             $formatting = NumberFormat::FORMAT_PERCENTAGE_00;
   402|                                             break;
   403|                                         case 'currency':
   404|                                             $type = DataType::TYPE_NUMERIC;
   405|                                             $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
   406|                                             if (floor($dataValue) == $dataValue) {
   407|                                                 $dataValue = (int) $dataValue;
   408|                                             }
   409|                                             $formatting = NumberFormat::FORMAT_CURRENCY_USD_INTEGER;
   410|                                             break;
   411|                                         case 'float':
   412|                                             $type = DataType::TYPE_NUMERIC;
   413|                                             $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
   414|                                             if (floor($dataValue) == $dataValue) {
   415|                                                 if ($dataValue == (int) $dataValue) {
   416|                                                     $dataValue = (int) $dataValue;
   417|                                                 }
   418|                                             }
   419|                                             break;
   420|                                         case 'date':
   421|                                             $type = DataType::TYPE_NUMERIC;
   422|                                             $value = $cellData->getAttributeNS($officeNs, 'date-value');
   423|                                             $dataValue = Date::convertIsoDate($value);
   424|                                             if ($dataValue != floor($dataValue)) {
   425|                                                 $formatting = NumberFormat::FORMAT_DATE_XLSX15
   426|                                                     . ' '
   427|                                                     . NumberFormat::FORMAT_DATE_TIME4;
   428|                                             } else {
   429|                                                 $formatting = NumberFormat::FORMAT_DATE_XLSX15;
   430|                                             }
   431|                                             break;
   432|                                         case 'time':
   433|                                             $type = DataType::TYPE_NUMERIC;
   434|                                             $timeValue = $cellData->getAttributeNS($officeNs, 'time-value');
   435|                                             $dataValue = Date::PHPToExcel(
   436|                                                 strtotime(
   437|                                                     '01-01-1970 ' . implode(':', sscanf($timeValue, 'PT%dH%dM%dS') ?? [])
   438|                                                 )
   439|                                             );
   440|                                             $formatting = NumberFormat::FORMAT_DATE_TIME4;
   441|                                             break;
   442|                                         default:
   443|                                             $dataValue = null;
   444|                                     }
   445|                                 } else {
   446|                                     $type = DataType::TYPE_NULL;
   447|                                     $dataValue = null;
   448|                                 }
   449|                                 if ($hasCalculatedValue) {
   450|                                     $type = DataType::TYPE_FORMULA;
   451|                                     $cellDataFormula = substr($cellDataFormula, strpos($cellDataFormula, ':=') + 1);
   452|                                     $cellDataFormula = FormulaTranslator::convertToExcelFormulaValue($cellDataFormula);
   453|                                 }
   454|                                 if ($cellData->hasAttributeNS($tableNs, 'number-columns-repeated')) {
   455|                                     $colRepeats = (int) $cellData->getAttributeNS($tableNs, 'number-columns-repeated');
   456|                                 } else {
   457|                                     $colRepeats = 1;
   458|                                 }
   459|                                 if ($type !== null) {
   460|                                     for ($i = 0; $i < $colRepeats; ++$i) {
   461|                                         if ($i > 0) {
   462|                                             ++$columnID;
   463|                                         }
   464|                                         if ($type !== DataType::TYPE_NULL) {
   465|                                             for ($rowAdjust = 0; $rowAdjust < $rowRepeats; ++$rowAdjust) {
   466|                                                 $rID = $rowID + $rowAdjust;
   467|                                                 $cell = $spreadsheet->getActiveSheet()
   468|                                                     ->getCell($columnID . $rID);
   469|                                                 if ($hasCalculatedValue) {
   470|                                                     $cell->setValueExplicit($cellDataFormula, $type);
   471|                                                 } else {
   472|                                                     $cell->setValueExplicit($dataValue, $type);
   473|                                                 }
   474|                                                 if ($hasCalculatedValue) {
   475|                                                     $cell->setCalculatedValue($dataValue, $type === DataType::TYPE_NUMERIC);
   476|                                                 }
   477|                                                 if ($formatting !== null) {
   478|                                                     $spreadsheet->getActiveSheet()
   479|                                                         ->getStyle($columnID . $rID)
   480|                                                         ->getNumberFormat()
   481|                                                         ->setFormatCode($formatting);
   482|                                                 } else {
   483|                                                     $spreadsheet->getActiveSheet()
   484|                                                         ->getStyle($columnID . $rID)
   485|                                                         ->getNumberFormat()
   486|                                                         ->setFormatCode(NumberFormat::FORMAT_GENERAL);
   487|                                                 }
   488|                                                 if ($hyperlink !== null) {
   489|                                                     if ($hyperlink[0] === '#') {
   490|                                                         $hyperlink = 'sheet://' . substr($hyperlink, 1);
   491|                                                     }
   492|                                                     $cell->getHyperlink()
   493|                                                         ->setUrl($hyperlink);
   494|                                                 }
   495|                                             }
   496|                                         }
   497|                                     }
   498|                                 }
   499|                                 $this->processMergedCells($cellData, $tableNs, $type, $columnID, $rowID, $spreadsheet);
   500|                                 ++$columnID;
   501|                             }
   502|                             $rowID += $rowRepeats;
   503|                             break;
   504|                     }
   505|                 }
   506|                 $pageSettings->setVisibilityForWorksheet($spreadsheet->getActiveSheet(), $worksheetStyleName);
   507|                 $pageSettings->setPrintSettingsForWorksheet($spreadsheet->getActiveSheet(), $worksheetStyleName);
   508|                 ++$worksheetID;
   509|             }
   510|             $autoFilterReader->read($workbookData);
   511|             $definedNameReader->read($workbookData);
   512|         }
   513|         $spreadsheet->setActiveSheetIndex(0);
   514|         if ($zip->locateName('settings.xml') !== false) {
   515|             $this->processSettings($zip, $spreadsheet);
   516|         }
   517|         return $spreadsheet;
   518|     }
   519|     private function processSettings(ZipArchive $zip, Spreadsheet $spreadsheet): void
   520|     {
   521|         $dom = new DOMDocument('1.01', 'UTF-8');
   522|         $dom->loadXML(
   523|             $this->getSecurityScannerOrThrow()->scan($zip->getFromName('settings.xml')),
   524|             Settings::getLibXmlLoaderOptions()
   525|         );
   526|         $configNs = (string) $dom->lookupNamespaceUri('config');
   527|         $officeNs = (string) $dom->lookupNamespaceUri('office');
   528|         $settings = $dom->getElementsByTagNameNS($officeNs, 'settings')
   529|             ->item(0);
   530|         if ($settings !== null) {
   531|             $this->lookForActiveSheet($settings, $spreadsheet, $configNs);
   532|             $this->lookForSelectedCells($settings, $spreadsheet, $configNs);
   533|         }
   534|     }
   535|     private function lookForActiveSheet(DOMElement $settings, Spreadsheet $spreadsheet, string $configNs): void
   536|     {
   537|         /** @var DOMElement $t */
   538|         foreach ($settings->getElementsByTagNameNS($configNs, 'config-item') as $t) {
   539|             if ($t->getAttributeNs($configNs, 'name') === 'ActiveTable') {
   540|                 try {
   541|                     $spreadsheet->setActiveSheetIndexByName($t->nodeValue ?? '');
   542|                 } catch (Throwable) {
   543|                 }
   544|                 break;
   545|             }
   546|         }
   547|     }
   548|     private function lookForSelectedCells(DOMElement $settings, Spreadsheet $spreadsheet, string $configNs): void
   549|     {
   550|         /** @var DOMElement $t */
   551|         foreach ($settings->getElementsByTagNameNS($configNs, 'config-item-map-named') as $t) {
   552|             if ($t->getAttributeNs($configNs, 'name') === 'Tables') {
   553|                 foreach ($t->getElementsByTagNameNS($configNs, 'config-item-map-entry') as $ws) {
   554|                     $setRow = $setCol = '';
   555|                     $wsname = $ws->getAttributeNs($configNs, 'name');
   556|                     foreach ($ws->getElementsByTagNameNS($configNs, 'config-item') as $configItem) {
   557|                         $attrName = $configItem->getAttributeNs($configNs, 'name');
   558|                         if ($attrName === 'CursorPositionX') {
   559|                             $setCol = $configItem->nodeValue;
   560|                         }
   561|                         if ($attrName === 'CursorPositionY') {
   562|                             $setRow = $configItem->nodeValue;
   563|                         }
   564|                     }
   565|                     $this->setSelected($spreadsheet, $wsname, "$setCol", "$setRow");
   566|                 }
   567|                 break;
   568|             }
   569|         }
   570|     }
   571|     private function setSelected(Spreadsheet $spreadsheet, string $wsname, string $setCol, string $setRow): void
   572|     {
   573|         if (is_numeric($setCol) && is_numeric($setRow)) {
   574|             $sheet = $spreadsheet->getSheetByName($wsname);
   575|             if ($sheet !== null) {
   576|                 $sheet->setSelectedCells([(int) $setCol + 1, (int) $setRow + 1]);
   577|             }
   578|         }
   579|     }
   580|     /**
   581|      * Recursively scan element.
   582|      */
   583|     protected function scanElementForText(DOMNode $element): string
   584|     {
   585|         $str = '';
   586|         foreach ($element->childNodes as $child) {
   587|             /** @var DOMNode $child */
   588|             if ($child->nodeType == XML_TEXT_NODE) {
   589|                 $str .= $child->nodeValue;
   590|             } elseif ($child->nodeType == XML_ELEMENT_NODE && $child->nodeName == 'text:line-break') {
   591|                 $str .= "\n";
   592|             } elseif ($child->nodeType == XML_ELEMENT_NODE && $child->nodeName == 'text:s') {
   593|                 $attributes = $child->attributes;
   594|                 /** @var ?DOMAttr $cAttr */
   595|                 $cAttr = ($attributes === null) ? null : $attributes->getNamedItem('c');
   596|                 $multiplier = self::getMultiplier($cAttr);
   597|                 $str .= str_repeat(' ', $multiplier);
   598|             }
   599|             if ($child->hasChildNodes()) {
   600|                 $str .= $this->scanElementForText($child);
   601|             }
   602|         }
   603|         return $str;
   604|     }
   605|     private static function getMultiplier(?DOMAttr $cAttr): int
   606|     {
   607|         if ($cAttr) {
   608|             $multiplier = (int) $cAttr->nodeValue;
   609|         } else {
   610|             $multiplier = 1;
   611|         }
   612|         return $multiplier;
   613|     }
   614|     private function parseRichText(string $is): RichText
   615|     {
   616|         $value = new RichText();
   617|         $value->createText($is);
   618|         return $value;
   619|     }
   620|     private function processMergedCells(
   621|         DOMElement $cellData,
   622|         string $tableNs,
   623|         string $type,
   624|         string $columnID,
   625|         int $rowID,
   626|         Spreadsheet $spreadsheet
   627|     ): void {
   628|         if (
   629|             $cellData->hasAttributeNS($tableNs, 'number-columns-spanned')
   630|             || $cellData->hasAttributeNS($tableNs, 'number-rows-spanned')
   631|         ) {
   632|             if (($type !== DataType::TYPE_NULL) || ($this->readDataOnly === false)) {
   633|                 $columnTo = $columnID;
   634|                 if ($cellData->hasAttributeNS($tableNs, 'number-columns-spanned')) {
   635|                     $columnIndex = Coordinate::columnIndexFromString($columnID);
   636|                     $columnIndex += (int) $cellData->getAttributeNS($tableNs, 'number-columns-spanned');
   637|                     $columnIndex -= 2;
   638|                     $columnTo = Coordinate::stringFromColumnIndex($columnIndex + 1);
   639|                 }
   640|                 $rowTo = $rowID;
   641|                 if ($cellData->hasAttributeNS($tableNs, 'number-rows-spanned')) {
   642|                     $rowTo = $rowTo + (int) $cellData->getAttributeNS($tableNs, 'number-rows-spanned') - 1;
   643|                 }
   644|                 $cellRange = $columnID . $rowID . ':' . $columnTo . $rowTo;
   645|                 $spreadsheet->getActiveSheet()->mergeCells($cellRange, Worksheet::MERGE_CELL_CONTENT_HIDE);
   646|             }
   647|         }
   648|     }
   649| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Slk.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-445 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     5| use PhpOffice\PhpSpreadsheet\Reader\Exception as ReaderException;
     6| use PhpOffice\PhpSpreadsheet\ReferenceHelper;
     7| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     8| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     9| use PhpOffice\PhpSpreadsheet\Style\Border;
    10| use PhpOffice\PhpSpreadsheet\Style\Fill;
    11| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    12| class Slk extends BaseReader
    13| {
    14|     /**
    15|      * Sheet index to read.
    16|      */
    17|     private int $sheetIndex = 0;
    18|     /**
    19|      * Formats.
    20|      */
    21|     private array $formats = [];
    22|     /**
    23|      * Format Count.
    24|      */
    25|     private int $format = 0;
    26|     /**
    27|      * Fonts.
    28|      */
    29|     private array $fonts = [];
    30|     /**
    31|      * Font Count.
    32|      */
    33|     private int $fontcount = 0;
    34|     /**
    35|      * Create a new SYLK Reader instance.
    36|      */
    37|     public function __construct()
    38|     {
    39|         parent::__construct();
    40|     }
    41|     /**
    42|      * Validate that the current file is a SYLK file.
    43|      */
    44|     public function canRead(string $filename): bool
    45|     {
    46|         try {
    47|             $this->openFile($filename);
    48|         } catch (ReaderException) {
    49|             return false;
    50|         }
    51|         $data = (string) fread($this->fileHandle, 2048);
    52|         $delimiterCount = substr_count($data, ';');
    53|         $hasDelimiter = $delimiterCount > 0;
    54|         $lines = explode("\n", $data);
    55|         $hasId = str_starts_with($lines[0], 'ID;P');
    56|         fclose($this->fileHandle);
    57|         return $hasDelimiter && $hasId;
    58|     }
    59|     private function canReadOrBust(string $filename): void
    60|     {
    61|         if (!$this->canRead($filename)) {
    62|             throw new ReaderException($filename . ' is an Invalid SYLK file.');
    63|         }
    64|         $this->openFile($filename);
    65|     }
    66|     /**
    67|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
    68|      */
    69|     public function listWorksheetInfo(string $filename): array
    70|     {
    71|         $this->canReadOrBust($filename);
    72|         $fileHandle = $this->fileHandle;
    73|         rewind($fileHandle);
    74|         $worksheetInfo = [];
    75|         $worksheetInfo[0]['worksheetName'] = basename($filename, '.slk');
    76|         $rowIndex = 0;
    77|         $columnIndex = 0;
    78|         while (($rowData = fgets($fileHandle)) !== false) {
    79|             $columnIndex = 0;
    80|             $rowData = StringHelper::SYLKtoUTF8($rowData);
    81|             $rowData = explode("\t", str_replace('¤', ';', str_replace(';', "\t", str_replace(';;', '¤', rtrim($rowData)))));
    82|             $dataType = array_shift($rowData);
    83|             if ($dataType == 'B') {
    84|                 foreach ($rowData as $rowDatum) {
    85|                     switch ($rowDatum[0]) {
    86|                         case 'X':
    87|                             $columnIndex = (int) substr($rowDatum, 1) - 1;
    88|                             break;
    89|                         case 'Y':
    90|                             $rowIndex = (int) substr($rowDatum, 1);
    91|                             break;
    92|                     }
    93|                 }
    94|                 break;
    95|             }
    96|         }
    97|         $worksheetInfo[0]['lastColumnIndex'] = $columnIndex;
    98|         $worksheetInfo[0]['totalRows'] = $rowIndex;
    99|         $worksheetInfo[0]['lastColumnLetter'] = Coordinate::stringFromColumnIndex($worksheetInfo[0]['lastColumnIndex'] + 1);
   100|         $worksheetInfo[0]['totalColumns'] = $worksheetInfo[0]['lastColumnIndex'] + 1;
   101|         fclose($fileHandle);
   102|         return $worksheetInfo;
   103|     }
   104|     /**
   105|      * Loads PhpSpreadsheet from file.
   106|      */
   107|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   108|     {
   109|         $spreadsheet = new Spreadsheet();
   110|         return $this->loadIntoExisting($filename, $spreadsheet);
   111|     }
   112|     private const COLOR_ARRAY = [
   113|         'FF00FFFF', // 0 - cyan
   114|         'FF000000', // 1 - black
   115|         'FFFFFFFF', // 2 - white
   116|         'FFFF0000', // 3 - red
   117|         'FF00FF00', // 4 - green
   118|         'FF0000FF', // 5 - blue
   119|         'FFFFFF00', // 6 - yellow
   120|         'FFFF00FF', // 7 - magenta
   121|     ];
   122|     private const FONT_STYLE_MAPPINGS = [
   123|         'B' => 'bold',
   124|         'I' => 'italic',
   125|         'U' => 'underline',
   126|     ];
   127|     private function processFormula(string $rowDatum, bool &$hasCalculatedValue, string &$cellDataFormula, string $row, string $column): void
   128|     {
   129|         $cellDataFormula = '=' . substr($rowDatum, 1);
   130|         $temp = explode('"', $cellDataFormula);
   131|         $key = false;
   132|         foreach ($temp as &$value) {
   133|             $key = $key === false;
   134|             if ($key) {
   135|                 preg_match_all('/(R(\[?-?\d*\]?))(C(\[?-?\d*\]?))/', $value, $cellReferences, PREG_SET_ORDER + PREG_OFFSET_CAPTURE);
   136|                 $cellReferences = array_reverse($cellReferences);
   137|                 foreach ($cellReferences as $cellReference) {
   138|                     $rowReference = $cellReference[2][0];
   139|                     if ($rowReference == '') {
   140|                         $rowReference = $row;
   141|                     }
   142|                     if ($rowReference[0] == '[') {
   143|                         $rowReference = (int) $row + (int) trim($rowReference, '[]');
   144|                     }
   145|                     $columnReference = $cellReference[4][0];
   146|                     if ($columnReference == '') {
   147|                         $columnReference = $column;
   148|                     }
   149|                     if ($columnReference[0] == '[') {
   150|                         $columnReference = (int) $column + (int) trim($columnReference, '[]');
   151|                     }
   152|                     $A1CellReference = Coordinate::stringFromColumnIndex((int) $columnReference) . $rowReference;
   153|                     $value = substr_replace($value, $A1CellReference, $cellReference[0][1], strlen($cellReference[0][0]));
   154|                 }
   155|             }
   156|         }
   157|         unset($value);
   158|         $cellDataFormula = implode('"', $temp);
   159|         $hasCalculatedValue = true;
   160|     }
   161|     private function processCRecord(array $rowData, Spreadsheet &$spreadsheet, string &$row, string &$column): void
   162|     {
   163|         $hasCalculatedValue = false;
   164|         $tryNumeric = false;
   165|         $cellDataFormula = $cellData = '';
   166|         $sharedColumn = $sharedRow = -1;
   167|         $sharedFormula = false;
   168|         foreach ($rowData as $rowDatum) {
   169|             switch ($rowDatum[0]) {
   170|                 case 'X':
   171|                     $column = substr($rowDatum, 1);
   172|                     break;
   173|                 case 'Y':
   174|                     $row = substr($rowDatum, 1);
   175|                     break;
   176|                 case 'K':
   177|                     $cellData = substr($rowDatum, 1);
   178|                     $tryNumeric = is_numeric($cellData);
   179|                     break;
   180|                 case 'E':
   181|                     $this->processFormula($rowDatum, $hasCalculatedValue, $cellDataFormula, $row, $column);
   182|                     break;
   183|                 case 'A':
   184|                     $comment = substr($rowDatum, 1);
   185|                     $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
   186|                     $spreadsheet->getActiveSheet()
   187|                         ->getComment("$columnLetter$row")
   188|                         ->getText()
   189|                         ->createText($comment);
   190|                     break;
   191|                 case 'C':
   192|                     $sharedColumn = (int) substr($rowDatum, 1);
   193|                     break;
   194|                 case 'R':
   195|                     $sharedRow = (int) substr($rowDatum, 1);
   196|                     break;
   197|                 case 'S':
   198|                     $sharedFormula = true;
   199|                     break;
   200|             }
   201|         }
   202|         if ($sharedFormula === true && $sharedRow >= 0 && $sharedColumn >= 0) {
   203|             $thisCoordinate = Coordinate::stringFromColumnIndex((int) $column) . $row;
   204|             $sharedCoordinate = Coordinate::stringFromColumnIndex($sharedColumn) . $sharedRow;
   205|             /** @var string */
   206|             $formula = $spreadsheet->getActiveSheet()->getCell($sharedCoordinate)->getValue();
   207|             $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setValue($formula);
   208|             $referenceHelper = ReferenceHelper::getInstance();
   209|             $newFormula = $referenceHelper->updateFormulaReferences($formula, 'A1', (int) $column - $sharedColumn, (int) $row - $sharedRow, '', true, false);
   210|             $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setValue($newFormula);
   211|             $cellData = Calculation::unwrapResult($cellData);
   212|             $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setCalculatedValue($cellData, $tryNumeric);
   213|             return;
   214|         }
   215|         $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
   216|         /** @var string */
   217|         $cellData = Calculation::unwrapResult($cellData);
   218|         $this->processCFinal($spreadsheet, $hasCalculatedValue, $cellDataFormula, $cellData, "$columnLetter$row", $tryNumeric);
   219|     }
   220|     private function processCFinal(Spreadsheet &$spreadsheet, bool $hasCalculatedValue, string $cellDataFormula, string $cellData, string $coordinate, bool $tryNumeric): void
   221|     {
   222|         $spreadsheet->getActiveSheet()->getCell($coordinate)->setValue(($hasCalculatedValue) ? $cellDataFormula : $cellData);
   223|         if ($hasCalculatedValue) {
   224|             $cellData = Calculation::unwrapResult($cellData);
   225|             $spreadsheet->getActiveSheet()->getCell($coordinate)->setCalculatedValue($cellData, $tryNumeric);
   226|         }
   227|     }
   228|     private function processFRecord(array $rowData, Spreadsheet &$spreadsheet, string &$row, string &$column): void
   229|     {
   230|         $formatStyle = $columnWidth = '';
   231|         $startCol = $endCol = '';
   232|         $fontStyle = '';
   233|         $styleData = [];
   234|         foreach ($rowData as $rowDatum) {
   235|             switch ($rowDatum[0]) {
   236|                 case 'C':
   237|                 case 'X':
   238|                     $column = substr($rowDatum, 1);
   239|                     break;
   240|                 case 'R':
   241|                 case 'Y':
   242|                     $row = substr($rowDatum, 1);
   243|                     break;
   244|                 case 'P':
   245|                     $formatStyle = $rowDatum;
   246|                     break;
   247|                 case 'W':
   248|                     [$startCol, $endCol, $columnWidth] = explode(' ', substr($rowDatum, 1));
   249|                     break;
   250|                 case 'S':
   251|                     $this->styleSettings($rowDatum, $styleData, $fontStyle);
   252|                     break;
   253|             }
   254|         }
   255|         $this->addFormats($spreadsheet, $formatStyle, $row, $column);
   256|         $this->addFonts($spreadsheet, $fontStyle, $row, $column);
   257|         $this->addStyle($spreadsheet, $styleData, $row, $column);
   258|         $this->addWidth($spreadsheet, $columnWidth, $startCol, $endCol);
   259|     }
   260|     private const STYLE_SETTINGS_FONT = ['D' => 'bold', 'I' => 'italic'];
   261|     private const STYLE_SETTINGS_BORDER = [
   262|         'B' => 'bottom',
   263|         'L' => 'left',
   264|         'R' => 'right',
   265|         'T' => 'top',
   266|     ];
   267|     private function styleSettings(string $rowDatum, array &$styleData, string &$fontStyle): void
   268|     {
   269|         $styleSettings = substr($rowDatum, 1);
   270|         $iMax = strlen($styleSettings);
   271|         for ($i = 0; $i < $iMax; ++$i) {
   272|             $char = $styleSettings[$i];
   273|             if (array_key_exists($char, self::STYLE_SETTINGS_FONT)) {
   274|                 $styleData['font'][self::STYLE_SETTINGS_FONT[$char]] = true;
   275|             } elseif (array_key_exists($char, self::STYLE_SETTINGS_BORDER)) {
   276|                 $styleData['borders'][self::STYLE_SETTINGS_BORDER[$char]]['borderStyle'] = Border::BORDER_THIN;
   277|             } elseif ($char == 'S') {
   278|                 $styleData['fill']['fillType'] = Fill::FILL_PATTERN_GRAY125;
   279|             } elseif ($char == 'M') {
   280|                 if (preg_match('/M([1-9]\\d*)/', $styleSettings, $matches)) {
   281|                     $fontStyle = $matches[1];
   282|                 }
   283|             }
   284|         }
   285|     }
   286|     private function addFormats(Spreadsheet &$spreadsheet, string $formatStyle, string $row, string $column): void
   287|     {
   288|         if ($formatStyle && $column > '' && $row > '') {
   289|             $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
   290|             if (isset($this->formats[$formatStyle])) {
   291|                 $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($this->formats[$formatStyle]);
   292|             }
   293|         }
   294|     }
   295|     private function addFonts(Spreadsheet &$spreadsheet, string $fontStyle, string $row, string $column): void
   296|     {
   297|         if ($fontStyle && $column > '' && $row > '') {
   298|             $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
   299|             if (isset($this->fonts[$fontStyle])) {
   300|                 $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($this->fonts[$fontStyle]);
   301|             }
   302|         }
   303|     }
   304|     private function addStyle(Spreadsheet &$spreadsheet, array $styleData, string $row, string $column): void
   305|     {
   306|         if ((!empty($styleData)) && $column > '' && $row > '') {
   307|             $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
   308|             $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($styleData);
   309|         }
   310|     }
   311|     private function addWidth(Spreadsheet $spreadsheet, string $columnWidth, string $startCol, string $endCol): void
   312|     {
   313|         if ($columnWidth > '') {
   314|             if ($startCol == $endCol) {
   315|                 $startCol = Coordinate::stringFromColumnIndex((int) $startCol);
   316|                 $spreadsheet->getActiveSheet()->getColumnDimension($startCol)->setWidth((float) $columnWidth);
   317|             } else {
   318|                 $startCol = Coordinate::stringFromColumnIndex((int) $startCol);
   319|                 $endCol = Coordinate::stringFromColumnIndex((int) $endCol);
   320|                 $spreadsheet->getActiveSheet()->getColumnDimension($startCol)->setWidth((float) $columnWidth);
   321|                 do {
   322|                     $spreadsheet->getActiveSheet()->getColumnDimension((string) ++$startCol)->setWidth((float) $columnWidth);
   323|                 } while ($startCol !== $endCol);
   324|             }
   325|         }
   326|     }
   327|     private function processPRecord(array $rowData, Spreadsheet &$spreadsheet): void
   328|     {
   329|         $formatArray = [];
   330|         $fromFormats = ['\-', '\ '];
   331|         $toFormats = ['-', ' '];
   332|         foreach ($rowData as $rowDatum) {
   333|             switch ($rowDatum[0]) {
   334|                 case 'P':
   335|                     $formatArray['numberFormat']['formatCode'] = str_replace($fromFormats, $toFormats, substr($rowDatum, 1));
   336|                     break;
   337|                 case 'E':
   338|                 case 'F':
   339|                     $formatArray['font']['name'] = substr($rowDatum, 1);
   340|                     break;
   341|                 case 'M':
   342|                     $formatArray['font']['size'] = ((float) substr($rowDatum, 1)) / 20;
   343|                     break;
   344|                 case 'L':
   345|                     $this->processPColors($rowDatum, $formatArray);
   346|                     break;
   347|                 case 'S':
   348|                     $this->processPFontStyles($rowDatum, $formatArray);
   349|                     break;
   350|             }
   351|         }
   352|         $this->processPFinal($spreadsheet, $formatArray);
   353|     }
   354|     private function processPColors(string $rowDatum, array &$formatArray): void
   355|     {
   356|         if (preg_match('/L([1-9]\\d*)/', $rowDatum, $matches)) {
   357|             $fontColor = $matches[1] % 8;
   358|             $formatArray['font']['color']['argb'] = self::COLOR_ARRAY[$fontColor];
   359|         }
   360|     }
   361|     private function processPFontStyles(string $rowDatum, array &$formatArray): void
   362|     {
   363|         $styleSettings = substr($rowDatum, 1);
   364|         $iMax = strlen($styleSettings);
   365|         for ($i = 0; $i < $iMax; ++$i) {
   366|             if (array_key_exists($styleSettings[$i], self::FONT_STYLE_MAPPINGS)) {
   367|                 $formatArray['font'][self::FONT_STYLE_MAPPINGS[$styleSettings[$i]]] = true;
   368|             }
   369|         }
   370|     }
   371|     private function processPFinal(Spreadsheet &$spreadsheet, array $formatArray): void
   372|     {
   373|         if (array_key_exists('numberFormat', $formatArray)) {
   374|             $this->formats['P' . $this->format] = $formatArray;
   375|             ++$this->format;
   376|         } elseif (array_key_exists('font', $formatArray)) {
   377|             ++$this->fontcount;
   378|             $this->fonts[$this->fontcount] = $formatArray;
   379|             if ($this->fontcount === 1) {
   380|                 $spreadsheet->getDefaultStyle()->applyFromArray($formatArray);
   381|             }
   382|         }
   383|     }
   384|     /**
   385|      * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
   386|      */
   387|     public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
   388|     {
   389|         $this->canReadOrBust($filename);
   390|         $fileHandle = $this->fileHandle;
   391|         rewind($fileHandle);
   392|         while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
   393|             $spreadsheet->createSheet();
   394|         }
   395|         $spreadsheet->setActiveSheetIndex($this->sheetIndex);
   396|         $spreadsheet->getActiveSheet()->setTitle(substr(basename($filename, '.slk'), 0, Worksheet::SHEET_TITLE_MAXIMUM_LENGTH));
   397|         $column = $row = '';
   398|         while (($rowDataTxt = fgets($fileHandle)) !== false) {
   399|             $rowDataTxt = StringHelper::SYLKtoUTF8($rowDataTxt);
   400|             $rowData = explode("\t", str_replace('¤', ';', str_replace(';', "\t", str_replace(';;', '¤', rtrim($rowDataTxt)))));
   401|             $dataType = array_shift($rowData);
   402|             if ($dataType == 'P') {
   403|                 $this->processPRecord($rowData, $spreadsheet);
   404|             } elseif ($dataType == 'C') {
   405|                 $this->processCRecord($rowData, $spreadsheet, $row, $column);
   406|             } elseif ($dataType == 'F') {
   407|                 $this->processFRecord($rowData, $spreadsheet, $row, $column);
   408|             } else {
   409|                 $this->columnRowFromRowData($rowData, $column, $row);
   410|             }
   411|         }
   412|         fclose($fileHandle);
   413|         return $spreadsheet;
   414|     }
   415|     private function columnRowFromRowData(array $rowData, string &$column, string &$row): void
   416|     {
   417|         foreach ($rowData as $rowDatum) {
   418|             $char0 = $rowDatum[0];
   419|             if ($char0 === 'X' || $char0 == 'C') {
   420|                 $column = substr($rowDatum, 1);
   421|             } elseif ($char0 === 'Y' || $char0 == 'R') {
   422|                 $row = substr($rowDatum, 1);
   423|             }
   424|         }
   425|     }
   426|     /**
   427|      * Get sheet index.
   428|      */
   429|     public function getSheetIndex(): int
   430|     {
   431|         return $this->sheetIndex;
   432|     }
   433|     /**
   434|      * Set sheet index.
   435|      *
   436|      * @param int $sheetIndex Sheet index
   437|      *
   438|      * @return $this
   439|      */
   440|     public function setSheetIndex(int $sheetIndex): static
   441|     {
   442|         $this->sheetIndex = $sheetIndex;
   443|         return $this;
   444|     }
   445| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Xls.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5315 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader;
     3| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     4| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     5| use PhpOffice\PhpSpreadsheet\Cell\DataValidation;
     6| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     7| use PhpOffice\PhpSpreadsheet\NamedRange;
     8| use PhpOffice\PhpSpreadsheet\Reader\Xls\ConditionalFormatting;
     9| use PhpOffice\PhpSpreadsheet\Reader\Xls\Style\CellFont;
    10| use PhpOffice\PhpSpreadsheet\Reader\Xls\Style\FillPattern;
    11| use PhpOffice\PhpSpreadsheet\RichText\RichText;
    12| use PhpOffice\PhpSpreadsheet\Shared\CodePage;
    13| use PhpOffice\PhpSpreadsheet\Shared\Date;
    14| use PhpOffice\PhpSpreadsheet\Shared\Escher;
    15| use PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer\SpContainer;
    16| use PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE;
    17| use PhpOffice\PhpSpreadsheet\Shared\File;
    18| use PhpOffice\PhpSpreadsheet\Shared\OLE;
    19| use PhpOffice\PhpSpreadsheet\Shared\OLERead;
    20| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
    21| use PhpOffice\PhpSpreadsheet\Shared\Xls as SharedXls;
    22| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    23| use PhpOffice\PhpSpreadsheet\Style\Alignment;
    24| use PhpOffice\PhpSpreadsheet\Style\Border;
    25| use PhpOffice\PhpSpreadsheet\Style\Borders;
    26| use PhpOffice\PhpSpreadsheet\Style\Conditional;
    27| use PhpOffice\PhpSpreadsheet\Style\Fill;
    28| use PhpOffice\PhpSpreadsheet\Style\Font;
    29| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    30| use PhpOffice\PhpSpreadsheet\Style\Protection;
    31| use PhpOffice\PhpSpreadsheet\Style\Style;
    32| use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
    33| use PhpOffice\PhpSpreadsheet\Worksheet\PageSetup;
    34| use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
    35| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    36| class Xls extends BaseReader
    37| {
    38|     private const HIGH_ORDER_BIT = 0x80 << 24;
    39|     private const FC000000 = 0xFC << 24;
    40|     private const FE000000 = 0xFE << 24;
    41|     const XLS_BIFF8 = 0x0600;
    42|     const XLS_BIFF7 = 0x0500;
    43|     const XLS_WORKBOOKGLOBALS = 0x0005;
    44|     const XLS_WORKSHEET = 0x0010;
    45|     const XLS_TYPE_FORMULA = 0x0006;
    46|     const XLS_TYPE_EOF = 0x000A;
    47|     const XLS_TYPE_PROTECT = 0x0012;
    48|     const XLS_TYPE_OBJECTPROTECT = 0x0063;
    49|     const XLS_TYPE_SCENPROTECT = 0x00DD;
    50|     const XLS_TYPE_PASSWORD = 0x0013;
    51|     const XLS_TYPE_HEADER = 0x0014;
    52|     const XLS_TYPE_FOOTER = 0x0015;
    53|     const XLS_TYPE_EXTERNSHEET = 0x0017;
    54|     const XLS_TYPE_DEFINEDNAME = 0x0018;
    55|     const XLS_TYPE_VERTICALPAGEBREAKS = 0x001A;
    56|     const XLS_TYPE_HORIZONTALPAGEBREAKS = 0x001B;
    57|     const XLS_TYPE_NOTE = 0x001C;
    58|     const XLS_TYPE_SELECTION = 0x001D;
    59|     const XLS_TYPE_DATEMODE = 0x0022;
    60|     const XLS_TYPE_EXTERNNAME = 0x0023;
    61|     const XLS_TYPE_LEFTMARGIN = 0x0026;
    62|     const XLS_TYPE_RIGHTMARGIN = 0x0027;
    63|     const XLS_TYPE_TOPMARGIN = 0x0028;
    64|     const XLS_TYPE_BOTTOMMARGIN = 0x0029;
    65|     const XLS_TYPE_PRINTGRIDLINES = 0x002B;
    66|     const XLS_TYPE_FILEPASS = 0x002F;
    67|     const XLS_TYPE_FONT = 0x0031;
    68|     const XLS_TYPE_CONTINUE = 0x003C;
    69|     const XLS_TYPE_PANE = 0x0041;
    70|     const XLS_TYPE_CODEPAGE = 0x0042;
    71|     const XLS_TYPE_DEFCOLWIDTH = 0x0055;
    72|     const XLS_TYPE_OBJ = 0x005D;
    73|     const XLS_TYPE_COLINFO = 0x007D;
    74|     const XLS_TYPE_IMDATA = 0x007F;
    75|     const XLS_TYPE_SHEETPR = 0x0081;
    76|     const XLS_TYPE_HCENTER = 0x0083;
    77|     const XLS_TYPE_VCENTER = 0x0084;
    78|     const XLS_TYPE_SHEET = 0x0085;
    79|     const XLS_TYPE_PALETTE = 0x0092;
    80|     const XLS_TYPE_SCL = 0x00A0;
    81|     const XLS_TYPE_PAGESETUP = 0x00A1;
    82|     const XLS_TYPE_MULRK = 0x00BD;
    83|     const XLS_TYPE_MULBLANK = 0x00BE;
    84|     const XLS_TYPE_DBCELL = 0x00D7;
    85|     const XLS_TYPE_XF = 0x00E0;
    86|     const XLS_TYPE_MERGEDCELLS = 0x00E5;
    87|     const XLS_TYPE_MSODRAWINGGROUP = 0x00EB;
    88|     const XLS_TYPE_MSODRAWING = 0x00EC;
    89|     const XLS_TYPE_SST = 0x00FC;
    90|     const XLS_TYPE_LABELSST = 0x00FD;
    91|     const XLS_TYPE_EXTSST = 0x00FF;
    92|     const XLS_TYPE_EXTERNALBOOK = 0x01AE;
    93|     const XLS_TYPE_DATAVALIDATIONS = 0x01B2;
    94|     const XLS_TYPE_TXO = 0x01B6;
    95|     const XLS_TYPE_HYPERLINK = 0x01B8;
    96|     const XLS_TYPE_DATAVALIDATION = 0x01BE;
    97|     const XLS_TYPE_DIMENSION = 0x0200;
    98|     const XLS_TYPE_BLANK = 0x0201;
    99|     const XLS_TYPE_NUMBER = 0x0203;
   100|     const XLS_TYPE_LABEL = 0x0204;
   101|     const XLS_TYPE_BOOLERR = 0x0205;
   102|     const XLS_TYPE_STRING = 0x0207;
   103|     const XLS_TYPE_ROW = 0x0208;
   104|     const XLS_TYPE_INDEX = 0x020B;
   105|     const XLS_TYPE_ARRAY = 0x0221;
   106|     const XLS_TYPE_DEFAULTROWHEIGHT = 0x0225;
   107|     const XLS_TYPE_WINDOW2 = 0x023E;
   108|     const XLS_TYPE_RK = 0x027E;
   109|     const XLS_TYPE_STYLE = 0x0293;
   110|     const XLS_TYPE_FORMAT = 0x041E;
   111|     const XLS_TYPE_SHAREDFMLA = 0x04BC;
   112|     const XLS_TYPE_BOF = 0x0809;
   113|     const XLS_TYPE_SHEETPROTECTION = 0x0867;
   114|     const XLS_TYPE_RANGEPROTECTION = 0x0868;
   115|     const XLS_TYPE_SHEETLAYOUT = 0x0862;
   116|     const XLS_TYPE_XFEXT = 0x087D;
   117|     const XLS_TYPE_PAGELAYOUTVIEW = 0x088B;
   118|     const XLS_TYPE_CFHEADER = 0x01B0;
   119|     const XLS_TYPE_CFRULE = 0x01B1;
   120|     const XLS_TYPE_UNKNOWN = 0xFFFF;
   121|     const MS_BIFF_CRYPTO_NONE = 0;
   122|     const MS_BIFF_CRYPTO_XOR = 1;
   123|     const MS_BIFF_CRYPTO_RC4 = 2;
   124|     const REKEY_BLOCK = 0x400;
   125|     const BORDER_STYLE_MAP = [
   126|         Border::BORDER_NONE, // => 0x00,
   127|         Border::BORDER_THIN,  // => 0x01,
   128|         Border::BORDER_MEDIUM, // => 0x02,
   129|         Border::BORDER_DASHED, // => 0x03,
   130|         Border::BORDER_DOTTED,  // => 0x04,
   131|         Border::BORDER_THICK, // => 0x05,
   132|         Border::BORDER_DOUBLE, // => 0x06,
   133|         Border::BORDER_HAIR, // => 0x07,
   134|         Border::BORDER_MEDIUMDASHED, // => 0x08,
   135|         Border::BORDER_DASHDOT, // => 0x09,
   136|         Border::BORDER_MEDIUMDASHDOT, // => 0x0A,
   137|         Border::BORDER_DASHDOTDOT, // => 0x0B,
   138|         Border::BORDER_MEDIUMDASHDOTDOT, // => 0x0C,
   139|         Border::BORDER_SLANTDASHDOT, // => 0x0D,
   140|         Border::BORDER_OMIT, // => 0x0E,
   141|         Border::BORDER_OMIT, // => 0x0F,
   142|     ];
   143|     /**
   144|      * Summary Information stream data.
   145|      */
   146|     private ?string $summaryInformation = null;
   147|     /**
   148|      * Extended Summary Information stream data.
   149|      */
   150|     private ?string $documentSummaryInformation = null;
   151|     /**
   152|      * Workbook stream data. (Includes workbook globals substream as well as sheet substreams).
   153|      */
   154|     private string $data;
   155|     /**
   156|      * Size in bytes of $this->data.
   157|      */
   158|     private int $dataSize;
   159|     /**
   160|      * Current position in stream.
   161|      */
   162|     private int $pos;
   163|     /**
   164|      * Workbook to be returned by the reader.
   165|      */
   166|     private Spreadsheet $spreadsheet;
   167|     /**
   168|      * Worksheet that is currently being built by the reader.
   169|      */
   170|     private Worksheet $phpSheet;
   171|     /**
   172|      * BIFF version.
   173|      */
   174|     private int $version = 0;
   175|     /**
   176|      * Codepage set in the Excel file being read. Only important for BIFF5 (Excel 5.0 - Excel 95)
   177|      * For BIFF8 (Excel 97 - Excel 2003) this will always have the value 'UTF-16LE'.
   178|      */
   179|     private string $codepage = '';
   180|     /**
   181|      * Shared formats.
   182|      */
   183|     private array $formats;
   184|     /**
   185|      * Shared fonts.
   186|      *
   187|      * @var Font[]
   188|      */
   189|     private array $objFonts;
   190|     /**
   191|      * Color palette.
   192|      */
   193|     private array $palette;
   194|     /**
   195|      * Worksheets.
   196|      */
   197|     private array $sheets;
   198|     /**
   199|      * External books.
   200|      */
   201|     private array $externalBooks;
   202|     /**
   203|      * REF structures. Only applies to BIFF8.
   204|      */
   205|     private array $ref;
   206|     /**
   207|      * External names.
   208|      */
   209|     private array $externalNames;
   210|     /**
   211|      * Defined names.
   212|      */
   213|     private array $definedname;
   214|     /**
   215|      * Shared strings. Only applies to BIFF8.
   216|      */
   217|     private array $sst;
   218|     /**
   219|      * Panes are frozen? (in sheet currently being read). See WINDOW2 record.
   220|      */
   221|     private bool $frozen;
   222|     /**
   223|      * Fit printout to number of pages? (in sheet currently being read). See SHEETPR record.
   224|      */
   225|     private bool $isFitToPages;
   226|     /**
   227|      * Objects. One OBJ record contributes with one entry.
   228|      */
   229|     private array $objs;
   230|     /**
   231|      * Text Objects. One TXO record corresponds with one entry.
   232|      */
   233|     private array $textObjects;
   234|     /**
   235|      * Cell Annotations (BIFF8).
   236|      */
   237|     private array $cellNotes;
   238|     /**
   239|      * The combined MSODRAWINGGROUP data.
   240|      */
   241|     private string $drawingGroupData;
   242|     /**
   243|      * The combined MSODRAWING data (per sheet).
   244|      */
   245|     private string $drawingData;
   246|     /**
   247|      * Keep track of XF index.
   248|      */
   249|     private int $xfIndex;
   250|     /**
   251|      * Mapping of XF index (that is a cell XF) to final index in cellXf collection.
   252|      */
   253|     private array $mapCellXfIndex;
   254|     /**
   255|      * Mapping of XF index (that is a style XF) to final index in cellStyleXf collection.
   256|      */
   257|     private array $mapCellStyleXfIndex;
   258|     /**
   259|      * The shared formulas in a sheet. One SHAREDFMLA record contributes with one value.
   260|      */
   261|     private array $sharedFormulas;
   262|     /**
   263|      * The shared formula parts in a sheet. One FORMULA record contributes with one value if it
   264|      * refers to a shared formula.
   265|      */
   266|     private array $sharedFormulaParts;
   267|     /**
   268|      * The type of encryption in use.
   269|      */
   270|     private int $encryption = 0;
   271|     /**
   272|      * The position in the stream after which contents are encrypted.
   273|      */
   274|     private int $encryptionStartPos = 0;
   275|     /**
   276|      * The current RC4 decryption object.
   277|      *
   278|      * @var ?Xls\RC4
   279|      */
   280|     private ?Xls\RC4 $rc4Key = null;
   281|     /**
   282|      * The position in the stream that the RC4 decryption object was left at.
   283|      */
   284|     private int $rc4Pos = 0;
   285|     /**
   286|      * The current MD5 context state.
   287|      * It is never set in the program, so code which uses it is suspect.
   288|      */
   289|     private string $md5Ctxt; // @phpstan-ignore-line
   290|     private int $textObjRef;
   291|     private string $baseCell;
   292|     private bool $activeSheetSet = false;
   293|     /**
   294|      * Create a new Xls Reader instance.
   295|      */
   296|     public function __construct()
   297|     {
   298|         parent::__construct();
   299|     }
   300|     /**
   301|      * Can the current IReader read the file?
   302|      */
   303|     public function canRead(string $filename): bool
   304|     {
   305|         if (File::testFileNoThrow($filename) === false) {
   306|             return false;
   307|         }
   308|         try {
   309|             $ole = new OLERead();
   310|             $ole->read($filename);
   311|             if ($ole->wrkbook === null) {
   312|                 throw new Exception('The filename ' . $filename . ' is not recognised as a Spreadsheet file');
   313|             }
   314|             return true;
   315|         } catch (PhpSpreadsheetException) {
   316|             return false;
   317|         }
   318|     }
   319|     public function setCodepage(string $codepage): void
   320|     {
   321|         if (CodePage::validate($codepage) === false) {
   322|             throw new PhpSpreadsheetException('Unknown codepage: ' . $codepage);
   323|         }
   324|         $this->codepage = $codepage;
   325|     }
   326|     public function getCodepage(): string
   327|     {
   328|         return $this->codepage;
   329|     }
   330|     /**
   331|      * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
   332|      */
   333|     public function listWorksheetNames(string $filename): array
   334|     {
   335|         File::assertFile($filename);
   336|         $worksheetNames = [];
   337|         $this->loadOLE($filename);
   338|         $this->dataSize = strlen($this->data);
   339|         $this->pos = 0;
   340|         $this->sheets = [];
   341|         while ($this->pos < $this->dataSize) {
   342|             $code = self::getUInt2d($this->data, $this->pos);
   343|             match ($code) {
   344|                 self::XLS_TYPE_BOF => $this->readBof(),
   345|                 self::XLS_TYPE_SHEET => $this->readSheet(),
   346|                 self::XLS_TYPE_EOF => $this->readDefault(),
   347|                 self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
   348|                 default => $this->readDefault(),
   349|             };
   350|             if ($code === self::XLS_TYPE_EOF) {
   351|                 break;
   352|             }
   353|         }
   354|         foreach ($this->sheets as $sheet) {
   355|             if ($sheet['sheetType'] != 0x00) {
   356|                 continue;
   357|             }
   358|             $worksheetNames[] = $sheet['name'];
   359|         }
   360|         return $worksheetNames;
   361|     }
   362|     /**
   363|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   364|      */
   365|     public function listWorksheetInfo(string $filename): array
   366|     {
   367|         File::assertFile($filename);
   368|         $worksheetInfo = [];
   369|         $this->loadOLE($filename);
   370|         $this->dataSize = strlen($this->data);
   371|         $this->pos = 0;
   372|         $this->sheets = [];
   373|         while ($this->pos < $this->dataSize) {
   374|             $code = self::getUInt2d($this->data, $this->pos);
   375|             match ($code) {
   376|                 self::XLS_TYPE_BOF => $this->readBof(),
   377|                 self::XLS_TYPE_SHEET => $this->readSheet(),
   378|                 self::XLS_TYPE_EOF => $this->readDefault(),
   379|                 self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
   380|                 default => $this->readDefault(),
   381|             };
   382|             if ($code === self::XLS_TYPE_EOF) {
   383|                 break;
   384|             }
   385|         }
   386|         foreach ($this->sheets as $sheet) {
   387|             if ($sheet['sheetType'] != 0x00) {
   388|                 continue;
   389|             }
   390|             $tmpInfo = [];
   391|             $tmpInfo['worksheetName'] = $sheet['name'];
   392|             $tmpInfo['lastColumnLetter'] = 'A';
   393|             $tmpInfo['lastColumnIndex'] = 0;
   394|             $tmpInfo['totalRows'] = 0;
   395|             $tmpInfo['totalColumns'] = 0;
   396|             $this->pos = $sheet['offset'];
   397|             while ($this->pos <= $this->dataSize - 4) {
   398|                 $code = self::getUInt2d($this->data, $this->pos);
   399|                 switch ($code) {
   400|                     case self::XLS_TYPE_RK:
   401|                     case self::XLS_TYPE_LABELSST:
   402|                     case self::XLS_TYPE_NUMBER:
   403|                     case self::XLS_TYPE_FORMULA:
   404|                     case self::XLS_TYPE_BOOLERR:
   405|                     case self::XLS_TYPE_LABEL:
   406|                         $length = self::getUInt2d($this->data, $this->pos + 2);
   407|                         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
   408|                         $this->pos += 4 + $length;
   409|                         $rowIndex = self::getUInt2d($recordData, 0) + 1;
   410|                         $columnIndex = self::getUInt2d($recordData, 2);
   411|                         $tmpInfo['totalRows'] = max($tmpInfo['totalRows'], $rowIndex);
   412|                         $tmpInfo['lastColumnIndex'] = max($tmpInfo['lastColumnIndex'], $columnIndex);
   413|                         break;
   414|                     case self::XLS_TYPE_BOF:
   415|                         $this->readBof();
   416|                         break;
   417|                     case self::XLS_TYPE_EOF:
   418|                         $this->readDefault();
   419|                         break 2;
   420|                     default:
   421|                         $this->readDefault();
   422|                         break;
   423|                 }
   424|             }
   425|             $tmpInfo['lastColumnLetter'] = Coordinate::stringFromColumnIndex($tmpInfo['lastColumnIndex'] + 1);
   426|             $tmpInfo['totalColumns'] = $tmpInfo['lastColumnIndex'] + 1;
   427|             $worksheetInfo[] = $tmpInfo;
   428|         }
   429|         return $worksheetInfo;
   430|     }
   431|     /**
   432|      * Loads PhpSpreadsheet from file.
   433|      */
   434|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   435|     {
   436|         $this->loadOLE($filename);
   437|         $this->spreadsheet = new Spreadsheet();
   438|         $this->spreadsheet->removeSheetByIndex(0); // remove 1st sheet
   439|         if (!$this->readDataOnly) {
   440|             $this->spreadsheet->removeCellStyleXfByIndex(0); // remove the default style
   441|             $this->spreadsheet->removeCellXfByIndex(0); // remove the default style
   442|         }
   443|         $this->readSummaryInformation();
   444|         $this->readDocumentSummaryInformation();
   445|         $this->dataSize = strlen($this->data);
   446|         $this->pos = 0;
   447|         $this->codepage = $this->codepage ?: CodePage::DEFAULT_CODE_PAGE;
   448|         $this->formats = [];
   449|         $this->objFonts = [];
   450|         $this->palette = [];
   451|         $this->sheets = [];
   452|         $this->externalBooks = [];
   453|         $this->ref = [];
   454|         $this->definedname = [];
   455|         $this->sst = [];
   456|         $this->drawingGroupData = '';
   457|         $this->xfIndex = 0;
   458|         $this->mapCellXfIndex = [];
   459|         $this->mapCellStyleXfIndex = [];
   460|         while ($this->pos < $this->dataSize) {
   461|             $code = self::getUInt2d($this->data, $this->pos);
   462|             match ($code) {
   463|                 self::XLS_TYPE_BOF => $this->readBof(),
   464|                 self::XLS_TYPE_FILEPASS => $this->readFilepass(),
   465|                 self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
   466|                 self::XLS_TYPE_DATEMODE => $this->readDateMode(),
   467|                 self::XLS_TYPE_FONT => $this->readFont(),
   468|                 self::XLS_TYPE_FORMAT => $this->readFormat(),
   469|                 self::XLS_TYPE_XF => $this->readXf(),
   470|                 self::XLS_TYPE_XFEXT => $this->readXfExt(),
   471|                 self::XLS_TYPE_STYLE => $this->readStyle(),
   472|                 self::XLS_TYPE_PALETTE => $this->readPalette(),
   473|                 self::XLS_TYPE_SHEET => $this->readSheet(),
   474|                 self::XLS_TYPE_EXTERNALBOOK => $this->readExternalBook(),
   475|                 self::XLS_TYPE_EXTERNNAME => $this->readExternName(),
   476|                 self::XLS_TYPE_EXTERNSHEET => $this->readExternSheet(),
   477|                 self::XLS_TYPE_DEFINEDNAME => $this->readDefinedName(),
   478|                 self::XLS_TYPE_MSODRAWINGGROUP => $this->readMsoDrawingGroup(),
   479|                 self::XLS_TYPE_SST => $this->readSst(),
   480|                 self::XLS_TYPE_EOF => $this->readDefault(),
   481|                 default => $this->readDefault(),
   482|             };
   483|             if ($code === self::XLS_TYPE_EOF) {
   484|                 break;
   485|             }
   486|         }
   487|         if (!$this->readDataOnly) {
   488|             foreach ($this->objFonts as $objFont) {
   489|                 if (isset($objFont->colorIndex)) {
   490|                     $color = Xls\Color::map($objFont->colorIndex, $this->palette, $this->version);
   491|                     $objFont->getColor()->setRGB($color['rgb']);
   492|                 }
   493|             }
   494|             foreach ($this->spreadsheet->getCellXfCollection() as $objStyle) {
   495|                 $fill = $objStyle->getFill();
   496|                 if (isset($fill->startcolorIndex)) {
   497|                     $startColor = Xls\Color::map($fill->startcolorIndex, $this->palette, $this->version);
   498|                     $fill->getStartColor()->setRGB($startColor['rgb']);
   499|                 }
   500|                 if (isset($fill->endcolorIndex)) {
   501|                     $endColor = Xls\Color::map($fill->endcolorIndex, $this->palette, $this->version);
   502|                     $fill->getEndColor()->setRGB($endColor['rgb']);
   503|                 }
   504|                 $top = $objStyle->getBorders()->getTop();
   505|                 $right = $objStyle->getBorders()->getRight();
   506|                 $bottom = $objStyle->getBorders()->getBottom();
   507|                 $left = $objStyle->getBorders()->getLeft();
   508|                 $diagonal = $objStyle->getBorders()->getDiagonal();
   509|                 if (isset($top->colorIndex)) {
   510|                     $borderTopColor = Xls\Color::map($top->colorIndex, $this->palette, $this->version);
   511|                     $top->getColor()->setRGB($borderTopColor['rgb']);
   512|                 }
   513|                 if (isset($right->colorIndex)) {
   514|                     $borderRightColor = Xls\Color::map($right->colorIndex, $this->palette, $this->version);
   515|                     $right->getColor()->setRGB($borderRightColor['rgb']);
   516|                 }
   517|                 if (isset($bottom->colorIndex)) {
   518|                     $borderBottomColor = Xls\Color::map($bottom->colorIndex, $this->palette, $this->version);
   519|                     $bottom->getColor()->setRGB($borderBottomColor['rgb']);
   520|                 }
   521|                 if (isset($left->colorIndex)) {
   522|                     $borderLeftColor = Xls\Color::map($left->colorIndex, $this->palette, $this->version);
   523|                     $left->getColor()->setRGB($borderLeftColor['rgb']);
   524|                 }
   525|                 if (isset($diagonal->colorIndex)) {
   526|                     $borderDiagonalColor = Xls\Color::map($diagonal->colorIndex, $this->palette, $this->version);
   527|                     $diagonal->getColor()->setRGB($borderDiagonalColor['rgb']);
   528|                 }
   529|             }
   530|         }
   531|         $escherWorkbook = null;
   532|         if (!$this->readDataOnly && $this->drawingGroupData) {
   533|             $escher = new Escher();
   534|             $reader = new Xls\Escher($escher);
   535|             $escherWorkbook = $reader->load($this->drawingGroupData);
   536|         }
   537|         $this->activeSheetSet = false;
   538|         foreach ($this->sheets as $sheet) {
   539|             $selectedCells = '';
   540|             if ($sheet['sheetType'] != 0x00) {
   541|                 continue;
   542|             }
   543|             if (isset($this->loadSheetsOnly) && !in_array($sheet['name'], $this->loadSheetsOnly)) {
   544|                 continue;
   545|             }
   546|             $this->phpSheet = $this->spreadsheet->createSheet();
   547|             $this->phpSheet->setTitle($sheet['name'], false, false);
   548|             $this->phpSheet->setSheetState($sheet['sheetState']);
   549|             $this->pos = $sheet['offset'];
   550|             $this->isFitToPages = false;
   551|             $this->drawingData = '';
   552|             $this->objs = [];
   553|             $this->sharedFormulaParts = [];
   554|             $this->sharedFormulas = [];
   555|             $this->textObjects = [];
   556|             $this->cellNotes = [];
   557|             $this->textObjRef = -1;
   558|             while ($this->pos <= $this->dataSize - 4) {
   559|                 $code = self::getUInt2d($this->data, $this->pos);
   560|                 switch ($code) {
   561|                     case self::XLS_TYPE_BOF:
   562|                         $this->readBof();
   563|                         break;
   564|                     case self::XLS_TYPE_PRINTGRIDLINES:
   565|                         $this->readPrintGridlines();
   566|                         break;
   567|                     case self::XLS_TYPE_DEFAULTROWHEIGHT:
   568|                         $this->readDefaultRowHeight();
   569|                         break;
   570|                     case self::XLS_TYPE_SHEETPR:
   571|                         $this->readSheetPr();
   572|                         break;
   573|                     case self::XLS_TYPE_HORIZONTALPAGEBREAKS:
   574|                         $this->readHorizontalPageBreaks();
   575|                         break;
   576|                     case self::XLS_TYPE_VERTICALPAGEBREAKS:
   577|                         $this->readVerticalPageBreaks();
   578|                         break;
   579|                     case self::XLS_TYPE_HEADER:
   580|                         $this->readHeader();
   581|                         break;
   582|                     case self::XLS_TYPE_FOOTER:
   583|                         $this->readFooter();
   584|                         break;
   585|                     case self::XLS_TYPE_HCENTER:
   586|                         $this->readHcenter();
   587|                         break;
   588|                     case self::XLS_TYPE_VCENTER:
   589|                         $this->readVcenter();
   590|                         break;
   591|                     case self::XLS_TYPE_LEFTMARGIN:
   592|                         $this->readLeftMargin();
   593|                         break;
   594|                     case self::XLS_TYPE_RIGHTMARGIN:
   595|                         $this->readRightMargin();
   596|                         break;
   597|                     case self::XLS_TYPE_TOPMARGIN:
   598|                         $this->readTopMargin();
   599|                         break;
   600|                     case self::XLS_TYPE_BOTTOMMARGIN:
   601|                         $this->readBottomMargin();
   602|                         break;
   603|                     case self::XLS_TYPE_PAGESETUP:
   604|                         $this->readPageSetup();
   605|                         break;
   606|                     case self::XLS_TYPE_PROTECT:
   607|                         $this->readProtect();
   608|                         break;
   609|                     case self::XLS_TYPE_SCENPROTECT:
   610|                         $this->readScenProtect();
   611|                         break;
   612|                     case self::XLS_TYPE_OBJECTPROTECT:
   613|                         $this->readObjectProtect();
   614|                         break;
   615|                     case self::XLS_TYPE_PASSWORD:
   616|                         $this->readPassword();
   617|                         break;
   618|                     case self::XLS_TYPE_DEFCOLWIDTH:
   619|                         $this->readDefColWidth();
   620|                         break;
   621|                     case self::XLS_TYPE_COLINFO:
   622|                         $this->readColInfo();
   623|                         break;
   624|                     case self::XLS_TYPE_DIMENSION:
   625|                         $this->readDefault();
   626|                         break;
   627|                     case self::XLS_TYPE_ROW:
   628|                         $this->readRow();
   629|                         break;
   630|                     case self::XLS_TYPE_DBCELL:
   631|                         $this->readDefault();
   632|                         break;
   633|                     case self::XLS_TYPE_RK:
   634|                         $this->readRk();
   635|                         break;
   636|                     case self::XLS_TYPE_LABELSST:
   637|                         $this->readLabelSst();
   638|                         break;
   639|                     case self::XLS_TYPE_MULRK:
   640|                         $this->readMulRk();
   641|                         break;
   642|                     case self::XLS_TYPE_NUMBER:
   643|                         $this->readNumber();
   644|                         break;
   645|                     case self::XLS_TYPE_FORMULA:
   646|                         $this->readFormula();
   647|                         break;
   648|                     case self::XLS_TYPE_SHAREDFMLA:
   649|                         $this->readSharedFmla();
   650|                         break;
   651|                     case self::XLS_TYPE_BOOLERR:
   652|                         $this->readBoolErr();
   653|                         break;
   654|                     case self::XLS_TYPE_MULBLANK:
   655|                         $this->readMulBlank();
   656|                         break;
   657|                     case self::XLS_TYPE_LABEL:
   658|                         $this->readLabel();
   659|                         break;
   660|                     case self::XLS_TYPE_BLANK:
   661|                         $this->readBlank();
   662|                         break;
   663|                     case self::XLS_TYPE_MSODRAWING:
   664|                         $this->readMsoDrawing();
   665|                         break;
   666|                     case self::XLS_TYPE_OBJ:
   667|                         $this->readObj();
   668|                         break;
   669|                     case self::XLS_TYPE_WINDOW2:
   670|                         $this->readWindow2();
   671|                         break;
   672|                     case self::XLS_TYPE_PAGELAYOUTVIEW:
   673|                         $this->readPageLayoutView();
   674|                         break;
   675|                     case self::XLS_TYPE_SCL:
   676|                         $this->readScl();
   677|                         break;
   678|                     case self::XLS_TYPE_PANE:
   679|                         $this->readPane();
   680|                         break;
   681|                     case self::XLS_TYPE_SELECTION:
   682|                         $selectedCells = $this->readSelection();
   683|                         break;
   684|                     case self::XLS_TYPE_MERGEDCELLS:
   685|                         $this->readMergedCells();
   686|                         break;
   687|                     case self::XLS_TYPE_HYPERLINK:
   688|                         $this->readHyperLink();
   689|                         break;
   690|                     case self::XLS_TYPE_DATAVALIDATIONS:
   691|                         $this->readDataValidations();
   692|                         break;
   693|                     case self::XLS_TYPE_DATAVALIDATION:
   694|                         $this->readDataValidation();
   695|                         break;
   696|                     case self::XLS_TYPE_CFHEADER:
   697|                         $cellRangeAddresses = $this->readCFHeader();
   698|                         break;
   699|                     case self::XLS_TYPE_CFRULE:
   700|                         $this->readCFRule($cellRangeAddresses ?? []);
   701|                         break;
   702|                     case self::XLS_TYPE_SHEETLAYOUT:
   703|                         $this->readSheetLayout();
   704|                         break;
   705|                     case self::XLS_TYPE_SHEETPROTECTION:
   706|                         $this->readSheetProtection();
   707|                         break;
   708|                     case self::XLS_TYPE_RANGEPROTECTION:
   709|                         $this->readRangeProtection();
   710|                         break;
   711|                     case self::XLS_TYPE_NOTE:
   712|                         $this->readNote();
   713|                         break;
   714|                     case self::XLS_TYPE_TXO:
   715|                         $this->readTextObject();
   716|                         break;
   717|                     case self::XLS_TYPE_CONTINUE:
   718|                         $this->readContinue();
   719|                         break;
   720|                     case self::XLS_TYPE_EOF:
   721|                         $this->readDefault();
   722|                         break 2;
   723|                     default:
   724|                         $this->readDefault();
   725|                         break;
   726|                 }
   727|             }
   728|             if (!$this->readDataOnly && $this->drawingData) {
   729|                 $escherWorksheet = new Escher();
   730|                 $reader = new Xls\Escher($escherWorksheet);
   731|                 $escherWorksheet = $reader->load($this->drawingData);
   732|                 /** @var SpContainer[] $allSpContainers */
   733|                 $allSpContainers = method_exists($escherWorksheet, 'getDgContainer') ? $escherWorksheet->getDgContainer()->getSpgrContainer()->getAllSpContainers() : [];
   734|             }
   735|             foreach ($this->objs as $n => $obj) {
   736|                 if (isset($allSpContainers[$n + 1])) {
   737|                     $spContainer = $allSpContainers[$n + 1];
   738|                     if ($spContainer->getNestingLevel() > 1) {
   739|                         continue;
   740|                     }
   741|                     /** @var int $startRow */
   742|                     [$startColumn, $startRow] = Coordinate::coordinateFromString($spContainer->getStartCoordinates());
   743|                     /** @var int $endRow */
   744|                     [$endColumn, $endRow] = Coordinate::coordinateFromString($spContainer->getEndCoordinates());
   745|                     $startOffsetX = $spContainer->getStartOffsetX();
   746|                     $startOffsetY = $spContainer->getStartOffsetY();
   747|                     $endOffsetX = $spContainer->getEndOffsetX();
   748|                     $endOffsetY = $spContainer->getEndOffsetY();
   749|                     $width = SharedXls::getDistanceX($this->phpSheet, $startColumn, $startOffsetX, $endColumn, $endOffsetX);
   750|                     $height = SharedXls::getDistanceY($this->phpSheet, $startRow, $startOffsetY, $endRow, $endOffsetY);
   751|                     $offsetX = (int) ($startOffsetX * SharedXls::sizeCol($this->phpSheet, $startColumn) / 1024);
   752|                     $offsetY = (int) ($startOffsetY * SharedXls::sizeRow($this->phpSheet, $startRow) / 256);
   753|                     switch ($obj['otObjType']) {
   754|                         case 0x19:
   755|                             if (isset($this->cellNotes[$obj['idObjID']])) {
   756|                                 if (isset($this->textObjects[$obj['idObjID']])) {
   757|                                     $textObject = $this->textObjects[$obj['idObjID']];
   758|                                     $this->cellNotes[$obj['idObjID']]['objTextData'] = $textObject;
   759|                                 }
   760|                             }
   761|                             break;
   762|                         case 0x08:
   763|                             $BSEindex = $spContainer->getOPT(0x0104);
   764|                             if (!$BSEindex) {
   765|                                 continue 2;
   766|                             }
   767|                             if ($escherWorkbook) {
   768|                                 $BSECollection = method_exists($escherWorkbook, 'getDggContainer') ? $escherWorkbook->getDggContainer()->getBstoreContainer()->getBSECollection() : [];
   769|                                 $BSE = $BSECollection[$BSEindex - 1];
   770|                                 $blipType = $BSE->getBlipType();
   771|                                 if ($blip = $BSE->getBlip()) {
   772|                                     $ih = imagecreatefromstring($blip->getData());
   773|                                     if ($ih !== false) {
   774|                                         $drawing = new MemoryDrawing();
   775|                                         $drawing->setImageResource($ih);
   776|                                         $drawing->setResizeProportional(false);
   777|                                         $drawing->setWidth($width);
   778|                                         $drawing->setHeight($height);
   779|                                         $drawing->setOffsetX($offsetX);
   780|                                         $drawing->setOffsetY($offsetY);
   781|                                         switch ($blipType) {
   782|                                             case BSE::BLIPTYPE_JPEG:
   783|                                                 $drawing->setRenderingFunction(MemoryDrawing::RENDERING_JPEG);
   784|                                                 $drawing->setMimeType(MemoryDrawing::MIMETYPE_JPEG);
   785|                                                 break;
   786|                                             case BSE::BLIPTYPE_PNG:
   787|                                                 imagealphablending($ih, false);
   788|                                                 imagesavealpha($ih, true);
   789|                                                 $drawing->setRenderingFunction(MemoryDrawing::RENDERING_PNG);
   790|                                                 $drawing->setMimeType(MemoryDrawing::MIMETYPE_PNG);
   791|                                                 break;
   792|                                         }
   793|                                         $drawing->setWorksheet($this->phpSheet);
   794|                                         $drawing->setCoordinates($spContainer->getStartCoordinates());
   795|                                     }
   796|                                 }
   797|                             }
   798|                             break;
   799|                         default:
   800|                             break;
   801|                     }
   802|                 }
   803|             }
   804|             if ($this->version == self::XLS_BIFF8) {
   805|                 foreach ($this->sharedFormulaParts as $cell => $baseCell) {
   806|                     /** @var int $row */
   807|                     [$column, $row] = Coordinate::coordinateFromString($cell);
   808|                     if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($column, $row, $this->phpSheet->getTitle())) {
   809|                         $formula = $this->getFormulaFromStructure($this->sharedFormulas[$baseCell], $cell);
   810|                         $this->phpSheet->getCell($cell)->setValueExplicit('=' . $formula, DataType::TYPE_FORMULA);
   811|                     }
   812|                 }
   813|             }
   814|             if (!empty($this->cellNotes)) {
   815|                 foreach ($this->cellNotes as $note => $noteDetails) {
   816|                     if (!isset($noteDetails['objTextData'])) {
   817|                         if (isset($this->textObjects[$note])) {
   818|                             $textObject = $this->textObjects[$note];
   819|                             $noteDetails['objTextData'] = $textObject;
   820|                         } else {
   821|                             $noteDetails['objTextData']['text'] = '';
   822|                         }
   823|                     }
   824|                     $cellAddress = str_replace('$', '', $noteDetails['cellRef']);
   825|                     $this->phpSheet->getComment($cellAddress)->setAuthor($noteDetails['author'])->setText($this->parseRichText($noteDetails['objTextData']['text']));
   826|                 }
   827|             }
   828|             if ($selectedCells !== '') {
   829|                 $this->phpSheet->setSelectedCells($selectedCells);
   830|             }
   831|         }
   832|         if ($this->activeSheetSet === false) {
   833|             $this->spreadsheet->setActiveSheetIndex(0);
   834|         }
   835|         foreach ($this->definedname as $definedName) {
   836|             if ($definedName['isBuiltInName']) {
   837|                 switch ($definedName['name']) {
   838|                     case pack('C', 0x06):
   839|                         $ranges = explode(',', $definedName['formula']); // FIXME: what if sheetname contains comma?
   840|                         $extractedRanges = [];
   841|                         $sheetName = '';
   842|                         /** @var non-empty-string $range */
   843|                         foreach ($ranges as $range) {
   844|                             $explodes = Worksheet::extractSheetTitle($range, true);
   845|                             $sheetName = trim($explodes[0], "'");
   846|                             if (!str_contains($explodes[1], ':')) {
   847|                                 $explodes[1] = $explodes[1] . ':' . $explodes[1];
   848|                             }
   849|                             $extractedRanges[] = str_replace('$', '', $explodes[1]); // C7:J66
   850|                         }
   851|                         if ($docSheet = $this->spreadsheet->getSheetByName($sheetName)) {
   852|                             $docSheet->getPageSetup()->setPrintArea(implode(',', $extractedRanges)); // C7:J66,A1:IV2
   853|                         }
   854|                         break;
   855|                     case pack('C', 0x07):
   856|                         $ranges = explode(',', $definedName['formula']); // FIXME: what if sheetname contains comma?
   857|                         foreach ($ranges as $range) {
   858|                             if (str_contains($range, '!')) {
   859|                                 $explodes = Worksheet::extractSheetTitle($range, true);
   860|                                 if ($docSheet = $this->spreadsheet->getSheetByName($explodes[0])) {
   861|                                     $extractedRange = $explodes[1];
   862|                                     $extractedRange = str_replace('$', '', $extractedRange);
   863|                                     $coordinateStrings = explode(':', $extractedRange);
   864|                                     if (count($coordinateStrings) == 2) {
   865|                                         [$firstColumn, $firstRow] = Coordinate::coordinateFromString($coordinateStrings[0]);
   866|                                         [$lastColumn, $lastRow] = Coordinate::coordinateFromString($coordinateStrings[1]);
   867|                                         if ($firstColumn == 'A' && $lastColumn == 'IV') {
   868|                                             $docSheet->getPageSetup()->setRowsToRepeatAtTop([$firstRow, $lastRow]);
   869|                                         } elseif ($firstRow == 1 && $lastRow == 65536) {
   870|                                             $docSheet->getPageSetup()->setColumnsToRepeatAtLeft([$firstColumn, $lastColumn]);
   871|                                         }
   872|                                     }
   873|                                 }
   874|                             }
   875|                         }
   876|                         break;
   877|                 }
   878|             } else {
   879|                 /** @var non-empty-string $formula */
   880|                 $formula = $definedName['formula'];
   881|                 if (str_contains($formula, '!')) {
   882|                     $explodes = Worksheet::extractSheetTitle($formula, true);
   883|                     if (
   884|                         ($docSheet = $this->spreadsheet->getSheetByName($explodes[0]))
   885|                         || ($docSheet = $this->spreadsheet->getSheetByName(trim($explodes[0], "'")))
   886|                     ) {
   887|                         $extractedRange = $explodes[1];
   888|                         $localOnly = ($definedName['scope'] === 0) ? false : true;
   889|                         $scope = ($definedName['scope'] === 0) ? null : $this->spreadsheet->getSheetByName($this->sheets[$definedName['scope'] - 1]['name']);
   890|                         $this->spreadsheet->addNamedRange(new NamedRange((string) $definedName['name'], $docSheet, $extractedRange, $localOnly, $scope));
   891|                     }
   892|                 }
   893|             }
   894|         }
   895|         $this->data = '';
   896|         return $this->spreadsheet;
   897|     }
   898|     /**
   899|      * Read record data from stream, decrypting as required.
   900|      *
   901|      * @param string $data Data stream to read from
   902|      * @param int $pos Position to start reading from
   903|      * @param int $len Record data length
   904|      *
   905|      * @return string Record data
   906|      */
   907|     private function readRecordData(string $data, int $pos, int $len): string
   908|     {
   909|         $data = substr($data, $pos, $len);
   910|         if ($this->encryption == self::MS_BIFF_CRYPTO_NONE || $pos < $this->encryptionStartPos) {
   911|             return $data;
   912|         }
   913|         $recordData = '';
   914|         if ($this->encryption == self::MS_BIFF_CRYPTO_RC4) {
   915|             $oldBlock = floor($this->rc4Pos / self::REKEY_BLOCK);
   916|             $block = (int) floor($pos / self::REKEY_BLOCK);
   917|             $endBlock = (int) floor(($pos + $len) / self::REKEY_BLOCK);
   918|             if ($block != $oldBlock || $pos < $this->rc4Pos || !$this->rc4Key) {
   919|                 $this->rc4Key = $this->makeKey($block, $this->md5Ctxt);
   920|                 $step = $pos % self::REKEY_BLOCK;
   921|             } else {
   922|                 $step = $pos - $this->rc4Pos;
   923|             }
   924|             $this->rc4Key->RC4(str_repeat("\0", $step));
   925|             while ($block != $endBlock) {
   926|                 $step = self::REKEY_BLOCK - ($pos % self::REKEY_BLOCK);
   927|                 $recordData .= $this->rc4Key->RC4(substr($data, 0, $step));
   928|                 $data = substr($data, $step);
   929|                 $pos += $step;
   930|                 $len -= $step;
   931|                 ++$block;
   932|                 $this->rc4Key = $this->makeKey($block, $this->md5Ctxt);
   933|             }
   934|             $recordData .= $this->rc4Key->RC4(substr($data, 0, $len));
   935|             $this->rc4Pos = $pos + $len;
   936|         } elseif ($this->encryption == self::MS_BIFF_CRYPTO_XOR) {
   937|             throw new Exception('XOr encryption not supported');
   938|         }
   939|         return $recordData;
   940|     }
   941|     /**
   942|      * Use OLE reader to extract the relevant data streams from the OLE file.
   943|      */
   944|     private function loadOLE(string $filename): void
   945|     {
   946|         $ole = new OLERead();
   947|         $ole->read($filename);
   948|         $this->data = $ole->getStream($ole->wrkbook); // @phpstan-ignore-line
   949|         $this->summaryInformation = $ole->getStream($ole->summaryInformation);
   950|         $this->documentSummaryInformation = $ole->getStream($ole->documentSummaryInformation);
   951|     }
   952|     /**
   953|      * Read summary information.
   954|      */
   955|     private function readSummaryInformation(): void
   956|     {
   957|         if (!isset($this->summaryInformation)) {
   958|             return;
   959|         }
   960|         $secOffset = self::getInt4d($this->summaryInformation, 44);
   961|         $countProperties = self::getInt4d($this->summaryInformation, $secOffset + 4);
   962|         $codePage = 'CP1252';
   963|         for ($i = 0; $i < $countProperties; ++$i) {
   964|             $id = self::getInt4d($this->summaryInformation, ($secOffset + 8) + (8 * $i));
   965|             $offset = self::getInt4d($this->summaryInformation, ($secOffset + 12) + (8 * $i));
   966|             $type = self::getInt4d($this->summaryInformation, $secOffset + $offset);
   967|             $value = null;
   968|             switch ($type) {
   969|                 case 0x02: // 2 byte signed integer
   970|                     $value = self::getUInt2d($this->summaryInformation, $secOffset + 4 + $offset);
   971|                     break;
   972|                 case 0x03: // 4 byte signed integer
   973|                     $value = self::getInt4d($this->summaryInformation, $secOffset + 4 + $offset);
   974|                     break;
   975|                 case 0x13: // 4 byte unsigned integer
   976|                     break;
   977|                 case 0x1E: // null-terminated string prepended by dword string length
   978|                     $byteLength = self::getInt4d($this->summaryInformation, $secOffset + 4 + $offset);
   979|                     $value = substr($this->summaryInformation, $secOffset + 8 + $offset, $byteLength);
   980|                     $value = StringHelper::convertEncoding($value, 'UTF-8', $codePage);
   981|                     $value = rtrim($value);
   982|                     break;
   983|                 case 0x40: // Filetime (64-bit value representing the number of 100-nanosecond intervals since January 1, 1601)
   984|                     $value = OLE::OLE2LocalDate(substr($this->summaryInformation, $secOffset + 4 + $offset, 8));
   985|                     break;
   986|                 case 0x47: // Clipboard format
   987|                     break;
   988|             }
   989|             switch ($id) {
   990|                 case 0x01:    //    Code Page
   991|                     $codePage = CodePage::numberToName((int) $value);
   992|                     break;
   993|                 case 0x02:    //    Title
   994|                     $this->spreadsheet->getProperties()->setTitle("$value");
   995|                     break;
   996|                 case 0x03:    //    Subject
   997|                     $this->spreadsheet->getProperties()->setSubject("$value");
   998|                     break;
   999|                 case 0x04:    //    Author (Creator)
  1000|                     $this->spreadsheet->getProperties()->setCreator("$value");
  1001|                     break;
  1002|                 case 0x05:    //    Keywords
  1003|                     $this->spreadsheet->getProperties()->setKeywords("$value");
  1004|                     break;
  1005|                 case 0x06:    //    Comments (Description)
  1006|                     $this->spreadsheet->getProperties()->setDescription("$value");
  1007|                     break;
  1008|                 case 0x07:    //    Template
  1009|                     break;
  1010|                 case 0x08:    //    Last Saved By (LastModifiedBy)
  1011|                     $this->spreadsheet->getProperties()->setLastModifiedBy("$value");
  1012|                     break;
  1013|                 case 0x09:    //    Revision
  1014|                     break;
  1015|                 case 0x0A:    //    Total Editing Time
  1016|                     break;
  1017|                 case 0x0B:    //    Last Printed
  1018|                     break;
  1019|                 case 0x0C:    //    Created Date/Time
  1020|                     $this->spreadsheet->getProperties()->setCreated($value);
  1021|                     break;
  1022|                 case 0x0D:    //    Modified Date/Time
  1023|                     $this->spreadsheet->getProperties()->setModified($value);
  1024|                     break;
  1025|                 case 0x0E:    //    Number of Pages
  1026|                     break;
  1027|                 case 0x0F:    //    Number of Words
  1028|                     break;
  1029|                 case 0x10:    //    Number of Characters
  1030|                     break;
  1031|                 case 0x11:    //    Thumbnail
  1032|                     break;
  1033|                 case 0x12:    //    Name of creating application
  1034|                     break;
  1035|                 case 0x13:    //    Security
  1036|                     break;
  1037|             }
  1038|         }
  1039|     }
  1040|     /**
  1041|      * Read additional document summary information.
  1042|      */
  1043|     private function readDocumentSummaryInformation(): void
  1044|     {
  1045|         if (!isset($this->documentSummaryInformation)) {
  1046|             return;
  1047|         }
  1048|         $secOffset = self::getInt4d($this->documentSummaryInformation, 44);
  1049|         $countProperties = self::getInt4d($this->documentSummaryInformation, $secOffset + 4);
  1050|         $codePage = 'CP1252';
  1051|         for ($i = 0; $i < $countProperties; ++$i) {
  1052|             $id = self::getInt4d($this->documentSummaryInformation, ($secOffset + 8) + (8 * $i));
  1053|             $offset = self::getInt4d($this->documentSummaryInformation, ($secOffset + 12) + (8 * $i));
  1054|             $type = self::getInt4d($this->documentSummaryInformation, $secOffset + $offset);
  1055|             $value = null;
  1056|             switch ($type) {
  1057|                 case 0x02:    //    2 byte signed integer
  1058|                     $value = self::getUInt2d($this->documentSummaryInformation, $secOffset + 4 + $offset);
  1059|                     break;
  1060|                 case 0x03:    //    4 byte signed integer
  1061|                     $value = self::getInt4d($this->documentSummaryInformation, $secOffset + 4 + $offset);
  1062|                     break;
  1063|                 case 0x0B:  // Boolean
  1064|                     $value = self::getUInt2d($this->documentSummaryInformation, $secOffset + 4 + $offset);
  1065|                     $value = ($value == 0 ? false : true);
  1066|                     break;
  1067|                 case 0x13:    //    4 byte unsigned integer
  1068|                     break;
  1069|                 case 0x1E:    //    null-terminated string prepended by dword string length
  1070|                     $byteLength = self::getInt4d($this->documentSummaryInformation, $secOffset + 4 + $offset);
  1071|                     $value = substr($this->documentSummaryInformation, $secOffset + 8 + $offset, $byteLength);
  1072|                     $value = StringHelper::convertEncoding($value, 'UTF-8', $codePage);
  1073|                     $value = rtrim($value);
  1074|                     break;
  1075|                 case 0x40:    //    Filetime (64-bit value representing the number of 100-nanosecond intervals since January 1, 1601)
  1076|                     $value = OLE::OLE2LocalDate(substr($this->documentSummaryInformation, $secOffset + 4 + $offset, 8));
  1077|                     break;
  1078|                 case 0x47:    //    Clipboard format
  1079|                     break;
  1080|             }
  1081|             switch ($id) {
  1082|                 case 0x01:    //    Code Page
  1083|                     $codePage = CodePage::numberToName((int) $value);
  1084|                     break;
  1085|                 case 0x02:    //    Category
  1086|                     $this->spreadsheet->getProperties()->setCategory("$value");
  1087|                     break;
  1088|                 case 0x03:    //    Presentation Target
  1089|                     break;
  1090|                 case 0x04:    //    Bytes
  1091|                     break;
  1092|                 case 0x05:    //    Lines
  1093|                     break;
  1094|                 case 0x06:    //    Paragraphs
  1095|                     break;
  1096|                 case 0x07:    //    Slides
  1097|                     break;
  1098|                 case 0x08:    //    Notes
  1099|                     break;
  1100|                 case 0x09:    //    Hidden Slides
  1101|                     break;
  1102|                 case 0x0A:    //    MM Clips
  1103|                     break;
  1104|                 case 0x0B:    //    Scale Crop
  1105|                     break;
  1106|                 case 0x0C:    //    Heading Pairs
  1107|                     break;
  1108|                 case 0x0D:    //    Titles of Parts
  1109|                     break;
  1110|                 case 0x0E:    //    Manager
  1111|                     $this->spreadsheet->getProperties()->setManager("$value");
  1112|                     break;
  1113|                 case 0x0F:    //    Company
  1114|                     $this->spreadsheet->getProperties()->setCompany("$value");
  1115|                     break;
  1116|                 case 0x10:    //    Links up-to-date
  1117|                     break;
  1118|             }
  1119|         }
  1120|     }
  1121|     /**
  1122|      * Reads a general type of BIFF record. Does nothing except for moving stream pointer forward to next record.
  1123|      */
  1124|     private function readDefault(): void
  1125|     {
  1126|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1127|         $this->pos += 4 + $length;
  1128|     }
  1129|     /**
  1130|      *    The NOTE record specifies a comment associated with a particular cell. In Excel 95 (BIFF7) and earlier versions,
  1131|      *        this record stores a note (cell note). This feature was significantly enhanced in Excel 97.
  1132|      */
  1133|     private function readNote(): void
  1134|     {
  1135|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1136|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1137|         $this->pos += 4 + $length;
  1138|         if ($this->readDataOnly) {
  1139|             return;
  1140|         }
  1141|         $cellAddress = $this->readBIFF8CellAddress(substr($recordData, 0, 4));
  1142|         if ($this->version == self::XLS_BIFF8) {
  1143|             $noteObjID = self::getUInt2d($recordData, 6);
  1144|             $noteAuthor = self::readUnicodeStringLong(substr($recordData, 8));
  1145|             $noteAuthor = $noteAuthor['value'];
  1146|             $this->cellNotes[$noteObjID] = [
  1147|                 'cellRef' => $cellAddress,
  1148|                 'objectID' => $noteObjID,
  1149|                 'author' => $noteAuthor,
  1150|             ];
  1151|         } else {
  1152|             $extension = false;
  1153|             if ($cellAddress == '$B$65536') {
  1154|                 $extension = true;
  1155|                 $arrayKeys = array_keys($this->phpSheet->getComments());
  1156|                 $cellAddress = array_pop($arrayKeys);
  1157|             }
  1158|             $cellAddress = str_replace('$', '', (string) $cellAddress);
  1159|             $noteText = trim(substr($recordData, 6));
  1160|             if ($extension) {
  1161|                 $comment = $this->phpSheet->getComment($cellAddress);
  1162|                 $commentText = $comment->getText()->getPlainText();
  1163|                 $comment->setText($this->parseRichText($commentText . $noteText));
  1164|             } else {
  1165|                 $this->phpSheet->getComment($cellAddress)->setText($this->parseRichText($noteText));
  1166|             }
  1167|         }
  1168|     }
  1169|     /**
  1170|      * The TEXT Object record contains the text associated with a cell annotation.
  1171|      */
  1172|     private function readTextObject(): void
  1173|     {
  1174|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1175|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1176|         $this->pos += 4 + $length;
  1177|         if ($this->readDataOnly) {
  1178|             return;
  1179|         }
  1180|         $grbitOpts = self::getUInt2d($recordData, 0);
  1181|         $rot = self::getUInt2d($recordData, 2);
  1182|         $cbRuns = self::getUInt2d($recordData, 12);
  1183|         $text = $this->getSplicedRecordData();
  1184|         $textByte = $text['spliceOffsets'][1] - $text['spliceOffsets'][0] - 1;
  1185|         $textStr = substr($text['recordData'], $text['spliceOffsets'][0] + 1, $textByte);
  1186|         $is16Bit = ord($text['recordData'][0]);
  1187|         if (($is16Bit & 0x01) === 0) {
  1188|             $textStr = StringHelper::ConvertEncoding($textStr, 'UTF-8', 'ISO-8859-1');
  1189|         } else {
  1190|             $textStr = $this->decodeCodepage($textStr);
  1191|         }
  1192|         $this->textObjects[$this->textObjRef] = [
  1193|             'text' => $textStr,
  1194|             'format' => substr($text['recordData'], $text['spliceOffsets'][1], $cbRuns),
  1195|             'alignment' => $grbitOpts,
  1196|             'rotation' => $rot,
  1197|         ];
  1198|     }
  1199|     /**
  1200|      * Read BOF.
  1201|      */
  1202|     private function readBof(): void
  1203|     {
  1204|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1205|         $recordData = substr($this->data, $this->pos + 4, $length);
  1206|         $this->pos += 4 + $length;
  1207|         $substreamType = self::getUInt2d($recordData, 2);
  1208|         switch ($substreamType) {
  1209|             case self::XLS_WORKBOOKGLOBALS:
  1210|                 $version = self::getUInt2d($recordData, 0);
  1211|                 if (($version != self::XLS_BIFF8) && ($version != self::XLS_BIFF7)) {
  1212|                     throw new Exception('Cannot read this Excel file. Version is too old.');
  1213|                 }
  1214|                 $this->version = $version;
  1215|                 break;
  1216|             case self::XLS_WORKSHEET:
  1217|                 break;
  1218|             default:
  1219|                 do {
  1220|                     $code = self::getUInt2d($this->data, $this->pos);
  1221|                     $this->readDefault();
  1222|                 } while ($code != self::XLS_TYPE_EOF && $this->pos < $this->dataSize);
  1223|                 break;
  1224|         }
  1225|     }
  1226|     /**
  1227|      * FILEPASS.
  1228|      *
  1229|      * This record is part of the File Protection Block. It
  1230|      * contains information about the read/write password of the
  1231|      * file. All record contents following this record will be
  1232|      * encrypted.
  1233|      *
  1234|      * --    "OpenOffice.org's Documentation of the Microsoft
  1235|      *         Excel File Format"
  1236|      *
  1237|      * The decryption functions and objects used from here on in
  1238|      * are based on the source of Spreadsheet-ParseExcel:
  1239|      * https://metacpan.org/release/Spreadsheet-ParseExcel
  1240|      */
  1241|     private function readFilepass(): void
  1242|     {
  1243|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1244|         if ($length != 54) {
  1245|             throw new Exception('Unexpected file pass record length');
  1246|         }
  1247|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1248|         $this->pos += 4 + $length;
  1249|         if (!$this->verifyPassword('VelvetSweatshop', substr($recordData, 6, 16), substr($recordData, 22, 16), substr($recordData, 38, 16), $this->md5Ctxt)) {
  1250|             throw new Exception('Decryption password incorrect');
  1251|         }
  1252|         $this->encryption = self::MS_BIFF_CRYPTO_RC4;
  1253|         $this->encryptionStartPos = $this->pos + self::getUInt2d($this->data, $this->pos + 2);
  1254|     }
  1255|     /**
  1256|      * Make an RC4 decryptor for the given block.
  1257|      *
  1258|      * @param int $block Block for which to create decrypto
  1259|      * @param string $valContext MD5 context state
  1260|      */
  1261|     private function makeKey(int $block, string $valContext): Xls\RC4
  1262|     {
  1263|         $pwarray = str_repeat("\0", 64);
  1264|         for ($i = 0; $i < 5; ++$i) {
  1265|             $pwarray[$i] = $valContext[$i];
  1266|         }
  1267|         $pwarray[5] = chr($block & 0xFF);
  1268|         $pwarray[6] = chr(($block >> 8) & 0xFF);
  1269|         $pwarray[7] = chr(($block >> 16) & 0xFF);
  1270|         $pwarray[8] = chr(($block >> 24) & 0xFF);
  1271|         $pwarray[9] = "\x80";
  1272|         $pwarray[56] = "\x48";
  1273|         $md5 = new Xls\MD5();
  1274|         $md5->add($pwarray);
  1275|         $s = $md5->getContext();
  1276|         return new Xls\RC4($s);
  1277|     }
  1278|     /**
  1279|      * Verify RC4 file password.
  1280|      *
  1281|      * @param string $password Password to check
  1282|      * @param string $docid Document id
  1283|      * @param string $salt_data Salt data
  1284|      * @param string $hashedsalt_data Hashed salt data
  1285|      * @param string $valContext Set to the MD5 context of the value
  1286|      *
  1287|      * @return bool Success
  1288|      */
  1289|     private function verifyPassword(string $password, string $docid, string $salt_data, string $hashedsalt_data, string &$valContext): bool
  1290|     {
  1291|         $pwarray = str_repeat("\0", 64);
  1292|         $iMax = strlen($password);
  1293|         for ($i = 0; $i < $iMax; ++$i) {
  1294|             $o = ord(substr($password, $i, 1));
  1295|             $pwarray[2 * $i] = chr($o & 0xFF);
  1296|             $pwarray[2 * $i + 1] = chr(($o >> 8) & 0xFF);
  1297|         }
  1298|         $pwarray[2 * $i] = chr(0x80);
  1299|         $pwarray[56] = chr(($i << 4) & 0xFF);
  1300|         $md5 = new Xls\MD5();
  1301|         $md5->add($pwarray);
  1302|         $mdContext1 = $md5->getContext();
  1303|         $offset = 0;
  1304|         $keyoffset = 0;
  1305|         $tocopy = 5;
  1306|         $md5->reset();
  1307|         while ($offset != 16) {
  1308|             if ((64 - $offset) < 5) {
  1309|                 $tocopy = 64 - $offset;
  1310|             }
  1311|             for ($i = 0; $i <= $tocopy; ++$i) {
  1312|                 $pwarray[$offset + $i] = $mdContext1[$keyoffset + $i];
  1313|             }
  1314|             $offset += $tocopy;
  1315|             if ($offset == 64) {
  1316|                 $md5->add($pwarray);
  1317|                 $keyoffset = $tocopy;
  1318|                 $tocopy = 5 - $tocopy;
  1319|                 $offset = 0;
  1320|                 continue;
  1321|             }
  1322|             $keyoffset = 0;
  1323|             $tocopy = 5;
  1324|             for ($i = 0; $i < 16; ++$i) {
  1325|                 $pwarray[$offset + $i] = $docid[$i];
  1326|             }
  1327|             $offset += 16;
  1328|         }
  1329|         $pwarray[16] = "\x80";
  1330|         for ($i = 0; $i < 47; ++$i) {
  1331|             $pwarray[17 + $i] = "\0";
  1332|         }
  1333|         $pwarray[56] = "\x80";
  1334|         $pwarray[57] = "\x0a";
  1335|         $md5->add($pwarray);
  1336|         $valContext = $md5->getContext();
  1337|         $key = $this->makeKey(0, $valContext);
  1338|         $salt = $key->RC4($salt_data);
  1339|         $hashedsalt = $key->RC4($hashedsalt_data);
  1340|         $salt .= "\x80" . str_repeat("\0", 47);
  1341|         $salt[56] = "\x80";
  1342|         $md5->reset();
  1343|         $md5->add($salt);
  1344|         $mdContext2 = $md5->getContext();
  1345|         return $mdContext2 == $hashedsalt;
  1346|     }
  1347|     /**
  1348|      * CODEPAGE.
  1349|      *
  1350|      * This record stores the text encoding used to write byte
  1351|      * strings, stored as MS Windows code page identifier.
  1352|      *
  1353|      * --    "OpenOffice.org's Documentation of the Microsoft
  1354|      *         Excel File Format"
  1355|      */
  1356|     private function readCodepage(): void
  1357|     {
  1358|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1359|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1360|         $this->pos += 4 + $length;
  1361|         $codepage = self::getUInt2d($recordData, 0);
  1362|         $this->codepage = CodePage::numberToName($codepage);
  1363|     }
  1364|     /**
  1365|      * DATEMODE.
  1366|      *
  1367|      * This record specifies the base date for displaying date
  1368|      * values. All dates are stored as count of days past this
  1369|      * base date. In BIFF2-BIFF4 this record is part of the
  1370|      * Calculation Settings Block. In BIFF5-BIFF8 it is
  1371|      * stored in the Workbook Globals Substream.
  1372|      *
  1373|      * --    "OpenOffice.org's Documentation of the Microsoft
  1374|      *         Excel File Format"
  1375|      */
  1376|     private function readDateMode(): void
  1377|     {
  1378|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1379|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1380|         $this->pos += 4 + $length;
  1381|         Date::setExcelCalendar(Date::CALENDAR_WINDOWS_1900);
  1382|         $this->spreadsheet->setExcelCalendar(Date::CALENDAR_WINDOWS_1900);
  1383|         if (ord($recordData[0]) == 1) {
  1384|             Date::setExcelCalendar(Date::CALENDAR_MAC_1904);
  1385|             $this->spreadsheet->setExcelCalendar(Date::CALENDAR_MAC_1904);
  1386|         }
  1387|     }
  1388|     /**
  1389|      * Read a FONT record.
  1390|      */
  1391|     private function readFont(): void
  1392|     {
  1393|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1394|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1395|         $this->pos += 4 + $length;
  1396|         if (!$this->readDataOnly) {
  1397|             $objFont = new Font();
  1398|             $size = self::getUInt2d($recordData, 0);
  1399|             $objFont->setSize($size / 20);
  1400|             $isItalic = (0x0002 & self::getUInt2d($recordData, 2)) >> 1;
  1401|             if ($isItalic) {
  1402|                 $objFont->setItalic(true);
  1403|             }
  1404|             $isStrike = (0x0008 & self::getUInt2d($recordData, 2)) >> 3;
  1405|             if ($isStrike) {
  1406|                 $objFont->setStrikethrough(true);
  1407|             }
  1408|             $colorIndex = self::getUInt2d($recordData, 4);
  1409|             $objFont->colorIndex = $colorIndex;
  1410|             $weight = self::getUInt2d($recordData, 6); // regular=400 bold=700
  1411|             if ($weight >= 550) {
  1412|                 $objFont->setBold(true);
  1413|             }
  1414|             $escapement = self::getUInt2d($recordData, 8);
  1415|             CellFont::escapement($objFont, $escapement);
  1416|             $underlineType = ord($recordData[10]);
  1417|             CellFont::underline($objFont, $underlineType);
  1418|             if ($this->version == self::XLS_BIFF8) {
  1419|                 $string = self::readUnicodeStringShort(substr($recordData, 14));
  1420|             } else {
  1421|                 $string = $this->readByteStringShort(substr($recordData, 14));
  1422|             }
  1423|             $objFont->setName($string['value']);
  1424|             $this->objFonts[] = $objFont;
  1425|         }
  1426|     }
  1427|     /**
  1428|      * FORMAT.
  1429|      *
  1430|      * This record contains information about a number format.
  1431|      * All FORMAT records occur together in a sequential list.
  1432|      *
  1433|      * In BIFF2-BIFF4 other records referencing a FORMAT record
  1434|      * contain a zero-based index into this list. From BIFF5 on
  1435|      * the FORMAT record contains the index itself that will be
  1436|      * used by other records.
  1437|      *
  1438|      * --    "OpenOffice.org's Documentation of the Microsoft
  1439|      *         Excel File Format"
  1440|      */
  1441|     private function readFormat(): void
  1442|     {
  1443|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1444|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1445|         $this->pos += 4 + $length;
  1446|         if (!$this->readDataOnly) {
  1447|             $indexCode = self::getUInt2d($recordData, 0);
  1448|             if ($this->version == self::XLS_BIFF8) {
  1449|                 $string = self::readUnicodeStringLong(substr($recordData, 2));
  1450|             } else {
  1451|                 $string = $this->readByteStringShort(substr($recordData, 2));
  1452|             }
  1453|             $formatString = $string['value'];
  1454|             if ($formatString === 'GENERAL') {
  1455|                 $formatString = NumberFormat::FORMAT_GENERAL;
  1456|             }
  1457|             $this->formats[$indexCode] = $formatString;
  1458|         }
  1459|     }
  1460|     /**
  1461|      * XF - Extended Format.
  1462|      *
  1463|      * This record contains formatting information for cells, rows, columns or styles.
  1464|      * According to https://support.microsoft.com/en-us/help/147732 there are always at least 15 cell style XF
  1465|      * and 1 cell XF.
  1466|      * Inspection of Excel files generated by MS Office Excel shows that XF records 0-14 are cell style XF
  1467|      * and XF record 15 is a cell XF
  1468|      * We only read the first cell style XF and skip the remaining cell style XF records
  1469|      * We read all cell XF records.
  1470|      *
  1471|      * --    "OpenOffice.org's Documentation of the Microsoft
  1472|      *         Excel File Format"
  1473|      */
  1474|     private function readXf(): void
  1475|     {
  1476|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1477|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1478|         $this->pos += 4 + $length;
  1479|         $objStyle = new Style();
  1480|         if (!$this->readDataOnly) {
  1481|             if (self::getUInt2d($recordData, 0) < 4) {
  1482|                 $fontIndex = self::getUInt2d($recordData, 0);
  1483|             } else {
  1484|                 $fontIndex = self::getUInt2d($recordData, 0) - 1;
  1485|             }
  1486|             if (isset($this->objFonts[$fontIndex])) {
  1487|                 $objStyle->setFont($this->objFonts[$fontIndex]);
  1488|             }
  1489|             $numberFormatIndex = self::getUInt2d($recordData, 2);
  1490|             if (isset($this->formats[$numberFormatIndex])) {
  1491|                 $numberFormat = ['formatCode' => $this->formats[$numberFormatIndex]];
  1492|             } elseif (($code = NumberFormat::builtInFormatCode($numberFormatIndex)) !== '') {
  1493|                 $numberFormat = ['formatCode' => $code];
  1494|             } else {
  1495|                 $numberFormat = ['formatCode' => NumberFormat::FORMAT_GENERAL];
  1496|             }
  1497|             $objStyle->getNumberFormat()->setFormatCode($numberFormat['formatCode']);
  1498|             $xfTypeProt = self::getUInt2d($recordData, 4);
  1499|             $isLocked = (0x01 & $xfTypeProt) >> 0;
  1500|             $objStyle->getProtection()->setLocked($isLocked ? Protection::PROTECTION_INHERIT : Protection::PROTECTION_UNPROTECTED);
  1501|             $isHidden = (0x02 & $xfTypeProt) >> 1;
  1502|             $objStyle->getProtection()->setHidden($isHidden ? Protection::PROTECTION_PROTECTED : Protection::PROTECTION_UNPROTECTED);
  1503|             $isCellStyleXf = (0x04 & $xfTypeProt) >> 2;
  1504|             $horAlign = (0x07 & ord($recordData[6])) >> 0;
  1505|             Xls\Style\CellAlignment::horizontal($objStyle->getAlignment(), $horAlign);
  1506|             $wrapText = (0x08 & ord($recordData[6])) >> 3;
  1507|             Xls\Style\CellAlignment::wrap($objStyle->getAlignment(), $wrapText);
  1508|             $vertAlign = (0x70 & ord($recordData[6])) >> 4;
  1509|             Xls\Style\CellAlignment::vertical($objStyle->getAlignment(), $vertAlign);
  1510|             if ($this->version == self::XLS_BIFF8) {
  1511|                 $angle = ord($recordData[7]);
  1512|                 $rotation = 0;
  1513|                 if ($angle <= 90) {
  1514|                     $rotation = $angle;
  1515|                 } elseif ($angle <= 180) {
  1516|                     $rotation = 90 - $angle;
  1517|                 } elseif ($angle == Alignment::TEXTROTATION_STACK_EXCEL) {
  1518|                     $rotation = Alignment::TEXTROTATION_STACK_PHPSPREADSHEET;
  1519|                 }
  1520|                 $objStyle->getAlignment()->setTextRotation($rotation);
  1521|                 $indent = (0x0F & ord($recordData[8])) >> 0;
  1522|                 $objStyle->getAlignment()->setIndent($indent);
  1523|                 $shrinkToFit = (0x10 & ord($recordData[8])) >> 4;
  1524|                 switch ($shrinkToFit) {
  1525|                     case 0:
  1526|                         $objStyle->getAlignment()->setShrinkToFit(false);
  1527|                         break;
  1528|                     case 1:
  1529|                         $objStyle->getAlignment()->setShrinkToFit(true);
  1530|                         break;
  1531|                 }
  1532|                 if ($bordersLeftStyle = Xls\Style\Border::lookup((0x0000000F & self::getInt4d($recordData, 10)) >> 0)) {
  1533|                     $objStyle->getBorders()->getLeft()->setBorderStyle($bordersLeftStyle);
  1534|                 }
  1535|                 if ($bordersRightStyle = Xls\Style\Border::lookup((0x000000F0 & self::getInt4d($recordData, 10)) >> 4)) {
  1536|                     $objStyle->getBorders()->getRight()->setBorderStyle($bordersRightStyle);
  1537|                 }
  1538|                 if ($bordersTopStyle = Xls\Style\Border::lookup((0x00000F00 & self::getInt4d($recordData, 10)) >> 8)) {
  1539|                     $objStyle->getBorders()->getTop()->setBorderStyle($bordersTopStyle);
  1540|                 }
  1541|                 if ($bordersBottomStyle = Xls\Style\Border::lookup((0x0000F000 & self::getInt4d($recordData, 10)) >> 12)) {
  1542|                     $objStyle->getBorders()->getBottom()->setBorderStyle($bordersBottomStyle);
  1543|                 }
  1544|                 $objStyle->getBorders()->getLeft()->colorIndex = (0x007F0000 & self::getInt4d($recordData, 10)) >> 16;
  1545|                 $objStyle->getBorders()->getRight()->colorIndex = (0x3F800000 & self::getInt4d($recordData, 10)) >> 23;
  1546|                 $diagonalDown = (0x40000000 & self::getInt4d($recordData, 10)) >> 30 ? true : false;
  1547|                 $diagonalUp = (self::HIGH_ORDER_BIT & self::getInt4d($recordData, 10)) >> 31 ? true : false;
  1548|                 if ($diagonalUp === false) {
  1549|                     if ($diagonalDown === false) {
  1550|                         $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_NONE);
  1551|                     } else {
  1552|                         $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_DOWN);
  1553|                     }
  1554|                 } elseif ($diagonalDown === false) {
  1555|                     $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_UP);
  1556|                 } else {
  1557|                     $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_BOTH);
  1558|                 }
  1559|                 $objStyle->getBorders()->getTop()->colorIndex = (0x0000007F & self::getInt4d($recordData, 14)) >> 0;
  1560|                 $objStyle->getBorders()->getBottom()->colorIndex = (0x00003F80 & self::getInt4d($recordData, 14)) >> 7;
  1561|                 $objStyle->getBorders()->getDiagonal()->colorIndex = (0x001FC000 & self::getInt4d($recordData, 14)) >> 14;
  1562|                 if ($bordersDiagonalStyle = Xls\Style\Border::lookup((0x01E00000 & self::getInt4d($recordData, 14)) >> 21)) {
  1563|                     $objStyle->getBorders()->getDiagonal()->setBorderStyle($bordersDiagonalStyle);
  1564|                 }
  1565|                 if ($fillType = FillPattern::lookup((self::FC000000 & self::getInt4d($recordData, 14)) >> 26)) {
  1566|                     $objStyle->getFill()->setFillType($fillType);
  1567|                 }
  1568|                 $objStyle->getFill()->startcolorIndex = (0x007F & self::getUInt2d($recordData, 18)) >> 0;
  1569|                 $objStyle->getFill()->endcolorIndex = (0x3F80 & self::getUInt2d($recordData, 18)) >> 7;
  1570|             } else {
  1571|                 $orientationAndFlags = ord($recordData[7]);
  1572|                 $xfOrientation = (0x03 & $orientationAndFlags) >> 0;
  1573|                 switch ($xfOrientation) {
  1574|                     case 0:
  1575|                         $objStyle->getAlignment()->setTextRotation(0);
  1576|                         break;
  1577|                     case 1:
  1578|                         $objStyle->getAlignment()->setTextRotation(Alignment::TEXTROTATION_STACK_PHPSPREADSHEET);
  1579|                         break;
  1580|                     case 2:
  1581|                         $objStyle->getAlignment()->setTextRotation(90);
  1582|                         break;
  1583|                     case 3:
  1584|                         $objStyle->getAlignment()->setTextRotation(-90);
  1585|                         break;
  1586|                 }
  1587|                 $borderAndBackground = self::getInt4d($recordData, 8);
  1588|                 $objStyle->getFill()->startcolorIndex = (0x0000007F & $borderAndBackground) >> 0;
  1589|                 $objStyle->getFill()->endcolorIndex = (0x00003F80 & $borderAndBackground) >> 7;
  1590|                 $objStyle->getFill()->setFillType(FillPattern::lookup((0x003F0000 & $borderAndBackground) >> 16));
  1591|                 $objStyle->getBorders()->getBottom()->setBorderStyle(Xls\Style\Border::lookup((0x01C00000 & $borderAndBackground) >> 22));
  1592|                 $objStyle->getBorders()->getBottom()->colorIndex = (self::FE000000 & $borderAndBackground) >> 25;
  1593|                 $borderLines = self::getInt4d($recordData, 12);
  1594|                 $objStyle->getBorders()->getTop()->setBorderStyle(Xls\Style\Border::lookup((0x00000007 & $borderLines) >> 0));
  1595|                 $objStyle->getBorders()->getLeft()->setBorderStyle(Xls\Style\Border::lookup((0x00000038 & $borderLines) >> 3));
  1596|                 $objStyle->getBorders()->getRight()->setBorderStyle(Xls\Style\Border::lookup((0x000001C0 & $borderLines) >> 6));
  1597|                 $objStyle->getBorders()->getTop()->colorIndex = (0x0000FE00 & $borderLines) >> 9;
  1598|                 $objStyle->getBorders()->getLeft()->colorIndex = (0x007F0000 & $borderLines) >> 16;
  1599|                 $objStyle->getBorders()->getRight()->colorIndex = (0x3F800000 & $borderLines) >> 23;
  1600|             }
  1601|             if ($isCellStyleXf) {
  1602|                 if ($this->xfIndex == 0) {
  1603|                     $this->spreadsheet->addCellStyleXf($objStyle);
  1604|                     $this->mapCellStyleXfIndex[$this->xfIndex] = 0;
  1605|                 }
  1606|             } else {
  1607|                 $this->spreadsheet->addCellXf($objStyle);
  1608|                 $this->mapCellXfIndex[$this->xfIndex] = count($this->spreadsheet->getCellXfCollection()) - 1;
  1609|             }
  1610|             ++$this->xfIndex;
  1611|         }
  1612|     }
  1613|     private function readXfExt(): void
  1614|     {
  1615|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1616|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1617|         $this->pos += 4 + $length;
  1618|         if (!$this->readDataOnly) {
  1619|             $ixfe = self::getUInt2d($recordData, 14);
  1620|             $offset = 20;
  1621|             while ($offset < $length) {
  1622|                 $extType = self::getUInt2d($recordData, $offset);
  1623|                 $cb = self::getUInt2d($recordData, $offset + 2);
  1624|                 $extData = substr($recordData, $offset + 4, $cb);
  1625|                 switch ($extType) {
  1626|                     case 4:        // fill start color
  1627|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1628|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1629|                         if ($xclfType == 2) {
  1630|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1631|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1632|                                 $fill = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFill();
  1633|                                 $fill->getStartColor()->setRGB($rgb);
  1634|                                 $fill->startcolorIndex = null; // normal color index does not apply, discard
  1635|                             }
  1636|                         }
  1637|                         break;
  1638|                     case 5:        // fill end color
  1639|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1640|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1641|                         if ($xclfType == 2) {
  1642|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1643|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1644|                                 $fill = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFill();
  1645|                                 $fill->getEndColor()->setRGB($rgb);
  1646|                                 $fill->endcolorIndex = null; // normal color index does not apply, discard
  1647|                             }
  1648|                         }
  1649|                         break;
  1650|                     case 7:        // border color top
  1651|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1652|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1653|                         if ($xclfType == 2) {
  1654|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1655|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1656|                                 $top = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getTop();
  1657|                                 $top->getColor()->setRGB($rgb);
  1658|                                 $top->colorIndex = null; // normal color index does not apply, discard
  1659|                             }
  1660|                         }
  1661|                         break;
  1662|                     case 8:        // border color bottom
  1663|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1664|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1665|                         if ($xclfType == 2) {
  1666|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1667|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1668|                                 $bottom = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getBottom();
  1669|                                 $bottom->getColor()->setRGB($rgb);
  1670|                                 $bottom->colorIndex = null; // normal color index does not apply, discard
  1671|                             }
  1672|                         }
  1673|                         break;
  1674|                     case 9:        // border color left
  1675|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1676|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1677|                         if ($xclfType == 2) {
  1678|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1679|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1680|                                 $left = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getLeft();
  1681|                                 $left->getColor()->setRGB($rgb);
  1682|                                 $left->colorIndex = null; // normal color index does not apply, discard
  1683|                             }
  1684|                         }
  1685|                         break;
  1686|                     case 10:        // border color right
  1687|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1688|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1689|                         if ($xclfType == 2) {
  1690|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1691|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1692|                                 $right = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getRight();
  1693|                                 $right->getColor()->setRGB($rgb);
  1694|                                 $right->colorIndex = null; // normal color index does not apply, discard
  1695|                             }
  1696|                         }
  1697|                         break;
  1698|                     case 11:        // border color diagonal
  1699|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1700|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1701|                         if ($xclfType == 2) {
  1702|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1703|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1704|                                 $diagonal = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getDiagonal();
  1705|                                 $diagonal->getColor()->setRGB($rgb);
  1706|                                 $diagonal->colorIndex = null; // normal color index does not apply, discard
  1707|                             }
  1708|                         }
  1709|                         break;
  1710|                     case 13:    // font color
  1711|                         $xclfType = self::getUInt2d($extData, 0); // color type
  1712|                         $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
  1713|                         if ($xclfType == 2) {
  1714|                             $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
  1715|                             if (isset($this->mapCellXfIndex[$ixfe])) {
  1716|                                 $font = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFont();
  1717|                                 $font->getColor()->setRGB($rgb);
  1718|                                 $font->colorIndex = null; // normal color index does not apply, discard
  1719|                             }
  1720|                         }
  1721|                         break;
  1722|                 }
  1723|                 $offset += $cb;
  1724|             }
  1725|         }
  1726|     }
  1727|     /**
  1728|      * Read STYLE record.
  1729|      */
  1730|     private function readStyle(): void
  1731|     {
  1732|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1733|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1734|         $this->pos += 4 + $length;
  1735|         if (!$this->readDataOnly) {
  1736|             $ixfe = self::getUInt2d($recordData, 0);
  1737|             $isBuiltIn = (bool) ((0x8000 & $ixfe) >> 15);
  1738|             if ($isBuiltIn) {
  1739|                 $builtInId = ord($recordData[2]);
  1740|                 switch ($builtInId) {
  1741|                     case 0x00:
  1742|                         break;
  1743|                     default:
  1744|                         break;
  1745|                 }
  1746|             }
  1747|         }
  1748|     }
  1749|     /**
  1750|      * Read PALETTE record.
  1751|      */
  1752|     private function readPalette(): void
  1753|     {
  1754|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1755|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1756|         $this->pos += 4 + $length;
  1757|         if (!$this->readDataOnly) {
  1758|             $nm = self::getUInt2d($recordData, 0);
  1759|             for ($i = 0; $i < $nm; ++$i) {
  1760|                 $rgb = substr($recordData, 2 + 4 * $i, 4);
  1761|                 $this->palette[] = self::readRGB($rgb);
  1762|             }
  1763|         }
  1764|     }
  1765|     /**
  1766|      * SHEET.
  1767|      *
  1768|      * This record is  located in the  Workbook Globals
  1769|      * Substream  and represents a sheet inside the workbook.
  1770|      * One SHEET record is written for each sheet. It stores the
  1771|      * sheet name and a stream offset to the BOF record of the
  1772|      * respective Sheet Substream within the Workbook Stream.
  1773|      *
  1774|      * --    "OpenOffice.org's Documentation of the Microsoft
  1775|      *         Excel File Format"
  1776|      */
  1777|     private function readSheet(): void
  1778|     {
  1779|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1780|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1781|         $rec_offset = self::getInt4d($this->data, $this->pos + 4);
  1782|         $this->pos += 4 + $length;
  1783|         $sheetState = match (ord($recordData[4])) {
  1784|             0x00 => Worksheet::SHEETSTATE_VISIBLE,
  1785|             0x01 => Worksheet::SHEETSTATE_HIDDEN,
  1786|             0x02 => Worksheet::SHEETSTATE_VERYHIDDEN,
  1787|             default => Worksheet::SHEETSTATE_VISIBLE,
  1788|         };
  1789|         $sheetType = ord($recordData[5]);
  1790|         $rec_name = null;
  1791|         if ($this->version == self::XLS_BIFF8) {
  1792|             $string = self::readUnicodeStringShort(substr($recordData, 6));
  1793|             $rec_name = $string['value'];
  1794|         } elseif ($this->version == self::XLS_BIFF7) {
  1795|             $string = $this->readByteStringShort(substr($recordData, 6));
  1796|             $rec_name = $string['value'];
  1797|         }
  1798|         $this->sheets[] = [
  1799|             'name' => $rec_name,
  1800|             'offset' => $rec_offset,
  1801|             'sheetState' => $sheetState,
  1802|             'sheetType' => $sheetType,
  1803|         ];
  1804|     }
  1805|     /**
  1806|      * Read EXTERNALBOOK record.
  1807|      */
  1808|     private function readExternalBook(): void
  1809|     {
  1810|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1811|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1812|         $this->pos += 4 + $length;
  1813|         $offset = 0;
  1814|         if (strlen($recordData) > 4) {
  1815|             $nm = self::getUInt2d($recordData, 0);
  1816|             $offset += 2;
  1817|             $encodedUrlString = self::readUnicodeStringLong(substr($recordData, 2));
  1818|             $offset += $encodedUrlString['size'];
  1819|             $externalSheetNames = [];
  1820|             for ($i = 0; $i < $nm; ++$i) {
  1821|                 $externalSheetNameString = self::readUnicodeStringLong(substr($recordData, $offset));
  1822|                 $externalSheetNames[] = $externalSheetNameString['value'];
  1823|                 $offset += $externalSheetNameString['size'];
  1824|             }
  1825|             $this->externalBooks[] = [
  1826|                 'type' => 'external',
  1827|                 'encodedUrl' => $encodedUrlString['value'],
  1828|                 'externalSheetNames' => $externalSheetNames,
  1829|             ];
  1830|         } elseif (substr($recordData, 2, 2) == pack('CC', 0x01, 0x04)) {
  1831|             $this->externalBooks[] = [
  1832|                 'type' => 'internal',
  1833|             ];
  1834|         } elseif (substr($recordData, 0, 4) == pack('vCC', 0x0001, 0x01, 0x3A)) {
  1835|             $this->externalBooks[] = [
  1836|                 'type' => 'addInFunction',
  1837|             ];
  1838|         } elseif (substr($recordData, 0, 2) == pack('v', 0x0000)) {
  1839|             $this->externalBooks[] = [
  1840|                 'type' => 'DDEorOLE',
  1841|             ];
  1842|         }
  1843|     }
  1844|     /**
  1845|      * Read EXTERNNAME record.
  1846|      */
  1847|     private function readExternName(): void
  1848|     {
  1849|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1850|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1851|         $this->pos += 4 + $length;
  1852|         if ($this->version == self::XLS_BIFF8) {
  1853|             $nameString = self::readUnicodeStringShort(substr($recordData, 6));
  1854|             $offset = 6 + $nameString['size'];
  1855|             $formula = $this->getFormulaFromStructure(substr($recordData, $offset));
  1856|             $this->externalNames[] = [
  1857|                 'name' => $nameString['value'],
  1858|                 'formula' => $formula,
  1859|             ];
  1860|         }
  1861|     }
  1862|     /**
  1863|      * Read EXTERNSHEET record.
  1864|      */
  1865|     private function readExternSheet(): void
  1866|     {
  1867|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1868|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1869|         $this->pos += 4 + $length;
  1870|         if ($this->version == self::XLS_BIFF8) {
  1871|             $nm = self::getUInt2d($recordData, 0);
  1872|             for ($i = 0; $i < $nm; ++$i) {
  1873|                 $this->ref[] = [
  1874|                     'externalBookIndex' => self::getUInt2d($recordData, 2 + 6 * $i),
  1875|                     'firstSheetIndex' => self::getUInt2d($recordData, 4 + 6 * $i),
  1876|                     'lastSheetIndex' => self::getUInt2d($recordData, 6 + 6 * $i),
  1877|                 ];
  1878|             }
  1879|         }
  1880|     }
  1881|     /**
  1882|      * DEFINEDNAME.
  1883|      *
  1884|      * This record is part of a Link Table. It contains the name
  1885|      * and the token array of an internal defined name. Token
  1886|      * arrays of defined names contain tokens with aberrant
  1887|      * token classes.
  1888|      *
  1889|      * --    "OpenOffice.org's Documentation of the Microsoft
  1890|      *         Excel File Format"
  1891|      */
  1892|     private function readDefinedName(): void
  1893|     {
  1894|         $length = self::getUInt2d($this->data, $this->pos + 2);
  1895|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  1896|         $this->pos += 4 + $length;
  1897|         if ($this->version == self::XLS_BIFF8) {
  1898|             $opts = self::getUInt2d($recordData, 0);
  1899|             $isBuiltInName = (0x0020 & $opts) >> 5;
  1900|             $nlen = ord($recordData[3]);
  1901|             $flen = self::getUInt2d($recordData, 4);
  1902|             $scope = self::getUInt2d($recordData, 8);
  1903|             $string = self::readUnicodeString(substr($recordData, 14), $nlen);
  1904|             $offset = 14 + $string['size'];
  1905|             $formulaStructure = pack('v', $flen) . substr($recordData, $offset);
  1906|             try {
  1907|                 $formula = $this->getFormulaFromStructure($formulaStructure);
  1908|             } catch (PhpSpreadsheetException) {
  1909|                 $formula = '';
  1910|                 $isBuiltInName = 0;
  1911|             }
  1912|             $this->definedname[] = [
  1913|                 'isBuiltInName' => $isBuiltInName,
  1914|                 'name' => $string['value'],
  1915|                 'formula' => $formula,
  1916|                 'scope' => $scope,
  1917|             ];
  1918|         }
  1919|     }
  1920|     /**
  1921|      * Read MSODRAWINGGROUP record.
  1922|      */
  1923|     private function readMsoDrawingGroup(): void
  1924|     {
  1925|         $splicedRecordData = $this->getSplicedRecordData();
  1926|         $recordData = $splicedRecordData['recordData'];
  1927|         $this->drawingGroupData .= $recordData;
  1928|     }
  1929|     /**
  1930|      * SST - Shared String Table.
  1931|      *
  1932|      * This record contains a list of all strings used anywhere
  1933|      * in the workbook. Each string occurs only once. The
  1934|      * workbook uses indexes into the list to reference the
  1935|      * strings.
  1936|      *
  1937|      * --    "OpenOffice.org's Documentation of the Microsoft
  1938|      *         Excel File Format"
  1939|      */
  1940|     private function readSst(): void
  1941|     {
  1942|         $pos = 0;
  1943|         $limitposSST = 0;
  1944|         $splicedRecordData = $this->getSplicedRecordData();
  1945|         $recordData = $splicedRecordData['recordData'];
  1946|         $spliceOffsets = $splicedRecordData['spliceOffsets'];
  1947|         $pos += 4;
  1948|         $nm = self::getInt4d($recordData, 4);
  1949|         $pos += 4;
  1950|         foreach ($spliceOffsets as $spliceOffset) {
  1951|             if ($pos <= $spliceOffset) {
  1952|                 $limitposSST = $spliceOffset;
  1953|             }
  1954|         }
  1955|         for ($i = 0; $i < $nm && $pos < $limitposSST; ++$i) {
  1956|             $numChars = self::getUInt2d($recordData, $pos);
  1957|             $pos += 2;
  1958|             $optionFlags = ord($recordData[$pos]);
  1959|             ++$pos;
  1960|             $isCompressed = (($optionFlags & 0x01) == 0);
  1961|             $hasAsian = (($optionFlags & 0x04) != 0);
  1962|             $hasRichText = (($optionFlags & 0x08) != 0);
  1963|             $formattingRuns = 0;
  1964|             if ($hasRichText) {
  1965|                 $formattingRuns = self::getUInt2d($recordData, $pos);
  1966|                 $pos += 2;
  1967|             }
  1968|             $extendedRunLength = 0;
  1969|             if ($hasAsian) {
  1970|                 $extendedRunLength = self::getInt4d($recordData, $pos);
  1971|                 $pos += 4;
  1972|             }
  1973|             $len = ($isCompressed) ? $numChars : $numChars * 2;
  1974|             $limitpos = null;
  1975|             foreach ($spliceOffsets as $spliceOffset) {
  1976|                 if ($pos <= $spliceOffset) {
  1977|                     $limitpos = $spliceOffset;
  1978|                     break;
  1979|                 }
  1980|             }
  1981|             if ($pos + $len <= $limitpos) {
  1982|                 $retstr = substr($recordData, $pos, $len);
  1983|                 $pos += $len;
  1984|             } else {
  1985|                 $retstr = substr($recordData, $pos, $limitpos - $pos);
  1986|                 $bytesRead = $limitpos - $pos;
  1987|                 $charsLeft = $numChars - (($isCompressed) ? $bytesRead : ($bytesRead / 2));
  1988|                 $pos = $limitpos;
  1989|                 while ($charsLeft > 0) {
  1990|                     foreach ($spliceOffsets as $spliceOffset) {
  1991|                         if ($pos < $spliceOffset) {
  1992|                             $limitpos = $spliceOffset;
  1993|                             break;
  1994|                         }
  1995|                     }
  1996|                     $option = ord($recordData[$pos]);
  1997|                     ++$pos;
  1998|                     if ($isCompressed && ($option == 0)) {
  1999|                         $len = min($charsLeft, $limitpos - $pos);
  2000|                         $retstr .= substr($recordData, $pos, $len);
  2001|                         $charsLeft -= $len;
  2002|                         $isCompressed = true;
  2003|                     } elseif (!$isCompressed && ($option != 0)) {
  2004|                         $len = min($charsLeft * 2, $limitpos - $pos);
  2005|                         $retstr .= substr($recordData, $pos, $len);
  2006|                         $charsLeft -= $len / 2;
  2007|                         $isCompressed = false;
  2008|                     } elseif (!$isCompressed && ($option == 0)) {
  2009|                         $len = min($charsLeft, $limitpos - $pos);
  2010|                         for ($j = 0; $j < $len; ++$j) {
  2011|                             $retstr .= $recordData[$pos + $j]
  2012|                                 . chr(0);
  2013|                         }
  2014|                         $charsLeft -= $len;
  2015|                         $isCompressed = false;
  2016|                     } else {
  2017|                         $newstr = '';
  2018|                         $jMax = strlen($retstr);
  2019|                         for ($j = 0; $j < $jMax; ++$j) {
  2020|                             $newstr .= $retstr[$j] . chr(0);
  2021|                         }
  2022|                         $retstr = $newstr;
  2023|                         $len = min($charsLeft * 2, $limitpos - $pos);
  2024|                         $retstr .= substr($recordData, $pos, $len);
  2025|                         $charsLeft -= $len / 2;
  2026|                         $isCompressed = false;
  2027|                     }
  2028|                     $pos += $len;
  2029|                 }
  2030|             }
  2031|             $retstr = self::encodeUTF16($retstr, $isCompressed);
  2032|             $fmtRuns = [];
  2033|             if ($hasRichText) {
  2034|                 for ($j = 0; $j < $formattingRuns; ++$j) {
  2035|                     $charPos = self::getUInt2d($recordData, $pos + $j * 4);
  2036|                     $fontIndex = self::getUInt2d($recordData, $pos + 2 + $j * 4);
  2037|                     $fmtRuns[] = [
  2038|                         'charPos' => $charPos,
  2039|                         'fontIndex' => $fontIndex,
  2040|                     ];
  2041|                 }
  2042|                 $pos += 4 * $formattingRuns;
  2043|             }
  2044|             if ($hasAsian) {
  2045|                 $pos += $extendedRunLength;
  2046|             }
  2047|             $this->sst[] = [
  2048|                 'value' => $retstr,
  2049|                 'fmtRuns' => $fmtRuns,
  2050|             ];
  2051|         }
  2052|     }
  2053|     /**
  2054|      * Read PRINTGRIDLINES record.
  2055|      */
  2056|     private function readPrintGridlines(): void
  2057|     {
  2058|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2059|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2060|         $this->pos += 4 + $length;
  2061|         if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
  2062|             $printGridlines = (bool) self::getUInt2d($recordData, 0);
  2063|             $this->phpSheet->setPrintGridlines($printGridlines);
  2064|         }
  2065|     }
  2066|     /**
  2067|      * Read DEFAULTROWHEIGHT record.
  2068|      */
  2069|     private function readDefaultRowHeight(): void
  2070|     {
  2071|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2072|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2073|         $this->pos += 4 + $length;
  2074|         $height = self::getUInt2d($recordData, 2);
  2075|         $this->phpSheet->getDefaultRowDimension()->setRowHeight($height / 20);
  2076|     }
  2077|     /**
  2078|      * Read SHEETPR record.
  2079|      */
  2080|     private function readSheetPr(): void
  2081|     {
  2082|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2083|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2084|         $this->pos += 4 + $length;
  2085|         $isSummaryBelow = (0x0040 & self::getUInt2d($recordData, 0)) >> 6;
  2086|         $this->phpSheet->setShowSummaryBelow((bool) $isSummaryBelow);
  2087|         $isSummaryRight = (0x0080 & self::getUInt2d($recordData, 0)) >> 7;
  2088|         $this->phpSheet->setShowSummaryRight((bool) $isSummaryRight);
  2089|         $this->isFitToPages = (bool) ((0x0100 & self::getUInt2d($recordData, 0)) >> 8);
  2090|     }
  2091|     /**
  2092|      * Read HORIZONTALPAGEBREAKS record.
  2093|      */
  2094|     private function readHorizontalPageBreaks(): void
  2095|     {
  2096|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2097|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2098|         $this->pos += 4 + $length;
  2099|         if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
  2100|             $nm = self::getUInt2d($recordData, 0);
  2101|             for ($i = 0; $i < $nm; ++$i) {
  2102|                 $r = self::getUInt2d($recordData, 2 + 6 * $i);
  2103|                 $cf = self::getUInt2d($recordData, 2 + 6 * $i + 2);
  2104|                 $this->phpSheet->setBreak([$cf + 1, $r], Worksheet::BREAK_ROW);
  2105|             }
  2106|         }
  2107|     }
  2108|     /**
  2109|      * Read VERTICALPAGEBREAKS record.
  2110|      */
  2111|     private function readVerticalPageBreaks(): void
  2112|     {
  2113|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2114|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2115|         $this->pos += 4 + $length;
  2116|         if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
  2117|             $nm = self::getUInt2d($recordData, 0);
  2118|             for ($i = 0; $i < $nm; ++$i) {
  2119|                 $c = self::getUInt2d($recordData, 2 + 6 * $i);
  2120|                 $rf = self::getUInt2d($recordData, 2 + 6 * $i + 2);
  2121|                 $this->phpSheet->setBreak([$c + 1, ($rf > 0) ? $rf : 1], Worksheet::BREAK_COLUMN);
  2122|             }
  2123|         }
  2124|     }
  2125|     /**
  2126|      * Read HEADER record.
  2127|      */
  2128|     private function readHeader(): void
  2129|     {
  2130|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2131|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2132|         $this->pos += 4 + $length;
  2133|         if (!$this->readDataOnly) {
  2134|             if ($recordData) {
  2135|                 if ($this->version == self::XLS_BIFF8) {
  2136|                     $string = self::readUnicodeStringLong($recordData);
  2137|                 } else {
  2138|                     $string = $this->readByteStringShort($recordData);
  2139|                 }
  2140|                 $this->phpSheet->getHeaderFooter()->setOddHeader($string['value']);
  2141|                 $this->phpSheet->getHeaderFooter()->setEvenHeader($string['value']);
  2142|             }
  2143|         }
  2144|     }
  2145|     /**
  2146|      * Read FOOTER record.
  2147|      */
  2148|     private function readFooter(): void
  2149|     {
  2150|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2151|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2152|         $this->pos += 4 + $length;
  2153|         if (!$this->readDataOnly) {
  2154|             if ($recordData) {
  2155|                 if ($this->version == self::XLS_BIFF8) {
  2156|                     $string = self::readUnicodeStringLong($recordData);
  2157|                 } else {
  2158|                     $string = $this->readByteStringShort($recordData);
  2159|                 }
  2160|                 $this->phpSheet->getHeaderFooter()->setOddFooter($string['value']);
  2161|                 $this->phpSheet->getHeaderFooter()->setEvenFooter($string['value']);
  2162|             }
  2163|         }
  2164|     }
  2165|     /**
  2166|      * Read HCENTER record.
  2167|      */
  2168|     private function readHcenter(): void
  2169|     {
  2170|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2171|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2172|         $this->pos += 4 + $length;
  2173|         if (!$this->readDataOnly) {
  2174|             $isHorizontalCentered = (bool) self::getUInt2d($recordData, 0);
  2175|             $this->phpSheet->getPageSetup()->setHorizontalCentered($isHorizontalCentered);
  2176|         }
  2177|     }
  2178|     /**
  2179|      * Read VCENTER record.
  2180|      */
  2181|     private function readVcenter(): void
  2182|     {
  2183|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2184|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2185|         $this->pos += 4 + $length;
  2186|         if (!$this->readDataOnly) {
  2187|             $isVerticalCentered = (bool) self::getUInt2d($recordData, 0);
  2188|             $this->phpSheet->getPageSetup()->setVerticalCentered($isVerticalCentered);
  2189|         }
  2190|     }
  2191|     /**
  2192|      * Read LEFTMARGIN record.
  2193|      */
  2194|     private function readLeftMargin(): void
  2195|     {
  2196|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2197|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2198|         $this->pos += 4 + $length;
  2199|         if (!$this->readDataOnly) {
  2200|             $this->phpSheet->getPageMargins()->setLeft(self::extractNumber($recordData));
  2201|         }
  2202|     }
  2203|     /**
  2204|      * Read RIGHTMARGIN record.
  2205|      */
  2206|     private function readRightMargin(): void
  2207|     {
  2208|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2209|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2210|         $this->pos += 4 + $length;
  2211|         if (!$this->readDataOnly) {
  2212|             $this->phpSheet->getPageMargins()->setRight(self::extractNumber($recordData));
  2213|         }
  2214|     }
  2215|     /**
  2216|      * Read TOPMARGIN record.
  2217|      */
  2218|     private function readTopMargin(): void
  2219|     {
  2220|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2221|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2222|         $this->pos += 4 + $length;
  2223|         if (!$this->readDataOnly) {
  2224|             $this->phpSheet->getPageMargins()->setTop(self::extractNumber($recordData));
  2225|         }
  2226|     }
  2227|     /**
  2228|      * Read BOTTOMMARGIN record.
  2229|      */
  2230|     private function readBottomMargin(): void
  2231|     {
  2232|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2233|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2234|         $this->pos += 4 + $length;
  2235|         if (!$this->readDataOnly) {
  2236|             $this->phpSheet->getPageMargins()->setBottom(self::extractNumber($recordData));
  2237|         }
  2238|     }
  2239|     /**
  2240|      * Read PAGESETUP record.
  2241|      */
  2242|     private function readPageSetup(): void
  2243|     {
  2244|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2245|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2246|         $this->pos += 4 + $length;
  2247|         if (!$this->readDataOnly) {
  2248|             $paperSize = self::getUInt2d($recordData, 0);
  2249|             $scale = self::getUInt2d($recordData, 2);
  2250|             $fitToWidth = self::getUInt2d($recordData, 6);
  2251|             $fitToHeight = self::getUInt2d($recordData, 8);
  2252|             $isOverThenDown = (0x0001 & self::getUInt2d($recordData, 10));
  2253|             $isPortrait = (0x0002 & self::getUInt2d($recordData, 10)) >> 1;
  2254|             $isNotInit = (0x0004 & self::getUInt2d($recordData, 10)) >> 2;
  2255|             if (!$isNotInit) {
  2256|                 $this->phpSheet->getPageSetup()->setPaperSize($paperSize);
  2257|                 $this->phpSheet->getPageSetup()->setPageOrder(((bool) $isOverThenDown) ? PageSetup::PAGEORDER_OVER_THEN_DOWN : PageSetup::PAGEORDER_DOWN_THEN_OVER);
  2258|                 $this->phpSheet->getPageSetup()->setOrientation(((bool) $isPortrait) ? PageSetup::ORIENTATION_PORTRAIT : PageSetup::ORIENTATION_LANDSCAPE);
  2259|                 $this->phpSheet->getPageSetup()->setScale($scale, false);
  2260|                 $this->phpSheet->getPageSetup()->setFitToPage((bool) $this->isFitToPages);
  2261|                 $this->phpSheet->getPageSetup()->setFitToWidth($fitToWidth, false);
  2262|                 $this->phpSheet->getPageSetup()->setFitToHeight($fitToHeight, false);
  2263|             }
  2264|             $marginHeader = self::extractNumber(substr($recordData, 16, 8));
  2265|             $this->phpSheet->getPageMargins()->setHeader($marginHeader);
  2266|             $marginFooter = self::extractNumber(substr($recordData, 24, 8));
  2267|             $this->phpSheet->getPageMargins()->setFooter($marginFooter);
  2268|         }
  2269|     }
  2270|     /**
  2271|      * PROTECT - Sheet protection (BIFF2 through BIFF8)
  2272|      *   if this record is omitted, then it also means no sheet protection.
  2273|      */
  2274|     private function readProtect(): void
  2275|     {
  2276|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2277|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2278|         $this->pos += 4 + $length;
  2279|         if ($this->readDataOnly) {
  2280|             return;
  2281|         }
  2282|         $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
  2283|         $this->phpSheet->getProtection()->setSheet((bool) $bool);
  2284|     }
  2285|     /**
  2286|      * SCENPROTECT.
  2287|      */
  2288|     private function readScenProtect(): void
  2289|     {
  2290|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2291|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2292|         $this->pos += 4 + $length;
  2293|         if ($this->readDataOnly) {
  2294|             return;
  2295|         }
  2296|         $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
  2297|         $this->phpSheet->getProtection()->setScenarios((bool) $bool);
  2298|     }
  2299|     /**
  2300|      * OBJECTPROTECT.
  2301|      */
  2302|     private function readObjectProtect(): void
  2303|     {
  2304|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2305|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2306|         $this->pos += 4 + $length;
  2307|         if ($this->readDataOnly) {
  2308|             return;
  2309|         }
  2310|         $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
  2311|         $this->phpSheet->getProtection()->setObjects((bool) $bool);
  2312|     }
  2313|     /**
  2314|      * PASSWORD - Sheet protection (hashed) password (BIFF2 through BIFF8).
  2315|      */
  2316|     private function readPassword(): void
  2317|     {
  2318|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2319|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2320|         $this->pos += 4 + $length;
  2321|         if (!$this->readDataOnly) {
  2322|             $password = strtoupper(dechex(self::getUInt2d($recordData, 0))); // the hashed password
  2323|             $this->phpSheet->getProtection()->setPassword($password, true);
  2324|         }
  2325|     }
  2326|     /**
  2327|      * Read DEFCOLWIDTH record.
  2328|      */
  2329|     private function readDefColWidth(): void
  2330|     {
  2331|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2332|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2333|         $this->pos += 4 + $length;
  2334|         $width = self::getUInt2d($recordData, 0);
  2335|         if ($width != 8) {
  2336|             $this->phpSheet->getDefaultColumnDimension()->setWidth($width);
  2337|         }
  2338|     }
  2339|     /**
  2340|      * Read COLINFO record.
  2341|      */
  2342|     private function readColInfo(): void
  2343|     {
  2344|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2345|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2346|         $this->pos += 4 + $length;
  2347|         if (!$this->readDataOnly) {
  2348|             $firstColumnIndex = self::getUInt2d($recordData, 0);
  2349|             $lastColumnIndex = self::getUInt2d($recordData, 2);
  2350|             $width = self::getUInt2d($recordData, 4);
  2351|             $xfIndex = self::getUInt2d($recordData, 6);
  2352|             $isHidden = (0x0001 & self::getUInt2d($recordData, 8)) >> 0;
  2353|             $level = (0x0700 & self::getUInt2d($recordData, 8)) >> 8;
  2354|             $isCollapsed = (bool) ((0x1000 & self::getUInt2d($recordData, 8)) >> 12);
  2355|             for ($i = $firstColumnIndex + 1; $i <= $lastColumnIndex + 1; ++$i) {
  2356|                 if ($lastColumnIndex == 255 || $lastColumnIndex == 256) {
  2357|                     $this->phpSheet->getDefaultColumnDimension()->setWidth($width / 256);
  2358|                     break;
  2359|                 }
  2360|                 $this->phpSheet->getColumnDimensionByColumn($i)->setWidth($width / 256);
  2361|                 $this->phpSheet->getColumnDimensionByColumn($i)->setVisible(!$isHidden);
  2362|                 $this->phpSheet->getColumnDimensionByColumn($i)->setOutlineLevel($level);
  2363|                 $this->phpSheet->getColumnDimensionByColumn($i)->setCollapsed($isCollapsed);
  2364|                 if (isset($this->mapCellXfIndex[$xfIndex])) {
  2365|                     $this->phpSheet->getColumnDimensionByColumn($i)->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2366|                 }
  2367|             }
  2368|         }
  2369|     }
  2370|     /**
  2371|      * ROW.
  2372|      *
  2373|      * This record contains the properties of a single row in a
  2374|      * sheet. Rows and cells in a sheet are divided into blocks
  2375|      * of 32 rows.
  2376|      *
  2377|      * --    "OpenOffice.org's Documentation of the Microsoft
  2378|      *         Excel File Format"
  2379|      */
  2380|     private function readRow(): void
  2381|     {
  2382|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2383|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2384|         $this->pos += 4 + $length;
  2385|         if (!$this->readDataOnly) {
  2386|             $r = self::getUInt2d($recordData, 0);
  2387|             $height = (0x7FFF & self::getUInt2d($recordData, 6)) >> 0;
  2388|             $useDefaultHeight = (0x8000 & self::getUInt2d($recordData, 6)) >> 15;
  2389|             if (!$useDefaultHeight) {
  2390|                 $this->phpSheet->getRowDimension($r + 1)->setRowHeight($height / 20);
  2391|             }
  2392|             $level = (0x00000007 & self::getInt4d($recordData, 12)) >> 0;
  2393|             $this->phpSheet->getRowDimension($r + 1)->setOutlineLevel($level);
  2394|             $isCollapsed = (bool) ((0x00000010 & self::getInt4d($recordData, 12)) >> 4);
  2395|             $this->phpSheet->getRowDimension($r + 1)->setCollapsed($isCollapsed);
  2396|             $isHidden = (0x00000020 & self::getInt4d($recordData, 12)) >> 5;
  2397|             $this->phpSheet->getRowDimension($r + 1)->setVisible(!$isHidden);
  2398|             $hasExplicitFormat = (0x00000080 & self::getInt4d($recordData, 12)) >> 7;
  2399|             $xfIndex = (0x0FFF0000 & self::getInt4d($recordData, 12)) >> 16;
  2400|             if ($hasExplicitFormat && isset($this->mapCellXfIndex[$xfIndex])) {
  2401|                 $this->phpSheet->getRowDimension($r + 1)->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2402|             }
  2403|         }
  2404|     }
  2405|     /**
  2406|      * Read RK record
  2407|      * This record represents a cell that contains an RK value
  2408|      * (encoded integer or floating-point value). If a
  2409|      * floating-point value cannot be encoded to an RK value,
  2410|      * a NUMBER record will be written. This record replaces the
  2411|      * record INTEGER written in BIFF2.
  2412|      *
  2413|      * --    "OpenOffice.org's Documentation of the Microsoft
  2414|      *         Excel File Format"
  2415|      */
  2416|     private function readRk(): void
  2417|     {
  2418|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2419|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2420|         $this->pos += 4 + $length;
  2421|         $row = self::getUInt2d($recordData, 0);
  2422|         $column = self::getUInt2d($recordData, 2);
  2423|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2424|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2425|             $xfIndex = self::getUInt2d($recordData, 4);
  2426|             $rknum = self::getInt4d($recordData, 6);
  2427|             $numValue = self::getIEEE754($rknum);
  2428|             $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2429|             if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2430|                 $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2431|             }
  2432|             $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
  2433|         }
  2434|     }
  2435|     /**
  2436|      * Read LABELSST record
  2437|      * This record represents a cell that contains a string. It
  2438|      * replaces the LABEL record and RSTRING record used in
  2439|      * BIFF2-BIFF5.
  2440|      *
  2441|      * --    "OpenOffice.org's Documentation of the Microsoft
  2442|      *         Excel File Format"
  2443|      */
  2444|     private function readLabelSst(): void
  2445|     {
  2446|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2447|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2448|         $this->pos += 4 + $length;
  2449|         $row = self::getUInt2d($recordData, 0);
  2450|         $column = self::getUInt2d($recordData, 2);
  2451|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2452|         $cell = null;
  2453|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2454|             $xfIndex = self::getUInt2d($recordData, 4);
  2455|             $index = self::getInt4d($recordData, 6);
  2456|             if (($fmtRuns = $this->sst[$index]['fmtRuns']) && !$this->readDataOnly) {
  2457|                 $richText = new RichText();
  2458|                 $charPos = 0;
  2459|                 $sstCount = count($this->sst[$index]['fmtRuns']);
  2460|                 for ($i = 0; $i <= $sstCount; ++$i) {
  2461|                     if (isset($fmtRuns[$i])) {
  2462|                         $text = StringHelper::substring($this->sst[$index]['value'], $charPos, $fmtRuns[$i]['charPos'] - $charPos);
  2463|                         $charPos = $fmtRuns[$i]['charPos'];
  2464|                     } else {
  2465|                         $text = StringHelper::substring($this->sst[$index]['value'], $charPos, StringHelper::countCharacters($this->sst[$index]['value']));
  2466|                     }
  2467|                     if (StringHelper::countCharacters($text) > 0) {
  2468|                         if ($i == 0) { // first text run, no style
  2469|                             $richText->createText($text);
  2470|                         } else {
  2471|                             $textRun = $richText->createTextRun($text);
  2472|                             if (isset($fmtRuns[$i - 1])) {
  2473|                                 if ($fmtRuns[$i - 1]['fontIndex'] < 4) {
  2474|                                     $fontIndex = $fmtRuns[$i - 1]['fontIndex'];
  2475|                                 } else {
  2476|                                     $fontIndex = $fmtRuns[$i - 1]['fontIndex'] - 1;
  2477|                                 }
  2478|                                 if (array_key_exists($fontIndex, $this->objFonts) === false) {
  2479|                                     $fontIndex = count($this->objFonts) - 1;
  2480|                                 }
  2481|                                 $textRun->setFont(clone $this->objFonts[$fontIndex]);
  2482|                             }
  2483|                         }
  2484|                     }
  2485|                 }
  2486|                 if ($this->readEmptyCells || trim($richText->getPlainText()) !== '') {
  2487|                     $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2488|                     $cell->setValueExplicit($richText, DataType::TYPE_STRING);
  2489|                 }
  2490|             } else {
  2491|                 if ($this->readEmptyCells || trim($this->sst[$index]['value']) !== '') {
  2492|                     $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2493|                     $cell->setValueExplicit($this->sst[$index]['value'], DataType::TYPE_STRING);
  2494|                 }
  2495|             }
  2496|             if (!$this->readDataOnly && $cell !== null && isset($this->mapCellXfIndex[$xfIndex])) {
  2497|                 $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2498|             }
  2499|         }
  2500|     }
  2501|     /**
  2502|      * Read MULRK record
  2503|      * This record represents a cell range containing RK value
  2504|      * cells. All cells are located in the same row.
  2505|      *
  2506|      * --    "OpenOffice.org's Documentation of the Microsoft
  2507|      *         Excel File Format"
  2508|      */
  2509|     private function readMulRk(): void
  2510|     {
  2511|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2512|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2513|         $this->pos += 4 + $length;
  2514|         $row = self::getUInt2d($recordData, 0);
  2515|         $colFirst = self::getUInt2d($recordData, 2);
  2516|         $colLast = self::getUInt2d($recordData, $length - 2);
  2517|         $columns = $colLast - $colFirst + 1;
  2518|         $offset = 4;
  2519|         for ($i = 1; $i <= $columns; ++$i) {
  2520|             $columnString = Coordinate::stringFromColumnIndex($colFirst + $i);
  2521|             if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2522|                 $xfIndex = self::getUInt2d($recordData, $offset);
  2523|                 $numValue = self::getIEEE754(self::getInt4d($recordData, $offset + 2));
  2524|                 $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2525|                 if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2526|                     $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2527|                 }
  2528|                 $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
  2529|             }
  2530|             $offset += 6;
  2531|         }
  2532|     }
  2533|     /**
  2534|      * Read NUMBER record
  2535|      * This record represents a cell that contains a
  2536|      * floating-point value.
  2537|      *
  2538|      * --    "OpenOffice.org's Documentation of the Microsoft
  2539|      *         Excel File Format"
  2540|      */
  2541|     private function readNumber(): void
  2542|     {
  2543|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2544|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2545|         $this->pos += 4 + $length;
  2546|         $row = self::getUInt2d($recordData, 0);
  2547|         $column = self::getUInt2d($recordData, 2);
  2548|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2549|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2550|             $xfIndex = self::getUInt2d($recordData, 4);
  2551|             $numValue = self::extractNumber(substr($recordData, 6, 8));
  2552|             $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2553|             if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2554|                 $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2555|             }
  2556|             $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
  2557|         }
  2558|     }
  2559|     /**
  2560|      * Read FORMULA record + perhaps a following STRING record if formula result is a string
  2561|      * This record contains the token array and the result of a
  2562|      * formula cell.
  2563|      *
  2564|      * --    "OpenOffice.org's Documentation of the Microsoft
  2565|      *         Excel File Format"
  2566|      */
  2567|     private function readFormula(): void
  2568|     {
  2569|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2570|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2571|         $this->pos += 4 + $length;
  2572|         $row = self::getUInt2d($recordData, 0);
  2573|         $column = self::getUInt2d($recordData, 2);
  2574|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2575|         $formulaStructure = substr($recordData, 20);
  2576|         $options = self::getUInt2d($recordData, 14);
  2577|         $isPartOfSharedFormula = (bool) (0x0008 & $options);
  2578|         $isPartOfSharedFormula = $isPartOfSharedFormula && ord($formulaStructure[2]) == 0x01;
  2579|         if ($isPartOfSharedFormula) {
  2580|             $baseRow = self::getUInt2d($formulaStructure, 3);
  2581|             $baseCol = self::getUInt2d($formulaStructure, 5);
  2582|             $this->baseCell = Coordinate::stringFromColumnIndex($baseCol + 1) . ($baseRow + 1);
  2583|         }
  2584|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2585|             if ($isPartOfSharedFormula) {
  2586|                 $this->sharedFormulaParts[$columnString . ($row + 1)] = $this->baseCell;
  2587|             }
  2588|             $xfIndex = self::getUInt2d($recordData, 4);
  2589|             if ((ord($recordData[6]) == 0) && (ord($recordData[12]) == 255) && (ord($recordData[13]) == 255)) {
  2590|                 $dataType = DataType::TYPE_STRING;
  2591|                 $code = self::getUInt2d($this->data, $this->pos);
  2592|                 if ($code == self::XLS_TYPE_SHAREDFMLA) {
  2593|                     $this->readSharedFmla();
  2594|                 }
  2595|                 $value = $this->readString();
  2596|             } elseif (
  2597|                 (ord($recordData[6]) == 1)
  2598|                 && (ord($recordData[12]) == 255)
  2599|                 && (ord($recordData[13]) == 255)
  2600|             ) {
  2601|                 $dataType = DataType::TYPE_BOOL;
  2602|                 $value = (bool) ord($recordData[8]);
  2603|             } elseif (
  2604|                 (ord($recordData[6]) == 2)
  2605|                 && (ord($recordData[12]) == 255)
  2606|                 && (ord($recordData[13]) == 255)
  2607|             ) {
  2608|                 $dataType = DataType::TYPE_ERROR;
  2609|                 $value = Xls\ErrorCode::lookup(ord($recordData[8]));
  2610|             } elseif (
  2611|                 (ord($recordData[6]) == 3)
  2612|                 && (ord($recordData[12]) == 255)
  2613|                 && (ord($recordData[13]) == 255)
  2614|             ) {
  2615|                 $dataType = DataType::TYPE_NULL;
  2616|                 $value = '';
  2617|             } else {
  2618|                 $dataType = DataType::TYPE_NUMERIC;
  2619|                 $value = self::extractNumber(substr($recordData, 6, 8));
  2620|             }
  2621|             $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2622|             if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2623|                 $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2624|             }
  2625|             if (!$isPartOfSharedFormula) {
  2626|                 try {
  2627|                     if ($this->version != self::XLS_BIFF8) {
  2628|                         throw new Exception('Not BIFF8. Can only read BIFF8 formulas');
  2629|                     }
  2630|                     $formula = $this->getFormulaFromStructure($formulaStructure); // get formula in human language
  2631|                     $cell->setValueExplicit('=' . $formula, DataType::TYPE_FORMULA);
  2632|                 } catch (PhpSpreadsheetException) {
  2633|                     $cell->setValueExplicit($value, $dataType);
  2634|                 }
  2635|             } else {
  2636|                 if ($this->version == self::XLS_BIFF8) {
  2637|                 } else {
  2638|                     $cell->setValueExplicit($value, $dataType);
  2639|                 }
  2640|             }
  2641|             $cell->setCalculatedValue($value, $dataType === DataType::TYPE_NUMERIC);
  2642|         }
  2643|     }
  2644|     /**
  2645|      * Read a SHAREDFMLA record. This function just stores the binary shared formula in the reader,
  2646|      * which usually contains relative references.
  2647|      * These will be used to construct the formula in each shared formula part after the sheet is read.
  2648|      */
  2649|     private function readSharedFmla(): void
  2650|     {
  2651|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2652|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2653|         $this->pos += 4 + $length;
  2654|         $formula = substr($recordData, 8);
  2655|         $this->sharedFormulas[$this->baseCell] = $formula;
  2656|     }
  2657|     /**
  2658|      * Read a STRING record from current stream position and advance the stream pointer to next record
  2659|      * This record is used for storing result from FORMULA record when it is a string, and
  2660|      * it occurs directly after the FORMULA record.
  2661|      *
  2662|      * @return string The string contents as UTF-8
  2663|      */
  2664|     private function readString(): string
  2665|     {
  2666|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2667|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2668|         $this->pos += 4 + $length;
  2669|         if ($this->version == self::XLS_BIFF8) {
  2670|             $string = self::readUnicodeStringLong($recordData);
  2671|             $value = $string['value'];
  2672|         } else {
  2673|             $string = $this->readByteStringLong($recordData);
  2674|             $value = $string['value'];
  2675|         }
  2676|         return $value;
  2677|     }
  2678|     /**
  2679|      * Read BOOLERR record
  2680|      * This record represents a Boolean value or error value
  2681|      * cell.
  2682|      *
  2683|      * --    "OpenOffice.org's Documentation of the Microsoft
  2684|      *         Excel File Format"
  2685|      */
  2686|     private function readBoolErr(): void
  2687|     {
  2688|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2689|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2690|         $this->pos += 4 + $length;
  2691|         $row = self::getUInt2d($recordData, 0);
  2692|         $column = self::getUInt2d($recordData, 2);
  2693|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2694|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2695|             $xfIndex = self::getUInt2d($recordData, 4);
  2696|             $boolErr = ord($recordData[6]);
  2697|             $isError = ord($recordData[7]);
  2698|             $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2699|             switch ($isError) {
  2700|                 case 0: // boolean
  2701|                     $value = (bool) $boolErr;
  2702|                     $cell->setValueExplicit($value, DataType::TYPE_BOOL);
  2703|                     break;
  2704|                 case 1: // error type
  2705|                     $value = Xls\ErrorCode::lookup($boolErr);
  2706|                     $cell->setValueExplicit($value, DataType::TYPE_ERROR);
  2707|                     break;
  2708|             }
  2709|             if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2710|                 $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2711|             }
  2712|         }
  2713|     }
  2714|     /**
  2715|      * Read MULBLANK record
  2716|      * This record represents a cell range of empty cells. All
  2717|      * cells are located in the same row.
  2718|      *
  2719|      * --    "OpenOffice.org's Documentation of the Microsoft
  2720|      *         Excel File Format"
  2721|      */
  2722|     private function readMulBlank(): void
  2723|     {
  2724|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2725|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2726|         $this->pos += 4 + $length;
  2727|         $row = self::getUInt2d($recordData, 0);
  2728|         $fc = self::getUInt2d($recordData, 2);
  2729|         if (!$this->readDataOnly && $this->readEmptyCells) {
  2730|             for ($i = 0; $i < $length / 2 - 3; ++$i) {
  2731|                 $columnString = Coordinate::stringFromColumnIndex($fc + $i + 1);
  2732|                 if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2733|                     $xfIndex = self::getUInt2d($recordData, 4 + 2 * $i);
  2734|                     if (isset($this->mapCellXfIndex[$xfIndex])) {
  2735|                         $this->phpSheet->getCell($columnString . ($row + 1))->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2736|                     }
  2737|                 }
  2738|             }
  2739|         }
  2740|     }
  2741|     /**
  2742|      * Read LABEL record
  2743|      * This record represents a cell that contains a string. In
  2744|      * BIFF8 it is usually replaced by the LABELSST record.
  2745|      * Excel still uses this record, if it copies unformatted
  2746|      * text cells to the clipboard.
  2747|      *
  2748|      * --    "OpenOffice.org's Documentation of the Microsoft
  2749|      *         Excel File Format"
  2750|      */
  2751|     private function readLabel(): void
  2752|     {
  2753|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2754|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2755|         $this->pos += 4 + $length;
  2756|         $row = self::getUInt2d($recordData, 0);
  2757|         $column = self::getUInt2d($recordData, 2);
  2758|         $columnString = Coordinate::stringFromColumnIndex($column + 1);
  2759|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2760|             $xfIndex = self::getUInt2d($recordData, 4);
  2761|             if ($this->version == self::XLS_BIFF8) {
  2762|                 $string = self::readUnicodeStringLong(substr($recordData, 6));
  2763|                 $value = $string['value'];
  2764|             } else {
  2765|                 $string = $this->readByteStringLong(substr($recordData, 6));
  2766|                 $value = $string['value'];
  2767|             }
  2768|             if ($this->readEmptyCells || trim($value) !== '') {
  2769|                 $cell = $this->phpSheet->getCell($columnString . ($row + 1));
  2770|                 $cell->setValueExplicit($value, DataType::TYPE_STRING);
  2771|                 if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
  2772|                     $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2773|                 }
  2774|             }
  2775|         }
  2776|     }
  2777|     /**
  2778|      * Read BLANK record.
  2779|      */
  2780|     private function readBlank(): void
  2781|     {
  2782|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2783|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2784|         $this->pos += 4 + $length;
  2785|         $row = self::getUInt2d($recordData, 0);
  2786|         $col = self::getUInt2d($recordData, 2);
  2787|         $columnString = Coordinate::stringFromColumnIndex($col + 1);
  2788|         if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
  2789|             $xfIndex = self::getUInt2d($recordData, 4);
  2790|             if (!$this->readDataOnly && $this->readEmptyCells && isset($this->mapCellXfIndex[$xfIndex])) {
  2791|                 $this->phpSheet->getCell($columnString . ($row + 1))->setXfIndex($this->mapCellXfIndex[$xfIndex]);
  2792|             }
  2793|         }
  2794|     }
  2795|     /**
  2796|      * Read MSODRAWING record.
  2797|      */
  2798|     private function readMsoDrawing(): void
  2799|     {
  2800|         $splicedRecordData = $this->getSplicedRecordData();
  2801|         $recordData = $splicedRecordData['recordData'];
  2802|         $this->drawingData .= $recordData;
  2803|     }
  2804|     /**
  2805|      * Read OBJ record.
  2806|      */
  2807|     private function readObj(): void
  2808|     {
  2809|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2810|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2811|         $this->pos += 4 + $length;
  2812|         if ($this->readDataOnly || $this->version != self::XLS_BIFF8) {
  2813|             return;
  2814|         }
  2815|         $ftCmoType = self::getUInt2d($recordData, 0);
  2816|         $cbCmoSize = self::getUInt2d($recordData, 2);
  2817|         $otObjType = self::getUInt2d($recordData, 4);
  2818|         $idObjID = self::getUInt2d($recordData, 6);
  2819|         $grbitOpts = self::getUInt2d($recordData, 6);
  2820|         $this->objs[] = [
  2821|             'ftCmoType' => $ftCmoType,
  2822|             'cbCmoSize' => $cbCmoSize,
  2823|             'otObjType' => $otObjType,
  2824|             'idObjID' => $idObjID,
  2825|             'grbitOpts' => $grbitOpts,
  2826|         ];
  2827|         $this->textObjRef = $idObjID;
  2828|     }
  2829|     /**
  2830|      * Read WINDOW2 record.
  2831|      */
  2832|     private function readWindow2(): void
  2833|     {
  2834|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2835|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2836|         $this->pos += 4 + $length;
  2837|         $options = self::getUInt2d($recordData, 0);
  2838|         $zoomscaleInPageBreakPreview = 0;
  2839|         $zoomscaleInNormalView = 0;
  2840|         if ($this->version === self::XLS_BIFF8) {
  2841|             if (!isset($recordData[10])) {
  2842|                 $zoomscaleInPageBreakPreview = 0;
  2843|             } else {
  2844|                 $zoomscaleInPageBreakPreview = self::getUInt2d($recordData, 10);
  2845|             }
  2846|             if ($zoomscaleInPageBreakPreview === 0) {
  2847|                 $zoomscaleInPageBreakPreview = 60;
  2848|             }
  2849|             if (!isset($recordData[12])) {
  2850|                 $zoomscaleInNormalView = 0;
  2851|             } else {
  2852|                 $zoomscaleInNormalView = self::getUInt2d($recordData, 12);
  2853|             }
  2854|             if ($zoomscaleInNormalView === 0) {
  2855|                 $zoomscaleInNormalView = 100;
  2856|             }
  2857|         }
  2858|         $showGridlines = (bool) ((0x0002 & $options) >> 1);
  2859|         $this->phpSheet->setShowGridlines($showGridlines);
  2860|         $showRowColHeaders = (bool) ((0x0004 & $options) >> 2);
  2861|         $this->phpSheet->setShowRowColHeaders($showRowColHeaders);
  2862|         $this->frozen = (bool) ((0x0008 & $options) >> 3);
  2863|         $this->phpSheet->setRightToLeft((bool) ((0x0040 & $options) >> 6));
  2864|         $isActive = (bool) ((0x0400 & $options) >> 10);
  2865|         if ($isActive) {
  2866|             $this->spreadsheet->setActiveSheetIndex($this->spreadsheet->getIndex($this->phpSheet));
  2867|             $this->activeSheetSet = true;
  2868|         }
  2869|         $isPageBreakPreview = (bool) ((0x0800 & $options) >> 11);
  2870|         if ($this->phpSheet->getSheetView()->getView() !== SheetView::SHEETVIEW_PAGE_LAYOUT) {
  2871|             $view = $isPageBreakPreview ? SheetView::SHEETVIEW_PAGE_BREAK_PREVIEW : SheetView::SHEETVIEW_NORMAL;
  2872|             $this->phpSheet->getSheetView()->setView($view);
  2873|             if ($this->version === self::XLS_BIFF8) {
  2874|                 $zoomScale = $isPageBreakPreview ? $zoomscaleInPageBreakPreview : $zoomscaleInNormalView;
  2875|                 $this->phpSheet->getSheetView()->setZoomScale($zoomScale);
  2876|                 $this->phpSheet->getSheetView()->setZoomScaleNormal($zoomscaleInNormalView);
  2877|             }
  2878|         }
  2879|     }
  2880|     /**
  2881|      * Read PLV Record(Created by Excel2007 or upper).
  2882|      */
  2883|     private function readPageLayoutView(): void
  2884|     {
  2885|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2886|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2887|         $this->pos += 4 + $length;
  2888|         $wScalePLV = self::getUInt2d($recordData, 12);
  2889|         $grbit = self::getUInt2d($recordData, 14);
  2890|         $fPageLayoutView = $grbit & 0x01;
  2891|         if ($fPageLayoutView === 1) {
  2892|             $this->phpSheet->getSheetView()->setView(SheetView::SHEETVIEW_PAGE_LAYOUT);
  2893|             $this->phpSheet->getSheetView()->setZoomScale($wScalePLV); //set by Excel2007 only if SHEETVIEW_PAGE_LAYOUT
  2894|         }
  2895|     }
  2896|     /**
  2897|      * Read SCL record.
  2898|      */
  2899|     private function readScl(): void
  2900|     {
  2901|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2902|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2903|         $this->pos += 4 + $length;
  2904|         $numerator = self::getUInt2d($recordData, 0);
  2905|         $denumerator = self::getUInt2d($recordData, 2);
  2906|         $this->phpSheet->getSheetView()->setZoomScale($numerator * 100 / $denumerator);
  2907|     }
  2908|     /**
  2909|      * Read PANE record.
  2910|      */
  2911|     private function readPane(): void
  2912|     {
  2913|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2914|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2915|         $this->pos += 4 + $length;
  2916|         if (!$this->readDataOnly) {
  2917|             $px = self::getUInt2d($recordData, 0);
  2918|             $py = self::getUInt2d($recordData, 2);
  2919|             $rwTop = self::getUInt2d($recordData, 4);
  2920|             $colLeft = self::getUInt2d($recordData, 6);
  2921|             if ($this->frozen) {
  2922|                 $cell = Coordinate::stringFromColumnIndex($px + 1) . ($py + 1);
  2923|                 $topLeftCell = Coordinate::stringFromColumnIndex($colLeft + 1) . ($rwTop + 1);
  2924|                 $this->phpSheet->freezePane($cell, $topLeftCell);
  2925|             }
  2926|         }
  2927|     }
  2928|     /**
  2929|      * Read SELECTION record. There is one such record for each pane in the sheet.
  2930|      */
  2931|     private function readSelection(): string
  2932|     {
  2933|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2934|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2935|         $selectedCells = '';
  2936|         $this->pos += 4 + $length;
  2937|         if (!$this->readDataOnly) {
  2938|             $data = substr($recordData, 7);
  2939|             $cellRangeAddressList = $this->readBIFF5CellRangeAddressList($data); // note: also BIFF8 uses BIFF5 syntax
  2940|             $selectedCells = $cellRangeAddressList['cellRangeAddresses'][0];
  2941|             if (preg_match('/^([A-Z]+1\:[A-Z]+)16384$/', $selectedCells)) {
  2942|                 $selectedCells = (string) preg_replace('/^([A-Z]+1\:[A-Z]+)16384$/', '${1}1048576', $selectedCells);
  2943|             }
  2944|             if (preg_match('/^([A-Z]+1\:[A-Z]+)65536$/', $selectedCells)) {
  2945|                 $selectedCells = (string) preg_replace('/^([A-Z]+1\:[A-Z]+)65536$/', '${1}1048576', $selectedCells);
  2946|             }
  2947|             if (preg_match('/^(A\d+\:)IV(\d+)$/', $selectedCells)) {
  2948|                 $selectedCells = (string) preg_replace('/^(A\d+\:)IV(\d+)$/', '${1}XFD${2}', $selectedCells);
  2949|             }
  2950|             $this->phpSheet->setSelectedCells($selectedCells);
  2951|         }
  2952|         return $selectedCells;
  2953|     }
  2954|     private function includeCellRangeFiltered(string $cellRangeAddress): bool
  2955|     {
  2956|         $includeCellRange = true;
  2957|         if ($this->getReadFilter() !== null) {
  2958|             $includeCellRange = false;
  2959|             $rangeBoundaries = Coordinate::getRangeBoundaries($cellRangeAddress);
  2960|             ++$rangeBoundaries[1][0];
  2961|             for ($row = $rangeBoundaries[0][1]; $row <= $rangeBoundaries[1][1]; ++$row) {
  2962|                 for ($column = $rangeBoundaries[0][0]; $column != $rangeBoundaries[1][0]; ++$column) {
  2963|                     if ($this->getReadFilter()->readCell($column, $row, $this->phpSheet->getTitle())) {
  2964|                         $includeCellRange = true;
  2965|                         break 2;
  2966|                     }
  2967|                 }
  2968|             }
  2969|         }
  2970|         return $includeCellRange;
  2971|     }
  2972|     /**
  2973|      * MERGEDCELLS.
  2974|      *
  2975|      * This record contains the addresses of merged cell ranges
  2976|      * in the current sheet.
  2977|      *
  2978|      * --    "OpenOffice.org's Documentation of the Microsoft
  2979|      *         Excel File Format"
  2980|      */
  2981|     private function readMergedCells(): void
  2982|     {
  2983|         $length = self::getUInt2d($this->data, $this->pos + 2);
  2984|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  2985|         $this->pos += 4 + $length;
  2986|         if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
  2987|             $cellRangeAddressList = $this->readBIFF8CellRangeAddressList($recordData);
  2988|             foreach ($cellRangeAddressList['cellRangeAddresses'] as $cellRangeAddress) {
  2989|                 if (
  2990|                     (str_contains($cellRangeAddress, ':'))
  2991|                     && ($this->includeCellRangeFiltered($cellRangeAddress))
  2992|                 ) {
  2993|                     $this->phpSheet->mergeCells($cellRangeAddress, Worksheet::MERGE_CELL_CONTENT_HIDE);
  2994|                 }
  2995|             }
  2996|         }
  2997|     }
  2998|     /**
  2999|      * Read HYPERLINK record.
  3000|      */
  3001|     private function readHyperLink(): void
  3002|     {
  3003|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3004|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3005|         $this->pos += 4 + $length;
  3006|         if (!$this->readDataOnly) {
  3007|             try {
  3008|                 $cellRange = $this->readBIFF8CellRangeAddressFixed($recordData);
  3009|             } catch (PhpSpreadsheetException) {
  3010|                 return;
  3011|             }
  3012|             $isFileLinkOrUrl = (0x00000001 & self::getUInt2d($recordData, 28)) >> 0;
  3013|             $hasDesc = (0x00000014 & self::getUInt2d($recordData, 28)) >> 2;
  3014|             $hasText = (0x00000008 & self::getUInt2d($recordData, 28)) >> 3;
  3015|             $hasFrame = (0x00000080 & self::getUInt2d($recordData, 28)) >> 7;
  3016|             $isUNC = (0x00000100 & self::getUInt2d($recordData, 28)) >> 8;
  3017|             $offset = 32;
  3018|             if ($hasDesc) {
  3019|                 $dl = self::getInt4d($recordData, 32);
  3020|                 $offset += 4 + 2 * $dl;
  3021|             }
  3022|             if ($hasFrame) {
  3023|                 $fl = self::getInt4d($recordData, $offset);
  3024|                 $offset += 4 + 2 * $fl;
  3025|             }
  3026|             $hyperlinkType = null;
  3027|             if ($isUNC) {
  3028|                 $hyperlinkType = 'UNC';
  3029|             } elseif (!$isFileLinkOrUrl) {
  3030|                 $hyperlinkType = 'workbook';
  3031|             } elseif (ord($recordData[$offset]) == 0x03) {
  3032|                 $hyperlinkType = 'local';
  3033|             } elseif (ord($recordData[$offset]) == 0xE0) {
  3034|                 $hyperlinkType = 'URL';
  3035|             }
  3036|             switch ($hyperlinkType) {
  3037|                 case 'URL':
  3038|                     $offset += 16;
  3039|                     $us = self::getInt4d($recordData, $offset);
  3040|                     $offset += 4;
  3041|                     $url = self::encodeUTF16(substr($recordData, $offset, $us - 2), false);
  3042|                     $nullOffset = strpos($url, chr(0x00));
  3043|                     if ($nullOffset) {
  3044|                         $url = substr($url, 0, $nullOffset);
  3045|                     }
  3046|                     $url .= $hasText ? '#' : '';
  3047|                     $offset += $us;
  3048|                     break;
  3049|                 case 'local':
  3050|                     $offset += 16;
  3051|                     $upLevelCount = self::getUInt2d($recordData, $offset);
  3052|                     $offset += 2;
  3053|                     $sl = self::getInt4d($recordData, $offset);
  3054|                     $offset += 4;
  3055|                     $shortenedFilePath = substr($recordData, $offset, $sl);
  3056|                     $shortenedFilePath = self::encodeUTF16($shortenedFilePath, true);
  3057|                     $shortenedFilePath = substr($shortenedFilePath, 0, -1); // remove trailing zero
  3058|                     $offset += $sl;
  3059|                     $offset += 24;
  3060|                     $sz = self::getInt4d($recordData, $offset);
  3061|                     $offset += 4;
  3062|                     $extendedFilePath = '';
  3063|                     if ($sz > 0) {
  3064|                         $xl = self::getInt4d($recordData, $offset);
  3065|                         $offset += 4;
  3066|                         $offset += 2;
  3067|                         $extendedFilePath = substr($recordData, $offset, $xl);
  3068|                         $extendedFilePath = self::encodeUTF16($extendedFilePath, false);
  3069|                         $offset += $xl;
  3070|                     }
  3071|                     $url = str_repeat('..\\', $upLevelCount);
  3072|                     $url .= ($sz > 0) ? $extendedFilePath : $shortenedFilePath; // use extended path if available
  3073|                     $url .= $hasText ? '#' : '';
  3074|                     break;
  3075|                 case 'UNC':
  3076|                     return;
  3077|                 case 'workbook':
  3078|                     $url = 'sheet://';
  3079|                     break;
  3080|                 default:
  3081|                     return;
  3082|             }
  3083|             if ($hasText) {
  3084|                 $tl = self::getInt4d($recordData, $offset);
  3085|                 $offset += 4;
  3086|                 $text = self::encodeUTF16(substr($recordData, $offset, 2 * ($tl - 1)), false);
  3087|                 $url .= $text;
  3088|             }
  3089|             foreach (Coordinate::extractAllCellReferencesInRange($cellRange) as $coordinate) {
  3090|                 $this->phpSheet->getCell($coordinate)->getHyperLink()->setUrl($url);
  3091|             }
  3092|         }
  3093|     }
  3094|     /**
  3095|      * Read DATAVALIDATIONS record.
  3096|      */
  3097|     private function readDataValidations(): void
  3098|     {
  3099|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3100|         $this->pos += 4 + $length;
  3101|     }
  3102|     /**
  3103|      * Read DATAVALIDATION record.
  3104|      */
  3105|     private function readDataValidation(): void
  3106|     {
  3107|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3108|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3109|         $this->pos += 4 + $length;
  3110|         if ($this->readDataOnly) {
  3111|             return;
  3112|         }
  3113|         $options = self::getInt4d($recordData, 0);
  3114|         $type = (0x0000000F & $options) >> 0;
  3115|         $type = Xls\DataValidationHelper::type($type);
  3116|         $errorStyle = (0x00000070 & $options) >> 4;
  3117|         $errorStyle = Xls\DataValidationHelper::errorStyle($errorStyle);
  3118|         $allowBlank = (0x00000100 & $options) >> 8;
  3119|         $suppressDropDown = (0x00000200 & $options) >> 9;
  3120|         $showInputMessage = (0x00040000 & $options) >> 18;
  3121|         $showErrorMessage = (0x00080000 & $options) >> 19;
  3122|         $operator = (0x00F00000 & $options) >> 20;
  3123|         $operator = Xls\DataValidationHelper::operator($operator);
  3124|         if ($type === null || $errorStyle === null || $operator === null) {
  3125|             return;
  3126|         }
  3127|         $offset = 4;
  3128|         $string = self::readUnicodeStringLong(substr($recordData, $offset));
  3129|         $promptTitle = $string['value'] !== chr(0) ? $string['value'] : '';
  3130|         $offset += $string['size'];
  3131|         $string = self::readUnicodeStringLong(substr($recordData, $offset));
  3132|         $errorTitle = $string['value'] !== chr(0) ? $string['value'] : '';
  3133|         $offset += $string['size'];
  3134|         $string = self::readUnicodeStringLong(substr($recordData, $offset));
  3135|         $prompt = $string['value'] !== chr(0) ? $string['value'] : '';
  3136|         $offset += $string['size'];
  3137|         $string = self::readUnicodeStringLong(substr($recordData, $offset));
  3138|         $error = $string['value'] !== chr(0) ? $string['value'] : '';
  3139|         $offset += $string['size'];
  3140|         $sz1 = self::getUInt2d($recordData, $offset);
  3141|         $offset += 2;
  3142|         $offset += 2;
  3143|         $formula1 = substr($recordData, $offset, $sz1);
  3144|         $formula1 = pack('v', $sz1) . $formula1; // prepend the length
  3145|         try {
  3146|             $formula1 = $this->getFormulaFromStructure($formula1);
  3147|             if ($type == DataValidation::TYPE_LIST) {
  3148|                 $formula1 = str_replace(chr(0), ',', $formula1);
  3149|             }
  3150|         } catch (PhpSpreadsheetException $e) {
  3151|             return;
  3152|         }
  3153|         $offset += $sz1;
  3154|         $sz2 = self::getUInt2d($recordData, $offset);
  3155|         $offset += 2;
  3156|         $offset += 2;
  3157|         $formula2 = substr($recordData, $offset, $sz2);
  3158|         $formula2 = pack('v', $sz2) . $formula2; // prepend the length
  3159|         try {
  3160|             $formula2 = $this->getFormulaFromStructure($formula2);
  3161|         } catch (PhpSpreadsheetException) {
  3162|             return;
  3163|         }
  3164|         $offset += $sz2;
  3165|         $cellRangeAddressList = $this->readBIFF8CellRangeAddressList(substr($recordData, $offset));
  3166|         $cellRangeAddresses = $cellRangeAddressList['cellRangeAddresses'];
  3167|         foreach ($cellRangeAddresses as $cellRange) {
  3168|             $stRange = $this->phpSheet->shrinkRangeToFit($cellRange);
  3169|             foreach (Coordinate::extractAllCellReferencesInRange($stRange) as $coordinate) {
  3170|                 $objValidation = $this->phpSheet->getCell($coordinate)->getDataValidation();
  3171|                 $objValidation->setType($type);
  3172|                 $objValidation->setErrorStyle($errorStyle);
  3173|                 $objValidation->setAllowBlank((bool) $allowBlank);
  3174|                 $objValidation->setShowInputMessage((bool) $showInputMessage);
  3175|                 $objValidation->setShowErrorMessage((bool) $showErrorMessage);
  3176|                 $objValidation->setShowDropDown(!$suppressDropDown);
  3177|                 $objValidation->setOperator($operator);
  3178|                 $objValidation->setErrorTitle($errorTitle);
  3179|                 $objValidation->setError($error);
  3180|                 $objValidation->setPromptTitle($promptTitle);
  3181|                 $objValidation->setPrompt($prompt);
  3182|                 $objValidation->setFormula1($formula1);
  3183|                 $objValidation->setFormula2($formula2);
  3184|             }
  3185|         }
  3186|     }
  3187|     /**
  3188|      * Read SHEETLAYOUT record. Stores sheet tab color information.
  3189|      */
  3190|     private function readSheetLayout(): void
  3191|     {
  3192|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3193|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3194|         $this->pos += 4 + $length;
  3195|         if (!$this->readDataOnly) {
  3196|             $sz = self::getInt4d($recordData, 12);
  3197|             switch ($sz) {
  3198|                 case 0x14:
  3199|                     $colorIndex = self::getUInt2d($recordData, 16);
  3200|                     $color = Xls\Color::map($colorIndex, $this->palette, $this->version);
  3201|                     $this->phpSheet->getTabColor()->setRGB($color['rgb']);
  3202|                     break;
  3203|                 case 0x28:
  3204|                     return;
  3205|             }
  3206|         }
  3207|     }
  3208|     /**
  3209|      * Read SHEETPROTECTION record (FEATHEADR).
  3210|      */
  3211|     private function readSheetProtection(): void
  3212|     {
  3213|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3214|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3215|         $this->pos += 4 + $length;
  3216|         if ($this->readDataOnly) {
  3217|             return;
  3218|         }
  3219|         $isf = self::getUInt2d($recordData, 12);
  3220|         if ($isf != 2) {
  3221|             return;
  3222|         }
  3223|         $options = self::getUInt2d($recordData, 19);
  3224|         $bool = (0x0001 & $options) >> 0;
  3225|         $this->phpSheet->getProtection()->setObjects((bool) $bool);
  3226|         $bool = (0x0002 & $options) >> 1;
  3227|         $this->phpSheet->getProtection()->setScenarios((bool) $bool);
  3228|         $bool = (0x0004 & $options) >> 2;
  3229|         $this->phpSheet->getProtection()->setFormatCells(!$bool);
  3230|         $bool = (0x0008 & $options) >> 3;
  3231|         $this->phpSheet->getProtection()->setFormatColumns(!$bool);
  3232|         $bool = (0x0010 & $options) >> 4;
  3233|         $this->phpSheet->getProtection()->setFormatRows(!$bool);
  3234|         $bool = (0x0020 & $options) >> 5;
  3235|         $this->phpSheet->getProtection()->setInsertColumns(!$bool);
  3236|         $bool = (0x0040 & $options) >> 6;
  3237|         $this->phpSheet->getProtection()->setInsertRows(!$bool);
  3238|         $bool = (0x0080 & $options) >> 7;
  3239|         $this->phpSheet->getProtection()->setInsertHyperlinks(!$bool);
  3240|         $bool = (0x0100 & $options) >> 8;
  3241|         $this->phpSheet->getProtection()->setDeleteColumns(!$bool);
  3242|         $bool = (0x0200 & $options) >> 9;
  3243|         $this->phpSheet->getProtection()->setDeleteRows(!$bool);
  3244|         $bool = (0x0400 & $options) >> 10;
  3245|         $this->phpSheet->getProtection()->setSelectLockedCells((bool) $bool);
  3246|         $bool = (0x0800 & $options) >> 11;
  3247|         $this->phpSheet->getProtection()->setSort(!$bool);
  3248|         $bool = (0x1000 & $options) >> 12;
  3249|         $this->phpSheet->getProtection()->setAutoFilter(!$bool);
  3250|         $bool = (0x2000 & $options) >> 13;
  3251|         $this->phpSheet->getProtection()->setPivotTables(!$bool);
  3252|         $bool = (0x4000 & $options) >> 14;
  3253|         $this->phpSheet->getProtection()->setSelectUnlockedCells((bool) $bool);
  3254|     }
  3255|     /**
  3256|      * Read RANGEPROTECTION record
  3257|      * Reading of this record is based on Microsoft Office Excel 97-2000 Binary File Format Specification,
  3258|      * where it is referred to as FEAT record.
  3259|      */
  3260|     private function readRangeProtection(): void
  3261|     {
  3262|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3263|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3264|         $this->pos += 4 + $length;
  3265|         $offset = 0;
  3266|         if (!$this->readDataOnly) {
  3267|             $offset += 12;
  3268|             $isf = self::getUInt2d($recordData, 12);
  3269|             if ($isf != 2) {
  3270|                 return;
  3271|             }
  3272|             $offset += 2;
  3273|             $offset += 5;
  3274|             $cref = self::getUInt2d($recordData, 19);
  3275|             $offset += 2;
  3276|             $offset += 6;
  3277|             $cellRanges = [];
  3278|             for ($i = 0; $i < $cref; ++$i) {
  3279|                 try {
  3280|                     $cellRange = $this->readBIFF8CellRangeAddressFixed(substr($recordData, 27 + 8 * $i, 8));
  3281|                 } catch (PhpSpreadsheetException) {
  3282|                     return;
  3283|                 }
  3284|                 $cellRanges[] = $cellRange;
  3285|                 $offset += 8;
  3286|             }
  3287|             $offset += 4;
  3288|             $wPassword = self::getInt4d($recordData, $offset);
  3289|             $offset += 4;
  3290|             if ($cellRanges) {
  3291|                 $this->phpSheet->protectCells(implode(' ', $cellRanges), ($wPassword === 0) ? '' : strtoupper(dechex($wPassword)), true);
  3292|             }
  3293|         }
  3294|     }
  3295|     /**
  3296|      * Read a free CONTINUE record. Free CONTINUE record may be a camouflaged MSODRAWING record
  3297|      * When MSODRAWING data on a sheet exceeds 8224 bytes, CONTINUE records are used instead. Undocumented.
  3298|      * In this case, we must treat the CONTINUE record as a MSODRAWING record.
  3299|      */
  3300|     private function readContinue(): void
  3301|     {
  3302|         $length = self::getUInt2d($this->data, $this->pos + 2);
  3303|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  3304|         if ($this->drawingData == '') {
  3305|             $this->pos += 4 + $length;
  3306|             return;
  3307|         }
  3308|         if ($length < 4) {
  3309|             $this->pos += 4 + $length;
  3310|             return;
  3311|         }
  3312|         $validSplitPoints = [0xF003, 0xF004, 0xF00D]; // add identifiers if we find more
  3313|         $splitPoint = self::getUInt2d($recordData, 2);
  3314|         if (in_array($splitPoint, $validSplitPoints)) {
  3315|             $splicedRecordData = $this->getSplicedRecordData();
  3316|             $this->drawingData .= $splicedRecordData['recordData'];
  3317|             return;
  3318|         }
  3319|         $this->pos += 4 + $length;
  3320|     }
  3321|     /**
  3322|      * Reads a record from current position in data stream and continues reading data as long as CONTINUE
  3323|      * records are found. Splices the record data pieces and returns the combined string as if record data
  3324|      * is in one piece.
  3325|      * Moves to next current position in data stream to start of next record different from a CONtINUE record.
  3326|      */
  3327|     private function getSplicedRecordData(): array
  3328|     {
  3329|         $data = '';
  3330|         $spliceOffsets = [];
  3331|         $i = 0;
  3332|         $spliceOffsets[0] = 0;
  3333|         do {
  3334|             ++$i;
  3335|             $length = self::getUInt2d($this->data, $this->pos + 2);
  3336|             $data .= $this->readRecordData($this->data, $this->pos + 4, $length);
  3337|             $spliceOffsets[$i] = $spliceOffsets[$i - 1] + $length;
  3338|             $this->pos += 4 + $length;
  3339|             $nextIdentifier = self::getUInt2d($this->data, $this->pos);
  3340|         } while ($nextIdentifier == self::XLS_TYPE_CONTINUE);
  3341|         return [
  3342|             'recordData' => $data,
  3343|             'spliceOffsets' => $spliceOffsets,
  3344|         ];
  3345|     }
  3346|     /**
  3347|      * Convert formula structure into human readable Excel formula like 'A3+A5*5'.
  3348|      *
  3349|      * @param string $formulaStructure The complete binary data for the formula
  3350|      * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
  3351|      *
  3352|      * @return string Human readable formula
  3353|      */
  3354|     private function getFormulaFromStructure(string $formulaStructure, string $baseCell = 'A1'): string
  3355|     {
  3356|         $sz = self::getUInt2d($formulaStructure, 0);
  3357|         $formulaData = substr($formulaStructure, 2, $sz);
  3358|         if (strlen($formulaStructure) > 2 + $sz) {
  3359|             $additionalData = substr($formulaStructure, 2 + $sz);
  3360|         } else {
  3361|             $additionalData = '';
  3362|         }
  3363|         return $this->getFormulaFromData($formulaData, $additionalData, $baseCell);
  3364|     }
  3365|     /**
  3366|      * Take formula data and additional data for formula and return human readable formula.
  3367|      *
  3368|      * @param string $formulaData The binary data for the formula itself
  3369|      * @param string $additionalData Additional binary data going with the formula
  3370|      * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
  3371|      *
  3372|      * @return string Human readable formula
  3373|      */
  3374|     private function getFormulaFromData(string $formulaData, string $additionalData = '', string $baseCell = 'A1'): string
  3375|     {
  3376|         $tokens = [];
  3377|         while ($formulaData !== '' && $token = $this->getNextToken($formulaData, $baseCell)) {
  3378|             $tokens[] = $token;
  3379|             $formulaData = substr($formulaData, $token['size']);
  3380|         }
  3381|         $formulaString = $this->createFormulaFromTokens($tokens, $additionalData);
  3382|         return $formulaString;
  3383|     }
  3384|     /**
  3385|      * Take array of tokens together with additional data for formula and return human readable formula.
  3386|      *
  3387|      * @param string $additionalData Additional binary data going with the formula
  3388|      *
  3389|      * @return string Human readable formula
  3390|      */
  3391|     private function createFormulaFromTokens(array $tokens, string $additionalData): string
  3392|     {
  3393|         if (empty($tokens)) {
  3394|             return '';
  3395|         }
  3396|         $formulaStrings = [];
  3397|         foreach ($tokens as $token) {
  3398|             $space0 = $space0 ?? ''; // spaces before next token, not tParen
  3399|             $space1 = $space1 ?? ''; // carriage returns before next token, not tParen
  3400|             $space2 = $space2 ?? ''; // spaces before opening parenthesis
  3401|             $space3 = $space3 ?? ''; // carriage returns before opening parenthesis
  3402|             $space4 = $space4 ?? ''; // spaces before closing parenthesis
  3403|             $space5 = $space5 ?? ''; // carriage returns before closing parenthesis
  3404|             switch ($token['name']) {
  3405|                 case 'tAdd': // addition
  3406|                 case 'tConcat': // addition
  3407|                 case 'tDiv': // division
  3408|                 case 'tEQ': // equality
  3409|                 case 'tGE': // greater than or equal
  3410|                 case 'tGT': // greater than
  3411|                 case 'tIsect': // intersection
  3412|                 case 'tLE': // less than or equal
  3413|                 case 'tList': // less than or equal
  3414|                 case 'tLT': // less than
  3415|                 case 'tMul': // multiplication
  3416|                 case 'tNE': // multiplication
  3417|                 case 'tPower': // power
  3418|                 case 'tRange': // range
  3419|                 case 'tSub': // subtraction
  3420|                     $op2 = array_pop($formulaStrings);
  3421|                     $op1 = array_pop($formulaStrings);
  3422|                     $formulaStrings[] = "$op1$space1$space0{$token['data']}$op2";
  3423|                     unset($space0, $space1);
  3424|                     break;
  3425|                 case 'tUplus': // unary plus
  3426|                 case 'tUminus': // unary minus
  3427|                     $op = array_pop($formulaStrings);
  3428|                     $formulaStrings[] = "$space1$space0{$token['data']}$op";
  3429|                     unset($space0, $space1);
  3430|                     break;
  3431|                 case 'tPercent': // percent sign
  3432|                     $op = array_pop($formulaStrings);
  3433|                     $formulaStrings[] = "$op$space1$space0{$token['data']}";
  3434|                     unset($space0, $space1);
  3435|                     break;
  3436|                 case 'tAttrVolatile': // indicates volatile function
  3437|                 case 'tAttrIf':
  3438|                 case 'tAttrSkip':
  3439|                 case 'tAttrChoose':
  3440|                     break;
  3441|                 case 'tAttrSpace': // space / carriage return
  3442|                     switch ($token['data']['spacetype']) {
  3443|                         case 'type0':
  3444|                             $space0 = str_repeat(' ', $token['data']['spacecount']);
  3445|                             break;
  3446|                         case 'type1':
  3447|                             $space1 = str_repeat("\n", $token['data']['spacecount']);
  3448|                             break;
  3449|                         case 'type2':
  3450|                             $space2 = str_repeat(' ', $token['data']['spacecount']);
  3451|                             break;
  3452|                         case 'type3':
  3453|                             $space3 = str_repeat("\n", $token['data']['spacecount']);
  3454|                             break;
  3455|                         case 'type4':
  3456|                             $space4 = str_repeat(' ', $token['data']['spacecount']);
  3457|                             break;
  3458|                         case 'type5':
  3459|                             $space5 = str_repeat("\n", $token['data']['spacecount']);
  3460|                             break;
  3461|                     }
  3462|                     break;
  3463|                 case 'tAttrSum': // SUM function with one parameter
  3464|                     $op = array_pop($formulaStrings);
  3465|                     $formulaStrings[] = "{$space1}{$space0}SUM($op)";
  3466|                     unset($space0, $space1);
  3467|                     break;
  3468|                 case 'tFunc': // function with fixed number of arguments
  3469|                 case 'tFuncV': // function with variable number of arguments
  3470|                     if ($token['data']['function'] != '') {
  3471|                         $ops = []; // array of operators
  3472|                         for ($i = 0; $i < $token['data']['args']; ++$i) {
  3473|                             $ops[] = array_pop($formulaStrings);
  3474|                         }
  3475|                         $ops = array_reverse($ops);
  3476|                         $formulaStrings[] = "$space1$space0{$token['data']['function']}(" . implode(',', $ops) . ')';
  3477|                         unset($space0, $space1);
  3478|                     } else {
  3479|                         $ops = []; // array of operators
  3480|                         for ($i = 0; $i < $token['data']['args'] - 1; ++$i) {
  3481|                             $ops[] = array_pop($formulaStrings);
  3482|                         }
  3483|                         $ops = array_reverse($ops);
  3484|                         $function = array_pop($formulaStrings);
  3485|                         $formulaStrings[] = "$space1$space0$function(" . implode(',', $ops) . ')';
  3486|                         unset($space0, $space1);
  3487|                     }
  3488|                     break;
  3489|                 case 'tParen': // parenthesis
  3490|                     $expression = array_pop($formulaStrings);
  3491|                     $formulaStrings[] = "$space3$space2($expression$space5$space4)";
  3492|                     unset($space2, $space3, $space4, $space5);
  3493|                     break;
  3494|                 case 'tArray': // array constant
  3495|                     $constantArray = self::readBIFF8ConstantArray($additionalData);
  3496|                     $formulaStrings[] = $space1 . $space0 . $constantArray['value'];
  3497|                     $additionalData = substr($additionalData, $constantArray['size']); // bite of chunk of additional data
  3498|                     unset($space0, $space1);
  3499|                     break;
  3500|                 case 'tMemArea':
  3501|                     $cellRangeAddressList = $this->readBIFF8CellRangeAddressList($additionalData);
  3502|                     $additionalData = substr($additionalData, $cellRangeAddressList['size']);
  3503|                     $formulaStrings[] = "$space1$space0{$token['data']}";
  3504|                     unset($space0, $space1);
  3505|                     break;
  3506|                 case 'tArea': // cell range address
  3507|                 case 'tBool': // boolean
  3508|                 case 'tErr': // error code
  3509|                 case 'tInt': // integer
  3510|                 case 'tMemErr':
  3511|                 case 'tMemFunc':
  3512|                 case 'tMissArg':
  3513|                 case 'tName':
  3514|                 case 'tNameX':
  3515|                 case 'tNum': // number
  3516|                 case 'tRef': // single cell reference
  3517|                 case 'tRef3d': // 3d cell reference
  3518|                 case 'tArea3d': // 3d cell range reference
  3519|                 case 'tRefN':
  3520|                 case 'tAreaN':
  3521|                 case 'tStr': // string
  3522|                     $formulaStrings[] = "$space1$space0{$token['data']}";
  3523|                     unset($space0, $space1);
  3524|                     break;
  3525|             }
  3526|         }
  3527|         $formulaString = $formulaStrings[0];
  3528|         return $formulaString;
  3529|     }
  3530|     /**
  3531|      * Fetch next token from binary formula data.
  3532|      *
  3533|      * @param string $formulaData Formula data
  3534|      * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
  3535|      */
  3536|     private function getNextToken(string $formulaData, string $baseCell = 'A1'): array
  3537|     {
  3538|         $id = ord($formulaData[0]); // token id
  3539|         $name = false; // initialize token name
  3540|         switch ($id) {
  3541|             case 0x03:
  3542|                 $name = 'tAdd';
  3543|                 $size = 1;
  3544|                 $data = '+';
  3545|                 break;
  3546|             case 0x04:
  3547|                 $name = 'tSub';
  3548|                 $size = 1;
  3549|                 $data = '-';
  3550|                 break;
  3551|             case 0x05:
  3552|                 $name = 'tMul';
  3553|                 $size = 1;
  3554|                 $data = '*';
  3555|                 break;
  3556|             case 0x06:
  3557|                 $name = 'tDiv';
  3558|                 $size = 1;
  3559|                 $data = '/';
  3560|                 break;
  3561|             case 0x07:
  3562|                 $name = 'tPower';
  3563|                 $size = 1;
  3564|                 $data = '^';
  3565|                 break;
  3566|             case 0x08:
  3567|                 $name = 'tConcat';
  3568|                 $size = 1;
  3569|                 $data = '&';
  3570|                 break;
  3571|             case 0x09:
  3572|                 $name = 'tLT';
  3573|                 $size = 1;
  3574|                 $data = '<';
  3575|                 break;
  3576|             case 0x0A:
  3577|                 $name = 'tLE';
  3578|                 $size = 1;
  3579|                 $data = '<=';
  3580|                 break;
  3581|             case 0x0B:
  3582|                 $name = 'tEQ';
  3583|                 $size = 1;
  3584|                 $data = '=';
  3585|                 break;
  3586|             case 0x0C:
  3587|                 $name = 'tGE';
  3588|                 $size = 1;
  3589|                 $data = '>=';
  3590|                 break;
  3591|             case 0x0D:
  3592|                 $name = 'tGT';
  3593|                 $size = 1;
  3594|                 $data = '>';
  3595|                 break;
  3596|             case 0x0E:
  3597|                 $name = 'tNE';
  3598|                 $size = 1;
  3599|                 $data = '<>';
  3600|                 break;
  3601|             case 0x0F:
  3602|                 $name = 'tIsect';
  3603|                 $size = 1;
  3604|                 $data = ' ';
  3605|                 break;
  3606|             case 0x10:
  3607|                 $name = 'tList';
  3608|                 $size = 1;
  3609|                 $data = ',';
  3610|                 break;
  3611|             case 0x11:
  3612|                 $name = 'tRange';
  3613|                 $size = 1;
  3614|                 $data = ':';
  3615|                 break;
  3616|             case 0x12:
  3617|                 $name = 'tUplus';
  3618|                 $size = 1;
  3619|                 $data = '+';
  3620|                 break;
  3621|             case 0x13:
  3622|                 $name = 'tUminus';
  3623|                 $size = 1;
  3624|                 $data = '-';
  3625|                 break;
  3626|             case 0x14:
  3627|                 $name = 'tPercent';
  3628|                 $size = 1;
  3629|                 $data = '%';
  3630|                 break;
  3631|             case 0x15:    //    parenthesis
  3632|                 $name = 'tParen';
  3633|                 $size = 1;
  3634|                 $data = null;
  3635|                 break;
  3636|             case 0x16:    //    missing argument
  3637|                 $name = 'tMissArg';
  3638|                 $size = 1;
  3639|                 $data = '';
  3640|                 break;
  3641|             case 0x17:    //    string
  3642|                 $name = 'tStr';
  3643|                 $string = self::readUnicodeStringShort(substr($formulaData, 1));
  3644|                 $size = 1 + $string['size'];
  3645|                 $data = self::UTF8toExcelDoubleQuoted($string['value']);
  3646|                 break;
  3647|             case 0x19:    //    Special attribute
  3648|                 switch (ord($formulaData[1])) {
  3649|                     case 0x01:
  3650|                         $name = 'tAttrVolatile';
  3651|                         $size = 4;
  3652|                         $data = null;
  3653|                         break;
  3654|                     case 0x02:
  3655|                         $name = 'tAttrIf';
  3656|                         $size = 4;
  3657|                         $data = null;
  3658|                         break;
  3659|                     case 0x04:
  3660|                         $name = 'tAttrChoose';
  3661|                         $nc = self::getUInt2d($formulaData, 2);
  3662|                         $size = 2 * $nc + 6;
  3663|                         $data = null;
  3664|                         break;
  3665|                     case 0x08:
  3666|                         $name = 'tAttrSkip';
  3667|                         $size = 4;
  3668|                         $data = null;
  3669|                         break;
  3670|                     case 0x10:
  3671|                         $name = 'tAttrSum';
  3672|                         $size = 4;
  3673|                         $data = null;
  3674|                         break;
  3675|                     case 0x40:
  3676|                     case 0x41:
  3677|                         $name = 'tAttrSpace';
  3678|                         $size = 4;
  3679|                         $spacetype = match (ord($formulaData[2])) {
  3680|                             0x00 => 'type0',
  3681|                             0x01 => 'type1',
  3682|                             0x02 => 'type2',
  3683|                             0x03 => 'type3',
  3684|                             0x04 => 'type4',
  3685|                             0x05 => 'type5',
  3686|                             default => throw new Exception('Unrecognized space type in tAttrSpace token'),
  3687|                         };
  3688|                         $spacecount = ord($formulaData[3]);
  3689|                         $data = ['spacetype' => $spacetype, 'spacecount' => $spacecount];
  3690|                         break;
  3691|                     default:
  3692|                         throw new Exception('Unrecognized attribute flag in tAttr token');
  3693|                 }
  3694|                 break;
  3695|             case 0x1C:    //    error code
  3696|                 $name = 'tErr';
  3697|                 $size = 2;
  3698|                 $data = Xls\ErrorCode::lookup(ord($formulaData[1]));
  3699|                 break;
  3700|             case 0x1D:    //    boolean
  3701|                 $name = 'tBool';
  3702|                 $size = 2;
  3703|                 $data = ord($formulaData[1]) ? 'TRUE' : 'FALSE';
  3704|                 break;
  3705|             case 0x1E:    //    integer
  3706|                 $name = 'tInt';
  3707|                 $size = 3;
  3708|                 $data = self::getUInt2d($formulaData, 1);
  3709|                 break;
  3710|             case 0x1F:    //    number
  3711|                 $name = 'tNum';
  3712|                 $size = 9;
  3713|                 $data = self::extractNumber(substr($formulaData, 1));
  3714|                 $data = str_replace(',', '.', (string) $data); // in case non-English locale
  3715|                 break;
  3716|             case 0x20:    //    array constant
  3717|             case 0x40:
  3718|             case 0x60:
  3719|                 $name = 'tArray';
  3720|                 $size = 8;
  3721|                 $data = null;
  3722|                 break;
  3723|             case 0x21:    //    function with fixed number of arguments
  3724|             case 0x41:
  3725|             case 0x61:
  3726|                 $name = 'tFunc';
  3727|                 $size = 3;
  3728|                 switch (self::getUInt2d($formulaData, 1)) {
  3729|                     case 2:
  3730|                         $function = 'ISNA';
  3731|                         $args = 1;
  3732|                         break;
  3733|                     case 3:
  3734|                         $function = 'ISERROR';
  3735|                         $args = 1;
  3736|                         break;
  3737|                     case 10:
  3738|                         $function = 'NA';
  3739|                         $args = 0;
  3740|                         break;
  3741|                     case 15:
  3742|                         $function = 'SIN';
  3743|                         $args = 1;
  3744|                         break;
  3745|                     case 16:
  3746|                         $function = 'COS';
  3747|                         $args = 1;
  3748|                         break;
  3749|                     case 17:
  3750|                         $function = 'TAN';
  3751|                         $args = 1;
  3752|                         break;
  3753|                     case 18:
  3754|                         $function = 'ATAN';
  3755|                         $args = 1;
  3756|                         break;
  3757|                     case 19:
  3758|                         $function = 'PI';
  3759|                         $args = 0;
  3760|                         break;
  3761|                     case 20:
  3762|                         $function = 'SQRT';
  3763|                         $args = 1;
  3764|                         break;
  3765|                     case 21:
  3766|                         $function = 'EXP';
  3767|                         $args = 1;
  3768|                         break;
  3769|                     case 22:
  3770|                         $function = 'LN';
  3771|                         $args = 1;
  3772|                         break;
  3773|                     case 23:
  3774|                         $function = 'LOG10';
  3775|                         $args = 1;
  3776|                         break;
  3777|                     case 24:
  3778|                         $function = 'ABS';
  3779|                         $args = 1;
  3780|                         break;
  3781|                     case 25:
  3782|                         $function = 'INT';
  3783|                         $args = 1;
  3784|                         break;
  3785|                     case 26:
  3786|                         $function = 'SIGN';
  3787|                         $args = 1;
  3788|                         break;
  3789|                     case 27:
  3790|                         $function = 'ROUND';
  3791|                         $args = 2;
  3792|                         break;
  3793|                     case 30:
  3794|                         $function = 'REPT';
  3795|                         $args = 2;
  3796|                         break;
  3797|                     case 31:
  3798|                         $function = 'MID';
  3799|                         $args = 3;
  3800|                         break;
  3801|                     case 32:
  3802|                         $function = 'LEN';
  3803|                         $args = 1;
  3804|                         break;
  3805|                     case 33:
  3806|                         $function = 'VALUE';
  3807|                         $args = 1;
  3808|                         break;
  3809|                     case 34:
  3810|                         $function = 'TRUE';
  3811|                         $args = 0;
  3812|                         break;
  3813|                     case 35:
  3814|                         $function = 'FALSE';
  3815|                         $args = 0;
  3816|                         break;
  3817|                     case 38:
  3818|                         $function = 'NOT';
  3819|                         $args = 1;
  3820|                         break;
  3821|                     case 39:
  3822|                         $function = 'MOD';
  3823|                         $args = 2;
  3824|                         break;
  3825|                     case 40:
  3826|                         $function = 'DCOUNT';
  3827|                         $args = 3;
  3828|                         break;
  3829|                     case 41:
  3830|                         $function = 'DSUM';
  3831|                         $args = 3;
  3832|                         break;
  3833|                     case 42:
  3834|                         $function = 'DAVERAGE';
  3835|                         $args = 3;
  3836|                         break;
  3837|                     case 43:
  3838|                         $function = 'DMIN';
  3839|                         $args = 3;
  3840|                         break;
  3841|                     case 44:
  3842|                         $function = 'DMAX';
  3843|                         $args = 3;
  3844|                         break;
  3845|                     case 45:
  3846|                         $function = 'DSTDEV';
  3847|                         $args = 3;
  3848|                         break;
  3849|                     case 48:
  3850|                         $function = 'TEXT';
  3851|                         $args = 2;
  3852|                         break;
  3853|                     case 61:
  3854|                         $function = 'MIRR';
  3855|                         $args = 3;
  3856|                         break;
  3857|                     case 63:
  3858|                         $function = 'RAND';
  3859|                         $args = 0;
  3860|                         break;
  3861|                     case 65:
  3862|                         $function = 'DATE';
  3863|                         $args = 3;
  3864|                         break;
  3865|                     case 66:
  3866|                         $function = 'TIME';
  3867|                         $args = 3;
  3868|                         break;
  3869|                     case 67:
  3870|                         $function = 'DAY';
  3871|                         $args = 1;
  3872|                         break;
  3873|                     case 68:
  3874|                         $function = 'MONTH';
  3875|                         $args = 1;
  3876|                         break;
  3877|                     case 69:
  3878|                         $function = 'YEAR';
  3879|                         $args = 1;
  3880|                         break;
  3881|                     case 71:
  3882|                         $function = 'HOUR';
  3883|                         $args = 1;
  3884|                         break;
  3885|                     case 72:
  3886|                         $function = 'MINUTE';
  3887|                         $args = 1;
  3888|                         break;
  3889|                     case 73:
  3890|                         $function = 'SECOND';
  3891|                         $args = 1;
  3892|                         break;
  3893|                     case 74:
  3894|                         $function = 'NOW';
  3895|                         $args = 0;
  3896|                         break;
  3897|                     case 75:
  3898|                         $function = 'AREAS';
  3899|                         $args = 1;
  3900|                         break;
  3901|                     case 76:
  3902|                         $function = 'ROWS';
  3903|                         $args = 1;
  3904|                         break;
  3905|                     case 77:
  3906|                         $function = 'COLUMNS';
  3907|                         $args = 1;
  3908|                         break;
  3909|                     case 83:
  3910|                         $function = 'TRANSPOSE';
  3911|                         $args = 1;
  3912|                         break;
  3913|                     case 86:
  3914|                         $function = 'TYPE';
  3915|                         $args = 1;
  3916|                         break;
  3917|                     case 97:
  3918|                         $function = 'ATAN2';
  3919|                         $args = 2;
  3920|                         break;
  3921|                     case 98:
  3922|                         $function = 'ASIN';
  3923|                         $args = 1;
  3924|                         break;
  3925|                     case 99:
  3926|                         $function = 'ACOS';
  3927|                         $args = 1;
  3928|                         break;
  3929|                     case 105:
  3930|                         $function = 'ISREF';
  3931|                         $args = 1;
  3932|                         break;
  3933|                     case 111:
  3934|                         $function = 'CHAR';
  3935|                         $args = 1;
  3936|                         break;
  3937|                     case 112:
  3938|                         $function = 'LOWER';
  3939|                         $args = 1;
  3940|                         break;
  3941|                     case 113:
  3942|                         $function = 'UPPER';
  3943|                         $args = 1;
  3944|                         break;
  3945|                     case 114:
  3946|                         $function = 'PROPER';
  3947|                         $args = 1;
  3948|                         break;
  3949|                     case 117:
  3950|                         $function = 'EXACT';
  3951|                         $args = 2;
  3952|                         break;
  3953|                     case 118:
  3954|                         $function = 'TRIM';
  3955|                         $args = 1;
  3956|                         break;
  3957|                     case 119:
  3958|                         $function = 'REPLACE';
  3959|                         $args = 4;
  3960|                         break;
  3961|                     case 121:
  3962|                         $function = 'CODE';
  3963|                         $args = 1;
  3964|                         break;
  3965|                     case 126:
  3966|                         $function = 'ISERR';
  3967|                         $args = 1;
  3968|                         break;
  3969|                     case 127:
  3970|                         $function = 'ISTEXT';
  3971|                         $args = 1;
  3972|                         break;
  3973|                     case 128:
  3974|                         $function = 'ISNUMBER';
  3975|                         $args = 1;
  3976|                         break;
  3977|                     case 129:
  3978|                         $function = 'ISBLANK';
  3979|                         $args = 1;
  3980|                         break;
  3981|                     case 130:
  3982|                         $function = 'T';
  3983|                         $args = 1;
  3984|                         break;
  3985|                     case 131:
  3986|                         $function = 'N';
  3987|                         $args = 1;
  3988|                         break;
  3989|                     case 140:
  3990|                         $function = 'DATEVALUE';
  3991|                         $args = 1;
  3992|                         break;
  3993|                     case 141:
  3994|                         $function = 'TIMEVALUE';
  3995|                         $args = 1;
  3996|                         break;
  3997|                     case 142:
  3998|                         $function = 'SLN';
  3999|                         $args = 3;
  4000|                         break;
  4001|                     case 143:
  4002|                         $function = 'SYD';
  4003|                         $args = 4;
  4004|                         break;
  4005|                     case 162:
  4006|                         $function = 'CLEAN';
  4007|                         $args = 1;
  4008|                         break;
  4009|                     case 163:
  4010|                         $function = 'MDETERM';
  4011|                         $args = 1;
  4012|                         break;
  4013|                     case 164:
  4014|                         $function = 'MINVERSE';
  4015|                         $args = 1;
  4016|                         break;
  4017|                     case 165:
  4018|                         $function = 'MMULT';
  4019|                         $args = 2;
  4020|                         break;
  4021|                     case 184:
  4022|                         $function = 'FACT';
  4023|                         $args = 1;
  4024|                         break;
  4025|                     case 189:
  4026|                         $function = 'DPRODUCT';
  4027|                         $args = 3;
  4028|                         break;
  4029|                     case 190:
  4030|                         $function = 'ISNONTEXT';
  4031|                         $args = 1;
  4032|                         break;
  4033|                     case 195:
  4034|                         $function = 'DSTDEVP';
  4035|                         $args = 3;
  4036|                         break;
  4037|                     case 196:
  4038|                         $function = 'DVARP';
  4039|                         $args = 3;
  4040|                         break;
  4041|                     case 198:
  4042|                         $function = 'ISLOGICAL';
  4043|                         $args = 1;
  4044|                         break;
  4045|                     case 199:
  4046|                         $function = 'DCOUNTA';
  4047|                         $args = 3;
  4048|                         break;
  4049|                     case 207:
  4050|                         $function = 'REPLACEB';
  4051|                         $args = 4;
  4052|                         break;
  4053|                     case 210:
  4054|                         $function = 'MIDB';
  4055|                         $args = 3;
  4056|                         break;
  4057|                     case 211:
  4058|                         $function = 'LENB';
  4059|                         $args = 1;
  4060|                         break;
  4061|                     case 212:
  4062|                         $function = 'ROUNDUP';
  4063|                         $args = 2;
  4064|                         break;
  4065|                     case 213:
  4066|                         $function = 'ROUNDDOWN';
  4067|                         $args = 2;
  4068|                         break;
  4069|                     case 214:
  4070|                         $function = 'ASC';
  4071|                         $args = 1;
  4072|                         break;
  4073|                     case 215:
  4074|                         $function = 'DBCS';
  4075|                         $args = 1;
  4076|                         break;
  4077|                     case 221:
  4078|                         $function = 'TODAY';
  4079|                         $args = 0;
  4080|                         break;
  4081|                     case 229:
  4082|                         $function = 'SINH';
  4083|                         $args = 1;
  4084|                         break;
  4085|                     case 230:
  4086|                         $function = 'COSH';
  4087|                         $args = 1;
  4088|                         break;
  4089|                     case 231:
  4090|                         $function = 'TANH';
  4091|                         $args = 1;
  4092|                         break;
  4093|                     case 232:
  4094|                         $function = 'ASINH';
  4095|                         $args = 1;
  4096|                         break;
  4097|                     case 233:
  4098|                         $function = 'ACOSH';
  4099|                         $args = 1;
  4100|                         break;
  4101|                     case 234:
  4102|                         $function = 'ATANH';
  4103|                         $args = 1;
  4104|                         break;
  4105|                     case 235:
  4106|                         $function = 'DGET';
  4107|                         $args = 3;
  4108|                         break;
  4109|                     case 244:
  4110|                         $function = 'INFO';
  4111|                         $args = 1;
  4112|                         break;
  4113|                     case 252:
  4114|                         $function = 'FREQUENCY';
  4115|                         $args = 2;
  4116|                         break;
  4117|                     case 261:
  4118|                         $function = 'ERROR.TYPE';
  4119|                         $args = 1;
  4120|                         break;
  4121|                     case 271:
  4122|                         $function = 'GAMMALN';
  4123|                         $args = 1;
  4124|                         break;
  4125|                     case 273:
  4126|                         $function = 'BINOMDIST';
  4127|                         $args = 4;
  4128|                         break;
  4129|                     case 274:
  4130|                         $function = 'CHIDIST';
  4131|                         $args = 2;
  4132|                         break;
  4133|                     case 275:
  4134|                         $function = 'CHIINV';
  4135|                         $args = 2;
  4136|                         break;
  4137|                     case 276:
  4138|                         $function = 'COMBIN';
  4139|                         $args = 2;
  4140|                         break;
  4141|                     case 277:
  4142|                         $function = 'CONFIDENCE';
  4143|                         $args = 3;
  4144|                         break;
  4145|                     case 278:
  4146|                         $function = 'CRITBINOM';
  4147|                         $args = 3;
  4148|                         break;
  4149|                     case 279:
  4150|                         $function = 'EVEN';
  4151|                         $args = 1;
  4152|                         break;
  4153|                     case 280:
  4154|                         $function = 'EXPONDIST';
  4155|                         $args = 3;
  4156|                         break;
  4157|                     case 281:
  4158|                         $function = 'FDIST';
  4159|                         $args = 3;
  4160|                         break;
  4161|                     case 282:
  4162|                         $function = 'FINV';
  4163|                         $args = 3;
  4164|                         break;
  4165|                     case 283:
  4166|                         $function = 'FISHER';
  4167|                         $args = 1;
  4168|                         break;
  4169|                     case 284:
  4170|                         $function = 'FISHERINV';
  4171|                         $args = 1;
  4172|                         break;
  4173|                     case 285:
  4174|                         $function = 'FLOOR';
  4175|                         $args = 2;
  4176|                         break;
  4177|                     case 286:
  4178|                         $function = 'GAMMADIST';
  4179|                         $args = 4;
  4180|                         break;
  4181|                     case 287:
  4182|                         $function = 'GAMMAINV';
  4183|                         $args = 3;
  4184|                         break;
  4185|                     case 288:
  4186|                         $function = 'CEILING';
  4187|                         $args = 2;
  4188|                         break;
  4189|                     case 289:
  4190|                         $function = 'HYPGEOMDIST';
  4191|                         $args = 4;
  4192|                         break;
  4193|                     case 290:
  4194|                         $function = 'LOGNORMDIST';
  4195|                         $args = 3;
  4196|                         break;
  4197|                     case 291:
  4198|                         $function = 'LOGINV';
  4199|                         $args = 3;
  4200|                         break;
  4201|                     case 292:
  4202|                         $function = 'NEGBINOMDIST';
  4203|                         $args = 3;
  4204|                         break;
  4205|                     case 293:
  4206|                         $function = 'NORMDIST';
  4207|                         $args = 4;
  4208|                         break;
  4209|                     case 294:
  4210|                         $function = 'NORMSDIST';
  4211|                         $args = 1;
  4212|                         break;
  4213|                     case 295:
  4214|                         $function = 'NORMINV';
  4215|                         $args = 3;
  4216|                         break;
  4217|                     case 296:
  4218|                         $function = 'NORMSINV';
  4219|                         $args = 1;
  4220|                         break;
  4221|                     case 297:
  4222|                         $function = 'STANDARDIZE';
  4223|                         $args = 3;
  4224|                         break;
  4225|                     case 298:
  4226|                         $function = 'ODD';
  4227|                         $args = 1;
  4228|                         break;
  4229|                     case 299:
  4230|                         $function = 'PERMUT';
  4231|                         $args = 2;
  4232|                         break;
  4233|                     case 300:
  4234|                         $function = 'POISSON';
  4235|                         $args = 3;
  4236|                         break;
  4237|                     case 301:
  4238|                         $function = 'TDIST';
  4239|                         $args = 3;
  4240|                         break;
  4241|                     case 302:
  4242|                         $function = 'WEIBULL';
  4243|                         $args = 4;
  4244|                         break;
  4245|                     case 303:
  4246|                         $function = 'SUMXMY2';
  4247|                         $args = 2;
  4248|                         break;
  4249|                     case 304:
  4250|                         $function = 'SUMX2MY2';
  4251|                         $args = 2;
  4252|                         break;
  4253|                     case 305:
  4254|                         $function = 'SUMX2PY2';
  4255|                         $args = 2;
  4256|                         break;
  4257|                     case 306:
  4258|                         $function = 'CHITEST';
  4259|                         $args = 2;
  4260|                         break;
  4261|                     case 307:
  4262|                         $function = 'CORREL';
  4263|                         $args = 2;
  4264|                         break;
  4265|                     case 308:
  4266|                         $function = 'COVAR';
  4267|                         $args = 2;
  4268|                         break;
  4269|                     case 309:
  4270|                         $function = 'FORECAST';
  4271|                         $args = 3;
  4272|                         break;
  4273|                     case 310:
  4274|                         $function = 'FTEST';
  4275|                         $args = 2;
  4276|                         break;
  4277|                     case 311:
  4278|                         $function = 'INTERCEPT';
  4279|                         $args = 2;
  4280|                         break;
  4281|                     case 312:
  4282|                         $function = 'PEARSON';
  4283|                         $args = 2;
  4284|                         break;
  4285|                     case 313:
  4286|                         $function = 'RSQ';
  4287|                         $args = 2;
  4288|                         break;
  4289|                     case 314:
  4290|                         $function = 'STEYX';
  4291|                         $args = 2;
  4292|                         break;
  4293|                     case 315:
  4294|                         $function = 'SLOPE';
  4295|                         $args = 2;
  4296|                         break;
  4297|                     case 316:
  4298|                         $function = 'TTEST';
  4299|                         $args = 4;
  4300|                         break;
  4301|                     case 325:
  4302|                         $function = 'LARGE';
  4303|                         $args = 2;
  4304|                         break;
  4305|                     case 326:
  4306|                         $function = 'SMALL';
  4307|                         $args = 2;
  4308|                         break;
  4309|                     case 327:
  4310|                         $function = 'QUARTILE';
  4311|                         $args = 2;
  4312|                         break;
  4313|                     case 328:
  4314|                         $function = 'PERCENTILE';
  4315|                         $args = 2;
  4316|                         break;
  4317|                     case 331:
  4318|                         $function = 'TRIMMEAN';
  4319|                         $args = 2;
  4320|                         break;
  4321|                     case 332:
  4322|                         $function = 'TINV';
  4323|                         $args = 2;
  4324|                         break;
  4325|                     case 337:
  4326|                         $function = 'POWER';
  4327|                         $args = 2;
  4328|                         break;
  4329|                     case 342:
  4330|                         $function = 'RADIANS';
  4331|                         $args = 1;
  4332|                         break;
  4333|                     case 343:
  4334|                         $function = 'DEGREES';
  4335|                         $args = 1;
  4336|                         break;
  4337|                     case 346:
  4338|                         $function = 'COUNTIF';
  4339|                         $args = 2;
  4340|                         break;
  4341|                     case 347:
  4342|                         $function = 'COUNTBLANK';
  4343|                         $args = 1;
  4344|                         break;
  4345|                     case 350:
  4346|                         $function = 'ISPMT';
  4347|                         $args = 4;
  4348|                         break;
  4349|                     case 351:
  4350|                         $function = 'DATEDIF';
  4351|                         $args = 3;
  4352|                         break;
  4353|                     case 352:
  4354|                         $function = 'DATESTRING';
  4355|                         $args = 1;
  4356|                         break;
  4357|                     case 353:
  4358|                         $function = 'NUMBERSTRING';
  4359|                         $args = 2;
  4360|                         break;
  4361|                     case 360:
  4362|                         $function = 'PHONETIC';
  4363|                         $args = 1;
  4364|                         break;
  4365|                     case 368:
  4366|                         $function = 'BAHTTEXT';
  4367|                         $args = 1;
  4368|                         break;
  4369|                     default:
  4370|                         throw new Exception('Unrecognized function in formula');
  4371|                 }
  4372|                 $data = ['function' => $function, 'args' => $args];
  4373|                 break;
  4374|             case 0x22:    //    function with variable number of arguments
  4375|             case 0x42:
  4376|             case 0x62:
  4377|                 $name = 'tFuncV';
  4378|                 $size = 4;
  4379|                 $args = ord($formulaData[1]);
  4380|                 $index = self::getUInt2d($formulaData, 2);
  4381|                 $function = match ($index) {
  4382|                     0 => 'COUNT',
  4383|                     1 => 'IF',
  4384|                     4 => 'SUM',
  4385|                     5 => 'AVERAGE',
  4386|                     6 => 'MIN',
  4387|                     7 => 'MAX',
  4388|                     8 => 'ROW',
  4389|                     9 => 'COLUMN',
  4390|                     11 => 'NPV',
  4391|                     12 => 'STDEV',
  4392|                     13 => 'DOLLAR',
  4393|                     14 => 'FIXED',
  4394|                     28 => 'LOOKUP',
  4395|                     29 => 'INDEX',
  4396|                     36 => 'AND',
  4397|                     37 => 'OR',
  4398|                     46 => 'VAR',
  4399|                     49 => 'LINEST',
  4400|                     50 => 'TREND',
  4401|                     51 => 'LOGEST',
  4402|                     52 => 'GROWTH',
  4403|                     56 => 'PV',
  4404|                     57 => 'FV',
  4405|                     58 => 'NPER',
  4406|                     59 => 'PMT',
  4407|                     60 => 'RATE',
  4408|                     62 => 'IRR',
  4409|                     64 => 'MATCH',
  4410|                     70 => 'WEEKDAY',
  4411|                     78 => 'OFFSET',
  4412|                     82 => 'SEARCH',
  4413|                     100 => 'CHOOSE',
  4414|                     101 => 'HLOOKUP',
  4415|                     102 => 'VLOOKUP',
  4416|                     109 => 'LOG',
  4417|                     115 => 'LEFT',
  4418|                     116 => 'RIGHT',
  4419|                     120 => 'SUBSTITUTE',
  4420|                     124 => 'FIND',
  4421|                     125 => 'CELL',
  4422|                     144 => 'DDB',
  4423|                     148 => 'INDIRECT',
  4424|                     167 => 'IPMT',
  4425|                     168 => 'PPMT',
  4426|                     169 => 'COUNTA',
  4427|                     183 => 'PRODUCT',
  4428|                     193 => 'STDEVP',
  4429|                     194 => 'VARP',
  4430|                     197 => 'TRUNC',
  4431|                     204 => 'USDOLLAR',
  4432|                     205 => 'FINDB',
  4433|                     206 => 'SEARCHB',
  4434|                     208 => 'LEFTB',
  4435|                     209 => 'RIGHTB',
  4436|                     216 => 'RANK',
  4437|                     219 => 'ADDRESS',
  4438|                     220 => 'DAYS360',
  4439|                     222 => 'VDB',
  4440|                     227 => 'MEDIAN',
  4441|                     228 => 'SUMPRODUCT',
  4442|                     247 => 'DB',
  4443|                     255 => '',
  4444|                     269 => 'AVEDEV',
  4445|                     270 => 'BETADIST',
  4446|                     272 => 'BETAINV',
  4447|                     317 => 'PROB',
  4448|                     318 => 'DEVSQ',
  4449|                     319 => 'GEOMEAN',
  4450|                     320 => 'HARMEAN',
  4451|                     321 => 'SUMSQ',
  4452|                     322 => 'KURT',
  4453|                     323 => 'SKEW',
  4454|                     324 => 'ZTEST',
  4455|                     329 => 'PERCENTRANK',
  4456|                     330 => 'MODE',
  4457|                     336 => 'CONCATENATE',
  4458|                     344 => 'SUBTOTAL',
  4459|                     345 => 'SUMIF',
  4460|                     354 => 'ROMAN',
  4461|                     358 => 'GETPIVOTDATA',
  4462|                     359 => 'HYPERLINK',
  4463|                     361 => 'AVERAGEA',
  4464|                     362 => 'MAXA',
  4465|                     363 => 'MINA',
  4466|                     364 => 'STDEVPA',
  4467|                     365 => 'VARPA',
  4468|                     366 => 'STDEVA',
  4469|                     367 => 'VARA',
  4470|                     default => throw new Exception('Unrecognized function in formula'),
  4471|                 };
  4472|                 $data = ['function' => $function, 'args' => $args];
  4473|                 break;
  4474|             case 0x23:    //    index to defined name
  4475|             case 0x43:
  4476|             case 0x63:
  4477|                 $name = 'tName';
  4478|                 $size = 5;
  4479|                 $definedNameIndex = self::getUInt2d($formulaData, 1) - 1;
  4480|                 $data = $this->definedname[$definedNameIndex]['name'] ?? '';
  4481|                 break;
  4482|             case 0x24:    //    single cell reference e.g. A5
  4483|             case 0x44:
  4484|             case 0x64:
  4485|                 $name = 'tRef';
  4486|                 $size = 5;
  4487|                 $data = $this->readBIFF8CellAddress(substr($formulaData, 1, 4));
  4488|                 break;
  4489|             case 0x25:    //    cell range reference to cells in the same sheet (2d)
  4490|             case 0x45:
  4491|             case 0x65:
  4492|                 $name = 'tArea';
  4493|                 $size = 9;
  4494|                 $data = $this->readBIFF8CellRangeAddress(substr($formulaData, 1, 8));
  4495|                 break;
  4496|             case 0x26:    //    Constant reference sub-expression
  4497|             case 0x46:
  4498|             case 0x66:
  4499|                 $name = 'tMemArea';
  4500|                 $subSize = self::getUInt2d($formulaData, 5);
  4501|                 $size = 7 + $subSize;
  4502|                 $data = $this->getFormulaFromData(substr($formulaData, 7, $subSize));
  4503|                 break;
  4504|             case 0x27:    //    Deleted constant reference sub-expression
  4505|             case 0x47:
  4506|             case 0x67:
  4507|                 $name = 'tMemErr';
  4508|                 $subSize = self::getUInt2d($formulaData, 5);
  4509|                 $size = 7 + $subSize;
  4510|                 $data = $this->getFormulaFromData(substr($formulaData, 7, $subSize));
  4511|                 break;
  4512|             case 0x29:    //    Variable reference sub-expression
  4513|             case 0x49:
  4514|             case 0x69:
  4515|                 $name = 'tMemFunc';
  4516|                 $subSize = self::getUInt2d($formulaData, 1);
  4517|                 $size = 3 + $subSize;
  4518|                 $data = $this->getFormulaFromData(substr($formulaData, 3, $subSize));
  4519|                 break;
  4520|             case 0x2C: // Relative 2d cell reference reference, used in shared formulas and some other places
  4521|             case 0x4C:
  4522|             case 0x6C:
  4523|                 $name = 'tRefN';
  4524|                 $size = 5;
  4525|                 $data = $this->readBIFF8CellAddressB(substr($formulaData, 1, 4), $baseCell);
  4526|                 break;
  4527|             case 0x2D:    //    Relative 2d range reference
  4528|             case 0x4D:
  4529|             case 0x6D:
  4530|                 $name = 'tAreaN';
  4531|                 $size = 9;
  4532|                 $data = $this->readBIFF8CellRangeAddressB(substr($formulaData, 1, 8), $baseCell);
  4533|                 break;
  4534|             case 0x39:    //    External name
  4535|             case 0x59:
  4536|             case 0x79:
  4537|                 $name = 'tNameX';
  4538|                 $size = 7;
  4539|                 $index = self::getUInt2d($formulaData, 3);
  4540|                 $data = $this->externalNames[$index - 1]['name'] ?? '';
  4541|                 break;
  4542|             case 0x3A:    //    3d reference to cell
  4543|             case 0x5A:
  4544|             case 0x7A:
  4545|                 $name = 'tRef3d';
  4546|                 $size = 7;
  4547|                 try {
  4548|                     $sheetRange = $this->readSheetRangeByRefIndex(self::getUInt2d($formulaData, 1));
  4549|                     $cellAddress = $this->readBIFF8CellAddress(substr($formulaData, 3, 4));
  4550|                     $data = "$sheetRange!$cellAddress";
  4551|                 } catch (PhpSpreadsheetException) {
  4552|                     $data = '#REF!';
  4553|                 }
  4554|                 break;
  4555|             case 0x3B:    //    3d reference to cell range
  4556|             case 0x5B:
  4557|             case 0x7B:
  4558|                 $name = 'tArea3d';
  4559|                 $size = 11;
  4560|                 try {
  4561|                     $sheetRange = $this->readSheetRangeByRefIndex(self::getUInt2d($formulaData, 1));
  4562|                     $cellRangeAddress = $this->readBIFF8CellRangeAddress(substr($formulaData, 3, 8));
  4563|                     $data = "$sheetRange!$cellRangeAddress";
  4564|                 } catch (PhpSpreadsheetException) {
  4565|                     $data = '#REF!';
  4566|                 }
  4567|                 break;
  4568|             default:
  4569|                 throw new Exception('Unrecognized token ' . sprintf('%02X', $id) . ' in formula');
  4570|         }
  4571|         return [
  4572|             'id' => $id,
  4573|             'name' => $name,
  4574|             'size' => $size,
  4575|             'data' => $data,
  4576|         ];
  4577|     }
  4578|     /**
  4579|      * Reads a cell address in BIFF8 e.g. 'A2' or '$A$2'
  4580|      * section 3.3.4.
  4581|      */
  4582|     private function readBIFF8CellAddress(string $cellAddressStructure): string
  4583|     {
  4584|         $row = self::getUInt2d($cellAddressStructure, 0) + 1;
  4585|         $column = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($cellAddressStructure, 2)) + 1);
  4586|         if (!(0x4000 & self::getUInt2d($cellAddressStructure, 2))) {
  4587|             $column = '$' . $column;
  4588|         }
  4589|         if (!(0x8000 & self::getUInt2d($cellAddressStructure, 2))) {
  4590|             $row = '$' . $row;
  4591|         }
  4592|         return $column . $row;
  4593|     }
  4594|     /**
  4595|      * Reads a cell address in BIFF8 for shared formulas. Uses positive and negative values for row and column
  4596|      * to indicate offsets from a base cell
  4597|      * section 3.3.4.
  4598|      *
  4599|      * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
  4600|      */
  4601|     private function readBIFF8CellAddressB(string $cellAddressStructure, string $baseCell = 'A1'): string
  4602|     {
  4603|         [$baseCol, $baseRow] = Coordinate::coordinateFromString($baseCell);
  4604|         $baseCol = Coordinate::columnIndexFromString($baseCol) - 1;
  4605|         $baseRow = (int) $baseRow;
  4606|         $rowIndex = self::getUInt2d($cellAddressStructure, 0);
  4607|         $row = self::getUInt2d($cellAddressStructure, 0) + 1;
  4608|         if (!(0x4000 & self::getUInt2d($cellAddressStructure, 2))) {
  4609|             $colIndex = 0x00FF & self::getUInt2d($cellAddressStructure, 2);
  4610|             $column = Coordinate::stringFromColumnIndex($colIndex + 1);
  4611|             $column = '$' . $column;
  4612|         } else {
  4613|             $relativeColIndex = 0x00FF & self::getInt2d($cellAddressStructure, 2);
  4614|             $colIndex = $baseCol + $relativeColIndex;
  4615|             $colIndex = ($colIndex < 256) ? $colIndex : $colIndex - 256;
  4616|             $colIndex = ($colIndex >= 0) ? $colIndex : $colIndex + 256;
  4617|             $column = Coordinate::stringFromColumnIndex($colIndex + 1);
  4618|         }
  4619|         if (!(0x8000 & self::getUInt2d($cellAddressStructure, 2))) {
  4620|             $row = '$' . $row;
  4621|         } else {
  4622|             $rowIndex = ($rowIndex <= 32767) ? $rowIndex : $rowIndex - 65536;
  4623|             $row = $baseRow + $rowIndex;
  4624|         }
  4625|         return $column . $row;
  4626|     }
  4627|     /**
  4628|      * Reads a cell range address in BIFF5 e.g. 'A2:B6' or 'A1'
  4629|      * always fixed range
  4630|      * section 2.5.14.
  4631|      */
  4632|     private function readBIFF5CellRangeAddressFixed(string $subData): string
  4633|     {
  4634|         $fr = self::getUInt2d($subData, 0) + 1;
  4635|         $lr = self::getUInt2d($subData, 2) + 1;
  4636|         $fc = ord($subData[4]);
  4637|         $lc = ord($subData[5]);
  4638|         if ($fr > $lr || $fc > $lc) {
  4639|             throw new Exception('Not a cell range address');
  4640|         }
  4641|         $fc = Coordinate::stringFromColumnIndex($fc + 1);
  4642|         $lc = Coordinate::stringFromColumnIndex($lc + 1);
  4643|         if ($fr == $lr && $fc == $lc) {
  4644|             return "$fc$fr";
  4645|         }
  4646|         return "$fc$fr:$lc$lr";
  4647|     }
  4648|     /**
  4649|      * Reads a cell range address in BIFF8 e.g. 'A2:B6' or 'A1'
  4650|      * always fixed range
  4651|      * section 2.5.14.
  4652|      */
  4653|     private function readBIFF8CellRangeAddressFixed(string $subData): string
  4654|     {
  4655|         $fr = self::getUInt2d($subData, 0) + 1;
  4656|         $lr = self::getUInt2d($subData, 2) + 1;
  4657|         $fc = self::getUInt2d($subData, 4);
  4658|         $lc = self::getUInt2d($subData, 6);
  4659|         if ($fr > $lr || $fc > $lc) {
  4660|             throw new Exception('Not a cell range address');
  4661|         }
  4662|         $fc = Coordinate::stringFromColumnIndex($fc + 1);
  4663|         $lc = Coordinate::stringFromColumnIndex($lc + 1);
  4664|         if ($fr == $lr && $fc == $lc) {
  4665|             return "$fc$fr";
  4666|         }
  4667|         return "$fc$fr:$lc$lr";
  4668|     }
  4669|     /**
  4670|      * Reads a cell range address in BIFF8 e.g. 'A2:B6' or '$A$2:$B$6'
  4671|      * there are flags indicating whether column/row index is relative
  4672|      * section 3.3.4.
  4673|      */
  4674|     private function readBIFF8CellRangeAddress(string $subData): string
  4675|     {
  4676|         $fr = self::getUInt2d($subData, 0) + 1;
  4677|         $lr = self::getUInt2d($subData, 2) + 1;
  4678|         $fc = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($subData, 4)) + 1);
  4679|         if (!(0x4000 & self::getUInt2d($subData, 4))) {
  4680|             $fc = '$' . $fc;
  4681|         }
  4682|         if (!(0x8000 & self::getUInt2d($subData, 4))) {
  4683|             $fr = '$' . $fr;
  4684|         }
  4685|         $lc = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($subData, 6)) + 1);
  4686|         if (!(0x4000 & self::getUInt2d($subData, 6))) {
  4687|             $lc = '$' . $lc;
  4688|         }
  4689|         if (!(0x8000 & self::getUInt2d($subData, 6))) {
  4690|             $lr = '$' . $lr;
  4691|         }
  4692|         return "$fc$fr:$lc$lr";
  4693|     }
  4694|     /**
  4695|      * Reads a cell range address in BIFF8 for shared formulas. Uses positive and negative values for row and column
  4696|      * to indicate offsets from a base cell
  4697|      * section 3.3.4.
  4698|      *
  4699|      * @param string $baseCell Base cell
  4700|      *
  4701|      * @return string Cell range address
  4702|      */
  4703|     private function readBIFF8CellRangeAddressB(string $subData, string $baseCell = 'A1'): string
  4704|     {
  4705|         [$baseCol, $baseRow] = Coordinate::indexesFromString($baseCell);
  4706|         $baseCol = $baseCol - 1;
  4707|         $frIndex = self::getUInt2d($subData, 0); // adjust below
  4708|         $lrIndex = self::getUInt2d($subData, 2); // adjust below
  4709|         if (!(0x4000 & self::getUInt2d($subData, 4))) {
  4710|             $fcIndex = 0x00FF & self::getUInt2d($subData, 4);
  4711|             $fc = Coordinate::stringFromColumnIndex($fcIndex + 1);
  4712|             $fc = '$' . $fc;
  4713|         } else {
  4714|             $relativeFcIndex = 0x00FF & self::getInt2d($subData, 4);
  4715|             $fcIndex = $baseCol + $relativeFcIndex;
  4716|             $fcIndex = ($fcIndex < 256) ? $fcIndex : $fcIndex - 256;
  4717|             $fcIndex = ($fcIndex >= 0) ? $fcIndex : $fcIndex + 256;
  4718|             $fc = Coordinate::stringFromColumnIndex($fcIndex + 1);
  4719|         }
  4720|         if (!(0x8000 & self::getUInt2d($subData, 4))) {
  4721|             $fr = $frIndex + 1;
  4722|             $fr = '$' . $fr;
  4723|         } else {
  4724|             $frIndex = ($frIndex <= 32767) ? $frIndex : $frIndex - 65536;
  4725|             $fr = $baseRow + $frIndex;
  4726|         }
  4727|         if (!(0x4000 & self::getUInt2d($subData, 6))) {
  4728|             $lcIndex = 0x00FF & self::getUInt2d($subData, 6);
  4729|             $lc = Coordinate::stringFromColumnIndex($lcIndex + 1);
  4730|             $lc = '$' . $lc;
  4731|         } else {
  4732|             $relativeLcIndex = 0x00FF & self::getInt2d($subData, 4);
  4733|             $lcIndex = $baseCol + $relativeLcIndex;
  4734|             $lcIndex = ($lcIndex < 256) ? $lcIndex : $lcIndex - 256;
  4735|             $lcIndex = ($lcIndex >= 0) ? $lcIndex : $lcIndex + 256;
  4736|             $lc = Coordinate::stringFromColumnIndex($lcIndex + 1);
  4737|         }
  4738|         if (!(0x8000 & self::getUInt2d($subData, 6))) {
  4739|             $lr = $lrIndex + 1;
  4740|             $lr = '$' . $lr;
  4741|         } else {
  4742|             $lrIndex = ($lrIndex <= 32767) ? $lrIndex : $lrIndex - 65536;
  4743|             $lr = $baseRow + $lrIndex;
  4744|         }
  4745|         return "$fc$fr:$lc$lr";
  4746|     }
  4747|     /**
  4748|      * Read BIFF8 cell range address list
  4749|      * section 2.5.15.
  4750|      */
  4751|     private function readBIFF8CellRangeAddressList(string $subData): array
  4752|     {
  4753|         $cellRangeAddresses = [];
  4754|         $nm = self::getUInt2d($subData, 0);
  4755|         $offset = 2;
  4756|         for ($i = 0; $i < $nm; ++$i) {
  4757|             $cellRangeAddresses[] = $this->readBIFF8CellRangeAddressFixed(substr($subData, $offset, 8));
  4758|             $offset += 8;
  4759|         }
  4760|         return [
  4761|             'size' => 2 + 8 * $nm,
  4762|             'cellRangeAddresses' => $cellRangeAddresses,
  4763|         ];
  4764|     }
  4765|     /**
  4766|      * Read BIFF5 cell range address list
  4767|      * section 2.5.15.
  4768|      */
  4769|     private function readBIFF5CellRangeAddressList(string $subData): array
  4770|     {
  4771|         $cellRangeAddresses = [];
  4772|         $nm = self::getUInt2d($subData, 0);
  4773|         $offset = 2;
  4774|         for ($i = 0; $i < $nm; ++$i) {
  4775|             $cellRangeAddresses[] = $this->readBIFF5CellRangeAddressFixed(substr($subData, $offset, 6));
  4776|             $offset += 6;
  4777|         }
  4778|         return [
  4779|             'size' => 2 + 6 * $nm,
  4780|             'cellRangeAddresses' => $cellRangeAddresses,
  4781|         ];
  4782|     }
  4783|     /**
  4784|      * Get a sheet range like Sheet1:Sheet3 from REF index
  4785|      * Note: If there is only one sheet in the range, one gets e.g Sheet1
  4786|      * It can also happen that the REF structure uses the -1 (FFFF) code to indicate deleted sheets,
  4787|      * in which case an Exception is thrown.
  4788|      */
  4789|     private function readSheetRangeByRefIndex(int $index): string|false
  4790|     {
  4791|         if (isset($this->ref[$index])) {
  4792|             $type = $this->externalBooks[$this->ref[$index]['externalBookIndex']]['type'];
  4793|             switch ($type) {
  4794|                 case 'internal':
  4795|                     if ($this->ref[$index]['firstSheetIndex'] == 0xFFFF || $this->ref[$index]['lastSheetIndex'] == 0xFFFF) {
  4796|                         throw new Exception('Deleted sheet reference');
  4797|                     }
  4798|                     $firstSheetName = $this->sheets[$this->ref[$index]['firstSheetIndex']]['name'];
  4799|                     $lastSheetName = $this->sheets[$this->ref[$index]['lastSheetIndex']]['name'];
  4800|                     if ($firstSheetName == $lastSheetName) {
  4801|                         $sheetRange = $firstSheetName;
  4802|                     } else {
  4803|                         $sheetRange = "$firstSheetName:$lastSheetName";
  4804|                     }
  4805|                     $sheetRange = str_replace("'", "''", $sheetRange);
  4806|                     if (preg_match("/[ !\"@#£$%&{()}<>=+'|^,;-]/u", $sheetRange)) {
  4807|                         $sheetRange = "'$sheetRange'";
  4808|                     }
  4809|                     return $sheetRange;
  4810|                 default:
  4811|                     throw new Exception('Xls reader only supports internal sheets in formulas');
  4812|             }
  4813|         }
  4814|         return false;
  4815|     }
  4816|     /**
  4817|      * read BIFF8 constant value array from array data
  4818|      * returns e.g. ['value' => '{1,2;3,4}', 'size' => 40]
  4819|      * section 2.5.8.
  4820|      */
  4821|     private static function readBIFF8ConstantArray(string $arrayData): array
  4822|     {
  4823|         $nc = ord($arrayData[0]);
  4824|         $nr = self::getUInt2d($arrayData, 1);
  4825|         $size = 3; // initialize
  4826|         $arrayData = substr($arrayData, 3);
  4827|         $matrixChunks = [];
  4828|         for ($r = 1; $r <= $nr + 1; ++$r) {
  4829|             $items = [];
  4830|             for ($c = 1; $c <= $nc + 1; ++$c) {
  4831|                 $constant = self::readBIFF8Constant($arrayData);
  4832|                 $items[] = $constant['value'];
  4833|                 $arrayData = substr($arrayData, $constant['size']);
  4834|                 $size += $constant['size'];
  4835|             }
  4836|             $matrixChunks[] = implode(',', $items); // looks like e.g. '1,"hello"'
  4837|         }
  4838|         $matrix = '{' . implode(';', $matrixChunks) . '}';
  4839|         return [
  4840|             'value' => $matrix,
  4841|             'size' => $size,
  4842|         ];
  4843|     }
  4844|     /**
  4845|      * read BIFF8 constant value which may be 'Empty Value', 'Number', 'String Value', 'Boolean Value', 'Error Value'
  4846|      * section 2.5.7
  4847|      * returns e.g. ['value' => '5', 'size' => 9].
  4848|      */
  4849|     private static function readBIFF8Constant(string $valueData): array
  4850|     {
  4851|         $identifier = ord($valueData[0]);
  4852|         switch ($identifier) {
  4853|             case 0x00: // empty constant (what is this?)
  4854|                 $value = '';
  4855|                 $size = 9;
  4856|                 break;
  4857|             case 0x01: // number
  4858|                 $value = self::extractNumber(substr($valueData, 1, 8));
  4859|                 $size = 9;
  4860|                 break;
  4861|             case 0x02: // string value
  4862|                 $string = self::readUnicodeStringLong(substr($valueData, 1));
  4863|                 $value = '"' . $string['value'] . '"';
  4864|                 $size = 1 + $string['size'];
  4865|                 break;
  4866|             case 0x04: // boolean
  4867|                 if (ord($valueData[1])) {
  4868|                     $value = 'TRUE';
  4869|                 } else {
  4870|                     $value = 'FALSE';
  4871|                 }
  4872|                 $size = 9;
  4873|                 break;
  4874|             case 0x10: // error code
  4875|                 $value = Xls\ErrorCode::lookup(ord($valueData[1]));
  4876|                 $size = 9;
  4877|                 break;
  4878|             default:
  4879|                 throw new PhpSpreadsheetException('Unsupported BIFF8 constant');
  4880|         }
  4881|         return [
  4882|             'value' => $value,
  4883|             'size' => $size,
  4884|         ];
  4885|     }
  4886|     /**
  4887|      * Extract RGB color
  4888|      * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.4.
  4889|      *
  4890|      * @param string $rgb Encoded RGB value (4 bytes)
  4891|      */
  4892|     private static function readRGB(string $rgb): array
  4893|     {
  4894|         $r = ord($rgb[0]);
  4895|         $g = ord($rgb[1]);
  4896|         $b = ord($rgb[2]);
  4897|         $rgb = sprintf('%02X%02X%02X', $r, $g, $b);
  4898|         return ['rgb' => $rgb];
  4899|     }
  4900|     /**
  4901|      * Read byte string (8-bit string length)
  4902|      * OpenOffice documentation: 2.5.2.
  4903|      */
  4904|     private function readByteStringShort(string $subData): array
  4905|     {
  4906|         $ln = ord($subData[0]);
  4907|         $value = $this->decodeCodepage(substr($subData, 1, $ln));
  4908|         return [
  4909|             'value' => $value,
  4910|             'size' => 1 + $ln, // size in bytes of data structure
  4911|         ];
  4912|     }
  4913|     /**
  4914|      * Read byte string (16-bit string length)
  4915|      * OpenOffice documentation: 2.5.2.
  4916|      */
  4917|     private function readByteStringLong(string $subData): array
  4918|     {
  4919|         $ln = self::getUInt2d($subData, 0);
  4920|         $value = $this->decodeCodepage(substr($subData, 2));
  4921|         return [
  4922|             'value' => $value,
  4923|             'size' => 2 + $ln, // size in bytes of data structure
  4924|         ];
  4925|     }
  4926|     /**
  4927|      * Extracts an Excel Unicode short string (8-bit string length)
  4928|      * OpenOffice documentation: 2.5.3
  4929|      * function will automatically find out where the Unicode string ends.
  4930|      */
  4931|     private static function readUnicodeStringShort(string $subData): array
  4932|     {
  4933|         $characterCount = ord($subData[0]);
  4934|         $string = self::readUnicodeString(substr($subData, 1), $characterCount);
  4935|         ++$string['size'];
  4936|         return $string;
  4937|     }
  4938|     /**
  4939|      * Extracts an Excel Unicode long string (16-bit string length)
  4940|      * OpenOffice documentation: 2.5.3
  4941|      * this function is under construction, needs to support rich text, and Asian phonetic settings.
  4942|      */
  4943|     private static function readUnicodeStringLong(string $subData): array
  4944|     {
  4945|         $characterCount = self::getUInt2d($subData, 0);
  4946|         $string = self::readUnicodeString(substr($subData, 2), $characterCount);
  4947|         $string['size'] += 2;
  4948|         return $string;
  4949|     }
  4950|     /**
  4951|      * Read Unicode string with no string length field, but with known character count
  4952|      * this function is under construction, needs to support rich text, and Asian phonetic settings
  4953|      * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.3.
  4954|      */
  4955|     private static function readUnicodeString(string $subData, int $characterCount): array
  4956|     {
  4957|         $isCompressed = !((0x01 & ord($subData[0])) >> 0);
  4958|         $value = self::encodeUTF16(substr($subData, 1, $isCompressed ? $characterCount : 2 * $characterCount), $isCompressed);
  4959|         return [
  4960|             'value' => $value,
  4961|             'size' => $isCompressed ? 1 + $characterCount : 1 + 2 * $characterCount, // the size in bytes including the option flags
  4962|         ];
  4963|     }
  4964|     /**
  4965|      * Convert UTF-8 string to string surounded by double quotes. Used for explicit string tokens in formulas.
  4966|      * Example:  hello"world  -->  "hello""world".
  4967|      *
  4968|      * @param string $value UTF-8 encoded string
  4969|      */
  4970|     private static function UTF8toExcelDoubleQuoted(string $value): string
  4971|     {
  4972|         return '"' . str_replace('"', '""', $value) . '"';
  4973|     }
  4974|     /**
  4975|      * Reads first 8 bytes of a string and return IEEE 754 float.
  4976|      *
  4977|      * @param string $data Binary string that is at least 8 bytes long
  4978|      */
  4979|     private static function extractNumber(string $data): int|float
  4980|     {
  4981|         $rknumhigh = self::getInt4d($data, 4);
  4982|         $rknumlow = self::getInt4d($data, 0);
  4983|         $sign = ($rknumhigh & self::HIGH_ORDER_BIT) >> 31;
  4984|         $exp = (($rknumhigh & 0x7FF00000) >> 20) - 1023;
  4985|         $mantissa = (0x100000 | ($rknumhigh & 0x000FFFFF));
  4986|         $mantissalow1 = ($rknumlow & self::HIGH_ORDER_BIT) >> 31;
  4987|         $mantissalow2 = ($rknumlow & 0x7FFFFFFF);
  4988|         $value = $mantissa / 2 ** (20 - $exp);
  4989|         if ($mantissalow1 != 0) {
  4990|             $value += 1 / 2 ** (21 - $exp);
  4991|         }
  4992|         if ($mantissalow2 != 0) {
  4993|             $value += $mantissalow2 / 2 ** (52 - $exp);
  4994|         }
  4995|         if ($sign) {
  4996|             $value *= -1;
  4997|         }
  4998|         return $value;
  4999|     }
  5000|     private static function getIEEE754(int $rknum): float|int
  5001|     {
  5002|         if (($rknum & 0x02) != 0) {
  5003|             $value = $rknum >> 2;
  5004|         } else {
  5005|             $sign = ($rknum & self::HIGH_ORDER_BIT) >> 31;
  5006|             $exp = ($rknum & 0x7FF00000) >> 20;
  5007|             $mantissa = (0x100000 | ($rknum & 0x000FFFFC));
  5008|             $value = $mantissa / 2 ** (20 - ($exp - 1023));
  5009|             if ($sign) {
  5010|                 $value = -1 * $value;
  5011|             }
  5012|         }
  5013|         if (($rknum & 0x01) != 0) {
  5014|             $value /= 100;
  5015|         }
  5016|         return $value;
  5017|     }
  5018|     /**
  5019|      * Get UTF-8 string from (compressed or uncompressed) UTF-16 string.
  5020|      */
  5021|     private static function encodeUTF16(string $string, bool $compressed = false): string
  5022|     {
  5023|         if ($compressed) {
  5024|             $string = self::uncompressByteString($string);
  5025|         }
  5026|         return StringHelper::convertEncoding($string, 'UTF-8', 'UTF-16LE');
  5027|     }
  5028|     /**
  5029|      * Convert UTF-16 string in compressed notation to uncompressed form. Only used for BIFF8.
  5030|      */
  5031|     private static function uncompressByteString(string $string): string
  5032|     {
  5033|         $uncompressedString = '';
  5034|         $strLen = strlen($string);
  5035|         for ($i = 0; $i < $strLen; ++$i) {
  5036|             $uncompressedString .= $string[$i] . "\0";
  5037|         }
  5038|         return $uncompressedString;
  5039|     }
  5040|     /**
  5041|      * Convert string to UTF-8. Only used for BIFF5.
  5042|      */
  5043|     private function decodeCodepage(string $string): string
  5044|     {
  5045|         return StringHelper::convertEncoding($string, 'UTF-8', $this->codepage);
  5046|     }
  5047|     /**
  5048|      * Read 16-bit unsigned integer.
  5049|      */
  5050|     public static function getUInt2d(string $data, int $pos): int
  5051|     {
  5052|         return ord($data[$pos]) | (ord($data[$pos + 1]) << 8);
  5053|     }
  5054|     /**
  5055|      * Read 16-bit signed integer.
  5056|      */
  5057|     public static function getInt2d(string $data, int $pos): int
  5058|     {
  5059|         return unpack('s', $data[$pos] . $data[$pos + 1])[1]; // @phpstan-ignore-line
  5060|     }
  5061|     /**
  5062|      * Read 32-bit signed integer.
  5063|      */
  5064|     public static function getInt4d(string $data, int $pos): int
  5065|     {
  5066|         $_or_24 = ord($data[$pos + 3]);
  5067|         if ($_or_24 >= 128) {
  5068|             $_ord_24 = -abs((256 - $_or_24) << 24);
  5069|         } else {
  5070|             $_ord_24 = ($_or_24 & 127) << 24;
  5071|         }
  5072|         return ord($data[$pos]) | (ord($data[$pos + 1]) << 8) | (ord($data[$pos + 2]) << 16) | $_ord_24;
  5073|     }
  5074|     private function parseRichText(string $is): RichText
  5075|     {
  5076|         $value = new RichText();
  5077|         $value->createText($is);
  5078|         return $value;
  5079|     }
  5080|     /**
  5081|      * Phpstan 1.4.4 complains that this property is never read.
  5082|      * So, we might be able to get rid of it altogether.
  5083|      * For now, however, this function makes it readable,
  5084|      * which satisfies Phpstan.
  5085|      *
  5086|      * @codeCoverageIgnore
  5087|      */
  5088|     public function getMapCellStyleXfIndex(): array
  5089|     {
  5090|         return $this->mapCellStyleXfIndex;
  5091|     }
  5092|     /**
  5093|      * Parse conditional formatting blocks.
  5094|      *
  5095|      * @see https://www.openoffice.org/sc/excelfileformat.pdf Search for CFHEADER followed by CFRULE
  5096|      */
  5097|     private function readCFHeader(): array
  5098|     {
  5099|         $length = self::getUInt2d($this->data, $this->pos + 2);
  5100|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  5101|         $this->pos += 4 + $length;
  5102|         if ($this->readDataOnly) {
  5103|             return [];
  5104|         }
  5105|         $cellRangeAddressList = ($this->version == self::XLS_BIFF8)
  5106|             ? $this->readBIFF8CellRangeAddressList(substr($recordData, 12))
  5107|             : $this->readBIFF5CellRangeAddressList(substr($recordData, 12));
  5108|         $cellRangeAddresses = $cellRangeAddressList['cellRangeAddresses'];
  5109|         return $cellRangeAddresses;
  5110|     }
  5111|     private function readCFRule(array $cellRangeAddresses): void
  5112|     {
  5113|         $length = self::getUInt2d($this->data, $this->pos + 2);
  5114|         $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
  5115|         $this->pos += 4 + $length;
  5116|         if ($this->readDataOnly) {
  5117|             return;
  5118|         }
  5119|         $cfRule = self::getUInt2d($recordData, 0);
  5120|         $type = (0x00FF & $cfRule) >> 0;
  5121|         $type = ConditionalFormatting::type($type);
  5122|         $operator = (0xFF00 & $cfRule) >> 8;
  5123|         $operator = ConditionalFormatting::operator($operator);
  5124|         if ($type === null || $operator === null) {
  5125|             return;
  5126|         }
  5127|         $size1 = self::getUInt2d($recordData, 2);
  5128|         $size2 = self::getUInt2d($recordData, 4);
  5129|         $options = self::getInt4d($recordData, 6);
  5130|         $style = new Style(false, true); // non-supervisor, conditional
  5131|         $noFormatSet = true;
  5132|         $hasFontRecord = (bool) ((0x04000000 & $options) >> 26);
  5133|         $hasAlignmentRecord = (bool) ((0x08000000 & $options) >> 27);
  5134|         $hasBorderRecord = (bool) ((0x10000000 & $options) >> 28);
  5135|         $hasFillRecord = (bool) ((0x20000000 & $options) >> 29);
  5136|         $hasProtectionRecord = (bool) ((0x40000000 & $options) >> 30);
  5137|         $hasBorderLeft = !(bool) (0x00000400 & $options);
  5138|         $hasBorderRight = !(bool) (0x00000800 & $options);
  5139|         $hasBorderTop = !(bool) (0x00001000 & $options);
  5140|         $hasBorderBottom = !(bool) (0x00002000 & $options);
  5141|         $offset = 12;
  5142|         if ($hasFontRecord === true) {
  5143|             $fontStyle = substr($recordData, $offset, 118);
  5144|             $this->getCFFontStyle($fontStyle, $style);
  5145|             $offset += 118;
  5146|             $noFormatSet = false;
  5147|         }
  5148|         if ($hasAlignmentRecord === true) {
  5149|             $offset += 8;
  5150|         }
  5151|         if ($hasBorderRecord === true) {
  5152|             $borderStyle = substr($recordData, $offset, 8);
  5153|             $this->getCFBorderStyle($borderStyle, $style, $hasBorderLeft, $hasBorderRight, $hasBorderTop, $hasBorderBottom);
  5154|             $offset += 8;
  5155|             $noFormatSet = false;
  5156|         }
  5157|         if ($hasFillRecord === true) {
  5158|             $fillStyle = substr($recordData, $offset, 4);
  5159|             $this->getCFFillStyle($fillStyle, $style);
  5160|             $offset += 4;
  5161|             $noFormatSet = false;
  5162|         }
  5163|         if ($hasProtectionRecord === true) {
  5164|             $offset += 2;
  5165|         }
  5166|         $formula1 = $formula2 = null;
  5167|         if ($size1 > 0) {
  5168|             $formula1 = $this->readCFFormula($recordData, $offset, $size1);
  5169|             if ($formula1 === null) {
  5170|                 return;
  5171|             }
  5172|             $offset += $size1;
  5173|         }
  5174|         if ($size2 > 0) {
  5175|             $formula2 = $this->readCFFormula($recordData, $offset, $size2);
  5176|             if ($formula2 === null) {
  5177|                 return;
  5178|             }
  5179|             $offset += $size2;
  5180|         }
  5181|         $this->setCFRules($cellRangeAddresses, $type, $operator, $formula1, $formula2, $style, $noFormatSet);
  5182|     }
  5183|     /*private function getCFStyleOptions(int $options, Style $style): void
  5184|     {
  5185|     }*/
  5186|     private function getCFFontStyle(string $options, Style $style): void
  5187|     {
  5188|         $fontSize = self::getInt4d($options, 64);
  5189|         if ($fontSize !== -1) {
  5190|             $style->getFont()->setSize($fontSize / 20); // Convert twips to points
  5191|         }
  5192|         $options68 = self::getInt4d($options, 68);
  5193|         $options88 = self::getInt4d($options, 88);
  5194|         if (($options88 & 2) === 0) {
  5195|             $bold = self::getUInt2d($options, 72); // 400 = normal, 700 = bold
  5196|             if ($bold !== 0) {
  5197|                 $style->getFont()->setBold($bold >= 550);
  5198|             }
  5199|             if (($options68 & 2) !== 0) {
  5200|                 $style->getFont()->setItalic(true);
  5201|             }
  5202|         }
  5203|         if (($options88 & 0x80) === 0) {
  5204|             if (($options68 & 0x80) !== 0) {
  5205|                 $style->getFont()->setStrikethrough(true);
  5206|             }
  5207|         }
  5208|         $color = self::getInt4d($options, 80);
  5209|         if ($color !== -1) {
  5210|             $style->getFont()->getColor()->setRGB(Xls\Color::map($color, $this->palette, $this->version)['rgb']);
  5211|         }
  5212|     }
  5213|     /*private function getCFAlignmentStyle(string $options, Style $style): void
  5214|     {
  5215|     }*/
  5216|     private function getCFBorderStyle(string $options, Style $style, bool $hasBorderLeft, bool $hasBorderRight, bool $hasBorderTop, bool $hasBorderBottom): void
  5217|     {
  5218|         $valueArray = unpack('V', $options);
  5219|         $value = is_array($valueArray) ? $valueArray[1] : 0;
  5220|         $left = $value & 15;
  5221|         $right = ($value >> 4) & 15;
  5222|         $top = ($value >> 8) & 15;
  5223|         $bottom = ($value >> 12) & 15;
  5224|         $leftc = ($value >> 16) & 0x7F;
  5225|         $rightc = ($value >> 23) & 0x7F;
  5226|         $valueArray = unpack('V', substr($options, 4));
  5227|         $value = is_array($valueArray) ? $valueArray[1] : 0;
  5228|         $topc = $value & 0x7F;
  5229|         $bottomc = ($value & 0x3F80) >> 7;
  5230|         if ($hasBorderLeft) {
  5231|             $style->getBorders()->getLeft()
  5232|                 ->setBorderStyle(self::BORDER_STYLE_MAP[$left]);
  5233|             $style->getBorders()->getLeft()->getColor()
  5234|                 ->setRGB(Xls\Color::map($leftc, $this->palette, $this->version)['rgb']);
  5235|         }
  5236|         if ($hasBorderRight) {
  5237|             $style->getBorders()->getRight()
  5238|                 ->setBorderStyle(self::BORDER_STYLE_MAP[$right]);
  5239|             $style->getBorders()->getRight()->getColor()
  5240|                 ->setRGB(Xls\Color::map($rightc, $this->palette, $this->version)['rgb']);
  5241|         }
  5242|         if ($hasBorderTop) {
  5243|             $style->getBorders()->getTop()
  5244|                 ->setBorderStyle(self::BORDER_STYLE_MAP[$top]);
  5245|             $style->getBorders()->getTop()->getColor()
  5246|                 ->setRGB(Xls\Color::map($topc, $this->palette, $this->version)['rgb']);
  5247|         }
  5248|         if ($hasBorderBottom) {
  5249|             $style->getBorders()->getBottom()
  5250|                 ->setBorderStyle(self::BORDER_STYLE_MAP[$bottom]);
  5251|             $style->getBorders()->getBottom()->getColor()
  5252|                 ->setRGB(Xls\Color::map($bottomc, $this->palette, $this->version)['rgb']);
  5253|         }
  5254|     }
  5255|     private function getCFFillStyle(string $options, Style $style): void
  5256|     {
  5257|         $fillPattern = self::getUInt2d($options, 0);
  5258|         $fillPattern = (0xFC00 & $fillPattern) >> 10;
  5259|         $fillPattern = FillPattern::lookup($fillPattern);
  5260|         $fillPattern = $fillPattern === Fill::FILL_NONE ? Fill::FILL_SOLID : $fillPattern;
  5261|         if ($fillPattern !== Fill::FILL_NONE) {
  5262|             $style->getFill()->setFillType($fillPattern);
  5263|             $fillColors = self::getUInt2d($options, 2);
  5264|             $color1 = (0x007F & $fillColors) >> 0;
  5265|             $color2 = (0x3F80 & $fillColors) >> 7;
  5266|             if ($fillPattern === Fill::FILL_SOLID) {
  5267|                 $style->getFill()->getStartColor()->setRGB(Xls\Color::map($color2, $this->palette, $this->version)['rgb']);
  5268|             } else {
  5269|                 $style->getFill()->getStartColor()->setRGB(Xls\Color::map($color1, $this->palette, $this->version)['rgb']);
  5270|                 $style->getFill()->getEndColor()->setRGB(Xls\Color::map($color2, $this->palette, $this->version)['rgb']);
  5271|             }
  5272|         }
  5273|     }
  5274|     /*private function getCFProtectionStyle(string $options, Style $style): void
  5275|     {
  5276|     }*/
  5277|     private function readCFFormula(string $recordData, int $offset, int $size): float|int|string|null
  5278|     {
  5279|         try {
  5280|             $formula = substr($recordData, $offset, $size);
  5281|             $formula = pack('v', $size) . $formula; // prepend the length
  5282|             $formula = $this->getFormulaFromStructure($formula);
  5283|             if (is_numeric($formula)) {
  5284|                 return (str_contains($formula, '.')) ? (float) $formula : (int) $formula;
  5285|             }
  5286|             return $formula;
  5287|         } catch (PhpSpreadsheetException) {
  5288|             return null;
  5289|         }
  5290|     }
  5291|     private function setCFRules(array $cellRanges, string $type, string $operator, null|float|int|string $formula1, null|float|int|string $formula2, Style $style, bool $noFormatSet): void
  5292|     {
  5293|         foreach ($cellRanges as $cellRange) {
  5294|             $conditional = new Conditional();
  5295|             $conditional->setNoFormatSet($noFormatSet);
  5296|             $conditional->setConditionType($type);
  5297|             $conditional->setOperatorType($operator);
  5298|             $conditional->setStopIfTrue(true);
  5299|             if ($formula1 !== null) {
  5300|                 $conditional->addCondition($formula1);
  5301|             }
  5302|             if ($formula2 !== null) {
  5303|                 $conditional->addCondition($formula2);
  5304|             }
  5305|             $conditional->setStyle($style);
  5306|             $conditionalStyles = $this->phpSheet->getStyle($cellRange)->getConditionalStyles();
  5307|             $conditionalStyles[] = $conditional;
  5308|             $this->phpSheet->getStyle($cellRange)->setConditionalStyles($conditionalStyles);
  5309|         }
  5310|     }
  5311|     public function getVersion(): int
  5312|     {
  5313|         return $this->version;
  5314|     }
  5315| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Xlsx.php
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 717-764 ---
   717|                                         }
   718|                                         if ($this->readEmptyCells || ($value !== null && $value !== '')) {
   719|                                             if ($value instanceof RichText && $this->readDataOnly) {
   720|                                                 $value = $value->getPlainText();
   721|                                             }
   722|                                             $cell = $docSheet->getCell($r);
   723|                                             if ($cellDataType != '') {
   724|                                                 if ($cellDataType === DataType::TYPE_NUMERIC && ($value === '' || $value === null)) {
   725|                                                     $cellDataType = DataType::TYPE_NULL;
   726|                                                 }
   727|                                                 if ($cellDataType !== DataType::TYPE_NULL) {
   728|                                                     $cell->setValueExplicit($value, $cellDataType);
   729|                                                 }
   730|                                             } else {
   731|                                                 $cell->setValue($value);
   732|                                             }
   733|                                             if ($calculatedValue !== null) {
   734|                                                 $cell->setCalculatedValue($calculatedValue, $originalCellDataTypeNumeric);
   735|                                             }
   736|                                             if (!$this->readDataOnly) {
   737|                                                 $holdSelected = $docSheet->getSelectedCells();
   738|                                                 $cAttrS = (int) ($cAttr['s'] ?? 0);
   739|                                                 $cAttrS = isset($styles[$cAttrS]) ? $cAttrS : 0;
   740|                                                 $cell->setXfIndex($cAttrS);
   741|                                                 if ($cellDataType === DataType::TYPE_FORMULA && $styles[$cAttrS]->quotePrefix === true) {
   742|                                                     $cell->getStyle()->setQuotePrefix(false);
   743|                                                 }
   744|                                                 $docSheet->setSelectedCells($holdSelected);
   745|                                             }
   746|                                         }
   747|                                         ++$rowIndex;
   748|                                     }
   749|                                     ++$cIndex;
   750|                                 }
   751|                             }
   752|                             $docSheet->setSelectedCells($holdSelectedCells);
   753|                             if ($xmlSheetNS && $xmlSheetNS->ignoredErrors) {
   754|                                 foreach ($xmlSheetNS->ignoredErrors->ignoredError as $ignoredErrorx) {
   755|                                     $ignoredError = self::testSimpleXml($ignoredErrorx);
   756|                                     $this->processIgnoredErrors($ignoredError, $docSheet);
   757|                                 }
   758|                             }
   759|                             if (!$this->readDataOnly && $xmlSheetNS && $xmlSheetNS->sheetProtection) {
   760|                                 $protAttr = $xmlSheetNS->sheetProtection->attributes() ?? [];
   761|                                 foreach ($protAttr as $key => $value) {
   762|                                     $method = 'set' . ucfirst($key);
   763|                                     $docSheet->getProtection()->$method(self::boolean((string) $value));
   764|                                 }

# --- HUNK 2: Lines 1024-1064 ---
  1024|                                             }
  1025|                                             $vmlDrawing = $this->loadZipNoNamespace($vmlRelationship, '');
  1026|                                             $vmlDrawing->registerXPathNamespace('v', Namespaces::URN_VML);
  1027|                                             $hfImages = [];
  1028|                                             $shapes = self::xpathNoFalse($vmlDrawing, '//v:shape');
  1029|                                             foreach ($shapes as $idx => $shape) {
  1030|                                                 $shape->registerXPathNamespace('v', Namespaces::URN_VML);
  1031|                                                 $imageData = $shape->xpath('//v:imagedata');
  1032|                                                 if (empty($imageData)) {
  1033|                                                     continue;
  1034|                                                 }
  1035|                                                 $imageData = $imageData[$idx];
  1036|                                                 $imageData = self::getAttributes($imageData, Namespaces::URN_MSOFFICE);
  1037|                                                 $style = self::toCSSArray((string) $shape['style']);
  1038|                                                 if (array_key_exists((string) $imageData['relid'], $drawings)) {
  1039|                                                     $shapeId = (string) $shape['id'];
  1040|                                                     $hfImages[$shapeId] = new HeaderFooterDrawing();
  1041|                                                     if (isset($imageData['title'])) {
  1042|                                                         $hfImages[$shapeId]->setName((string) $imageData['title']);
  1043|                                                     }
  1044|                                                     $hfImages[$shapeId]->setPath('zip://' . File::realpath($filename) . '#' . $drawings[(string) $imageData['relid']], false);
  1045|                                                     $hfImages[$shapeId]->setResizeProportional(false);
  1046|                                                     $hfImages[$shapeId]->setWidth($style['width']);
  1047|                                                     $hfImages[$shapeId]->setHeight($style['height']);
  1048|                                                     if (isset($style['margin-left'])) {
  1049|                                                         $hfImages[$shapeId]->setOffsetX($style['margin-left']);
  1050|                                                     }
  1051|                                                     $hfImages[$shapeId]->setOffsetY($style['margin-top']);
  1052|                                                     $hfImages[$shapeId]->setResizeProportional(true);
  1053|                                                 }
  1054|                                             }
  1055|                                             $docSheet->getHeaderFooter()->setImages($hfImages);
  1056|                                         }
  1057|                                     }
  1058|                                 }
  1059|                             }
  1060|                             $drawingFilename = dirname("$dir/$fileWorksheet")
  1061|                                 . '/_rels/'
  1062|                                 . basename($fileWorksheet)
  1063|                                 . '.rels';
  1064|                             if (str_starts_with($drawingFilename, 'xl//xl/')) {

# --- HUNK 3: Lines 1128-1177 ---
  1128|                                             foreach ($xmlDrawingChildren->oneCellAnchor as $oneCellAnchor) {
  1129|                                                 $oneCellAnchor = self::testSimpleXml($oneCellAnchor);
  1130|                                                 if ($oneCellAnchor->pic->blipFill) {
  1131|                                                     /** @var SimpleXMLElement $blip */
  1132|                                                     $blip = $oneCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->blip;
  1133|                                                     /** @var SimpleXMLElement $xfrm */
  1134|                                                     $xfrm = $oneCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->xfrm;
  1135|                                                     /** @var SimpleXMLElement $outerShdw */
  1136|                                                     $outerShdw = $oneCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->effectLst->outerShdw;
  1137|                                                     $objDrawing = new \PhpOffice\PhpSpreadsheet\Worksheet\Drawing();
  1138|                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'name'));
  1139|                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
  1140|                                                     $embedImageKey = (string) self::getArrayItem(
  1141|                                                         self::getAttributes($blip, $xmlNamespaceBase),
  1142|                                                         'embed'
  1143|                                                     );
  1144|                                                     if (isset($images[$embedImageKey])) {
  1145|                                                         $objDrawing->setPath(
  1146|                                                             'zip://' . File::realpath($filename) . '#'
  1147|                                                             . $images[$embedImageKey],
  1148|                                                             false
  1149|                                                         );
  1150|                                                     } else {
  1151|                                                         $linkImageKey = (string) self::getArrayItem(
  1152|                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
  1153|                                                             'link'
  1154|                                                         );
  1155|                                                         if (isset($images[$linkImageKey])) {
  1156|                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
  1157|                                                             $objDrawing->setPath($url);
  1158|                                                         }
  1159|                                                     }
  1160|                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $oneCellAnchor->from->col) + 1) . ($oneCellAnchor->from->row + 1));
  1161|                                                     $objDrawing->setOffsetX((int) Drawing::EMUToPixels($oneCellAnchor->from->colOff));
  1162|                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($oneCellAnchor->from->rowOff));
  1163|                                                     $objDrawing->setResizeProportional(false);
  1164|                                                     $objDrawing->setWidth(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cx')));
  1165|                                                     $objDrawing->setHeight(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cy')));
  1166|                                                     if ($xfrm) {
  1167|                                                         $objDrawing->setRotation((int) Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($xfrm), 'rot')));
  1168|                                                         $objDrawing->setFlipVertical((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipV'));
  1169|                                                         $objDrawing->setFlipHorizontal((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipH'));
  1170|                                                     }
  1171|                                                     if ($outerShdw) {
  1172|                                                         $shadow = $objDrawing->getShadow();
  1173|                                                         $shadow->setVisible(true);
  1174|                                                         $shadow->setBlurRadius(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'blurRad')));
  1175|                                                         $shadow->setDistance(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'dist')));
  1176|                                                         $shadow->setDirection(Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($outerShdw), 'dir')));
  1177|                                                         $shadow->setAlignment((string) self::getArrayItem(self::getAttributes($outerShdw), 'algn'));

# --- HUNK 4: Lines 1211-1260 ---
  1211|                                                     $blip = $twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->blip;
  1212|                                                     if (isset($twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->srcRect)) {
  1213|                                                         $objDrawing->setSrcRect($twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->srcRect->attributes());
  1214|                                                     }
  1215|                                                     $xfrm = $twoCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->xfrm;
  1216|                                                     $outerShdw = $twoCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->effectLst->outerShdw;
  1217|                                                     $editAs = $twoCellAnchor->attributes();
  1218|                                                     if (isset($editAs, $editAs['editAs'])) {
  1219|                                                         $objDrawing->setEditAs($editAs['editAs']);
  1220|                                                     }
  1221|                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'name'));
  1222|                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
  1223|                                                     $embedImageKey = (string) self::getArrayItem(
  1224|                                                         self::getAttributes($blip, $xmlNamespaceBase),
  1225|                                                         'embed'
  1226|                                                     );
  1227|                                                     if (isset($images[$embedImageKey])) {
  1228|                                                         $objDrawing->setPath(
  1229|                                                             'zip://' . File::realpath($filename) . '#'
  1230|                                                             . $images[$embedImageKey],
  1231|                                                             false
  1232|                                                         );
  1233|                                                     } else {
  1234|                                                         $linkImageKey = (string) self::getArrayItem(
  1235|                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
  1236|                                                             'link'
  1237|                                                         );
  1238|                                                         if (isset($images[$linkImageKey])) {
  1239|                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
  1240|                                                             $objDrawing->setPath($url);
  1241|                                                         }
  1242|                                                     }
  1243|                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->from->col) + 1) . ($twoCellAnchor->from->row + 1));
  1244|                                                     $objDrawing->setOffsetX(Drawing::EMUToPixels($twoCellAnchor->from->colOff));
  1245|                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($twoCellAnchor->from->rowOff));
  1246|                                                     $objDrawing->setCoordinates2(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->to->col) + 1) . ($twoCellAnchor->to->row + 1));
  1247|                                                     $objDrawing->setOffsetX2(Drawing::EMUToPixels($twoCellAnchor->to->colOff));
  1248|                                                     $objDrawing->setOffsetY2(Drawing::EMUToPixels($twoCellAnchor->to->rowOff));
  1249|                                                     $objDrawing->setResizeProportional(false);
  1250|                                                     if ($xfrm) {
  1251|                                                         $objDrawing->setWidth(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($xfrm->ext), 'cx')));
  1252|                                                         $objDrawing->setHeight(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($xfrm->ext), 'cy')));
  1253|                                                         $objDrawing->setRotation(Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($xfrm), 'rot')));
  1254|                                                         $objDrawing->setFlipVertical((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipV'));
  1255|                                                         $objDrawing->setFlipHorizontal((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipH'));
  1256|                                                     }
  1257|                                                     if ($outerShdw) {
  1258|                                                         $shadow = $objDrawing->getShadow();
  1259|                                                         $shadow->setVisible(true);
  1260|                                                         $shadow->setBlurRadius(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'blurRad')));


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Xlsx/ColumnAndRowAttributes.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-192 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     4| use PhpOffice\PhpSpreadsheet\Reader\DefaultReadFilter;
     5| use PhpOffice\PhpSpreadsheet\Reader\IReadFilter;
     6| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     7| use SimpleXMLElement;
     8| class ColumnAndRowAttributes extends BaseParserClass
     9| {
    10|     private Worksheet $worksheet;
    11|     private ?SimpleXMLElement $worksheetXml;
    12|     public function __construct(Worksheet $workSheet, ?SimpleXMLElement $worksheetXml = null)
    13|     {
    14|         $this->worksheet = $workSheet;
    15|         $this->worksheetXml = $worksheetXml;
    16|     }
    17|     /**
    18|      * Set Worksheet column attributes by attributes array passed.
    19|      *
    20|      * @param string $columnAddress A, B, ... DX, ...
    21|      * @param array $columnAttributes array of attributes (indexes are attribute name, values are value)
    22|      *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'width', ... ?
    23|      */
    24|     private function setColumnAttributes(string $columnAddress, array $columnAttributes): void
    25|     {
    26|         if (isset($columnAttributes['xfIndex'])) {
    27|             $this->worksheet->getColumnDimension($columnAddress)->setXfIndex($columnAttributes['xfIndex']);
    28|         }
    29|         if (isset($columnAttributes['visible'])) {
    30|             $this->worksheet->getColumnDimension($columnAddress)->setVisible($columnAttributes['visible']);
    31|         }
    32|         if (isset($columnAttributes['collapsed'])) {
    33|             $this->worksheet->getColumnDimension($columnAddress)->setCollapsed($columnAttributes['collapsed']);
    34|         }
    35|         if (isset($columnAttributes['outlineLevel'])) {
    36|             $this->worksheet->getColumnDimension($columnAddress)->setOutlineLevel($columnAttributes['outlineLevel']);
    37|         }
    38|         if (isset($columnAttributes['width'])) {
    39|             $this->worksheet->getColumnDimension($columnAddress)->setWidth($columnAttributes['width']);
    40|         }
    41|     }
    42|     /**
    43|      * Set Worksheet row attributes by attributes array passed.
    44|      *
    45|      * @param int $rowNumber 1, 2, 3, ... 99, ...
    46|      * @param array $rowAttributes array of attributes (indexes are attribute name, values are value)
    47|      *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'rowHeight', ... ?
    48|      */
    49|     private function setRowAttributes(int $rowNumber, array $rowAttributes): void
    50|     {
    51|         if (isset($rowAttributes['xfIndex'])) {
    52|             $this->worksheet->getRowDimension($rowNumber)->setXfIndex($rowAttributes['xfIndex']);
    53|         }
    54|         if (isset($rowAttributes['visible'])) {
    55|             $this->worksheet->getRowDimension($rowNumber)->setVisible($rowAttributes['visible']);
    56|         }
    57|         if (isset($rowAttributes['collapsed'])) {
    58|             $this->worksheet->getRowDimension($rowNumber)->setCollapsed($rowAttributes['collapsed']);
    59|         }
    60|         if (isset($rowAttributes['outlineLevel'])) {
    61|             $this->worksheet->getRowDimension($rowNumber)->setOutlineLevel($rowAttributes['outlineLevel']);
    62|         }
    63|         if (isset($rowAttributes['rowHeight'])) {
    64|             $this->worksheet->getRowDimension($rowNumber)->setRowHeight($rowAttributes['rowHeight']);
    65|         }
    66|     }
    67|     public function load(?IReadFilter $readFilter = null, bool $readDataOnly = false, bool $ignoreRowsWithNoCells = false): void
    68|     {
    69|         if ($this->worksheetXml === null) {
    70|             return;
    71|         }
    72|         $columnsAttributes = [];
    73|         $rowsAttributes = [];
    74|         if (isset($this->worksheetXml->cols)) {
    75|             $columnsAttributes = $this->readColumnAttributes($this->worksheetXml->cols, $readDataOnly);
    76|         }
    77|         if ($this->worksheetXml->sheetData && $this->worksheetXml->sheetData->row) {
    78|             $rowsAttributes = $this->readRowAttributes($this->worksheetXml->sheetData->row, $readDataOnly, $ignoreRowsWithNoCells);
    79|         }
    80|         if ($readFilter !== null && $readFilter::class === DefaultReadFilter::class) {
    81|             $readFilter = null;
    82|         }
    83|         $columnsAttributesAreSet = [];
    84|         foreach ($columnsAttributes as $columnCoordinate => $columnAttributes) {
    85|             if (
    86|                 $readFilter === null
    87|                 || !$this->isFilteredColumn($readFilter, $columnCoordinate, $rowsAttributes)
    88|             ) {
    89|                 if (!isset($columnsAttributesAreSet[$columnCoordinate])) {
    90|                     $this->setColumnAttributes($columnCoordinate, $columnAttributes);
    91|                     $columnsAttributesAreSet[$columnCoordinate] = true;
    92|                 }
    93|             }
    94|         }
    95|         $rowsAttributesAreSet = [];
    96|         foreach ($rowsAttributes as $rowCoordinate => $rowAttributes) {
    97|             if (
    98|                 $readFilter === null
    99|                 || !$this->isFilteredRow($readFilter, $rowCoordinate, $columnsAttributes)
   100|             ) {
   101|                 if (!isset($rowsAttributesAreSet[$rowCoordinate])) {
   102|                     $this->setRowAttributes($rowCoordinate, $rowAttributes);
   103|                     $rowsAttributesAreSet[$rowCoordinate] = true;
   104|                 }
   105|             }
   106|         }
   107|     }
   108|     private function isFilteredColumn(IReadFilter $readFilter, string $columnCoordinate, array $rowsAttributes): bool
   109|     {
   110|         foreach ($rowsAttributes as $rowCoordinate => $rowAttributes) {
   111|             if (!$readFilter->readCell($columnCoordinate, $rowCoordinate, $this->worksheet->getTitle())) {
   112|                 return true;
   113|             }
   114|         }
   115|         return false;
   116|     }
   117|     private function readColumnAttributes(SimpleXMLElement $worksheetCols, bool $readDataOnly): array
   118|     {
   119|         $columnAttributes = [];
   120|         foreach ($worksheetCols->col as $columnx) {
   121|             $column = $columnx->attributes();
   122|             if ($column !== null) {
   123|                 $startColumn = Coordinate::stringFromColumnIndex((int) $column['min']);
   124|                 $endColumn = Coordinate::stringFromColumnIndex((int) $column['max']);
   125|                 ++$endColumn;
   126|                 for ($columnAddress = $startColumn; $columnAddress !== $endColumn; ++$columnAddress) {
   127|                     $columnAttributes[$columnAddress] = $this->readColumnRangeAttributes($column, $readDataOnly);
   128|                     if ((int) ($column['max']) == 16384) {
   129|                         break;
   130|                     }
   131|                 }
   132|             }
   133|         }
   134|         return $columnAttributes;
   135|     }
   136|     private function readColumnRangeAttributes(?SimpleXMLElement $column, bool $readDataOnly): array
   137|     {
   138|         $columnAttributes = [];
   139|         if ($column !== null) {
   140|             if (isset($column['style']) && !$readDataOnly) {
   141|                 $columnAttributes['xfIndex'] = (int) $column['style'];
   142|             }
   143|             if (isset($column['hidden']) && self::boolean($column['hidden'])) {
   144|                 $columnAttributes['visible'] = false;
   145|             }
   146|             if (isset($column['collapsed']) && self::boolean($column['collapsed'])) {
   147|                 $columnAttributes['collapsed'] = true;
   148|             }
   149|             if (isset($column['outlineLevel']) && ((int) $column['outlineLevel']) > 0) {
   150|                 $columnAttributes['outlineLevel'] = (int) $column['outlineLevel'];
   151|             }
   152|             if (isset($column['width'])) {
   153|                 $columnAttributes['width'] = (float) $column['width'];
   154|             }
   155|         }
   156|         return $columnAttributes;
   157|     }
   158|     private function isFilteredRow(IReadFilter $readFilter, int $rowCoordinate, array $columnsAttributes): bool
   159|     {
   160|         foreach ($columnsAttributes as $columnCoordinate => $columnAttributes) {
   161|             if (!$readFilter->readCell($columnCoordinate, $rowCoordinate, $this->worksheet->getTitle())) {
   162|                 return true;
   163|             }
   164|         }
   165|         return false;
   166|     }
   167|     private function readRowAttributes(SimpleXMLElement $worksheetRow, bool $readDataOnly, bool $ignoreRowsWithNoCells): array
   168|     {
   169|         $rowAttributes = [];
   170|         foreach ($worksheetRow as $rowx) {
   171|             $row = $rowx->attributes();
   172|             if ($row !== null && (!$ignoreRowsWithNoCells || isset($rowx->c))) {
   173|                 if (isset($row['ht']) && !$readDataOnly) {
   174|                     $rowAttributes[(int) $row['r']]['rowHeight'] = (float) $row['ht'];
   175|                 }
   176|                 if (isset($row['hidden']) && self::boolean($row['hidden'])) {
   177|                     $rowAttributes[(int) $row['r']]['visible'] = false;
   178|                 }
   179|                 if (isset($row['collapsed']) && self::boolean($row['collapsed'])) {
   180|                     $rowAttributes[(int) $row['r']]['collapsed'] = true;
   181|                 }
   182|                 if (isset($row['outlineLevel']) && (int) $row['outlineLevel'] > 0) {
   183|                     $rowAttributes[(int) $row['r']]['outlineLevel'] = (int) $row['outlineLevel'];
   184|                 }
   185|                 if (isset($row['s']) && !$readDataOnly) {
   186|                     $rowAttributes[(int) $row['r']]['xfIndex'] = (int) $row['s'];
   187|                 }
   188|             }
   189|         }
   190|         return $rowAttributes;
   191|     }
   192| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Xlsx/ConditionalStyles.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-277 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Styles as StyleReader;
     4| use PhpOffice\PhpSpreadsheet\Style\Color;
     5| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     6| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalColorScale;
     7| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalDataBar;
     8| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormattingRuleExtension;
     9| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormatValueObject;
    10| use PhpOffice\PhpSpreadsheet\Style\Style as Style;
    11| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    12| use SimpleXMLElement;
    13| use stdClass;
    14| class ConditionalStyles
    15| {
    16|     private Worksheet $worksheet;
    17|     private SimpleXMLElement $worksheetXml;
    18|     private array $ns;
    19|     private array $dxfs;
    20|     private StyleReader $styleReader;
    21|     public function __construct(Worksheet $workSheet, SimpleXMLElement $worksheetXml, array $dxfs, StyleReader $styleReader)
    22|     {
    23|         $this->worksheet = $workSheet;
    24|         $this->worksheetXml = $worksheetXml;
    25|         $this->dxfs = $dxfs;
    26|         $this->styleReader = $styleReader;
    27|     }
    28|     public function load(): void
    29|     {
    30|         $selectedCells = $this->worksheet->getSelectedCells();
    31|         $this->setConditionalStyles(
    32|             $this->worksheet,
    33|             $this->readConditionalStyles($this->worksheetXml),
    34|             $this->worksheetXml->extLst
    35|         );
    36|         $this->worksheet->setSelectedCells($selectedCells);
    37|     }
    38|     public function loadFromExt(): void
    39|     {
    40|         $selectedCells = $this->worksheet->getSelectedCells();
    41|         $this->ns = $this->worksheetXml->getNamespaces(true);
    42|         $this->setConditionalsFromExt(
    43|             $this->readConditionalsFromExt($this->worksheetXml->extLst)
    44|         );
    45|         $this->worksheet->setSelectedCells($selectedCells);
    46|     }
    47|     private function setConditionalsFromExt(array $conditionals): void
    48|     {
    49|         foreach ($conditionals as $conditionalRange => $cfRules) {
    50|             ksort($cfRules);
    51|             $this->worksheet->getStyle($conditionalRange)
    52|                 ->setConditionalStyles(array_values($cfRules));
    53|         }
    54|     }
    55|     private function readConditionalsFromExt(SimpleXMLElement $extLst): array
    56|     {
    57|         $conditionals = [];
    58|         if (!isset($extLst->ext)) {
    59|             return $conditionals;
    60|         }
    61|         foreach ($extLst->ext as $extlstcond) {
    62|             $extAttrs = $extlstcond->attributes() ?? [];
    63|             $extUri = (string) ($extAttrs['uri'] ?? '');
    64|             if ($extUri !== '{78C0D931-6437-407d-A8EE-F0AAD7539E65}') {
    65|                 continue;
    66|             }
    67|             $conditionalFormattingRuleXml = $extlstcond->children($this->ns['x14']);
    68|             if (!$conditionalFormattingRuleXml->conditionalFormattings) {
    69|                 return [];
    70|             }
    71|             foreach ($conditionalFormattingRuleXml->children($this->ns['x14']) as $extFormattingXml) {
    72|                 $extFormattingRangeXml = $extFormattingXml->children($this->ns['xm']);
    73|                 if (!$extFormattingRangeXml->sqref) {
    74|                     continue;
    75|                 }
    76|                 $sqref = (string) $extFormattingRangeXml->sqref;
    77|                 $extCfRuleXml = $extFormattingXml->cfRule;
    78|                 $attributes = $extCfRuleXml->attributes();
    79|                 if (!$attributes) {
    80|                     continue;
    81|                 }
    82|                 $conditionType = (string) $attributes->type;
    83|                 if (
    84|                     !Conditional::isValidConditionType($conditionType)
    85|                     || $conditionType === Conditional::CONDITION_DATABAR
    86|                 ) {
    87|                     continue;
    88|                 }
    89|                 $priority = (int) $attributes->priority;
    90|                 $conditional = $this->readConditionalRuleFromExt($extCfRuleXml, $attributes);
    91|                 $cfStyle = $this->readStyleFromExt($extCfRuleXml);
    92|                 $conditional->setStyle($cfStyle);
    93|                 $conditionals[$sqref][$priority] = $conditional;
    94|             }
    95|         }
    96|         return $conditionals;
    97|     }
    98|     private function readConditionalRuleFromExt(SimpleXMLElement $cfRuleXml, SimpleXMLElement $attributes): Conditional
    99|     {
   100|         $conditionType = (string) $attributes->type;
   101|         $operatorType = (string) $attributes->operator;
   102|         $operands = [];
   103|         foreach ($cfRuleXml->children($this->ns['xm']) as $cfRuleOperandsXml) {
   104|             $operands[] = (string) $cfRuleOperandsXml;
   105|         }
   106|         $conditional = new Conditional();
   107|         $conditional->setConditionType($conditionType);
   108|         $conditional->setOperatorType($operatorType);
   109|         if (
   110|             $conditionType === Conditional::CONDITION_CONTAINSTEXT
   111|             || $conditionType === Conditional::CONDITION_NOTCONTAINSTEXT
   112|             || $conditionType === Conditional::CONDITION_BEGINSWITH
   113|             || $conditionType === Conditional::CONDITION_ENDSWITH
   114|             || $conditionType === Conditional::CONDITION_TIMEPERIOD
   115|         ) {
   116|             $conditional->setText(array_pop($operands) ?? '');
   117|         }
   118|         $conditional->setConditions($operands);
   119|         return $conditional;
   120|     }
   121|     private function readStyleFromExt(SimpleXMLElement $extCfRuleXml): Style
   122|     {
   123|         $cfStyle = new Style(false, true);
   124|         if ($extCfRuleXml->dxf) {
   125|             $styleXML = $extCfRuleXml->dxf->children();
   126|             if ($styleXML->borders) {
   127|                 $this->styleReader->readBorderStyle($cfStyle->getBorders(), $styleXML->borders);
   128|             }
   129|             if ($styleXML->fill) {
   130|                 $this->styleReader->readFillStyle($cfStyle->getFill(), $styleXML->fill);
   131|             }
   132|         }
   133|         return $cfStyle;
   134|     }
   135|     private function readConditionalStyles(SimpleXMLElement $xmlSheet): array
   136|     {
   137|         $conditionals = [];
   138|         foreach ($xmlSheet->conditionalFormatting as $conditional) {
   139|             foreach ($conditional->cfRule as $cfRule) {
   140|                 if (Conditional::isValidConditionType((string) $cfRule['type']) && (!isset($cfRule['dxfId']) || isset($this->dxfs[(int) ($cfRule['dxfId'])]))) {
   141|                     $conditionals[(string) $conditional['sqref']][(int) ($cfRule['priority'])] = $cfRule;
   142|                 } elseif ((string) $cfRule['type'] == Conditional::CONDITION_DATABAR) {
   143|                     $conditionals[(string) $conditional['sqref']][(int) ($cfRule['priority'])] = $cfRule;
   144|                 }
   145|             }
   146|         }
   147|         return $conditionals;
   148|     }
   149|     private function setConditionalStyles(Worksheet $worksheet, array $conditionals, SimpleXMLElement $xmlExtLst): void
   150|     {
   151|         foreach ($conditionals as $cellRangeReference => $cfRules) {
   152|             ksort($cfRules);
   153|             $conditionalStyles = $this->readStyleRules($cfRules, $xmlExtLst);
   154|             $cellRangeReference = str_replace(['$', ' ', ',', '^'], ['', '^', ' ', ','], strtoupper($cellRangeReference));
   155|             $worksheet->getStyle($cellRangeReference)->setConditionalStyles($conditionalStyles);
   156|         }
   157|     }
   158|     private function readStyleRules(array $cfRules, SimpleXMLElement $extLst): array
   159|     {
   160|         $conditionalFormattingRuleExtensions = ConditionalFormattingRuleExtension::parseExtLstXml($extLst);
   161|         $conditionalStyles = [];
   162|         /** @var SimpleXMLElement $cfRule */
   163|         foreach ($cfRules as $cfRule) {
   164|             $objConditional = new Conditional();
   165|             $objConditional->setConditionType((string) $cfRule['type']);
   166|             $objConditional->setOperatorType((string) $cfRule['operator']);
   167|             $objConditional->setNoFormatSet(!isset($cfRule['dxfId']));
   168|             if ((string) $cfRule['text'] != '') {
   169|                 $objConditional->setText((string) $cfRule['text']);
   170|             } elseif ((string) $cfRule['timePeriod'] != '') {
   171|                 $objConditional->setText((string) $cfRule['timePeriod']);
   172|             }
   173|             if (isset($cfRule['stopIfTrue']) && (int) $cfRule['stopIfTrue'] === 1) {
   174|                 $objConditional->setStopIfTrue(true);
   175|             }
   176|             if (count($cfRule->formula) >= 1) {
   177|                 foreach ($cfRule->formula as $formulax) {
   178|                     $formula = (string) $formulax;
   179|                     if ($formula === 'TRUE') {
   180|                         $objConditional->addCondition(true);
   181|                     } elseif ($formula === 'FALSE') {
   182|                         $objConditional->addCondition(false);
   183|                     } else {
   184|                         $objConditional->addCondition($formula);
   185|                     }
   186|                 }
   187|             } else {
   188|                 $objConditional->addCondition('');
   189|             }
   190|             if (isset($cfRule->dataBar)) {
   191|                 $objConditional->setDataBar(
   192|                     $this->readDataBarOfConditionalRule($cfRule, $conditionalFormattingRuleExtensions)
   193|                 );
   194|             } elseif (isset($cfRule->colorScale)) {
   195|                 $objConditional->setColorScale(
   196|                     $this->readColorScale($cfRule)
   197|                 );
   198|             } elseif (isset($cfRule['dxfId'])) {
   199|                 $objConditional->setStyle(clone $this->dxfs[(int) ($cfRule['dxfId'])]);
   200|             }
   201|             $conditionalStyles[] = $objConditional;
   202|         }
   203|         return $conditionalStyles;
   204|     }
   205|     private function readDataBarOfConditionalRule(SimpleXMLElement $cfRule, array $conditionalFormattingRuleExtensions): ConditionalDataBar
   206|     {
   207|         $dataBar = new ConditionalDataBar();
   208|         if (isset($cfRule->dataBar['showValue'])) {
   209|             $dataBar->setShowValue((bool) $cfRule->dataBar['showValue']);
   210|         }
   211|         $cfvoXml = $cfRule->dataBar->cfvo;
   212|         $cfvoIndex = 0;
   213|         foreach ((count($cfvoXml) > 1 ? $cfvoXml : [$cfvoXml]) as $cfvo) { //* @phpstan-ignore-line
   214|             if ($cfvoIndex === 0) {
   215|                 $dataBar->setMinimumConditionalFormatValueObject(new ConditionalFormatValueObject((string) $cfvo['type'], (string) $cfvo['val']));
   216|             }
   217|             if ($cfvoIndex === 1) {
   218|                 $dataBar->setMaximumConditionalFormatValueObject(new ConditionalFormatValueObject((string) $cfvo['type'], (string) $cfvo['val']));
   219|             }
   220|             ++$cfvoIndex;
   221|         }
   222|         if (isset($cfRule->dataBar->color)) {
   223|             $dataBar->setColor($this->styleReader->readColor($cfRule->dataBar->color));
   224|         }
   225|         $this->readDataBarExtLstOfConditionalRule($dataBar, $cfRule, $conditionalFormattingRuleExtensions);
   226|         return $dataBar;
   227|     }
   228|     private function readColorScale(SimpleXMLElement|stdClass $cfRule): ConditionalColorScale
   229|     {
   230|         $colorScale = new ConditionalColorScale();
   231|         $count = count($cfRule->colorScale->cfvo);
   232|         $idx = 0;
   233|         foreach ($cfRule->colorScale->cfvo as $cfvoXml) {
   234|             $attr = $cfvoXml->attributes() ?? [];
   235|             $type = (string) ($attr['type'] ?? '');
   236|             $val = $attr['val'] ?? null;
   237|             if ($idx === 0) {
   238|                 $method = 'setMinimumConditionalFormatValueObject';
   239|             } elseif ($idx === 1 && $count === 3) {
   240|                 $method = 'setMidpointConditionalFormatValueObject';
   241|             } else {
   242|                 $method = 'setMaximumConditionalFormatValueObject';
   243|             }
   244|             if ($type !== 'formula') {
   245|                 $colorScale->$method(new ConditionalFormatValueObject($type, $val));
   246|             } else {
   247|                 $colorScale->$method(new ConditionalFormatValueObject($type, null, $val));
   248|             }
   249|             ++$idx;
   250|         }
   251|         $idx = 0;
   252|         foreach ($cfRule->colorScale->color as $color) {
   253|             $rgb = $this->styleReader->readColor($color);
   254|             if ($idx === 0) {
   255|                 $colorScale->setMinimumColor(new Color($rgb));
   256|             } elseif ($idx === 1 && $count === 3) {
   257|                 $colorScale->setMidpointColor(new Color($rgb));
   258|             } else {
   259|                 $colorScale->setMaximumColor(new Color($rgb));
   260|             }
   261|             ++$idx;
   262|         }
   263|         return $colorScale;
   264|     }
   265|     private function readDataBarExtLstOfConditionalRule(ConditionalDataBar $dataBar, SimpleXMLElement $cfRule, array $conditionalFormattingRuleExtensions): void
   266|     {
   267|         if (isset($cfRule->extLst)) {
   268|             $ns = $cfRule->extLst->getNamespaces(true);
   269|             foreach ((count($cfRule->extLst) > 0 ? $cfRule->extLst->ext : [$cfRule->extLst->ext]) as $ext) { //* @phpstan-ignore-line
   270|                 $extId = (string) $ext->children($ns['x14'])->id;
   271|                 if (isset($conditionalFormattingRuleExtensions[$extId]) && (string) $ext['uri'] === '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}') {
   272|                     $dataBar->setConditionalFormattingRuleExt($conditionalFormattingRuleExtensions[$extId]);
   273|                 }
   274|             }
   275|         }
   276|     }
   277| }


# ====================================================================
# FILE: src/PhpSpreadsheet/ReferenceHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1025 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
     5| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     6| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     7| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     8| use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
     9| use PhpOffice\PhpSpreadsheet\Worksheet\Table;
    10| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    11| class ReferenceHelper
    12| {
    13|     /**    Constants                */
    14|     /**    Regular Expressions      */
    15|     private const SHEETNAME_PART = '((\w*|\'[^!]*\')!)';
    16|     private const SHEETNAME_PART_WITH_SLASHES = '/' . self::SHEETNAME_PART . '/';
    17|     const REFHELPER_REGEXP_CELLREF = self::SHEETNAME_PART . '?(?<![:a-z1-9_\.\$])(\$?[a-z]{1,3}\$?\d+)(?=[^:!\d\'])';
    18|     const REFHELPER_REGEXP_CELLRANGE = self::SHEETNAME_PART . '?(\$?[a-z]{1,3}\$?\d+):(\$?[a-z]{1,3}\$?\d+)';
    19|     const REFHELPER_REGEXP_ROWRANGE = self::SHEETNAME_PART . '?(\$?\d+):(\$?\d+)';
    20|     const REFHELPER_REGEXP_COLRANGE = self::SHEETNAME_PART . '?(\$?[a-z]{1,3}):(\$?[a-z]{1,3})';
    21|     /**
    22|      * Instance of this class.
    23|      *
    24|      * @var ?ReferenceHelper
    25|      */
    26|     private static ?ReferenceHelper $instance = null;
    27|     private ?CellReferenceHelper $cellReferenceHelper = null;
    28|     /**
    29|      * Get an instance of this class.
    30|      */
    31|     public static function getInstance(): self
    32|     {
    33|         if (self::$instance === null) {
    34|             self::$instance = new self();
    35|         }
    36|         return self::$instance;
    37|     }
    38|     /**
    39|      * Create a new ReferenceHelper.
    40|      */
    41|     protected function __construct()
    42|     {
    43|     }
    44|     /**
    45|      * Compare two column addresses
    46|      * Intended for use as a Callback function for sorting column addresses by column.
    47|      *
    48|      * @param string $a First column to test (e.g. 'AA')
    49|      * @param string $b Second column to test (e.g. 'Z')
    50|      */
    51|     public static function columnSort(string $a, string $b): int
    52|     {
    53|         return strcasecmp(strlen($a) . $a, strlen($b) . $b);
    54|     }
    55|     /**
    56|      * Compare two column addresses
    57|      * Intended for use as a Callback function for reverse sorting column addresses by column.
    58|      *
    59|      * @param string $a First column to test (e.g. 'AA')
    60|      * @param string $b Second column to test (e.g. 'Z')
    61|      */
    62|     public static function columnReverseSort(string $a, string $b): int
    63|     {
    64|         return -strcasecmp(strlen($a) . $a, strlen($b) . $b);
    65|     }
    66|     /**
    67|      * Compare two cell addresses
    68|      * Intended for use as a Callback function for sorting cell addresses by column and row.
    69|      *
    70|      * @param string $a First cell to test (e.g. 'AA1')
    71|      * @param string $b Second cell to test (e.g. 'Z1')
    72|      */
    73|     public static function cellSort(string $a, string $b): int
    74|     {
    75|         sscanf($a, '%[A-Z]%d', $ac, $ar);
    76|         /** @var int $ar */
    77|         /** @var string $ac */
    78|         sscanf($b, '%[A-Z]%d', $bc, $br);
    79|         /** @var int $br */
    80|         /** @var string $bc */
    81|         if ($ar === $br) {
    82|             return strcasecmp(strlen($ac) . $ac, strlen($bc) . $bc);
    83|         }
    84|         return ($ar < $br) ? -1 : 1;
    85|     }
    86|     /**
    87|      * Compare two cell addresses
    88|      * Intended for use as a Callback function for sorting cell addresses by column and row.
    89|      *
    90|      * @param string $a First cell to test (e.g. 'AA1')
    91|      * @param string $b Second cell to test (e.g. 'Z1')
    92|      */
    93|     public static function cellReverseSort(string $a, string $b): int
    94|     {
    95|         sscanf($a, '%[A-Z]%d', $ac, $ar);
    96|         /** @var int $ar */
    97|         /** @var string $ac */
    98|         sscanf($b, '%[A-Z]%d', $bc, $br);
    99|         /** @var int $br */
   100|         /** @var string $bc */
   101|         if ($ar === $br) {
   102|             return -strcasecmp(strlen($ac) . $ac, strlen($bc) . $bc);
   103|         }
   104|         return ($ar < $br) ? 1 : -1;
   105|     }
   106|     /**
   107|      * Update page breaks when inserting/deleting rows/columns.
   108|      *
   109|      * @param Worksheet $worksheet The worksheet that we're editing
   110|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   111|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   112|      */
   113|     protected function adjustPageBreaks(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
   114|     {
   115|         $aBreaks = $worksheet->getBreaks();
   116|         ($numberOfColumns > 0 || $numberOfRows > 0)
   117|             ? uksort($aBreaks, [self::class, 'cellReverseSort'])
   118|             : uksort($aBreaks, [self::class, 'cellSort']);
   119|         foreach ($aBreaks as $cellAddress => $value) {
   120|             /** @var CellReferenceHelper */
   121|             $cellReferenceHelper = $this->cellReferenceHelper;
   122|             if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === true) {
   123|                 $worksheet->setBreak($cellAddress, Worksheet::BREAK_NONE);
   124|             } else {
   125|                 $newReference = $this->updateCellReference($cellAddress);
   126|                 if ($cellAddress !== $newReference) {
   127|                     $worksheet->setBreak($newReference, $value)
   128|                         ->setBreak($cellAddress, Worksheet::BREAK_NONE);
   129|                 }
   130|             }
   131|         }
   132|     }
   133|     /**
   134|      * Update cell comments when inserting/deleting rows/columns.
   135|      *
   136|      * @param Worksheet $worksheet The worksheet that we're editing
   137|      */
   138|     protected function adjustComments(Worksheet $worksheet): void
   139|     {
   140|         $aComments = $worksheet->getComments();
   141|         $aNewComments = []; // the new array of all comments
   142|         foreach ($aComments as $cellAddress => &$value) {
   143|             /** @var CellReferenceHelper */
   144|             $cellReferenceHelper = $this->cellReferenceHelper;
   145|             if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === false) {
   146|                 $newReference = $this->updateCellReference($cellAddress);
   147|                 $aNewComments[$newReference] = $value;
   148|             }
   149|         }
   150|         $worksheet->setComments($aNewComments);
   151|     }
   152|     /**
   153|      * Update hyperlinks when inserting/deleting rows/columns.
   154|      *
   155|      * @param Worksheet $worksheet The worksheet that we're editing
   156|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   157|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   158|      */
   159|     protected function adjustHyperlinks(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
   160|     {
   161|         $aHyperlinkCollection = $worksheet->getHyperlinkCollection();
   162|         ($numberOfColumns > 0 || $numberOfRows > 0)
   163|             ? uksort($aHyperlinkCollection, [self::class, 'cellReverseSort'])
   164|             : uksort($aHyperlinkCollection, [self::class, 'cellSort']);
   165|         foreach ($aHyperlinkCollection as $cellAddress => $value) {
   166|             $newReference = $this->updateCellReference($cellAddress);
   167|             /** @var CellReferenceHelper */
   168|             $cellReferenceHelper = $this->cellReferenceHelper;
   169|             if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === true) {
   170|                 $worksheet->setHyperlink($cellAddress, null);
   171|             } elseif ($cellAddress !== $newReference) {
   172|                 $worksheet->setHyperlink($newReference, $value);
   173|                 $worksheet->setHyperlink($cellAddress, null);
   174|             }
   175|         }
   176|     }
   177|     /**
   178|      * Update conditional formatting styles when inserting/deleting rows/columns.
   179|      *
   180|      * @param Worksheet $worksheet The worksheet that we're editing
   181|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   182|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   183|      */
   184|     protected function adjustConditionalFormatting(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
   185|     {
   186|         $aStyles = $worksheet->getConditionalStylesCollection();
   187|         ($numberOfColumns > 0 || $numberOfRows > 0)
   188|             ? uksort($aStyles, [self::class, 'cellReverseSort'])
   189|             : uksort($aStyles, [self::class, 'cellSort']);
   190|         foreach ($aStyles as $cellAddress => $cfRules) {
   191|             $worksheet->removeConditionalStyles($cellAddress);
   192|             $newReference = $this->updateCellReference($cellAddress);
   193|             foreach ($cfRules as &$cfRule) {
   194|                 /** @var Conditional $cfRule */
   195|                 $conditions = $cfRule->getConditions();
   196|                 foreach ($conditions as &$condition) {
   197|                     if (is_string($condition)) {
   198|                         /** @var CellReferenceHelper */
   199|                         $cellReferenceHelper = $this->cellReferenceHelper;
   200|                         $condition = $this->updateFormulaReferences(
   201|                             $condition,
   202|                             $cellReferenceHelper->beforeCellAddress(),
   203|                             $numberOfColumns,
   204|                             $numberOfRows,
   205|                             $worksheet->getTitle(),
   206|                             true
   207|                         );
   208|                     }
   209|                 }
   210|                 $cfRule->setConditions($conditions);
   211|             }
   212|             $worksheet->setConditionalStyles($newReference, $cfRules);
   213|         }
   214|     }
   215|     /**
   216|      * Update data validations when inserting/deleting rows/columns.
   217|      *
   218|      * @param Worksheet $worksheet The worksheet that we're editing
   219|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   220|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   221|      */
   222|     protected function adjustDataValidations(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
   223|     {
   224|         $aDataValidationCollection = $worksheet->getDataValidationCollection();
   225|         ($numberOfColumns > 0 || $numberOfRows > 0)
   226|             ? uksort($aDataValidationCollection, [self::class, 'cellReverseSort'])
   227|             : uksort($aDataValidationCollection, [self::class, 'cellSort']);
   228|         foreach ($aDataValidationCollection as $cellAddress => $dataValidation) {
   229|             $newReference = $this->updateCellReference($cellAddress);
   230|             if ($cellAddress !== $newReference) {
   231|                 $dataValidation->setSqref($newReference);
   232|                 $worksheet->setDataValidation($newReference, $dataValidation);
   233|                 $worksheet->setDataValidation($cellAddress, null);
   234|             }
   235|         }
   236|     }
   237|     /**
   238|      * Update merged cells when inserting/deleting rows/columns.
   239|      *
   240|      * @param Worksheet $worksheet The worksheet that we're editing
   241|      */
   242|     protected function adjustMergeCells(Worksheet $worksheet): void
   243|     {
   244|         $aMergeCells = $worksheet->getMergeCells();
   245|         $aNewMergeCells = []; // the new array of all merge cells
   246|         foreach ($aMergeCells as $cellAddress => &$value) {
   247|             $newReference = $this->updateCellReference($cellAddress);
   248|             $aNewMergeCells[$newReference] = $newReference;
   249|         }
   250|         $worksheet->setMergeCells($aNewMergeCells); // replace the merge cells array
   251|     }
   252|     /**
   253|      * Update protected cells when inserting/deleting rows/columns.
   254|      *
   255|      * @param Worksheet $worksheet The worksheet that we're editing
   256|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   257|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   258|      */
   259|     protected function adjustProtectedCells(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
   260|     {
   261|         $aProtectedCells = $worksheet->getProtectedCells();
   262|         ($numberOfColumns > 0 || $numberOfRows > 0)
   263|             ? uksort($aProtectedCells, [self::class, 'cellReverseSort'])
   264|             : uksort($aProtectedCells, [self::class, 'cellSort']);
   265|         foreach ($aProtectedCells as $cellAddress => $value) {
   266|             $newReference = $this->updateCellReference($cellAddress);
   267|             if ($cellAddress !== $newReference) {
   268|                 $worksheet->protectCells($newReference, $value, true);
   269|                 $worksheet->unprotectCells($cellAddress);
   270|             }
   271|         }
   272|     }
   273|     /**
   274|      * Update column dimensions when inserting/deleting rows/columns.
   275|      *
   276|      * @param Worksheet $worksheet The worksheet that we're editing
   277|      */
   278|     protected function adjustColumnDimensions(Worksheet $worksheet): void
   279|     {
   280|         $aColumnDimensions = array_reverse($worksheet->getColumnDimensions(), true);
   281|         if (!empty($aColumnDimensions)) {
   282|             foreach ($aColumnDimensions as $objColumnDimension) {
   283|                 $newReference = $this->updateCellReference($objColumnDimension->getColumnIndex() . '1');
   284|                 [$newReference] = Coordinate::coordinateFromString($newReference);
   285|                 if ($objColumnDimension->getColumnIndex() !== $newReference) {
   286|                     $objColumnDimension->setColumnIndex($newReference);
   287|                 }
   288|             }
   289|             $worksheet->refreshColumnDimensions();
   290|         }
   291|     }
   292|     /**
   293|      * Update row dimensions when inserting/deleting rows/columns.
   294|      *
   295|      * @param Worksheet $worksheet The worksheet that we're editing
   296|      * @param int $beforeRow Number of the row we're inserting/deleting before
   297|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   298|      */
   299|     protected function adjustRowDimensions(Worksheet $worksheet, int $beforeRow, int $numberOfRows): void
   300|     {
   301|         $aRowDimensions = array_reverse($worksheet->getRowDimensions(), true);
   302|         if (!empty($aRowDimensions)) {
   303|             foreach ($aRowDimensions as $objRowDimension) {
   304|                 $newReference = $this->updateCellReference('A' . $objRowDimension->getRowIndex());
   305|                 [, $newReference] = Coordinate::coordinateFromString($newReference);
   306|                 $newRoweference = (int) $newReference;
   307|                 if ($objRowDimension->getRowIndex() !== $newRoweference) {
   308|                     $objRowDimension->setRowIndex($newRoweference);
   309|                 }
   310|             }
   311|             $worksheet->refreshRowDimensions();
   312|             $copyDimension = $worksheet->getRowDimension($beforeRow - 1);
   313|             for ($i = $beforeRow; $i <= $beforeRow - 1 + $numberOfRows; ++$i) {
   314|                 $newDimension = $worksheet->getRowDimension($i);
   315|                 $newDimension->setRowHeight($copyDimension->getRowHeight());
   316|                 $newDimension->setVisible($copyDimension->getVisible());
   317|                 $newDimension->setOutlineLevel($copyDimension->getOutlineLevel());
   318|                 $newDimension->setCollapsed($copyDimension->getCollapsed());
   319|             }
   320|         }
   321|     }
   322|     /**
   323|      * Insert a new column or row, updating all possible related data.
   324|      *
   325|      * @param string $beforeCellAddress Insert before this cell address (e.g. 'A1')
   326|      * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
   327|      * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
   328|      * @param Worksheet $worksheet The worksheet that we're editing
   329|      */
   330|     public function insertNewBefore(
   331|         string $beforeCellAddress,
   332|         int $numberOfColumns,
   333|         int $numberOfRows,
   334|         Worksheet $worksheet
   335|     ): void {
   336|         $remove = ($numberOfColumns < 0 || $numberOfRows < 0);
   337|         if (
   338|             $this->cellReferenceHelper === null
   339|             || $this->cellReferenceHelper->refreshRequired($beforeCellAddress, $numberOfColumns, $numberOfRows)
   340|         ) {
   341|             $this->cellReferenceHelper = new CellReferenceHelper($beforeCellAddress, $numberOfColumns, $numberOfRows);
   342|         }
   343|         [$beforeColumn, $beforeRow, $beforeColumnString] = Coordinate::indexesFromString($beforeCellAddress);
   344|         $highestColumn = $worksheet->getHighestColumn();
   345|         $highestDataColumn = $worksheet->getHighestDataColumn();
   346|         $highestRow = $worksheet->getHighestRow();
   347|         $highestDataRow = $worksheet->getHighestDataRow();
   348|         if ($numberOfColumns < 0 && $beforeColumn - 2 + $numberOfColumns > 0) {
   349|             $this->clearColumnStrips($highestRow, $beforeColumn, $numberOfColumns, $worksheet);
   350|         }
   351|         if ($numberOfRows < 0 && $beforeRow - 1 + $numberOfRows > 0) {
   352|             $this->clearRowStrips($highestColumn, $beforeColumn, $beforeRow, $numberOfRows, $worksheet);
   353|         }
   354|         $startRow = $startCol = 1;
   355|         $startColString = 'A';
   356|         if ($numberOfRows === 0) {
   357|             $startCol = $beforeColumn;
   358|             $startColString = $beforeColumnString;
   359|         } elseif ($numberOfColumns === 0) {
   360|             $startRow = $beforeRow;
   361|         }
   362|         $highColumn = Coordinate::columnIndexFromString($highestDataColumn);
   363|         for ($row = $startRow; $row <= $highestDataRow; ++$row) {
   364|             for ($col = $startCol, $colString = $startColString; $col <= $highColumn; ++$col, ++$colString) {
   365|                 $worksheet->getCell("$colString$row"); // create cell if it doesn't exist
   366|             }
   367|         }
   368|         $allCoordinates = $worksheet->getCoordinates();
   369|         if ($remove) {
   370|             $allCoordinates = array_reverse($allCoordinates);
   371|         }
   372|         while ($coordinate = array_pop($allCoordinates)) {
   373|             $cell = $worksheet->getCell($coordinate);
   374|             $cellIndex = Coordinate::columnIndexFromString($cell->getColumn());
   375|             if ($cellIndex - 1 + $numberOfColumns < 0) {
   376|                 continue;
   377|             }
   378|             $newCoordinate = Coordinate::stringFromColumnIndex($cellIndex + $numberOfColumns) . ($cell->getRow() + $numberOfRows);
   379|             if (($cellIndex >= $beforeColumn) && ($cell->getRow() >= $beforeRow)) {
   380|                 $worksheet->getCell($newCoordinate)->setXfIndex($cell->getXfIndex());
   381|                 if ($cell->getDataType() === DataType::TYPE_FORMULA) {
   382|                     $worksheet->getCell($newCoordinate)
   383|                         ->setValue($this->updateFormulaReferences($cell->getValueString(), $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true));
   384|                 } else {
   385|                     $worksheet->getCell($newCoordinate)->setValueExplicit($cell->getValue(), $cell->getDataType());
   386|                 }
   387|                 $worksheet->getCellCollection()->delete($coordinate);
   388|             } else {
   389|                 /*    We don't need to update styles for rows/columns before our insertion position,
   390|                         but we do still need to adjust any formulae in those cells                    */
   391|                 if ($cell->getDataType() === DataType::TYPE_FORMULA) {
   392|                     $cell->setValue($this->updateFormulaReferences($cell->getValueString(), $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true));
   393|                 }
   394|             }
   395|         }
   396|         $highestColumn = $worksheet->getHighestColumn();
   397|         $highestRow = $worksheet->getHighestRow();
   398|         if ($numberOfColumns > 0 && $beforeColumn - 2 > 0) {
   399|             $this->duplicateStylesByColumn($worksheet, $beforeColumn, $beforeRow, $highestRow, $numberOfColumns);
   400|         }
   401|         if ($numberOfRows > 0 && $beforeRow - 1 > 0) {
   402|             $this->duplicateStylesByRow($worksheet, $beforeColumn, $beforeRow, $highestColumn, $numberOfRows);
   403|         }
   404|         $this->adjustColumnDimensions($worksheet);
   405|         $this->adjustRowDimensions($worksheet, $beforeRow, $numberOfRows);
   406|         $this->adjustPageBreaks($worksheet, $numberOfColumns, $numberOfRows);
   407|         $this->adjustComments($worksheet);
   408|         $this->adjustHyperlinks($worksheet, $numberOfColumns, $numberOfRows);
   409|         $this->adjustConditionalFormatting($worksheet, $numberOfColumns, $numberOfRows);
   410|         $this->adjustDataValidations($worksheet, $numberOfColumns, $numberOfRows);
   411|         $this->adjustMergeCells($worksheet);
   412|         $this->adjustProtectedCells($worksheet, $numberOfColumns, $numberOfRows);
   413|         $this->adjustAutoFilter($worksheet, $beforeCellAddress, $numberOfColumns);
   414|         $this->adjustTable($worksheet, $beforeCellAddress, $numberOfColumns);
   415|         if ($worksheet->getFreezePane()) {
   416|             $splitCell = $worksheet->getFreezePane();
   417|             $topLeftCell = $worksheet->getTopLeftCell() ?? '';
   418|             $splitCell = $this->updateCellReference($splitCell);
   419|             $topLeftCell = $this->updateCellReference($topLeftCell);
   420|             $worksheet->freezePane($splitCell, $topLeftCell);
   421|         }
   422|         if ($worksheet->getPageSetup()->isPrintAreaSet()) {
   423|             $worksheet->getPageSetup()->setPrintArea(
   424|                 $this->updateCellReference($worksheet->getPageSetup()->getPrintArea())
   425|             );
   426|         }
   427|         $aDrawings = $worksheet->getDrawingCollection();
   428|         foreach ($aDrawings as $objDrawing) {
   429|             $newReference = $this->updateCellReference($objDrawing->getCoordinates());
   430|             if ($objDrawing->getCoordinates() != $newReference) {
   431|                 $objDrawing->setCoordinates($newReference);
   432|             }
   433|             if ($objDrawing->getCoordinates2() !== '') {
   434|                 $newReference = $this->updateCellReference($objDrawing->getCoordinates2());
   435|                 if ($objDrawing->getCoordinates2() != $newReference) {
   436|                     $objDrawing->setCoordinates2($newReference);
   437|                 }
   438|             }
   439|         }
   440|         if (count($worksheet->getParentOrThrow()->getDefinedNames()) > 0) {
   441|             $this->updateDefinedNames($worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
   442|         }
   443|         $worksheet->garbageCollect();
   444|     }
   445|     private static function matchSheetName(?string $match, string $worksheetName): bool
   446|     {
   447|         return $match === null || $match === '' || $match === "'\u{fffc}'" || $match === "'\u{fffb}'" || strcasecmp(trim($match, "'"), $worksheetName) === 0;
   448|     }
   449|     private static function sheetnameBeforeCells(string $match, string $worksheetName, string $cells): string
   450|     {
   451|         $toString = ($match > '') ? "$match!" : '';
   452|         return str_replace(["\u{fffc}", "'\u{fffb}'"], $worksheetName, $toString) . $cells;
   453|     }
   454|     /**
   455|      * Update references within formulas.
   456|      *
   457|      * @param string $formula Formula to update
   458|      * @param string $beforeCellAddress Insert before this one
   459|      * @param int $numberOfColumns Number of columns to insert
   460|      * @param int $numberOfRows Number of rows to insert
   461|      * @param string $worksheetName Worksheet name/title
   462|      *
   463|      * @return string Updated formula
   464|      */
   465|     public function updateFormulaReferences(
   466|         string $formula = '',
   467|         string $beforeCellAddress = 'A1',
   468|         int $numberOfColumns = 0,
   469|         int $numberOfRows = 0,
   470|         string $worksheetName = '',
   471|         bool $includeAbsoluteReferences = false,
   472|         bool $onlyAbsoluteReferences = false
   473|     ): string {
   474|         $callback = fn (array $matches): string => (strcasecmp(trim($matches[2], "'"), $worksheetName) === 0) ? (($matches[2][0] === "'") ? "'\u{fffc}'!" : "'\u{fffb}'!") : "'\u{fffd}'!";
   475|         if (
   476|             $this->cellReferenceHelper === null
   477|             || $this->cellReferenceHelper->refreshRequired($beforeCellAddress, $numberOfColumns, $numberOfRows)
   478|         ) {
   479|             $this->cellReferenceHelper = new CellReferenceHelper($beforeCellAddress, $numberOfColumns, $numberOfRows);
   480|         }
   481|         $formulaBlocks = explode('"', $formula);
   482|         $i = false;
   483|         foreach ($formulaBlocks as &$formulaBlock) {
   484|             $i = $i === false;
   485|             if ($i) {
   486|                 $adjustCount = 0;
   487|                 $newCellTokens = $cellTokens = [];
   488|                 $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
   489|                 $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_ROWRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
   490|                 if ($matchCount > 0) {
   491|                     foreach ($matches as $match) {
   492|                         $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
   493|                         $modified3 = substr($this->updateCellReference('$A' . $match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences), 2);
   494|                         $modified4 = substr($this->updateCellReference('$A' . $match[4], $includeAbsoluteReferences, $onlyAbsoluteReferences), 2);
   495|                         if ($match[3] . ':' . $match[4] !== $modified3 . ':' . $modified4) {
   496|                             if (self::matchSheetName($match[2], $worksheetName)) {
   497|                                 $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
   498|                                 $column = 100000;
   499|                                 $row = 10000000 + (int) trim($match[3], '$');
   500|                                 $cellIndex = "{$column}{$row}";
   501|                                 $newCellTokens[$cellIndex] = preg_quote($toString, '/');
   502|                                 $cellTokens[$cellIndex] = '/(?<!\d\$\!)' . preg_quote($fromString, '/') . '(?!\d)/i';
   503|                                 ++$adjustCount;
   504|                             }
   505|                         }
   506|                     }
   507|                 }
   508|                 $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
   509|                 $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_COLRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
   510|                 if ($matchCount > 0) {
   511|                     foreach ($matches as $match) {
   512|                         $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
   513|                         $modified3 = substr($this->updateCellReference($match[3] . '$1', $includeAbsoluteReferences, $onlyAbsoluteReferences), 0, -2);
   514|                         $modified4 = substr($this->updateCellReference($match[4] . '$1', $includeAbsoluteReferences, $onlyAbsoluteReferences), 0, -2);
   515|                         if ($match[3] . ':' . $match[4] !== $modified3 . ':' . $modified4) {
   516|                             if (self::matchSheetName($match[2], $worksheetName)) {
   517|                                 $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
   518|                                 $column = Coordinate::columnIndexFromString(trim($match[3], '$')) + 100000;
   519|                                 $row = 10000000;
   520|                                 $cellIndex = "{$column}{$row}";
   521|                                 $newCellTokens[$cellIndex] = preg_quote($toString, '/');
   522|                                 $cellTokens[$cellIndex] = '/(?<![A-Z\$\!])' . preg_quote($fromString, '/') . '(?![A-Z])/i';
   523|                                 ++$adjustCount;
   524|                             }
   525|                         }
   526|                     }
   527|                 }
   528|                 $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, "$formulaBlock") ?? "$formulaBlock") . ' ';
   529|                 $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_CELLRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
   530|                 if ($matchCount > 0) {
   531|                     foreach ($matches as $match) {
   532|                         $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
   533|                         $modified3 = $this->updateCellReference($match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences);
   534|                         $modified4 = $this->updateCellReference($match[4], $includeAbsoluteReferences, $onlyAbsoluteReferences);
   535|                         if ($match[3] . $match[4] !== $modified3 . $modified4) {
   536|                             if (self::matchSheetName($match[2], $worksheetName)) {
   537|                                 $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
   538|                                 [$column, $row] = Coordinate::coordinateFromString($match[3]);
   539|                                 $column = Coordinate::columnIndexFromString(trim($column, '$')) + 100000;
   540|                                 $row = (int) trim($row, '$') + 10000000;
   541|                                 $cellIndex = "{$column}{$row}";
   542|                                 $newCellTokens[$cellIndex] = preg_quote($toString, '/');
   543|                                 $cellTokens[$cellIndex] = '/(?<![A-Z]\$\!)' . preg_quote($fromString, '/') . '(?!\d)/i';
   544|                                 ++$adjustCount;
   545|                             }
   546|                         }
   547|                     }
   548|                 }
   549|                 $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
   550|                 $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_CELLREF . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
   551|                 if ($matchCount > 0) {
   552|                     foreach ($matches as $match) {
   553|                         $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}");
   554|                         $modified3 = $this->updateCellReference($match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences);
   555|                         if ($match[3] !== $modified3) {
   556|                             if (self::matchSheetName($match[2], $worksheetName)) {
   557|                                 $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3");
   558|                                 [$column, $row] = Coordinate::coordinateFromString($match[3]);
   559|                                 $columnAdditionalIndex = $column[0] === '$' ? 1 : 0;
   560|                                 $rowAdditionalIndex = $row[0] === '$' ? 1 : 0;
   561|                                 $column = Coordinate::columnIndexFromString(trim($column, '$')) + 100000;
   562|                                 $row = (int) trim($row, '$') + 10000000;
   563|                                 $cellIndex = $row . $rowAdditionalIndex . $column . $columnAdditionalIndex;
   564|                                 $newCellTokens[$cellIndex] = preg_quote($toString, '/');
   565|                                 $cellTokens[$cellIndex] = '/(?<![A-Z\$\!])' . preg_quote($fromString, '/') . '(?!\d)/i';
   566|                                 ++$adjustCount;
   567|                             }
   568|                         }
   569|                     }
   570|                 }
   571|                 if ($adjustCount > 0) {
   572|                     if ($numberOfColumns > 0 || $numberOfRows > 0) {
   573|                         krsort($cellTokens);
   574|                         krsort($newCellTokens);
   575|                     } else {
   576|                         ksort($cellTokens);
   577|                         ksort($newCellTokens);
   578|                     }   //  Update cell references in the formula
   579|                     $formulaBlock = str_replace('\\', '', (string) preg_replace($cellTokens, $newCellTokens, $formulaBlock));
   580|                 }
   581|             }
   582|         }
   583|         unset($formulaBlock);
   584|         return implode('"', $formulaBlocks);
   585|     }
   586|     /**
   587|      * Update all cell references within a formula, irrespective of worksheet.
   588|      */
   589|     public function updateFormulaReferencesAnyWorksheet(string $formula = '', int $numberOfColumns = 0, int $numberOfRows = 0): string
   590|     {
   591|         $formula = $this->updateCellReferencesAllWorksheets($formula, $numberOfColumns, $numberOfRows);
   592|         if ($numberOfColumns !== 0) {
   593|             $formula = $this->updateColumnRangesAllWorksheets($formula, $numberOfColumns);
   594|         }
   595|         if ($numberOfRows !== 0) {
   596|             $formula = $this->updateRowRangesAllWorksheets($formula, $numberOfRows);
   597|         }
   598|         return $formula;
   599|     }
   600|     private function updateCellReferencesAllWorksheets(string $formula, int $numberOfColumns, int $numberOfRows): string
   601|     {
   602|         $splitCount = preg_match_all(
   603|             '/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/mui',
   604|             $formula,
   605|             $splitRanges,
   606|             PREG_OFFSET_CAPTURE
   607|         );
   608|         $columnLengths = array_map('strlen', array_column($splitRanges[6], 0));
   609|         $rowLengths = array_map('strlen', array_column($splitRanges[7], 0));
   610|         $columnOffsets = array_column($splitRanges[6], 1);
   611|         $rowOffsets = array_column($splitRanges[7], 1);
   612|         $columns = $splitRanges[6];
   613|         $rows = $splitRanges[7];
   614|         while ($splitCount > 0) {
   615|             --$splitCount;
   616|             $columnLength = $columnLengths[$splitCount];
   617|             $rowLength = $rowLengths[$splitCount];
   618|             $columnOffset = $columnOffsets[$splitCount];
   619|             $rowOffset = $rowOffsets[$splitCount];
   620|             $column = $columns[$splitCount][0];
   621|             $row = $rows[$splitCount][0];
   622|             if (!empty($column) && $column[0] !== '$') {
   623|                 $column = ((Coordinate::columnIndexFromString($column) + $numberOfColumns) % AddressRange::MAX_COLUMN_INT) ?: AddressRange::MAX_COLUMN_INT;
   624|                 $column = Coordinate::stringFromColumnIndex($column);
   625|                 $rowOffset -= ($columnLength - strlen($column));
   626|                 $formula = substr($formula, 0, $columnOffset) . $column . substr($formula, $columnOffset + $columnLength);
   627|             }
   628|             if (!empty($row) && $row[0] !== '$') {
   629|                 $row = (((int) $row + $numberOfRows) % AddressRange::MAX_ROW) ?: AddressRange::MAX_ROW;
   630|                 $formula = substr($formula, 0, $rowOffset) . $row . substr($formula, $rowOffset + $rowLength);
   631|             }
   632|         }
   633|         return $formula;
   634|     }
   635|     private function updateColumnRangesAllWorksheets(string $formula, int $numberOfColumns): string
   636|     {
   637|         $splitCount = preg_match_all(
   638|             '/' . Calculation::CALCULATION_REGEXP_COLUMNRANGE_RELATIVE . '/mui',
   639|             $formula,
   640|             $splitRanges,
   641|             PREG_OFFSET_CAPTURE
   642|         );
   643|         $fromColumnLengths = array_map('strlen', array_column($splitRanges[1], 0));
   644|         $fromColumnOffsets = array_column($splitRanges[1], 1);
   645|         $toColumnLengths = array_map('strlen', array_column($splitRanges[2], 0));
   646|         $toColumnOffsets = array_column($splitRanges[2], 1);
   647|         $fromColumns = $splitRanges[1];
   648|         $toColumns = $splitRanges[2];
   649|         while ($splitCount > 0) {
   650|             --$splitCount;
   651|             $fromColumnLength = $fromColumnLengths[$splitCount];
   652|             $toColumnLength = $toColumnLengths[$splitCount];
   653|             $fromColumnOffset = $fromColumnOffsets[$splitCount];
   654|             $toColumnOffset = $toColumnOffsets[$splitCount];
   655|             $fromColumn = $fromColumns[$splitCount][0];
   656|             $toColumn = $toColumns[$splitCount][0];
   657|             if (!empty($fromColumn) && $fromColumn[0] !== '$') {
   658|                 $fromColumn = Coordinate::stringFromColumnIndex(Coordinate::columnIndexFromString($fromColumn) + $numberOfColumns);
   659|                 $formula = substr($formula, 0, $fromColumnOffset) . $fromColumn . substr($formula, $fromColumnOffset + $fromColumnLength);
   660|             }
   661|             if (!empty($toColumn) && $toColumn[0] !== '$') {
   662|                 $toColumn = Coordinate::stringFromColumnIndex(Coordinate::columnIndexFromString($toColumn) + $numberOfColumns);
   663|                 $formula = substr($formula, 0, $toColumnOffset) . $toColumn . substr($formula, $toColumnOffset + $toColumnLength);
   664|             }
   665|         }
   666|         return $formula;
   667|     }
   668|     private function updateRowRangesAllWorksheets(string $formula, int $numberOfRows): string
   669|     {
   670|         $splitCount = preg_match_all(
   671|             '/' . Calculation::CALCULATION_REGEXP_ROWRANGE_RELATIVE . '/mui',
   672|             $formula,
   673|             $splitRanges,
   674|             PREG_OFFSET_CAPTURE
   675|         );
   676|         $fromRowLengths = array_map('strlen', array_column($splitRanges[1], 0));
   677|         $fromRowOffsets = array_column($splitRanges[1], 1);
   678|         $toRowLengths = array_map('strlen', array_column($splitRanges[2], 0));
   679|         $toRowOffsets = array_column($splitRanges[2], 1);
   680|         $fromRows = $splitRanges[1];
   681|         $toRows = $splitRanges[2];
   682|         while ($splitCount > 0) {
   683|             --$splitCount;
   684|             $fromRowLength = $fromRowLengths[$splitCount];
   685|             $toRowLength = $toRowLengths[$splitCount];
   686|             $fromRowOffset = $fromRowOffsets[$splitCount];
   687|             $toRowOffset = $toRowOffsets[$splitCount];
   688|             $fromRow = $fromRows[$splitCount][0];
   689|             $toRow = $toRows[$splitCount][0];
   690|             if (!empty($fromRow) && $fromRow[0] !== '$') {
   691|                 $fromRow = (int) $fromRow + $numberOfRows;
   692|                 $formula = substr($formula, 0, $fromRowOffset) . $fromRow . substr($formula, $fromRowOffset + $fromRowLength);
   693|             }
   694|             if (!empty($toRow) && $toRow[0] !== '$') {
   695|                 $toRow = (int) $toRow + $numberOfRows;
   696|                 $formula = substr($formula, 0, $toRowOffset) . $toRow . substr($formula, $toRowOffset + $toRowLength);
   697|             }
   698|         }
   699|         return $formula;
   700|     }
   701|     /**
   702|      * Update cell reference.
   703|      *
   704|      * @param string $cellReference Cell address or range of addresses
   705|      *
   706|      * @return string Updated cell range
   707|      */
   708|     private function updateCellReference(string $cellReference = 'A1', bool $includeAbsoluteReferences = false, bool $onlyAbsoluteReferences = false): string
   709|     {
   710|         if (str_contains($cellReference, '!')) {
   711|             return $cellReference;
   712|         }
   713|         if (!Coordinate::coordinateIsRange($cellReference)) {
   714|             /** @var CellReferenceHelper */
   715|             $cellReferenceHelper = $this->cellReferenceHelper;
   716|             return $cellReferenceHelper->updateCellReference($cellReference, $includeAbsoluteReferences, $onlyAbsoluteReferences);
   717|         }
   718|         return $this->updateCellRange($cellReference, $includeAbsoluteReferences, $onlyAbsoluteReferences);
   719|     }
   720|     /**
   721|      * Update named formulae (i.e. containing worksheet references / named ranges).
   722|      *
   723|      * @param Spreadsheet $spreadsheet Object to update
   724|      * @param string $oldName Old name (name to replace)
   725|      * @param string $newName New name
   726|      */
   727|     public function updateNamedFormulae(Spreadsheet $spreadsheet, string $oldName = '', string $newName = ''): void
   728|     {
   729|         if ($oldName == '') {
   730|             return;
   731|         }
   732|         foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
   733|             foreach ($sheet->getCoordinates(false) as $coordinate) {
   734|                 $cell = $sheet->getCell($coordinate);
   735|                 if ($cell->getDataType() === DataType::TYPE_FORMULA) {
   736|                     $formula = $cell->getValueString();
   737|                     if (str_contains($formula, $oldName)) {
   738|                         $formula = str_replace("'" . $oldName . "'!", "'" . $newName . "'!", $formula);
   739|                         $formula = str_replace($oldName . '!', $newName . '!', $formula);
   740|                         $cell->setValueExplicit($formula, DataType::TYPE_FORMULA);
   741|                     }
   742|                 }
   743|             }
   744|         }
   745|     }
   746|     private function updateDefinedNames(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
   747|     {
   748|         foreach ($worksheet->getParentOrThrow()->getDefinedNames() as $definedName) {
   749|             if ($definedName->isFormula() === false) {
   750|                 $this->updateNamedRange($definedName, $worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
   751|             } else {
   752|                 $this->updateNamedFormula($definedName, $worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
   753|             }
   754|         }
   755|     }
   756|     private function updateNamedRange(DefinedName $definedName, Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
   757|     {
   758|         $cellAddress = $definedName->getValue();
   759|         $asFormula = ($cellAddress[0] === '=');
   760|         if ($definedName->getWorksheet() !== null && $definedName->getWorksheet()->getHashCode() === $worksheet->getHashCode()) {
   761|             /**
   762|              * If we delete the entire range that is referenced by a Named Range, MS Excel sets the value to #REF!
   763|              * PhpSpreadsheet still only does a basic adjustment, so the Named Range will still reference Cells.
   764|              * Note that this applies only when deleting columns/rows; subsequent insertion won't fix the #REF!
   765|              * TODO Can we work out a method to identify Named Ranges that cease to be valid, so that we can replace
   766|              *      them with a #REF!
   767|              */
   768|             if ($asFormula === true) {
   769|                 $formula = $this->updateFormulaReferences($cellAddress, $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true, true);
   770|                 $definedName->setValue($formula);
   771|             } else {
   772|                 $definedName->setValue($this->updateCellReference(ltrim($cellAddress, '='), true));
   773|             }
   774|         }
   775|     }
   776|     private function updateNamedFormula(DefinedName $definedName, Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
   777|     {
   778|         if ($definedName->getWorksheet() !== null && $definedName->getWorksheet()->getHashCode() === $worksheet->getHashCode()) {
   779|             /**
   780|              * If we delete the entire range that is referenced by a Named Formula, MS Excel sets the value to #REF!
   781|              * PhpSpreadsheet still only does a basic adjustment, so the Named Formula will still reference Cells.
   782|              * Note that this applies only when deleting columns/rows; subsequent insertion won't fix the #REF!
   783|              * TODO Can we work out a method to identify Named Ranges that cease to be valid, so that we can replace
   784|              *      them with a #REF!
   785|              */
   786|             $formula = $definedName->getValue();
   787|             $formula = $this->updateFormulaReferences($formula, $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true);
   788|             $definedName->setValue($formula);
   789|         }
   790|     }
   791|     /**
   792|      * Update cell range.
   793|      *
   794|      * @param string $cellRange Cell range    (e.g. 'B2:D4', 'B:C' or '2:3')
   795|      *
   796|      * @return string Updated cell range
   797|      */
   798|     private function updateCellRange(string $cellRange = 'A1:A1', bool $includeAbsoluteReferences = false, bool $onlyAbsoluteReferences = false): string
   799|     {
   800|         if (!Coordinate::coordinateIsRange($cellRange)) {
   801|             throw new Exception('Only cell ranges may be passed to this method.');
   802|         }
   803|         $range = Coordinate::splitRange($cellRange);
   804|         $ic = count($range);
   805|         for ($i = 0; $i < $ic; ++$i) {
   806|             $jc = count($range[$i]);
   807|             for ($j = 0; $j < $jc; ++$j) {
   808|                 /** @var CellReferenceHelper */
   809|                 $cellReferenceHelper = $this->cellReferenceHelper;
   810|                 if (ctype_alpha($range[$i][$j])) {
   811|                     $range[$i][$j] = Coordinate::coordinateFromString(
   812|                         $cellReferenceHelper->updateCellReference($range[$i][$j] . '1', $includeAbsoluteReferences, $onlyAbsoluteReferences)
   813|                     )[0];
   814|                 } elseif (ctype_digit($range[$i][$j])) {
   815|                     $range[$i][$j] = Coordinate::coordinateFromString(
   816|                         $cellReferenceHelper->updateCellReference('A' . $range[$i][$j], $includeAbsoluteReferences, $onlyAbsoluteReferences)
   817|                     )[1];
   818|                 } else {
   819|                     $range[$i][$j] = $cellReferenceHelper->updateCellReference($range[$i][$j], $includeAbsoluteReferences, $onlyAbsoluteReferences);
   820|                 }
   821|             }
   822|         }
   823|         return Coordinate::buildRange($range);
   824|     }
   825|     private function clearColumnStrips(int $highestRow, int $beforeColumn, int $numberOfColumns, Worksheet $worksheet): void
   826|     {
   827|         $startColumnId = Coordinate::stringFromColumnIndex($beforeColumn + $numberOfColumns);
   828|         $endColumnId = Coordinate::stringFromColumnIndex($beforeColumn);
   829|         for ($row = 1; $row <= $highestRow - 1; ++$row) {
   830|             for ($column = $startColumnId; $column !== $endColumnId; ++$column) {
   831|                 $coordinate = $column . $row;
   832|                 $this->clearStripCell($worksheet, $coordinate);
   833|             }
   834|         }
   835|     }
   836|     private function clearRowStrips(string $highestColumn, int $beforeColumn, int $beforeRow, int $numberOfRows, Worksheet $worksheet): void
   837|     {
   838|         $startColumnId = Coordinate::stringFromColumnIndex($beforeColumn);
   839|         ++$highestColumn;
   840|         for ($column = $startColumnId; $column !== $highestColumn; ++$column) {
   841|             for ($row = $beforeRow + $numberOfRows; $row <= $beforeRow - 1; ++$row) {
   842|                 $coordinate = $column . $row;
   843|                 $this->clearStripCell($worksheet, $coordinate);
   844|             }
   845|         }
   846|     }
   847|     private function clearStripCell(Worksheet $worksheet, string $coordinate): void
   848|     {
   849|         $worksheet->removeConditionalStyles($coordinate);
   850|         $worksheet->setHyperlink($coordinate);
   851|         $worksheet->setDataValidation($coordinate);
   852|         $worksheet->removeComment($coordinate);
   853|         if ($worksheet->cellExists($coordinate)) {
   854|             $worksheet->getCell($coordinate)->setValueExplicit(null, DataType::TYPE_NULL);
   855|             $worksheet->getCell($coordinate)->setXfIndex(0);
   856|         }
   857|     }
   858|     private function adjustAutoFilter(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns): void
   859|     {
   860|         $autoFilter = $worksheet->getAutoFilter();
   861|         $autoFilterRange = $autoFilter->getRange();
   862|         if (!empty($autoFilterRange)) {
   863|             if ($numberOfColumns !== 0) {
   864|                 $autoFilterColumns = $autoFilter->getColumns();
   865|                 if (count($autoFilterColumns) > 0) {
   866|                     $column = '';
   867|                     $row = 0;
   868|                     sscanf($beforeCellAddress, '%[A-Z]%d', $column, $row);
   869|                     $columnIndex = Coordinate::columnIndexFromString((string) $column);
   870|                     [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($autoFilterRange);
   871|                     if ($columnIndex <= $rangeEnd[0]) {
   872|                         if ($numberOfColumns < 0) {
   873|                             $this->adjustAutoFilterDeleteRules($columnIndex, $numberOfColumns, $autoFilterColumns, $autoFilter);
   874|                         }
   875|                         $startCol = ($columnIndex > $rangeStart[0]) ? $columnIndex : $rangeStart[0];
   876|                         if ($numberOfColumns > 0) {
   877|                             $this->adjustAutoFilterInsert($startCol, $numberOfColumns, $rangeEnd[0], $autoFilter);
   878|                         } else {
   879|                             $this->adjustAutoFilterDelete($startCol, $numberOfColumns, $rangeEnd[0], $autoFilter);
   880|                         }
   881|                     }
   882|                 }
   883|             }
   884|             $worksheet->setAutoFilter(
   885|                 $this->updateCellReference($autoFilterRange)
   886|             );
   887|         }
   888|     }
   889|     private function adjustAutoFilterDeleteRules(int $columnIndex, int $numberOfColumns, array $autoFilterColumns, AutoFilter $autoFilter): void
   890|     {
   891|         $deleteColumn = $columnIndex + $numberOfColumns - 1;
   892|         $deleteCount = abs($numberOfColumns);
   893|         for ($i = 1; $i <= $deleteCount; ++$i) {
   894|             $columnName = Coordinate::stringFromColumnIndex($deleteColumn + 1);
   895|             if (isset($autoFilterColumns[$columnName])) {
   896|                 $autoFilter->clearColumn($columnName);
   897|             }
   898|             ++$deleteColumn;
   899|         }
   900|     }
   901|     private function adjustAutoFilterInsert(int $startCol, int $numberOfColumns, int $rangeEnd, AutoFilter $autoFilter): void
   902|     {
   903|         $startColRef = $startCol;
   904|         $endColRef = $rangeEnd;
   905|         $toColRef = $rangeEnd + $numberOfColumns;
   906|         do {
   907|             $autoFilter->shiftColumn(Coordinate::stringFromColumnIndex($endColRef), Coordinate::stringFromColumnIndex($toColRef));
   908|             --$endColRef;
   909|             --$toColRef;
   910|         } while ($startColRef <= $endColRef);
   911|     }
   912|     private function adjustAutoFilterDelete(int $startCol, int $numberOfColumns, int $rangeEnd, AutoFilter $autoFilter): void
   913|     {
   914|         $startColID = Coordinate::stringFromColumnIndex($startCol);
   915|         $toColID = Coordinate::stringFromColumnIndex($startCol + $numberOfColumns);
   916|         $endColID = Coordinate::stringFromColumnIndex($rangeEnd + 1);
   917|         do {
   918|             $autoFilter->shiftColumn($startColID, $toColID);
   919|             ++$startColID;
   920|             ++$toColID;
   921|         } while ($startColID !== $endColID);
   922|     }
   923|     private function adjustTable(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns): void
   924|     {
   925|         $tableCollection = $worksheet->getTableCollection();
   926|         foreach ($tableCollection as $table) {
   927|             $tableRange = $table->getRange();
   928|             if (!empty($tableRange)) {
   929|                 if ($numberOfColumns !== 0) {
   930|                     $tableColumns = $table->getColumns();
   931|                     if (count($tableColumns) > 0) {
   932|                         $column = '';
   933|                         $row = 0;
   934|                         sscanf($beforeCellAddress, '%[A-Z]%d', $column, $row);
   935|                         $columnIndex = Coordinate::columnIndexFromString((string) $column);
   936|                         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($tableRange);
   937|                         if ($columnIndex <= $rangeEnd[0]) {
   938|                             if ($numberOfColumns < 0) {
   939|                                 $this->adjustTableDeleteRules($columnIndex, $numberOfColumns, $tableColumns, $table);
   940|                             }
   941|                             $startCol = ($columnIndex > $rangeStart[0]) ? $columnIndex : $rangeStart[0];
   942|                             if ($numberOfColumns > 0) {
   943|                                 $this->adjustTableInsert($startCol, $numberOfColumns, $rangeEnd[0], $table);
   944|                             } else {
   945|                                 $this->adjustTableDelete($startCol, $numberOfColumns, $rangeEnd[0], $table);
   946|                             }
   947|                         }
   948|                     }
   949|                 }
   950|                 $table->setRange($this->updateCellReference($tableRange));
   951|             }
   952|         }
   953|     }
   954|     private function adjustTableDeleteRules(int $columnIndex, int $numberOfColumns, array $tableColumns, Table $table): void
   955|     {
   956|         $deleteColumn = $columnIndex + $numberOfColumns - 1;
   957|         $deleteCount = abs($numberOfColumns);
   958|         for ($i = 1; $i <= $deleteCount; ++$i) {
   959|             $columnName = Coordinate::stringFromColumnIndex($deleteColumn + 1);
   960|             if (isset($tableColumns[$columnName])) {
   961|                 $table->clearColumn($columnName);
   962|             }
   963|             ++$deleteColumn;
   964|         }
   965|     }
   966|     private function adjustTableInsert(int $startCol, int $numberOfColumns, int $rangeEnd, Table $table): void
   967|     {
   968|         $startColRef = $startCol;
   969|         $endColRef = $rangeEnd;
   970|         $toColRef = $rangeEnd + $numberOfColumns;
   971|         do {
   972|             $table->shiftColumn(Coordinate::stringFromColumnIndex($endColRef), Coordinate::stringFromColumnIndex($toColRef));
   973|             --$endColRef;
   974|             --$toColRef;
   975|         } while ($startColRef <= $endColRef);
   976|     }
   977|     private function adjustTableDelete(int $startCol, int $numberOfColumns, int $rangeEnd, Table $table): void
   978|     {
   979|         $startColID = Coordinate::stringFromColumnIndex($startCol);
   980|         $toColID = Coordinate::stringFromColumnIndex($startCol + $numberOfColumns);
   981|         $endColID = Coordinate::stringFromColumnIndex($rangeEnd + 1);
   982|         do {
   983|             $table->shiftColumn($startColID, $toColID);
   984|             ++$startColID;
   985|             ++$toColID;
   986|         } while ($startColID !== $endColID);
   987|     }
   988|     private function duplicateStylesByColumn(Worksheet $worksheet, int $beforeColumn, int $beforeRow, int $highestRow, int $numberOfColumns): void
   989|     {
   990|         $beforeColumnName = Coordinate::stringFromColumnIndex($beforeColumn - 1);
   991|         for ($i = $beforeRow; $i <= $highestRow - 1; ++$i) {
   992|             $coordinate = $beforeColumnName . $i;
   993|             if ($worksheet->cellExists($coordinate)) {
   994|                 $xfIndex = $worksheet->getCell($coordinate)->getXfIndex();
   995|                 for ($j = $beforeColumn; $j <= $beforeColumn - 1 + $numberOfColumns; ++$j) {
   996|                     if (!empty($xfIndex) || $worksheet->cellExists([$j, $i])) {
   997|                         $worksheet->getCell([$j, $i])->setXfIndex($xfIndex);
   998|                     }
   999|                 }
  1000|             }
  1001|         }
  1002|     }
  1003|     private function duplicateStylesByRow(Worksheet $worksheet, int $beforeColumn, int $beforeRow, string $highestColumn, int $numberOfRows): void
  1004|     {
  1005|         $highestColumnIndex = Coordinate::columnIndexFromString($highestColumn);
  1006|         for ($i = $beforeColumn; $i <= $highestColumnIndex; ++$i) {
  1007|             $coordinate = Coordinate::stringFromColumnIndex($i) . ($beforeRow - 1);
  1008|             if ($worksheet->cellExists($coordinate)) {
  1009|                 $xfIndex = $worksheet->getCell($coordinate)->getXfIndex();
  1010|                 for ($j = $beforeRow; $j <= $beforeRow - 1 + $numberOfRows; ++$j) {
  1011|                     if (!empty($xfIndex) || $worksheet->cellExists([$j, $i])) {
  1012|                         $worksheet->getCell(Coordinate::stringFromColumnIndex($i) . $j)->setXfIndex($xfIndex);
  1013|                     }
  1014|                 }
  1015|             }
  1016|         }
  1017|     }
  1018|     /**
  1019|      * __clone implementation. Cloning should not be allowed in a Singleton!
  1020|      */
  1021|     final public function __clone()
  1022|     {
  1023|         throw new Exception('Cloning a Singleton is not allowed!');
  1024|     }
  1025| }


# ====================================================================
# FILE: src/PhpSpreadsheet/RichText/RichText.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-136 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\RichText;
     3| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     4| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     5| use PhpOffice\PhpSpreadsheet\IComparable;
     6| use Stringable;
     7| class RichText implements IComparable, Stringable
     8| {
     9|     /**
    10|      * Rich text elements.
    11|      *
    12|      * @var ITextElement[]
    13|      */
    14|     private array $richTextElements;
    15|     /**
    16|      * Create a new RichText instance.
    17|      */
    18|     public function __construct(?Cell $cell = null)
    19|     {
    20|         $this->richTextElements = [];
    21|         if ($cell !== null) {
    22|             if ($cell->getValueString() !== '') {
    23|                 $objRun = new Run($cell->getValueString());
    24|                 $objRun->setFont(clone $cell->getWorksheet()->getStyle($cell->getCoordinate())->getFont());
    25|                 $this->addText($objRun);
    26|             }
    27|             $cell->setValueExplicit($this, DataType::TYPE_STRING);
    28|         }
    29|     }
    30|     /**
    31|      * Add text.
    32|      *
    33|      * @param ITextElement $text Rich text element
    34|      *
    35|      * @return $this
    36|      */
    37|     public function addText(ITextElement $text): static
    38|     {
    39|         $this->richTextElements[] = $text;
    40|         return $this;
    41|     }
    42|     /**
    43|      * Create text.
    44|      *
    45|      * @param string $text Text
    46|      */
    47|     public function createText(string $text): TextElement
    48|     {
    49|         $objText = new TextElement($text);
    50|         $this->addText($objText);
    51|         return $objText;
    52|     }
    53|     /**
    54|      * Create text run.
    55|      *
    56|      * @param string $text Text
    57|      */
    58|     public function createTextRun(string $text): Run
    59|     {
    60|         $objText = new Run($text);
    61|         $this->addText($objText);
    62|         return $objText;
    63|     }
    64|     /**
    65|      * Get plain text.
    66|      */
    67|     public function getPlainText(): string
    68|     {
    69|         $returnValue = '';
    70|         foreach ($this->richTextElements as $text) {
    71|             $returnValue .= $text->getText();
    72|         }
    73|         return $returnValue;
    74|     }
    75|     /**
    76|      * Convert to string.
    77|      */
    78|     public function __toString(): string
    79|     {
    80|         return $this->getPlainText();
    81|     }
    82|     /**
    83|      * Get Rich Text elements.
    84|      *
    85|      * @return ITextElement[]
    86|      */
    87|     public function getRichTextElements(): array
    88|     {
    89|         return $this->richTextElements;
    90|     }
    91|     /**
    92|      * Set Rich Text elements.
    93|      *
    94|      * @param ITextElement[] $textElements Array of elements
    95|      *
    96|      * @return $this
    97|      */
    98|     public function setRichTextElements(array $textElements): static
    99|     {
   100|         $this->richTextElements = $textElements;
   101|         return $this;
   102|     }
   103|     /**
   104|      * Get hash code.
   105|      *
   106|      * @return string Hash code
   107|      */
   108|     public function getHashCode(): string
   109|     {
   110|         $hashElements = '';
   111|         foreach ($this->richTextElements as $element) {
   112|             $hashElements .= $element->getHashCode();
   113|         }
   114|         return md5(
   115|             $hashElements
   116|             . __CLASS__
   117|         );
   118|     }
   119|     /**
   120|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   121|      */
   122|     public function __clone()
   123|     {
   124|         $vars = get_object_vars($this);
   125|         foreach ($vars as $key => $value) {
   126|             $newValue = is_object($value) ? (clone $value) : $value;
   127|             if (is_array($value)) {
   128|                 $newValue = [];
   129|                 foreach ($value as $key2 => $value2) {
   130|                     $newValue[$key2] = is_object($value2) ? (clone $value2) : $value2;
   131|                 }
   132|             }
   133|             $this->$key = $newValue;
   134|         }
   135|     }
   136| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Shared/Date.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-460 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Shared;
     3| use DateTime;
     4| use DateTimeInterface;
     5| use DateTimeZone;
     6| use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     8| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     9| use PhpOffice\PhpSpreadsheet\Exception;
    10| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
    11| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    12| class Date
    13| {
    14|     /** constants */
    15|     const CALENDAR_WINDOWS_1900 = 1900; //    Base date of 1st Jan 1900 = 1.0
    16|     const CALENDAR_MAC_1904 = 1904; //    Base date of 2nd Jan 1904 = 1.0
    17|     /**
    18|      * Names of the months of the year, indexed by shortname
    19|      * Planned usage for locale settings.
    20|      *
    21|      * @var string[]
    22|      */
    23|     public static array $monthNames = [
    24|         'Jan' => 'January',
    25|         'Feb' => 'February',
    26|         'Mar' => 'March',
    27|         'Apr' => 'April',
    28|         'May' => 'May',
    29|         'Jun' => 'June',
    30|         'Jul' => 'July',
    31|         'Aug' => 'August',
    32|         'Sep' => 'September',
    33|         'Oct' => 'October',
    34|         'Nov' => 'November',
    35|         'Dec' => 'December',
    36|     ];
    37|     /**
    38|      * @var string[]
    39|      */
    40|     public static array $numberSuffixes = [
    41|         'st',
    42|         'nd',
    43|         'rd',
    44|         'th',
    45|     ];
    46|     /**
    47|      * Base calendar year to use for calculations
    48|      * Value is either CALENDAR_WINDOWS_1900 (1900) or CALENDAR_MAC_1904 (1904).
    49|      */
    50|     protected static int $excelCalendar = self::CALENDAR_WINDOWS_1900;
    51|     /**
    52|      * Default timezone to use for DateTime objects.
    53|      */
    54|     protected static ?DateTimeZone $defaultTimeZone = null;
    55|     /**
    56|      * Set the Excel calendar (Windows 1900 or Mac 1904).
    57|      *
    58|      * @param ?int $baseYear Excel base date (1900 or 1904)
    59|      *
    60|      * @return bool Success or failure
    61|      */
    62|     public static function setExcelCalendar(?int $baseYear): bool
    63|     {
    64|         if (
    65|             ($baseYear === self::CALENDAR_WINDOWS_1900)
    66|             || ($baseYear === self::CALENDAR_MAC_1904)
    67|         ) {
    68|             self::$excelCalendar = $baseYear;
    69|             return true;
    70|         }
    71|         return false;
    72|     }
    73|     /**
    74|      * Return the Excel calendar (Windows 1900 or Mac 1904).
    75|      *
    76|      * @return int Excel base date (1900 or 1904)
    77|      */
    78|     public static function getExcelCalendar(): int
    79|     {
    80|         return self::$excelCalendar;
    81|     }
    82|     /**
    83|      * Set the Default timezone to use for dates.
    84|      *
    85|      * @param null|DateTimeZone|string $timeZone The timezone to set for all Excel datetimestamp to PHP DateTime Object conversions
    86|      *
    87|      * @return bool Success or failure
    88|      */
    89|     public static function setDefaultTimezone($timeZone): bool
    90|     {
    91|         try {
    92|             $timeZone = self::validateTimeZone($timeZone);
    93|             self::$defaultTimeZone = $timeZone;
    94|             $retval = true;
    95|         } catch (PhpSpreadsheetException) {
    96|             $retval = false;
    97|         }
    98|         return $retval;
    99|     }
   100|     /**
   101|      * Return the Default timezone, or UTC if default not set.
   102|      */
   103|     public static function getDefaultTimezone(): DateTimeZone
   104|     {
   105|         return self::$defaultTimeZone ?? new DateTimeZone('UTC');
   106|     }
   107|     /**
   108|      * Return the Default timezone, or local timezone if default is not set.
   109|      */
   110|     public static function getDefaultOrLocalTimezone(): DateTimeZone
   111|     {
   112|         return self::$defaultTimeZone ?? new DateTimeZone(date_default_timezone_get());
   113|     }
   114|     /**
   115|      * Return the Default timezone even if null.
   116|      */
   117|     public static function getDefaultTimezoneOrNull(): ?DateTimeZone
   118|     {
   119|         return self::$defaultTimeZone;
   120|     }
   121|     /**
   122|      * Validate a timezone.
   123|      *
   124|      * @param null|DateTimeZone|string $timeZone The timezone to validate, either as a timezone string or object
   125|      *
   126|      * @return ?DateTimeZone The timezone as a timezone object
   127|      */
   128|     private static function validateTimeZone($timeZone): ?DateTimeZone
   129|     {
   130|         if ($timeZone instanceof DateTimeZone || $timeZone === null) {
   131|             return $timeZone;
   132|         }
   133|         if (in_array($timeZone, DateTimeZone::listIdentifiers(DateTimeZone::ALL_WITH_BC))) {
   134|             return new DateTimeZone($timeZone);
   135|         }
   136|         throw new PhpSpreadsheetException('Invalid timezone');
   137|     }
   138|     /**
   139|      * @param mixed $value Converts a date/time in ISO-8601 standard format date string to an Excel
   140|      *                         serialized timestamp.
   141|      *                     See https://en.wikipedia.org/wiki/ISO_8601 for details of the ISO-8601 standard format.
   142|      */
   143|     public static function convertIsoDate(mixed $value): float|int
   144|     {
   145|         if (!is_string($value)) {
   146|             throw new Exception('Non-string value supplied for Iso Date conversion');
   147|         }
   148|         $date = new DateTime($value);
   149|         $dateErrors = DateTime::getLastErrors();
   150|         if (is_array($dateErrors) && ($dateErrors['warning_count'] > 0 || $dateErrors['error_count'] > 0)) {
   151|             throw new Exception("Invalid string $value supplied for datatype Date");
   152|         }
   153|         $newValue = self::PHPToExcel($date);
   154|         if ($newValue === false) {
   155|             throw new Exception("Invalid string $value supplied for datatype Date");
   156|         }
   157|         if (preg_match('/^\\s*\\d?\\d:\\d\\d(:\\d\\d([.]\\d+)?)?\\s*(am|pm)?\\s*$/i', $value) == 1) {
   158|             $newValue = fmod($newValue, 1.0);
   159|         }
   160|         return $newValue;
   161|     }
   162|     /**
   163|      * Convert a MS serialized datetime value from Excel to a PHP Date/Time object.
   164|      *
   165|      * @param float|int $excelTimestamp MS Excel serialized date/time value
   166|      * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
   167|      *                                           if you don't want to treat it as a UTC value
   168|      *                                           Use the default (UTC) unless you absolutely need a conversion
   169|      *
   170|      * @return DateTime PHP date/time object
   171|      */
   172|     public static function excelToDateTimeObject(float|int $excelTimestamp, null|DateTimeZone|string $timeZone = null): DateTime
   173|     {
   174|         $timeZone = ($timeZone === null) ? self::getDefaultTimezone() : self::validateTimeZone($timeZone);
   175|         if (Functions::getCompatibilityMode() == Functions::COMPATIBILITY_EXCEL) {
   176|             if ($excelTimestamp < 1 && self::$excelCalendar === self::CALENDAR_WINDOWS_1900) {
   177|                 $baseDate = new DateTime('1970-01-01', $timeZone);
   178|             } else {
   179|                 if (self::$excelCalendar == self::CALENDAR_WINDOWS_1900) {
   180|                     $baseDate = ($excelTimestamp < 60) ? new DateTime('1899-12-31', $timeZone) : new DateTime('1899-12-30', $timeZone);
   181|                 } else {
   182|                     $baseDate = new DateTime('1904-01-01', $timeZone);
   183|                 }
   184|             }
   185|         } else {
   186|             $baseDate = new DateTime('1899-12-30', $timeZone);
   187|         }
   188|         $days = floor($excelTimestamp);
   189|         $partDay = $excelTimestamp - $days;
   190|         $hms = 86400 * $partDay;
   191|         $microseconds = (int) round(fmod($hms, 1) * 1000000);
   192|         $hms = (int) floor($hms);
   193|         $hours = intdiv($hms, 3600);
   194|         $hms -= $hours * 3600;
   195|         $minutes = intdiv($hms, 60);
   196|         $seconds = $hms % 60;
   197|         if ($days >= 0) {
   198|             $days = '+' . $days;
   199|         }
   200|         $interval = $days . ' days';
   201|         return $baseDate->modify($interval)
   202|             ->setTime($hours, $minutes, $seconds, $microseconds);
   203|     }
   204|     /**
   205|      * Convert a MS serialized datetime value from Excel to a unix timestamp.
   206|      * The use of Unix timestamps, and therefore this function, is discouraged.
   207|      * They are not Y2038-safe on a 32-bit system, and have no timezone info.
   208|      *
   209|      * @param float|int $excelTimestamp MS Excel serialized date/time value
   210|      * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
   211|      *                                               if you don't want to treat it as a UTC value
   212|      *                                               Use the default (UTC) unless you absolutely need a conversion
   213|      *
   214|      * @return int Unix timetamp for this date/time
   215|      */
   216|     public static function excelToTimestamp($excelTimestamp, $timeZone = null): int
   217|     {
   218|         $dto = self::excelToDateTimeObject($excelTimestamp, $timeZone);
   219|         self::roundMicroseconds($dto);
   220|         return (int) $dto->format('U');
   221|     }
   222|     /**
   223|      * Convert a date from PHP to an MS Excel serialized date/time value.
   224|      *
   225|      * @param mixed $dateValue PHP DateTime object or a string - Unix timestamp is also permitted, but discouraged;
   226|      *    not Y2038-safe on a 32-bit system, and no timezone info
   227|      *
   228|      * @return false|float Excel date/time value
   229|      *                                  or boolean FALSE on failure
   230|      */
   231|     public static function PHPToExcel(mixed $dateValue)
   232|     {
   233|         if ((is_object($dateValue)) && ($dateValue instanceof DateTimeInterface)) {
   234|             return self::dateTimeToExcel($dateValue);
   235|         } elseif (is_numeric($dateValue)) {
   236|             return self::timestampToExcel($dateValue);
   237|         } elseif (is_string($dateValue)) {
   238|             return self::stringToExcel($dateValue);
   239|         }
   240|         return false;
   241|     }
   242|     /**
   243|      * Convert a PHP DateTime object to an MS Excel serialized date/time value.
   244|      *
   245|      * @param DateTimeInterface $dateValue PHP DateTime object
   246|      *
   247|      * @return float MS Excel serialized date/time value
   248|      */
   249|     public static function dateTimeToExcel(DateTimeInterface $dateValue): float
   250|     {
   251|         $seconds = (float) sprintf('%d.%06d', $dateValue->format('s'), $dateValue->format('u'));
   252|         return self::formattedPHPToExcel(
   253|             (int) $dateValue->format('Y'),
   254|             (int) $dateValue->format('m'),
   255|             (int) $dateValue->format('d'),
   256|             (int) $dateValue->format('H'),
   257|             (int) $dateValue->format('i'),
   258|             $seconds
   259|         );
   260|     }
   261|     /**
   262|      * Convert a Unix timestamp to an MS Excel serialized date/time value.
   263|      * The use of Unix timestamps, and therefore this function, is discouraged.
   264|      * They are not Y2038-safe on a 32-bit system, and have no timezone info.
   265|      *
   266|      * @param float|int|string $unixTimestamp Unix Timestamp
   267|      *
   268|      * @return false|float MS Excel serialized date/time value
   269|      */
   270|     public static function timestampToExcel($unixTimestamp): bool|float
   271|     {
   272|         if (!is_numeric($unixTimestamp)) {
   273|             return false;
   274|         }
   275|         return self::dateTimeToExcel(new DateTime('@' . $unixTimestamp));
   276|     }
   277|     /**
   278|      * formattedPHPToExcel.
   279|      *
   280|      * @return float Excel date/time value
   281|      */
   282|     public static function formattedPHPToExcel(int $year, int $month, int $day, int $hours = 0, int $minutes = 0, float|int $seconds = 0): float
   283|     {
   284|         if (self::$excelCalendar == self::CALENDAR_WINDOWS_1900) {
   285|             $excel1900isLeapYear = true;
   286|             if (($year == 1900) && ($month <= 2)) {
   287|                 $excel1900isLeapYear = false;
   288|             }
   289|             $myexcelBaseDate = 2415020;
   290|         } else {
   291|             $myexcelBaseDate = 2416481;
   292|             $excel1900isLeapYear = false;
   293|         }
   294|         if ($month > 2) {
   295|             $month -= 3;
   296|         } else {
   297|             $month += 9;
   298|             --$year;
   299|         }
   300|         $century = (int) substr((string) $year, 0, 2);
   301|         $decade = (int) substr((string) $year, 2, 2);
   302|         $excelDate = floor((146097 * $century) / 4) + floor((1461 * $decade) / 4) + floor((153 * $month + 2) / 5) + $day + 1721119 - $myexcelBaseDate + $excel1900isLeapYear;
   303|         $excelTime = (($hours * 3600) + ($minutes * 60) + $seconds) / 86400;
   304|         return (float) $excelDate + $excelTime;
   305|     }
   306|     /**
   307|      * Is a given cell a date/time?
   308|      */
   309|     public static function isDateTime(Cell $cell, mixed $value = null, bool $dateWithoutTimeOkay = true): bool
   310|     {
   311|         $result = false;
   312|         $worksheet = $cell->getWorksheetOrNull();
   313|         $spreadsheet = ($worksheet === null) ? null : $worksheet->getParent();
   314|         if ($worksheet !== null && $spreadsheet !== null) {
   315|             $index = $spreadsheet->getActiveSheetIndex();
   316|             $selected = $worksheet->getSelectedCells();
   317|             try {
   318|                 $result = is_numeric($value ?? $cell->getCalculatedValue())
   319|                     && self::isDateTimeFormat(
   320|                         $worksheet->getStyle(
   321|                             $cell->getCoordinate()
   322|                         )->getNumberFormat(),
   323|                         $dateWithoutTimeOkay
   324|                     );
   325|             } catch (Exception) {
   326|             }
   327|             $worksheet->setSelectedCells($selected);
   328|             $spreadsheet->setActiveSheetIndex($index);
   329|         }
   330|         return $result;
   331|     }
   332|     /**
   333|      * Is a given NumberFormat code a date/time format code?
   334|      */
   335|     public static function isDateTimeFormat(NumberFormat $excelFormatCode, bool $dateWithoutTimeOkay = true): bool
   336|     {
   337|         return self::isDateTimeFormatCode((string) $excelFormatCode->getFormatCode(), $dateWithoutTimeOkay);
   338|     }
   339|     private const POSSIBLE_DATETIME_FORMAT_CHARACTERS = 'eymdHs';
   340|     private const POSSIBLE_TIME_FORMAT_CHARACTERS = 'Hs'; // note - no 'm' due to ambiguity
   341|     /**
   342|      * Is a given number format code a date/time?
   343|      */
   344|     public static function isDateTimeFormatCode(string $excelFormatCode, bool $dateWithoutTimeOkay = true): bool
   345|     {
   346|         if (strtolower($excelFormatCode) === strtolower(NumberFormat::FORMAT_GENERAL)) {
   347|             return false;
   348|         }
   349|         if (preg_match('/[0#]E[+-]0/i', $excelFormatCode)) {
   350|             return false;
   351|         }
   352|         $excelFormatCode = (string) NumberFormat::convertSystemFormats($excelFormatCode);
   353|         if (in_array($excelFormatCode, NumberFormat::DATE_TIME_OR_DATETIME_ARRAY, true)) {
   354|             return $dateWithoutTimeOkay || in_array($excelFormatCode, NumberFormat::TIME_OR_DATETIME_ARRAY);
   355|         }
   356|         if ((str_starts_with($excelFormatCode, '_')) || (str_starts_with($excelFormatCode, '0 '))) {
   357|             return false;
   358|         }
   359|         if (str_contains($excelFormatCode, '-00000')) {
   360|             return false;
   361|         }
   362|         $possibleFormatCharacters = $dateWithoutTimeOkay ? self::POSSIBLE_DATETIME_FORMAT_CHARACTERS : self::POSSIBLE_TIME_FORMAT_CHARACTERS;
   363|         if (preg_match('/(^|\])[^\[]*[' . $possibleFormatCharacters . ']/i', $excelFormatCode)) {
   364|             if (str_contains($excelFormatCode, '"')) {
   365|                 $segMatcher = false;
   366|                 foreach (explode('"', $excelFormatCode) as $subVal) {
   367|                     $segMatcher = $segMatcher === false;
   368|                     if (
   369|                         $segMatcher
   370|                         && (preg_match('/(^|\])[^\[]*[' . $possibleFormatCharacters . ']/i', $subVal))
   371|                     ) {
   372|                         return true;
   373|                     }
   374|                 }
   375|                 return false;
   376|             }
   377|             return true;
   378|         }
   379|         return false;
   380|     }
   381|     /**
   382|      * Convert a date/time string to Excel time.
   383|      *
   384|      * @param string $dateValue Examples: '2009-12-31', '2009-12-31 15:59', '2009-12-31 15:59:10'
   385|      *
   386|      * @return false|float Excel date/time serial value
   387|      */
   388|     public static function stringToExcel(string $dateValue): bool|float
   389|     {
   390|         if (strlen($dateValue) < 2) {
   391|             return false;
   392|         }
   393|         if (!preg_match('/^(\d{1,4}[ \.\/\-][A-Z]{3,9}([ \.\/\-]\d{1,4})?|[A-Z]{3,9}[ \.\/\-]\d{1,4}([ \.\/\-]\d{1,4})?|\d{1,4}[ \.\/\-]\d{1,4}([ \.\/\-]\d{1,4})?)( \d{1,2}:\d{1,2}(:\d{1,2})?)?$/iu', $dateValue)) {
   394|             return false;
   395|         }
   396|         $dateValueNew = DateTimeExcel\DateValue::fromString($dateValue);
   397|         if (!is_float($dateValueNew)) {
   398|             return false;
   399|         }
   400|         if (str_contains($dateValue, ':')) {
   401|             $timeValue = DateTimeExcel\TimeValue::fromString($dateValue);
   402|             if (!is_float($timeValue)) {
   403|                 return false;
   404|             }
   405|             $dateValueNew += $timeValue;
   406|         }
   407|         return $dateValueNew;
   408|     }
   409|     /**
   410|      * Converts a month name (either a long or a short name) to a month number.
   411|      *
   412|      * @param string $monthName Month name or abbreviation
   413|      *
   414|      * @return int|string Month number (1 - 12), or the original string argument if it isn't a valid month name
   415|      */
   416|     public static function monthStringToNumber(string $monthName)
   417|     {
   418|         $monthIndex = 1;
   419|         foreach (self::$monthNames as $shortMonthName => $longMonthName) {
   420|             if (($monthName === $longMonthName) || ($monthName === $shortMonthName)) {
   421|                 return $monthIndex;
   422|             }
   423|             ++$monthIndex;
   424|         }
   425|         return $monthName;
   426|     }
   427|     /**
   428|      * Strips an ordinal from a numeric value.
   429|      *
   430|      * @param string $day Day number with an ordinal
   431|      *
   432|      * @return int|string The integer value with any ordinal stripped, or the original string argument if it isn't a valid numeric
   433|      */
   434|     public static function dayStringToNumber(string $day)
   435|     {
   436|         $strippedDayValue = (str_replace(self::$numberSuffixes, '', $day));
   437|         if (is_numeric($strippedDayValue)) {
   438|             return (int) $strippedDayValue;
   439|         }
   440|         return $day;
   441|     }
   442|     public static function dateTimeFromTimestamp(string $date, ?DateTimeZone $timeZone = null): DateTime
   443|     {
   444|         $dtobj = DateTime::createFromFormat('U', $date) ?: new DateTime();
   445|         $dtobj->setTimeZone($timeZone ?? self::getDefaultOrLocalTimezone());
   446|         return $dtobj;
   447|     }
   448|     public static function formattedDateTimeFromTimestamp(string $date, string $format, ?DateTimeZone $timeZone = null): string
   449|     {
   450|         $dtobj = self::dateTimeFromTimestamp($date, $timeZone);
   451|         return $dtobj->format($format);
   452|     }
   453|     public static function roundMicroseconds(DateTime $dti): void
   454|     {
   455|         $microseconds = (int) $dti->format('u');
   456|         if ($microseconds >= 500000) {
   457|             $dti->modify('+1 second');
   458|         }
   459|     }
   460| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Shared/Escher/DgContainer/SpgrContainer.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer;
     3| class SpgrContainer
     4| {
     5|     /**
     6|      * Parent Shape Group Container.
     7|      */
     8|     private ?self $parent = null;
     9|     /**
    10|      * Shape Container collection.
    11|      */
    12|     private array $children = [];
    13|     /**
    14|      * Set parent Shape Group Container.
    15|      */
    16|     public function setParent(?self $parent): void
    17|     {
    18|         $this->parent = $parent;
    19|     }
    20|     /**
    21|      * Get the parent Shape Group Container if any.
    22|      */
    23|     public function getParent(): ?self
    24|     {
    25|         return $this->parent;
    26|     }
    27|     /**
    28|      * Add a child. This will be either spgrContainer or spContainer.
    29|      *
    30|      * @param SpgrContainer|SpgrContainer\SpContainer $child child to be added
    31|      */
    32|     public function addChild(mixed $child): void
    33|     {
    34|         $this->children[] = $child;
    35|         $child->setParent($this);
    36|     }
    37|     /**
    38|      * Get collection of Shape Containers.
    39|      */
    40|     public function getChildren(): array
    41|     {
    42|         return $this->children;
    43|     }
    44|     /**
    45|      * Recursively get all spContainers within this spgrContainer.
    46|      *
    47|      * @return SpgrContainer\SpContainer[]
    48|      */
    49|     public function getAllSpContainers(): array
    50|     {
    51|         $allSpContainers = [];
    52|         foreach ($this->children as $child) {
    53|             if ($child instanceof self) {
    54|                 $allSpContainers = array_merge($allSpContainers, $child->getAllSpContainers());
    55|             } else {
    56|                 $allSpContainers[] = $child;
    57|             }
    58|         }
    59|         return $allSpContainers;
    60|     }
    61| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Shared/Trend/PolynomialBestFit.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-169 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Shared\Trend;
     3| use Matrix\Matrix;
     4| class PolynomialBestFit extends BestFit
     5| {
     6|     /**
     7|      * Algorithm type to use for best-fit
     8|      * (Name of this Trend class).
     9|      */
    10|     protected string $bestFitType = 'polynomial';
    11|     /**
    12|      * Polynomial order.
    13|      */
    14|     protected int $order = 0;
    15|     /**
    16|      * Return the order of this polynomial.
    17|      */
    18|     public function getOrder(): int
    19|     {
    20|         return $this->order;
    21|     }
    22|     /**
    23|      * Return the Y-Value for a specified value of X.
    24|      *
    25|      * @param float $xValue X-Value
    26|      *
    27|      * @return float Y-Value
    28|      */
    29|     public function getValueOfYForX(float $xValue): float
    30|     {
    31|         $retVal = $this->getIntersect();
    32|         $slope = $this->getSlope();
    33|         foreach ($slope as $key => $value) {
    34|             if ($value != 0.0) {
    35|                 $retVal += $value * $xValue ** ($key + 1);
    36|             }
    37|         }
    38|         return $retVal;
    39|     }
    40|     /**
    41|      * Return the X-Value for a specified value of Y.
    42|      *
    43|      * @param float $yValue Y-Value
    44|      *
    45|      * @return float X-Value
    46|      */
    47|     public function getValueOfXForY(float $yValue): float
    48|     {
    49|         return ($yValue - $this->getIntersect()) / $this->getSlope();
    50|     }
    51|     /**
    52|      * Return the Equation of the best-fit line.
    53|      *
    54|      * @param int $dp Number of places of decimal precision to display
    55|      */
    56|     public function getEquation(int $dp = 0): string
    57|     {
    58|         $slope = $this->getSlope($dp);
    59|         $intersect = $this->getIntersect($dp);
    60|         $equation = 'Y = ' . $intersect;
    61|         foreach ($slope as $key => $value) {
    62|             if ($value != 0.0) {
    63|                 $equation .= ' + ' . $value . ' * X';
    64|                 if ($key > 0) {
    65|                     $equation .= '^' . ($key + 1);
    66|                 }
    67|             }
    68|         }
    69|         return $equation;
    70|     }
    71|     /**
    72|      * Return the Slope of the line.
    73|      *
    74|      * @param int $dp Number of places of decimal precision to display
    75|      */
    76|     public function getSlope(int $dp = 0): float
    77|     {
    78|         if ($dp != 0) {
    79|             $coefficients = [];
    80|             foreach ($this->slope as $coefficient) {
    81|                 $coefficients[] = round($coefficient, $dp);
    82|             }
    83|             return $coefficients;
    84|         }
    85|         return $this->slope;
    86|     }
    87|     public function getCoefficients(int $dp = 0): array
    88|     {
    89|         return array_merge([$this->getIntersect($dp)], $this->getSlope($dp));
    90|     }
    91|     /**
    92|      * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
    93|      *
    94|      * @param int $order Order of Polynomial for this regression
    95|      * @param float[] $yValues The set of Y-values for this regression
    96|      * @param float[] $xValues The set of X-values for this regression
    97|      */
    98|     private function polynomialRegression(int $order, array $yValues, array $xValues): void
    99|     {
   100|         $x_sum = array_sum($xValues);
   101|         $y_sum = array_sum($yValues);
   102|         $xx_sum = $xy_sum = $yy_sum = 0;
   103|         for ($i = 0; $i < $this->valueCount; ++$i) {
   104|             $xy_sum += $xValues[$i] * $yValues[$i];
   105|             $xx_sum += $xValues[$i] * $xValues[$i];
   106|             $yy_sum += $yValues[$i] * $yValues[$i];
   107|         }
   108|         /*
   109|          *    This routine uses logic from the PHP port of polyfit version 0.1
   110|          *    written by Michael Bommarito and Paul Meagher
   111|          *
   112|          *    The function fits a polynomial function of order $order through
   113|          *    a series of x-y data points using least squares.
   114|          *
   115|          */
   116|         $A = [];
   117|         $B = [];
   118|         for ($i = 0; $i < $this->valueCount; ++$i) {
   119|             for ($j = 0; $j <= $order; ++$j) {
   120|                 $A[$i][$j] = $xValues[$i] ** $j;
   121|             }
   122|         }
   123|         for ($i = 0; $i < $this->valueCount; ++$i) {
   124|             $B[$i] = [$yValues[$i]];
   125|         }
   126|         $matrixA = new Matrix($A);
   127|         $matrixB = new Matrix($B);
   128|         $C = $matrixA->solve($matrixB);
   129|         $coefficients = [];
   130|         for ($i = 0; $i < $C->rows; ++$i) {
   131|             $r = $C->getValue($i + 1, 1); // row and column are origin-1
   132|             if (!is_numeric($r) || abs($r) <= 10 ** (-9)) {
   133|                 $r = 0;
   134|             } else {
   135|                 $r += 0;
   136|             }
   137|             $coefficients[] = $r;
   138|         }
   139|         $this->intersect = (float) array_shift($coefficients);
   140|         $this->slope = $coefficients;
   141|         $this->calculateGoodnessOfFit($x_sum, $y_sum, $xx_sum, $yy_sum, $xy_sum, 0, 0, 0);
   142|         foreach ($this->xValues as $xKey => $xValue) {
   143|             $this->yBestFitValues[$xKey] = $this->getValueOfYForX($xValue);
   144|         }
   145|     }
   146|     /**
   147|      * Define the regression and calculate the goodness of fit for a set of X and Y data values.
   148|      *
   149|      * @param int $order Order of Polynomial for this regression
   150|      * @param float[] $yValues The set of Y-values for this regression
   151|      * @param float[] $xValues The set of X-values for this regression
   152|      */
   153|     public function __construct(int $order, array $yValues, array $xValues = [])
   154|     {
   155|         parent::__construct($yValues, $xValues);
   156|         if (!$this->error) {
   157|             if ($order < $this->valueCount) {
   158|                 $this->bestFitType .= '_' . $order;
   159|                 $this->order = $order;
   160|                 $this->polynomialRegression($order, $yValues, $xValues);
   161|                 if (($this->getGoodnessOfFit() < 0.0) || ($this->getGoodnessOfFit() > 1.0)) {
   162|                     $this->error = true;
   163|                 }
   164|             } else {
   165|                 $this->error = true;
   166|             }
   167|         }
   168|     }
   169| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Spreadsheet.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1339 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet;
     3| use JsonSerializable;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     5| use PhpOffice\PhpSpreadsheet\Document\Properties;
     6| use PhpOffice\PhpSpreadsheet\Document\Security;
     7| use PhpOffice\PhpSpreadsheet\Reader\Xlsx as XlsxReader;
     8| use PhpOffice\PhpSpreadsheet\Shared\Date;
     9| use PhpOffice\PhpSpreadsheet\Shared\File;
    10| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
    11| use PhpOffice\PhpSpreadsheet\Style\Style;
    12| use PhpOffice\PhpSpreadsheet\Worksheet\Iterator;
    13| use PhpOffice\PhpSpreadsheet\Worksheet\Table;
    14| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    15| use PhpOffice\PhpSpreadsheet\Writer\Xlsx as XlsxWriter;
    16| class Spreadsheet implements JsonSerializable
    17| {
    18|     const VISIBILITY_VISIBLE = 'visible';
    19|     const VISIBILITY_HIDDEN = 'hidden';
    20|     const VISIBILITY_VERY_HIDDEN = 'veryHidden';
    21|     private const DEFINED_NAME_IS_RANGE = false;
    22|     private const DEFINED_NAME_IS_FORMULA = true;
    23|     private const WORKBOOK_VIEW_VISIBILITY_VALUES = [
    24|         self::VISIBILITY_VISIBLE,
    25|         self::VISIBILITY_HIDDEN,
    26|         self::VISIBILITY_VERY_HIDDEN,
    27|     ];
    28|     protected int $excelCalendar = Date::CALENDAR_WINDOWS_1900;
    29|     /**
    30|      * Unique ID.
    31|      */
    32|     private string $uniqueID;
    33|     /**
    34|      * Document properties.
    35|      */
    36|     private Properties $properties;
    37|     /**
    38|      * Document security.
    39|      */
    40|     private Security $security;
    41|     /**
    42|      * Collection of Worksheet objects.
    43|      *
    44|      * @var Worksheet[]
    45|      */
    46|     private array $workSheetCollection;
    47|     /**
    48|      * Calculation Engine.
    49|      */
    50|     private ?Calculation $calculationEngine;
    51|     /**
    52|      * Active sheet index.
    53|      */
    54|     private int $activeSheetIndex;
    55|     /**
    56|      * Named ranges.
    57|      *
    58|      * @var DefinedName[]
    59|      */
    60|     private array $definedNames;
    61|     /**
    62|      * CellXf supervisor.
    63|      */
    64|     private Style $cellXfSupervisor;
    65|     /**
    66|      * CellXf collection.
    67|      *
    68|      * @var Style[]
    69|      */
    70|     private array $cellXfCollection = [];
    71|     /**
    72|      * CellStyleXf collection.
    73|      *
    74|      * @var Style[]
    75|      */
    76|     private array $cellStyleXfCollection = [];
    77|     /**
    78|      * hasMacros : this workbook have macros ?
    79|      */
    80|     private bool $hasMacros = false;
    81|     /**
    82|      * macrosCode : all macros code as binary data (the vbaProject.bin file, this include form, code,  etc.), null if no macro.
    83|      */
    84|     private ?string $macrosCode = null;
    85|     /**
    86|      * macrosCertificate : if macros are signed, contains binary data vbaProjectSignature.bin file, null if not signed.
    87|      */
    88|     private ?string $macrosCertificate = null;
    89|     /**
    90|      * ribbonXMLData : null if workbook is'nt Excel 2007 or not contain a customized UI.
    91|      *
    92|      * @var null|array{target: string, data: string}
    93|      */
    94|     private ?array $ribbonXMLData = null;
    95|     /**
    96|      * ribbonBinObjects : null if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements
    97|      * ignored if $ribbonXMLData is null.
    98|      */
    99|     private ?array $ribbonBinObjects = null;
   100|     /**
   101|      * List of unparsed loaded data for export to same format with better compatibility.
   102|      * It has to be minimized when the library start to support currently unparsed data.
   103|      */
   104|     private array $unparsedLoadedData = [];
   105|     /**
   106|      * Controls visibility of the horizonal scroll bar in the application.
   107|      */
   108|     private bool $showHorizontalScroll = true;
   109|     /**
   110|      * Controls visibility of the horizonal scroll bar in the application.
   111|      */
   112|     private bool $showVerticalScroll = true;
   113|     /**
   114|      * Controls visibility of the sheet tabs in the application.
   115|      */
   116|     private bool $showSheetTabs = true;
   117|     /**
   118|      * Specifies a boolean value that indicates whether the workbook window
   119|      * is minimized.
   120|      */
   121|     private bool $minimized = false;
   122|     /**
   123|      * Specifies a boolean value that indicates whether to group dates
   124|      * when presenting the user with filtering optiomd in the user
   125|      * interface.
   126|      */
   127|     private bool $autoFilterDateGrouping = true;
   128|     /**
   129|      * Specifies the index to the first sheet in the book view.
   130|      */
   131|     private int $firstSheetIndex = 0;
   132|     /**
   133|      * Specifies the visible status of the workbook.
   134|      */
   135|     private string $visibility = self::VISIBILITY_VISIBLE;
   136|     /**
   137|      * Specifies the ratio between the workbook tabs bar and the horizontal
   138|      * scroll bar.  TabRatio is assumed to be out of 1000 of the horizontal
   139|      * window width.
   140|      */
   141|     private int $tabRatio = 600;
   142|     private Theme $theme;
   143|     public function getTheme(): Theme
   144|     {
   145|         return $this->theme;
   146|     }
   147|     /**
   148|      * The workbook has macros ?
   149|      */
   150|     public function hasMacros(): bool
   151|     {
   152|         return $this->hasMacros;
   153|     }
   154|     /**
   155|      * Define if a workbook has macros.
   156|      *
   157|      * @param bool $hasMacros true|false
   158|      */
   159|     public function setHasMacros(bool $hasMacros): void
   160|     {
   161|         $this->hasMacros = (bool) $hasMacros;
   162|     }
   163|     /**
   164|      * Set the macros code.
   165|      *
   166|      * @param string $macroCode string|null
   167|      */
   168|     public function setMacrosCode(string $macroCode): void
   169|     {
   170|         $this->macrosCode = $macroCode;
   171|         $this->setHasMacros($macroCode !== null);
   172|     }
   173|     /**
   174|      * Return the macros code.
   175|      */
   176|     public function getMacrosCode(): ?string
   177|     {
   178|         return $this->macrosCode;
   179|     }
   180|     /**
   181|      * Set the macros certificate.
   182|      */
   183|     public function setMacrosCertificate(?string $certificate): void
   184|     {
   185|         $this->macrosCertificate = $certificate;
   186|     }
   187|     /**
   188|      * Is the project signed ?
   189|      *
   190|      * @return bool true|false
   191|      */
   192|     public function hasMacrosCertificate(): bool
   193|     {
   194|         return $this->macrosCertificate !== null;
   195|     }
   196|     /**
   197|      * Return the macros certificate.
   198|      */
   199|     public function getMacrosCertificate(): ?string
   200|     {
   201|         return $this->macrosCertificate;
   202|     }
   203|     /**
   204|      * Remove all macros, certificate from spreadsheet.
   205|      */
   206|     public function discardMacros(): void
   207|     {
   208|         $this->hasMacros = false;
   209|         $this->macrosCode = null;
   210|         $this->macrosCertificate = null;
   211|     }
   212|     /**
   213|      * set ribbon XML data.
   214|      */
   215|     public function setRibbonXMLData(mixed $target, mixed $xmlData): void
   216|     {
   217|         if (is_string($target) && is_string($xmlData)) {
   218|             $this->ribbonXMLData = ['target' => $target, 'data' => $xmlData];
   219|         } else {
   220|             $this->ribbonXMLData = null;
   221|         }
   222|     }
   223|     /**
   224|      * retrieve ribbon XML Data.
   225|      */
   226|     public function getRibbonXMLData(string $what = 'all'): null|array|string //we need some constants here...
   227|     {
   228|         $returnData = null;
   229|         $what = strtolower($what);
   230|         switch ($what) {
   231|             case 'all':
   232|                 $returnData = $this->ribbonXMLData;
   233|                 break;
   234|             case 'target':
   235|             case 'data':
   236|                 if (is_array($this->ribbonXMLData)) {
   237|                     $returnData = $this->ribbonXMLData[$what];
   238|                 }
   239|                 break;
   240|         }
   241|         return $returnData;
   242|     }
   243|     /**
   244|      * store binaries ribbon objects (pictures).
   245|      */
   246|     public function setRibbonBinObjects(mixed $binObjectsNames, mixed $binObjectsData): void
   247|     {
   248|         if ($binObjectsNames !== null && $binObjectsData !== null) {
   249|             $this->ribbonBinObjects = ['names' => $binObjectsNames, 'data' => $binObjectsData];
   250|         } else {
   251|             $this->ribbonBinObjects = null;
   252|         }
   253|     }
   254|     /**
   255|      * List of unparsed loaded data for export to same format with better compatibility.
   256|      * It has to be minimized when the library start to support currently unparsed data.
   257|      *
   258|      * @internal
   259|      */
   260|     public function getUnparsedLoadedData(): array
   261|     {
   262|         return $this->unparsedLoadedData;
   263|     }
   264|     /**
   265|      * List of unparsed loaded data for export to same format with better compatibility.
   266|      * It has to be minimized when the library start to support currently unparsed data.
   267|      *
   268|      * @internal
   269|      */
   270|     public function setUnparsedLoadedData(array $unparsedLoadedData): void
   271|     {
   272|         $this->unparsedLoadedData = $unparsedLoadedData;
   273|     }
   274|     /**
   275|      * retrieve Binaries Ribbon Objects.
   276|      */
   277|     public function getRibbonBinObjects(string $what = 'all'): ?array
   278|     {
   279|         $ReturnData = null;
   280|         $what = strtolower($what);
   281|         switch ($what) {
   282|             case 'all':
   283|                 return $this->ribbonBinObjects;
   284|             case 'names':
   285|             case 'data':
   286|                 if (is_array($this->ribbonBinObjects) && isset($this->ribbonBinObjects[$what])) {
   287|                     $ReturnData = $this->ribbonBinObjects[$what];
   288|                 }
   289|                 break;
   290|             case 'types':
   291|                 if (
   292|                     is_array($this->ribbonBinObjects)
   293|                     && isset($this->ribbonBinObjects['data']) && is_array($this->ribbonBinObjects['data'])
   294|                 ) {
   295|                     $tmpTypes = array_keys($this->ribbonBinObjects['data']);
   296|                     $ReturnData = array_unique(array_map(fn (string $path): string => pathinfo($path, PATHINFO_EXTENSION), $tmpTypes));
   297|                 } else {
   298|                     $ReturnData = []; // the caller want an array... not null if empty
   299|                 }
   300|                 break;
   301|         }
   302|         return $ReturnData;
   303|     }
   304|     /**
   305|      * This workbook have a custom UI ?
   306|      */
   307|     public function hasRibbon(): bool
   308|     {
   309|         return $this->ribbonXMLData !== null;
   310|     }
   311|     /**
   312|      * This workbook have additionnal object for the ribbon ?
   313|      */
   314|     public function hasRibbonBinObjects(): bool
   315|     {
   316|         return $this->ribbonBinObjects !== null;
   317|     }
   318|     /**
   319|      * Check if a sheet with a specified code name already exists.
   320|      *
   321|      * @param string $codeName Name of the worksheet to check
   322|      */
   323|     public function sheetCodeNameExists(string $codeName): bool
   324|     {
   325|         return $this->getSheetByCodeName($codeName) !== null;
   326|     }
   327|     /**
   328|      * Get sheet by code name. Warning : sheet don't have always a code name !
   329|      *
   330|      * @param string $codeName Sheet name
   331|      */
   332|     public function getSheetByCodeName(string $codeName): ?Worksheet
   333|     {
   334|         $worksheetCount = count($this->workSheetCollection);
   335|         for ($i = 0; $i < $worksheetCount; ++$i) {
   336|             if ($this->workSheetCollection[$i]->getCodeName() == $codeName) {
   337|                 return $this->workSheetCollection[$i];
   338|             }
   339|         }
   340|         return null;
   341|     }
   342|     /**
   343|      * Create a new PhpSpreadsheet with one Worksheet.
   344|      */
   345|     public function __construct()
   346|     {
   347|         $this->uniqueID = uniqid('', true);
   348|         $this->calculationEngine = new Calculation($this);
   349|         $this->theme = new Theme();
   350|         $this->workSheetCollection = [];
   351|         $this->workSheetCollection[] = new Worksheet($this);
   352|         $this->activeSheetIndex = 0;
   353|         $this->properties = new Properties();
   354|         $this->security = new Security();
   355|         $this->definedNames = [];
   356|         $this->cellXfSupervisor = new Style(true);
   357|         $this->cellXfSupervisor->bindParent($this);
   358|         $this->addCellXf(new Style());
   359|         $this->addCellStyleXf(new Style());
   360|     }
   361|     /**
   362|      * Code to execute when this worksheet is unset().
   363|      */
   364|     public function __destruct()
   365|     {
   366|         $this->disconnectWorksheets();
   367|         $this->calculationEngine = null;
   368|         $this->cellXfCollection = [];
   369|         $this->cellStyleXfCollection = [];
   370|         $this->definedNames = [];
   371|     }
   372|     /**
   373|      * Disconnect all worksheets from this PhpSpreadsheet workbook object,
   374|      * typically so that the PhpSpreadsheet object can be unset.
   375|      */
   376|     public function disconnectWorksheets(): void
   377|     {
   378|         foreach ($this->workSheetCollection as $worksheet) {
   379|             $worksheet->disconnectCells();
   380|             unset($worksheet);
   381|         }
   382|         $this->workSheetCollection = [];
   383|     }
   384|     /**
   385|      * Return the calculation engine for this worksheet.
   386|      */
   387|     public function getCalculationEngine(): ?Calculation
   388|     {
   389|         return $this->calculationEngine;
   390|     }
   391|     /**
   392|      * Get properties.
   393|      */
   394|     public function getProperties(): Properties
   395|     {
   396|         return $this->properties;
   397|     }
   398|     /**
   399|      * Set properties.
   400|      */
   401|     public function setProperties(Properties $documentProperties): void
   402|     {
   403|         $this->properties = $documentProperties;
   404|     }
   405|     /**
   406|      * Get security.
   407|      */
   408|     public function getSecurity(): Security
   409|     {
   410|         return $this->security;
   411|     }
   412|     /**
   413|      * Set security.
   414|      */
   415|     public function setSecurity(Security $documentSecurity): void
   416|     {
   417|         $this->security = $documentSecurity;
   418|     }
   419|     /**
   420|      * Get active sheet.
   421|      */
   422|     public function getActiveSheet(): Worksheet
   423|     {
   424|         return $this->getSheet($this->activeSheetIndex);
   425|     }
   426|     /**
   427|      * Create sheet and add it to this workbook.
   428|      *
   429|      * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
   430|      */
   431|     public function createSheet(?int $sheetIndex = null): Worksheet
   432|     {
   433|         $newSheet = new Worksheet($this);
   434|         $this->addSheet($newSheet, $sheetIndex);
   435|         return $newSheet;
   436|     }
   437|     /**
   438|      * Check if a sheet with a specified name already exists.
   439|      *
   440|      * @param string $worksheetName Name of the worksheet to check
   441|      */
   442|     public function sheetNameExists(string $worksheetName): bool
   443|     {
   444|         return $this->getSheetByName($worksheetName) !== null;
   445|     }
   446|     /**
   447|      * Add sheet.
   448|      *
   449|      * @param Worksheet $worksheet The worksheet to add
   450|      * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
   451|      */
   452|     public function addSheet(Worksheet $worksheet, ?int $sheetIndex = null): Worksheet
   453|     {
   454|         if ($this->sheetNameExists($worksheet->getTitle())) {
   455|             throw new Exception(
   456|                 "Workbook already contains a worksheet named '{$worksheet->getTitle()}'. Rename this worksheet first."
   457|             );
   458|         }
   459|         if ($sheetIndex === null) {
   460|             if ($this->activeSheetIndex < 0) {
   461|                 $this->activeSheetIndex = 0;
   462|             }
   463|             $this->workSheetCollection[] = $worksheet;
   464|         } else {
   465|             array_splice(
   466|                 $this->workSheetCollection,
   467|                 $sheetIndex,
   468|                 0,
   469|                 [$worksheet]
   470|             );
   471|             if ($this->activeSheetIndex >= $sheetIndex) {
   472|                 ++$this->activeSheetIndex;
   473|             }
   474|         }
   475|         if ($worksheet->getParent() === null) {
   476|             $worksheet->rebindParent($this);
   477|         }
   478|         return $worksheet;
   479|     }
   480|     /**
   481|      * Remove sheet by index.
   482|      *
   483|      * @param int $sheetIndex Index position of the worksheet to remove
   484|      */
   485|     public function removeSheetByIndex(int $sheetIndex): void
   486|     {
   487|         $numSheets = count($this->workSheetCollection);
   488|         if ($sheetIndex > $numSheets - 1) {
   489|             throw new Exception(
   490|                 "You tried to remove a sheet by the out of bounds index: {$sheetIndex}. The actual number of sheets is {$numSheets}."
   491|             );
   492|         }
   493|         array_splice($this->workSheetCollection, $sheetIndex, 1);
   494|         if (
   495|             ($this->activeSheetIndex >= $sheetIndex)
   496|             && ($this->activeSheetIndex > 0 || $numSheets <= 1)
   497|         ) {
   498|             --$this->activeSheetIndex;
   499|         }
   500|     }
   501|     /**
   502|      * Get sheet by index.
   503|      *
   504|      * @param int $sheetIndex Sheet index
   505|      */
   506|     public function getSheet(int $sheetIndex): Worksheet
   507|     {
   508|         if (!isset($this->workSheetCollection[$sheetIndex])) {
   509|             $numSheets = $this->getSheetCount();
   510|             throw new Exception(
   511|                 "Your requested sheet index: {$sheetIndex} is out of bounds. The actual number of sheets is {$numSheets}."
   512|             );
   513|         }
   514|         return $this->workSheetCollection[$sheetIndex];
   515|     }
   516|     /**
   517|      * Get all sheets.
   518|      *
   519|      * @return Worksheet[]
   520|      */
   521|     public function getAllSheets(): array
   522|     {
   523|         return $this->workSheetCollection;
   524|     }
   525|     /**
   526|      * Get sheet by name.
   527|      *
   528|      * @param string $worksheetName Sheet name
   529|      */
   530|     public function getSheetByName(string $worksheetName): ?Worksheet
   531|     {
   532|         $worksheetCount = count($this->workSheetCollection);
   533|         for ($i = 0; $i < $worksheetCount; ++$i) {
   534|             if (strcasecmp($this->workSheetCollection[$i]->getTitle(), trim($worksheetName, "'")) === 0) {
   535|                 return $this->workSheetCollection[$i];
   536|             }
   537|         }
   538|         return null;
   539|     }
   540|     /**
   541|      * Get sheet by name, throwing exception if not found.
   542|      */
   543|     public function getSheetByNameOrThrow(string $worksheetName): Worksheet
   544|     {
   545|         $worksheet = $this->getSheetByName($worksheetName);
   546|         if ($worksheet === null) {
   547|             throw new Exception("Sheet $worksheetName does not exist.");
   548|         }
   549|         return $worksheet;
   550|     }
   551|     /**
   552|      * Get index for sheet.
   553|      *
   554|      * @return int index
   555|      */
   556|     public function getIndex(Worksheet $worksheet): int
   557|     {
   558|         foreach ($this->workSheetCollection as $key => $value) {
   559|             if ($value->getHashCode() === $worksheet->getHashCode()) {
   560|                 return $key;
   561|             }
   562|         }
   563|         throw new Exception('Sheet does not exist.');
   564|     }
   565|     /**
   566|      * Set index for sheet by sheet name.
   567|      *
   568|      * @param string $worksheetName Sheet name to modify index for
   569|      * @param int $newIndexPosition New index for the sheet
   570|      *
   571|      * @return int New sheet index
   572|      */
   573|     public function setIndexByName(string $worksheetName, int $newIndexPosition): int
   574|     {
   575|         $oldIndex = $this->getIndex($this->getSheetByNameOrThrow($worksheetName));
   576|         $worksheet = array_splice(
   577|             $this->workSheetCollection,
   578|             $oldIndex,
   579|             1
   580|         );
   581|         array_splice(
   582|             $this->workSheetCollection,
   583|             $newIndexPosition,
   584|             0,
   585|             $worksheet
   586|         );
   587|         return $newIndexPosition;
   588|     }
   589|     /**
   590|      * Get sheet count.
   591|      */
   592|     public function getSheetCount(): int
   593|     {
   594|         return count($this->workSheetCollection);
   595|     }
   596|     /**
   597|      * Get active sheet index.
   598|      *
   599|      * @return int Active sheet index
   600|      */
   601|     public function getActiveSheetIndex(): int
   602|     {
   603|         return $this->activeSheetIndex;
   604|     }
   605|     /**
   606|      * Set active sheet index.
   607|      *
   608|      * @param int $worksheetIndex Active sheet index
   609|      */
   610|     public function setActiveSheetIndex(int $worksheetIndex): Worksheet
   611|     {
   612|         $numSheets = count($this->workSheetCollection);
   613|         if ($worksheetIndex > $numSheets - 1) {
   614|             throw new Exception(
   615|                 "You tried to set a sheet active by the out of bounds index: {$worksheetIndex}. The actual number of sheets is {$numSheets}."
   616|             );
   617|         }
   618|         $this->activeSheetIndex = $worksheetIndex;
   619|         return $this->getActiveSheet();
   620|     }
   621|     /**
   622|      * Set active sheet index by name.
   623|      *
   624|      * @param string $worksheetName Sheet title
   625|      */
   626|     public function setActiveSheetIndexByName(string $worksheetName): Worksheet
   627|     {
   628|         if (($worksheet = $this->getSheetByName($worksheetName)) instanceof Worksheet) {
   629|             $this->setActiveSheetIndex($this->getIndex($worksheet));
   630|             return $worksheet;
   631|         }
   632|         throw new Exception('Workbook does not contain sheet:' . $worksheetName);
   633|     }
   634|     /**
   635|      * Get sheet names.
   636|      *
   637|      * @return string[]
   638|      */
   639|     public function getSheetNames(): array
   640|     {
   641|         $returnValue = [];
   642|         $worksheetCount = $this->getSheetCount();
   643|         for ($i = 0; $i < $worksheetCount; ++$i) {
   644|             $returnValue[] = $this->getSheet($i)->getTitle();
   645|         }
   646|         return $returnValue;
   647|     }
   648|     /**
   649|      * Add external sheet.
   650|      *
   651|      * @param Worksheet $worksheet External sheet to add
   652|      * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
   653|      */
   654|     public function addExternalSheet(Worksheet $worksheet, ?int $sheetIndex = null): Worksheet
   655|     {
   656|         if ($this->sheetNameExists($worksheet->getTitle())) {
   657|             throw new Exception("Workbook already contains a worksheet named '{$worksheet->getTitle()}'. Rename the external sheet first.");
   658|         }
   659|         $countCellXfs = count($this->cellXfCollection);
   660|         foreach ($worksheet->getParentOrThrow()->getCellXfCollection() as $cellXf) {
   661|             $this->addCellXf(clone $cellXf);
   662|         }
   663|         $worksheet->rebindParent($this);
   664|         foreach ($worksheet->getCoordinates(false) as $coordinate) {
   665|             $cell = $worksheet->getCell($coordinate);
   666|             $cell->setXfIndex($cell->getXfIndex() + $countCellXfs);
   667|         }
   668|         foreach ($worksheet->getColumnDimensions() as $columnDimension) {
   669|             $columnDimension->setXfIndex($columnDimension->getXfIndex() + $countCellXfs);
   670|         }
   671|         foreach ($worksheet->getRowDimensions() as $rowDimension) {
   672|             $xfIndex = $rowDimension->getXfIndex();
   673|             if ($xfIndex !== null) {
   674|                 $rowDimension->setXfIndex($xfIndex + $countCellXfs);
   675|             }
   676|         }
   677|         return $this->addSheet($worksheet, $sheetIndex);
   678|     }
   679|     /**
   680|      * Get an array of all Named Ranges.
   681|      *
   682|      * @return DefinedName[]
   683|      */
   684|     public function getNamedRanges(): array
   685|     {
   686|         return array_filter(
   687|             $this->definedNames,
   688|             fn (DefinedName $definedName): bool => $definedName->isFormula() === self::DEFINED_NAME_IS_RANGE
   689|         );
   690|     }
   691|     /**
   692|      * Get an array of all Named Formulae.
   693|      *
   694|      * @return DefinedName[]
   695|      */
   696|     public function getNamedFormulae(): array
   697|     {
   698|         return array_filter(
   699|             $this->definedNames,
   700|             fn (DefinedName $definedName): bool => $definedName->isFormula() === self::DEFINED_NAME_IS_FORMULA
   701|         );
   702|     }
   703|     /**
   704|      * Get an array of all Defined Names (both named ranges and named formulae).
   705|      *
   706|      * @return DefinedName[]
   707|      */
   708|     public function getDefinedNames(): array
   709|     {
   710|         return $this->definedNames;
   711|     }
   712|     /**
   713|      * Add a named range.
   714|      * If a named range with this name already exists, then this will replace the existing value.
   715|      */
   716|     public function addNamedRange(NamedRange $namedRange): void
   717|     {
   718|         $this->addDefinedName($namedRange);
   719|     }
   720|     /**
   721|      * Add a named formula.
   722|      * If a named formula with this name already exists, then this will replace the existing value.
   723|      */
   724|     public function addNamedFormula(NamedFormula $namedFormula): void
   725|     {
   726|         $this->addDefinedName($namedFormula);
   727|     }
   728|     /**
   729|      * Add a defined name (either a named range or a named formula).
   730|      * If a defined named with this name already exists, then this will replace the existing value.
   731|      */
   732|     public function addDefinedName(DefinedName $definedName): void
   733|     {
   734|         $upperCaseName = StringHelper::strToUpper($definedName->getName());
   735|         if ($definedName->getScope() == null) {
   736|             $this->definedNames[$upperCaseName] = $definedName;
   737|         } else {
   738|             $this->definedNames[$definedName->getScope()->getTitle() . '!' . $upperCaseName] = $definedName;
   739|         }
   740|     }
   741|     /**
   742|      * Get named range.
   743|      *
   744|      * @param null|Worksheet $worksheet Scope. Use null for global scope
   745|      */
   746|     public function getNamedRange(string $namedRange, ?Worksheet $worksheet = null): ?NamedRange
   747|     {
   748|         $returnValue = null;
   749|         if ($namedRange !== '') {
   750|             $namedRange = StringHelper::strToUpper($namedRange);
   751|             $returnValue = $this->getGlobalDefinedNameByType($namedRange, self::DEFINED_NAME_IS_RANGE);
   752|             $returnValue = $this->getLocalDefinedNameByType($namedRange, self::DEFINED_NAME_IS_RANGE, $worksheet) ?: $returnValue;
   753|         }
   754|         return $returnValue instanceof NamedRange ? $returnValue : null;
   755|     }
   756|     /**
   757|      * Get named formula.
   758|      *
   759|      * @param null|Worksheet $worksheet Scope. Use null for global scope
   760|      */
   761|     public function getNamedFormula(string $namedFormula, ?Worksheet $worksheet = null): ?NamedFormula
   762|     {
   763|         $returnValue = null;
   764|         if ($namedFormula !== '') {
   765|             $namedFormula = StringHelper::strToUpper($namedFormula);
   766|             $returnValue = $this->getGlobalDefinedNameByType($namedFormula, self::DEFINED_NAME_IS_FORMULA);
   767|             $returnValue = $this->getLocalDefinedNameByType($namedFormula, self::DEFINED_NAME_IS_FORMULA, $worksheet) ?: $returnValue;
   768|         }
   769|         return $returnValue instanceof NamedFormula ? $returnValue : null;
   770|     }
   771|     private function getGlobalDefinedNameByType(string $name, bool $type): ?DefinedName
   772|     {
   773|         if (isset($this->definedNames[$name]) && $this->definedNames[$name]->isFormula() === $type) {
   774|             return $this->definedNames[$name];
   775|         }
   776|         return null;
   777|     }
   778|     private function getLocalDefinedNameByType(string $name, bool $type, ?Worksheet $worksheet = null): ?DefinedName
   779|     {
   780|         if (
   781|             ($worksheet !== null) && isset($this->definedNames[$worksheet->getTitle() . '!' . $name])
   782|             && $this->definedNames[$worksheet->getTitle() . '!' . $name]->isFormula() === $type
   783|         ) {
   784|             return $this->definedNames[$worksheet->getTitle() . '!' . $name];
   785|         }
   786|         return null;
   787|     }
   788|     /**
   789|      * Get named range.
   790|      *
   791|      * @param null|Worksheet $worksheet Scope. Use null for global scope
   792|      */
   793|     public function getDefinedName(string $definedName, ?Worksheet $worksheet = null): ?DefinedName
   794|     {
   795|         $returnValue = null;
   796|         if ($definedName !== '') {
   797|             $definedName = StringHelper::strToUpper($definedName);
   798|             if (isset($this->definedNames[$definedName])) {
   799|                 $returnValue = $this->definedNames[$definedName];
   800|             }
   801|             if (($worksheet !== null) && isset($this->definedNames[$worksheet->getTitle() . '!' . $definedName])) {
   802|                 $returnValue = $this->definedNames[$worksheet->getTitle() . '!' . $definedName];
   803|             }
   804|         }
   805|         return $returnValue;
   806|     }
   807|     /**
   808|      * Remove named range.
   809|      *
   810|      * @param null|Worksheet $worksheet scope: use null for global scope
   811|      *
   812|      * @return $this
   813|      */
   814|     public function removeNamedRange(string $namedRange, ?Worksheet $worksheet = null): self
   815|     {
   816|         if ($this->getNamedRange($namedRange, $worksheet) === null) {
   817|             return $this;
   818|         }
   819|         return $this->removeDefinedName($namedRange, $worksheet);
   820|     }
   821|     /**
   822|      * Remove named formula.
   823|      *
   824|      * @param null|Worksheet $worksheet scope: use null for global scope
   825|      *
   826|      * @return $this
   827|      */
   828|     public function removeNamedFormula(string $namedFormula, ?Worksheet $worksheet = null): self
   829|     {
   830|         if ($this->getNamedFormula($namedFormula, $worksheet) === null) {
   831|             return $this;
   832|         }
   833|         return $this->removeDefinedName($namedFormula, $worksheet);
   834|     }
   835|     /**
   836|      * Remove defined name.
   837|      *
   838|      * @param null|Worksheet $worksheet scope: use null for global scope
   839|      *
   840|      * @return $this
   841|      */
   842|     public function removeDefinedName(string $definedName, ?Worksheet $worksheet = null): self
   843|     {
   844|         $definedName = StringHelper::strToUpper($definedName);
   845|         if ($worksheet === null) {
   846|             if (isset($this->definedNames[$definedName])) {
   847|                 unset($this->definedNames[$definedName]);
   848|             }
   849|         } else {
   850|             if (isset($this->definedNames[$worksheet->getTitle() . '!' . $definedName])) {
   851|                 unset($this->definedNames[$worksheet->getTitle() . '!' . $definedName]);
   852|             } elseif (isset($this->definedNames[$definedName])) {
   853|                 unset($this->definedNames[$definedName]);
   854|             }
   855|         }
   856|         return $this;
   857|     }
   858|     /**
   859|      * Get worksheet iterator.
   860|      */
   861|     public function getWorksheetIterator(): Iterator
   862|     {
   863|         return new Iterator($this);
   864|     }
   865|     /**
   866|      * Copy workbook (!= clone!).
   867|      */
   868|     public function copy(): self
   869|     {
   870|         $filename = File::temporaryFilename();
   871|         $writer = new XlsxWriter($this);
   872|         $writer->setIncludeCharts(true);
   873|         $writer->save($filename);
   874|         $reader = new XlsxReader();
   875|         $reader->setIncludeCharts(true);
   876|         $reloadedSpreadsheet = $reader->load($filename);
   877|         unlink($filename);
   878|         return $reloadedSpreadsheet;
   879|     }
   880|     public function __clone()
   881|     {
   882|         throw new Exception(
   883|             'Do not use clone on spreadsheet. Use spreadsheet->copy() instead.'
   884|         );
   885|     }
   886|     /**
   887|      * Get the workbook collection of cellXfs.
   888|      *
   889|      * @return Style[]
   890|      */
   891|     public function getCellXfCollection(): array
   892|     {
   893|         return $this->cellXfCollection;
   894|     }
   895|     /**
   896|      * Get cellXf by index.
   897|      */
   898|     public function getCellXfByIndex(int $cellStyleIndex): Style
   899|     {
   900|         return $this->cellXfCollection[$cellStyleIndex];
   901|     }
   902|     /**
   903|      * Get cellXf by hash code.
   904|      *
   905|      * @return false|Style
   906|      */
   907|     public function getCellXfByHashCode(string $hashcode): bool|Style
   908|     {
   909|         foreach ($this->cellXfCollection as $cellXf) {
   910|             if ($cellXf->getHashCode() === $hashcode) {
   911|                 return $cellXf;
   912|             }
   913|         }
   914|         return false;
   915|     }
   916|     /**
   917|      * Check if style exists in style collection.
   918|      */
   919|     public function cellXfExists(Style $cellStyleIndex): bool
   920|     {
   921|         return in_array($cellStyleIndex, $this->cellXfCollection, true);
   922|     }
   923|     /**
   924|      * Get default style.
   925|      */
   926|     public function getDefaultStyle(): Style
   927|     {
   928|         if (isset($this->cellXfCollection[0])) {
   929|             return $this->cellXfCollection[0];
   930|         }
   931|         throw new Exception('No default style found for this workbook');
   932|     }
   933|     /**
   934|      * Add a cellXf to the workbook.
   935|      */
   936|     public function addCellXf(Style $style): void
   937|     {
   938|         $this->cellXfCollection[] = $style;
   939|         $style->setIndex(count($this->cellXfCollection) - 1);
   940|     }
   941|     /**
   942|      * Remove cellXf by index. It is ensured that all cells get their xf index updated.
   943|      *
   944|      * @param int $cellStyleIndex Index to cellXf
   945|      */
   946|     public function removeCellXfByIndex(int $cellStyleIndex): void
   947|     {
   948|         if ($cellStyleIndex > count($this->cellXfCollection) - 1) {
   949|             throw new Exception('CellXf index is out of bounds.');
   950|         }
   951|         array_splice($this->cellXfCollection, $cellStyleIndex, 1);
   952|         foreach ($this->workSheetCollection as $worksheet) {
   953|             foreach ($worksheet->getCoordinates(false) as $coordinate) {
   954|                 $cell = $worksheet->getCell($coordinate);
   955|                 $xfIndex = $cell->getXfIndex();
   956|                 if ($xfIndex > $cellStyleIndex) {
   957|                     $cell->setXfIndex($xfIndex - 1);
   958|                 } elseif ($xfIndex == $cellStyleIndex) {
   959|                     $cell->setXfIndex(0);
   960|                 }
   961|             }
   962|         }
   963|     }
   964|     /**
   965|      * Get the cellXf supervisor.
   966|      */
   967|     public function getCellXfSupervisor(): Style
   968|     {
   969|         return $this->cellXfSupervisor;
   970|     }
   971|     /**
   972|      * Get the workbook collection of cellStyleXfs.
   973|      *
   974|      * @return Style[]
   975|      */
   976|     public function getCellStyleXfCollection(): array
   977|     {
   978|         return $this->cellStyleXfCollection;
   979|     }
   980|     /**
   981|      * Get cellStyleXf by index.
   982|      *
   983|      * @param int $cellStyleIndex Index to cellXf
   984|      */
   985|     public function getCellStyleXfByIndex(int $cellStyleIndex): Style
   986|     {
   987|         return $this->cellStyleXfCollection[$cellStyleIndex];
   988|     }
   989|     /**
   990|      * Get cellStyleXf by hash code.
   991|      *
   992|      * @return false|Style
   993|      */
   994|     public function getCellStyleXfByHashCode(string $hashcode): bool|Style
   995|     {
   996|         foreach ($this->cellStyleXfCollection as $cellStyleXf) {
   997|             if ($cellStyleXf->getHashCode() === $hashcode) {
   998|                 return $cellStyleXf;
   999|             }
  1000|         }
  1001|         return false;
  1002|     }
  1003|     /**
  1004|      * Add a cellStyleXf to the workbook.
  1005|      */
  1006|     public function addCellStyleXf(Style $style): void
  1007|     {
  1008|         $this->cellStyleXfCollection[] = $style;
  1009|         $style->setIndex(count($this->cellStyleXfCollection) - 1);
  1010|     }
  1011|     /**
  1012|      * Remove cellStyleXf by index.
  1013|      *
  1014|      * @param int $cellStyleIndex Index to cellXf
  1015|      */
  1016|     public function removeCellStyleXfByIndex(int $cellStyleIndex): void
  1017|     {
  1018|         if ($cellStyleIndex > count($this->cellStyleXfCollection) - 1) {
  1019|             throw new Exception('CellStyleXf index is out of bounds.');
  1020|         }
  1021|         array_splice($this->cellStyleXfCollection, $cellStyleIndex, 1);
  1022|     }
  1023|     /**
  1024|      * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells
  1025|      * and columns in the workbook.
  1026|      */
  1027|     public function garbageCollect(): void
  1028|     {
  1029|         $countReferencesCellXf = [];
  1030|         foreach ($this->cellXfCollection as $index => $cellXf) {
  1031|             $countReferencesCellXf[$index] = 0;
  1032|         }
  1033|         foreach ($this->getWorksheetIterator() as $sheet) {
  1034|             foreach ($sheet->getCoordinates(false) as $coordinate) {
  1035|                 $cell = $sheet->getCell($coordinate);
  1036|                 ++$countReferencesCellXf[$cell->getXfIndex()];
  1037|             }
  1038|             foreach ($sheet->getRowDimensions() as $rowDimension) {
  1039|                 if ($rowDimension->getXfIndex() !== null) {
  1040|                     ++$countReferencesCellXf[$rowDimension->getXfIndex()];
  1041|                 }
  1042|             }
  1043|             foreach ($sheet->getColumnDimensions() as $columnDimension) {
  1044|                 ++$countReferencesCellXf[$columnDimension->getXfIndex()];
  1045|             }
  1046|         }
  1047|         $countNeededCellXfs = 0;
  1048|         $map = [];
  1049|         foreach ($this->cellXfCollection as $index => $cellXf) {
  1050|             if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf
  1051|                 ++$countNeededCellXfs;
  1052|             } else {
  1053|                 unset($this->cellXfCollection[$index]);
  1054|             }
  1055|             $map[$index] = $countNeededCellXfs - 1;
  1056|         }
  1057|         $this->cellXfCollection = array_values($this->cellXfCollection);
  1058|         foreach ($this->cellXfCollection as $i => $cellXf) {
  1059|             $cellXf->setIndex($i);
  1060|         }
  1061|         if (empty($this->cellXfCollection)) {
  1062|             $this->cellXfCollection[] = new Style();
  1063|         }
  1064|         foreach ($this->getWorksheetIterator() as $sheet) {
  1065|             foreach ($sheet->getCoordinates(false) as $coordinate) {
  1066|                 $cell = $sheet->getCell($coordinate);
  1067|                 $cell->setXfIndex($map[$cell->getXfIndex()]);
  1068|             }
  1069|             foreach ($sheet->getRowDimensions() as $rowDimension) {
  1070|                 if ($rowDimension->getXfIndex() !== null) {
  1071|                     $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);
  1072|                 }
  1073|             }
  1074|             foreach ($sheet->getColumnDimensions() as $columnDimension) {
  1075|                 $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);
  1076|             }
  1077|             $sheet->garbageCollect();
  1078|         }
  1079|     }
  1080|     /**
  1081|      * Return the unique ID value assigned to this spreadsheet workbook.
  1082|      */
  1083|     public function getID(): string
  1084|     {
  1085|         return $this->uniqueID;
  1086|     }
  1087|     /**
  1088|      * Get the visibility of the horizonal scroll bar in the application.
  1089|      *
  1090|      * @return bool True if horizonal scroll bar is visible
  1091|      */
  1092|     public function getShowHorizontalScroll(): bool
  1093|     {
  1094|         return $this->showHorizontalScroll;
  1095|     }
  1096|     /**
  1097|      * Set the visibility of the horizonal scroll bar in the application.
  1098|      *
  1099|      * @param bool $showHorizontalScroll True if horizonal scroll bar is visible
  1100|      */
  1101|     public function setShowHorizontalScroll(bool $showHorizontalScroll): void
  1102|     {
  1103|         $this->showHorizontalScroll = (bool) $showHorizontalScroll;
  1104|     }
  1105|     /**
  1106|      * Get the visibility of the vertical scroll bar in the application.
  1107|      *
  1108|      * @return bool True if vertical scroll bar is visible
  1109|      */
  1110|     public function getShowVerticalScroll(): bool
  1111|     {
  1112|         return $this->showVerticalScroll;
  1113|     }
  1114|     /**
  1115|      * Set the visibility of the vertical scroll bar in the application.
  1116|      *
  1117|      * @param bool $showVerticalScroll True if vertical scroll bar is visible
  1118|      */
  1119|     public function setShowVerticalScroll(bool $showVerticalScroll): void
  1120|     {
  1121|         $this->showVerticalScroll = (bool) $showVerticalScroll;
  1122|     }
  1123|     /**
  1124|      * Get the visibility of the sheet tabs in the application.
  1125|      *
  1126|      * @return bool True if the sheet tabs are visible
  1127|      */
  1128|     public function getShowSheetTabs(): bool
  1129|     {
  1130|         return $this->showSheetTabs;
  1131|     }
  1132|     /**
  1133|      * Set the visibility of the sheet tabs  in the application.
  1134|      *
  1135|      * @param bool $showSheetTabs True if sheet tabs are visible
  1136|      */
  1137|     public function setShowSheetTabs(bool $showSheetTabs): void
  1138|     {
  1139|         $this->showSheetTabs = (bool) $showSheetTabs;
  1140|     }
  1141|     /**
  1142|      * Return whether the workbook window is minimized.
  1143|      *
  1144|      * @return bool true if workbook window is minimized
  1145|      */
  1146|     public function getMinimized(): bool
  1147|     {
  1148|         return $this->minimized;
  1149|     }
  1150|     /**
  1151|      * Set whether the workbook window is minimized.
  1152|      *
  1153|      * @param bool $minimized true if workbook window is minimized
  1154|      */
  1155|     public function setMinimized(bool $minimized): void
  1156|     {
  1157|         $this->minimized = (bool) $minimized;
  1158|     }
  1159|     /**
  1160|      * Return whether to group dates when presenting the user with
  1161|      * filtering optiomd in the user interface.
  1162|      *
  1163|      * @return bool true if workbook window is minimized
  1164|      */
  1165|     public function getAutoFilterDateGrouping(): bool
  1166|     {
  1167|         return $this->autoFilterDateGrouping;
  1168|     }
  1169|     /**
  1170|      * Set whether to group dates when presenting the user with
  1171|      * filtering optiomd in the user interface.
  1172|      *
  1173|      * @param bool $autoFilterDateGrouping true if workbook window is minimized
  1174|      */
  1175|     public function setAutoFilterDateGrouping(bool $autoFilterDateGrouping): void
  1176|     {
  1177|         $this->autoFilterDateGrouping = (bool) $autoFilterDateGrouping;
  1178|     }
  1179|     /**
  1180|      * Return the first sheet in the book view.
  1181|      *
  1182|      * @return int First sheet in book view
  1183|      */
  1184|     public function getFirstSheetIndex(): int
  1185|     {
  1186|         return $this->firstSheetIndex;
  1187|     }
  1188|     /**
  1189|      * Set the first sheet in the book view.
  1190|      *
  1191|      * @param int $firstSheetIndex First sheet in book view
  1192|      */
  1193|     public function setFirstSheetIndex(int $firstSheetIndex): void
  1194|     {
  1195|         if ($firstSheetIndex >= 0) {
  1196|             $this->firstSheetIndex = (int) $firstSheetIndex;
  1197|         } else {
  1198|             throw new Exception('First sheet index must be a positive integer.');
  1199|         }
  1200|     }
  1201|     /**
  1202|      * Return the visibility status of the workbook.
  1203|      *
  1204|      * This may be one of the following three values:
  1205|      * - visibile
  1206|      *
  1207|      * @return string Visible status
  1208|      */
  1209|     public function getVisibility(): string
  1210|     {
  1211|         return $this->visibility;
  1212|     }
  1213|     /**
  1214|      * Set the visibility status of the workbook.
  1215|      *
  1216|      * Valid values are:
  1217|      *  - 'visible' (self::VISIBILITY_VISIBLE):
  1218|      *       Workbook window is visible
  1219|      *  - 'hidden' (self::VISIBILITY_HIDDEN):
  1220|      *       Workbook window is hidden, but can be shown by the user
  1221|      *       via the user interface
  1222|      *  - 'veryHidden' (self::VISIBILITY_VERY_HIDDEN):
  1223|      *       Workbook window is hidden and cannot be shown in the
  1224|      *       user interface.
  1225|      *
  1226|      * @param null|string $visibility visibility status of the workbook
  1227|      */
  1228|     public function setVisibility(?string $visibility): void
  1229|     {
  1230|         if ($visibility === null) {
  1231|             $visibility = self::VISIBILITY_VISIBLE;
  1232|         }
  1233|         if (in_array($visibility, self::WORKBOOK_VIEW_VISIBILITY_VALUES)) {
  1234|             $this->visibility = $visibility;
  1235|         } else {
  1236|             throw new Exception('Invalid visibility value.');
  1237|         }
  1238|     }
  1239|     /**
  1240|      * Get the ratio between the workbook tabs bar and the horizontal scroll bar.
  1241|      * TabRatio is assumed to be out of 1000 of the horizontal window width.
  1242|      *
  1243|      * @return int Ratio between the workbook tabs bar and the horizontal scroll bar
  1244|      */
  1245|     public function getTabRatio(): int
  1246|     {
  1247|         return $this->tabRatio;
  1248|     }
  1249|     /**
  1250|      * Set the ratio between the workbook tabs bar and the horizontal scroll bar
  1251|      * TabRatio is assumed to be out of 1000 of the horizontal window width.
  1252|      *
  1253|      * @param int $tabRatio Ratio between the tabs bar and the horizontal scroll bar
  1254|      */
  1255|     public function setTabRatio(int $tabRatio): void
  1256|     {
  1257|         if ($tabRatio >= 0 && $tabRatio <= 1000) {
  1258|             $this->tabRatio = (int) $tabRatio;
  1259|         } else {
  1260|             throw new Exception('Tab ratio must be between 0 and 1000.');
  1261|         }
  1262|     }
  1263|     public function reevaluateAutoFilters(bool $resetToMax): void
  1264|     {
  1265|         foreach ($this->workSheetCollection as $sheet) {
  1266|             $filter = $sheet->getAutoFilter();
  1267|             if (!empty($filter->getRange())) {
  1268|                 if ($resetToMax) {
  1269|                     $filter->setRangeToMaxRow();
  1270|                 }
  1271|                 $filter->showHideRows();
  1272|             }
  1273|         }
  1274|     }
  1275|     /**
  1276|      * @throws Exception
  1277|      */
  1278|     public function __serialize(): array
  1279|     {
  1280|         throw new Exception('Spreadsheet objects cannot be serialized');
  1281|     }
  1282|     /**
  1283|      * @throws Exception
  1284|      */
  1285|     public function jsonSerialize(): mixed
  1286|     {
  1287|         throw new Exception('Spreadsheet objects cannot be json encoded');
  1288|     }
  1289|     public function resetThemeFonts(): void
  1290|     {
  1291|         $majorFontLatin = $this->theme->getMajorFontLatin();
  1292|         $minorFontLatin = $this->theme->getMinorFontLatin();
  1293|         foreach ($this->cellXfCollection as $cellStyleXf) {
  1294|             $scheme = $cellStyleXf->getFont()->getScheme();
  1295|             if ($scheme === 'major') {
  1296|                 $cellStyleXf->getFont()->setName($majorFontLatin)->setScheme($scheme);
  1297|             } elseif ($scheme === 'minor') {
  1298|                 $cellStyleXf->getFont()->setName($minorFontLatin)->setScheme($scheme);
  1299|             }
  1300|         }
  1301|         foreach ($this->cellStyleXfCollection as $cellStyleXf) {
  1302|             $scheme = $cellStyleXf->getFont()->getScheme();
  1303|             if ($scheme === 'major') {
  1304|                 $cellStyleXf->getFont()->setName($majorFontLatin)->setScheme($scheme);
  1305|             } elseif ($scheme === 'minor') {
  1306|                 $cellStyleXf->getFont()->setName($minorFontLatin)->setScheme($scheme);
  1307|             }
  1308|         }
  1309|     }
  1310|     public function getTableByName(string $tableName): ?Table
  1311|     {
  1312|         $table = null;
  1313|         foreach ($this->workSheetCollection as $sheet) {
  1314|             $table = $sheet->getTableByName($tableName);
  1315|             if ($table !== null) {
  1316|                 break;
  1317|             }
  1318|         }
  1319|         return $table;
  1320|     }
  1321|     /**
  1322|      * @return bool Success or failure
  1323|      */
  1324|     public function setExcelCalendar(int $baseYear): bool
  1325|     {
  1326|         if (($baseYear === Date::CALENDAR_WINDOWS_1900) || ($baseYear === Date::CALENDAR_MAC_1904)) {
  1327|             $this->excelCalendar = $baseYear;
  1328|             return true;
  1329|         }
  1330|         return false;
  1331|     }
  1332|     /**
  1333|      * @return int Excel base date (1900 or 1904)
  1334|      */
  1335|     public function getExcelCalendar(): int
  1336|     {
  1337|         return $this->excelCalendar;
  1338|     }
  1339| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/ConditionalFormatting/CellMatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-206 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception;
     5| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     6| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     7| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     8| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     9| class CellMatcher
    10| {
    11|     public const COMPARISON_OPERATORS = [
    12|         Conditional::OPERATOR_EQUAL => '=',
    13|         Conditional::OPERATOR_GREATERTHAN => '>',
    14|         Conditional::OPERATOR_GREATERTHANOREQUAL => '>=',
    15|         Conditional::OPERATOR_LESSTHAN => '<',
    16|         Conditional::OPERATOR_LESSTHANOREQUAL => '<=',
    17|         Conditional::OPERATOR_NOTEQUAL => '<>',
    18|     ];
    19|     public const COMPARISON_RANGE_OPERATORS = [
    20|         Conditional::OPERATOR_BETWEEN => 'IF(AND(A1>=%s,A1<=%s),TRUE,FALSE)',
    21|         Conditional::OPERATOR_NOTBETWEEN => 'IF(AND(A1>=%s,A1<=%s),FALSE,TRUE)',
    22|     ];
    23|     public const COMPARISON_DUPLICATES_OPERATORS = [
    24|         Conditional::CONDITION_DUPLICATES => "COUNTIF('%s'!%s,%s)>1",
    25|         Conditional::CONDITION_UNIQUE => "COUNTIF('%s'!%s,%s)=1",
    26|     ];
    27|     protected Cell $cell;
    28|     protected int $cellRow;
    29|     protected Worksheet $worksheet;
    30|     protected int $cellColumn;
    31|     protected string $conditionalRange;
    32|     protected string $referenceCell;
    33|     protected int $referenceRow;
    34|     protected int $referenceColumn;
    35|     protected Calculation $engine;
    36|     public function __construct(Cell $cell, string $conditionalRange)
    37|     {
    38|         $this->cell = $cell;
    39|         $this->worksheet = $cell->getWorksheet();
    40|         [$this->cellColumn, $this->cellRow] = Coordinate::indexesFromString($this->cell->getCoordinate());
    41|         $this->setReferenceCellForExpressions($conditionalRange);
    42|         $this->engine = Calculation::getInstance($this->worksheet->getParent());
    43|     }
    44|     protected function setReferenceCellForExpressions(string $conditionalRange): void
    45|     {
    46|         $conditionalRange = Coordinate::splitRange(str_replace('$', '', strtoupper($conditionalRange)));
    47|         [$this->referenceCell] = $conditionalRange[0];
    48|         [$this->referenceColumn, $this->referenceRow] = Coordinate::indexesFromString($this->referenceCell);
    49|         $rangeSets = [];
    50|         foreach ($conditionalRange as $rangeSet) {
    51|             $absoluteRangeSet = array_map(
    52|                 [Coordinate::class, 'absoluteCoordinate'],
    53|                 $rangeSet
    54|             );
    55|             $rangeSets[] = implode(':', $absoluteRangeSet);
    56|         }
    57|         $this->conditionalRange = implode(',', $rangeSets);
    58|     }
    59|     public function evaluateConditional(Conditional $conditional): bool
    60|     {
    61|         $cellColumn = Coordinate::stringFromColumnIndex($this->cellColumn);
    62|         $cellAddress = "{$cellColumn}{$this->cellRow}";
    63|         $this->cell = $this->worksheet->getCell($cellAddress);
    64|         return match ($conditional->getConditionType()) {
    65|             Conditional::CONDITION_CELLIS => $this->processOperatorComparison($conditional),
    66|             Conditional::CONDITION_DUPLICATES, Conditional::CONDITION_UNIQUE => $this->processDuplicatesComparison($conditional),
    67|             Conditional::CONDITION_CONTAINSTEXT,
    68|             Conditional::CONDITION_NOTCONTAINSTEXT,
    69|             Conditional::CONDITION_BEGINSWITH,
    70|             Conditional::CONDITION_ENDSWITH,
    71|             Conditional::CONDITION_CONTAINSBLANKS,
    72|             Conditional::CONDITION_NOTCONTAINSBLANKS,
    73|             Conditional::CONDITION_CONTAINSERRORS,
    74|             Conditional::CONDITION_NOTCONTAINSERRORS,
    75|             Conditional::CONDITION_TIMEPERIOD,
    76|             Conditional::CONDITION_EXPRESSION => $this->processExpression($conditional),
    77|             default => false,
    78|         };
    79|     }
    80|     protected function wrapValue(mixed $value): float|int|string
    81|     {
    82|         if (!is_numeric($value)) {
    83|             if (is_bool($value)) {
    84|                 return $value ? 'TRUE' : 'FALSE';
    85|             } elseif ($value === null) {
    86|                 return 'NULL';
    87|             }
    88|             return '"' . $value . '"';
    89|         }
    90|         return $value;
    91|     }
    92|     protected function wrapCellValue(): float|int|string
    93|     {
    94|         return $this->wrapValue($this->cell->getCalculatedValue());
    95|     }
    96|     protected function conditionCellAdjustment(array $matches): float|int|string
    97|     {
    98|         $column = $matches[6];
    99|         $row = $matches[7];
   100|         if (!str_contains($column, '$')) {
   101|             $column = Coordinate::columnIndexFromString($column);
   102|             $column += $this->cellColumn - $this->referenceColumn;
   103|             $column = Coordinate::stringFromColumnIndex($column);
   104|         }
   105|         if (!str_contains($row, '$')) {
   106|             $row += $this->cellRow - $this->referenceRow;
   107|         }
   108|         if (!empty($matches[4])) {
   109|             $worksheet = $this->worksheet->getParentOrThrow()->getSheetByName(trim($matches[4], "'"));
   110|             if ($worksheet === null) {
   111|                 return $this->wrapValue(null);
   112|             }
   113|             return $this->wrapValue(
   114|                 $worksheet
   115|                     ->getCell(str_replace('$', '', "{$column}{$row}"))
   116|                     ->getCalculatedValue()
   117|             );
   118|         }
   119|         return $this->wrapValue(
   120|             $this->worksheet
   121|                 ->getCell(str_replace('$', '', "{$column}{$row}"))
   122|                 ->getCalculatedValue()
   123|         );
   124|     }
   125|     protected function cellConditionCheck(string $condition): string
   126|     {
   127|         $splitCondition = explode(Calculation::FORMULA_STRING_QUOTE, $condition);
   128|         $i = false;
   129|         foreach ($splitCondition as &$value) {
   130|             $i = $i === false;
   131|             if ($i) {
   132|                 $value = (string) preg_replace_callback(
   133|                     '/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i',
   134|                     [$this, 'conditionCellAdjustment'],
   135|                     $value
   136|                 );
   137|             }
   138|         }
   139|         unset($value);
   140|         return implode(Calculation::FORMULA_STRING_QUOTE, $splitCondition);
   141|     }
   142|     protected function adjustConditionsForCellReferences(array $conditions): array
   143|     {
   144|         return array_map(
   145|             [$this, 'cellConditionCheck'],
   146|             $conditions
   147|         );
   148|     }
   149|     protected function processOperatorComparison(Conditional $conditional): bool
   150|     {
   151|         if (array_key_exists($conditional->getOperatorType(), self::COMPARISON_RANGE_OPERATORS)) {
   152|             return $this->processRangeOperator($conditional);
   153|         }
   154|         $operator = self::COMPARISON_OPERATORS[$conditional->getOperatorType()];
   155|         $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
   156|         $expression = sprintf('%s%s%s', (string) $this->wrapCellValue(), $operator, (string) array_pop($conditions));
   157|         return $this->evaluateExpression($expression);
   158|     }
   159|     protected function processRangeOperator(Conditional $conditional): bool
   160|     {
   161|         $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
   162|         sort($conditions);
   163|         $expression = sprintf(
   164|             (string) preg_replace(
   165|                 '/\bA1\b/i',
   166|                 (string) $this->wrapCellValue(),
   167|                 self::COMPARISON_RANGE_OPERATORS[$conditional->getOperatorType()]
   168|             ),
   169|             ...$conditions
   170|         );
   171|         return $this->evaluateExpression($expression);
   172|     }
   173|     protected function processDuplicatesComparison(Conditional $conditional): bool
   174|     {
   175|         $worksheetName = $this->cell->getWorksheet()->getTitle();
   176|         $expression = sprintf(
   177|             self::COMPARISON_DUPLICATES_OPERATORS[$conditional->getConditionType()],
   178|             $worksheetName,
   179|             $this->conditionalRange,
   180|             $this->cellConditionCheck($this->cell->getCalculatedValueString())
   181|         );
   182|         return $this->evaluateExpression($expression);
   183|     }
   184|     protected function processExpression(Conditional $conditional): bool
   185|     {
   186|         $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
   187|         $expression = array_pop($conditions);
   188|         $expression = (string) preg_replace(
   189|             '/\b' . $this->referenceCell . '\b/i',
   190|             (string) $this->wrapCellValue(),
   191|             $expression
   192|         );
   193|         return $this->evaluateExpression($expression);
   194|     }
   195|     protected function evaluateExpression(string $expression): bool
   196|     {
   197|         $expression = "={$expression}";
   198|         try {
   199|             $this->engine->flushInstance();
   200|             $result = (bool) $this->engine->calculateFormula($expression);
   201|         } catch (Exception) {
   202|             return false;
   203|         }
   204|         return $result;
   205|     }
   206| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/CellValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-152 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Exception;
     5| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     6| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\CellMatcher;
     7| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     8| /**
     9|  * @method CellValue equals($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    10|  * @method CellValue notEquals($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    11|  * @method CellValue greaterThan($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    12|  * @method CellValue greaterThanOrEqual($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    13|  * @method CellValue lessThan($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    14|  * @method CellValue lessThanOrEqual($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    15|  * @method CellValue between($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    16|  * @method CellValue notBetween($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    17|  * @method CellValue and($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    18|  */
    19| class CellValue extends WizardAbstract implements WizardInterface
    20| {
    21|     protected const MAGIC_OPERATIONS = [
    22|         'equals' => Conditional::OPERATOR_EQUAL,
    23|         'notEquals' => Conditional::OPERATOR_NOTEQUAL,
    24|         'greaterThan' => Conditional::OPERATOR_GREATERTHAN,
    25|         'greaterThanOrEqual' => Conditional::OPERATOR_GREATERTHANOREQUAL,
    26|         'lessThan' => Conditional::OPERATOR_LESSTHAN,
    27|         'lessThanOrEqual' => Conditional::OPERATOR_LESSTHANOREQUAL,
    28|         'between' => Conditional::OPERATOR_BETWEEN,
    29|         'notBetween' => Conditional::OPERATOR_NOTBETWEEN,
    30|     ];
    31|     protected const SINGLE_OPERATORS = CellMatcher::COMPARISON_OPERATORS;
    32|     protected const RANGE_OPERATORS = CellMatcher::COMPARISON_RANGE_OPERATORS;
    33|     protected string $operator = Conditional::OPERATOR_EQUAL;
    34|     protected array $operand = [0];
    35|     /**
    36|      * @var string[]
    37|      */
    38|     protected array $operandValueType = [];
    39|     public function __construct(string $cellRange)
    40|     {
    41|         parent::__construct($cellRange);
    42|     }
    43|     protected function operator(string $operator): void
    44|     {
    45|         if ((!isset(self::SINGLE_OPERATORS[$operator])) && (!isset(self::RANGE_OPERATORS[$operator]))) {
    46|             throw new Exception('Invalid Operator for Cell Value CF Rule Wizard');
    47|         }
    48|         $this->operator = $operator;
    49|     }
    50|     protected function operand(int $index, mixed $operand, string $operandValueType = Wizard::VALUE_TYPE_LITERAL): void
    51|     {
    52|         if (is_string($operand)) {
    53|             $operand = $this->validateOperand($operand, $operandValueType);
    54|         }
    55|         $this->operand[$index] = $operand;
    56|         $this->operandValueType[$index] = $operandValueType;
    57|     }
    58|     /** @param null|bool|float|int|string $value value to be wrapped */
    59|     protected function wrapValue(mixed $value, string $operandValueType): float|int|string
    60|     {
    61|         if (!is_numeric($value) && !is_bool($value) && null !== $value) {
    62|             if ($operandValueType === Wizard::VALUE_TYPE_LITERAL) {
    63|                 return '"' . str_replace('"', '""', $value) . '"';
    64|             }
    65|             return $this->cellConditionCheck($value);
    66|         }
    67|         if (null === $value) {
    68|             $value = 'NULL';
    69|         } elseif (is_bool($value)) {
    70|             $value = $value ? 'TRUE' : 'FALSE';
    71|         }
    72|         return $value;
    73|     }
    74|     public function getConditional(): Conditional
    75|     {
    76|         if (!isset(self::RANGE_OPERATORS[$this->operator])) {
    77|             unset($this->operand[1], $this->operandValueType[1]);
    78|         }
    79|         $values = array_map([$this, 'wrapValue'], $this->operand, $this->operandValueType);
    80|         $conditional = new Conditional();
    81|         $conditional->setConditionType(Conditional::CONDITION_CELLIS);
    82|         $conditional->setOperatorType($this->operator);
    83|         $conditional->setConditions($values);
    84|         $conditional->setStyle($this->getStyle());
    85|         $conditional->setStopIfTrue($this->getStopIfTrue());
    86|         return $conditional;
    87|     }
    88|     protected static function unwrapString(string $condition): string
    89|     {
    90|         if ((str_starts_with($condition, '"')) && (str_starts_with(strrev($condition), '"'))) {
    91|             $condition = substr($condition, 1, -1);
    92|         }
    93|         return str_replace('""', '"', $condition);
    94|     }
    95|     public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
    96|     {
    97|         if ($conditional->getConditionType() !== Conditional::CONDITION_CELLIS) {
    98|             throw new Exception('Conditional is not a Cell Value CF Rule conditional');
    99|         }
   100|         $wizard = new self($cellRange);
   101|         $wizard->style = $conditional->getStyle();
   102|         $wizard->stopIfTrue = $conditional->getStopIfTrue();
   103|         $wizard->operator = $conditional->getOperatorType();
   104|         $conditions = $conditional->getConditions();
   105|         foreach ($conditions as $index => $condition) {
   106|             $operandValueType = Wizard::VALUE_TYPE_LITERAL;
   107|             if (is_string($condition)) {
   108|                 if (Calculation::keyInExcelConstants($condition)) {
   109|                     $condition = Calculation::getExcelConstants($condition);
   110|                 } elseif (preg_match('/^' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '$/i', $condition)) {
   111|                     $operandValueType = Wizard::VALUE_TYPE_CELL;
   112|                     $condition = self::reverseAdjustCellRef($condition, $cellRange);
   113|                 } elseif (
   114|                     preg_match('/\(\)/', $condition)
   115|                     || preg_match('/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i', $condition)
   116|                 ) {
   117|                     $operandValueType = Wizard::VALUE_TYPE_FORMULA;
   118|                     $condition = self::reverseAdjustCellRef($condition, $cellRange);
   119|                 } else {
   120|                     $condition = self::unwrapString($condition);
   121|                 }
   122|             }
   123|             $wizard->operand($index, $condition, $operandValueType);
   124|         }
   125|         return $wizard;
   126|     }
   127|     /**
   128|      * @param mixed[] $arguments
   129|      */
   130|     public function __call(string $methodName, array $arguments): self
   131|     {
   132|         if (!isset(self::MAGIC_OPERATIONS[$methodName]) && $methodName !== 'and') {
   133|             throw new Exception('Invalid Operator for Cell Value CF Rule Wizard');
   134|         }
   135|         if ($methodName === 'and') {
   136|             if (!isset(self::RANGE_OPERATORS[$this->operator])) {
   137|                 throw new Exception('AND Value is only appropriate for range operators');
   138|             }
   139|             $this->operand(1, ...$arguments);
   140|             return $this;
   141|         }
   142|         $this->operator(self::MAGIC_OPERATIONS[$methodName]);
   143|         if (count($arguments) < 2) {
   144|             $this->operand(0, $arguments[0]);
   145|         } else {
   146|             /** @var string */
   147|             $arg1 = $arguments[1];
   148|             $this->operand(0, $arguments[0], $arg1);
   149|         }
   150|         return $this;
   151|     }
   152| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/Expression.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     3| use PhpOffice\PhpSpreadsheet\Exception;
     4| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     5| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     6| /**
     7|  * @method Expression formula(string $expression)
     8|  */
     9| class Expression extends WizardAbstract implements WizardInterface
    10| {
    11|     protected string $expression;
    12|     public function __construct(string $cellRange)
    13|     {
    14|         parent::__construct($cellRange);
    15|     }
    16|     public function expression(string $expression): self
    17|     {
    18|         $expression = $this->validateOperand($expression, Wizard::VALUE_TYPE_FORMULA);
    19|         $this->expression = $expression;
    20|         return $this;
    21|     }
    22|     public function getConditional(): Conditional
    23|     {
    24|         $expression = $this->adjustConditionsForCellReferences([$this->expression]);
    25|         $conditional = new Conditional();
    26|         $conditional->setConditionType(Conditional::CONDITION_EXPRESSION);
    27|         $conditional->setConditions($expression);
    28|         $conditional->setStyle($this->getStyle());
    29|         $conditional->setStopIfTrue($this->getStopIfTrue());
    30|         return $conditional;
    31|     }
    32|     public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
    33|     {
    34|         if ($conditional->getConditionType() !== Conditional::CONDITION_EXPRESSION) {
    35|             throw new Exception('Conditional is not an Expression CF Rule conditional');
    36|         }
    37|         $wizard = new self($cellRange);
    38|         $wizard->style = $conditional->getStyle();
    39|         $wizard->stopIfTrue = $conditional->getStopIfTrue();
    40|         $wizard->expression = self::reverseAdjustCellRef((string) ($conditional->getConditions()[0]), $cellRange);
    41|         return $wizard;
    42|     }
    43|     /**
    44|      * @param string[] $arguments
    45|      */
    46|     public function __call(string $methodName, array $arguments): self
    47|     {
    48|         if ($methodName !== 'formula') {
    49|             throw new Exception('Invalid Operation for Expression CF Rule Wizard');
    50|         }
    51|         $this->expression(...$arguments);
    52|         return $this;
    53|     }
    54| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/TextValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-136 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Exception;
     5| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     6| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     7| /**
     8|  * @method TextValue contains(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
     9|  * @method TextValue doesNotContain(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    10|  * @method TextValue doesntContain(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    11|  * @method TextValue beginsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    12|  * @method TextValue startsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    13|  * @method TextValue endsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
    14|  */
    15| class TextValue extends WizardAbstract implements WizardInterface
    16| {
    17|     protected const MAGIC_OPERATIONS = [
    18|         'contains' => Conditional::OPERATOR_CONTAINSTEXT,
    19|         'doesntContain' => Conditional::OPERATOR_NOTCONTAINS,
    20|         'doesNotContain' => Conditional::OPERATOR_NOTCONTAINS,
    21|         'beginsWith' => Conditional::OPERATOR_BEGINSWITH,
    22|         'startsWith' => Conditional::OPERATOR_BEGINSWITH,
    23|         'endsWith' => Conditional::OPERATOR_ENDSWITH,
    24|     ];
    25|     protected const OPERATORS = [
    26|         Conditional::OPERATOR_CONTAINSTEXT => Conditional::CONDITION_CONTAINSTEXT,
    27|         Conditional::OPERATOR_NOTCONTAINS => Conditional::CONDITION_NOTCONTAINSTEXT,
    28|         Conditional::OPERATOR_BEGINSWITH => Conditional::CONDITION_BEGINSWITH,
    29|         Conditional::OPERATOR_ENDSWITH => Conditional::CONDITION_ENDSWITH,
    30|     ];
    31|     protected const EXPRESSIONS = [
    32|         Conditional::OPERATOR_CONTAINSTEXT => 'NOT(ISERROR(SEARCH(%s,%s)))',
    33|         Conditional::OPERATOR_NOTCONTAINS => 'ISERROR(SEARCH(%s,%s))',
    34|         Conditional::OPERATOR_BEGINSWITH => 'LEFT(%s,LEN(%s))=%s',
    35|         Conditional::OPERATOR_ENDSWITH => 'RIGHT(%s,LEN(%s))=%s',
    36|     ];
    37|     protected string $operator;
    38|     protected string $operand;
    39|     protected string $operandValueType;
    40|     public function __construct(string $cellRange)
    41|     {
    42|         parent::__construct($cellRange);
    43|     }
    44|     protected function operator(string $operator): void
    45|     {
    46|         if (!isset(self::OPERATORS[$operator])) {
    47|             throw new Exception('Invalid Operator for Text Value CF Rule Wizard');
    48|         }
    49|         $this->operator = $operator;
    50|     }
    51|     protected function operand(string $operand, string $operandValueType = Wizard::VALUE_TYPE_LITERAL): void
    52|     {
    53|         $operand = $this->validateOperand($operand, $operandValueType);
    54|         $this->operand = $operand;
    55|         $this->operandValueType = $operandValueType;
    56|     }
    57|     protected function wrapValue(string $value): string
    58|     {
    59|         return '"' . $value . '"';
    60|     }
    61|     protected function setExpression(): void
    62|     {
    63|         $operand = $this->operandValueType === Wizard::VALUE_TYPE_LITERAL
    64|             ? $this->wrapValue(str_replace('"', '""', $this->operand))
    65|             : $this->cellConditionCheck($this->operand);
    66|         if (
    67|             $this->operator === Conditional::OPERATOR_CONTAINSTEXT
    68|             || $this->operator === Conditional::OPERATOR_NOTCONTAINS
    69|         ) {
    70|             $this->expression = sprintf(self::EXPRESSIONS[$this->operator], $operand, $this->referenceCell);
    71|         } else {
    72|             $this->expression = sprintf(self::EXPRESSIONS[$this->operator], $this->referenceCell, $operand, $operand);
    73|         }
    74|     }
    75|     public function getConditional(): Conditional
    76|     {
    77|         $this->setExpression();
    78|         $conditional = new Conditional();
    79|         $conditional->setConditionType(self::OPERATORS[$this->operator]);
    80|         $conditional->setOperatorType($this->operator);
    81|         $conditional->setText(
    82|             $this->operandValueType !== Wizard::VALUE_TYPE_LITERAL
    83|                 ? $this->cellConditionCheck($this->operand)
    84|                 : $this->operand
    85|         );
    86|         $conditional->setConditions([$this->expression]);
    87|         $conditional->setStyle($this->getStyle());
    88|         $conditional->setStopIfTrue($this->getStopIfTrue());
    89|         return $conditional;
    90|     }
    91|     public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
    92|     {
    93|         if (!in_array($conditional->getConditionType(), self::OPERATORS, true)) {
    94|             throw new Exception('Conditional is not a Text Value CF Rule conditional');
    95|         }
    96|         $wizard = new self($cellRange);
    97|         $wizard->operator = (string) array_search($conditional->getConditionType(), self::OPERATORS, true);
    98|         $wizard->style = $conditional->getStyle();
    99|         $wizard->stopIfTrue = $conditional->getStopIfTrue();
   100|         $wizard->operandValueType = Wizard::VALUE_TYPE_LITERAL;
   101|         $condition = $conditional->getText();
   102|         if (preg_match('/^' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '$/i', $condition)) {
   103|             $wizard->operandValueType = Wizard::VALUE_TYPE_CELL;
   104|             $condition = self::reverseAdjustCellRef($condition, $cellRange);
   105|         } elseif (
   106|             preg_match('/\(\)/', $condition)
   107|             || preg_match('/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i', $condition)
   108|         ) {
   109|             $wizard->operandValueType = Wizard::VALUE_TYPE_FORMULA;
   110|         }
   111|         $wizard->operand = $condition;
   112|         return $wizard;
   113|     }
   114|     /**
   115|      * @param mixed[] $arguments
   116|      */
   117|     public function __call(string $methodName, array $arguments): self
   118|     {
   119|         if (!isset(self::MAGIC_OPERATIONS[$methodName])) {
   120|             throw new Exception('Invalid Operation for Text Value CF Rule Wizard');
   121|         }
   122|         $this->operator(self::MAGIC_OPERATIONS[$methodName]);
   123|         if (count($arguments) < 2) {
   124|             /** @var string */
   125|             $arg0 = $arguments[0];
   126|             $this->operand($arg0);
   127|         } else {
   128|             /** @var string */
   129|             $arg0 = $arguments[0];
   130|             /** @var string */
   131|             $arg1 = $arguments[1];
   132|             $this->operand($arg0, $arg1);
   133|         }
   134|         return $this;
   135|     }
   136| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/NumberFormat/DateFormatter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-159 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat;
     3| use PhpOffice\PhpSpreadsheet\Shared\Date;
     4| class DateFormatter
     5| {
     6|     /**
     7|      * Search/replace values to convert Excel date/time format masks to PHP format masks.
     8|      */
     9|     private const DATE_FORMAT_REPLACEMENTS = [
    10|         '\\' => '',
    11|         'am/pm' => 'A',
    12|         'e' => 'Y',
    13|         'yyyy' => 'Y',
    14|         'yy' => 'y',
    15|         'mmmmm' => 'M',
    16|         'mmmm' => 'F',
    17|         'mmm' => 'M',
    18|         ':mm' => ':i',
    19|         'mm:' => 'i:',
    20|         'dddd' => 'l',
    21|         'ddd' => 'D',
    22|         'dd' => 'd',
    23|         'd' => 'j',
    24|         '.s' => '',
    25|     ];
    26|     /**
    27|      * Search/replace values to convert Excel date/time format masks hours to PHP format masks (24 hr clock).
    28|      */
    29|     private const DATE_FORMAT_REPLACEMENTS24 = [
    30|         'hh' => 'H',
    31|         'h' => 'G',
    32|         'mm' => 'm',
    33|         'm' => 'n',
    34|         'ss' => 's',
    35|     ];
    36|     /**
    37|      * Search/replace values to convert Excel date/time format masks hours to PHP format masks (12 hr clock).
    38|      */
    39|     private const DATE_FORMAT_REPLACEMENTS12 = [
    40|         'hh' => 'h',
    41|         'h' => 'g',
    42|         'mm' => 'm',
    43|         'm' => 'n',
    44|         'ss' => 's',
    45|     ];
    46|     private const HOURS_IN_DAY = 24;
    47|     private const MINUTES_IN_DAY = 60 * self::HOURS_IN_DAY;
    48|     private const SECONDS_IN_DAY = 60 * self::MINUTES_IN_DAY;
    49|     private const INTERVAL_PRECISION = 10;
    50|     private const INTERVAL_LEADING_ZERO = [
    51|         '[hh]',
    52|         '[mm]',
    53|         '[ss]',
    54|     ];
    55|     private const INTERVAL_ROUND_PRECISION = [
    56|         '[h]' => self::INTERVAL_PRECISION,
    57|         '[hh]' => self::INTERVAL_PRECISION,
    58|         '[m]' => self::INTERVAL_PRECISION,
    59|         '[mm]' => self::INTERVAL_PRECISION,
    60|         '[s]' => 0,
    61|         '[ss]' => 0,
    62|     ];
    63|     private const INTERVAL_MULTIPLIER = [
    64|         '[h]' => self::HOURS_IN_DAY,
    65|         '[hh]' => self::HOURS_IN_DAY,
    66|         '[m]' => self::MINUTES_IN_DAY,
    67|         '[mm]' => self::MINUTES_IN_DAY,
    68|         '[s]' => self::SECONDS_IN_DAY,
    69|         '[ss]' => self::SECONDS_IN_DAY,
    70|     ];
    71|     private static function tryInterval(bool &$seekingBracket, string &$block, mixed $value, string $format): void
    72|     {
    73|         if ($seekingBracket) {
    74|             if (str_contains($block, $format)) {
    75|                 $hours = (string) (int) round(
    76|                     self::INTERVAL_MULTIPLIER[$format] * $value,
    77|                     self::INTERVAL_ROUND_PRECISION[$format]
    78|                 );
    79|                 if (strlen($hours) === 1 && in_array($format, self::INTERVAL_LEADING_ZERO, true)) {
    80|                     $hours = "0$hours";
    81|                 }
    82|                 $block = str_replace($format, $hours, $block);
    83|                 $seekingBracket = false;
    84|             }
    85|         }
    86|     }
    87|     /** @param float|int $value value to be formatted */
    88|     public static function format(mixed $value, string $format): string
    89|     {
    90|         $format = (string) preg_replace('/^(\[DBNum\d\])*(\[\$[^\]]*\])/i', '', $format);
    91|         /** @var callable $callable */
    92|         $callable = [self::class, 'setLowercaseCallback'];
    93|         $format = (string) preg_replace_callback('/(?:^|")([^"]*)(?:$|")/', $callable, $format);
    94|         $blocks = explode('"', $format);
    95|         foreach ($blocks as $key => &$block) {
    96|             if ($key % 2 == 0) {
    97|                 $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS);
    98|                 if (!strpos($block, 'A')) {
    99|                     $seekingBracket = true;
   100|                     self::tryInterval($seekingBracket, $block, $value, '[h]');
   101|                     self::tryInterval($seekingBracket, $block, $value, '[hh]');
   102|                     self::tryInterval($seekingBracket, $block, $value, '[mm]');
   103|                     self::tryInterval($seekingBracket, $block, $value, '[m]');
   104|                     self::tryInterval($seekingBracket, $block, $value, '[s]');
   105|                     self::tryInterval($seekingBracket, $block, $value, '[ss]');
   106|                     $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS24);
   107|                 } else {
   108|                     $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS12);
   109|                 }
   110|             }
   111|         }
   112|         $format = implode('"', $blocks);
   113|         /** @var callable $callback */
   114|         $callback = [self::class, 'escapeQuotesCallback'];
   115|         $format = (string) preg_replace_callback('/"(.*)"/U', $callback, $format);
   116|         $dateObj = Date::excelToDateTimeObject($value);
   117|         $format = (string) \preg_replace('/\\\\:m/', ':i', $format);
   118|         $microseconds = (int) $dateObj->format('u');
   119|         if (str_contains($format, ':s.000')) {
   120|             $milliseconds = (int) round($microseconds / 1000.0);
   121|             if ($milliseconds === 1000) {
   122|                 $milliseconds = 0;
   123|                 $dateObj->modify('+1 second');
   124|             }
   125|             $dateObj->modify("-$microseconds microseconds");
   126|             $format = str_replace(':s.000', ':s.' . sprintf('%03d', $milliseconds), $format);
   127|         } elseif (str_contains($format, ':s.00')) {
   128|             $centiseconds = (int) round($microseconds / 10000.0);
   129|             if ($centiseconds === 100) {
   130|                 $centiseconds = 0;
   131|                 $dateObj->modify('+1 second');
   132|             }
   133|             $dateObj->modify("-$microseconds microseconds");
   134|             $format = str_replace(':s.00', ':s.' . sprintf('%02d', $centiseconds), $format);
   135|         } elseif (str_contains($format, ':s.0')) {
   136|             $deciseconds = (int) round($microseconds / 100000.0);
   137|             if ($deciseconds === 10) {
   138|                 $deciseconds = 0;
   139|                 $dateObj->modify('+1 second');
   140|             }
   141|             $dateObj->modify("-$microseconds microseconds");
   142|             $format = str_replace(':s.0', ':s.' . sprintf('%1d', $deciseconds), $format);
   143|         } else { // no fractional second
   144|             if ($microseconds >= 500000) {
   145|                 $dateObj->modify('+1 second');
   146|             }
   147|             $dateObj->modify("-$microseconds microseconds");
   148|         }
   149|         return $dateObj->format($format);
   150|     }
   151|     private static function setLowercaseCallback(array $matches): string
   152|     {
   153|         return mb_strtolower($matches[0]);
   154|     }
   155|     private static function escapeQuotesCallback(array $matches): string
   156|     {
   157|         return '\\' . implode('\\', str_split($matches[1]));
   158|     }
   159| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/NumberFormat/NumberFormatter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-241 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat;
     3| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     4| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
     5| class NumberFormatter extends BaseFormatter
     6| {
     7|     private const NUMBER_REGEX = '/(0+)(\\.?)(0*)/';
     8|     private static function mergeComplexNumberFormatMasks(array $numbers, array $masks): array
     9|     {
    10|         $decimalCount = strlen($numbers[1]);
    11|         $postDecimalMasks = [];
    12|         do {
    13|             $tempMask = array_pop($masks);
    14|             if ($tempMask !== null) {
    15|                 $postDecimalMasks[] = $tempMask;
    16|                 $decimalCount -= strlen($tempMask);
    17|             }
    18|         } while ($tempMask !== null && $decimalCount > 0);
    19|         return [
    20|             implode('.', $masks),
    21|             implode('.', array_reverse($postDecimalMasks)),
    22|         ];
    23|     }
    24|     private static function processComplexNumberFormatMask(mixed $number, string $mask): string
    25|     {
    26|         /** @var string $result */
    27|         $result = $number;
    28|         $maskingBlockCount = preg_match_all('/0+/', $mask, $maskingBlocks, PREG_OFFSET_CAPTURE);
    29|         if ($maskingBlockCount > 1) {
    30|             $maskingBlocks = array_reverse($maskingBlocks[0]);
    31|             $offset = 0;
    32|             foreach ($maskingBlocks as $block) {
    33|                 $size = strlen($block[0]);
    34|                 $divisor = 10 ** $size;
    35|                 $offset = $block[1];
    36|                 /** @var float $numberFloat */
    37|                 $numberFloat = $number;
    38|                 $blockValue = sprintf("%0{$size}d", fmod($numberFloat, $divisor));
    39|                 $number = floor($numberFloat / $divisor);
    40|                 $mask = substr_replace($mask, $blockValue, $offset, $size);
    41|             }
    42|             /** @var string $numberString */
    43|             $numberString = $number;
    44|             if ($number > 0) {
    45|                 $mask = substr_replace($mask, $numberString, $offset, 0);
    46|             }
    47|             $result = $mask;
    48|         }
    49|         return self::makeString($result);
    50|     }
    51|     private static function complexNumberFormatMask(mixed $number, string $mask, bool $splitOnPoint = true): string
    52|     {
    53|         /** @var float $numberFloat */
    54|         $numberFloat = $number;
    55|         if ($splitOnPoint) {
    56|             $masks = explode('.', $mask);
    57|             if (count($masks) <= 2) {
    58|                 $decmask = $masks[1] ?? '';
    59|                 $decpos = substr_count($decmask, '0');
    60|                 $numberFloat = round($numberFloat, $decpos);
    61|             }
    62|         }
    63|         $sign = ($numberFloat < 0.0) ? '-' : '';
    64|         $number = self::f2s(abs($numberFloat));
    65|         if ($splitOnPoint && str_contains($mask, '.') && str_contains($number, '.')) {
    66|             $numbers = explode('.', $number);
    67|             $masks = explode('.', $mask);
    68|             if (count($masks) > 2) {
    69|                 $masks = self::mergeComplexNumberFormatMasks($numbers, $masks);
    70|             }
    71|             $integerPart = self::complexNumberFormatMask($numbers[0], $masks[0], false);
    72|             $numlen = strlen($numbers[1]);
    73|             $msklen = strlen($masks[1]);
    74|             if ($numlen < $msklen) {
    75|                 $numbers[1] .= str_repeat('0', $msklen - $numlen);
    76|             }
    77|             $decimalPart = strrev(self::complexNumberFormatMask(strrev($numbers[1]), strrev($masks[1]), false));
    78|             $decimalPart = substr($decimalPart, 0, $msklen);
    79|             return "{$sign}{$integerPart}.{$decimalPart}";
    80|         }
    81|         if (strlen($number) < strlen($mask)) {
    82|             $number = str_repeat('0', strlen($mask) - strlen($number)) . $number;
    83|         }
    84|         $result = self::processComplexNumberFormatMask($number, $mask);
    85|         return "{$sign}{$result}";
    86|     }
    87|     public static function f2s(float $f): string
    88|     {
    89|         return self::floatStringConvertScientific((string) $f);
    90|     }
    91|     public static function floatStringConvertScientific(string $s): string
    92|     {
    93|         if (preg_match('/^([+-])?([1-9])([.]([0-9]+))?[eE]([+-]?[0-9]+)$/', $s, $matches) === 1) {
    94|             $exponent = (int) $matches[5];
    95|             $sign = ($matches[1] === '-') ? '-' : '';
    96|             if ($exponent >= 0) {
    97|                 $exponentPlus1 = $exponent + 1;
    98|                 $out = $matches[2] . $matches[4];
    99|                 $len = strlen($out);
   100|                 if ($len < $exponentPlus1) {
   101|                     $out .= str_repeat('0', $exponentPlus1 - $len);
   102|                 }
   103|                 $out = substr($out, 0, $exponentPlus1) . ((strlen($out) === $exponentPlus1) ? '' : ('.' . substr($out, $exponentPlus1)));
   104|                 $s = "$sign$out";
   105|             } else {
   106|                 $s = $sign . '0.' . str_repeat('0', -$exponent - 1) . $matches[2] . $matches[4];
   107|             }
   108|         }
   109|         return $s;
   110|     }
   111|     private static function formatStraightNumericValue(mixed $value, string $format, array $matches, bool $useThousands): string
   112|     {
   113|         /** @var float $valueFloat */
   114|         $valueFloat = $value;
   115|         $left = $matches[1];
   116|         $dec = $matches[2];
   117|         $right = $matches[3];
   118|         $minWidth = strlen($left) + strlen($dec) + strlen($right);
   119|         if ($useThousands) {
   120|             $value = number_format(
   121|                 $valueFloat,
   122|                 strlen($right),
   123|                 StringHelper::getDecimalSeparator(),
   124|                 StringHelper::getThousandsSeparator()
   125|             );
   126|             return self::pregReplace(self::NUMBER_REGEX, $value, $format);
   127|         }
   128|         if (preg_match('/[0#]E[+-]0/i', $format)) {
   129|             $decimals = strlen($right);
   130|             $size = $decimals + 3;
   131|             return sprintf("%{$size}.{$decimals}E", $valueFloat);
   132|         } elseif (preg_match('/0([^\d\.]+)0/', $format) || substr_count($format, '.') > 1) {
   133|             if ($valueFloat == floor($valueFloat) && substr_count($format, '.') === 1) {
   134|                 $value *= 10 ** strlen(explode('.', $format)[1]);
   135|             }
   136|             $result = self::complexNumberFormatMask($value, $format);
   137|             if (str_contains($result, 'E')) {
   138|                 $result = self::f2s($valueFloat);
   139|             }
   140|             return $result;
   141|         }
   142|         $sprintf_pattern = "%0$minWidth." . strlen($right) . 'F';
   143|         /** @var float $valueFloat */
   144|         $valueFloat = $value;
   145|         $value = self::adjustSeparators(sprintf($sprintf_pattern, round($valueFloat, strlen($right))));
   146|         return self::pregReplace(self::NUMBER_REGEX, $value, $format);
   147|     }
   148|     /** @param float|int|numeric-string $value value to be formatted */
   149|     public static function format(mixed $value, string $format): string
   150|     {
   151|         $baseFormat = $format;
   152|         $useThousands = self::areThousandsRequired($format);
   153|         $scale = self::scaleThousandsMillions($format);
   154|         if (preg_match('/[#\?0]?.*[#\?0]\/(\?+|\d+|#)/', $format)) {
   155|             $format = (string) preg_replace('/[#0]+\//', '?/', $format);
   156|             $format = (string) preg_replace('/\/[#0]+/', '/?', $format);
   157|             $value = FractionFormatter::format($value, $format);
   158|         } else {
   159|             $value = $value / $scale;
   160|             $paddingPlaceholder = (str_contains($format, '?'));
   161|             $format = self::pregReplace('/[\\#\?](?=(?:[^"]*"[^"]*")*[^"]*\Z)/', '0', $format);
   162|             $format = self::pregReplace('/\[\$\-.*\]/', '', $format);
   163|             $n = '/\\[[^\\]]+\\]/';
   164|             $m = self::pregReplace($n, '', $format);
   165|             $format = self::makeString(str_replace(['"', '*'], '', $format));
   166|             if (preg_match(self::NUMBER_REGEX, $m, $matches)) {
   167|                 $value = self::formatStraightNumericValue($value, $format, $matches, $useThousands);
   168|                 if ($paddingPlaceholder === true) {
   169|                     $value = self::padValue($value, $baseFormat);
   170|                 }
   171|             } elseif ($format !== NumberFormat::FORMAT_GENERAL) {
   172|                 $value = self::makeString(str_replace('?', '', $format));
   173|             }
   174|         }
   175|         if (preg_match('/\[\$(.*)\]/u', $format, $m)) {
   176|             $currencyCode = $m[1];
   177|             [$currencyCode] = explode('-', $currencyCode);
   178|             if ($currencyCode == '') {
   179|                 $currencyCode = StringHelper::getCurrencyCode();
   180|             }
   181|             $value = self::pregReplace('/\[\$([^\]]*)\]/u', $currencyCode, (string) $value);
   182|         }
   183|         if (
   184|             (str_contains((string) $value, '0.'))
   185|             && ((str_contains($baseFormat, '#.')) || (str_contains($baseFormat, '?.')))
   186|         ) {
   187|             $value = preg_replace('/(\b)0\.|([^\d])0\./', '${2}.', (string) $value);
   188|         }
   189|         return (string) $value;
   190|     }
   191|     private static function makeString(array|string $value): string
   192|     {
   193|         return is_array($value) ? '' : "$value";
   194|     }
   195|     private static function pregReplace(string $pattern, string $replacement, string $subject): string
   196|     {
   197|         return self::makeString(preg_replace($pattern, $replacement, $subject) ?? '');
   198|     }
   199|     public static function padValue(string $value, string $baseFormat): string
   200|     {
   201|         $preDecimal = $postDecimal = '';
   202|         $pregArray = preg_split('/\.(?=(?:[^"]*"[^"]*")*[^"]*\Z)/miu', $baseFormat . '.?');
   203|         if (is_array($pregArray)) {
   204|             $preDecimal = $pregArray[0] ?? '';
   205|             $postDecimal = $pregArray[1] ?? '';
   206|         }
   207|         $length = strlen($value);
   208|         if (str_contains($postDecimal, '?')) {
   209|             $value = str_pad(rtrim($value, '0. '), $length, ' ', STR_PAD_RIGHT);
   210|         }
   211|         if (str_contains($preDecimal, '?')) {
   212|             $value = str_pad(ltrim($value, '0, '), $length, ' ', STR_PAD_LEFT);
   213|         }
   214|         return $value;
   215|     }
   216|     /**
   217|      * Find out if we need thousands separator
   218|      * This is indicated by a comma enclosed by a digit placeholders: #, 0 or ?
   219|      */
   220|     public static function areThousandsRequired(string &$format): bool
   221|     {
   222|         $useThousands = (bool) preg_match('/([#\?0]),([#\?0])/', $format);
   223|         if ($useThousands) {
   224|             $format = self::pregReplace('/([#\?0]),([#\?0])/', '${1}${2}', $format);
   225|         }
   226|         return $useThousands;
   227|     }
   228|     /**
   229|      * Scale thousands, millions,...
   230|      * This is indicated by a number of commas after a digit placeholder: #, or 0.0,, or ?,.
   231|      */
   232|     public static function scaleThousandsMillions(string &$format): int
   233|     {
   234|         $scale = 1; // same as no scale
   235|         if (preg_match('/(#|0|\?)(,+)/', $format, $matches)) {
   236|             $scale = 1000 ** strlen($matches[2]);
   237|             $format = self::pregReplace('/([#\?0]),+/', '${1}', $format);
   238|         }
   239|         return $scale;
   240|     }
   241| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Style/NumberFormat/Wizard/DateTime.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat\Wizard;
     3| class DateTime extends DateTimeWizard
     4| {
     5|     /**
     6|      * @var string[]
     7|      */
     8|     protected array $separators;
     9|     /**
    10|      * @var array<DateTimeWizard|string>
    11|      */
    12|     protected array $formatBlocks;
    13|     /**
    14|      * @param null|string|string[] $separators
    15|      *          If you want to use only a single format block, then pass a null as the separator argument
    16|      * @param DateTimeWizard|string ...$formatBlocks
    17|      */
    18|     public function __construct($separators, ...$formatBlocks)
    19|     {
    20|         $this->separators = $this->padSeparatorArray(
    21|             is_array($separators) ? $separators : [$separators],
    22|             count($formatBlocks) - 1
    23|         );
    24|         $this->formatBlocks = array_map([$this, 'mapFormatBlocks'], $formatBlocks);
    25|     }
    26|     private function mapFormatBlocks(DateTimeWizard|string $value): string
    27|     {
    28|         if ($value instanceof DateTimeWizard) {
    29|             return $value->__toString();
    30|         }
    31|         return $this->wrapLiteral($value);
    32|     }
    33|     public function format(): string
    34|     {
    35|         return implode('', array_map([$this, 'intersperse'], $this->formatBlocks, $this->separators));
    36|     }
    37| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/AutoFilter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-916 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use DateTime;
     4| use DateTimeZone;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     7| use PhpOffice\PhpSpreadsheet\Calculation\Internal\WildcardMatch;
     8| use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
     9| use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
    10| use PhpOffice\PhpSpreadsheet\Cell\CellRange;
    11| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
    12| use PhpOffice\PhpSpreadsheet\Exception;
    13| use PhpOffice\PhpSpreadsheet\Shared\Date;
    14| use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column\Rule;
    15| use Stringable;
    16| class AutoFilter implements Stringable
    17| {
    18|     /**
    19|      * Autofilter Worksheet.
    20|      */
    21|     private ?Worksheet $workSheet;
    22|     /**
    23|      * Autofilter Range.
    24|      */
    25|     private string $range;
    26|     /**
    27|      * Autofilter Column Ruleset.
    28|      *
    29|      * @var AutoFilter\Column[]
    30|      */
    31|     private array $columns = [];
    32|     private bool $evaluated = false;
    33|     public function getEvaluated(): bool
    34|     {
    35|         return $this->evaluated;
    36|     }
    37|     public function setEvaluated(bool $value): void
    38|     {
    39|         $this->evaluated = $value;
    40|     }
    41|     /**
    42|      * Create a new AutoFilter.
    43|      *
    44|      * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
    45|      *            A simple string containing a Cell range like 'A1:E10' is permitted
    46|      *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
    47|      *              or an AddressRange object.
    48|      */
    49|     public function __construct(AddressRange|string|array $range = '', ?Worksheet $worksheet = null)
    50|     {
    51|         if ($range !== '') {
    52|             [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
    53|         }
    54|         $this->range = $range ?? '';
    55|         $this->workSheet = $worksheet;
    56|     }
    57|     public function __destruct()
    58|     {
    59|         $this->workSheet = null;
    60|     }
    61|     /**
    62|      * Get AutoFilter Parent Worksheet.
    63|      */
    64|     public function getParent(): null|Worksheet
    65|     {
    66|         return $this->workSheet;
    67|     }
    68|     /**
    69|      * Set AutoFilter Parent Worksheet.
    70|      *
    71|      * @return $this
    72|      */
    73|     public function setParent(?Worksheet $worksheet = null): static
    74|     {
    75|         $this->evaluated = false;
    76|         $this->workSheet = $worksheet;
    77|         return $this;
    78|     }
    79|     /**
    80|      * Get AutoFilter Range.
    81|      */
    82|     public function getRange(): string
    83|     {
    84|         return $this->range;
    85|     }
    86|     /**
    87|      * Set AutoFilter Cell Range.
    88|      *
    89|      * @param AddressRange<CellRange>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
    90|      *            A simple string containing a Cell range like 'A1:E10' or a Cell address like 'A1' is permitted
    91|      *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
    92|      *              or an AddressRange object.
    93|      */
    94|     public function setRange(AddressRange|string|array $range = ''): self
    95|     {
    96|         $this->evaluated = false;
    97|         if ($range !== '') {
    98|             [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
    99|         }
   100|         if (empty($range)) {
   101|             $this->columns = [];
   102|             $this->range = '';
   103|             return $this;
   104|         }
   105|         if (ctype_digit($range) || ctype_alpha($range)) {
   106|             throw new Exception("{$range} is an invalid range for AutoFilter");
   107|         }
   108|         $this->range = $range;
   109|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   110|         foreach ($this->columns as $key => $value) {
   111|             $colIndex = Coordinate::columnIndexFromString($key);
   112|             if (($rangeStart[0] > $colIndex) || ($rangeEnd[0] < $colIndex)) {
   113|                 unset($this->columns[$key]);
   114|             }
   115|         }
   116|         return $this;
   117|     }
   118|     public function setRangeToMaxRow(): self
   119|     {
   120|         $this->evaluated = false;
   121|         if ($this->workSheet !== null) {
   122|             $thisrange = $this->range;
   123|             $range = (string) preg_replace('/\\d+$/', (string) $this->workSheet->getHighestRow(), $thisrange);
   124|             if ($range !== $thisrange) {
   125|                 $this->setRange($range);
   126|             }
   127|         }
   128|         return $this;
   129|     }
   130|     /**
   131|      * Get all AutoFilter Columns.
   132|      *
   133|      * @return AutoFilter\Column[]
   134|      */
   135|     public function getColumns(): array
   136|     {
   137|         return $this->columns;
   138|     }
   139|     /**
   140|      * Validate that the specified column is in the AutoFilter range.
   141|      *
   142|      * @param string $column Column name (e.g. A)
   143|      *
   144|      * @return int The column offset within the autofilter range
   145|      */
   146|     public function testColumnInRange(string $column): int
   147|     {
   148|         if (empty($this->range)) {
   149|             throw new Exception('No autofilter range is defined.');
   150|         }
   151|         $columnIndex = Coordinate::columnIndexFromString($column);
   152|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   153|         if (($rangeStart[0] > $columnIndex) || ($rangeEnd[0] < $columnIndex)) {
   154|             throw new Exception('Column is outside of current autofilter range.');
   155|         }
   156|         return $columnIndex - $rangeStart[0];
   157|     }
   158|     /**
   159|      * Get a specified AutoFilter Column Offset within the defined AutoFilter range.
   160|      *
   161|      * @param string $column Column name (e.g. A)
   162|      *
   163|      * @return int The offset of the specified column within the autofilter range
   164|      */
   165|     public function getColumnOffset(string $column): int
   166|     {
   167|         return $this->testColumnInRange($column);
   168|     }
   169|     /**
   170|      * Get a specified AutoFilter Column.
   171|      *
   172|      * @param string $column Column name (e.g. A)
   173|      */
   174|     public function getColumn(string $column): AutoFilter\Column
   175|     {
   176|         $this->testColumnInRange($column);
   177|         if (!isset($this->columns[$column])) {
   178|             $this->columns[$column] = new AutoFilter\Column($column, $this);
   179|         }
   180|         return $this->columns[$column];
   181|     }
   182|     /**
   183|      * Get a specified AutoFilter Column by it's offset.
   184|      *
   185|      * @param int $columnOffset Column offset within range (starting from 0)
   186|      */
   187|     public function getColumnByOffset(int $columnOffset): AutoFilter\Column
   188|     {
   189|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   190|         $pColumn = Coordinate::stringFromColumnIndex($rangeStart[0] + $columnOffset);
   191|         return $this->getColumn($pColumn);
   192|     }
   193|     /**
   194|      * Set AutoFilter.
   195|      *
   196|      * @param AutoFilter\Column|string $columnObjectOrString
   197|      *            A simple string containing a Column ID like 'A' is permitted
   198|      *
   199|      * @return $this
   200|      */
   201|     public function setColumn(AutoFilter\Column|string $columnObjectOrString): static
   202|     {
   203|         $this->evaluated = false;
   204|         if ((is_string($columnObjectOrString)) && (!empty($columnObjectOrString))) {
   205|             $column = $columnObjectOrString;
   206|         } elseif ($columnObjectOrString instanceof AutoFilter\Column) {
   207|             $column = $columnObjectOrString->getColumnIndex();
   208|         } else {
   209|             throw new Exception('Column is not within the autofilter range.');
   210|         }
   211|         $this->testColumnInRange($column);
   212|         if (is_string($columnObjectOrString)) {
   213|             $this->columns[$columnObjectOrString] = new AutoFilter\Column($columnObjectOrString, $this);
   214|         } else {
   215|             $columnObjectOrString->setParent($this);
   216|             $this->columns[$column] = $columnObjectOrString;
   217|         }
   218|         ksort($this->columns);
   219|         return $this;
   220|     }
   221|     /**
   222|      * Clear a specified AutoFilter Column.
   223|      *
   224|      * @param string $column Column name (e.g. A)
   225|      *
   226|      * @return $this
   227|      */
   228|     public function clearColumn(string $column): static
   229|     {
   230|         $this->evaluated = false;
   231|         $this->testColumnInRange($column);
   232|         if (isset($this->columns[$column])) {
   233|             unset($this->columns[$column]);
   234|         }
   235|         return $this;
   236|     }
   237|     /**
   238|      * Shift an AutoFilter Column Rule to a different column.
   239|      *
   240|      * Note: This method bypasses validation of the destination column to ensure it is within this AutoFilter range.
   241|      *        Nor does it verify whether any column rule already exists at $toColumn, but will simply override any existing value.
   242|      *        Use with caution.
   243|      *
   244|      * @param string $fromColumn Column name (e.g. A)
   245|      * @param string $toColumn Column name (e.g. B)
   246|      *
   247|      * @return $this
   248|      */
   249|     public function shiftColumn(string $fromColumn, string $toColumn): static
   250|     {
   251|         $this->evaluated = false;
   252|         $fromColumn = strtoupper($fromColumn);
   253|         $toColumn = strtoupper($toColumn);
   254|         if (($fromColumn !== null) && (isset($this->columns[$fromColumn])) && ($toColumn !== null)) {
   255|             $this->columns[$fromColumn]->setParent();
   256|             $this->columns[$fromColumn]->setColumnIndex($toColumn);
   257|             $this->columns[$toColumn] = $this->columns[$fromColumn];
   258|             $this->columns[$toColumn]->setParent($this);
   259|             unset($this->columns[$fromColumn]);
   260|             ksort($this->columns);
   261|         }
   262|         return $this;
   263|     }
   264|     /**
   265|      * Test if cell value is in the defined set of values.
   266|      *
   267|      * @param array{blanks: bool, filterValues: array<string,array<string,string>>} $dataSet
   268|      */
   269|     protected static function filterTestInSimpleDataSet(mixed $cellValue, array $dataSet): bool
   270|     {
   271|         $dataSetValues = $dataSet['filterValues'];
   272|         $blanks = $dataSet['blanks'];
   273|         if (($cellValue == '') || ($cellValue === null)) {
   274|             return $blanks;
   275|         }
   276|         return in_array($cellValue, $dataSetValues);
   277|     }
   278|     /**
   279|      * Test if cell value is in the defined set of Excel date values.
   280|      *
   281|      * @param array{blanks: bool, filterValues: array<string,array<string,string>>} $dataSet
   282|      */
   283|     protected static function filterTestInDateGroupSet(mixed $cellValue, array $dataSet): bool
   284|     {
   285|         $dateSet = $dataSet['filterValues'];
   286|         $blanks = $dataSet['blanks'];
   287|         if (($cellValue == '') || ($cellValue === null)) {
   288|             return $blanks;
   289|         }
   290|         $timeZone = new DateTimeZone('UTC');
   291|         if (is_numeric($cellValue)) {
   292|             $dateTime = Date::excelToDateTimeObject((float) $cellValue, $timeZone);
   293|             $cellValue = (float) $cellValue;
   294|             if ($cellValue < 1) {
   295|                 $dtVal = $dateTime->format('His');
   296|                 $dateSet = $dateSet['time'];
   297|             } elseif ($cellValue == floor($cellValue)) {
   298|                 $dtVal = $dateTime->format('Ymd');
   299|                 $dateSet = $dateSet['date'];
   300|             } else {
   301|                 $dtVal = $dateTime->format('YmdHis');
   302|                 $dateSet = $dateSet['dateTime'];
   303|             }
   304|             foreach ($dateSet as $dateValue) {
   305|                 if (str_starts_with($dtVal, $dateValue)) {
   306|                     return true;
   307|                 }
   308|             }
   309|         }
   310|         return false;
   311|     }
   312|     /**
   313|      * Test if cell value is within a set of values defined by a ruleset.
   314|      *
   315|      * @param mixed[] $ruleSet
   316|      */
   317|     protected static function filterTestInCustomDataSet(mixed $cellValue, array $ruleSet): bool
   318|     {
   319|         /** @var array[] $dataSet */
   320|         $dataSet = $ruleSet['filterRules'];
   321|         $join = $ruleSet['join'];
   322|         $customRuleForBlanks = $ruleSet['customRuleForBlanks'] ?? false;
   323|         if (!$customRuleForBlanks) {
   324|             if (($cellValue == '') || ($cellValue === null)) {
   325|                 return false;
   326|             }
   327|         }
   328|         $returnVal = ($join == AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND);
   329|         foreach ($dataSet as $rule) {
   330|             /** @var string $ruleValue */
   331|             $ruleValue = $rule['value'];
   332|             /** @var string $ruleOperator */
   333|             $ruleOperator = $rule['operator'];
   334|             /** @var string $cellValueString */
   335|             $cellValueString = $cellValue ?? '';
   336|             $retVal = false;
   337|             if (is_numeric($ruleValue)) {
   338|                 $numericTest = is_numeric($cellValue);
   339|                 switch ($ruleOperator) {
   340|                     case Rule::AUTOFILTER_COLUMN_RULE_EQUAL:
   341|                         $retVal = $numericTest && ($cellValue == $ruleValue);
   342|                         break;
   343|                     case Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL:
   344|                         $retVal = !$numericTest || ($cellValue != $ruleValue);
   345|                         break;
   346|                     case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN:
   347|                         $retVal = $numericTest && ($cellValue > $ruleValue);
   348|                         break;
   349|                     case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL:
   350|                         $retVal = $numericTest && ($cellValue >= $ruleValue);
   351|                         break;
   352|                     case Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN:
   353|                         $retVal = $numericTest && ($cellValue < $ruleValue);
   354|                         break;
   355|                     case Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL:
   356|                         $retVal = $numericTest && ($cellValue <= $ruleValue);
   357|                         break;
   358|                 }
   359|             } elseif ($ruleValue == '') {
   360|                 $retVal = match ($ruleOperator) {
   361|                     Rule::AUTOFILTER_COLUMN_RULE_EQUAL => ($cellValue == '') || ($cellValue === null),
   362|                     Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL => ($cellValue != '') && ($cellValue !== null),
   363|                     default => true,
   364|                 };
   365|             } else {
   366|                 switch ($ruleOperator) {
   367|                     case Rule::AUTOFILTER_COLUMN_RULE_EQUAL:
   368|                         $retVal = (bool) preg_match('/^' . $ruleValue . '$/i', $cellValueString);
   369|                         break;
   370|                     case Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL:
   371|                         $retVal = !((bool) preg_match('/^' . $ruleValue . '$/i', $cellValueString));
   372|                         break;
   373|                     case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN:
   374|                         $retVal = strcasecmp($cellValueString, $ruleValue) > 0;
   375|                         break;
   376|                     case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL:
   377|                         $retVal = strcasecmp($cellValueString, $ruleValue) >= 0;
   378|                         break;
   379|                     case Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN:
   380|                         $retVal = strcasecmp($cellValueString, $ruleValue) < 0;
   381|                         break;
   382|                     case Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL:
   383|                         $retVal = strcasecmp($cellValueString, $ruleValue) <= 0;
   384|                         break;
   385|                 }
   386|             }
   387|             switch ($join) {
   388|                 case AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR:
   389|                     $returnVal = $returnVal || $retVal;
   390|                     if ($returnVal) {
   391|                         return $returnVal;
   392|                     }
   393|                     break;
   394|                 case AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND:
   395|                     $returnVal = $returnVal && $retVal;
   396|                     break;
   397|             }
   398|         }
   399|         return $returnVal;
   400|     }
   401|     /**
   402|      * Test if cell date value is matches a set of values defined by a set of months.
   403|      *
   404|      * @param mixed[] $monthSet
   405|      */
   406|     protected static function filterTestInPeriodDateSet(mixed $cellValue, array $monthSet): bool
   407|     {
   408|         if (($cellValue == '') || ($cellValue === null)) {
   409|             return false;
   410|         }
   411|         if (is_numeric($cellValue)) {
   412|             $dateObject = Date::excelToDateTimeObject((float) $cellValue, new DateTimeZone('UTC'));
   413|             $dateValue = (int) $dateObject->format('m');
   414|             if (in_array($dateValue, $monthSet)) {
   415|                 return true;
   416|             }
   417|         }
   418|         return false;
   419|     }
   420|     private static function makeDateObject(int $year, int $month, int $day, int $hour = 0, int $minute = 0, int $second = 0): DateTime
   421|     {
   422|         $baseDate = new DateTime();
   423|         $baseDate->setDate($year, $month, $day);
   424|         $baseDate->setTime($hour, $minute, $second);
   425|         return $baseDate;
   426|     }
   427|     private const DATE_FUNCTIONS = [
   428|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH => 'dynamicLastMonth',
   429|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER => 'dynamicLastQuarter',
   430|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK => 'dynamicLastWeek',
   431|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR => 'dynamicLastYear',
   432|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH => 'dynamicNextMonth',
   433|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER => 'dynamicNextQuarter',
   434|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK => 'dynamicNextWeek',
   435|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR => 'dynamicNextYear',
   436|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH => 'dynamicThisMonth',
   437|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER => 'dynamicThisQuarter',
   438|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK => 'dynamicThisWeek',
   439|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR => 'dynamicThisYear',
   440|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_TODAY => 'dynamicToday',
   441|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW => 'dynamicTomorrow',
   442|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE => 'dynamicYearToDate',
   443|         Rule::AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY => 'dynamicYesterday',
   444|     ];
   445|     private static function dynamicLastMonth(): array
   446|     {
   447|         $maxval = new DateTime();
   448|         $year = (int) $maxval->format('Y');
   449|         $month = (int) $maxval->format('m');
   450|         $maxval->setDate($year, $month, 1);
   451|         $maxval->setTime(0, 0, 0);
   452|         $val = clone $maxval;
   453|         $val->modify('-1 month');
   454|         return [$val, $maxval];
   455|     }
   456|     private static function firstDayOfQuarter(): DateTime
   457|     {
   458|         $val = new DateTime();
   459|         $year = (int) $val->format('Y');
   460|         $month = (int) $val->format('m');
   461|         $month = 3 * intdiv($month - 1, 3) + 1;
   462|         $val->setDate($year, $month, 1);
   463|         $val->setTime(0, 0, 0);
   464|         return $val;
   465|     }
   466|     private static function dynamicLastQuarter(): array
   467|     {
   468|         $maxval = self::firstDayOfQuarter();
   469|         $val = clone $maxval;
   470|         $val->modify('-3 months');
   471|         return [$val, $maxval];
   472|     }
   473|     private static function dynamicLastWeek(): array
   474|     {
   475|         $val = new DateTime();
   476|         $val->setTime(0, 0, 0);
   477|         $dayOfWeek = (int) $val->format('w'); // Sunday is 0
   478|         $subtract = $dayOfWeek + 7; // revert to prior Sunday
   479|         $val->modify("-$subtract days");
   480|         $maxval = clone $val;
   481|         $maxval->modify('+7 days');
   482|         return [$val, $maxval];
   483|     }
   484|     private static function dynamicLastYear(): array
   485|     {
   486|         $val = new DateTime();
   487|         $year = (int) $val->format('Y');
   488|         $val = self::makeDateObject($year - 1, 1, 1);
   489|         $maxval = self::makeDateObject($year, 1, 1);
   490|         return [$val, $maxval];
   491|     }
   492|     private static function dynamicNextMonth(): array
   493|     {
   494|         $val = new DateTime();
   495|         $year = (int) $val->format('Y');
   496|         $month = (int) $val->format('m');
   497|         $val->setDate($year, $month, 1);
   498|         $val->setTime(0, 0, 0);
   499|         $val->modify('+1 month');
   500|         $maxval = clone $val;
   501|         $maxval->modify('+1 month');
   502|         return [$val, $maxval];
   503|     }
   504|     private static function dynamicNextQuarter(): array
   505|     {
   506|         $val = self::firstDayOfQuarter();
   507|         $val->modify('+3 months');
   508|         $maxval = clone $val;
   509|         $maxval->modify('+3 months');
   510|         return [$val, $maxval];
   511|     }
   512|     private static function dynamicNextWeek(): array
   513|     {
   514|         $val = new DateTime();
   515|         $val->setTime(0, 0, 0);
   516|         $dayOfWeek = (int) $val->format('w'); // Sunday is 0
   517|         $add = 7 - $dayOfWeek; // move to next Sunday
   518|         $val->modify("+$add days");
   519|         $maxval = clone $val;
   520|         $maxval->modify('+7 days');
   521|         return [$val, $maxval];
   522|     }
   523|     private static function dynamicNextYear(): array
   524|     {
   525|         $val = new DateTime();
   526|         $year = (int) $val->format('Y');
   527|         $val = self::makeDateObject($year + 1, 1, 1);
   528|         $maxval = self::makeDateObject($year + 2, 1, 1);
   529|         return [$val, $maxval];
   530|     }
   531|     private static function dynamicThisMonth(): array
   532|     {
   533|         $baseDate = new DateTime();
   534|         $baseDate->setTime(0, 0, 0);
   535|         $year = (int) $baseDate->format('Y');
   536|         $month = (int) $baseDate->format('m');
   537|         $val = self::makeDateObject($year, $month, 1);
   538|         $maxval = clone $val;
   539|         $maxval->modify('+1 month');
   540|         return [$val, $maxval];
   541|     }
   542|     private static function dynamicThisQuarter(): array
   543|     {
   544|         $val = self::firstDayOfQuarter();
   545|         $maxval = clone $val;
   546|         $maxval->modify('+3 months');
   547|         return [$val, $maxval];
   548|     }
   549|     private static function dynamicThisWeek(): array
   550|     {
   551|         $val = new DateTime();
   552|         $val->setTime(0, 0, 0);
   553|         $dayOfWeek = (int) $val->format('w'); // Sunday is 0
   554|         $subtract = $dayOfWeek; // revert to Sunday
   555|         $val->modify("-$subtract days");
   556|         $maxval = clone $val;
   557|         $maxval->modify('+7 days');
   558|         return [$val, $maxval];
   559|     }
   560|     private static function dynamicThisYear(): array
   561|     {
   562|         $val = new DateTime();
   563|         $year = (int) $val->format('Y');
   564|         $val = self::makeDateObject($year, 1, 1);
   565|         $maxval = self::makeDateObject($year + 1, 1, 1);
   566|         return [$val, $maxval];
   567|     }
   568|     private static function dynamicToday(): array
   569|     {
   570|         $val = new DateTime();
   571|         $val->setTime(0, 0, 0);
   572|         $maxval = clone $val;
   573|         $maxval->modify('+1 day');
   574|         return [$val, $maxval];
   575|     }
   576|     private static function dynamicTomorrow(): array
   577|     {
   578|         $val = new DateTime();
   579|         $val->setTime(0, 0, 0);
   580|         $val->modify('+1 day');
   581|         $maxval = clone $val;
   582|         $maxval->modify('+1 day');
   583|         return [$val, $maxval];
   584|     }
   585|     private static function dynamicYearToDate(): array
   586|     {
   587|         $maxval = new DateTime();
   588|         $maxval->setTime(0, 0, 0);
   589|         $val = self::makeDateObject((int) $maxval->format('Y'), 1, 1);
   590|         $maxval->modify('+1 day');
   591|         return [$val, $maxval];
   592|     }
   593|     private static function dynamicYesterday(): array
   594|     {
   595|         $maxval = new DateTime();
   596|         $maxval->setTime(0, 0, 0);
   597|         $val = clone $maxval;
   598|         $val->modify('-1 day');
   599|         return [$val, $maxval];
   600|     }
   601|     /**
   602|      * Convert a dynamic rule daterange to a custom filter range expression for ease of calculation.
   603|      *
   604|      * @return mixed[]
   605|      */
   606|     private function dynamicFilterDateRange(string $dynamicRuleType, AutoFilter\Column &$filterColumn): array
   607|     {
   608|         $ruleValues = [];
   609|         $callBack = [__CLASS__, self::DATE_FUNCTIONS[$dynamicRuleType]]; // What if not found?
   610|         $val = $maxval = 0;
   611|         if (is_callable($callBack)) {
   612|             [$val, $maxval] = $callBack();
   613|         }
   614|         $val = Date::dateTimeToExcel($val);
   615|         $maxval = Date::dateTimeToExcel($maxval);
   616|         $filterColumn->setAttributes(['val' => $val, 'maxVal' => $maxval]);
   617|         $ruleValues[] = ['operator' => Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL, 'value' => $val];
   618|         $ruleValues[] = ['operator' => Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN, 'value' => $maxval];
   619|         return ['method' => 'filterTestInCustomDataSet', 'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND]];
   620|     }
   621|     /**
   622|      * Apply the AutoFilter rules to the AutoFilter Range.
   623|      */
   624|     private function calculateTopTenValue(string $columnID, int $startRow, int $endRow, ?string $ruleType, mixed $ruleValue): mixed
   625|     {
   626|         $range = $columnID . $startRow . ':' . $columnID . $endRow;
   627|         $retVal = null;
   628|         if ($this->workSheet !== null) {
   629|             $dataValues = Functions::flattenArray($this->workSheet->rangeToArray($range, null, true, false));
   630|             $dataValues = array_filter($dataValues);
   631|             if ($ruleType == Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP) {
   632|                 rsort($dataValues);
   633|             } else {
   634|                 sort($dataValues);
   635|             }
   636|             if (is_numeric($ruleValue)) {
   637|                 $ruleValue = (int) $ruleValue;
   638|             }
   639|             if ($ruleValue === null || is_int($ruleValue)) {
   640|                 $slice = array_slice($dataValues, 0, $ruleValue);
   641|                 $retVal = array_pop($slice);
   642|             }
   643|         }
   644|         return $retVal;
   645|     }
   646|     /**
   647|      * Apply the AutoFilter rules to the AutoFilter Range.
   648|      *
   649|      * @return $this
   650|      */
   651|     public function showHideRows(): static
   652|     {
   653|         if ($this->workSheet === null) {
   654|             return $this;
   655|         }
   656|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   657|         $this->workSheet->getRowDimension($rangeStart[1])->setVisible(true);
   658|         $columnFilterTests = [];
   659|         foreach ($this->columns as $columnID => $filterColumn) {
   660|             $rules = $filterColumn->getRules();
   661|             switch ($filterColumn->getFilterType()) {
   662|                 case AutoFilter\Column::AUTOFILTER_FILTERTYPE_FILTER:
   663|                     $ruleType = null;
   664|                     $ruleValues = [];
   665|                     foreach ($rules as $rule) {
   666|                         $ruleType = $rule->getRuleType();
   667|                         $ruleValues[] = $rule->getValue();
   668|                     }
   669|                     $blanks = false;
   670|                     $ruleDataSet = array_filter($ruleValues);
   671|                     if (count($ruleValues) != count($ruleDataSet)) {
   672|                         $blanks = true;
   673|                     }
   674|                     if ($ruleType == Rule::AUTOFILTER_RULETYPE_FILTER) {
   675|                         $columnFilterTests[$columnID] = [
   676|                             'method' => 'filterTestInSimpleDataSet',
   677|                             'arguments' => ['filterValues' => $ruleDataSet, 'blanks' => $blanks],
   678|                         ];
   679|                     } elseif ($ruleType !== null) {
   680|                         $arguments = [
   681|                             'date' => [],
   682|                             'time' => [],
   683|                             'dateTime' => [],
   684|                         ];
   685|                         foreach ($ruleDataSet as $ruleValue) {
   686|                             if (!is_array($ruleValue)) {
   687|                                 continue;
   688|                             }
   689|                             $date = $time = '';
   690|                             if (
   691|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR]))
   692|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR] !== '')
   693|                             ) {
   694|                                 $date .= sprintf('%04d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR]);
   695|                             }
   696|                             if (
   697|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH]))
   698|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH] != '')
   699|                             ) {
   700|                                 $date .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH]);
   701|                             }
   702|                             if (
   703|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY]))
   704|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY] !== '')
   705|                             ) {
   706|                                 $date .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY]);
   707|                             }
   708|                             if (
   709|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR]))
   710|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR] !== '')
   711|                             ) {
   712|                                 $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR]);
   713|                             }
   714|                             if (
   715|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE]))
   716|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE] !== '')
   717|                             ) {
   718|                                 $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE]);
   719|                             }
   720|                             if (
   721|                                 (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND]))
   722|                                 && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND] !== '')
   723|                             ) {
   724|                                 $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND]);
   725|                             }
   726|                             $dateTime = $date . $time;
   727|                             $arguments['date'][] = $date;
   728|                             $arguments['time'][] = $time;
   729|                             $arguments['dateTime'][] = $dateTime;
   730|                         }
   731|                         $arguments['date'] = array_filter($arguments['date']);
   732|                         $arguments['time'] = array_filter($arguments['time']);
   733|                         $arguments['dateTime'] = array_filter($arguments['dateTime']);
   734|                         $columnFilterTests[$columnID] = [
   735|                             'method' => 'filterTestInDateGroupSet',
   736|                             'arguments' => ['filterValues' => $arguments, 'blanks' => $blanks],
   737|                         ];
   738|                     }
   739|                     break;
   740|                 case AutoFilter\Column::AUTOFILTER_FILTERTYPE_CUSTOMFILTER:
   741|                     $customRuleForBlanks = true;
   742|                     $ruleValues = [];
   743|                     foreach ($rules as $rule) {
   744|                         $ruleValue = $rule->getValue();
   745|                         if (!is_array($ruleValue) && !is_numeric($ruleValue)) {
   746|                             $ruleValue = WildcardMatch::wildcard($ruleValue);
   747|                             if (trim($ruleValue) == '') {
   748|                                 $customRuleForBlanks = true;
   749|                                 $ruleValue = trim($ruleValue);
   750|                             }
   751|                         }
   752|                         $ruleValues[] = ['operator' => $rule->getOperator(), 'value' => $ruleValue];
   753|                     }
   754|                     $join = $filterColumn->getJoin();
   755|                     $columnFilterTests[$columnID] = [
   756|                         'method' => 'filterTestInCustomDataSet',
   757|                         'arguments' => ['filterRules' => $ruleValues, 'join' => $join, 'customRuleForBlanks' => $customRuleForBlanks],
   758|                     ];
   759|                     break;
   760|                 case AutoFilter\Column::AUTOFILTER_FILTERTYPE_DYNAMICFILTER:
   761|                     $ruleValues = [];
   762|                     foreach ($rules as $rule) {
   763|                         $dynamicRuleType = $rule->getGrouping();
   764|                         if (
   765|                             ($dynamicRuleType == Rule::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE)
   766|                             || ($dynamicRuleType == Rule::AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE)
   767|                         ) {
   768|                             $averageFormula = '=AVERAGE(' . $columnID . ($rangeStart[1] + 1) . ':' . $columnID . $rangeEnd[1] . ')';
   769|                             $average = Calculation::getInstance($this->workSheet->getParent())->calculateFormula($averageFormula, null, $this->workSheet->getCell('A1'));
   770|                             while (is_array($average)) {
   771|                                 $average = array_pop($average);
   772|                             }
   773|                             $operator = ($dynamicRuleType === Rule::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE)
   774|                                 ? Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN
   775|                                 : Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN;
   776|                             $ruleValues[] = [
   777|                                 'operator' => $operator,
   778|                                 'value' => $average,
   779|                             ];
   780|                             $columnFilterTests[$columnID] = [
   781|                                 'method' => 'filterTestInCustomDataSet',
   782|                                 'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR],
   783|                             ];
   784|                         } else {
   785|                             if ($dynamicRuleType[0] == 'M' || $dynamicRuleType[0] == 'Q') {
   786|                                 $periodType = '';
   787|                                 $period = 0;
   788|                                 sscanf($dynamicRuleType, '%[A-Z]%d', $periodType, $period);
   789|                                 if ($periodType == 'M') {
   790|                                     $ruleValues = [$period];
   791|                                 } else {
   792|                                     --$period;
   793|                                     $periodEnd = (1 + $period) * 3;
   794|                                     $periodStart = 1 + $period * 3;
   795|                                     $ruleValues = range($periodStart, $periodEnd);
   796|                                 }
   797|                                 $columnFilterTests[$columnID] = [
   798|                                     'method' => 'filterTestInPeriodDateSet',
   799|                                     'arguments' => $ruleValues,
   800|                                 ];
   801|                                 $filterColumn->setAttributes([]);
   802|                             } else {
   803|                                 $columnFilterTests[$columnID] = $this->dynamicFilterDateRange($dynamicRuleType, $filterColumn);
   804|                                 break;
   805|                             }
   806|                         }
   807|                     }
   808|                     break;
   809|                 case AutoFilter\Column::AUTOFILTER_FILTERTYPE_TOPTENFILTER:
   810|                     $ruleValues = [];
   811|                     $dataRowCount = $rangeEnd[1] - $rangeStart[1];
   812|                     $toptenRuleType = null;
   813|                     $ruleValue = 0;
   814|                     $ruleOperator = null;
   815|                     foreach ($rules as $rule) {
   816|                         $toptenRuleType = $rule->getGrouping();
   817|                         $ruleValue = $rule->getValue();
   818|                         $ruleOperator = $rule->getOperator();
   819|                     }
   820|                     if (is_numeric($ruleValue) && $ruleOperator === Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT) {
   821|                         $ruleValue = (int) floor((float) $ruleValue * ($dataRowCount / 100));
   822|                     }
   823|                     if (!is_array($ruleValue) && $ruleValue < 1) {
   824|                         $ruleValue = 1;
   825|                     }
   826|                     if (!is_array($ruleValue) && $ruleValue > 500) {
   827|                         $ruleValue = 500;
   828|                     }
   829|                     /** @var float|int|string */
   830|                     $maxVal = $this->calculateTopTenValue($columnID, $rangeStart[1] + 1, (int) $rangeEnd[1], $toptenRuleType, $ruleValue);
   831|                     $operator = ($toptenRuleType == Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP)
   832|                         ? Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL
   833|                         : Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL;
   834|                     $ruleValues[] = ['operator' => $operator, 'value' => $maxVal];
   835|                     $columnFilterTests[$columnID] = [
   836|                         'method' => 'filterTestInCustomDataSet',
   837|                         'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR],
   838|                     ];
   839|                     $filterColumn->setAttributes(['maxVal' => $maxVal]);
   840|                     break;
   841|             }
   842|         }
   843|         $rangeEnd[1] = $this->autoExtendRange($rangeStart[1], $rangeEnd[1]);
   844|         for ($row = $rangeStart[1] + 1; $row <= $rangeEnd[1]; ++$row) {
   845|             $result = true;
   846|             foreach ($columnFilterTests as $columnID => $columnFilterTest) {
   847|                 $cellValue = $this->workSheet->getCell($columnID . $row)->getCalculatedValue();
   848|                 /** @var callable */
   849|                 $temp = [self::class, $columnFilterTest['method']];
   850|                 /** @var bool */
   851|                 $result // $result && // phpstan says $result is always true here
   852|                     = call_user_func_array($temp, [$cellValue, $columnFilterTest['arguments']]);
   853|                 if (!$result) {
   854|                     break;
   855|                 }
   856|             }
   857|             if ($result === false || $this->workSheet->rowDimensionExists((int) $row)) {
   858|                 $this->workSheet->getRowDimension((int) $row)->setVisible($result);
   859|             }
   860|         }
   861|         $this->evaluated = true;
   862|         return $this;
   863|     }
   864|     /**
   865|      * Magic Range Auto-sizing.
   866|      * For a single row rangeSet, we follow MS Excel rules, and search for the first empty row to determine our range.
   867|      */
   868|     public function autoExtendRange(int $startRow, int $endRow): int
   869|     {
   870|         if ($startRow === $endRow && $this->workSheet !== null) {
   871|             try {
   872|                 $rowIterator = $this->workSheet->getRowIterator($startRow + 1);
   873|             } catch (Exception) {
   874|                 return $startRow;
   875|             }
   876|             foreach ($rowIterator as $row) {
   877|                 if ($row->isEmpty(CellIterator::TREAT_NULL_VALUE_AS_EMPTY_CELL | CellIterator::TREAT_EMPTY_STRING_AS_EMPTY_CELL) === true) {
   878|                     return $row->getRowIndex() - 1;
   879|                 }
   880|             }
   881|         }
   882|         return $endRow;
   883|     }
   884|     /**
   885|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   886|      */
   887|     public function __clone()
   888|     {
   889|         $vars = get_object_vars($this);
   890|         foreach ($vars as $key => $value) {
   891|             if (is_object($value)) {
   892|                 if ($key === 'workSheet') {
   893|                     $this->{$key} = null;
   894|                 } else {
   895|                     $this->{$key} = clone $value;
   896|                 }
   897|             } elseif ((is_array($value)) && ($key == 'columns')) {
   898|                 $this->{$key} = [];
   899|                 foreach ($value as $k => $v) {
   900|                     $this->{$key}[$k] = clone $v;
   901|                     $this->{$key}[$k]->setParent($this);
   902|                 }
   903|             } else {
   904|                 $this->{$key} = $value;
   905|             }
   906|         }
   907|     }
   908|     /**
   909|      * toString method replicates previous behavior by returning the range if object is
   910|      * referenced as a property of its parent.
   911|      */
   912|     public function __toString(): string
   913|     {
   914|         return (string) $this->range;
   915|     }
   916| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/AutoFilter/Column.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-318 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
     3| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     4| use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
     5| class Column
     6| {
     7|     const AUTOFILTER_FILTERTYPE_FILTER = 'filters';
     8|     const AUTOFILTER_FILTERTYPE_CUSTOMFILTER = 'customFilters';
     9|     const AUTOFILTER_FILTERTYPE_DYNAMICFILTER = 'dynamicFilter';
    10|     const AUTOFILTER_FILTERTYPE_TOPTENFILTER = 'top10';
    11|     /**
    12|      * Types of autofilter rules.
    13|      *
    14|      * @var string[]
    15|      */
    16|     private static array $filterTypes = [
    17|         self::AUTOFILTER_FILTERTYPE_FILTER,
    18|         self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER,
    19|         self::AUTOFILTER_FILTERTYPE_DYNAMICFILTER,
    20|         self::AUTOFILTER_FILTERTYPE_TOPTENFILTER,
    21|     ];
    22|     const AUTOFILTER_COLUMN_JOIN_AND = 'and';
    23|     const AUTOFILTER_COLUMN_JOIN_OR = 'or';
    24|     /**
    25|      * Join options for autofilter rules.
    26|      *
    27|      * @var string[]
    28|      */
    29|     private static array $ruleJoins = [
    30|         self::AUTOFILTER_COLUMN_JOIN_AND,
    31|         self::AUTOFILTER_COLUMN_JOIN_OR,
    32|     ];
    33|     /**
    34|      * Autofilter.
    35|      */
    36|     private ?AutoFilter $parent;
    37|     /**
    38|      * Autofilter Column Index.
    39|      */
    40|     private string $columnIndex;
    41|     /**
    42|      * Autofilter Column Filter Type.
    43|      */
    44|     private string $filterType = self::AUTOFILTER_FILTERTYPE_FILTER;
    45|     /**
    46|      * Autofilter Multiple Rules And/Or.
    47|      */
    48|     private string $join = self::AUTOFILTER_COLUMN_JOIN_OR;
    49|     /**
    50|      * Autofilter Column Rules.
    51|      *
    52|      * @var Column\Rule[]
    53|      */
    54|     private array $ruleset = [];
    55|     /**
    56|      * Autofilter Column Dynamic Attributes.
    57|      *
    58|      * @var (float|int|string)[]
    59|      */
    60|     private array $attributes = [];
    61|     /**
    62|      * Create a new Column.
    63|      *
    64|      * @param string $column Column (e.g. A)
    65|      * @param ?AutoFilter $parent Autofilter for this column
    66|      */
    67|     public function __construct(string $column, ?AutoFilter $parent = null)
    68|     {
    69|         $this->columnIndex = $column;
    70|         $this->parent = $parent;
    71|     }
    72|     public function setEvaluatedFalse(): void
    73|     {
    74|         if ($this->parent !== null) {
    75|             $this->parent->setEvaluated(false);
    76|         }
    77|     }
    78|     /**
    79|      * Get AutoFilter column index as string eg: 'A'.
    80|      */
    81|     public function getColumnIndex(): string
    82|     {
    83|         return $this->columnIndex;
    84|     }
    85|     /**
    86|      * Set AutoFilter column index as string eg: 'A'.
    87|      *
    88|      * @param string $column Column (e.g. A)
    89|      *
    90|      * @return $this
    91|      */
    92|     public function setColumnIndex(string $column): static
    93|     {
    94|         $this->setEvaluatedFalse();
    95|         $column = strtoupper($column);
    96|         if ($this->parent !== null) {
    97|             $this->parent->testColumnInRange($column);
    98|         }
    99|         $this->columnIndex = $column;
   100|         return $this;
   101|     }
   102|     /**
   103|      * Get this Column's AutoFilter Parent.
   104|      */
   105|     public function getParent(): ?AutoFilter
   106|     {
   107|         return $this->parent;
   108|     }
   109|     /**
   110|      * Set this Column's AutoFilter Parent.
   111|      *
   112|      * @return $this
   113|      */
   114|     public function setParent(?AutoFilter $parent = null): static
   115|     {
   116|         $this->setEvaluatedFalse();
   117|         $this->parent = $parent;
   118|         return $this;
   119|     }
   120|     /**
   121|      * Get AutoFilter Type.
   122|      */
   123|     public function getFilterType(): string
   124|     {
   125|         return $this->filterType;
   126|     }
   127|     /**
   128|      * Set AutoFilter Type.
   129|      *
   130|      * @return $this
   131|      */
   132|     public function setFilterType(string $filterType): static
   133|     {
   134|         $this->setEvaluatedFalse();
   135|         if (!in_array($filterType, self::$filterTypes)) {
   136|             throw new PhpSpreadsheetException('Invalid filter type for column AutoFilter.');
   137|         }
   138|         if ($filterType === self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER && count($this->ruleset) > 2) {
   139|             throw new PhpSpreadsheetException('No more than 2 rules are allowed in a Custom Filter');
   140|         }
   141|         $this->filterType = $filterType;
   142|         return $this;
   143|     }
   144|     /**
   145|      * Get AutoFilter Multiple Rules And/Or Join.
   146|      */
   147|     public function getJoin(): string
   148|     {
   149|         return $this->join;
   150|     }
   151|     /**
   152|      * Set AutoFilter Multiple Rules And/Or.
   153|      *
   154|      * @param string $join And/Or
   155|      *
   156|      * @return $this
   157|      */
   158|     public function setJoin(string $join): static
   159|     {
   160|         $this->setEvaluatedFalse();
   161|         $join = strtolower($join);
   162|         if (!in_array($join, self::$ruleJoins)) {
   163|             throw new PhpSpreadsheetException('Invalid rule connection for column AutoFilter.');
   164|         }
   165|         $this->join = $join;
   166|         return $this;
   167|     }
   168|     /**
   169|      * Set AutoFilter Attributes.
   170|      *
   171|      * @param (float|int|string)[] $attributes
   172|      *
   173|      * @return $this
   174|      */
   175|     public function setAttributes(array $attributes): static
   176|     {
   177|         $this->setEvaluatedFalse();
   178|         $this->attributes = $attributes;
   179|         return $this;
   180|     }
   181|     /**
   182|      * Set An AutoFilter Attribute.
   183|      *
   184|      * @param string $name Attribute Name
   185|      * @param float|int|string $value Attribute Value
   186|      *
   187|      * @return $this
   188|      */
   189|     public function setAttribute(string $name, $value): static
   190|     {
   191|         $this->setEvaluatedFalse();
   192|         $this->attributes[$name] = $value;
   193|         return $this;
   194|     }
   195|     /**
   196|      * Get AutoFilter Column Attributes.
   197|      *
   198|      * @return (float|int|string)[]
   199|      */
   200|     public function getAttributes(): array
   201|     {
   202|         return $this->attributes;
   203|     }
   204|     /**
   205|      * Get specific AutoFilter Column Attribute.
   206|      *
   207|      * @param string $name Attribute Name
   208|      */
   209|     public function getAttribute(string $name): null|float|int|string
   210|     {
   211|         if (isset($this->attributes[$name])) {
   212|             return $this->attributes[$name];
   213|         }
   214|         return null;
   215|     }
   216|     public function ruleCount(): int
   217|     {
   218|         return count($this->ruleset);
   219|     }
   220|     /**
   221|      * Get all AutoFilter Column Rules.
   222|      *
   223|      * @return Column\Rule[]
   224|      */
   225|     public function getRules(): array
   226|     {
   227|         return $this->ruleset;
   228|     }
   229|     /**
   230|      * Get a specified AutoFilter Column Rule.
   231|      *
   232|      * @param int $index Rule index in the ruleset array
   233|      */
   234|     public function getRule(int $index): Column\Rule
   235|     {
   236|         if (!isset($this->ruleset[$index])) {
   237|             $this->ruleset[$index] = new Column\Rule($this);
   238|         }
   239|         return $this->ruleset[$index];
   240|     }
   241|     /**
   242|      * Create a new AutoFilter Column Rule in the ruleset.
   243|      */
   244|     public function createRule(): Column\Rule
   245|     {
   246|         $this->setEvaluatedFalse();
   247|         if ($this->filterType === self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER && count($this->ruleset) >= 2) {
   248|             throw new PhpSpreadsheetException('No more than 2 rules are allowed in a Custom Filter');
   249|         }
   250|         $this->ruleset[] = new Column\Rule($this);
   251|         return end($this->ruleset);
   252|     }
   253|     /**
   254|      * Add a new AutoFilter Column Rule to the ruleset.
   255|      *
   256|      * @return $this
   257|      */
   258|     public function addRule(Column\Rule $rule): static
   259|     {
   260|         $this->setEvaluatedFalse();
   261|         $rule->setParent($this);
   262|         $this->ruleset[] = $rule;
   263|         return $this;
   264|     }
   265|     /**
   266|      * Delete a specified AutoFilter Column Rule
   267|      * If the number of rules is reduced to 1, then we reset And/Or logic to Or.
   268|      *
   269|      * @param int $index Rule index in the ruleset array
   270|      *
   271|      * @return $this
   272|      */
   273|     public function deleteRule(int $index): static
   274|     {
   275|         $this->setEvaluatedFalse();
   276|         if (isset($this->ruleset[$index])) {
   277|             unset($this->ruleset[$index]);
   278|             if (count($this->ruleset) <= 1) {
   279|                 $this->setJoin(self::AUTOFILTER_COLUMN_JOIN_OR);
   280|             }
   281|         }
   282|         return $this;
   283|     }
   284|     /**
   285|      * Delete all AutoFilter Column Rules.
   286|      *
   287|      * @return $this
   288|      */
   289|     public function clearRules(): static
   290|     {
   291|         $this->setEvaluatedFalse();
   292|         $this->ruleset = [];
   293|         $this->setJoin(self::AUTOFILTER_COLUMN_JOIN_OR);
   294|         return $this;
   295|     }
   296|     /**
   297|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   298|      */
   299|     public function __clone()
   300|     {
   301|         $vars = get_object_vars($this);
   302|         /** @var AutoFilter\Column\Rule[] $value */
   303|         foreach ($vars as $key => $value) {
   304|             if ($key === 'parent') {
   305|                 $this->parent = null;
   306|             } elseif ($key === 'ruleset') {
   307|                 $this->ruleset = [];
   308|                 foreach ($value as $k => $v) {
   309|                     $cloned = clone $v;
   310|                     $cloned->setParent($this); // attach the new cloned Rule to this new cloned Autofilter Cloned object
   311|                     $this->ruleset[$k] = $cloned;
   312|                 }
   313|             } else {
   314|                 $this->$key = $value;
   315|             }
   316|         }
   317|     }
   318| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/MemoryDrawing.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-268 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use GdImage;
     4| use PhpOffice\PhpSpreadsheet\Exception;
     5| use PhpOffice\PhpSpreadsheet\Shared\File;
     6| class MemoryDrawing extends BaseDrawing
     7| {
     8|     const RENDERING_DEFAULT = 'imagepng';
     9|     const RENDERING_PNG = 'imagepng';
    10|     const RENDERING_GIF = 'imagegif';
    11|     const RENDERING_JPEG = 'imagejpeg';
    12|     const MIMETYPE_DEFAULT = 'image/png';
    13|     const MIMETYPE_PNG = 'image/png';
    14|     const MIMETYPE_GIF = 'image/gif';
    15|     const MIMETYPE_JPEG = 'image/jpeg';
    16|     const SUPPORTED_MIME_TYPES = [
    17|         self::MIMETYPE_GIF,
    18|         self::MIMETYPE_JPEG,
    19|         self::MIMETYPE_PNG,
    20|     ];
    21|     /**
    22|      * Image resource.
    23|      */
    24|     private null|GdImage $imageResource = null;
    25|     /**
    26|      * Rendering function.
    27|      */
    28|     private string $renderingFunction;
    29|     /**
    30|      * Mime type.
    31|      */
    32|     private string $mimeType;
    33|     /**
    34|      * Unique name.
    35|      */
    36|     private string $uniqueName;
    37|     /**
    38|      * Create a new MemoryDrawing.
    39|      */
    40|     public function __construct()
    41|     {
    42|         $this->renderingFunction = self::RENDERING_DEFAULT;
    43|         $this->mimeType = self::MIMETYPE_DEFAULT;
    44|         $this->uniqueName = md5(mt_rand(0, 9999) . time() . mt_rand(0, 9999));
    45|         parent::__construct();
    46|     }
    47|     public function __destruct()
    48|     {
    49|         if ($this->imageResource) {
    50|             @imagedestroy($this->imageResource);
    51|             $this->imageResource = null;
    52|         }
    53|         $this->worksheet = null;
    54|     }
    55|     public function __clone()
    56|     {
    57|         parent::__clone();
    58|         $this->cloneResource();
    59|     }
    60|     private function cloneResource(): void
    61|     {
    62|         if (!$this->imageResource) {
    63|             return;
    64|         }
    65|         $width = (int) imagesx($this->imageResource);
    66|         $height = (int) imagesy($this->imageResource);
    67|         if (imageistruecolor($this->imageResource)) {
    68|             $clone = imagecreatetruecolor($width, $height);
    69|             if (!$clone) {
    70|                 throw new Exception('Could not clone image resource');
    71|             }
    72|             imagealphablending($clone, false);
    73|             imagesavealpha($clone, true);
    74|         } else {
    75|             $clone = imagecreate($width, $height);
    76|             if (!$clone) {
    77|                 throw new Exception('Could not clone image resource');
    78|             }
    79|             $transparent = imagecolortransparent($this->imageResource);
    80|             if ($transparent >= 0) {
    81|                 $rgb = imagecolorsforindex($this->imageResource, $transparent);
    82|                 imagesavealpha($clone, true);
    83|                 $color = imagecolorallocatealpha($clone, $rgb['red'], $rgb['green'], $rgb['blue'], $rgb['alpha']);
    84|                 if ($color === false) {
    85|                     throw new Exception('Could not get image alpha color');
    86|                 }
    87|                 imagefill($clone, 0, 0, $color);
    88|             }
    89|         }
    90|         imagecopy($clone, $this->imageResource, 0, 0, 0, 0, $width, $height);
    91|         $this->imageResource = $clone;
    92|     }
    93|     /**
    94|      * @param resource $imageStream Stream data to be converted to a Memory Drawing
    95|      *
    96|      * @throws Exception
    97|      */
    98|     public static function fromStream($imageStream): self
    99|     {
   100|         $streamValue = stream_get_contents($imageStream);
   101|         if ($streamValue === false) {
   102|             throw new Exception('Unable to read data from stream');
   103|         }
   104|         return self::fromString($streamValue);
   105|     }
   106|     /**
   107|      * @param string $imageString String data to be converted to a Memory Drawing
   108|      *
   109|      * @throws Exception
   110|      */
   111|     public static function fromString(string $imageString): self
   112|     {
   113|         $gdImage = @imagecreatefromstring($imageString);
   114|         if ($gdImage === false) {
   115|             throw new Exception('Value cannot be converted to an image');
   116|         }
   117|         $mimeType = self::identifyMimeType($imageString);
   118|         if (imageistruecolor($gdImage) || imagecolortransparent($gdImage) >= 0) {
   119|             imagesavealpha($gdImage, true);
   120|         }
   121|         $renderingFunction = self::identifyRenderingFunction($mimeType);
   122|         $drawing = new self();
   123|         $drawing->setImageResource($gdImage);
   124|         $drawing->setRenderingFunction($renderingFunction);
   125|         $drawing->setMimeType($mimeType);
   126|         return $drawing;
   127|     }
   128|     private static function identifyRenderingFunction(string $mimeType): string
   129|     {
   130|         return match ($mimeType) {
   131|             self::MIMETYPE_PNG => self::RENDERING_PNG,
   132|             self::MIMETYPE_JPEG => self::RENDERING_JPEG,
   133|             self::MIMETYPE_GIF => self::RENDERING_GIF,
   134|             default => self::RENDERING_DEFAULT,
   135|         };
   136|     }
   137|     /**
   138|      * @throws Exception
   139|      */
   140|     private static function identifyMimeType(string $imageString): string
   141|     {
   142|         $temporaryFileName = File::temporaryFilename();
   143|         file_put_contents($temporaryFileName, $imageString);
   144|         $mimeType = self::identifyMimeTypeUsingExif($temporaryFileName);
   145|         if ($mimeType !== null) {
   146|             unlink($temporaryFileName);
   147|             return $mimeType;
   148|         }
   149|         $mimeType = self::identifyMimeTypeUsingGd($temporaryFileName);
   150|         if ($mimeType !== null) {
   151|             unlink($temporaryFileName);
   152|             return $mimeType;
   153|         }
   154|         unlink($temporaryFileName);
   155|         return self::MIMETYPE_DEFAULT;
   156|     }
   157|     private static function identifyMimeTypeUsingExif(string $temporaryFileName): ?string
   158|     {
   159|         if (function_exists('exif_imagetype')) {
   160|             $imageType = @exif_imagetype($temporaryFileName);
   161|             $mimeType = ($imageType) ? image_type_to_mime_type($imageType) : null;
   162|             return self::supportedMimeTypes($mimeType);
   163|         }
   164|         return null;
   165|     }
   166|     private static function identifyMimeTypeUsingGd(string $temporaryFileName): ?string
   167|     {
   168|         if (function_exists('getimagesize')) {
   169|             $imageSize = @getimagesize($temporaryFileName);
   170|             if (is_array($imageSize)) {
   171|                 $mimeType = $imageSize['mime'];
   172|                 return self::supportedMimeTypes($mimeType);
   173|             }
   174|         }
   175|         return null;
   176|     }
   177|     private static function supportedMimeTypes(?string $mimeType = null): ?string
   178|     {
   179|         if (in_array($mimeType, self::SUPPORTED_MIME_TYPES, true)) {
   180|             return $mimeType;
   181|         }
   182|         return null;
   183|     }
   184|     /**
   185|      * Get image resource.
   186|      */
   187|     public function getImageResource(): ?GdImage
   188|     {
   189|         return $this->imageResource;
   190|     }
   191|     /**
   192|      * Set image resource.
   193|      *
   194|      * @return $this
   195|      */
   196|     public function setImageResource(?GdImage $value): static
   197|     {
   198|         $this->imageResource = $value;
   199|         if ($this->imageResource !== null) {
   200|             $this->width = (int) imagesx($this->imageResource);
   201|             $this->height = (int) imagesy($this->imageResource);
   202|         }
   203|         return $this;
   204|     }
   205|     /**
   206|      * Get rendering function.
   207|      */
   208|     public function getRenderingFunction(): string
   209|     {
   210|         return $this->renderingFunction;
   211|     }
   212|     /**
   213|      * Set rendering function.
   214|      *
   215|      * @param string $value see self::RENDERING_*
   216|      *
   217|      * @return $this
   218|      */
   219|     public function setRenderingFunction(string $value): static
   220|     {
   221|         $this->renderingFunction = $value;
   222|         return $this;
   223|     }
   224|     /**
   225|      * Get mime type.
   226|      */
   227|     public function getMimeType(): string
   228|     {
   229|         return $this->mimeType;
   230|     }
   231|     /**
   232|      * Set mime type.
   233|      *
   234|      * @param string $value see self::MIMETYPE_*
   235|      *
   236|      * @return $this
   237|      */
   238|     public function setMimeType(string $value): static
   239|     {
   240|         $this->mimeType = $value;
   241|         return $this;
   242|     }
   243|     /**
   244|      * Get indexed filename (using image index).
   245|      */
   246|     public function getIndexedFilename(): string
   247|     {
   248|         $extension = strtolower($this->getMimeType());
   249|         $extension = explode('/', $extension);
   250|         $extension = $extension[1];
   251|         return $this->uniqueName . $this->getImageIndex() . '.' . $extension;
   252|     }
   253|     /**
   254|      * Get hash code.
   255|      *
   256|      * @return string Hash code
   257|      */
   258|     public function getHashCode(): string
   259|     {
   260|         return md5(
   261|             $this->renderingFunction
   262|             . $this->mimeType
   263|             . $this->uniqueName
   264|             . parent::getHashCode()
   265|             . __CLASS__
   266|         );
   267|     }
   268| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/Table.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-488 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
     4| use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
     5| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     6| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     7| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     8| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     9| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    10| use PhpOffice\PhpSpreadsheet\Worksheet\Table\TableStyle;
    11| use Stringable;
    12| class Table implements Stringable
    13| {
    14|     /**
    15|      * Table Name.
    16|      */
    17|     private string $name;
    18|     /**
    19|      * Show Header Row.
    20|      */
    21|     private bool $showHeaderRow = true;
    22|     /**
    23|      * Show Totals Row.
    24|      */
    25|     private bool $showTotalsRow = false;
    26|     /**
    27|      * Table Range.
    28|      */
    29|     private string $range = '';
    30|     /**
    31|      * Table Worksheet.
    32|      */
    33|     private ?Worksheet $workSheet = null;
    34|     /**
    35|      * Table allow filter.
    36|      */
    37|     private bool $allowFilter = true;
    38|     /**
    39|      * Table Column.
    40|      *
    41|      * @var Table\Column[]
    42|      */
    43|     private array $columns = [];
    44|     /**
    45|      * Table Style.
    46|      */
    47|     private TableStyle $style;
    48|     /**
    49|      * Table AutoFilter.
    50|      */
    51|     private AutoFilter $autoFilter;
    52|     /**
    53|      * Create a new Table.
    54|      *
    55|      * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
    56|      *            A simple string containing a Cell range like 'A1:E10' is permitted
    57|      *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
    58|      *              or an AddressRange object.
    59|      * @param string $name (e.g. Table1)
    60|      */
    61|     public function __construct(AddressRange|string|array $range = '', string $name = '')
    62|     {
    63|         $this->style = new TableStyle();
    64|         $this->autoFilter = new AutoFilter($range);
    65|         $this->setRange($range);
    66|         $this->setName($name);
    67|     }
    68|     /**
    69|      * Code to execute when this table is unset().
    70|      */
    71|     public function __destruct()
    72|     {
    73|         $this->workSheet = null;
    74|     }
    75|     /**
    76|      * Get Table name.
    77|      */
    78|     public function getName(): string
    79|     {
    80|         return $this->name;
    81|     }
    82|     /**
    83|      * Set Table name.
    84|      *
    85|      * @throws PhpSpreadsheetException
    86|      */
    87|     public function setName(string $name): self
    88|     {
    89|         $name = trim($name);
    90|         if (!empty($name)) {
    91|             if (strlen($name) === 1 && in_array($name, ['C', 'c', 'R', 'r'])) {
    92|                 throw new PhpSpreadsheetException('The table name is invalid');
    93|             }
    94|             if (StringHelper::countCharacters($name) > 255) {
    95|                 throw new PhpSpreadsheetException('The table name cannot be longer than 255 characters');
    96|             }
    97|             if (
    98|                 preg_match(Coordinate::A1_COORDINATE_REGEX, $name)
    99|                 || preg_match('/^R\[?\-?[0-9]*\]?C\[?\-?[0-9]*\]?$/i', $name)
   100|             ) {
   101|                 throw new PhpSpreadsheetException('The table name can\'t be the same as a cell reference');
   102|             }
   103|             if (!preg_match('/^[\p{L}_\\\\]/iu', $name)) {
   104|                 throw new PhpSpreadsheetException('The table name must begin a name with a letter, an underscore character (_), or a backslash (\)');
   105|             }
   106|             if (!preg_match('/^[\p{L}_\\\\][\p{L}\p{M}0-9\._]+$/iu', $name)) {
   107|                 throw new PhpSpreadsheetException('The table name contains invalid characters');
   108|             }
   109|             $this->checkForDuplicateTableNames($name, $this->workSheet);
   110|             $this->updateStructuredReferences($name);
   111|         }
   112|         $this->name = $name;
   113|         return $this;
   114|     }
   115|     /**
   116|      * @throws PhpSpreadsheetException
   117|      */
   118|     private function checkForDuplicateTableNames(string $name, ?Worksheet $worksheet): void
   119|     {
   120|         $tableName = StringHelper::strToLower($name);
   121|         if ($worksheet !== null && StringHelper::strToLower($this->name) !== $name) {
   122|             $spreadsheet = $worksheet->getParentOrThrow();
   123|             foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
   124|                 foreach ($sheet->getTableCollection() as $table) {
   125|                     if (StringHelper::strToLower($table->getName()) === $tableName && $table != $this) {
   126|                         throw new PhpSpreadsheetException("Spreadsheet already contains a table named '{$this->name}'");
   127|                     }
   128|                 }
   129|             }
   130|         }
   131|     }
   132|     private function updateStructuredReferences(string $name): void
   133|     {
   134|         if (!$this->workSheet || !$this->name) {
   135|             return;
   136|         }
   137|         if (StringHelper::strToLower($this->name) !== StringHelper::strToLower($name)) {
   138|             $spreadsheet = $this->workSheet->getParentOrThrow();
   139|             foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
   140|                 $this->updateStructuredReferencesInCells($sheet, $name);
   141|             }
   142|             $this->updateStructuredReferencesInNamedFormulae($spreadsheet, $name);
   143|         }
   144|     }
   145|     private function updateStructuredReferencesInCells(Worksheet $worksheet, string $newName): void
   146|     {
   147|         $pattern = '/' . preg_quote($this->name, '/') . '\[/mui';
   148|         foreach ($worksheet->getCoordinates(false) as $coordinate) {
   149|             $cell = $worksheet->getCell($coordinate);
   150|             if ($cell->getDataType() === DataType::TYPE_FORMULA) {
   151|                 $formula = $cell->getValueString();
   152|                 if (preg_match($pattern, $formula) === 1) {
   153|                     $formula = preg_replace($pattern, "{$newName}[", $formula);
   154|                     $cell->setValueExplicit($formula, DataType::TYPE_FORMULA);
   155|                 }
   156|             }
   157|         }
   158|     }
   159|     private function updateStructuredReferencesInNamedFormulae(Spreadsheet $spreadsheet, string $newName): void
   160|     {
   161|         $pattern = '/' . preg_quote($this->name, '/') . '\[/mui';
   162|         foreach ($spreadsheet->getNamedFormulae() as $namedFormula) {
   163|             $formula = $namedFormula->getValue();
   164|             if (preg_match($pattern, $formula) === 1) {
   165|                 $formula = preg_replace($pattern, "{$newName}[", $formula) ?? '';
   166|                 $namedFormula->setValue($formula);
   167|             }
   168|         }
   169|     }
   170|     /**
   171|      * Get show Header Row.
   172|      */
   173|     public function getShowHeaderRow(): bool
   174|     {
   175|         return $this->showHeaderRow;
   176|     }
   177|     /**
   178|      * Set show Header Row.
   179|      */
   180|     public function setShowHeaderRow(bool $showHeaderRow): self
   181|     {
   182|         $this->showHeaderRow = $showHeaderRow;
   183|         return $this;
   184|     }
   185|     /**
   186|      * Get show Totals Row.
   187|      */
   188|     public function getShowTotalsRow(): bool
   189|     {
   190|         return $this->showTotalsRow;
   191|     }
   192|     /**
   193|      * Set show Totals Row.
   194|      */
   195|     public function setShowTotalsRow(bool $showTotalsRow): self
   196|     {
   197|         $this->showTotalsRow = $showTotalsRow;
   198|         return $this;
   199|     }
   200|     /**
   201|      * Get allow filter.
   202|      * If false, autofiltering is disabled for the table, if true it is enabled.
   203|      */
   204|     public function getAllowFilter(): bool
   205|     {
   206|         return $this->allowFilter;
   207|     }
   208|     /**
   209|      * Set show Autofiltering.
   210|      * Disabling autofiltering has the same effect as hiding the filter button on all the columns in the table.
   211|      */
   212|     public function setAllowFilter(bool $allowFilter): self
   213|     {
   214|         $this->allowFilter = $allowFilter;
   215|         return $this;
   216|     }
   217|     /**
   218|      * Get Table Range.
   219|      */
   220|     public function getRange(): string
   221|     {
   222|         return $this->range;
   223|     }
   224|     /**
   225|      * Set Table Cell Range.
   226|      *
   227|      * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
   228|      *            A simple string containing a Cell range like 'A1:E10' is permitted
   229|      *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
   230|      *              or an AddressRange object.
   231|      */
   232|     public function setRange(AddressRange|string|array $range = ''): self
   233|     {
   234|         if ($range !== '') {
   235|             [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
   236|         }
   237|         if (empty($range)) {
   238|             $this->columns = [];
   239|             $this->range = '';
   240|             return $this;
   241|         }
   242|         if (!str_contains($range, ':')) {
   243|             throw new PhpSpreadsheetException('Table must be set on a range of cells.');
   244|         }
   245|         [$width, $height] = Coordinate::rangeDimension($range);
   246|         if ($width < 1 || $height < 1) {
   247|             throw new PhpSpreadsheetException('The table range must be at least 1 column and row');
   248|         }
   249|         $this->range = $range;
   250|         $this->autoFilter->setRange($range);
   251|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   252|         foreach ($this->columns as $key => $value) {
   253|             $colIndex = Coordinate::columnIndexFromString($key);
   254|             if (($rangeStart[0] > $colIndex) || ($rangeEnd[0] < $colIndex)) {
   255|                 unset($this->columns[$key]);
   256|             }
   257|         }
   258|         return $this;
   259|     }
   260|     /**
   261|      * Set Table Cell Range to max row.
   262|      */
   263|     public function setRangeToMaxRow(): self
   264|     {
   265|         if ($this->workSheet !== null) {
   266|             $thisrange = $this->range;
   267|             $range = (string) preg_replace('/\\d+$/', (string) $this->workSheet->getHighestRow(), $thisrange);
   268|             if ($range !== $thisrange) {
   269|                 $this->setRange($range);
   270|             }
   271|         }
   272|         return $this;
   273|     }
   274|     /**
   275|      * Get Table's Worksheet.
   276|      */
   277|     public function getWorksheet(): ?Worksheet
   278|     {
   279|         return $this->workSheet;
   280|     }
   281|     /**
   282|      * Set Table's Worksheet.
   283|      */
   284|     public function setWorksheet(?Worksheet $worksheet = null): self
   285|     {
   286|         if ($this->name !== '' && $worksheet !== null) {
   287|             $spreadsheet = $worksheet->getParentOrThrow();
   288|             $tableName = StringHelper::strToUpper($this->name);
   289|             foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
   290|                 foreach ($sheet->getTableCollection() as $table) {
   291|                     if (StringHelper::strToUpper($table->getName()) === $tableName) {
   292|                         throw new PhpSpreadsheetException("Workbook already contains a table named '{$this->name}'");
   293|                     }
   294|                 }
   295|             }
   296|         }
   297|         $this->workSheet = $worksheet;
   298|         $this->autoFilter->setParent($worksheet);
   299|         return $this;
   300|     }
   301|     /**
   302|      * Get all Table Columns.
   303|      *
   304|      * @return Table\Column[]
   305|      */
   306|     public function getColumns(): array
   307|     {
   308|         return $this->columns;
   309|     }
   310|     /**
   311|      * Validate that the specified column is in the Table range.
   312|      *
   313|      * @param string $column Column name (e.g. A)
   314|      *
   315|      * @return int The column offset within the table range
   316|      */
   317|     public function isColumnInRange(string $column): int
   318|     {
   319|         if (empty($this->range)) {
   320|             throw new PhpSpreadsheetException('No table range is defined.');
   321|         }
   322|         $columnIndex = Coordinate::columnIndexFromString($column);
   323|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   324|         if (($rangeStart[0] > $columnIndex) || ($rangeEnd[0] < $columnIndex)) {
   325|             throw new PhpSpreadsheetException('Column is outside of current table range.');
   326|         }
   327|         return $columnIndex - $rangeStart[0];
   328|     }
   329|     /**
   330|      * Get a specified Table Column Offset within the defined Table range.
   331|      *
   332|      * @param string $column Column name (e.g. A)
   333|      *
   334|      * @return int The offset of the specified column within the table range
   335|      */
   336|     public function getColumnOffset(string $column): int
   337|     {
   338|         return $this->isColumnInRange($column);
   339|     }
   340|     /**
   341|      * Get a specified Table Column.
   342|      *
   343|      * @param string $column Column name (e.g. A)
   344|      */
   345|     public function getColumn(string $column): Table\Column
   346|     {
   347|         $this->isColumnInRange($column);
   348|         if (!isset($this->columns[$column])) {
   349|             $this->columns[$column] = new Table\Column($column, $this);
   350|         }
   351|         return $this->columns[$column];
   352|     }
   353|     /**
   354|      * Get a specified Table Column by it's offset.
   355|      *
   356|      * @param int $columnOffset Column offset within range (starting from 0)
   357|      */
   358|     public function getColumnByOffset(int $columnOffset): Table\Column
   359|     {
   360|         [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
   361|         $pColumn = Coordinate::stringFromColumnIndex($rangeStart[0] + $columnOffset);
   362|         return $this->getColumn($pColumn);
   363|     }
   364|     /**
   365|      * Set Table.
   366|      *
   367|      * @param string|Table\Column $columnObjectOrString
   368|      *            A simple string containing a Column ID like 'A' is permitted
   369|      */
   370|     public function setColumn(string|Table\Column $columnObjectOrString): self
   371|     {
   372|         if ((is_string($columnObjectOrString)) && (!empty($columnObjectOrString))) {
   373|             $column = $columnObjectOrString;
   374|         } elseif (is_object($columnObjectOrString) && ($columnObjectOrString instanceof Table\Column)) {
   375|             $column = $columnObjectOrString->getColumnIndex();
   376|         } else {
   377|             throw new PhpSpreadsheetException('Column is not within the table range.');
   378|         }
   379|         $this->isColumnInRange($column);
   380|         if (is_string($columnObjectOrString)) {
   381|             $this->columns[$columnObjectOrString] = new Table\Column($columnObjectOrString, $this);
   382|         } else {
   383|             $columnObjectOrString->setTable($this);
   384|             $this->columns[$column] = $columnObjectOrString;
   385|         }
   386|         ksort($this->columns);
   387|         return $this;
   388|     }
   389|     /**
   390|      * Clear a specified Table Column.
   391|      *
   392|      * @param string $column Column name (e.g. A)
   393|      */
   394|     public function clearColumn(string $column): self
   395|     {
   396|         $this->isColumnInRange($column);
   397|         if (isset($this->columns[$column])) {
   398|             unset($this->columns[$column]);
   399|         }
   400|         return $this;
   401|     }
   402|     /**
   403|      * Shift an Table Column Rule to a different column.
   404|      *
   405|      * Note: This method bypasses validation of the destination column to ensure it is within this Table range.
   406|      *        Nor does it verify whether any column rule already exists at $toColumn, but will simply override any existing value.
   407|      *        Use with caution.
   408|      *
   409|      * @param string $fromColumn Column name (e.g. A)
   410|      * @param string $toColumn Column name (e.g. B)
   411|      */
   412|     public function shiftColumn(string $fromColumn, string $toColumn): self
   413|     {
   414|         $fromColumn = strtoupper($fromColumn);
   415|         $toColumn = strtoupper($toColumn);
   416|         if (($fromColumn !== null) && (isset($this->columns[$fromColumn])) && ($toColumn !== null)) {
   417|             $this->columns[$fromColumn]->setTable();
   418|             $this->columns[$fromColumn]->setColumnIndex($toColumn);
   419|             $this->columns[$toColumn] = $this->columns[$fromColumn];
   420|             $this->columns[$toColumn]->setTable($this);
   421|             unset($this->columns[$fromColumn]);
   422|             ksort($this->columns);
   423|         }
   424|         return $this;
   425|     }
   426|     /**
   427|      * Get table Style.
   428|      */
   429|     public function getStyle(): TableStyle
   430|     {
   431|         return $this->style;
   432|     }
   433|     /**
   434|      * Set table Style.
   435|      */
   436|     public function setStyle(TableStyle $style): self
   437|     {
   438|         $this->style = $style;
   439|         return $this;
   440|     }
   441|     /**
   442|      * Get AutoFilter.
   443|      */
   444|     public function getAutoFilter(): AutoFilter
   445|     {
   446|         return $this->autoFilter;
   447|     }
   448|     /**
   449|      * Set AutoFilter.
   450|      */
   451|     public function setAutoFilter(AutoFilter $autoFilter): self
   452|     {
   453|         $this->autoFilter = $autoFilter;
   454|         return $this;
   455|     }
   456|     /**
   457|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   458|      */
   459|     public function __clone()
   460|     {
   461|         $vars = get_object_vars($this);
   462|         foreach ($vars as $key => $value) {
   463|             if (is_object($value)) {
   464|                 if ($key === 'workSheet') {
   465|                     $this->{$key} = null;
   466|                 } else {
   467|                     $this->{$key} = clone $value;
   468|                 }
   469|             } elseif ((is_array($value)) && ($key === 'columns')) {
   470|                 $this->{$key} = [];
   471|                 foreach ($value as $k => $v) {
   472|                     $this->{$key}[$k] = clone $v;
   473|                     $this->{$key}[$k]->setTable($this);
   474|                 }
   475|             } else {
   476|                 $this->{$key} = $value;
   477|             }
   478|         }
   479|     }
   480|     /**
   481|      * toString method replicates previous behavior by returning the range if object is
   482|      * referenced as a property of its worksheet.
   483|      */
   484|     public function __toString(): string
   485|     {
   486|         return (string) $this->range;
   487|     }
   488| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/Validations.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
     4| use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
     5| use PhpOffice\PhpSpreadsheet\Cell\CellRange;
     6| use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
     7| class Validations
     8| {
     9|     /**
    10|      * Validate a cell address.
    11|      *
    12|      * @param null|array{0: int, 1: int}|CellAddress|string $cellAddress Coordinate of the cell as a string, eg: 'C5';
    13|      *               or as an array of [$columnIndex, $row] (e.g. [3, 5]), or a CellAddress object.
    14|      */
    15|     public static function validateCellAddress(null|CellAddress|string|array $cellAddress): string
    16|     {
    17|         if (is_string($cellAddress)) {
    18|             [$worksheet, $address] = Worksheet::extractSheetTitle($cellAddress, true);
    19|             return empty($worksheet) ? strtoupper("$address") : $worksheet . '!' . strtoupper("$address");
    20|         }
    21|         if (is_array($cellAddress)) {
    22|             $cellAddress = CellAddress::fromColumnRowArray($cellAddress);
    23|         }
    24|         return (string) $cellAddress;
    25|     }
    26|     /**
    27|      * Validate a cell address or cell range.
    28|      *
    29|      * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|CellAddress|int|string $cellRange Coordinate of the cells as a string, eg: 'C5:F12';
    30|      *               or as an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 12]),
    31|      *               or as a CellAddress or AddressRange object.
    32|      */
    33|     public static function validateCellOrCellRange(AddressRange|CellAddress|int|string|array $cellRange): string
    34|     {
    35|         if (is_string($cellRange) || is_numeric($cellRange)) {
    36|             $cellRange = (string) preg_replace('/^([A-Z]+|\d+)$/', '${1}:${1}', (string) $cellRange);
    37|         } elseif (is_object($cellRange) && $cellRange instanceof CellAddress) {
    38|             $cellRange = new CellRange($cellRange, $cellRange);
    39|         }
    40|         return self::validateCellRange($cellRange);
    41|     }
    42|     private const SETMAXROW = '${1}1:${2}' . AddressRange::MAX_ROW;
    43|     private const SETMAXCOL = 'A${1}:' . AddressRange::MAX_COLUMN . '${2}';
    44|     /**
    45|      * Validate a cell range.
    46|      *
    47|      * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $cellRange Coordinate of the cells as a string, eg: 'C5:F12';
    48|      *               or as an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 12]),
    49|      *               or as an AddressRange object.
    50|      */
    51|     public static function validateCellRange(AddressRange|string|array $cellRange): string
    52|     {
    53|         if (is_string($cellRange)) {
    54|             [$worksheet, $addressRange] = Worksheet::extractSheetTitle($cellRange, true);
    55|             $addressRange = (string) preg_replace(
    56|                 ['/^([A-Z]+):([A-Z]+)$/i', '/^(\\d+):(\\d+)$/'],
    57|                 [self::SETMAXROW, self::SETMAXCOL],
    58|                 $addressRange ?? ''
    59|             );
    60|             return empty($worksheet) ? strtoupper($addressRange) : $worksheet . '!' . strtoupper($addressRange);
    61|         }
    62|         if (is_array($cellRange)) {
    63|             switch (count($cellRange)) {
    64|                 case 4:
    65|                     $from = [$cellRange[0], $cellRange[1]];
    66|                     $to = [$cellRange[2], $cellRange[3]];
    67|                     break;
    68|                 case 2:
    69|                     $from = [$cellRange[0], $cellRange[1]];
    70|                     $to = [$cellRange[0], $cellRange[1]];
    71|                     break;
    72|                 default:
    73|                     throw new SpreadsheetException('CellRange array length must be 2 or 4');
    74|             }
    75|             $cellRange = new CellRange(CellAddress::fromColumnRowArray($from), CellAddress::fromColumnRowArray($to));
    76|         }
    77|         return (string) $cellRange;
    78|     }
    79|     public static function definedNameToCoordinate(string $coordinate, Worksheet $worksheet): string
    80|     {
    81|         $coordinate = strtoupper($coordinate);
    82|         $testCoordinate = (string) preg_replace('/^=/', '', $coordinate);
    83|         $defined = $worksheet->getParentOrThrow()->getDefinedName($testCoordinate, $worksheet);
    84|         if ($defined !== null) {
    85|             if ($defined->getWorksheet() === $worksheet && !$defined->isFormula()) {
    86|                 $coordinate = (string) preg_replace('/^=/', '', $defined->getValue());
    87|             }
    88|         }
    89|         return $coordinate;
    90|     }
    91| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/Worksheet.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3080-3104 ---
  3080|         $referenceHelper = ReferenceHelper::getInstance();
  3081|         foreach ($toArray as $destination) {
  3082|             if ($destination !== $fromCell) {
  3083|                 $toIndexes = Coordinate::indexesFromString($destination);
  3084|                 $this->getCell($destination)->setValue($referenceHelper->updateFormulaReferences($valueString, 'A1', $toIndexes[0] - $fromIndexes[0], $toIndexes[1] - $fromIndexes[1]));
  3085|                 if ($copyStyle) {
  3086|                     $this->getCell($destination)->getStyle()->applyFromArray($style);
  3087|                 }
  3088|             }
  3089|         }
  3090|     }
  3091|     public function applyStylesFromArray(string $coordinate, array $styleArray): bool
  3092|     {
  3093|         $spreadsheet = $this->parent;
  3094|         if ($spreadsheet === null) {
  3095|             return false;
  3096|         }
  3097|         $activeSheetIndex = $spreadsheet->getActiveSheetIndex();
  3098|         $originalSelected = $this->selectedCells;
  3099|         $this->getStyle($coordinate)->applyFromArray($styleArray);
  3100|         $this->selectedCells = $originalSelected;
  3101|         $spreadsheet->setActiveSheetIndex($activeSheetIndex);
  3102|         return true;
  3103|     }
  3104| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Csv.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-270 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     5| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     6| use Stringable;
     7| class Csv extends BaseWriter
     8| {
     9|     /**
    10|      * PhpSpreadsheet object.
    11|      */
    12|     private Spreadsheet $spreadsheet;
    13|     /**
    14|      * Delimiter.
    15|      */
    16|     private string $delimiter = ',';
    17|     /**
    18|      * Enclosure.
    19|      */
    20|     private string $enclosure = '"';
    21|     /**
    22|      * Line ending.
    23|      */
    24|     private string $lineEnding = PHP_EOL;
    25|     /**
    26|      * Sheet index to write.
    27|      */
    28|     private int $sheetIndex = 0;
    29|     /**
    30|      * Whether to write a UTF8 BOM.
    31|      */
    32|     private bool $useBOM = false;
    33|     /**
    34|      * Whether to write a Separator line as the first line of the file
    35|      *     sep=x.
    36|      */
    37|     private bool $includeSeparatorLine = false;
    38|     /**
    39|      * Whether to write a fully Excel compatible CSV file.
    40|      */
    41|     private bool $excelCompatibility = false;
    42|     /**
    43|      * Output encoding.
    44|      */
    45|     private string $outputEncoding = '';
    46|     /**
    47|      * Whether number of columns should be allowed to vary
    48|      * between rows, or use a fixed range based on the max
    49|      * column overall.
    50|      */
    51|     private bool $variableColumns = false;
    52|     /**
    53|      * Create a new CSV.
    54|      */
    55|     public function __construct(Spreadsheet $spreadsheet)
    56|     {
    57|         $this->spreadsheet = $spreadsheet;
    58|     }
    59|     /**
    60|      * Save PhpSpreadsheet to file.
    61|      *
    62|      * @param resource|string $filename
    63|      */
    64|     public function save($filename, int $flags = 0): void
    65|     {
    66|         $this->processFlags($flags);
    67|         $sheet = $this->spreadsheet->getSheet($this->sheetIndex);
    68|         $saveDebugLog = Calculation::getInstance($this->spreadsheet)->getDebugLog()->getWriteDebugLog();
    69|         Calculation::getInstance($this->spreadsheet)->getDebugLog()->setWriteDebugLog(false);
    70|         $saveArrayReturnType = Calculation::getArrayReturnType();
    71|         Calculation::setArrayReturnType(Calculation::RETURN_ARRAY_AS_VALUE);
    72|         $this->openFileHandle($filename);
    73|         if ($this->excelCompatibility) {
    74|             $this->setUseBOM(true); //  Enforce UTF-8 BOM Header
    75|             $this->setIncludeSeparatorLine(true); //  Set separator line
    76|             $this->setEnclosure('"'); //  Set enclosure to "
    77|             $this->setDelimiter(';'); //  Set delimiter to a semi-colon
    78|             $this->setLineEnding("\r\n");
    79|         }
    80|         if ($this->useBOM) {
    81|             fwrite($this->fileHandle, "\xEF\xBB\xBF");
    82|         }
    83|         if ($this->includeSeparatorLine) {
    84|             fwrite($this->fileHandle, 'sep=' . $this->getDelimiter() . $this->lineEnding);
    85|         }
    86|         $maxCol = $sheet->getHighestDataColumn();
    87|         $maxRow = $sheet->getHighestDataRow();
    88|         $row = 0;
    89|         foreach ($sheet->rangeToArrayYieldRows("A1:$maxCol$maxRow", '', $this->preCalculateFormulas) as $cellsArray) {
    90|             ++$row;
    91|             if ($this->variableColumns) {
    92|                 $column = $sheet->getHighestDataColumn($row);
    93|                 if ($column === 'A' && !$sheet->cellExists("A$row")) {
    94|                     $cellsArray = [];
    95|                 } else {
    96|                     array_splice($cellsArray, Coordinate::columnIndexFromString($column));
    97|                 }
    98|             }
    99|             $this->writeLine($this->fileHandle, $cellsArray);
   100|         }
   101|         $this->maybeCloseFileHandle();
   102|         Calculation::setArrayReturnType($saveArrayReturnType);
   103|         Calculation::getInstance($this->spreadsheet)->getDebugLog()->setWriteDebugLog($saveDebugLog);
   104|     }
   105|     public function getDelimiter(): string
   106|     {
   107|         return $this->delimiter;
   108|     }
   109|     public function setDelimiter(string $delimiter): self
   110|     {
   111|         $this->delimiter = $delimiter;
   112|         return $this;
   113|     }
   114|     public function getEnclosure(): string
   115|     {
   116|         return $this->enclosure;
   117|     }
   118|     public function setEnclosure(string $enclosure = '"'): self
   119|     {
   120|         $this->enclosure = $enclosure;
   121|         return $this;
   122|     }
   123|     public function getLineEnding(): string
   124|     {
   125|         return $this->lineEnding;
   126|     }
   127|     public function setLineEnding(string $lineEnding): self
   128|     {
   129|         $this->lineEnding = $lineEnding;
   130|         return $this;
   131|     }
   132|     /**
   133|      * Get whether BOM should be used.
   134|      */
   135|     public function getUseBOM(): bool
   136|     {
   137|         return $this->useBOM;
   138|     }
   139|     /**
   140|      * Set whether BOM should be used, typically when non-ASCII characters are used.
   141|      */
   142|     public function setUseBOM(bool $useBOM): self
   143|     {
   144|         $this->useBOM = $useBOM;
   145|         return $this;
   146|     }
   147|     /**
   148|      * Get whether a separator line should be included.
   149|      */
   150|     public function getIncludeSeparatorLine(): bool
   151|     {
   152|         return $this->includeSeparatorLine;
   153|     }
   154|     /**
   155|      * Set whether a separator line should be included as the first line of the file.
   156|      */
   157|     public function setIncludeSeparatorLine(bool $includeSeparatorLine): self
   158|     {
   159|         $this->includeSeparatorLine = $includeSeparatorLine;
   160|         return $this;
   161|     }
   162|     /**
   163|      * Get whether the file should be saved with full Excel Compatibility.
   164|      */
   165|     public function getExcelCompatibility(): bool
   166|     {
   167|         return $this->excelCompatibility;
   168|     }
   169|     /**
   170|      * Set whether the file should be saved with full Excel Compatibility.
   171|      *
   172|      * @param bool $excelCompatibility Set the file to be written as a fully Excel compatible csv file
   173|      *                                Note that this overrides other settings such as useBOM, enclosure and delimiter
   174|      */
   175|     public function setExcelCompatibility(bool $excelCompatibility): self
   176|     {
   177|         $this->excelCompatibility = $excelCompatibility;
   178|         return $this;
   179|     }
   180|     public function getSheetIndex(): int
   181|     {
   182|         return $this->sheetIndex;
   183|     }
   184|     public function setSheetIndex(int $sheetIndex): self
   185|     {
   186|         $this->sheetIndex = $sheetIndex;
   187|         return $this;
   188|     }
   189|     public function getOutputEncoding(): string
   190|     {
   191|         return $this->outputEncoding;
   192|     }
   193|     public function setOutputEncoding(string $outputEnconding): self
   194|     {
   195|         $this->outputEncoding = $outputEnconding;
   196|         return $this;
   197|     }
   198|     private bool $enclosureRequired = true;
   199|     public function setEnclosureRequired(bool $value): self
   200|     {
   201|         $this->enclosureRequired = $value;
   202|         return $this;
   203|     }
   204|     public function getEnclosureRequired(): bool
   205|     {
   206|         return $this->enclosureRequired;
   207|     }
   208|     /**
   209|      * Convert boolean to TRUE/FALSE; otherwise return element cast to string.
   210|      *
   211|      * @param null|bool|float|int|string|Stringable $element element to be converted
   212|      */
   213|     private static function elementToString(mixed $element): string
   214|     {
   215|         if (is_bool($element)) {
   216|             return $element ? 'TRUE' : 'FALSE';
   217|         }
   218|         return (string) $element;
   219|     }
   220|     /**
   221|      * Write line to CSV file.
   222|      *
   223|      * @param resource $fileHandle PHP filehandle
   224|      * @param array $values Array containing values in a row
   225|      */
   226|     private function writeLine($fileHandle, array $values): void
   227|     {
   228|         $delimiter = '';
   229|         $line = '';
   230|         /** @var null|bool|float|int|string|Stringable $element */
   231|         foreach ($values as $element) {
   232|             $element = self::elementToString($element);
   233|             $line .= $delimiter;
   234|             $delimiter = $this->delimiter;
   235|             $enclosure = $this->enclosure;
   236|             if ($enclosure) {
   237|                 if (!$this->enclosureRequired && strpbrk($element, "$delimiter$enclosure\n") === false) {
   238|                     $enclosure = '';
   239|                 } else {
   240|                     $element = str_replace($enclosure, $enclosure . $enclosure, $element);
   241|                 }
   242|             }
   243|             $line .= $enclosure . $element . $enclosure;
   244|         }
   245|         $line .= $this->lineEnding;
   246|         if ($this->outputEncoding != '') {
   247|             $line = mb_convert_encoding($line, $this->outputEncoding);
   248|         }
   249|         fwrite($fileHandle, $line);
   250|     }
   251|     /**
   252|      * Get whether number of columns should be allowed to vary
   253|      * between rows, or use a fixed range based on the max
   254|      * column overall.
   255|      */
   256|     public function getVariableColumns(): bool
   257|     {
   258|         return $this->variableColumns;
   259|     }
   260|     /**
   261|      * Set whether number of columns should be allowed to vary
   262|      * between rows, or use a fixed range based on the max
   263|      * column overall.
   264|      */
   265|     public function setVariableColumns(bool $pValue): self
   266|     {
   267|         $this->variableColumns = $pValue;
   268|         return $this;
   269|     }
   270| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Html.php
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 443-531 ---
   443|         return $html;
   444|     }
   445|     private function extendRowsAndColumns(Worksheet $worksheet, int &$colMax, int &$rowMax): void
   446|     {
   447|         if ($this->includeCharts) {
   448|             foreach ($worksheet->getChartCollection() as $chart) {
   449|                 if ($chart instanceof Chart) {
   450|                     $chartCoordinates = $chart->getTopLeftPosition();
   451|                     $this->sheetCharts[$chartCoordinates['cell']] = $chart;
   452|                     $chartTL = Coordinate::indexesFromString($chartCoordinates['cell']);
   453|                     if ($chartTL[1] > $rowMax) {
   454|                         $rowMax = $chartTL[1];
   455|                     }
   456|                     if ($chartTL[0] > $colMax) {
   457|                         $colMax = $chartTL[0];
   458|                     }
   459|                 }
   460|             }
   461|         }
   462|         foreach ($worksheet->getDrawingCollection() as $drawing) {
   463|             $imageTL = Coordinate::indexesFromString($drawing->getCoordinates());
   464|             $this->sheetDrawings[$drawing->getCoordinates()] = $drawing;
   465|             if ($imageTL[1] > $rowMax) {
   466|                 $rowMax = $imageTL[1];
   467|             }
   468|             if ($imageTL[0] > $colMax) {
   469|                 $colMax = $imageTL[0];
   470|             }
   471|         }
   472|     }
   473|     /**
   474|      * Convert Windows file name to file protocol URL.
   475|      *
   476|      * @param string $filename file name on local system
   477|      */
   478|     public static function winFileToUrl(string $filename, bool $mpdf = false): string
   479|     {
   480|         if (substr($filename, 1, 2) === ':\\') {
   481|             $protocol = $mpdf ? '' : 'file:///';
   482|             $filename = $protocol . str_replace('\\', '/', $filename);
   483|         }
   484|         return $filename;
   485|     }
   486|     /**
   487|      * Generate image tag in cell.
   488|      *
   489|      * @param string $coordinates Cell coordinates
   490|      */
   491|     private function writeImageInCell(string $coordinates): string
   492|     {
   493|         $html = '';
   494|         $drawing = $this->sheetDrawings[$coordinates] ?? null;
   495|         if ($drawing !== null) {
   496|             $filedesc = $drawing->getDescription();
   497|             $filedesc = $filedesc ? htmlspecialchars($filedesc, ENT_QUOTES) : 'Embedded image';
   498|             if ($drawing instanceof Drawing) {
   499|                 $filename = $drawing->getPath();
   500|                 $filename = (string) preg_replace('/^[.]/', '', $filename);
   501|                 $filename = $this->getImagesRoot() . $filename;
   502|                 $filename = (string) preg_replace('@^[.]([^/])@', '$1', $filename);
   503|                 $filename = htmlspecialchars($filename, Settings::htmlEntityFlags());
   504|                 $html .= PHP_EOL;
   505|                 $imageData = self::winFileToUrl($filename, $this instanceof Pdf\Mpdf);
   506|                 if ($this->embedImages || str_starts_with($imageData, 'zip://')) {
   507|                     $picture = @file_get_contents($filename);
   508|                     if ($picture !== false) {
   509|                         $imageDetails = getimagesize($filename) ?: ['mime' => ''];
   510|                         $base64 = base64_encode($picture);
   511|                         $imageData = 'data:' . $imageDetails['mime'] . ';base64,' . $base64;
   512|                     }
   513|                 }
   514|                 $html .= '<img style="position: absolute; z-index: 1; left: '
   515|                     . $drawing->getOffsetX() . 'px; top: ' . $drawing->getOffsetY() . 'px; width: '
   516|                     . $drawing->getWidth() . 'px; height: ' . $drawing->getHeight() . 'px;" src="'
   517|                     . $imageData . '" alt="' . $filedesc . '" />';
   518|             } elseif ($drawing instanceof MemoryDrawing) {
   519|                 $imageResource = $drawing->getImageResource();
   520|                 if ($imageResource) {
   521|                     ob_start(); //  Let's start output buffering.
   522|                     imagepng($imageResource); //  This will normally output the image, but because of ob_start(), it won't.
   523|                     $contents = (string) ob_get_contents(); //  Instead, output above is saved to $contents
   524|                     ob_end_clean(); //  End the output buffer.
   525|                     $dataUri = 'data:image/png;base64,' . base64_encode($contents);
   526|                     $html .= '<img alt="' . $filedesc . '" src="' . $dataUri . '" style="width:' . $drawing->getWidth() . 'px;left: '
   527|                         . $drawing->getOffsetX() . 'px; top: ' . $drawing->getOffsetY() . 'px;position: absolute; z-index: 1;" />';
   528|                 }
   529|             }
   530|         }
   531|         return $html;

# --- HUNK 2: Lines 1145-1185 ---
  1145|         $html .= $this->writeComment($worksheet, $coordinate);
  1146|         $html .= $cellData;
  1147|         $html .= '</' . $cellType . '>' . PHP_EOL;
  1148|     }
  1149|     /**
  1150|      * Generate row.
  1151|      *
  1152|      * @param array $values Array containing cells in a row
  1153|      * @param int $row Row number (0-based)
  1154|      * @param string $cellType eg: 'td'
  1155|      */
  1156|     private function generateRow(Worksheet $worksheet, array $values, int $row, string $cellType): string
  1157|     {
  1158|         $sheetIndex = $worksheet->getParentOrThrow()->getIndex($worksheet);
  1159|         $html = $this->generateRowStart($worksheet, $sheetIndex, $row);
  1160|         $colNum = 0;
  1161|         foreach ($values as $cellAddress) {
  1162|             [$cell, $cssClass, $coordinate] = $this->generateRowCellCss($worksheet, $cellAddress, $row, $colNum);
  1163|             $cellData = $this->generateRowCellData($worksheet, $cell, $cssClass);
  1164|             if ($worksheet->hyperlinkExists($coordinate) && !$worksheet->getHyperlink($coordinate)->isInternal()) {
  1165|                 $cellData = '<a href="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getUrl(), Settings::htmlEntityFlags()) . '" title="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getTooltip(), Settings::htmlEntityFlags()) . '">' . $cellData . '</a>';
  1166|             }
  1167|             $writeCell = !(isset($this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])
  1168|                 && $this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum]);
  1169|             $colSpan = 1;
  1170|             $rowSpan = 1;
  1171|             if (isset($this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])) {
  1172|                 $spans = $this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum];
  1173|                 $rowSpan = $spans['rowspan'];
  1174|                 $colSpan = $spans['colspan'];
  1175|                 $endCellCoord = Coordinate::stringFromColumnIndex($colNum + $colSpan) . ($row + $rowSpan);
  1176|                 if (!$this->useInlineCss) {
  1177|                     $cssClass .= ' style' . $worksheet->getCell($endCellCoord)->getXfIndex();
  1178|                 } else {
  1179|                     $endBorders = $this->spreadsheet->getCellXfByIndex($worksheet->getCell($endCellCoord)->getXfIndex())->getBorders();
  1180|                     $altBorders = $this->createCSSStyleBorders($endBorders);
  1181|                     foreach ($altBorders as $altKey => $altValue) {
  1182|                         if (str_contains($altValue, '!important')) {
  1183|                             $cssClass[$altKey] = $altValue;
  1184|                         }
  1185|                     }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Ods/Cell/Comment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Ods\Cell;
     3| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     4| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     5| /**
     6|  * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
     7|  */
     8| class Comment
     9| {
    10|     public static function write(XMLWriter $objWriter, Cell $cell): void
    11|     {
    12|         $comments = $cell->getWorksheet()->getComments();
    13|         if (!isset($comments[$cell->getCoordinate()])) {
    14|             return;
    15|         }
    16|         $comment = $comments[$cell->getCoordinate()];
    17|         $objWriter->startElement('office:annotation');
    18|         $objWriter->writeAttribute('svg:width', $comment->getWidth());
    19|         $objWriter->writeAttribute('svg:height', $comment->getHeight());
    20|         $objWriter->writeAttribute('svg:x', $comment->getMarginLeft());
    21|         $objWriter->writeAttribute('svg:y', $comment->getMarginTop());
    22|         $objWriter->writeElement('dc:creator', $comment->getAuthor());
    23|         $objWriter->startElement('text:p');
    24|         $text = $comment->getText()->getPlainText();
    25|         $textElements = explode("\n", $text);
    26|         $newLineOwed = false;
    27|         foreach ($textElements as $textSegment) {
    28|             if ($newLineOwed) {
    29|                 $objWriter->writeElement('text:line-break');
    30|             }
    31|             $newLineOwed = true;
    32|             if ($textSegment !== '') {
    33|                 $objWriter->writeElement('text:span', $textSegment);
    34|             }
    35|         }
    36|         $objWriter->endElement(); // text:p
    37|         $objWriter->endElement();
    38|     }
    39| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Ods/Content.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-313 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Ods;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalculationException;
     5| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     6| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     7| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     8| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     9| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    10| use PhpOffice\PhpSpreadsheet\Worksheet\RowCellIterator;
    11| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
    12| use PhpOffice\PhpSpreadsheet\Writer\Ods;
    13| use PhpOffice\PhpSpreadsheet\Writer\Ods\Cell\Comment;
    14| use PhpOffice\PhpSpreadsheet\Writer\Ods\Cell\Style;
    15| /**
    16|  * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
    17|  */
    18| class Content extends WriterPart
    19| {
    20|     const NUMBER_COLS_REPEATED_MAX = 1024;
    21|     const NUMBER_ROWS_REPEATED_MAX = 1048576;
    22|     private Formula $formulaConvertor;
    23|     /**
    24|      * Set parent Ods writer.
    25|      */
    26|     public function __construct(Ods $writer)
    27|     {
    28|         parent::__construct($writer);
    29|         $this->formulaConvertor = new Formula($this->getParentWriter()->getSpreadsheet()->getDefinedNames());
    30|     }
    31|     /**
    32|      * Write content.xml to XML format.
    33|      *
    34|      * @return string XML Output
    35|      */
    36|     public function write(): string
    37|     {
    38|         $objWriter = null;
    39|         if ($this->getParentWriter()->getUseDiskCaching()) {
    40|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    41|         } else {
    42|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    43|         }
    44|         $objWriter->startDocument('1.0', 'UTF-8');
    45|         $objWriter->startElement('office:document-content');
    46|         $objWriter->writeAttribute('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
    47|         $objWriter->writeAttribute('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
    48|         $objWriter->writeAttribute('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
    49|         $objWriter->writeAttribute('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
    50|         $objWriter->writeAttribute('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
    51|         $objWriter->writeAttribute('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
    52|         $objWriter->writeAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    53|         $objWriter->writeAttribute('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
    54|         $objWriter->writeAttribute('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
    55|         $objWriter->writeAttribute('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
    56|         $objWriter->writeAttribute('xmlns:presentation', 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0');
    57|         $objWriter->writeAttribute('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
    58|         $objWriter->writeAttribute('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
    59|         $objWriter->writeAttribute('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
    60|         $objWriter->writeAttribute('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
    61|         $objWriter->writeAttribute('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
    62|         $objWriter->writeAttribute('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
    63|         $objWriter->writeAttribute('xmlns:ooo', 'http://openoffice.org/2004/office');
    64|         $objWriter->writeAttribute('xmlns:ooow', 'http://openoffice.org/2004/writer');
    65|         $objWriter->writeAttribute('xmlns:oooc', 'http://openoffice.org/2004/calc');
    66|         $objWriter->writeAttribute('xmlns:dom', 'http://www.w3.org/2001/xml-events');
    67|         $objWriter->writeAttribute('xmlns:xforms', 'http://www.w3.org/2002/xforms');
    68|         $objWriter->writeAttribute('xmlns:xsd', 'http://www.w3.org/2001/XMLSchema');
    69|         $objWriter->writeAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
    70|         $objWriter->writeAttribute('xmlns:rpt', 'http://openoffice.org/2005/report');
    71|         $objWriter->writeAttribute('xmlns:of', 'urn:oasis:names:tc:opendocument:xmlns:of:1.2');
    72|         $objWriter->writeAttribute('xmlns:xhtml', 'http://www.w3.org/1999/xhtml');
    73|         $objWriter->writeAttribute('xmlns:grddl', 'http://www.w3.org/2003/g/data-view#');
    74|         $objWriter->writeAttribute('xmlns:tableooo', 'http://openoffice.org/2009/table');
    75|         $objWriter->writeAttribute('xmlns:field', 'urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0');
    76|         $objWriter->writeAttribute('xmlns:formx', 'urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0');
    77|         $objWriter->writeAttribute('xmlns:css3t', 'http://www.w3.org/TR/css3-text/');
    78|         $objWriter->writeAttribute('office:version', '1.2');
    79|         $objWriter->writeElement('office:scripts');
    80|         $objWriter->writeElement('office:font-face-decls');
    81|         $objWriter->startElement('office:automatic-styles');
    82|         $this->writeXfStyles($objWriter, $this->getParentWriter()->getSpreadsheet());
    83|         $objWriter->endElement();
    84|         $objWriter->startElement('office:body');
    85|         $objWriter->startElement('office:spreadsheet');
    86|         $objWriter->writeElement('table:calculation-settings');
    87|         $this->writeSheets($objWriter);
    88|         (new AutoFilters($objWriter, $this->getParentWriter()->getSpreadsheet()))->write();
    89|         (new NamedExpressions($objWriter, $this->getParentWriter()->getSpreadsheet(), $this->formulaConvertor))->write();
    90|         $objWriter->endElement();
    91|         $objWriter->endElement();
    92|         $objWriter->endElement();
    93|         return $objWriter->getData();
    94|     }
    95|     /**
    96|      * Write sheets.
    97|      */
    98|     private function writeSheets(XMLWriter $objWriter): void
    99|     {
   100|         $spreadsheet = $this->getParentWriter()->getSpreadsheet();
   101|         $sheetCount = $spreadsheet->getSheetCount();
   102|         for ($sheetIndex = 0; $sheetIndex < $sheetCount; ++$sheetIndex) {
   103|             $objWriter->startElement('table:table');
   104|             $objWriter->writeAttribute('table:name', $spreadsheet->getSheet($sheetIndex)->getTitle());
   105|             $objWriter->writeAttribute('table:style-name', Style::TABLE_STYLE_PREFIX . (string) ($sheetIndex + 1));
   106|             $objWriter->writeElement('office:forms');
   107|             $lastColumn = 0;
   108|             foreach ($spreadsheet->getSheet($sheetIndex)->getColumnDimensions() as $columnDimension) {
   109|                 $thisColumn = $columnDimension->getColumnNumeric();
   110|                 $emptyColumns = $thisColumn - $lastColumn - 1;
   111|                 if ($emptyColumns > 0) {
   112|                     $objWriter->startElement('table:table-column');
   113|                     $objWriter->writeAttribute('table:number-columns-repeated', (string) $emptyColumns);
   114|                     $objWriter->endElement();
   115|                 }
   116|                 $lastColumn = $thisColumn;
   117|                 $objWriter->startElement('table:table-column');
   118|                 $objWriter->writeAttribute(
   119|                     'table:style-name',
   120|                     sprintf('%s_%d_%d', Style::COLUMN_STYLE_PREFIX, $sheetIndex, $columnDimension->getColumnNumeric())
   121|                 );
   122|                 $objWriter->writeAttribute('table:default-cell-style-name', 'ce0');
   123|                 $objWriter->endElement();
   124|             }
   125|             $this->writeRows($objWriter, $spreadsheet->getSheet($sheetIndex), $sheetIndex);
   126|             $objWriter->endElement();
   127|         }
   128|     }
   129|     /**
   130|      * Write rows of the specified sheet.
   131|      */
   132|     private function writeRows(XMLWriter $objWriter, Worksheet $sheet, int $sheetIndex): void
   133|     {
   134|         $numberRowsRepeated = self::NUMBER_ROWS_REPEATED_MAX;
   135|         $span_row = 0;
   136|         $rows = $sheet->getRowIterator();
   137|         foreach ($rows as $row) {
   138|             $cellIterator = $row->getCellIterator();
   139|             --$numberRowsRepeated;
   140|             if ($cellIterator->valid()) {
   141|                 $objWriter->startElement('table:table-row');
   142|                 if ($span_row) {
   143|                     if ($span_row > 1) {
   144|                         $objWriter->writeAttribute('table:number-rows-repeated', (string) $span_row);
   145|                     }
   146|                     $objWriter->startElement('table:table-cell');
   147|                     $objWriter->writeAttribute('table:number-columns-repeated', (string) self::NUMBER_COLS_REPEATED_MAX);
   148|                     $objWriter->endElement();
   149|                     $span_row = 0;
   150|                 } else {
   151|                     if ($sheet->rowDimensionExists($row->getRowIndex()) && $sheet->getRowDimension($row->getRowIndex())->getRowHeight() > 0) {
   152|                         $objWriter->writeAttribute(
   153|                             'table:style-name',
   154|                             sprintf('%s_%d_%d', Style::ROW_STYLE_PREFIX, $sheetIndex, $row->getRowIndex())
   155|                         );
   156|                     }
   157|                     $this->writeCells($objWriter, $cellIterator);
   158|                 }
   159|                 $objWriter->endElement();
   160|             } else {
   161|                 ++$span_row;
   162|             }
   163|         }
   164|     }
   165|     /**
   166|      * Write cells of the specified row.
   167|      */
   168|     private function writeCells(XMLWriter $objWriter, RowCellIterator $cells): void
   169|     {
   170|         $numberColsRepeated = self::NUMBER_COLS_REPEATED_MAX;
   171|         $prevColumn = -1;
   172|         foreach ($cells as $cell) {
   173|             /** @var Cell $cell */
   174|             $column = Coordinate::columnIndexFromString($cell->getColumn()) - 1;
   175|             $this->writeCellSpan($objWriter, $column, $prevColumn);
   176|             $objWriter->startElement('table:table-cell');
   177|             $this->writeCellMerge($objWriter, $cell);
   178|             $style = $cell->getXfIndex();
   179|             if ($style !== null) {
   180|                 $objWriter->writeAttribute('table:style-name', Style::CELL_STYLE_PREFIX . $style);
   181|             }
   182|             switch ($cell->getDataType()) {
   183|                 case DataType::TYPE_BOOL:
   184|                     $objWriter->writeAttribute('office:value-type', 'boolean');
   185|                     $objWriter->writeAttribute('office:boolean-value', $cell->getValue() ? 'true' : 'false');
   186|                     $objWriter->writeElement('text:p', Calculation::getInstance()->getLocaleBoolean($cell->getValue() ? 'TRUE' : 'FALSE'));
   187|                     break;
   188|                 case DataType::TYPE_ERROR:
   189|                     $objWriter->writeAttribute('table:formula', 'of:=#NULL!');
   190|                     $objWriter->writeAttribute('office:value-type', 'string');
   191|                     $objWriter->writeAttribute('office:string-value', '');
   192|                     $objWriter->writeElement('text:p', '#NULL!');
   193|                     break;
   194|                 case DataType::TYPE_FORMULA:
   195|                     $formulaValue = $cell->getValueString();
   196|                     if ($this->getParentWriter()->getPreCalculateFormulas()) {
   197|                         try {
   198|                             $formulaValue = $cell->getCalculatedValueString();
   199|                         } catch (CalculationException $e) {
   200|                         }
   201|                     }
   202|                     $objWriter->writeAttribute('table:formula', $this->formulaConvertor->convertFormula($cell->getValueString()));
   203|                     if (is_numeric($formulaValue)) {
   204|                         $objWriter->writeAttribute('office:value-type', 'float');
   205|                     } else {
   206|                         $objWriter->writeAttribute('office:value-type', 'string');
   207|                     }
   208|                     $objWriter->writeAttribute('office:value', $formulaValue);
   209|                     $objWriter->writeElement('text:p', $formulaValue);
   210|                     break;
   211|                 case DataType::TYPE_NUMERIC:
   212|                     $objWriter->writeAttribute('office:value-type', 'float');
   213|                     $objWriter->writeAttribute('office:value', $cell->getValueString());
   214|                     $objWriter->writeElement('text:p', $cell->getValueString());
   215|                     break;
   216|                 case DataType::TYPE_INLINE:
   217|                 case DataType::TYPE_STRING:
   218|                     $objWriter->writeAttribute('office:value-type', 'string');
   219|                     $url = $cell->getHyperlink()->getUrl();
   220|                     if (empty($url)) {
   221|                         $objWriter->writeElement('text:p', $cell->getValueString());
   222|                     } else {
   223|                         $objWriter->startElement('text:p');
   224|                         $objWriter->startElement('text:a');
   225|                         $sheets = 'sheet://';
   226|                         $lensheets = strlen($sheets);
   227|                         if (substr($url, 0, $lensheets) === $sheets) {
   228|                             $url = '#' . substr($url, $lensheets);
   229|                         }
   230|                         $objWriter->writeAttribute('xlink:href', $url);
   231|                         $objWriter->writeAttribute('xlink:type', 'simple');
   232|                         $objWriter->text($cell->getValueString());
   233|                         $objWriter->endElement(); // text:a
   234|                         $objWriter->endElement(); // text:p
   235|                     }
   236|                     break;
   237|             }
   238|             Comment::write($objWriter, $cell);
   239|             $objWriter->endElement();
   240|             $prevColumn = $column;
   241|         }
   242|         $numberColsRepeated = $numberColsRepeated - $prevColumn - 1;
   243|         if ($numberColsRepeated > 0) {
   244|             if ($numberColsRepeated > 1) {
   245|                 $objWriter->startElement('table:table-cell');
   246|                 $objWriter->writeAttribute('table:number-columns-repeated', (string) $numberColsRepeated);
   247|                 $objWriter->endElement();
   248|             } else {
   249|                 $objWriter->writeElement('table:table-cell');
   250|             }
   251|         }
   252|     }
   253|     /**
   254|      * Write span.
   255|      */
   256|     private function writeCellSpan(XMLWriter $objWriter, int $curColumn, int $prevColumn): void
   257|     {
   258|         $diff = $curColumn - $prevColumn - 1;
   259|         if (1 === $diff) {
   260|             $objWriter->writeElement('table:table-cell');
   261|         } elseif ($diff > 1) {
   262|             $objWriter->startElement('table:table-cell');
   263|             $objWriter->writeAttribute('table:number-columns-repeated', (string) $diff);
   264|             $objWriter->endElement();
   265|         }
   266|     }
   267|     /**
   268|      * Write XF cell styles.
   269|      */
   270|     private function writeXfStyles(XMLWriter $writer, Spreadsheet $spreadsheet): void
   271|     {
   272|         $styleWriter = new Style($writer);
   273|         $sheetCount = $spreadsheet->getSheetCount();
   274|         for ($i = 0; $i < $sheetCount; ++$i) {
   275|             $worksheet = $spreadsheet->getSheet($i);
   276|             $styleWriter->writeTableStyle($worksheet, $i + 1);
   277|             $worksheet->calculateColumnWidths();
   278|             foreach ($worksheet->getColumnDimensions() as $columnDimension) {
   279|                 if ($columnDimension->getWidth() !== -1.0) {
   280|                     $styleWriter->writeColumnStyles($columnDimension, $i);
   281|                 }
   282|             }
   283|         }
   284|         for ($i = 0; $i < $sheetCount; ++$i) {
   285|             $worksheet = $spreadsheet->getSheet($i);
   286|             foreach ($worksheet->getRowDimensions() as $rowDimension) {
   287|                 if ($rowDimension->getRowHeight() > 0.0) {
   288|                     $styleWriter->writeRowStyles($rowDimension, $i);
   289|                 }
   290|             }
   291|         }
   292|         foreach ($spreadsheet->getCellXfCollection() as $style) {
   293|             $styleWriter->write($style);
   294|         }
   295|     }
   296|     /**
   297|      * Write attributes for merged cell.
   298|      */
   299|     private function writeCellMerge(XMLWriter $objWriter, Cell $cell): void
   300|     {
   301|         if (!$cell->isMergeRangeValueCell()) {
   302|             return;
   303|         }
   304|         $mergeRange = Coordinate::splitRange((string) $cell->getMergeRange());
   305|         [$startCell, $endCell] = $mergeRange[0];
   306|         $start = Coordinate::coordinateFromString($startCell);
   307|         $end = Coordinate::coordinateFromString($endCell);
   308|         $columnSpan = Coordinate::columnIndexFromString($end[0]) - Coordinate::columnIndexFromString($start[0]) + 1;
   309|         $rowSpan = ((int) $end[1]) - ((int) $start[1]) + 1;
   310|         $objWriter->writeAttribute('table:number-columns-spanned', (string) $columnSpan);
   311|         $objWriter->writeAttribute('table:number-rows-spanned', (string) $rowSpan);
   312|     }
   313| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 312-352 ---
   312|                 if ($newImage === false) {
   313|                     throw new Exception("Unable to create image from $filename");
   314|                 }
   315|                 ob_start();
   316|                 imagepng($newImage);
   317|                 $blipData = ob_get_contents();
   318|                 ob_end_clean();
   319|                 break;
   320|         }
   321|         if ($blipData) {
   322|             $blip = new Blip();
   323|             $blip->setData($blipData);
   324|             $BSE = new BSE();
   325|             $BSE->setBlipType($blipType);
   326|             $BSE->setBlip($blip);
   327|             $bstoreContainer->addBSE($BSE);
   328|         }
   329|     }
   330|     private function processBaseDrawing(BstoreContainer &$bstoreContainer, BaseDrawing $drawing): void
   331|     {
   332|         if ($drawing instanceof Drawing) {
   333|             $this->processDrawing($bstoreContainer, $drawing);
   334|         } elseif ($drawing instanceof MemoryDrawing) {
   335|             $this->processMemoryDrawing($bstoreContainer, $drawing, $drawing->getRenderingFunction());
   336|         }
   337|     }
   338|     private function checkForDrawings(): bool
   339|     {
   340|         $found = false;
   341|         foreach ($this->spreadsheet->getAllSheets() as $sheet) {
   342|             if (count($sheet->getDrawingCollection()) > 0) {
   343|                 $found = true;
   344|                 break;
   345|             }
   346|         }
   347|         return $found;
   348|     }
   349|     /**
   350|      * Build the Escher object corresponding to the MSODRAWINGGROUP record.
   351|      */
   352|     private function buildWorkbookEscher(): void


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls/ConditionalHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
     3| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     4| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
     5| class ConditionalHelper
     6| {
     7|     /**
     8|      * Formula parser.
     9|      */
    10|     protected Parser $parser;
    11|     protected mixed $condition;
    12|     protected string $cellRange;
    13|     protected ?string $tokens = null;
    14|     protected int $size;
    15|     public function __construct(Parser $parser)
    16|     {
    17|         $this->parser = $parser;
    18|     }
    19|     public function processCondition(mixed $condition, string $cellRange): void
    20|     {
    21|         $this->condition = $condition;
    22|         $this->cellRange = $cellRange;
    23|         if (is_int($condition) || is_float($condition)) {
    24|             $this->size = ($condition <= 65535 ? 3 : 0x0000);
    25|             $this->tokens = pack('Cv', 0x1E, $condition);
    26|         } else {
    27|             try {
    28|                 /** @var float|int|string */
    29|                 $conditionx = $condition;
    30|                 $formula = Wizard\WizardAbstract::reverseAdjustCellRef((string) $conditionx, $cellRange);
    31|                 $this->parser->parse($formula);
    32|                 $this->tokens = $this->parser->toReversePolish();
    33|                 $this->size = strlen($this->tokens ?? '');
    34|             } catch (PhpSpreadsheetException) {
    35|                 $this->tokens = pack('Cv', 0x1E, 0);
    36|                 $this->size = 3;
    37|             }
    38|         }
    39|     }
    40|     public function tokens(): ?string
    41|     {
    42|         return $this->tokens;
    43|     }
    44|     public function size(): int
    45|     {
    46|         return $this->size;
    47|     }
    48| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls/Parser.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1271 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     5| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     6| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet as PhpspreadsheetWorksheet;
     7| use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
     8| class Parser
     9| {
    10|     /**    Constants                */
    11|     const REGEX_SHEET_TITLE_UNQUOTED = '[^\*\:\/\\\\\?\[\]\+\-\% \\\'\^\&\<\>\=\,\;\#\(\)\"\{\}]+';
    12|     const REGEX_SHEET_TITLE_QUOTED = '(([^\*\:\/\\\\\?\[\]\\\'])+|(\\\'\\\')+)+';
    13|     /**
    14|      * The index of the character we are currently looking at.
    15|      */
    16|     public int $currentCharacter;
    17|     /**
    18|      * The token we are working on.
    19|      */
    20|     public string $currentToken;
    21|     /**
    22|      * The formula to parse.
    23|      */
    24|     private string $formula;
    25|     /**
    26|      * The character ahead of the current char.
    27|      */
    28|     public string $lookAhead;
    29|     /**
    30|      * The parse tree to be generated.
    31|      */
    32|     public array|string $parseTree;
    33|     /**
    34|      * Array of external sheets.
    35|      */
    36|     private array $externalSheets;
    37|     /**
    38|      * Array of sheet references in the form of REF structures.
    39|      */
    40|     public array $references;
    41|     /**
    42|      * The Excel ptg indices.
    43|      */
    44|     private array $ptg = [
    45|         'ptgExp' => 0x01,
    46|         'ptgTbl' => 0x02,
    47|         'ptgAdd' => 0x03,
    48|         'ptgSub' => 0x04,
    49|         'ptgMul' => 0x05,
    50|         'ptgDiv' => 0x06,
    51|         'ptgPower' => 0x07,
    52|         'ptgConcat' => 0x08,
    53|         'ptgLT' => 0x09,
    54|         'ptgLE' => 0x0A,
    55|         'ptgEQ' => 0x0B,
    56|         'ptgGE' => 0x0C,
    57|         'ptgGT' => 0x0D,
    58|         'ptgNE' => 0x0E,
    59|         'ptgIsect' => 0x0F,
    60|         'ptgUnion' => 0x10,
    61|         'ptgRange' => 0x11,
    62|         'ptgUplus' => 0x12,
    63|         'ptgUminus' => 0x13,
    64|         'ptgPercent' => 0x14,
    65|         'ptgParen' => 0x15,
    66|         'ptgMissArg' => 0x16,
    67|         'ptgStr' => 0x17,
    68|         'ptgAttr' => 0x19,
    69|         'ptgSheet' => 0x1A,
    70|         'ptgEndSheet' => 0x1B,
    71|         'ptgErr' => 0x1C,
    72|         'ptgBool' => 0x1D,
    73|         'ptgInt' => 0x1E,
    74|         'ptgNum' => 0x1F,
    75|         'ptgArray' => 0x20,
    76|         'ptgFunc' => 0x21,
    77|         'ptgFuncVar' => 0x22,
    78|         'ptgName' => 0x23,
    79|         'ptgRef' => 0x24,
    80|         'ptgArea' => 0x25,
    81|         'ptgMemArea' => 0x26,
    82|         'ptgMemErr' => 0x27,
    83|         'ptgMemNoMem' => 0x28,
    84|         'ptgMemFunc' => 0x29,
    85|         'ptgRefErr' => 0x2A,
    86|         'ptgAreaErr' => 0x2B,
    87|         'ptgRefN' => 0x2C,
    88|         'ptgAreaN' => 0x2D,
    89|         'ptgMemAreaN' => 0x2E,
    90|         'ptgMemNoMemN' => 0x2F,
    91|         'ptgNameX' => 0x39,
    92|         'ptgRef3d' => 0x3A,
    93|         'ptgArea3d' => 0x3B,
    94|         'ptgRefErr3d' => 0x3C,
    95|         'ptgAreaErr3d' => 0x3D,
    96|         'ptgArrayV' => 0x40,
    97|         'ptgFuncV' => 0x41,
    98|         'ptgFuncVarV' => 0x42,
    99|         'ptgNameV' => 0x43,
   100|         'ptgRefV' => 0x44,
   101|         'ptgAreaV' => 0x45,
   102|         'ptgMemAreaV' => 0x46,
   103|         'ptgMemErrV' => 0x47,
   104|         'ptgMemNoMemV' => 0x48,
   105|         'ptgMemFuncV' => 0x49,
   106|         'ptgRefErrV' => 0x4A,
   107|         'ptgAreaErrV' => 0x4B,
   108|         'ptgRefNV' => 0x4C,
   109|         'ptgAreaNV' => 0x4D,
   110|         'ptgMemAreaNV' => 0x4E,
   111|         'ptgMemNoMemNV' => 0x4F,
   112|         'ptgFuncCEV' => 0x58,
   113|         'ptgNameXV' => 0x59,
   114|         'ptgRef3dV' => 0x5A,
   115|         'ptgArea3dV' => 0x5B,
   116|         'ptgRefErr3dV' => 0x5C,
   117|         'ptgAreaErr3dV' => 0x5D,
   118|         'ptgArrayA' => 0x60,
   119|         'ptgFuncA' => 0x61,
   120|         'ptgFuncVarA' => 0x62,
   121|         'ptgNameA' => 0x63,
   122|         'ptgRefA' => 0x64,
   123|         'ptgAreaA' => 0x65,
   124|         'ptgMemAreaA' => 0x66,
   125|         'ptgMemErrA' => 0x67,
   126|         'ptgMemNoMemA' => 0x68,
   127|         'ptgMemFuncA' => 0x69,
   128|         'ptgRefErrA' => 0x6A,
   129|         'ptgAreaErrA' => 0x6B,
   130|         'ptgRefNA' => 0x6C,
   131|         'ptgAreaNA' => 0x6D,
   132|         'ptgMemAreaNA' => 0x6E,
   133|         'ptgMemNoMemNA' => 0x6F,
   134|         'ptgFuncCEA' => 0x78,
   135|         'ptgNameXA' => 0x79,
   136|         'ptgRef3dA' => 0x7A,
   137|         'ptgArea3dA' => 0x7B,
   138|         'ptgRefErr3dA' => 0x7C,
   139|         'ptgAreaErr3dA' => 0x7D,
   140|     ];
   141|     /**
   142|      * Thanks to Michael Meeks and Gnumeric for the initial arg values.
   143|      *
   144|      * The following hash was generated by "function_locale.pl" in the distro.
   145|      * Refer to function_locale.pl for non-English function names.
   146|      *
   147|      * The array elements are as follow:
   148|      * ptg:   The Excel function ptg code.
   149|      * args:  The number of arguments that the function takes:
   150|      *           >=0 is a fixed number of arguments.
   151|      *           -1  is a variable  number of arguments.
   152|      * class: The reference, value or array class of the function args.
   153|      * vol:   The function is volatile.
   154|      */
   155|     private array $functions = [
   156|         'COUNT' => [0, -1, 0, 0],
   157|         'IF' => [1, -1, 1, 0],
   158|         'ISNA' => [2, 1, 1, 0],
   159|         'ISERROR' => [3, 1, 1, 0],
   160|         'SUM' => [4, -1, 0, 0],
   161|         'AVERAGE' => [5, -1, 0, 0],
   162|         'MIN' => [6, -1, 0, 0],
   163|         'MAX' => [7, -1, 0, 0],
   164|         'ROW' => [8, -1, 0, 0],
   165|         'COLUMN' => [9, -1, 0, 0],
   166|         'NA' => [10, 0, 0, 0],
   167|         'NPV' => [11, -1, 1, 0],
   168|         'STDEV' => [12, -1, 0, 0],
   169|         'DOLLAR' => [13, -1, 1, 0],
   170|         'FIXED' => [14, -1, 1, 0],
   171|         'SIN' => [15, 1, 1, 0],
   172|         'COS' => [16, 1, 1, 0],
   173|         'TAN' => [17, 1, 1, 0],
   174|         'ATAN' => [18, 1, 1, 0],
   175|         'PI' => [19, 0, 1, 0],
   176|         'SQRT' => [20, 1, 1, 0],
   177|         'EXP' => [21, 1, 1, 0],
   178|         'LN' => [22, 1, 1, 0],
   179|         'LOG10' => [23, 1, 1, 0],
   180|         'ABS' => [24, 1, 1, 0],
   181|         'INT' => [25, 1, 1, 0],
   182|         'SIGN' => [26, 1, 1, 0],
   183|         'ROUND' => [27, 2, 1, 0],
   184|         'LOOKUP' => [28, -1, 0, 0],
   185|         'INDEX' => [29, -1, 0, 1],
   186|         'REPT' => [30, 2, 1, 0],
   187|         'MID' => [31, 3, 1, 0],
   188|         'LEN' => [32, 1, 1, 0],
   189|         'VALUE' => [33, 1, 1, 0],
   190|         'TRUE' => [34, 0, 1, 0],
   191|         'FALSE' => [35, 0, 1, 0],
   192|         'AND' => [36, -1, 0, 0],
   193|         'OR' => [37, -1, 0, 0],
   194|         'NOT' => [38, 1, 1, 0],
   195|         'MOD' => [39, 2, 1, 0],
   196|         'DCOUNT' => [40, 3, 0, 0],
   197|         'DSUM' => [41, 3, 0, 0],
   198|         'DAVERAGE' => [42, 3, 0, 0],
   199|         'DMIN' => [43, 3, 0, 0],
   200|         'DMAX' => [44, 3, 0, 0],
   201|         'DSTDEV' => [45, 3, 0, 0],
   202|         'VAR' => [46, -1, 0, 0],
   203|         'DVAR' => [47, 3, 0, 0],
   204|         'TEXT' => [48, 2, 1, 0],
   205|         'LINEST' => [49, -1, 0, 0],
   206|         'TREND' => [50, -1, 0, 0],
   207|         'LOGEST' => [51, -1, 0, 0],
   208|         'GROWTH' => [52, -1, 0, 0],
   209|         'PV' => [56, -1, 1, 0],
   210|         'FV' => [57, -1, 1, 0],
   211|         'NPER' => [58, -1, 1, 0],
   212|         'PMT' => [59, -1, 1, 0],
   213|         'RATE' => [60, -1, 1, 0],
   214|         'MIRR' => [61, 3, 0, 0],
   215|         'IRR' => [62, -1, 0, 0],
   216|         'RAND' => [63, 0, 1, 1],
   217|         'MATCH' => [64, -1, 0, 0],
   218|         'DATE' => [65, 3, 1, 0],
   219|         'TIME' => [66, 3, 1, 0],
   220|         'DAY' => [67, 1, 1, 0],
   221|         'MONTH' => [68, 1, 1, 0],
   222|         'YEAR' => [69, 1, 1, 0],
   223|         'WEEKDAY' => [70, -1, 1, 0],
   224|         'HOUR' => [71, 1, 1, 0],
   225|         'MINUTE' => [72, 1, 1, 0],
   226|         'SECOND' => [73, 1, 1, 0],
   227|         'NOW' => [74, 0, 1, 1],
   228|         'AREAS' => [75, 1, 0, 1],
   229|         'ROWS' => [76, 1, 0, 1],
   230|         'COLUMNS' => [77, 1, 0, 1],
   231|         'OFFSET' => [78, -1, 0, 1],
   232|         'SEARCH' => [82, -1, 1, 0],
   233|         'TRANSPOSE' => [83, 1, 1, 0],
   234|         'TYPE' => [86, 1, 1, 0],
   235|         'ATAN2' => [97, 2, 1, 0],
   236|         'ASIN' => [98, 1, 1, 0],
   237|         'ACOS' => [99, 1, 1, 0],
   238|         'CHOOSE' => [100, -1, 1, 0],
   239|         'HLOOKUP' => [101, -1, 0, 0],
   240|         'VLOOKUP' => [102, -1, 0, 0],
   241|         'ISREF' => [105, 1, 0, 0],
   242|         'LOG' => [109, -1, 1, 0],
   243|         'CHAR' => [111, 1, 1, 0],
   244|         'LOWER' => [112, 1, 1, 0],
   245|         'UPPER' => [113, 1, 1, 0],
   246|         'PROPER' => [114, 1, 1, 0],
   247|         'LEFT' => [115, -1, 1, 0],
   248|         'RIGHT' => [116, -1, 1, 0],
   249|         'EXACT' => [117, 2, 1, 0],
   250|         'TRIM' => [118, 1, 1, 0],
   251|         'REPLACE' => [119, 4, 1, 0],
   252|         'SUBSTITUTE' => [120, -1, 1, 0],
   253|         'CODE' => [121, 1, 1, 0],
   254|         'FIND' => [124, -1, 1, 0],
   255|         'CELL' => [125, -1, 0, 1],
   256|         'ISERR' => [126, 1, 1, 0],
   257|         'ISTEXT' => [127, 1, 1, 0],
   258|         'ISNUMBER' => [128, 1, 1, 0],
   259|         'ISBLANK' => [129, 1, 1, 0],
   260|         'T' => [130, 1, 0, 0],
   261|         'N' => [131, 1, 0, 0],
   262|         'DATEVALUE' => [140, 1, 1, 0],
   263|         'TIMEVALUE' => [141, 1, 1, 0],
   264|         'SLN' => [142, 3, 1, 0],
   265|         'SYD' => [143, 4, 1, 0],
   266|         'DDB' => [144, -1, 1, 0],
   267|         'INDIRECT' => [148, -1, 1, 1],
   268|         'CALL' => [150, -1, 1, 0],
   269|         'CLEAN' => [162, 1, 1, 0],
   270|         'MDETERM' => [163, 1, 2, 0],
   271|         'MINVERSE' => [164, 1, 2, 0],
   272|         'MMULT' => [165, 2, 2, 0],
   273|         'IPMT' => [167, -1, 1, 0],
   274|         'PPMT' => [168, -1, 1, 0],
   275|         'COUNTA' => [169, -1, 0, 0],
   276|         'PRODUCT' => [183, -1, 0, 0],
   277|         'FACT' => [184, 1, 1, 0],
   278|         'DPRODUCT' => [189, 3, 0, 0],
   279|         'ISNONTEXT' => [190, 1, 1, 0],
   280|         'STDEVP' => [193, -1, 0, 0],
   281|         'VARP' => [194, -1, 0, 0],
   282|         'DSTDEVP' => [195, 3, 0, 0],
   283|         'DVARP' => [196, 3, 0, 0],
   284|         'TRUNC' => [197, -1, 1, 0],
   285|         'ISLOGICAL' => [198, 1, 1, 0],
   286|         'DCOUNTA' => [199, 3, 0, 0],
   287|         'USDOLLAR' => [204, -1, 1, 0],
   288|         'FINDB' => [205, -1, 1, 0],
   289|         'SEARCHB' => [206, -1, 1, 0],
   290|         'REPLACEB' => [207, 4, 1, 0],
   291|         'LEFTB' => [208, -1, 1, 0],
   292|         'RIGHTB' => [209, -1, 1, 0],
   293|         'MIDB' => [210, 3, 1, 0],
   294|         'LENB' => [211, 1, 1, 0],
   295|         'ROUNDUP' => [212, 2, 1, 0],
   296|         'ROUNDDOWN' => [213, 2, 1, 0],
   297|         'ASC' => [214, 1, 1, 0],
   298|         'DBCS' => [215, 1, 1, 0],
   299|         'RANK' => [216, -1, 0, 0],
   300|         'ADDRESS' => [219, -1, 1, 0],
   301|         'DAYS360' => [220, -1, 1, 0],
   302|         'TODAY' => [221, 0, 1, 1],
   303|         'VDB' => [222, -1, 1, 0],
   304|         'MEDIAN' => [227, -1, 0, 0],
   305|         'SUMPRODUCT' => [228, -1, 2, 0],
   306|         'SINH' => [229, 1, 1, 0],
   307|         'COSH' => [230, 1, 1, 0],
   308|         'TANH' => [231, 1, 1, 0],
   309|         'ASINH' => [232, 1, 1, 0],
   310|         'ACOSH' => [233, 1, 1, 0],
   311|         'ATANH' => [234, 1, 1, 0],
   312|         'DGET' => [235, 3, 0, 0],
   313|         'INFO' => [244, 1, 1, 1],
   314|         'DB' => [247, -1, 1, 0],
   315|         'FREQUENCY' => [252, 2, 0, 0],
   316|         'ERROR.TYPE' => [261, 1, 1, 0],
   317|         'REGISTER.ID' => [267, -1, 1, 0],
   318|         'AVEDEV' => [269, -1, 0, 0],
   319|         'BETADIST' => [270, -1, 1, 0],
   320|         'GAMMALN' => [271, 1, 1, 0],
   321|         'BETAINV' => [272, -1, 1, 0],
   322|         'BINOMDIST' => [273, 4, 1, 0],
   323|         'CHIDIST' => [274, 2, 1, 0],
   324|         'CHIINV' => [275, 2, 1, 0],
   325|         'COMBIN' => [276, 2, 1, 0],
   326|         'CONFIDENCE' => [277, 3, 1, 0],
   327|         'CRITBINOM' => [278, 3, 1, 0],
   328|         'EVEN' => [279, 1, 1, 0],
   329|         'EXPONDIST' => [280, 3, 1, 0],
   330|         'FDIST' => [281, 3, 1, 0],
   331|         'FINV' => [282, 3, 1, 0],
   332|         'FISHER' => [283, 1, 1, 0],
   333|         'FISHERINV' => [284, 1, 1, 0],
   334|         'FLOOR' => [285, 2, 1, 0],
   335|         'GAMMADIST' => [286, 4, 1, 0],
   336|         'GAMMAINV' => [287, 3, 1, 0],
   337|         'CEILING' => [288, 2, 1, 0],
   338|         'HYPGEOMDIST' => [289, 4, 1, 0],
   339|         'LOGNORMDIST' => [290, 3, 1, 0],
   340|         'LOGINV' => [291, 3, 1, 0],
   341|         'NEGBINOMDIST' => [292, 3, 1, 0],
   342|         'NORMDIST' => [293, 4, 1, 0],
   343|         'NORMSDIST' => [294, 1, 1, 0],
   344|         'NORMINV' => [295, 3, 1, 0],
   345|         'NORMSINV' => [296, 1, 1, 0],
   346|         'STANDARDIZE' => [297, 3, 1, 0],
   347|         'ODD' => [298, 1, 1, 0],
   348|         'PERMUT' => [299, 2, 1, 0],
   349|         'POISSON' => [300, 3, 1, 0],
   350|         'TDIST' => [301, 3, 1, 0],
   351|         'WEIBULL' => [302, 4, 1, 0],
   352|         'SUMXMY2' => [303, 2, 2, 0],
   353|         'SUMX2MY2' => [304, 2, 2, 0],
   354|         'SUMX2PY2' => [305, 2, 2, 0],
   355|         'CHITEST' => [306, 2, 2, 0],
   356|         'CORREL' => [307, 2, 2, 0],
   357|         'COVAR' => [308, 2, 2, 0],
   358|         'FORECAST' => [309, 3, 2, 0],
   359|         'FTEST' => [310, 2, 2, 0],
   360|         'INTERCEPT' => [311, 2, 2, 0],
   361|         'PEARSON' => [312, 2, 2, 0],
   362|         'RSQ' => [313, 2, 2, 0],
   363|         'STEYX' => [314, 2, 2, 0],
   364|         'SLOPE' => [315, 2, 2, 0],
   365|         'TTEST' => [316, 4, 2, 0],
   366|         'PROB' => [317, -1, 2, 0],
   367|         'DEVSQ' => [318, -1, 0, 0],
   368|         'GEOMEAN' => [319, -1, 0, 0],
   369|         'HARMEAN' => [320, -1, 0, 0],
   370|         'SUMSQ' => [321, -1, 0, 0],
   371|         'KURT' => [322, -1, 0, 0],
   372|         'SKEW' => [323, -1, 0, 0],
   373|         'ZTEST' => [324, -1, 0, 0],
   374|         'LARGE' => [325, 2, 0, 0],
   375|         'SMALL' => [326, 2, 0, 0],
   376|         'QUARTILE' => [327, 2, 0, 0],
   377|         'PERCENTILE' => [328, 2, 0, 0],
   378|         'PERCENTRANK' => [329, -1, 0, 0],
   379|         'MODE' => [330, -1, 2, 0],
   380|         'TRIMMEAN' => [331, 2, 0, 0],
   381|         'TINV' => [332, 2, 1, 0],
   382|         'CONCATENATE' => [336, -1, 1, 0],
   383|         'POWER' => [337, 2, 1, 0],
   384|         'RADIANS' => [342, 1, 1, 0],
   385|         'DEGREES' => [343, 1, 1, 0],
   386|         'SUBTOTAL' => [344, -1, 0, 0],
   387|         'SUMIF' => [345, -1, 0, 0],
   388|         'COUNTIF' => [346, 2, 0, 0],
   389|         'COUNTBLANK' => [347, 1, 0, 0],
   390|         'ISPMT' => [350, 4, 1, 0],
   391|         'DATEDIF' => [351, 3, 1, 0],
   392|         'DATESTRING' => [352, 1, 1, 0],
   393|         'NUMBERSTRING' => [353, 2, 1, 0],
   394|         'ROMAN' => [354, -1, 1, 0],
   395|         'GETPIVOTDATA' => [358, -1, 0, 0],
   396|         'HYPERLINK' => [359, -1, 1, 0],
   397|         'PHONETIC' => [360, 1, 0, 0],
   398|         'AVERAGEA' => [361, -1, 0, 0],
   399|         'MAXA' => [362, -1, 0, 0],
   400|         'MINA' => [363, -1, 0, 0],
   401|         'STDEVPA' => [364, -1, 0, 0],
   402|         'VARPA' => [365, -1, 0, 0],
   403|         'STDEVA' => [366, -1, 0, 0],
   404|         'VARA' => [367, -1, 0, 0],
   405|         'BAHTTEXT' => [368, 1, 0, 0],
   406|     ];
   407|     private Spreadsheet $spreadsheet;
   408|     /**
   409|      * The class constructor.
   410|      */
   411|     public function __construct(Spreadsheet $spreadsheet)
   412|     {
   413|         $this->spreadsheet = $spreadsheet;
   414|         $this->currentCharacter = 0;
   415|         $this->currentToken = ''; // The token we are working on.
   416|         $this->formula = ''; // The formula to parse.
   417|         $this->lookAhead = ''; // The character ahead of the current char.
   418|         $this->parseTree = ''; // The parse tree to be generated.
   419|         $this->externalSheets = [];
   420|         $this->references = [];
   421|     }
   422|     /**
   423|      * Convert a token to the proper ptg value.
   424|      *
   425|      * @param string $token the token to convert
   426|      *
   427|      * @return string the converted token on success
   428|      */
   429|     private function convert(string $token): string
   430|     {
   431|         if (preg_match('/"([^"]|""){0,255}"/', $token)) {
   432|             return $this->convertString($token);
   433|         }
   434|         if (is_numeric($token)) {
   435|             return $this->convertNumber($token);
   436|         }
   437|         if (preg_match('/^\$?([A-Ia-i]?[A-Za-z])\$?(\d+)$/', $token)) {
   438|             return $this->convertRef2d($token);
   439|         }
   440|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?(\\d+)$/u', $token)) {
   441|             return $this->convertRef3d($token);
   442|         }
   443|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?(\\d+)$/u", $token)) {
   444|             return $this->convertRef3d($token);
   445|         }
   446|         if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)\:(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)$/', $token)) {
   447|             return $this->convertRange2d($token);
   448|         }
   449|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)\\:\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)$/u', $token)) {
   450|             return $this->convertRange3d($token);
   451|         }
   452|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)\\:\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)$/u", $token)) {
   453|             return $this->convertRange3d($token);
   454|         }
   455|         if (isset($this->ptg[$token])) {
   456|             return pack('C', $this->ptg[$token]);
   457|         }
   458|         if (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $token) || $token == '#N/A') {
   459|             return $this->convertError($token);
   460|         }
   461|         if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/mui', $token) && $this->spreadsheet->getDefinedName($token) !== null) {
   462|             return $this->convertDefinedName($token);
   463|         }
   464|         /*if (preg_match("/[A-Z0-9\xc0-\xdc\.]+/", $token))
   465|         {
   466|             return($this->convertFunction($token, $this->_func_args));
   467|         }*/
   468|         if ($token == 'arg') {
   469|             return '';
   470|         }
   471|         if (preg_match('/^true$/i', $token)) {
   472|             return $this->convertBool(1);
   473|         }
   474|         if (preg_match('/^false$/i', $token)) {
   475|             return $this->convertBool(0);
   476|         }
   477|         throw new WriterException("Unknown token $token");
   478|     }
   479|     /**
   480|      * Convert a number token to ptgInt or ptgNum.
   481|      *
   482|      * @param float|int|string $num an integer or double for conversion to its ptg value
   483|      */
   484|     private function convertNumber(mixed $num): string
   485|     {
   486|         if ((preg_match('/^\\d+$/', (string) $num)) && ($num <= 65535)) {
   487|             return pack('Cv', $this->ptg['ptgInt'], $num);
   488|         }
   489|         if (BIFFwriter::getByteOrder()) { // if it's Big Endian
   490|             $num = strrev((string) $num);
   491|         }
   492|         return pack('Cd', $this->ptg['ptgNum'], $num);
   493|     }
   494|     private function convertBool(int $num): string
   495|     {
   496|         return pack('CC', $this->ptg['ptgBool'], $num);
   497|     }
   498|     /**
   499|      * Convert a string token to ptgStr.
   500|      *
   501|      * @param string $string a string for conversion to its ptg value
   502|      *
   503|      * @return string the converted token
   504|      */
   505|     private function convertString(string $string): string
   506|     {
   507|         $string = substr($string, 1, -1);
   508|         if (strlen($string) > 255) {
   509|             throw new WriterException('String is too long');
   510|         }
   511|         return pack('C', $this->ptg['ptgStr']) . StringHelper::UTF8toBIFF8UnicodeShort($string);
   512|     }
   513|     /**
   514|      * Convert a function to a ptgFunc or ptgFuncVarV depending on the number of
   515|      * args that it takes.
   516|      *
   517|      * @param string $token the name of the function for convertion to ptg value
   518|      * @param int $num_args the number of arguments the function receives
   519|      *
   520|      * @return string The packed ptg for the function
   521|      */
   522|     private function convertFunction(string $token, int $num_args): string
   523|     {
   524|         $args = $this->functions[$token][1];
   525|         if ($args >= 0) {
   526|             return pack('Cv', $this->ptg['ptgFuncV'], $this->functions[$token][0]);
   527|         }
   528|         return pack('CCv', $this->ptg['ptgFuncVarV'], $num_args, $this->functions[$token][0]);
   529|     }
   530|     /**
   531|      * Convert an Excel range such as A1:D4 to a ptgRefV.
   532|      *
   533|      * @param string $range An Excel range in the A1:A2
   534|      */
   535|     private function convertRange2d(string $range, int $class = 0): string
   536|     {
   537|         if (preg_match('/^(\$)?([A-Ia-i]?[A-Za-z])(\$)?(\d+)\:(\$)?([A-Ia-i]?[A-Za-z])(\$)?(\d+)$/', $range)) {
   538|             [$cell1, $cell2] = explode(':', $range);
   539|         } else {
   540|             throw new WriterException('Unknown range separator');
   541|         }
   542|         [$row1, $col1] = $this->cellToPackedRowcol($cell1);
   543|         [$row2, $col2] = $this->cellToPackedRowcol($cell2);
   544|         if ($class == 0) {
   545|             $ptgArea = pack('C', $this->ptg['ptgArea']);
   546|         } elseif ($class == 1) {
   547|             $ptgArea = pack('C', $this->ptg['ptgAreaV']);
   548|         } elseif ($class == 2) {
   549|             $ptgArea = pack('C', $this->ptg['ptgAreaA']);
   550|         } else {
   551|             throw new WriterException("Unknown class $class");
   552|         }
   553|         return $ptgArea . $row1 . $row2 . $col1 . $col2;
   554|     }
   555|     /**
   556|      * Convert an Excel 3d range such as "Sheet1!A1:D4" or "Sheet1:Sheet2!A1:D4" to
   557|      * a ptgArea3d.
   558|      *
   559|      * @param string $token an Excel range in the Sheet1!A1:A2 format
   560|      *
   561|      * @return string the packed ptgArea3d token on success
   562|      */
   563|     private function convertRange3d(string $token): string
   564|     {
   565|         [$ext_ref, $range] = PhpspreadsheetWorksheet::extractSheetTitle($token, true);
   566|         $ext_ref = $this->getRefIndex($ext_ref ?? '');
   567|         [$cell1, $cell2] = explode(':', $range ?? '');
   568|         if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\\d+)$/', $cell1)) {
   569|             [$row1, $col1] = $this->cellToPackedRowcol($cell1);
   570|             [$row2, $col2] = $this->cellToPackedRowcol($cell2);
   571|         } else { // It's a rows range (like 26:27)
   572|             [$row1, $col1, $row2, $col2] = $this->rangeToPackedRange($cell1 . ':' . $cell2);
   573|         }
   574|         $ptgArea = pack('C', $this->ptg['ptgArea3d']);
   575|         return $ptgArea . $ext_ref . $row1 . $row2 . $col1 . $col2;
   576|     }
   577|     /**
   578|      * Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
   579|      *
   580|      * @param string $cell An Excel cell reference
   581|      *
   582|      * @return string The cell in packed() format with the corresponding ptg
   583|      */
   584|     private function convertRef2d(string $cell): string
   585|     {
   586|         $cell_array = $this->cellToPackedRowcol($cell);
   587|         [$row, $col] = $cell_array;
   588|         $ptgRef = pack('C', $this->ptg['ptgRefA']);
   589|         return $ptgRef . $row . $col;
   590|     }
   591|     /**
   592|      * Convert an Excel 3d reference such as "Sheet1!A1" or "Sheet1:Sheet2!A1" to a
   593|      * ptgRef3d.
   594|      *
   595|      * @param string $cell An Excel cell reference
   596|      *
   597|      * @return string the packed ptgRef3d token on success
   598|      */
   599|     private function convertRef3d(string $cell): string
   600|     {
   601|         [$ext_ref, $cell] = PhpspreadsheetWorksheet::extractSheetTitle($cell, true);
   602|         $ext_ref = $this->getRefIndex($ext_ref ?? '');
   603|         [$row, $col] = $this->cellToPackedRowcol($cell ?? '');
   604|         $ptgRef = pack('C', $this->ptg['ptgRef3dA']);
   605|         return $ptgRef . $ext_ref . $row . $col;
   606|     }
   607|     /**
   608|      * Convert an error code to a ptgErr.
   609|      *
   610|      * @param string $errorCode The error code for conversion to its ptg value
   611|      *
   612|      * @return string The error code ptgErr
   613|      */
   614|     private function convertError(string $errorCode): string
   615|     {
   616|         return match ($errorCode) {
   617|             '#NULL!' => pack('C', 0x00),
   618|             '#DIV/0!' => pack('C', 0x07),
   619|             '#VALUE!' => pack('C', 0x0F),
   620|             '#REF!' => pack('C', 0x17),
   621|             '#NAME?' => pack('C', 0x1D),
   622|             '#NUM!' => pack('C', 0x24),
   623|             '#N/A' => pack('C', 0x2A),
   624|             default => pack('C', 0xFF),
   625|         };
   626|     }
   627|     private bool $tryDefinedName = false;
   628|     private function convertDefinedName(string $name): string
   629|     {
   630|         if (strlen($name) > 255) {
   631|             throw new WriterException('Defined Name is too long');
   632|         }
   633|         if ($this->tryDefinedName) {
   634|             $nameReference = 1;
   635|             foreach ($this->spreadsheet->getDefinedNames() as $definedName) {
   636|                 if ($name === $definedName->getName()) {
   637|                     break;
   638|                 }
   639|                 ++$nameReference;
   640|             }
   641|             $ptgRef = pack('Cvxx', $this->ptg['ptgName'], $nameReference);
   642|             return $ptgRef;
   643|         }
   644|         throw new WriterException('Cannot yet write formulae with defined names to Xls');
   645|     }
   646|     /**
   647|      * Look up the REF index that corresponds to an external sheet name
   648|      * (or range). If it doesn't exist yet add it to the workbook's references
   649|      * array. It assumes all sheet names given must exist.
   650|      *
   651|      * @param string $ext_ref The name of the external reference
   652|      *
   653|      * @return string The reference index in packed() format on success
   654|      */
   655|     private function getRefIndex(string $ext_ref): string
   656|     {
   657|         $ext_ref = (string) preg_replace(["/^'/", "/'$/"], ['', ''], $ext_ref); // Remove leading and trailing ' if any.
   658|         $ext_ref = str_replace('\'\'', '\'', $ext_ref); // Replace escaped '' with '
   659|         if (preg_match('/:/', $ext_ref)) {
   660|             [$sheet_name1, $sheet_name2] = explode(':', $ext_ref);
   661|             $sheet1 = $this->getSheetIndex($sheet_name1);
   662|             if ($sheet1 == -1) {
   663|                 throw new WriterException("Unknown sheet name $sheet_name1 in formula");
   664|             }
   665|             $sheet2 = $this->getSheetIndex($sheet_name2);
   666|             if ($sheet2 == -1) {
   667|                 throw new WriterException("Unknown sheet name $sheet_name2 in formula");
   668|             }
   669|             if ($sheet1 > $sheet2) {
   670|                 [$sheet1, $sheet2] = [$sheet2, $sheet1];
   671|             }
   672|         } else { // Single sheet name only.
   673|             $sheet1 = $this->getSheetIndex($ext_ref);
   674|             if ($sheet1 == -1) {
   675|                 throw new WriterException("Unknown sheet name $ext_ref in formula");
   676|             }
   677|             $sheet2 = $sheet1;
   678|         }
   679|         $supbook_index = 0x00;
   680|         $ref = pack('vvv', $supbook_index, $sheet1, $sheet2);
   681|         $totalreferences = count($this->references);
   682|         $index = -1;
   683|         for ($i = 0; $i < $totalreferences; ++$i) {
   684|             if ($ref == $this->references[$i]) {
   685|                 $index = $i;
   686|                 break;
   687|             }
   688|         }
   689|         if ($index == -1) {
   690|             $this->references[$totalreferences] = $ref;
   691|             $index = $totalreferences;
   692|         }
   693|         return pack('v', $index);
   694|     }
   695|     /**
   696|      * Look up the index that corresponds to an external sheet name. The hash of
   697|      * sheet names is updated by the addworksheet() method of the
   698|      * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
   699|      *
   700|      * @param string $sheet_name Sheet name
   701|      *
   702|      * @return int The sheet index, -1 if the sheet was not found
   703|      */
   704|     private function getSheetIndex(string $sheet_name): int
   705|     {
   706|         if (!isset($this->externalSheets[$sheet_name])) {
   707|             return -1;
   708|         }
   709|         return $this->externalSheets[$sheet_name];
   710|     }
   711|     /**
   712|      * This method is used to update the array of sheet names. It is
   713|      * called by the addWorksheet() method of the
   714|      * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
   715|      *
   716|      * @param string $name The name of the worksheet being added
   717|      * @param int $index The index of the worksheet being added
   718|      *
   719|      * @see Workbook::addWorksheet
   720|      */
   721|     public function setExtSheet(string $name, int $index): void
   722|     {
   723|         $this->externalSheets[$name] = $index;
   724|     }
   725|     /**
   726|      * pack() row and column into the required 3 or 4 byte format.
   727|      *
   728|      * @param string $cell The Excel cell reference to be packed
   729|      *
   730|      * @return array Array containing the row and column in packed() format
   731|      */
   732|     private function cellToPackedRowcol(string $cell): array
   733|     {
   734|         $cell = strtoupper($cell);
   735|         [$row, $col, $row_rel, $col_rel] = $this->cellToRowcol($cell);
   736|         if ($col >= 256) {
   737|             throw new WriterException("Column in: $cell greater than 255");
   738|         }
   739|         if ($row >= 65536) {
   740|             throw new WriterException("Row in: $cell greater than 65536 ");
   741|         }
   742|         $col |= $col_rel << 14;
   743|         $col |= $row_rel << 15;
   744|         $col = pack('v', $col);
   745|         $row = pack('v', $row);
   746|         return [$row, $col];
   747|     }
   748|     /**
   749|      * pack() row range into the required 3 or 4 byte format.
   750|      * Just using maximum col/rows, which is probably not the correct solution.
   751|      *
   752|      * @param string $range The Excel range to be packed
   753|      *
   754|      * @return array Array containing (row1,col1,row2,col2) in packed() format
   755|      */
   756|     private function rangeToPackedRange(string $range): array
   757|     {
   758|         preg_match('/(\$)?(\d+)\:(\$)?(\d+)/', $range, $match);
   759|         $row1_rel = empty($match[1]) ? 1 : 0;
   760|         $row1 = $match[2];
   761|         $row2_rel = empty($match[3]) ? 1 : 0;
   762|         $row2 = $match[4];
   763|         --$row1;
   764|         --$row2;
   765|         $col1 = 0;
   766|         $col2 = 65535; // FIXME: maximum possible value for Excel 5 (change this!!!)
   767|         if (($row1 >= 65536) || ($row2 >= 65536)) {
   768|             throw new WriterException("Row in: $range greater than 65536 ");
   769|         }
   770|         $col1 |= $row1_rel << 15;
   771|         $col2 |= $row2_rel << 15;
   772|         $col1 = pack('v', $col1);
   773|         $col2 = pack('v', $col2);
   774|         $row1 = pack('v', $row1);
   775|         $row2 = pack('v', $row2);
   776|         return [$row1, $col1, $row2, $col2];
   777|     }
   778|     /**
   779|      * Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
   780|      * indexed row and column number. Also returns two (0,1) values to indicate
   781|      * whether the row or column are relative references.
   782|      *
   783|      * @param string $cell the Excel cell reference in A1 format
   784|      */
   785|     private function cellToRowcol(string $cell): array
   786|     {
   787|         preg_match('/(\$)?([A-I]?[A-Z])(\$)?(\d+)/', $cell, $match);
   788|         $col_rel = empty($match[1]) ? 1 : 0;
   789|         $col_ref = $match[2];
   790|         $row_rel = empty($match[3]) ? 1 : 0;
   791|         $row = $match[4];
   792|         $expn = strlen($col_ref) - 1;
   793|         $col = 0;
   794|         $col_ref_length = strlen($col_ref);
   795|         for ($i = 0; $i < $col_ref_length; ++$i) {
   796|             $col += (ord($col_ref[$i]) - 64) * 26 ** $expn;
   797|             --$expn;
   798|         }
   799|         --$row;
   800|         --$col;
   801|         return [$row, $col, $row_rel, $col_rel];
   802|     }
   803|     /**
   804|      * Advance to the next valid token.
   805|      */
   806|     private function advance(): void
   807|     {
   808|         $token = '';
   809|         $i = $this->currentCharacter;
   810|         $formula_length = strlen($this->formula);
   811|         if ($i < $formula_length) {
   812|             while ($this->formula[$i] == ' ') {
   813|                 ++$i;
   814|             }
   815|             if ($i < ($formula_length - 1)) {
   816|                 $this->lookAhead = $this->formula[$i + 1];
   817|             }
   818|             $token = '';
   819|         }
   820|         while ($i < $formula_length) {
   821|             $token .= $this->formula[$i];
   822|             if ($i < ($formula_length - 1)) {
   823|                 $this->lookAhead = $this->formula[$i + 1];
   824|             } else {
   825|                 $this->lookAhead = '';
   826|             }
   827|             if ($this->match($token) != '') {
   828|                 $this->currentCharacter = $i + 1;
   829|                 $this->currentToken = $token;
   830|                 return;
   831|             }
   832|             if ($i < ($formula_length - 2)) {
   833|                 $this->lookAhead = $this->formula[$i + 2];
   834|             } else { // if we run out of characters lookAhead becomes empty
   835|                 $this->lookAhead = '';
   836|             }
   837|             ++$i;
   838|         }
   839|     }
   840|     /**
   841|      * Checks if it's a valid token.
   842|      *
   843|      * @param string $token the token to check
   844|      *
   845|      * @return string The checked token or empty string on failure
   846|      */
   847|     private function match(string $token): string
   848|     {
   849|         switch ($token) {
   850|             case '+':
   851|             case '-':
   852|             case '*':
   853|             case '/':
   854|             case '(':
   855|             case ')':
   856|             case ',':
   857|             case ';':
   858|             case '>=':
   859|             case '<=':
   860|             case '=':
   861|             case '<>':
   862|             case '^':
   863|             case '&':
   864|             case '%':
   865|                 return $token;
   866|             case '>':
   867|                 if ($this->lookAhead === '=') { // it's a GE token
   868|                     break;
   869|                 }
   870|                 return $token;
   871|             case '<':
   872|                 if (($this->lookAhead === '=') || ($this->lookAhead === '>')) {
   873|                     break;
   874|                 }
   875|                 return $token;
   876|         }
   877|         if (preg_match('/^\$?[A-Ia-i]?[A-Za-z]\$?\d+$/', $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.') && ($this->lookAhead !== '!')) {
   878|             return $token;
   879|         }
   880|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?\\d+$/u', $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.')) {
   881|             return $token;
   882|         }
   883|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?\\d+$/u", $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.')) {
   884|             return $token;
   885|         }
   886|         if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+:(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $token) && !preg_match('/\d/', $this->lookAhead)) {
   887|             return $token;
   888|         }
   889|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?\\d+:\$?([A-Ia-i]?[A-Za-z])?\$?\\d+$/u', $token) && !preg_match('/\d/', $this->lookAhead)) {
   890|             return $token;
   891|         }
   892|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+:\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+$/u", $token) && !preg_match('/\d/', $this->lookAhead)) {
   893|             return $token;
   894|         }
   895|         if (is_numeric($token) && (!is_numeric($token . $this->lookAhead) || ($this->lookAhead == '')) && ($this->lookAhead !== '!') && ($this->lookAhead !== ':')) {
   896|             return $token;
   897|         }
   898|         if (preg_match('/"([^"]|""){0,255}"/', $token) && $this->lookAhead !== '"' && (substr_count($token, '"') % 2 == 0)) {
   899|             return $token;
   900|         }
   901|         if (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $token) || $token === '#N/A') {
   902|             return $token;
   903|         }
   904|         if (preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/i", $token) && ($this->lookAhead === '(')) {
   905|             return $token;
   906|         }
   907|         if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $token) && $this->spreadsheet->getDefinedName($token) !== null) {
   908|             return $token;
   909|         }
   910|         if (preg_match('/^true$/i', $token) && ($this->lookAhead === ')' || $this->lookAhead === ',')) {
   911|             return $token;
   912|         }
   913|         if (preg_match('/^false$/i', $token) && ($this->lookAhead === ')' || $this->lookAhead === ',')) {
   914|             return $token;
   915|         }
   916|         if (str_ends_with($token, ')')) {
   917|             return $token;
   918|         }
   919|         return '';
   920|     }
   921|     /**
   922|      * The parsing method. It parses a formula.
   923|      *
   924|      * @param string $formula the formula to parse, without the initial equal
   925|      *                        sign (=)
   926|      *
   927|      * @return bool true on success
   928|      */
   929|     public function parse(string $formula): bool
   930|     {
   931|         $this->currentCharacter = 0;
   932|         $this->formula = (string) $formula;
   933|         $this->lookAhead = $formula[1] ?? '';
   934|         $this->advance();
   935|         $this->parseTree = $this->condition();
   936|         return true;
   937|     }
   938|     /**
   939|      * It parses a condition. It assumes the following rule:
   940|      * Cond -> Expr [(">" | "<") Expr].
   941|      *
   942|      * @return array The parsed ptg'd tree on success
   943|      */
   944|     private function condition(): array
   945|     {
   946|         $result = $this->expression();
   947|         if ($this->currentToken == '<') {
   948|             $this->advance();
   949|             $result2 = $this->expression();
   950|             $result = $this->createTree('ptgLT', $result, $result2);
   951|         } elseif ($this->currentToken == '>') {
   952|             $this->advance();
   953|             $result2 = $this->expression();
   954|             $result = $this->createTree('ptgGT', $result, $result2);
   955|         } elseif ($this->currentToken == '<=') {
   956|             $this->advance();
   957|             $result2 = $this->expression();
   958|             $result = $this->createTree('ptgLE', $result, $result2);
   959|         } elseif ($this->currentToken == '>=') {
   960|             $this->advance();
   961|             $result2 = $this->expression();
   962|             $result = $this->createTree('ptgGE', $result, $result2);
   963|         } elseif ($this->currentToken == '=') {
   964|             $this->advance();
   965|             $result2 = $this->expression();
   966|             $result = $this->createTree('ptgEQ', $result, $result2);
   967|         } elseif ($this->currentToken == '<>') {
   968|             $this->advance();
   969|             $result2 = $this->expression();
   970|             $result = $this->createTree('ptgNE', $result, $result2);
   971|         }
   972|         return $result;
   973|     }
   974|     /**
   975|      * It parses a expression. It assumes the following rule:
   976|      * Expr -> Term [("+" | "-") Term]
   977|      *      -> "string"
   978|      *      -> "-" Term : Negative value
   979|      *      -> "+" Term : Positive value
   980|      *      -> Error code.
   981|      *
   982|      * @return array The parsed ptg'd tree on success
   983|      */
   984|     private function expression(): array
   985|     {
   986|         if (preg_match('/"([^"]|""){0,255}"/', $this->currentToken)) {
   987|             $tmp = str_replace('""', '"', $this->currentToken);
   988|             if (($tmp == '"') || ($tmp == '')) {
   989|                 $tmp = '""';
   990|             }
   991|             $result = $this->createTree($tmp, '', '');
   992|             $this->advance();
   993|             return $result;
   994|         } elseif (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $this->currentToken) || $this->currentToken == '#N/A') { // error code
   995|             $result = $this->createTree($this->currentToken, 'ptgErr', '');
   996|             $this->advance();
   997|             return $result;
   998|         } elseif ($this->currentToken == '-') { // negative value
   999|             $this->advance();
  1000|             $result2 = $this->expression();
  1001|             return $this->createTree('ptgUminus', $result2, '');
  1002|         } elseif ($this->currentToken == '+') { // positive value
  1003|             $this->advance();
  1004|             $result2 = $this->expression();
  1005|             return $this->createTree('ptgUplus', $result2, '');
  1006|         }
  1007|         $result = $this->term();
  1008|         while ($this->currentToken === '&') {
  1009|             $this->advance();
  1010|             $result2 = $this->expression();
  1011|             $result = $this->createTree('ptgConcat', $result, $result2);
  1012|         }
  1013|         while (
  1014|             ($this->currentToken == '+')
  1015|             || ($this->currentToken == '-')
  1016|             || ($this->currentToken == '^')
  1017|         ) {
  1018|             if ($this->currentToken == '+') {
  1019|                 $this->advance();
  1020|                 $result2 = $this->term();
  1021|                 $result = $this->createTree('ptgAdd', $result, $result2);
  1022|             } elseif ($this->currentToken == '-') {
  1023|                 $this->advance();
  1024|                 $result2 = $this->term();
  1025|                 $result = $this->createTree('ptgSub', $result, $result2);
  1026|             } else {
  1027|                 $this->advance();
  1028|                 $result2 = $this->term();
  1029|                 $result = $this->createTree('ptgPower', $result, $result2);
  1030|             }
  1031|         }
  1032|         return $result;
  1033|     }
  1034|     /**
  1035|      * This function just introduces a ptgParen element in the tree, so that Excel
  1036|      * doesn't get confused when working with a parenthesized formula afterwards.
  1037|      *
  1038|      * @return array The parsed ptg'd tree
  1039|      *
  1040|      * @see fact()
  1041|      */
  1042|     private function parenthesizedExpression(): array
  1043|     {
  1044|         return $this->createTree('ptgParen', $this->expression(), '');
  1045|     }
  1046|     /**
  1047|      * It parses a term. It assumes the following rule:
  1048|      * Term -> Fact [("*" | "/") Fact].
  1049|      *
  1050|      * @return array The parsed ptg'd tree on success
  1051|      */
  1052|     private function term(): array
  1053|     {
  1054|         $result = $this->fact();
  1055|         while (
  1056|             ($this->currentToken == '*')
  1057|             || ($this->currentToken == '/')
  1058|         ) {
  1059|             if ($this->currentToken == '*') {
  1060|                 $this->advance();
  1061|                 $result2 = $this->fact();
  1062|                 $result = $this->createTree('ptgMul', $result, $result2);
  1063|             } else {
  1064|                 $this->advance();
  1065|                 $result2 = $this->fact();
  1066|                 $result = $this->createTree('ptgDiv', $result, $result2);
  1067|             }
  1068|         }
  1069|         return $result;
  1070|     }
  1071|     /**
  1072|      * It parses a factor. It assumes the following rule:
  1073|      * Fact -> ( Expr )
  1074|      *       | CellRef
  1075|      *       | CellRange
  1076|      *       | Number
  1077|      *       | Function.
  1078|      *
  1079|      * @return array The parsed ptg'd tree on success
  1080|      */
  1081|     private function fact(): array
  1082|     {
  1083|         $currentToken = $this->currentToken;
  1084|         if ($currentToken === '(') {
  1085|             $this->advance(); // eat the "("
  1086|             $result = $this->parenthesizedExpression();
  1087|             if ($this->currentToken !== ')') {
  1088|                 throw new WriterException("')' token expected.");
  1089|             }
  1090|             $this->advance(); // eat the ")"
  1091|             return $result;
  1092|         }
  1093|         if (preg_match('/^\$?[A-Ia-i]?[A-Za-z]\$?\d+$/', $this->currentToken)) {
  1094|             $result = $this->createTree($this->currentToken, '', '');
  1095|             $this->advance();
  1096|             return $result;
  1097|         }
  1098|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?\\d+$/u', $this->currentToken)) {
  1099|             $result = $this->createTree($this->currentToken, '', '');
  1100|             $this->advance();
  1101|             return $result;
  1102|         }
  1103|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?\\d+$/u", $this->currentToken)) {
  1104|             $result = $this->createTree($this->currentToken, '', '');
  1105|             $this->advance();
  1106|             return $result;
  1107|         }
  1108|         if (
  1109|             preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+:(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $this->currentToken)
  1110|             || preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+\.\.(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $this->currentToken)
  1111|         ) {
  1112|             $result = $this->createTree($this->currentToken, '', '');
  1113|             $this->advance();
  1114|             return $result;
  1115|         }
  1116|         if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?\\d+:\$?([A-Ia-i]?[A-Za-z])?\$?\\d+$/u', $this->currentToken)) {
  1117|             $result = $this->createTree($this->currentToken, '', '');
  1118|             $this->advance();
  1119|             return $result;
  1120|         }
  1121|         if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+:\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+$/u", $this->currentToken)) {
  1122|             $result = $this->createTree($this->currentToken, '', '');
  1123|             $this->advance();
  1124|             return $result;
  1125|         }
  1126|         if (is_numeric($this->currentToken)) {
  1127|             if ($this->lookAhead === '%') {
  1128|                 $result = $this->createTree('ptgPercent', $this->currentToken, '');
  1129|                 $this->advance(); // Skip the percentage operator once we've pre-built that tree
  1130|             } else {
  1131|                 $result = $this->createTree($this->currentToken, '', '');
  1132|             }
  1133|             $this->advance();
  1134|             return $result;
  1135|         }
  1136|         if (preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/i", $this->currentToken) && ($this->lookAhead === '(')) {
  1137|             return $this->func();
  1138|         }
  1139|         if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $this->currentToken) && $this->spreadsheet->getDefinedName($this->currentToken) !== null) {
  1140|             $result = $this->createTree('ptgName', $this->currentToken, '');
  1141|             $this->advance();
  1142|             return $result;
  1143|         }
  1144|         if (preg_match('/^true|false$/i', $this->currentToken)) {
  1145|             $result = $this->createTree($this->currentToken, '', '');
  1146|             $this->advance();
  1147|             return $result;
  1148|         }
  1149|         throw new WriterException('Syntax error: ' . $this->currentToken . ', lookahead: ' . $this->lookAhead . ', current char: ' . $this->currentCharacter);
  1150|     }
  1151|     /**
  1152|      * It parses a function call. It assumes the following rule:
  1153|      * Func -> ( Expr [,Expr]* ).
  1154|      *
  1155|      * @return array The parsed ptg'd tree on success
  1156|      */
  1157|     private function func(): array
  1158|     {
  1159|         $num_args = 0; // number of arguments received
  1160|         $function = strtoupper($this->currentToken);
  1161|         $result = ''; // initialize result
  1162|         $this->advance();
  1163|         $this->advance(); // eat the "("
  1164|         while ($this->currentToken !== ')') {
  1165|             if ($num_args > 0) {
  1166|                 if ($this->currentToken === ',' || $this->currentToken === ';') {
  1167|                     $this->advance(); // eat the "," or ";"
  1168|                 } else {
  1169|                     throw new WriterException("Syntax error: comma expected in function $function, arg #{$num_args}");
  1170|                 }
  1171|                 $result2 = $this->condition();
  1172|                 $result = $this->createTree('arg', $result, $result2);
  1173|             } else { // first argument
  1174|                 $result2 = $this->condition();
  1175|                 $result = $this->createTree('arg', '', $result2);
  1176|             }
  1177|             ++$num_args;
  1178|         }
  1179|         if (!isset($this->functions[$function])) {
  1180|             throw new WriterException("Function $function() doesn't exist");
  1181|         }
  1182|         $args = $this->functions[$function][1];
  1183|         if (($args >= 0) && ($args != $num_args)) {
  1184|             throw new WriterException("Incorrect number of arguments in function $function() ");
  1185|         }
  1186|         $result = $this->createTree($function, $result, $num_args);
  1187|         $this->advance(); // eat the ")"
  1188|         return $result;
  1189|     }
  1190|     /**
  1191|      * Creates a tree. In fact an array which may have one or two arrays (sub-trees)
  1192|      * as elements.
  1193|      *
  1194|      * @param mixed $value the value of this node
  1195|      * @param mixed $left the left array (sub-tree) or a final node
  1196|      * @param mixed $right the right array (sub-tree) or a final node
  1197|      *
  1198|      * @return array A tree
  1199|      */
  1200|     private function createTree(mixed $value, mixed $left, mixed $right): array
  1201|     {
  1202|         return ['value' => $value, 'left' => $left, 'right' => $right];
  1203|     }
  1204|     /**
  1205|      * Builds a string containing the tree in reverse polish notation (What you
  1206|      * would use in a HP calculator stack).
  1207|      * The following tree:.
  1208|      *
  1209|      *    +
  1210|      *   / \
  1211|      *  2   3
  1212|      *
  1213|      * produces: "23+"
  1214|      *
  1215|      * The following tree:
  1216|      *
  1217|      *    +
  1218|      *   / \
  1219|      *  3   *
  1220|      *     / \
  1221|      *    6   A1
  1222|      *
  1223|      * produces: "36A1*+"
  1224|      *
  1225|      * In fact all operands, functions, references, etc... are written as ptg's
  1226|      *
  1227|      * @param array $tree the optional tree to convert
  1228|      *
  1229|      * @return string The tree in reverse polish notation
  1230|      */
  1231|     public function toReversePolish(array $tree = []): string
  1232|     {
  1233|         $polish = ''; // the string we are going to return
  1234|         if (empty($tree)) { // If it's the first call use parseTree
  1235|             $tree = $this->parseTree;
  1236|         }
  1237|         if (!is_array($tree) || !isset($tree['left'], $tree['right'], $tree['value'])) {
  1238|             throw new WriterException('Unexpected non-array');
  1239|         }
  1240|         if (is_array($tree['left'])) {
  1241|             $converted_tree = $this->toReversePolish($tree['left']);
  1242|             $polish .= $converted_tree;
  1243|         } elseif ($tree['left'] != '') { // It's a final node
  1244|             $converted_tree = $this->convert($tree['left']);
  1245|             $polish .= $converted_tree;
  1246|         }
  1247|         if (is_array($tree['right'])) {
  1248|             $converted_tree = $this->toReversePolish($tree['right']);
  1249|             $polish .= $converted_tree;
  1250|         } elseif ($tree['right'] != '') { // It's a final node
  1251|             $converted_tree = $this->convert($tree['right']);
  1252|             $polish .= $converted_tree;
  1253|         }
  1254|         if (
  1255|             preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/", $tree['value'])
  1256|             && !preg_match('/^([A-Ia-i]?[A-Za-z])(\d+)$/', $tree['value'])
  1257|             && !preg_match('/^[A-Ia-i]?[A-Za-z](\\d+)\\.\\.[A-Ia-i]?[A-Za-z](\\d+)$/', $tree['value'])
  1258|             && !is_numeric($tree['value'])
  1259|             && !isset($this->ptg[$tree['value']])
  1260|         ) {
  1261|             if ($tree['left'] != '') {
  1262|                 $left_tree = $this->toReversePolish($tree['left']);
  1263|             } else {
  1264|                 $left_tree = '';
  1265|             }
  1266|             return $left_tree . $this->convertFunction($tree['value'], $tree['right']);
  1267|         }
  1268|         $converted_tree = $this->convert($tree['value']);
  1269|         return $polish . $converted_tree;
  1270|     }
  1271| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls/Style/ColorMap.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xls\Style;
     3| use PhpOffice\PhpSpreadsheet\Style\Color;
     4| /*
     5|  * Static array incorrectly used by Xls Writer for Conditional Styles.
     6|  *
     7|  * @deprecated since version 2.2
     8|  *
     9|  * @codecoverageignore
    10|  */
    11| class ColorMap
    12| {
    13|     /**
    14|      * @var array<string, int>
    15|      */
    16|     private static array $colorMap = [
    17|         '#000000' => 0x08,
    18|         '#FFFFFF' => 0x09,
    19|         '#FF0000' => 0x0A,
    20|         '#00FF00' => 0x0B,
    21|         '#0000FF' => 0x0C,
    22|         '#FFFF00' => 0x0D,
    23|         '#FF00FF' => 0x0E,
    24|         '#00FFFF' => 0x0F,
    25|         '#800000' => 0x10,
    26|         '#008000' => 0x11,
    27|         '#000080' => 0x12,
    28|         '#808000' => 0x13,
    29|         '#800080' => 0x14,
    30|         '#008080' => 0x15,
    31|         '#C0C0C0' => 0x16,
    32|         '#808080' => 0x17,
    33|         '#9999FF' => 0x18,
    34|         '#993366' => 0x19,
    35|         '#FFFFCC' => 0x1A,
    36|         '#CCFFFF' => 0x1B,
    37|         '#660066' => 0x1C,
    38|         '#FF8080' => 0x1D,
    39|         '#0066CC' => 0x1E,
    40|         '#CCCCFF' => 0x1F,
    41|         '#00CCFF' => 0x28,
    42|         '#CCFFCC' => 0x2A,
    43|         '#FFFF99' => 0x2B,
    44|         '#99CCFF' => 0x2C,
    45|         '#FF99CC' => 0x2D,
    46|         '#CC99FF' => 0x2E,
    47|         '#FFCC99' => 0x2F,
    48|         '#3366FF' => 0x30,
    49|         '#33CCCC' => 0x31,
    50|         '#99CC00' => 0x32,
    51|         '#FFCC00' => 0x33,
    52|         '#FF9900' => 0x34,
    53|         '#FF6600' => 0x35,
    54|         '#666699' => 0x36,
    55|         '#969696' => 0x37,
    56|         '#003366' => 0x38,
    57|         '#339966' => 0x39,
    58|         '#003300' => 0x3A,
    59|         '#333300' => 0x3B,
    60|         '#993300' => 0x3C,
    61|         '#333399' => 0x3E,
    62|         '#333333' => 0x3F,
    63|     ];
    64|     public static function lookup(Color $color, int $defaultIndex = 0x00): int
    65|     {
    66|         $colorRgb = strtoupper($color->getRGB());
    67|         if (is_string($colorRgb) && array_key_exists("#{$colorRgb}", self::$colorMap)) {
    68|             return self::$colorMap["#{$colorRgb}"];
    69|         }
    70|         return $defaultIndex;
    71|     }
    72| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls/Workbook.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-820 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     5| use PhpOffice\PhpSpreadsheet\DefinedName;
     6| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     7| use PhpOffice\PhpSpreadsheet\Shared\Date;
     8| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     9| use PhpOffice\PhpSpreadsheet\Spreadsheet;
    10| use PhpOffice\PhpSpreadsheet\Style\Style;
    11| class Workbook extends BIFFwriter
    12| {
    13|     /**
    14|      * Formula parser.
    15|      */
    16|     private Parser $parser;
    17|     /*
    18|      * The BIFF file size for the workbook. Not currently used.
    19|      *
    20|      * @see calcSheetOffsets()
    21|      */
    22|     /**
    23|      * XF Writers.
    24|      *
    25|      * @var Xf[]
    26|      */
    27|     private array $xfWriters = [];
    28|     /**
    29|      * Array containing the colour palette.
    30|      */
    31|     private array $palette;
    32|     /**
    33|      * The codepage indicates the text encoding used for strings.
    34|      */
    35|     private int $codepage;
    36|     /**
    37|      * The country code used for localization.
    38|      */
    39|     private int $countryCode;
    40|     /**
    41|      * Workbook.
    42|      */
    43|     private Spreadsheet $spreadsheet;
    44|     /**
    45|      * Fonts writers.
    46|      *
    47|      * @var Font[]
    48|      */
    49|     private array $fontWriters = [];
    50|     /**
    51|      * Added fonts. Maps from font's hash => index in workbook.
    52|      */
    53|     private array $addedFonts = [];
    54|     /**
    55|      * Shared number formats.
    56|      */
    57|     private array $numberFormats = [];
    58|     /**
    59|      * Added number formats. Maps from numberFormat's hash => index in workbook.
    60|      */
    61|     private array $addedNumberFormats = [];
    62|     /**
    63|      * Sizes of the binary worksheet streams.
    64|      */
    65|     private array $worksheetSizes = [];
    66|     /**
    67|      * Offsets of the binary worksheet streams relative to the start of the global workbook stream.
    68|      */
    69|     private array $worksheetOffsets = [];
    70|     /**
    71|      * Total number of shared strings in workbook.
    72|      */
    73|     private int $stringTotal;
    74|     /**
    75|      * Number of unique shared strings in workbook.
    76|      */
    77|     private int $stringUnique;
    78|     /**
    79|      * Array of unique shared strings in workbook.
    80|      */
    81|     private array $stringTable;
    82|     /**
    83|      * Color cache.
    84|      */
    85|     private array $colors;
    86|     /**
    87|      * Escher object corresponding to MSODRAWINGGROUP.
    88|      */
    89|     private ?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher = null;
    90|     /**
    91|      * Class constructor.
    92|      *
    93|      * @param Spreadsheet $spreadsheet The Workbook
    94|      * @param int $str_total Total number of strings
    95|      * @param int $str_unique Total number of unique strings
    96|      * @param array $str_table String Table
    97|      * @param array $colors Colour Table
    98|      * @param Parser $parser The formula parser created for the Workbook
    99|      */
   100|     public function __construct(Spreadsheet $spreadsheet, int &$str_total, int &$str_unique, array &$str_table, array &$colors, Parser $parser)
   101|     {
   102|         parent::__construct();
   103|         $this->parser = $parser;
   104|         $this->palette = [];
   105|         $this->countryCode = -1;
   106|         $this->stringTotal = &$str_total;
   107|         $this->stringUnique = &$str_unique;
   108|         $this->stringTable = &$str_table;
   109|         $this->colors = &$colors;
   110|         $this->setPaletteXl97();
   111|         $this->spreadsheet = $spreadsheet;
   112|         $this->codepage = 0x04B0;
   113|         $countSheets = $spreadsheet->getSheetCount();
   114|         for ($i = 0; $i < $countSheets; ++$i) {
   115|             $phpSheet = $spreadsheet->getSheet($i);
   116|             $this->parser->setExtSheet($phpSheet->getTitle(), $i); // Register worksheet name with parser
   117|             $supbook_index = 0x00;
   118|             $ref = pack('vvv', $supbook_index, $i, $i);
   119|             $this->parser->references[] = $ref; // Register reference with parser
   120|             if ($phpSheet->isTabColorSet()) {
   121|                 $this->addColor($phpSheet->getTabColor()->getRGB());
   122|             }
   123|         }
   124|     }
   125|     /**
   126|      * Add a new XF writer.
   127|      *
   128|      * @param bool $isStyleXf Is it a style XF?
   129|      *
   130|      * @return int Index to XF record
   131|      */
   132|     public function addXfWriter(Style $style, bool $isStyleXf = false): int
   133|     {
   134|         $xfWriter = new Xf($style);
   135|         $xfWriter->setIsStyleXf($isStyleXf);
   136|         $fontIndex = $this->addFont($style->getFont());
   137|         $xfWriter->setFontIndex($fontIndex);
   138|         $xfWriter->setFgColor($this->addColor($style->getFill()->getStartColor()->getRGB()));
   139|         $xfWriter->setBgColor($this->addColor($style->getFill()->getEndColor()->getRGB()));
   140|         $xfWriter->setBottomColor($this->addColor($style->getBorders()->getBottom()->getColor()->getRGB()));
   141|         $xfWriter->setTopColor($this->addColor($style->getBorders()->getTop()->getColor()->getRGB()));
   142|         $xfWriter->setRightColor($this->addColor($style->getBorders()->getRight()->getColor()->getRGB()));
   143|         $xfWriter->setLeftColor($this->addColor($style->getBorders()->getLeft()->getColor()->getRGB()));
   144|         $xfWriter->setDiagColor($this->addColor($style->getBorders()->getDiagonal()->getColor()->getRGB()));
   145|         if ($style->getNumberFormat()->getBuiltInFormatCode() === false) {
   146|             $numberFormatHashCode = $style->getNumberFormat()->getHashCode();
   147|             if (isset($this->addedNumberFormats[$numberFormatHashCode])) {
   148|                 $numberFormatIndex = $this->addedNumberFormats[$numberFormatHashCode];
   149|             } else {
   150|                 $numberFormatIndex = 164 + count($this->numberFormats);
   151|                 $this->numberFormats[$numberFormatIndex] = $style->getNumberFormat();
   152|                 $this->addedNumberFormats[$numberFormatHashCode] = $numberFormatIndex;
   153|             }
   154|         } else {
   155|             $numberFormatIndex = (int) $style->getNumberFormat()->getBuiltInFormatCode();
   156|         }
   157|         $xfWriter->setNumberFormatIndex($numberFormatIndex);
   158|         $this->xfWriters[] = $xfWriter;
   159|         return count($this->xfWriters) - 1;
   160|     }
   161|     /**
   162|      * Add a font to added fonts.
   163|      *
   164|      * @return int Index to FONT record
   165|      */
   166|     public function addFont(\PhpOffice\PhpSpreadsheet\Style\Font $font): int
   167|     {
   168|         $fontHashCode = $font->getHashCode();
   169|         if (isset($this->addedFonts[$fontHashCode])) {
   170|             $fontIndex = $this->addedFonts[$fontHashCode];
   171|         } else {
   172|             $countFonts = count($this->fontWriters);
   173|             $fontIndex = ($countFonts < 4) ? $countFonts : $countFonts + 1;
   174|             $fontWriter = new Font($font);
   175|             $fontWriter->setColorIndex($this->addColor($font->getColor()->getRGB()));
   176|             $this->fontWriters[] = $fontWriter;
   177|             $this->addedFonts[$fontHashCode] = $fontIndex;
   178|         }
   179|         return $fontIndex;
   180|     }
   181|     /**
   182|      * Alter color palette adding a custom color.
   183|      *
   184|      * @param string $rgb E.g. 'FF00AA'
   185|      *
   186|      * @return int Color index
   187|      */
   188|     public function addColor(string $rgb, int $default = 0): int
   189|     {
   190|         if (!isset($this->colors[$rgb])) {
   191|             $color
   192|                 = [
   193|                     hexdec(substr($rgb, 0, 2)),
   194|                     hexdec(substr($rgb, 2, 2)),
   195|                     hexdec(substr($rgb, 4)),
   196|                     0,
   197|                 ];
   198|             $colorIndex = array_search($color, $this->palette);
   199|             if ($colorIndex) {
   200|                 $this->colors[$rgb] = $colorIndex;
   201|             } else {
   202|                 if (count($this->colors) === 0) {
   203|                     $lastColor = 7;
   204|                 } else {
   205|                     $lastColor = end($this->colors);
   206|                 }
   207|                 if ($lastColor < 57) {
   208|                     $colorIndex = $lastColor + 1;
   209|                     $this->palette[$colorIndex] = $color;
   210|                     $this->colors[$rgb] = $colorIndex;
   211|                 } else {
   212|                     $colorIndex = $default;
   213|                 }
   214|             }
   215|         } else {
   216|             $colorIndex = $this->colors[$rgb];
   217|         }
   218|         return $colorIndex;
   219|     }
   220|     /**
   221|      * Sets the colour palette to the Excel 97+ default.
   222|      */
   223|     private function setPaletteXl97(): void
   224|     {
   225|         $this->palette = [
   226|             0x08 => [0x00, 0x00, 0x00, 0x00],
   227|             0x09 => [0xFF, 0xFF, 0xFF, 0x00],
   228|             0x0A => [0xFF, 0x00, 0x00, 0x00],
   229|             0x0B => [0x00, 0xFF, 0x00, 0x00],
   230|             0x0C => [0x00, 0x00, 0xFF, 0x00],
   231|             0x0D => [0xFF, 0xFF, 0x00, 0x00],
   232|             0x0E => [0xFF, 0x00, 0xFF, 0x00],
   233|             0x0F => [0x00, 0xFF, 0xFF, 0x00],
   234|             0x10 => [0x80, 0x00, 0x00, 0x00],
   235|             0x11 => [0x00, 0x80, 0x00, 0x00],
   236|             0x12 => [0x00, 0x00, 0x80, 0x00],
   237|             0x13 => [0x80, 0x80, 0x00, 0x00],
   238|             0x14 => [0x80, 0x00, 0x80, 0x00],
   239|             0x15 => [0x00, 0x80, 0x80, 0x00],
   240|             0x16 => [0xC0, 0xC0, 0xC0, 0x00],
   241|             0x17 => [0x80, 0x80, 0x80, 0x00],
   242|             0x18 => [0x99, 0x99, 0xFF, 0x00],
   243|             0x19 => [0x99, 0x33, 0x66, 0x00],
   244|             0x1A => [0xFF, 0xFF, 0xCC, 0x00],
   245|             0x1B => [0xCC, 0xFF, 0xFF, 0x00],
   246|             0x1C => [0x66, 0x00, 0x66, 0x00],
   247|             0x1D => [0xFF, 0x80, 0x80, 0x00],
   248|             0x1E => [0x00, 0x66, 0xCC, 0x00],
   249|             0x1F => [0xCC, 0xCC, 0xFF, 0x00],
   250|             0x20 => [0x00, 0x00, 0x80, 0x00],
   251|             0x21 => [0xFF, 0x00, 0xFF, 0x00],
   252|             0x22 => [0xFF, 0xFF, 0x00, 0x00],
   253|             0x23 => [0x00, 0xFF, 0xFF, 0x00],
   254|             0x24 => [0x80, 0x00, 0x80, 0x00],
   255|             0x25 => [0x80, 0x00, 0x00, 0x00],
   256|             0x26 => [0x00, 0x80, 0x80, 0x00],
   257|             0x27 => [0x00, 0x00, 0xFF, 0x00],
   258|             0x28 => [0x00, 0xCC, 0xFF, 0x00],
   259|             0x29 => [0xCC, 0xFF, 0xFF, 0x00],
   260|             0x2A => [0xCC, 0xFF, 0xCC, 0x00],
   261|             0x2B => [0xFF, 0xFF, 0x99, 0x00],
   262|             0x2C => [0x99, 0xCC, 0xFF, 0x00],
   263|             0x2D => [0xFF, 0x99, 0xCC, 0x00],
   264|             0x2E => [0xCC, 0x99, 0xFF, 0x00],
   265|             0x2F => [0xFF, 0xCC, 0x99, 0x00],
   266|             0x30 => [0x33, 0x66, 0xFF, 0x00],
   267|             0x31 => [0x33, 0xCC, 0xCC, 0x00],
   268|             0x32 => [0x99, 0xCC, 0x00, 0x00],
   269|             0x33 => [0xFF, 0xCC, 0x00, 0x00],
   270|             0x34 => [0xFF, 0x99, 0x00, 0x00],
   271|             0x35 => [0xFF, 0x66, 0x00, 0x00],
   272|             0x36 => [0x66, 0x66, 0x99, 0x00],
   273|             0x37 => [0x96, 0x96, 0x96, 0x00],
   274|             0x38 => [0x00, 0x33, 0x66, 0x00],
   275|             0x39 => [0x33, 0x99, 0x66, 0x00],
   276|             0x3A => [0x00, 0x33, 0x00, 0x00],
   277|             0x3B => [0x33, 0x33, 0x00, 0x00],
   278|             0x3C => [0x99, 0x33, 0x00, 0x00],
   279|             0x3D => [0x99, 0x33, 0x66, 0x00],
   280|             0x3E => [0x33, 0x33, 0x99, 0x00],
   281|             0x3F => [0x33, 0x33, 0x33, 0x00],
   282|         ];
   283|     }
   284|     /**
   285|      * Assemble worksheets into a workbook and send the BIFF data to an OLE
   286|      * storage.
   287|      *
   288|      * @param array $worksheetSizes The sizes in bytes of the binary worksheet streams
   289|      *
   290|      * @return string Binary data for workbook stream
   291|      */
   292|     public function writeWorkbook(array $worksheetSizes): string
   293|     {
   294|         $this->worksheetSizes = $worksheetSizes;
   295|         $total_worksheets = $this->spreadsheet->getSheetCount();
   296|         $this->storeBof(0x0005);
   297|         $this->writeCodepage();
   298|         $this->writeWindow1();
   299|         $this->writeDateMode();
   300|         $this->writeAllFonts();
   301|         $this->writeAllNumberFormats();
   302|         $this->writeAllXfs();
   303|         $this->writeAllStyles();
   304|         $this->writePalette();
   305|         $part3 = '';
   306|         if ($this->countryCode !== -1) {
   307|             $part3 .= $this->writeCountry();
   308|         }
   309|         $part3 .= $this->writeRecalcId();
   310|         $part3 .= $this->writeSupbookInternal();
   311|         /* TODO: store external SUPBOOK records and XCT and CRN records
   312|         in case of external references for BIFF8 */
   313|         $part3 .= $this->writeExternalsheetBiff8();
   314|         $part3 .= $this->writeAllDefinedNamesBiff8();
   315|         $part3 .= $this->writeMsoDrawingGroup();
   316|         $part3 .= $this->writeSharedStringsTable();
   317|         $part3 .= $this->writeEof();
   318|         $this->calcSheetOffsets();
   319|         for ($i = 0; $i < $total_worksheets; ++$i) {
   320|             $this->writeBoundSheet($this->spreadsheet->getSheet($i), $this->worksheetOffsets[$i]);
   321|         }
   322|         $this->_data .= $part3;
   323|         return $this->_data;
   324|     }
   325|     /**
   326|      * Calculate offsets for Worksheet BOF records.
   327|      */
   328|     private function calcSheetOffsets(): void
   329|     {
   330|         $boundsheet_length = 10; // fixed length for a BOUNDSHEET record
   331|         $offset = $this->_datasize;
   332|         $total_worksheets = count($this->spreadsheet->getAllSheets());
   333|         foreach ($this->spreadsheet->getWorksheetIterator() as $sheet) {
   334|             $offset += $boundsheet_length + strlen(StringHelper::UTF8toBIFF8UnicodeShort($sheet->getTitle()));
   335|         }
   336|         for ($i = 0; $i < $total_worksheets; ++$i) {
   337|             $this->worksheetOffsets[$i] = $offset;
   338|             $offset += $this->worksheetSizes[$i];
   339|         }
   340|     }
   341|     /**
   342|      * Store the Excel FONT records.
   343|      */
   344|     private function writeAllFonts(): void
   345|     {
   346|         foreach ($this->fontWriters as $fontWriter) {
   347|             $this->append($fontWriter->writeFont());
   348|         }
   349|     }
   350|     /**
   351|      * Store user defined numerical formats i.e. FORMAT records.
   352|      */
   353|     private function writeAllNumberFormats(): void
   354|     {
   355|         foreach ($this->numberFormats as $numberFormatIndex => $numberFormat) {
   356|             $this->writeNumberFormat($numberFormat->getFormatCode(), $numberFormatIndex);
   357|         }
   358|     }
   359|     /**
   360|      * Write all XF records.
   361|      */
   362|     private function writeAllXfs(): void
   363|     {
   364|         foreach ($this->xfWriters as $xfWriter) {
   365|             $this->append($xfWriter->writeXf());
   366|         }
   367|     }
   368|     /**
   369|      * Write all STYLE records.
   370|      */
   371|     private function writeAllStyles(): void
   372|     {
   373|         $this->writeStyle();
   374|     }
   375|     private function parseDefinedNameValue(DefinedName $definedName): string
   376|     {
   377|         $definedRange = $definedName->getValue();
   378|         $splitCount = preg_match_all(
   379|             '/' . Calculation::CALCULATION_REGEXP_CELLREF . '/mui',
   380|             $definedRange,
   381|             $splitRanges,
   382|             PREG_OFFSET_CAPTURE
   383|         );
   384|         $lengths = array_map('strlen', array_column($splitRanges[0], 0));
   385|         $offsets = array_column($splitRanges[0], 1);
   386|         $worksheets = $splitRanges[2];
   387|         $columns = $splitRanges[6];
   388|         $rows = $splitRanges[7];
   389|         while ($splitCount > 0) {
   390|             --$splitCount;
   391|             $length = $lengths[$splitCount];
   392|             $offset = $offsets[$splitCount];
   393|             $worksheet = $worksheets[$splitCount][0];
   394|             $column = $columns[$splitCount][0];
   395|             $row = $rows[$splitCount][0];
   396|             $newRange = '';
   397|             if (empty($worksheet)) {
   398|                 if (($offset === 0) || ($definedRange[$offset - 1] !== ':')) {
   399|                     $worksheet = $definedName->getWorksheet() ? $definedName->getWorksheet()->getTitle() : null;
   400|                 }
   401|             } else {
   402|                 $worksheet = str_replace("''", "'", trim($worksheet, "'"));
   403|             }
   404|             if (!empty($worksheet)) {
   405|                 $newRange = "'" . str_replace("'", "''", $worksheet) . "'!";
   406|             }
   407|             if (!empty($column)) {
   408|                 $newRange .= "\${$column}";
   409|             }
   410|             if (!empty($row)) {
   411|                 $newRange .= "\${$row}";
   412|             }
   413|             $definedRange = substr($definedRange, 0, $offset) . $newRange . substr($definedRange, $offset + $length);
   414|         }
   415|         return $definedRange;
   416|     }
   417|     /**
   418|      * Writes all the DEFINEDNAME records (BIFF8).
   419|      * So far this is only used for repeating rows/columns (print titles) and print areas.
   420|      */
   421|     private function writeAllDefinedNamesBiff8(): string
   422|     {
   423|         $chunk = '';
   424|         $definedNames = $this->spreadsheet->getDefinedNames();
   425|         if (count($definedNames) > 0) {
   426|             foreach ($definedNames as $definedName) {
   427|                 $range = $this->parseDefinedNameValue($definedName);
   428|                 try {
   429|                     $this->parser->parse($range);
   430|                     $formulaData = $this->parser->toReversePolish();
   431|                     if (isset($formulaData[0]) && ($formulaData[0] == "\x7A" || $formulaData[0] == "\x5A")) {
   432|                         $formulaData = "\x3A" . substr($formulaData, 1);
   433|                     }
   434|                     if ($definedName->getLocalOnly()) {
   435|                         $scopeWs = $definedName->getScope();
   436|                         $scope = ($scopeWs === null) ? 0 : ($this->spreadsheet->getIndex($scopeWs) + 1);
   437|                     } else {
   438|                         $scope = 0;
   439|                     }
   440|                     $chunk .= $this->writeData($this->writeDefinedNameBiff8($definedName->getName(), $formulaData, $scope, false));
   441|                 } catch (PhpSpreadsheetException) {
   442|                 }
   443|             }
   444|         }
   445|         $total_worksheets = $this->spreadsheet->getSheetCount();
   446|         for ($i = 0; $i < $total_worksheets; ++$i) {
   447|             $sheetSetup = $this->spreadsheet->getSheet($i)->getPageSetup();
   448|             if ($sheetSetup->isColumnsToRepeatAtLeftSet() && $sheetSetup->isRowsToRepeatAtTopSet()) {
   449|                 $repeat = $sheetSetup->getColumnsToRepeatAtLeft();
   450|                 $colmin = Coordinate::columnIndexFromString($repeat[0]) - 1;
   451|                 $colmax = Coordinate::columnIndexFromString($repeat[1]) - 1;
   452|                 $repeat = $sheetSetup->getRowsToRepeatAtTop();
   453|                 $rowmin = $repeat[0] - 1;
   454|                 $rowmax = $repeat[1] - 1;
   455|                 $formulaData = pack('Cv', 0x29, 0x17); // tMemFunc
   456|                 $formulaData .= pack('Cvvvvv', 0x3B, $i, 0, 65535, $colmin, $colmax); // tArea3d
   457|                 $formulaData .= pack('Cvvvvv', 0x3B, $i, $rowmin, $rowmax, 0, 255); // tArea3d
   458|                 $formulaData .= pack('C', 0x10); // tList
   459|                 $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x07), $formulaData, $i + 1, true));
   460|             } elseif ($sheetSetup->isColumnsToRepeatAtLeftSet() || $sheetSetup->isRowsToRepeatAtTopSet()) {
   461|                 if ($sheetSetup->isColumnsToRepeatAtLeftSet()) {
   462|                     $repeat = $sheetSetup->getColumnsToRepeatAtLeft();
   463|                     $colmin = Coordinate::columnIndexFromString($repeat[0]) - 1;
   464|                     $colmax = Coordinate::columnIndexFromString($repeat[1]) - 1;
   465|                 } else {
   466|                     $colmin = 0;
   467|                     $colmax = 255;
   468|                 }
   469|                 if ($sheetSetup->isRowsToRepeatAtTopSet()) {
   470|                     $repeat = $sheetSetup->getRowsToRepeatAtTop();
   471|                     $rowmin = $repeat[0] - 1;
   472|                     $rowmax = $repeat[1] - 1;
   473|                 } else {
   474|                     $rowmin = 0;
   475|                     $rowmax = 65535;
   476|                 }
   477|                 $formulaData = pack('Cvvvvv', 0x3B, $i, $rowmin, $rowmax, $colmin, $colmax);
   478|                 $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x07), $formulaData, $i + 1, true));
   479|             }
   480|         }
   481|         for ($i = 0; $i < $total_worksheets; ++$i) {
   482|             $sheetSetup = $this->spreadsheet->getSheet($i)->getPageSetup();
   483|             if ($sheetSetup->isPrintAreaSet()) {
   484|                 $printArea = Coordinate::splitRange($sheetSetup->getPrintArea());
   485|                 $countPrintArea = count($printArea);
   486|                 $formulaData = '';
   487|                 for ($j = 0; $j < $countPrintArea; ++$j) {
   488|                     $printAreaRect = $printArea[$j]; // e.g. A3:J6
   489|                     $printAreaRect[0] = Coordinate::indexesFromString($printAreaRect[0]);
   490|                     $printAreaRect[1] = Coordinate::indexesFromString($printAreaRect[1]);
   491|                     $print_rowmin = $printAreaRect[0][1] - 1;
   492|                     $print_rowmax = $printAreaRect[1][1] - 1;
   493|                     $print_colmin = $printAreaRect[0][0] - 1;
   494|                     $print_colmax = $printAreaRect[1][0] - 1;
   495|                     $formulaData .= pack('Cvvvvv', 0x3B, $i, $print_rowmin, $print_rowmax, $print_colmin, $print_colmax);
   496|                     if ($j > 0) {
   497|                         $formulaData .= pack('C', 0x10); // list operator token ','
   498|                     }
   499|                 }
   500|                 $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x06), $formulaData, $i + 1, true));
   501|             }
   502|         }
   503|         for ($i = 0; $i < $total_worksheets; ++$i) {
   504|             $sheetAutoFilter = $this->spreadsheet->getSheet($i)->getAutoFilter();
   505|             $autoFilterRange = $sheetAutoFilter->getRange();
   506|             if (!empty($autoFilterRange)) {
   507|                 $rangeBounds = Coordinate::rangeBoundaries($autoFilterRange);
   508|                 $name = pack('C', 0x0D);
   509|                 $chunk .= $this->writeData($this->writeShortNameBiff8($name, $i + 1, $rangeBounds, true));
   510|             }
   511|         }
   512|         return $chunk;
   513|     }
   514|     /**
   515|      * Write a DEFINEDNAME record for BIFF8 using explicit binary formula data.
   516|      *
   517|      * @param string $name The name in UTF-8
   518|      * @param string $formulaData The binary formula data
   519|      * @param int $sheetIndex 1-based sheet index the defined name applies to. 0 = global
   520|      * @param bool $isBuiltIn Built-in name?
   521|      *
   522|      * @return string Complete binary record data
   523|      */
   524|     private function writeDefinedNameBiff8(string $name, string $formulaData, int $sheetIndex = 0, bool $isBuiltIn = false): string
   525|     {
   526|         $record = 0x0018;
   527|         $options = $isBuiltIn ? 0x20 : 0x00;
   528|         $nlen = StringHelper::countCharacters($name);
   529|         $name = substr(StringHelper::UTF8toBIFF8UnicodeLong($name), 2);
   530|         $sz = strlen($formulaData);
   531|         $data = pack('vCCvvvCCCC', $options, 0, $nlen, $sz, 0, $sheetIndex, 0, 0, 0, 0)
   532|             . $name . $formulaData;
   533|         $length = strlen($data);
   534|         $header = pack('vv', $record, $length);
   535|         return $header . $data;
   536|     }
   537|     /**
   538|      * Write a short NAME record.
   539|      *
   540|      * @param int $sheetIndex 1-based sheet index the defined name applies to. 0 = global
   541|      * @param int[][] $rangeBounds range boundaries
   542|      *
   543|      * @return string Complete binary record data
   544|      * */
   545|     private function writeShortNameBiff8(string $name, int $sheetIndex, array $rangeBounds, bool $isHidden = false): string
   546|     {
   547|         $record = 0x0018;
   548|         $options = ($isHidden ? 0x21 : 0x00);
   549|         $extra = pack(
   550|             'Cvvvvv',
   551|             0x3B,
   552|             $sheetIndex - 1,
   553|             $rangeBounds[0][1] - 1,
   554|             $rangeBounds[1][1] - 1,
   555|             $rangeBounds[0][0] - 1,
   556|             $rangeBounds[1][0] - 1
   557|         );
   558|         $sz = strlen($extra);
   559|         $data = pack('vCCvvvCCCCC', $options, 0, 1, $sz, 0, $sheetIndex, 0, 0, 0, 0, 0)
   560|             . $name . $extra;
   561|         $length = strlen($data);
   562|         $header = pack('vv', $record, $length);
   563|         return $header . $data;
   564|     }
   565|     /**
   566|      * Stores the CODEPAGE biff record.
   567|      */
   568|     private function writeCodepage(): void
   569|     {
   570|         $record = 0x0042; // Record identifier
   571|         $length = 0x0002; // Number of bytes to follow
   572|         $cv = $this->codepage; // The code page
   573|         $header = pack('vv', $record, $length);
   574|         $data = pack('v', $cv);
   575|         $this->append($header . $data);
   576|     }
   577|     /**
   578|      * Write Excel BIFF WINDOW1 record.
   579|      */
   580|     private function writeWindow1(): void
   581|     {
   582|         $record = 0x003D; // Record identifier
   583|         $length = 0x0012; // Number of bytes to follow
   584|         $xWn = 0x0000; // Horizontal position of window
   585|         $yWn = 0x0000; // Vertical position of window
   586|         $dxWn = 0x25BC; // Width of window
   587|         $dyWn = 0x1572; // Height of window
   588|         $grbit = 0x0038; // Option flags
   589|         $ctabsel = 1; // Number of workbook tabs selected
   590|         $wTabRatio = 0x0258; // Tab to scrollbar ratio
   591|         $itabFirst = 0; // 1st displayed worksheet
   592|         $itabCur = $this->spreadsheet->getActiveSheetIndex(); // Active worksheet
   593|         $header = pack('vv', $record, $length);
   594|         $data = pack('vvvvvvvvv', $xWn, $yWn, $dxWn, $dyWn, $grbit, $itabCur, $itabFirst, $ctabsel, $wTabRatio);
   595|         $this->append($header . $data);
   596|     }
   597|     /**
   598|      * Writes Excel BIFF BOUNDSHEET record.
   599|      *
   600|      * @param int $offset Location of worksheet BOF
   601|      */
   602|     private function writeBoundSheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, int $offset): void
   603|     {
   604|         $sheetname = $sheet->getTitle();
   605|         $record = 0x0085; // Record identifier
   606|         $ss = match ($sheet->getSheetState()) {
   607|             \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_VISIBLE => 0x00,
   608|             \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_HIDDEN => 0x01,
   609|             \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_VERYHIDDEN => 0x02,
   610|             default => 0x00,
   611|         };
   612|         $st = 0x00;
   613|         $data = pack('VCC', $offset, $ss, $st);
   614|         $data .= StringHelper::UTF8toBIFF8UnicodeShort($sheetname);
   615|         $length = strlen($data);
   616|         $header = pack('vv', $record, $length);
   617|         $this->append($header . $data);
   618|     }
   619|     /**
   620|      * Write Internal SUPBOOK record.
   621|      */
   622|     private function writeSupbookInternal(): string
   623|     {
   624|         $record = 0x01AE; // Record identifier
   625|         $length = 0x0004; // Bytes to follow
   626|         $header = pack('vv', $record, $length);
   627|         $data = pack('vv', $this->spreadsheet->getSheetCount(), 0x0401);
   628|         return $this->writeData($header . $data);
   629|     }
   630|     /**
   631|      * Writes the Excel BIFF EXTERNSHEET record. These references are used by
   632|      * formulas.
   633|      */
   634|     private function writeExternalsheetBiff8(): string
   635|     {
   636|         $totalReferences = count($this->parser->references);
   637|         $record = 0x0017; // Record identifier
   638|         $length = 2 + 6 * $totalReferences; // Number of bytes to follow
   639|         $header = pack('vv', $record, $length);
   640|         $data = pack('v', $totalReferences);
   641|         for ($i = 0; $i < $totalReferences; ++$i) {
   642|             $data .= $this->parser->references[$i];
   643|         }
   644|         return $this->writeData($header . $data);
   645|     }
   646|     /**
   647|      * Write Excel BIFF STYLE records.
   648|      */
   649|     private function writeStyle(): void
   650|     {
   651|         $record = 0x0293; // Record identifier
   652|         $length = 0x0004; // Bytes to follow
   653|         $ixfe = 0x8000; // Index to cell style XF
   654|         $BuiltIn = 0x00; // Built-in style
   655|         $iLevel = 0xFF; // Outline style level
   656|         $header = pack('vv', $record, $length);
   657|         $data = pack('vCC', $ixfe, $BuiltIn, $iLevel);
   658|         $this->append($header . $data);
   659|     }
   660|     /**
   661|      * Writes Excel FORMAT record for non "built-in" numerical formats.
   662|      *
   663|      * @param string $format Custom format string
   664|      * @param int $ifmt Format index code
   665|      */
   666|     private function writeNumberFormat(string $format, int $ifmt): void
   667|     {
   668|         $record = 0x041E; // Record identifier
   669|         $numberFormatString = StringHelper::UTF8toBIFF8UnicodeLong($format);
   670|         $length = 2 + strlen($numberFormatString); // Number of bytes to follow
   671|         $header = pack('vv', $record, $length);
   672|         $data = pack('v', $ifmt) . $numberFormatString;
   673|         $this->append($header . $data);
   674|     }
   675|     /**
   676|      * Write DATEMODE record to indicate the date system in use (1904 or 1900).
   677|      */
   678|     private function writeDateMode(): void
   679|     {
   680|         $record = 0x0022; // Record identifier
   681|         $length = 0x0002; // Bytes to follow
   682|         $f1904 = ($this->spreadsheet->getExcelCalendar() === Date::CALENDAR_MAC_1904)
   683|             ? 1  // Flag for 1904 date system
   684|             : 0; // Flag for 1900 date system
   685|         $header = pack('vv', $record, $length);
   686|         $data = pack('v', $f1904);
   687|         $this->append($header . $data);
   688|     }
   689|     /**
   690|      * Stores the COUNTRY record for localization.
   691|      */
   692|     private function writeCountry(): string
   693|     {
   694|         $record = 0x008C; // Record identifier
   695|         $length = 4; // Number of bytes to follow
   696|         $header = pack('vv', $record, $length);
   697|         $data = pack('vv', $this->countryCode, $this->countryCode);
   698|         return $this->writeData($header . $data);
   699|     }
   700|     /**
   701|      * Write the RECALCID record.
   702|      */
   703|     private function writeRecalcId(): string
   704|     {
   705|         $record = 0x01C1; // Record identifier
   706|         $length = 8; // Number of bytes to follow
   707|         $header = pack('vv', $record, $length);
   708|         $data = pack('VV', 0x000001C1, 0x00001E667);
   709|         return $this->writeData($header . $data);
   710|     }
   711|     /**
   712|      * Stores the PALETTE biff record.
   713|      */
   714|     private function writePalette(): void
   715|     {
   716|         $aref = $this->palette;
   717|         $record = 0x0092; // Record identifier
   718|         $length = 2 + 4 * count($aref); // Number of bytes to follow
   719|         $ccv = count($aref); // Number of RGB values to follow
   720|         $data = ''; // The RGB data
   721|         foreach ($aref as $color) {
   722|             foreach ($color as $byte) {
   723|                 $data .= pack('C', $byte);
   724|             }
   725|         }
   726|         $header = pack('vvv', $record, $length, $ccv);
   727|         $this->append($header . $data);
   728|     }
   729|     /**
   730|      * Handling of the SST continue blocks is complicated by the need to include an
   731|      * additional continuation byte depending on whether the string is split between
   732|      * blocks or whether it starts at the beginning of the block. (There are also
   733|      * additional complications that will arise later when/if Rich Strings are
   734|      * supported).
   735|      *
   736|      * The Excel documentation says that the SST record should be followed by an
   737|      * EXTSST record. The EXTSST record is a hash table that is used to optimise
   738|      * access to SST. However, despite the documentation it doesn't seem to be
   739|      * required so we will ignore it.
   740|      *
   741|      * @return string Binary data
   742|      */
   743|     private function writeSharedStringsTable(): string
   744|     {
   745|         $continue_limit = 8224;
   746|         $recordDatas = [];
   747|         $recordData = pack('VV', $this->stringTotal, $this->stringUnique);
   748|         foreach (array_keys($this->stringTable) as $string) {
   749|             $headerinfo = unpack('vlength/Cencoding', $string);
   750|             $encoding = $headerinfo['encoding'] ?? 1;
   751|             $finished = false;
   752|             while ($finished === false) {
   753|                 if (strlen($recordData) + strlen($string) <= $continue_limit) {
   754|                     $recordData .= $string;
   755|                     if (strlen($recordData) + strlen($string) == $continue_limit) {
   756|                         $recordDatas[] = $recordData;
   757|                         $recordData = '';
   758|                     }
   759|                     $finished = true;
   760|                 } else {
   761|                     $space_remaining = $continue_limit - strlen($recordData);
   762|                     $min_space_needed = ($encoding == 1) ? 5 : 4;
   763|                     if ($space_remaining < $min_space_needed) {
   764|                         $recordDatas[] = $recordData;
   765|                         $recordData = '';
   766|                     } else {
   767|                         $effective_space_remaining = $space_remaining;
   768|                         if ($encoding == 1 && (strlen($string) - $space_remaining) % 2 == 1) {
   769|                             --$effective_space_remaining;
   770|                         }
   771|                         $recordData .= substr($string, 0, $effective_space_remaining);
   772|                         $string = substr($string, $effective_space_remaining); // for next cycle in while loop
   773|                         $recordDatas[] = $recordData;
   774|                         $recordData = pack('C', $encoding);
   775|                     }
   776|                 }
   777|             }
   778|         }
   779|         if ($recordData !== '') {
   780|             $recordDatas[] = $recordData;
   781|         }
   782|         $chunk = '';
   783|         foreach ($recordDatas as $i => $recordData) {
   784|             $record = ($i == 0) ? 0x00FC : 0x003C;
   785|             $header = pack('vv', $record, strlen($recordData));
   786|             $data = $header . $recordData;
   787|             $chunk .= $this->writeData($data);
   788|         }
   789|         return $chunk;
   790|     }
   791|     /**
   792|      * Writes the MSODRAWINGGROUP record if needed. Possibly split using CONTINUE records.
   793|      */
   794|     private function writeMsoDrawingGroup(): string
   795|     {
   796|         if (isset($this->escher)) {
   797|             $writer = new Escher($this->escher);
   798|             $data = $writer->close();
   799|             $record = 0x00EB;
   800|             $length = strlen($data);
   801|             $header = pack('vv', $record, $length);
   802|             return $this->writeData($header . $data);
   803|         }
   804|         return '';
   805|     }
   806|     /**
   807|      * Get Escher object.
   808|      */
   809|     public function getEscher(): ?\PhpOffice\PhpSpreadsheet\Shared\Escher
   810|     {
   811|         return $this->escher;
   812|     }
   813|     /**
   814|      * Set Escher object.
   815|      */
   816|     public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher): void
   817|     {
   818|         $this->escher = $escher;
   819|     }
   820| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls/Worksheet.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2378 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
     3| use GdImage;
     4| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     5| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     6| use PhpOffice\PhpSpreadsheet\Cell\DataType;
     7| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     8| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     9| use PhpOffice\PhpSpreadsheet\RichText\Run;
    10| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
    11| use PhpOffice\PhpSpreadsheet\Shared\Xls;
    12| use PhpOffice\PhpSpreadsheet\Style\Border;
    13| use PhpOffice\PhpSpreadsheet\Style\Borders;
    14| use PhpOffice\PhpSpreadsheet\Style\Conditional;
    15| use PhpOffice\PhpSpreadsheet\Style\Protection;
    16| use PhpOffice\PhpSpreadsheet\Worksheet\PageSetup;
    17| use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
    18| use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
    19| class Worksheet extends BIFFwriter
    20| {
    21|     private static int $always0 = 0;
    22|     private static int $always1 = 1;
    23|     /**
    24|      * Formula parser.
    25|      */
    26|     private Parser $parser;
    27|     /**
    28|      * Array containing format information for columns.
    29|      */
    30|     private array $columnInfo;
    31|     /**
    32|      * The active pane for the worksheet.
    33|      */
    34|     private int $activePane;
    35|     /**
    36|      * Whether to use outline.
    37|      */
    38|     private bool $outlineOn;
    39|     /**
    40|      * Auto outline styles.
    41|      */
    42|     private bool $outlineStyle;
    43|     /**
    44|      * Whether to have outline summary below.
    45|      * Not currently used.
    46|      */
    47|     private bool $outlineBelow; //* @phpstan-ignore-line
    48|     /**
    49|      * Whether to have outline summary at the right.
    50|      * Not currently used.
    51|      */
    52|     private bool $outlineRight; //* @phpstan-ignore-line
    53|     /**
    54|      * Reference to the total number of strings in the workbook.
    55|      */
    56|     private int $stringTotal;
    57|     /**
    58|      * Reference to the number of unique strings in the workbook.
    59|      */
    60|     private int $stringUnique;
    61|     /**
    62|      * Reference to the array containing all the unique strings in the workbook.
    63|      */
    64|     private array $stringTable;
    65|     /**
    66|      * Color cache.
    67|      */
    68|     private array $colors;
    69|     /**
    70|      * Index of first used row (at least 0).
    71|      */
    72|     private int $firstRowIndex;
    73|     /**
    74|      * Index of last used row. (no used rows means -1).
    75|      */
    76|     private int $lastRowIndex;
    77|     /**
    78|      * Index of first used column (at least 0).
    79|      */
    80|     private int $firstColumnIndex;
    81|     /**
    82|      * Index of last used column (no used columns means -1).
    83|      */
    84|     private int $lastColumnIndex;
    85|     /**
    86|      * Sheet object.
    87|      */
    88|     public \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet;
    89|     /**
    90|      * Escher object corresponding to MSODRAWING.
    91|      */
    92|     private ?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher = null;
    93|     /**
    94|      * Array of font hashes associated to FONT records index.
    95|      */
    96|     public array $fontHashIndex;
    97|     private bool $preCalculateFormulas;
    98|     private int $printHeaders;
    99|     private ?Workbook $writerWorkbook;
   100|     /**
   101|      * Constructor.
   102|      *
   103|      * @param int $str_total Total number of strings
   104|      * @param int $str_unique Total number of unique strings
   105|      * @param array $str_table String Table
   106|      * @param array $colors Colour Table
   107|      * @param Parser $parser The formula parser created for the Workbook
   108|      * @param bool $preCalculateFormulas Flag indicating whether formulas should be calculated or just written
   109|      * @param \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet The worksheet to write
   110|      */
   111|     public function __construct(int &$str_total, int &$str_unique, array &$str_table, array &$colors, Parser $parser, bool $preCalculateFormulas, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet, ?Workbook $writerWorkbook = null)
   112|     {
   113|         parent::__construct();
   114|         $this->preCalculateFormulas = $preCalculateFormulas;
   115|         $this->stringTotal = &$str_total;
   116|         $this->stringUnique = &$str_unique;
   117|         $this->stringTable = &$str_table;
   118|         $this->colors = &$colors;
   119|         $this->parser = $parser;
   120|         $this->phpSheet = $phpSheet;
   121|         $this->columnInfo = [];
   122|         $this->activePane = 3;
   123|         $this->printHeaders = 0;
   124|         $this->outlineStyle = false;
   125|         $this->outlineBelow = true;
   126|         $this->outlineRight = true;
   127|         $this->outlineOn = true;
   128|         $this->fontHashIndex = [];
   129|         $minR = 1;
   130|         $minC = 'A';
   131|         $maxR = $this->phpSheet->getHighestRow();
   132|         $maxC = $this->phpSheet->getHighestColumn();
   133|         $this->firstRowIndex = $minR;
   134|         $this->lastRowIndex = ($maxR > 65535) ? 65535 : $maxR;
   135|         $this->firstColumnIndex = Coordinate::columnIndexFromString($minC);
   136|         $this->lastColumnIndex = Coordinate::columnIndexFromString($maxC);
   137|         if ($this->lastColumnIndex > 255) {
   138|             $this->lastColumnIndex = 255;
   139|         }
   140|         $this->writerWorkbook = $writerWorkbook;
   141|     }
   142|     /**
   143|      * Add data to the beginning of the workbook (note the reverse order)
   144|      * and to the end of the workbook.
   145|      *
   146|      * @see Workbook::storeWorkbook
   147|      */
   148|     public function close(): void
   149|     {
   150|         $phpSheet = $this->phpSheet;
   151|         $selectedCells = $this->phpSheet->getSelectedCells();
   152|         $activeSheetIndex = $this->phpSheet->getParentOrThrow()->getActiveSheetIndex();
   153|         $this->storeBof(0x0010);
   154|         $this->writePrintHeaders();
   155|         $this->writePrintGridlines();
   156|         $this->writeGridset();
   157|         $phpSheet->calculateColumnWidths();
   158|         if (($defaultWidth = $phpSheet->getDefaultColumnDimension()->getWidth()) < 0) {
   159|             $defaultWidth = \PhpOffice\PhpSpreadsheet\Shared\Font::getDefaultColumnWidthByFont($phpSheet->getParentOrThrow()->getDefaultStyle()->getFont());
   160|         }
   161|         $columnDimensions = $phpSheet->getColumnDimensions();
   162|         $maxCol = $this->lastColumnIndex - 1;
   163|         for ($i = 0; $i <= $maxCol; ++$i) {
   164|             $hidden = 0;
   165|             $level = 0;
   166|             $xfIndex = 15; // there are 15 cell style Xfs
   167|             $width = $defaultWidth;
   168|             $columnLetter = Coordinate::stringFromColumnIndex($i + 1);
   169|             if (isset($columnDimensions[$columnLetter])) {
   170|                 $columnDimension = $columnDimensions[$columnLetter];
   171|                 if ($columnDimension->getWidth() >= 0) {
   172|                     $width = $columnDimension->getWidth();
   173|                 }
   174|                 $hidden = $columnDimension->getVisible() ? 0 : 1;
   175|                 $level = $columnDimension->getOutlineLevel();
   176|                 $xfIndex = $columnDimension->getXfIndex() + 15; // there are 15 cell style Xfs
   177|             }
   178|             $this->columnInfo[] = [$i, $i, $width, $xfIndex, $hidden, $level];
   179|         }
   180|         $this->writeGuts();
   181|         $this->writeDefaultRowHeight();
   182|         $this->writeWsbool();
   183|         $this->writeBreaks();
   184|         $this->writeHeader();
   185|         $this->writeFooter();
   186|         $this->writeHcenter();
   187|         $this->writeVcenter();
   188|         $this->writeMarginLeft();
   189|         $this->writeMarginRight();
   190|         $this->writeMarginTop();
   191|         $this->writeMarginBottom();
   192|         $this->writeSetup();
   193|         $this->writeProtect();
   194|         $this->writeScenProtect();
   195|         $this->writeObjectProtect();
   196|         $this->writePassword();
   197|         $this->writeDefcol();
   198|         if (!empty($this->columnInfo)) {
   199|             $colcount = count($this->columnInfo);
   200|             for ($i = 0; $i < $colcount; ++$i) {
   201|                 $this->writeColinfo($this->columnInfo[$i]);
   202|             }
   203|         }
   204|         $autoFilterRange = $phpSheet->getAutoFilter()->getRange();
   205|         if (!empty($autoFilterRange)) {
   206|             $this->writeAutoFilterInfo();
   207|         }
   208|         $this->writeDimensions();
   209|         foreach ($phpSheet->getRowDimensions() as $rowDimension) {
   210|             $xfIndex = $rowDimension->getXfIndex() + 15; // there are 15 cellXfs
   211|             $this->writeRow(
   212|                 $rowDimension->getRowIndex() - 1,
   213|                 (int) $rowDimension->getRowHeight(),
   214|                 $xfIndex,
   215|                 !$rowDimension->getVisible(),
   216|                 $rowDimension->getOutlineLevel()
   217|             );
   218|         }
   219|         foreach ($phpSheet->getCellCollection()->getSortedCoordinates() as $coordinate) {
   220|             /** @var Cell $cell */
   221|             $cell = $phpSheet->getCellCollection()->get($coordinate);
   222|             $row = $cell->getRow() - 1;
   223|             $column = Coordinate::columnIndexFromString($cell->getColumn()) - 1;
   224|             if ($row > 65535 || $column > 255) {
   225|                 throw new WriterException('Rows or columns overflow! Excel5 has limit to 65535 rows and 255 columns. Use XLSX instead.');
   226|             }
   227|             $xfIndex = $cell->getXfIndex() + 15; // there are 15 cell style Xfs
   228|             $cVal = $cell->getValue();
   229|             if ($cVal instanceof RichText) {
   230|                 $arrcRun = [];
   231|                 $str_pos = 0;
   232|                 $elements = $cVal->getRichTextElements();
   233|                 foreach ($elements as $element) {
   234|                     $str_fontidx = 0;
   235|                     if ($element instanceof Run) {
   236|                         $getFont = $element->getFont();
   237|                         if ($getFont !== null) {
   238|                             $str_fontidx = $this->fontHashIndex[$getFont->getHashCode()];
   239|                         }
   240|                     }
   241|                     $arrcRun[] = ['strlen' => $str_pos, 'fontidx' => $str_fontidx];
   242|                     $str_pos += StringHelper::countCharacters($element->getText(), 'UTF-8');
   243|                 }
   244|                 $this->writeRichTextString($row, $column, $cVal->getPlainText(), $xfIndex, $arrcRun);
   245|             } else {
   246|                 switch ($cell->getDatatype()) {
   247|                     case DataType::TYPE_STRING:
   248|                     case DataType::TYPE_INLINE:
   249|                     case DataType::TYPE_NULL:
   250|                         if ($cVal === '' || $cVal === null) {
   251|                             $this->writeBlank($row, $column, $xfIndex);
   252|                         } else {
   253|                             $this->writeString($row, $column, $cell->getValueString(), $xfIndex);
   254|                         }
   255|                         break;
   256|                     case DataType::TYPE_NUMERIC:
   257|                         $this->writeNumber($row, $column, is_numeric($cVal) ? ($cVal + 0) : 0, $xfIndex);
   258|                         break;
   259|                     case DataType::TYPE_FORMULA:
   260|                         $calculatedValue = $this->preCalculateFormulas ? $cell->getCalculatedValue() : null;
   261|                         $calculatedValueString = $this->preCalculateFormulas ? $cell->getCalculatedValueString() : '';
   262|                         if (self::WRITE_FORMULA_EXCEPTION == $this->writeFormula($row, $column, $cell->getValueString(), $xfIndex, $calculatedValue)) {
   263|                             if ($calculatedValue === null) {
   264|                                 $calculatedValue = $cell->getCalculatedValue();
   265|                             }
   266|                             $calctype = gettype($calculatedValue);
   267|                             match ($calctype) {
   268|                                 'integer', 'double' => $this->writeNumber($row, $column, is_numeric($calculatedValue) ? ((float) $calculatedValue) : 0.0, $xfIndex),
   269|                                 'string' => $this->writeString($row, $column, $calculatedValueString, $xfIndex),
   270|                                 'boolean' => $this->writeBoolErr($row, $column, (int) $calculatedValueString, 0, $xfIndex),
   271|                                 default => $this->writeString($row, $column, $cell->getValueString(), $xfIndex),
   272|                             };
   273|                         }
   274|                         break;
   275|                     case DataType::TYPE_BOOL:
   276|                         $this->writeBoolErr($row, $column, (int) $cell->getValueString(), 0, $xfIndex);
   277|                         break;
   278|                     case DataType::TYPE_ERROR:
   279|                         $this->writeBoolErr($row, $column, ErrorCode::error($cell->getValueString()), 1, $xfIndex);
   280|                         break;
   281|                 }
   282|             }
   283|         }
   284|         $this->writeMsoDrawing();
   285|         $this->phpSheet->getParentOrThrow()->setActiveSheetIndex($activeSheetIndex);
   286|         $this->writeWindow2();
   287|         $this->writePageLayoutView();
   288|         $this->writeZoom();
   289|         if ($phpSheet->getFreezePane()) {
   290|             $this->writePanes();
   291|         }
   292|         $this->phpSheet->setSelectedCells($selectedCells);
   293|         $this->writeSelection();
   294|         $this->writeMergedCells();
   295|         $phpParent = $phpSheet->getParent();
   296|         $hyperlinkbase = ($phpParent === null) ? '' : $phpParent->getProperties()->getHyperlinkBase();
   297|         foreach ($phpSheet->getHyperLinkCollection() as $coordinate => $hyperlink) {
   298|             [$column, $row] = Coordinate::indexesFromString($coordinate);
   299|             $url = $hyperlink->getUrl();
   300|             if (str_contains($url, 'sheet://')) {
   301|                 $url = str_replace('sheet://', 'internal:', $url);
   302|             } elseif (preg_match('/^(http:|https:|ftp:|mailto:)/', $url)) {
   303|             } elseif (!empty($hyperlinkbase) && preg_match('~^([A-Za-z]:)?[/\\\\]~', $url) !== 1) {
   304|                 $url = "$hyperlinkbase$url";
   305|                 if (preg_match('/^(http:|https:|ftp:|mailto:)/', $url) !== 1) {
   306|                     $url = 'external:' . $url;
   307|                 }
   308|             } else {
   309|                 $url = 'external:' . $url;
   310|             }
   311|             $this->writeUrl($row - 1, $column - 1, $url);
   312|         }
   313|         $this->writeDataValidity();
   314|         $this->writeSheetLayout();
   315|         $this->writeSheetProtection();
   316|         $this->writeRangeProtection();
   317|         $this->writeConditionalFormatting();
   318|         $this->storeEof();
   319|     }
   320|     private function writeConditionalFormatting(): void
   321|     {
   322|         $conditionalFormulaHelper = new ConditionalHelper($this->parser);
   323|         $arrConditionalStyles = [];
   324|         foreach ($this->phpSheet->getConditionalStylesCollection() as $key => $value) {
   325|             $keyExplode = explode(',', Coordinate::resolveUnionAndIntersection($key));
   326|             foreach ($keyExplode as $exploded) {
   327|                 $arrConditionalStyles[$exploded] = $value;
   328|             }
   329|         }
   330|         if (!empty($arrConditionalStyles)) {
   331|             foreach ($arrConditionalStyles as $cellCoordinate => $conditionalStyles) {
   332|                 $cfHeaderWritten = false;
   333|                 foreach ($conditionalStyles as $conditional) {
   334|                     /** @var Conditional $conditional */
   335|                     if (
   336|                         $conditional->getConditionType() === Conditional::CONDITION_EXPRESSION
   337|                         || $conditional->getConditionType() === Conditional::CONDITION_CELLIS
   338|                     ) {
   339|                         if ($cfHeaderWritten === false) {
   340|                             $cfHeaderWritten = $this->writeCFHeader($cellCoordinate, $conditionalStyles);
   341|                         }
   342|                         if ($cfHeaderWritten === true) {
   343|                             $this->writeCFRule($conditionalFormulaHelper, $conditional, $cellCoordinate);
   344|                         }
   345|                     }
   346|                 }
   347|             }
   348|         }
   349|     }
   350|     /**
   351|      * Write a cell range address in BIFF8
   352|      * always fixed range
   353|      * See section 2.5.14 in OpenOffice.org's Documentation of the Microsoft Excel File Format.
   354|      *
   355|      * @param string $range E.g. 'A1' or 'A1:B6'
   356|      *
   357|      * @return string Binary data
   358|      */
   359|     private function writeBIFF8CellRangeAddressFixed(string $range): string
   360|     {
   361|         $explodes = explode(':', $range);
   362|         $firstCell = $explodes[0];
   363|         if (count($explodes) == 1) {
   364|             $lastCell = $firstCell;
   365|         } else {
   366|             $lastCell = $explodes[1];
   367|         }
   368|         $firstCellCoordinates = Coordinate::indexesFromString($firstCell); // e.g. [0, 1]
   369|         $lastCellCoordinates = Coordinate::indexesFromString($lastCell); // e.g. [1, 6]
   370|         return pack('vvvv', $firstCellCoordinates[1] - 1, $lastCellCoordinates[1] - 1, $firstCellCoordinates[0] - 1, $lastCellCoordinates[0] - 1);
   371|     }
   372|     /**
   373|      * Retrieves data from memory in one chunk, or from disk
   374|      * sized chunks.
   375|      *
   376|      * @return string The data
   377|      */
   378|     public function getData(): string
   379|     {
   380|         if (isset($this->_data)) {
   381|             $tmp = $this->_data;
   382|             $this->_data = null;
   383|             return $tmp;
   384|         }
   385|         return '';
   386|     }
   387|     /**
   388|      * Set the option to print the row and column headers on the printed page.
   389|      *
   390|      * @param int $print Whether to print the headers or not. Defaults to 1 (print).
   391|      */
   392|     public function printRowColHeaders(int $print = 1): void
   393|     {
   394|         $this->printHeaders = $print;
   395|     }
   396|     /**
   397|      * This method sets the properties for outlining and grouping. The defaults
   398|      * correspond to Excel's defaults.
   399|      */
   400|     public function setOutline(bool $visible = true, bool $symbols_below = true, bool $symbols_right = true, bool $auto_style = false): void
   401|     {
   402|         $this->outlineOn = $visible;
   403|         $this->outlineBelow = $symbols_below;
   404|         $this->outlineRight = $symbols_right;
   405|         $this->outlineStyle = $auto_style;
   406|     }
   407|     /**
   408|      * Write a double to the specified row and column (zero indexed).
   409|      * An integer can be written as a double. Excel will display an
   410|      * integer. $format is optional.
   411|      *
   412|      * Returns  0 : normal termination
   413|      *         -2 : row or column out of range
   414|      *
   415|      * @param int $row Zero indexed row
   416|      * @param int $col Zero indexed column
   417|      * @param float $num The number to write
   418|      * @param int $xfIndex The optional XF format
   419|      */
   420|     private function writeNumber(int $row, int $col, float $num, int $xfIndex): int
   421|     {
   422|         $record = 0x0203; // Record identifier
   423|         $length = 0x000E; // Number of bytes to follow
   424|         $header = pack('vv', $record, $length);
   425|         $data = pack('vvv', $row, $col, $xfIndex);
   426|         $xl_double = pack('d', $num);
   427|         if (self::getByteOrder()) { // if it's Big Endian
   428|             $xl_double = strrev($xl_double);
   429|         }
   430|         $this->append($header . $data . $xl_double);
   431|         return 0;
   432|     }
   433|     /**
   434|      * Write a LABELSST record or a LABEL record. Which one depends on BIFF version.
   435|      *
   436|      * @param int $row Row index (0-based)
   437|      * @param int $col Column index (0-based)
   438|      * @param string $str The string
   439|      * @param int $xfIndex Index to XF record
   440|      */
   441|     private function writeString(int $row, int $col, string $str, int $xfIndex): void
   442|     {
   443|         $this->writeLabelSst($row, $col, $str, $xfIndex);
   444|     }
   445|     /**
   446|      * Write a LABELSST record or a LABEL record. Which one depends on BIFF version
   447|      * It differs from writeString by the writing of rich text strings.
   448|      *
   449|      * @param int $row Row index (0-based)
   450|      * @param int $col Column index (0-based)
   451|      * @param string $str The string
   452|      * @param int $xfIndex The XF format index for the cell
   453|      * @param array $arrcRun Index to Font record and characters beginning
   454|      */
   455|     private function writeRichTextString(int $row, int $col, string $str, int $xfIndex, array $arrcRun): void
   456|     {
   457|         $record = 0x00FD; // Record identifier
   458|         $length = 0x000A; // Bytes to follow
   459|         $str = StringHelper::UTF8toBIFF8UnicodeShort($str, $arrcRun);
   460|         if (!isset($this->stringTable[$str])) {
   461|             $this->stringTable[$str] = $this->stringUnique++;
   462|         }
   463|         ++$this->stringTotal;
   464|         $header = pack('vv', $record, $length);
   465|         $data = pack('vvvV', $row, $col, $xfIndex, $this->stringTable[$str]);
   466|         $this->append($header . $data);
   467|     }
   468|     /**
   469|      * Write a string to the specified row and column (zero indexed).
   470|      * This is the BIFF8 version (no 255 chars limit).
   471|      * $format is optional.
   472|      *
   473|      * @param int $row Zero indexed row
   474|      * @param int $col Zero indexed column
   475|      * @param string $str The string to write
   476|      * @param int $xfIndex The XF format index for the cell
   477|      */
   478|     private function writeLabelSst(int $row, int $col, string $str, int $xfIndex): void
   479|     {
   480|         $record = 0x00FD; // Record identifier
   481|         $length = 0x000A; // Bytes to follow
   482|         $str = StringHelper::UTF8toBIFF8UnicodeLong($str);
   483|         if (!isset($this->stringTable[$str])) {
   484|             $this->stringTable[$str] = $this->stringUnique++;
   485|         }
   486|         ++$this->stringTotal;
   487|         $header = pack('vv', $record, $length);
   488|         $data = pack('vvvV', $row, $col, $xfIndex, $this->stringTable[$str]);
   489|         $this->append($header . $data);
   490|     }
   491|     /**
   492|      * Write a blank cell to the specified row and column (zero indexed).
   493|      * A blank cell is used to specify formatting without adding a string
   494|      * or a number.
   495|      *
   496|      * A blank cell without a format serves no purpose. Therefore, we don't write
   497|      * a BLANK record unless a format is specified.
   498|      *
   499|      * Returns  0 : normal termination (including no format)
   500|      *         -1 : insufficient number of arguments
   501|      *         -2 : row or column out of range
   502|      *
   503|      * @param int $row Zero indexed row
   504|      * @param int $col Zero indexed column
   505|      * @param int $xfIndex The XF format index
   506|      */
   507|     public function writeBlank(int $row, int $col, int $xfIndex): int
   508|     {
   509|         $record = 0x0201; // Record identifier
   510|         $length = 0x0006; // Number of bytes to follow
   511|         $header = pack('vv', $record, $length);
   512|         $data = pack('vvv', $row, $col, $xfIndex);
   513|         $this->append($header . $data);
   514|         return 0;
   515|     }
   516|     /**
   517|      * Write a boolean or an error type to the specified row and column (zero indexed).
   518|      *
   519|      * @param int $row Row index (0-based)
   520|      * @param int $col Column index (0-based)
   521|      * @param int $isError Error or Boolean?
   522|      */
   523|     private function writeBoolErr(int $row, int $col, int $value, int $isError, int $xfIndex): int
   524|     {
   525|         $record = 0x0205;
   526|         $length = 8;
   527|         $header = pack('vv', $record, $length);
   528|         $data = pack('vvvCC', $row, $col, $xfIndex, $value, $isError);
   529|         $this->append($header . $data);
   530|         return 0;
   531|     }
   532|     const WRITE_FORMULA_NORMAL = 0;
   533|     const WRITE_FORMULA_ERRORS = -1;
   534|     const WRITE_FORMULA_RANGE = -2;
   535|     const WRITE_FORMULA_EXCEPTION = -3;
   536|     private static bool $allowThrow = false;
   537|     public static function setAllowThrow(bool $allowThrow): void
   538|     {
   539|         self::$allowThrow = $allowThrow;
   540|     }
   541|     public static function getAllowThrow(): bool
   542|     {
   543|         return self::$allowThrow;
   544|     }
   545|     /**
   546|      * Write a formula to the specified row and column (zero indexed).
   547|      * The textual representation of the formula is passed to the parser in
   548|      * Parser.php which returns a packed binary string.
   549|      *
   550|      * Returns  0 : WRITE_FORMULA_NORMAL  normal termination
   551|      *         -1 : WRITE_FORMULA_ERRORS formula errors (bad formula)
   552|      *         -2 : WRITE_FORMULA_RANGE  row or column out of range
   553|      *         -3 : WRITE_FORMULA_EXCEPTION parse raised exception, probably due to definedname
   554|      *
   555|      * @param int $row Zero indexed row
   556|      * @param int $col Zero indexed column
   557|      * @param string $formula The formula text string
   558|      * @param int $xfIndex The XF format index
   559|      * @param mixed $calculatedValue Calculated value
   560|      */
   561|     private function writeFormula(int $row, int $col, string $formula, int $xfIndex, mixed $calculatedValue): int
   562|     {
   563|         $record = 0x0006; // Record identifier
   564|         $stringValue = null;
   565|         if (isset($calculatedValue)) {
   566|             if (is_bool($calculatedValue)) {
   567|                 $num = pack('CCCvCv', 0x01, 0x00, (int) $calculatedValue, 0x00, 0x00, 0xFFFF);
   568|             } elseif (is_int($calculatedValue) || is_float($calculatedValue)) {
   569|                 $num = pack('d', $calculatedValue);
   570|             } elseif (is_string($calculatedValue)) {
   571|                 $errorCodes = DataType::getErrorCodes();
   572|                 if (isset($errorCodes[$calculatedValue])) {
   573|                     $num = pack('CCCvCv', 0x02, 0x00, ErrorCode::error($calculatedValue), 0x00, 0x00, 0xFFFF);
   574|                 } elseif ($calculatedValue === '') {
   575|                     $num = pack('CCCvCv', 0x03, 0x00, 0x00, 0x00, 0x00, 0xFFFF);
   576|                 } else {
   577|                     $stringValue = $calculatedValue;
   578|                     $num = pack('CCCvCv', 0x00, 0x00, 0x00, 0x00, 0x00, 0xFFFF);
   579|                 }
   580|             } else {
   581|                 $num = pack('d', 0x00);
   582|             }
   583|         } else {
   584|             $num = pack('d', 0x00);
   585|         }
   586|         $grbit = 0x03; // Option flags
   587|         $unknown = 0x0000; // Must be zero
   588|         if ($formula[0] == '=') {
   589|             $formula = substr($formula, 1);
   590|         } else {
   591|             $this->writeString($row, $col, 'Unrecognised character for formula', 0);
   592|             return self::WRITE_FORMULA_ERRORS;
   593|         }
   594|         try {
   595|             $this->parser->parse($formula);
   596|             $formula = $this->parser->toReversePolish();
   597|             $formlen = strlen($formula); // Length of the binary string
   598|             $length = 0x16 + $formlen; // Length of the record data
   599|             $header = pack('vv', $record, $length);
   600|             $data = pack('vvv', $row, $col, $xfIndex)
   601|                 . $num
   602|                 . pack('vVv', $grbit, $unknown, $formlen);
   603|             $this->append($header . $data . $formula);
   604|             if ($stringValue !== null) {
   605|                 $this->writeStringRecord($stringValue);
   606|             }
   607|             return self::WRITE_FORMULA_NORMAL;
   608|         } catch (PhpSpreadsheetException $e) {
   609|             if (self::$allowThrow) {
   610|                 throw $e;
   611|             }
   612|             return self::WRITE_FORMULA_EXCEPTION;
   613|         }
   614|     }
   615|     /**
   616|      * Write a STRING record. This.
   617|      */
   618|     private function writeStringRecord(string $stringValue): void
   619|     {
   620|         $record = 0x0207; // Record identifier
   621|         $data = StringHelper::UTF8toBIFF8UnicodeLong($stringValue);
   622|         $length = strlen($data);
   623|         $header = pack('vv', $record, $length);
   624|         $this->append($header . $data);
   625|     }
   626|     /**
   627|      * Write a hyperlink.
   628|      * This is comprised of two elements: the visible label and
   629|      * the invisible link. The visible label is the same as the link unless an
   630|      * alternative string is specified. The label is written using the
   631|      * writeString() method. Therefore the 255 characters string limit applies.
   632|      * $string and $format are optional.
   633|      *
   634|      * The hyperlink can be to a http, ftp, mail, internal sheet (not yet), or external
   635|      * directory url.
   636|      *
   637|      * @param int $row Row
   638|      * @param int $col Column
   639|      * @param string $url URL string
   640|      */
   641|     private function writeUrl(int $row, int $col, string $url): void
   642|     {
   643|         $this->writeUrlRange($row, $col, $row, $col, $url);
   644|     }
   645|     /**
   646|      * This is the more general form of writeUrl(). It allows a hyperlink to be
   647|      * written to a range of cells. This function also decides the type of hyperlink
   648|      * to be written. These are either, Web (http, ftp, mailto), Internal
   649|      * (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
   650|      *
   651|      * @param int $row1 Start row
   652|      * @param int $col1 Start column
   653|      * @param int $row2 End row
   654|      * @param int $col2 End column
   655|      * @param string $url URL string
   656|      *
   657|      * @see writeUrl()
   658|      */
   659|     private function writeUrlRange(int $row1, int $col1, int $row2, int $col2, string $url): void
   660|     {
   661|         if (preg_match('[^internal:]', $url)) {
   662|             $this->writeUrlInternal($row1, $col1, $row2, $col2, $url);
   663|         }
   664|         if (preg_match('[^external:]', $url)) {
   665|             $this->writeUrlExternal($row1, $col1, $row2, $col2, $url);
   666|         }
   667|         $this->writeUrlWeb($row1, $col1, $row2, $col2, $url);
   668|     }
   669|     /**
   670|      * Used to write http, ftp and mailto hyperlinks.
   671|      * The link type ($options) is 0x03 is the same as absolute dir ref without
   672|      * sheet. However it is differentiated by the $unknown2 data stream.
   673|      *
   674|      * @param int $row1 Start row
   675|      * @param int $col1 Start column
   676|      * @param int $row2 End row
   677|      * @param int $col2 End column
   678|      * @param string $url URL string
   679|      *
   680|      * @see writeUrl()
   681|      */
   682|     public function writeUrlWeb(int $row1, int $col1, int $row2, int $col2, string $url): void
   683|     {
   684|         $record = 0x01B8; // Record identifier
   685|         $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
   686|         $unknown2 = pack('H*', 'E0C9EA79F9BACE118C8200AA004BA90B');
   687|         $options = pack('V', 0x03);
   688|         /** @phpstan-ignore-next-line */
   689|         $url = implode("\0", preg_split("''", $url, -1, PREG_SPLIT_NO_EMPTY));
   690|         $url = $url . "\0\0\0";
   691|         $url_len = pack('V', strlen($url));
   692|         $length = 0x34 + strlen($url);
   693|         $header = pack('vv', $record, $length);
   694|         $data = pack('vvvv', $row1, $row2, $col1, $col2);
   695|         $this->append($header . $data . $unknown1 . $options . $unknown2 . $url_len . $url);
   696|     }
   697|     /**
   698|      * Used to write internal reference hyperlinks such as "Sheet1!A1".
   699|      *
   700|      * @param int $row1 Start row
   701|      * @param int $col1 Start column
   702|      * @param int $row2 End row
   703|      * @param int $col2 End column
   704|      * @param string $url URL string
   705|      *
   706|      * @see writeUrl()
   707|      */
   708|     private function writeUrlInternal(int $row1, int $col1, int $row2, int $col2, string $url): void
   709|     {
   710|         $record = 0x01B8; // Record identifier
   711|         $url = (string) preg_replace('/^internal:/', '', $url);
   712|         $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
   713|         $options = pack('V', 0x08);
   714|         $url .= "\0";
   715|         $url_len = StringHelper::countCharacters($url);
   716|         $url_len = pack('V', $url_len);
   717|         $url = StringHelper::convertEncoding($url, 'UTF-16LE', 'UTF-8');
   718|         $length = 0x24 + strlen($url);
   719|         $header = pack('vv', $record, $length);
   720|         $data = pack('vvvv', $row1, $row2, $col1, $col2);
   721|         $this->append($header . $data . $unknown1 . $options . $url_len . $url);
   722|     }
   723|     /**
   724|      * Write links to external directory names such as 'c:\foo.xls',
   725|      * c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
   726|      *
   727|      * Note: Excel writes some relative links with the $dir_long string. We ignore
   728|      * these cases for the sake of simpler code.
   729|      *
   730|      * @param int $row1 Start row
   731|      * @param int $col1 Start column
   732|      * @param int $row2 End row
   733|      * @param int $col2 End column
   734|      * @param string $url URL string
   735|      *
   736|      * @see writeUrl()
   737|      */
   738|     private function writeUrlExternal(int $row1, int $col1, int $row2, int $col2, string $url): void
   739|     {
   740|         if (preg_match('[^external:\\\\]', $url)) {
   741|             return;
   742|         }
   743|         $record = 0x01B8; // Record identifier
   744|         $url = (string) preg_replace(['/^external:/', '/\//'], ['', '\\'], $url);
   745|         $absolute = 0x00; // relative path
   746|         if (preg_match('/^[A-Z]:/', $url)) {
   747|             $absolute = 0x02; // absolute path on Windows, e.g. C:\...
   748|         }
   749|         $link_type = 0x01 | $absolute;
   750|         $dir_long = $url;
   751|         if (preg_match('/\\#/', $url)) {
   752|             $link_type |= 0x08;
   753|         }
   754|         $link_type = pack('V', $link_type);
   755|         $up_count = preg_match_all('/\\.\\.\\\\/', $dir_long, $useless);
   756|         $up_count = pack('v', $up_count);
   757|         $dir_short = (string) preg_replace('/\\.\\.\\\\/', '', $dir_long) . "\0";
   758|         $dir_short_len = pack('V', strlen($dir_short));
   759|         $stream_len = pack('V', 0); //strlen($dir_long) + 0x06);
   760|         $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
   761|         $unknown2 = pack('H*', '0303000000000000C000000000000046');
   762|         $unknown3 = pack('H*', 'FFFFADDE000000000000000000000000000000000000000');
   763|         $data = pack('vvvv', $row1, $row2, $col1, $col2)
   764|             . $unknown1
   765|             . $link_type
   766|             . $unknown2
   767|             . $up_count
   768|             . $dir_short_len
   769|             . $dir_short
   770|             . $unknown3
   771|             . $stream_len; /*.
   772|                           $dir_long_len .
   773|                           $unknown4     .
   774|                           $dir_long     .
   775|                           $sheet_len    .
   776|                           $sheet        ;*/
   777|         $length = strlen($data);
   778|         $header = pack('vv', $record, $length);
   779|         $this->append($header . $data);
   780|     }
   781|     /**
   782|      * This method is used to set the height and format for a row.
   783|      *
   784|      * @param int $row The row to set
   785|      * @param int $height Height we are giving to the row.
   786|      *                        Use null to set XF without setting height
   787|      * @param int $xfIndex The optional cell style Xf index to apply to the columns
   788|      * @param bool $hidden The optional hidden attribute
   789|      * @param int $level The optional outline level for row, in range [0,7]
   790|      */
   791|     private function writeRow(int $row, int $height, int $xfIndex, bool $hidden = false, int $level = 0): void
   792|     {
   793|         $record = 0x0208; // Record identifier
   794|         $length = 0x0010; // Number of bytes to follow
   795|         $colMic = 0x0000; // First defined column
   796|         $colMac = 0x0000; // Last defined column
   797|         $irwMac = 0x0000; // Used by Excel to optimise loading
   798|         $reserved = 0x0000; // Reserved
   799|         $grbit = 0x0000; // Option flags
   800|         $ixfe = $xfIndex;
   801|         if ($height < 0) {
   802|             $height = null;
   803|         }
   804|         if ($height !== null) {
   805|             $miyRw = $height * 20; // row height
   806|         } else {
   807|             $miyRw = 0xFF; // default row height is 256
   808|         }
   809|         $grbit |= $level;
   810|         if ($hidden === true) {
   811|             $grbit |= 0x0030;
   812|         }
   813|         if ($height !== null) {
   814|             $grbit |= 0x0040; // fUnsynced
   815|         }
   816|         if ($xfIndex !== 0xF) {
   817|             $grbit |= 0x0080;
   818|         }
   819|         $grbit |= 0x0100;
   820|         $header = pack('vv', $record, $length);
   821|         $data = pack('vvvvvvvv', $row, $colMic, $colMac, $miyRw, $irwMac, $reserved, $grbit, $ixfe);
   822|         $this->append($header . $data);
   823|     }
   824|     /**
   825|      * Writes Excel DIMENSIONS to define the area in which there is data.
   826|      */
   827|     private function writeDimensions(): void
   828|     {
   829|         $record = 0x0200; // Record identifier
   830|         $length = 0x000E;
   831|         $data = pack('VVvvv', $this->firstRowIndex, $this->lastRowIndex + 1, $this->firstColumnIndex, $this->lastColumnIndex + 1, 0x0000); // reserved
   832|         $header = pack('vv', $record, $length);
   833|         $this->append($header . $data);
   834|     }
   835|     /**
   836|      * Write BIFF record Window2.
   837|      */
   838|     private function writeWindow2(): void
   839|     {
   840|         $record = 0x023E; // Record identifier
   841|         $length = 0x0012;
   842|         $rwTop = 0x0000; // Top row visible in window
   843|         $colLeft = 0x0000; // Leftmost column visible in window
   844|         $fDspFmla = 0; // 0 - bit
   845|         $fDspGrid = $this->phpSheet->getShowGridlines() ? 1 : 0; // 1
   846|         $fDspRwCol = $this->phpSheet->getShowRowColHeaders() ? 1 : 0; // 2
   847|         $fFrozen = $this->phpSheet->getFreezePane() ? 1 : 0; // 3
   848|         $fDspZeros = 1; // 4
   849|         $fDefaultHdr = 1; // 5
   850|         $fArabic = $this->phpSheet->getRightToLeft() ? 1 : 0; // 6
   851|         $fDspGuts = $this->outlineOn; // 7
   852|         $fFrozenNoSplit = 0; // 0 - bit
   853|         $fSelected = ($this->phpSheet === $this->phpSheet->getParentOrThrow()->getActiveSheet()) ? 1 : 0;
   854|         $fPageBreakPreview = $this->phpSheet->getSheetView()->getView() === SheetView::SHEETVIEW_PAGE_BREAK_PREVIEW;
   855|         $grbit = $fDspFmla;
   856|         $grbit |= $fDspGrid << 1;
   857|         $grbit |= $fDspRwCol << 2;
   858|         $grbit |= $fFrozen << 3;
   859|         $grbit |= $fDspZeros << 4;
   860|         $grbit |= $fDefaultHdr << 5;
   861|         $grbit |= $fArabic << 6;
   862|         $grbit |= $fDspGuts << 7;
   863|         $grbit |= $fFrozenNoSplit << 8;
   864|         $grbit |= $fSelected << 9; // Selected sheets.
   865|         $grbit |= $fSelected << 10; // Active sheet.
   866|         $grbit |= $fPageBreakPreview << 11;
   867|         $header = pack('vv', $record, $length);
   868|         $data = pack('vvv', $grbit, $rwTop, $colLeft);
   869|         $rgbHdr = 0x0040; // Row/column heading and gridline color index
   870|         $zoom_factor_page_break = ($fPageBreakPreview ? $this->phpSheet->getSheetView()->getZoomScale() : 0x0000);
   871|         $zoom_factor_normal = $this->phpSheet->getSheetView()->getZoomScaleNormal();
   872|         $data .= pack('vvvvV', $rgbHdr, 0x0000, $zoom_factor_page_break, $zoom_factor_normal, 0x00000000);
   873|         $this->append($header . $data);
   874|     }
   875|     /**
   876|      * Write BIFF record DEFAULTROWHEIGHT.
   877|      */
   878|     private function writeDefaultRowHeight(): void
   879|     {
   880|         $defaultRowHeight = $this->phpSheet->getDefaultRowDimension()->getRowHeight();
   881|         if ($defaultRowHeight < 0) {
   882|             return;
   883|         }
   884|         $defaultRowHeight = (int) 20 * $defaultRowHeight;
   885|         $record = 0x0225; // Record identifier
   886|         $length = 0x0004; // Number of bytes to follow
   887|         $header = pack('vv', $record, $length);
   888|         $data = pack('vv', 1, $defaultRowHeight);
   889|         $this->append($header . $data);
   890|     }
   891|     /**
   892|      * Write BIFF record DEFCOLWIDTH if COLINFO records are in use.
   893|      */
   894|     private function writeDefcol(): void
   895|     {
   896|         $defaultColWidth = 8;
   897|         $record = 0x0055; // Record identifier
   898|         $length = 0x0002; // Number of bytes to follow
   899|         $header = pack('vv', $record, $length);
   900|         $data = pack('v', $defaultColWidth);
   901|         $this->append($header . $data);
   902|     }
   903|     /**
   904|      * Write BIFF record COLINFO to define column widths.
   905|      *
   906|      * Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
   907|      * length record.
   908|      *
   909|      * @param array $col_array This is the only parameter received and is composed of the following:
   910|      *                0 => First formatted column,
   911|      *                1 => Last formatted column,
   912|      *                2 => Col width (8.43 is Excel default),
   913|      *                3 => The optional XF format of the column,
   914|      *                4 => Option flags.
   915|      *                5 => Optional outline level
   916|      */
   917|     private function writeColinfo(array $col_array): void
   918|     {
   919|         $colFirst = $col_array[0] ?? null;
   920|         $colLast = $col_array[1] ?? null;
   921|         $coldx = $col_array[2] ?? 8.43;
   922|         $xfIndex = $col_array[3] ?? 15;
   923|         $grbit = $col_array[4] ?? 0;
   924|         $level = $col_array[5] ?? 0;
   925|         $record = 0x007D; // Record identifier
   926|         $length = 0x000C; // Number of bytes to follow
   927|         $coldx *= 256; // Convert to units of 1/256 of a char
   928|         $ixfe = $xfIndex;
   929|         $reserved = 0x0000; // Reserved
   930|         $level = max(0, min($level, 7));
   931|         $grbit |= $level << 8;
   932|         $header = pack('vv', $record, $length);
   933|         $data = pack('vvvvvv', $colFirst, $colLast, $coldx, $ixfe, $grbit, $reserved);
   934|         $this->append($header . $data);
   935|     }
   936|     /**
   937|      * Write BIFF record SELECTION.
   938|      */
   939|     private function writeSelection(): void
   940|     {
   941|         $selectedCells = Coordinate::splitRange($this->phpSheet->getSelectedCells());
   942|         $selectedCells = $selectedCells[0];
   943|         if (count($selectedCells) == 2) {
   944|             [$first, $last] = $selectedCells;
   945|         } else {
   946|             $first = $selectedCells[0];
   947|             $last = $selectedCells[0];
   948|         }
   949|         [$colFirst, $rwFirst] = Coordinate::coordinateFromString($first);
   950|         $colFirst = Coordinate::columnIndexFromString($colFirst) - 1; // base 0 column index
   951|         --$rwFirst; // base 0 row index
   952|         [$colLast, $rwLast] = Coordinate::coordinateFromString($last);
   953|         $colLast = Coordinate::columnIndexFromString($colLast) - 1; // base 0 column index
   954|         --$rwLast; // base 0 row index
   955|         $colFirst = min($colFirst, 255);
   956|         $colLast = min($colLast, 255);
   957|         $rwFirst = min($rwFirst, 65535);
   958|         $rwLast = min($rwLast, 65535);
   959|         $record = 0x001D; // Record identifier
   960|         $length = 0x000F; // Number of bytes to follow
   961|         $pnn = $this->activePane; // Pane position
   962|         $rwAct = $rwFirst; // Active row
   963|         $colAct = $colFirst; // Active column
   964|         $irefAct = 0; // Active cell ref
   965|         $cref = 1; // Number of refs
   966|         if ($rwFirst > $rwLast) {
   967|             [$rwFirst, $rwLast] = [$rwLast, $rwFirst];
   968|         }
   969|         if ($colFirst > $colLast) {
   970|             [$colFirst, $colLast] = [$colLast, $colFirst];
   971|         }
   972|         $header = pack('vv', $record, $length);
   973|         $data = pack('CvvvvvvCC', $pnn, $rwAct, $colAct, $irefAct, $cref, $rwFirst, $rwLast, $colFirst, $colLast);
   974|         $this->append($header . $data);
   975|     }
   976|     /**
   977|      * Store the MERGEDCELLS records for all ranges of merged cells.
   978|      */
   979|     private function writeMergedCells(): void
   980|     {
   981|         $mergeCells = $this->phpSheet->getMergeCells();
   982|         $countMergeCells = count($mergeCells);
   983|         if ($countMergeCells == 0) {
   984|             return;
   985|         }
   986|         $maxCountMergeCellsPerRecord = 1027;
   987|         $record = 0x00E5;
   988|         $i = 0;
   989|         $j = 0;
   990|         $recordData = '';
   991|         foreach ($mergeCells as $mergeCell) {
   992|             ++$i;
   993|             ++$j;
   994|             $range = Coordinate::splitRange($mergeCell);
   995|             [$first, $last] = $range[0];
   996|             [$firstColumn, $firstRow] = Coordinate::indexesFromString($first);
   997|             [$lastColumn, $lastRow] = Coordinate::indexesFromString($last);
   998|             $recordData .= pack('vvvv', $firstRow - 1, $lastRow - 1, $firstColumn - 1, $lastColumn - 1);
   999|             if ($j == $maxCountMergeCellsPerRecord || $i == $countMergeCells) {
  1000|                 $recordData = pack('v', $j) . $recordData;
  1001|                 $length = strlen($recordData);
  1002|                 $header = pack('vv', $record, $length);
  1003|                 $this->append($header . $recordData);
  1004|                 $recordData = '';
  1005|                 $j = 0;
  1006|             }
  1007|         }
  1008|     }
  1009|     /**
  1010|      * Write SHEETLAYOUT record.
  1011|      */
  1012|     private function writeSheetLayout(): void
  1013|     {
  1014|         if (!$this->phpSheet->isTabColorSet()) {
  1015|             return;
  1016|         }
  1017|         $recordData = pack(
  1018|             'vvVVVvv',
  1019|             0x0862,
  1020|             0x0000, // unused
  1021|             0x00000000, // unused
  1022|             0x00000000, // unused
  1023|             0x00000014, // size of record data
  1024|             $this->colors[$this->phpSheet->getTabColor()->getRGB()], // color index
  1025|             0x0000        // unused
  1026|         );
  1027|         $length = strlen($recordData);
  1028|         $record = 0x0862; // Record identifier
  1029|         $header = pack('vv', $record, $length);
  1030|         $this->append($header . $recordData);
  1031|     }
  1032|     private static function protectionBitsDefaultFalse(?bool $value, int $shift): int
  1033|     {
  1034|         if ($value === false) {
  1035|             return 1 << $shift;
  1036|         }
  1037|         return 0;
  1038|     }
  1039|     private static function protectionBitsDefaultTrue(?bool $value, int $shift): int
  1040|     {
  1041|         if ($value !== false) {
  1042|             return 1 << $shift;
  1043|         }
  1044|         return 0;
  1045|     }
  1046|     /**
  1047|      * Write SHEETPROTECTION.
  1048|      */
  1049|     private function writeSheetProtection(): void
  1050|     {
  1051|         $record = 0x0867;
  1052|         $protection = $this->phpSheet->getProtection();
  1053|         $options = self::protectionBitsDefaultTrue($protection->getObjects(), 0)
  1054|             | self::protectionBitsDefaultTrue($protection->getScenarios(), 1)
  1055|             | self::protectionBitsDefaultFalse($protection->getFormatCells(), 2)
  1056|             | self::protectionBitsDefaultFalse($protection->getFormatColumns(), 3)
  1057|             | self::protectionBitsDefaultFalse($protection->getFormatRows(), 4)
  1058|             | self::protectionBitsDefaultFalse($protection->getInsertColumns(), 5)
  1059|             | self::protectionBitsDefaultFalse($protection->getInsertRows(), 6)
  1060|             | self::protectionBitsDefaultFalse($protection->getInsertHyperlinks(), 7)
  1061|             | self::protectionBitsDefaultFalse($protection->getDeleteColumns(), 8)
  1062|             | self::protectionBitsDefaultFalse($protection->getDeleteRows(), 9)
  1063|             | self::protectionBitsDefaultTrue($protection->getSelectLockedCells(), 10)
  1064|             | self::protectionBitsDefaultFalse($protection->getSort(), 11)
  1065|             | self::protectionBitsDefaultFalse($protection->getAutoFilter(), 12)
  1066|             | self::protectionBitsDefaultFalse($protection->getPivotTables(), 13)
  1067|             | self::protectionBitsDefaultTrue($protection->getSelectUnlockedCells(), 14);
  1068|         $recordData = pack(
  1069|             'vVVCVVvv',
  1070|             0x0867, // repeated record identifier
  1071|             0x0000, // not used
  1072|             0x0000, // not used
  1073|             0x00, // not used
  1074|             0x01000200, // unknown data
  1075|             0xFFFFFFFF, // unknown data
  1076|             $options, // options
  1077|             0x0000 // not used
  1078|         );
  1079|         $length = strlen($recordData);
  1080|         $header = pack('vv', $record, $length);
  1081|         $this->append($header . $recordData);
  1082|     }
  1083|     /**
  1084|      * Write BIFF record RANGEPROTECTION.
  1085|      *
  1086|      * Openoffice.org's Documentation of the Microsoft Excel File Format uses term RANGEPROTECTION for these records
  1087|      * Microsoft Office Excel 97-2007 Binary File Format Specification uses term FEAT for these records
  1088|      */
  1089|     private function writeRangeProtection(): void
  1090|     {
  1091|         foreach ($this->phpSheet->getProtectedCellRanges() as $range => $protectedCells) {
  1092|             $password = $protectedCells->getPassword();
  1093|             $cellRanges = explode(' ', $range);
  1094|             $cref = count($cellRanges);
  1095|             $recordData = pack(
  1096|                 'vvVVvCVvVv',
  1097|                 0x0868,
  1098|                 0x00,
  1099|                 0x0000,
  1100|                 0x0000,
  1101|                 0x02,
  1102|                 0x0,
  1103|                 0x0000,
  1104|                 $cref,
  1105|                 0x0000,
  1106|                 0x00
  1107|             );
  1108|             foreach ($cellRanges as $cellRange) {
  1109|                 $recordData .= $this->writeBIFF8CellRangeAddressFixed($cellRange);
  1110|             }
  1111|             $recordData .= pack(
  1112|                 'VV',
  1113|                 0x0000,
  1114|                 hexdec($password)
  1115|             );
  1116|             $recordData .= StringHelper::UTF8toBIFF8UnicodeLong('p' . md5($recordData));
  1117|             $length = strlen($recordData);
  1118|             $record = 0x0868; // Record identifier
  1119|             $header = pack('vv', $record, $length);
  1120|             $this->append($header . $recordData);
  1121|         }
  1122|     }
  1123|     /**
  1124|      * Writes the Excel BIFF PANE record.
  1125|      * The panes can either be frozen or thawed (unfrozen).
  1126|      * Frozen panes are specified in terms of an integer number of rows and columns.
  1127|      * Thawed panes are specified in terms of Excel's units for rows and columns.
  1128|      */
  1129|     private function writePanes(): void
  1130|     {
  1131|         if (!$this->phpSheet->getFreezePane()) {
  1132|             return;
  1133|         }
  1134|         [$column, $row] = Coordinate::indexesFromString($this->phpSheet->getFreezePane());
  1135|         $x = $column - 1;
  1136|         $y = $row - 1;
  1137|         [$leftMostColumn, $topRow] = Coordinate::indexesFromString($this->phpSheet->getTopLeftCell() ?? '');
  1138|         $rwTop = $topRow - 1;
  1139|         $colLeft = $leftMostColumn - 1;
  1140|         $record = 0x0041; // Record identifier
  1141|         $length = 0x000A; // Number of bytes to follow
  1142|         $pnnAct = 0;
  1143|         if ($x != 0 && $y != 0) {
  1144|             $pnnAct = 0; // Bottom right
  1145|         }
  1146|         if ($x != 0 && $y == 0) {
  1147|             $pnnAct = 1; // Top right
  1148|         }
  1149|         if ($x == 0 && $y != 0) {
  1150|             $pnnAct = 2; // Bottom left
  1151|         }
  1152|         if ($x == 0 && $y == 0) {
  1153|             $pnnAct = 3; // Top left
  1154|         }
  1155|         $this->activePane = $pnnAct; // Used in writeSelection
  1156|         $header = pack('vv', $record, $length);
  1157|         $data = pack('vvvvv', $x, $y, $rwTop, $colLeft, $pnnAct);
  1158|         $this->append($header . $data);
  1159|     }
  1160|     /**
  1161|      * Store the page setup SETUP BIFF record.
  1162|      */
  1163|     private function writeSetup(): void
  1164|     {
  1165|         $record = 0x00A1; // Record identifier
  1166|         $length = 0x0022; // Number of bytes to follow
  1167|         $iPaperSize = $this->phpSheet->getPageSetup()->getPaperSize(); // Paper size
  1168|         $iScale = $this->phpSheet->getPageSetup()->getScale() ?: 100; // Print scaling factor
  1169|         $iPageStart = 0x01; // Starting page number
  1170|         $iFitWidth = (int) $this->phpSheet->getPageSetup()->getFitToWidth(); // Fit to number of pages wide
  1171|         $iFitHeight = (int) $this->phpSheet->getPageSetup()->getFitToHeight(); // Fit to number of pages high
  1172|         $iRes = 0x0258; // Print resolution
  1173|         $iVRes = 0x0258; // Vertical print resolution
  1174|         $numHdr = $this->phpSheet->getPageMargins()->getHeader(); // Header Margin
  1175|         $numFtr = $this->phpSheet->getPageMargins()->getFooter(); // Footer Margin
  1176|         $iCopies = 0x01; // Number of copies
  1177|         $fLeftToRight = $this->phpSheet->getPageSetup()->getPageOrder() === PageSetup::PAGEORDER_DOWN_THEN_OVER
  1178|             ? 0x0 : 0x1;
  1179|         $fLandscape = ($this->phpSheet->getPageSetup()->getOrientation() == PageSetup::ORIENTATION_LANDSCAPE)
  1180|             ? 0x0 : 0x1;
  1181|         $fNoPls = 0x0; // Setup not read from printer
  1182|         $fNoColor = 0x0; // Print black and white
  1183|         $fDraft = 0x0; // Print draft quality
  1184|         $fNotes = 0x0; // Print notes
  1185|         $fNoOrient = 0x0; // Orientation not set
  1186|         $fUsePage = 0x0; // Use custom starting page
  1187|         $grbit = $fLeftToRight;
  1188|         $grbit |= $fLandscape << 1;
  1189|         $grbit |= $fNoPls << 2;
  1190|         $grbit |= $fNoColor << 3;
  1191|         $grbit |= $fDraft << 4;
  1192|         $grbit |= $fNotes << 5;
  1193|         $grbit |= $fNoOrient << 6;
  1194|         $grbit |= $fUsePage << 7;
  1195|         $numHdr = pack('d', $numHdr);
  1196|         $numFtr = pack('d', $numFtr);
  1197|         if (self::getByteOrder()) { // if it's Big Endian
  1198|             $numHdr = strrev($numHdr);
  1199|             $numFtr = strrev($numFtr);
  1200|         }
  1201|         $header = pack('vv', $record, $length);
  1202|         $data1 = pack('vvvvvvvv', $iPaperSize, $iScale, $iPageStart, $iFitWidth, $iFitHeight, $grbit, $iRes, $iVRes);
  1203|         $data2 = $numHdr . $numFtr;
  1204|         $data3 = pack('v', $iCopies);
  1205|         $this->append($header . $data1 . $data2 . $data3);
  1206|     }
  1207|     /**
  1208|      * Store the header caption BIFF record.
  1209|      */
  1210|     private function writeHeader(): void
  1211|     {
  1212|         $record = 0x0014; // Record identifier
  1213|         /* removing for now
  1214|         if (strlen($this->phpSheet->getHeaderFooter()->getOddHeader()) <= 255) {
  1215|             $str      = $this->phpSheet->getHeaderFooter()->getOddHeader();       // header string
  1216|         } else {
  1217|             $str = '';
  1218|         }
  1219|         */
  1220|         $recordData = StringHelper::UTF8toBIFF8UnicodeLong($this->phpSheet->getHeaderFooter()->getOddHeader());
  1221|         $length = strlen($recordData);
  1222|         $header = pack('vv', $record, $length);
  1223|         $this->append($header . $recordData);
  1224|     }
  1225|     /**
  1226|      * Store the footer caption BIFF record.
  1227|      */
  1228|     private function writeFooter(): void
  1229|     {
  1230|         $record = 0x0015; // Record identifier
  1231|         /* removing for now
  1232|         if (strlen($this->phpSheet->getHeaderFooter()->getOddFooter()) <= 255) {
  1233|             $str = $this->phpSheet->getHeaderFooter()->getOddFooter();
  1234|         } else {
  1235|             $str = '';
  1236|         }
  1237|         */
  1238|         $recordData = StringHelper::UTF8toBIFF8UnicodeLong($this->phpSheet->getHeaderFooter()->getOddFooter());
  1239|         $length = strlen($recordData);
  1240|         $header = pack('vv', $record, $length);
  1241|         $this->append($header . $recordData);
  1242|     }
  1243|     /**
  1244|      * Store the horizontal centering HCENTER BIFF record.
  1245|      */
  1246|     private function writeHcenter(): void
  1247|     {
  1248|         $record = 0x0083; // Record identifier
  1249|         $length = 0x0002; // Bytes to follow
  1250|         $fHCenter = $this->phpSheet->getPageSetup()->getHorizontalCentered() ? 1 : 0; // Horizontal centering
  1251|         $header = pack('vv', $record, $length);
  1252|         $data = pack('v', $fHCenter);
  1253|         $this->append($header . $data);
  1254|     }
  1255|     /**
  1256|      * Store the vertical centering VCENTER BIFF record.
  1257|      */
  1258|     private function writeVcenter(): void
  1259|     {
  1260|         $record = 0x0084; // Record identifier
  1261|         $length = 0x0002; // Bytes to follow
  1262|         $fVCenter = $this->phpSheet->getPageSetup()->getVerticalCentered() ? 1 : 0; // Horizontal centering
  1263|         $header = pack('vv', $record, $length);
  1264|         $data = pack('v', $fVCenter);
  1265|         $this->append($header . $data);
  1266|     }
  1267|     /**
  1268|      * Store the LEFTMARGIN BIFF record.
  1269|      */
  1270|     private function writeMarginLeft(): void
  1271|     {
  1272|         $record = 0x0026; // Record identifier
  1273|         $length = 0x0008; // Bytes to follow
  1274|         $margin = $this->phpSheet->getPageMargins()->getLeft(); // Margin in inches
  1275|         $header = pack('vv', $record, $length);
  1276|         $data = pack('d', $margin);
  1277|         if (self::getByteOrder()) { // if it's Big Endian
  1278|             $data = strrev($data);
  1279|         }
  1280|         $this->append($header . $data);
  1281|     }
  1282|     /**
  1283|      * Store the RIGHTMARGIN BIFF record.
  1284|      */
  1285|     private function writeMarginRight(): void
  1286|     {
  1287|         $record = 0x0027; // Record identifier
  1288|         $length = 0x0008; // Bytes to follow
  1289|         $margin = $this->phpSheet->getPageMargins()->getRight(); // Margin in inches
  1290|         $header = pack('vv', $record, $length);
  1291|         $data = pack('d', $margin);
  1292|         if (self::getByteOrder()) { // if it's Big Endian
  1293|             $data = strrev($data);
  1294|         }
  1295|         $this->append($header . $data);
  1296|     }
  1297|     /**
  1298|      * Store the TOPMARGIN BIFF record.
  1299|      */
  1300|     private function writeMarginTop(): void
  1301|     {
  1302|         $record = 0x0028; // Record identifier
  1303|         $length = 0x0008; // Bytes to follow
  1304|         $margin = $this->phpSheet->getPageMargins()->getTop(); // Margin in inches
  1305|         $header = pack('vv', $record, $length);
  1306|         $data = pack('d', $margin);
  1307|         if (self::getByteOrder()) { // if it's Big Endian
  1308|             $data = strrev($data);
  1309|         }
  1310|         $this->append($header . $data);
  1311|     }
  1312|     /**
  1313|      * Store the BOTTOMMARGIN BIFF record.
  1314|      */
  1315|     private function writeMarginBottom(): void
  1316|     {
  1317|         $record = 0x0029; // Record identifier
  1318|         $length = 0x0008; // Bytes to follow
  1319|         $margin = $this->phpSheet->getPageMargins()->getBottom(); // Margin in inches
  1320|         $header = pack('vv', $record, $length);
  1321|         $data = pack('d', $margin);
  1322|         if (self::getByteOrder()) { // if it's Big Endian
  1323|             $data = strrev($data);
  1324|         }
  1325|         $this->append($header . $data);
  1326|     }
  1327|     /**
  1328|      * Write the PRINTHEADERS BIFF record.
  1329|      */
  1330|     private function writePrintHeaders(): void
  1331|     {
  1332|         $record = 0x002A; // Record identifier
  1333|         $length = 0x0002; // Bytes to follow
  1334|         $fPrintRwCol = $this->printHeaders; // Boolean flag
  1335|         $header = pack('vv', $record, $length);
  1336|         $data = pack('v', $fPrintRwCol);
  1337|         $this->append($header . $data);
  1338|     }
  1339|     /**
  1340|      * Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
  1341|      * GRIDSET record.
  1342|      */
  1343|     private function writePrintGridlines(): void
  1344|     {
  1345|         $record = 0x002B; // Record identifier
  1346|         $length = 0x0002; // Bytes to follow
  1347|         $fPrintGrid = $this->phpSheet->getPrintGridlines() ? 1 : 0; // Boolean flag
  1348|         $header = pack('vv', $record, $length);
  1349|         $data = pack('v', $fPrintGrid);
  1350|         $this->append($header . $data);
  1351|     }
  1352|     /**
  1353|      * Write the GRIDSET BIFF record. Must be used in conjunction with the
  1354|      * PRINTGRIDLINES record.
  1355|      */
  1356|     private function writeGridset(): void
  1357|     {
  1358|         $record = 0x0082; // Record identifier
  1359|         $length = 0x0002; // Bytes to follow
  1360|         $fGridSet = !$this->phpSheet->getPrintGridlines(); // Boolean flag
  1361|         $header = pack('vv', $record, $length);
  1362|         $data = pack('v', $fGridSet);
  1363|         $this->append($header . $data);
  1364|     }
  1365|     /**
  1366|      * Write the AUTOFILTERINFO BIFF record. This is used to configure the number of autofilter select used in the sheet.
  1367|      */
  1368|     private function writeAutoFilterInfo(): void
  1369|     {
  1370|         $record = 0x009D; // Record identifier
  1371|         $length = 0x0002; // Bytes to follow
  1372|         $rangeBounds = Coordinate::rangeBoundaries($this->phpSheet->getAutoFilter()->getRange());
  1373|         $iNumFilters = 1 + $rangeBounds[1][0] - $rangeBounds[0][0];
  1374|         $header = pack('vv', $record, $length);
  1375|         $data = pack('v', $iNumFilters);
  1376|         $this->append($header . $data);
  1377|     }
  1378|     /**
  1379|      * Write the GUTS BIFF record. This is used to configure the gutter margins
  1380|      * where Excel outline symbols are displayed. The visibility of the gutters is
  1381|      * controlled by a flag in WSBOOL.
  1382|      *
  1383|      * @see writeWsbool()
  1384|      */
  1385|     private function writeGuts(): void
  1386|     {
  1387|         $record = 0x0080; // Record identifier
  1388|         $length = 0x0008; // Bytes to follow
  1389|         $dxRwGut = 0x0000; // Size of row gutter
  1390|         $dxColGut = 0x0000; // Size of col gutter
  1391|         $maxRowOutlineLevel = 0;
  1392|         foreach ($this->phpSheet->getRowDimensions() as $rowDimension) {
  1393|             $maxRowOutlineLevel = max($maxRowOutlineLevel, $rowDimension->getOutlineLevel());
  1394|         }
  1395|         $col_level = 0;
  1396|         $colcount = count($this->columnInfo);
  1397|         for ($i = 0; $i < $colcount; ++$i) {
  1398|             $col_level = max($this->columnInfo[$i][5], $col_level);
  1399|         }
  1400|         $col_level = max(0, min($col_level, 7));
  1401|         if ($maxRowOutlineLevel) {
  1402|             ++$maxRowOutlineLevel;
  1403|         }
  1404|         if ($col_level) {
  1405|             ++$col_level;
  1406|         }
  1407|         $header = pack('vv', $record, $length);
  1408|         $data = pack('vvvv', $dxRwGut, $dxColGut, $maxRowOutlineLevel, $col_level);
  1409|         $this->append($header . $data);
  1410|     }
  1411|     /**
  1412|      * Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
  1413|      * with the SETUP record.
  1414|      */
  1415|     private function writeWsbool(): void
  1416|     {
  1417|         $record = 0x0081; // Record identifier
  1418|         $length = 0x0002; // Bytes to follow
  1419|         $grbit = 0x0000;
  1420|         $grbit |= 0x0001; // Auto page breaks visible
  1421|         if ($this->outlineStyle) {
  1422|             $grbit |= 0x0020; // Auto outline styles
  1423|         }
  1424|         if ($this->phpSheet->getShowSummaryBelow()) {
  1425|             $grbit |= 0x0040; // Outline summary below
  1426|         }
  1427|         if ($this->phpSheet->getShowSummaryRight()) {
  1428|             $grbit |= 0x0080; // Outline summary right
  1429|         }
  1430|         if ($this->phpSheet->getPageSetup()->getFitToPage()) {
  1431|             $grbit |= 0x0100; // Page setup fit to page
  1432|         }
  1433|         if ($this->outlineOn) {
  1434|             $grbit |= 0x0400; // Outline symbols displayed
  1435|         }
  1436|         $header = pack('vv', $record, $length);
  1437|         $data = pack('v', $grbit);
  1438|         $this->append($header . $data);
  1439|     }
  1440|     /**
  1441|      * Write the HORIZONTALPAGEBREAKS and VERTICALPAGEBREAKS BIFF records.
  1442|      */
  1443|     private function writeBreaks(): void
  1444|     {
  1445|         $vbreaks = [];
  1446|         $hbreaks = [];
  1447|         foreach ($this->phpSheet->getRowBreaks() as $cell => $break) {
  1448|             $coordinates = Coordinate::coordinateFromString($cell);
  1449|             $hbreaks[] = $coordinates[1];
  1450|         }
  1451|         foreach ($this->phpSheet->getColumnBreaks() as $cell => $break) {
  1452|             $coordinates = Coordinate::indexesFromString($cell);
  1453|             $vbreaks[] = $coordinates[0] - 1;
  1454|         }
  1455|         if (!empty($hbreaks)) {
  1456|             sort($hbreaks, SORT_NUMERIC);
  1457|             if ($hbreaks[0] == 0) { // don't use first break if it's 0
  1458|                 array_shift($hbreaks);
  1459|             }
  1460|             $record = 0x001B; // Record identifier
  1461|             $cbrk = count($hbreaks); // Number of page breaks
  1462|             $length = 2 + 6 * $cbrk; // Bytes to follow
  1463|             $header = pack('vv', $record, $length);
  1464|             $data = pack('v', $cbrk);
  1465|             foreach ($hbreaks as $hbreak) {
  1466|                 $data .= pack('vvv', $hbreak, 0x0000, 0x00FF);
  1467|             }
  1468|             $this->append($header . $data);
  1469|         }
  1470|         if (!empty($vbreaks)) {
  1471|             $vbreaks = array_slice($vbreaks, 0, 1000);
  1472|             sort($vbreaks, SORT_NUMERIC);
  1473|             if ($vbreaks[0] == 0) { // don't use first break if it's 0
  1474|                 array_shift($vbreaks);
  1475|             }
  1476|             $record = 0x001A; // Record identifier
  1477|             $cbrk = count($vbreaks); // Number of page breaks
  1478|             $length = 2 + 6 * $cbrk; // Bytes to follow
  1479|             $header = pack('vv', $record, $length);
  1480|             $data = pack('v', $cbrk);
  1481|             foreach ($vbreaks as $vbreak) {
  1482|                 $data .= pack('vvv', $vbreak, 0x0000, 0xFFFF);
  1483|             }
  1484|             $this->append($header . $data);
  1485|         }
  1486|     }
  1487|     /**
  1488|      * Set the Biff PROTECT record to indicate that the worksheet is protected.
  1489|      */
  1490|     private function writeProtect(): void
  1491|     {
  1492|         if ($this->phpSheet->getProtection()->getSheet() !== true) {
  1493|             return;
  1494|         }
  1495|         $record = 0x0012; // Record identifier
  1496|         $length = 0x0002; // Bytes to follow
  1497|         $fLock = 1; // Worksheet is protected
  1498|         $header = pack('vv', $record, $length);
  1499|         $data = pack('v', $fLock);
  1500|         $this->append($header . $data);
  1501|     }
  1502|     /**
  1503|      * Write SCENPROTECT.
  1504|      */
  1505|     private function writeScenProtect(): void
  1506|     {
  1507|         if ($this->phpSheet->getProtection()->getSheet() !== true) {
  1508|             return;
  1509|         }
  1510|         if ($this->phpSheet->getProtection()->getScenarios() !== true) {
  1511|             return;
  1512|         }
  1513|         $record = 0x00DD; // Record identifier
  1514|         $length = 0x0002; // Bytes to follow
  1515|         $header = pack('vv', $record, $length);
  1516|         $data = pack('v', 1);
  1517|         $this->append($header . $data);
  1518|     }
  1519|     /**
  1520|      * Write OBJECTPROTECT.
  1521|      */
  1522|     private function writeObjectProtect(): void
  1523|     {
  1524|         if ($this->phpSheet->getProtection()->getSheet() !== true) {
  1525|             return;
  1526|         }
  1527|         if ($this->phpSheet->getProtection()->getObjects() !== true) {
  1528|             return;
  1529|         }
  1530|         $record = 0x0063; // Record identifier
  1531|         $length = 0x0002; // Bytes to follow
  1532|         $header = pack('vv', $record, $length);
  1533|         $data = pack('v', 1);
  1534|         $this->append($header . $data);
  1535|     }
  1536|     /**
  1537|      * Write the worksheet PASSWORD record.
  1538|      */
  1539|     private function writePassword(): void
  1540|     {
  1541|         if ($this->phpSheet->getProtection()->getSheet() !== true || !$this->phpSheet->getProtection()->getPassword() || $this->phpSheet->getProtection()->getAlgorithm() !== '') {
  1542|             return;
  1543|         }
  1544|         $record = 0x0013; // Record identifier
  1545|         $length = 0x0002; // Bytes to follow
  1546|         $wPassword = hexdec($this->phpSheet->getProtection()->getPassword()); // Encoded password
  1547|         $header = pack('vv', $record, $length);
  1548|         $data = pack('v', $wPassword);
  1549|         $this->append($header . $data);
  1550|     }
  1551|     /**
  1552|      * Insert a 24bit bitmap image in a worksheet.
  1553|      *
  1554|      * @param int $row The row we are going to insert the bitmap into
  1555|      * @param int $col The column we are going to insert the bitmap into
  1556|      * @param GdImage|string $bitmap The bitmap filename or GD-image resource
  1557|      * @param int $x the horizontal position (offset) of the image inside the cell
  1558|      * @param int $y the vertical position (offset) of the image inside the cell
  1559|      * @param float $scale_x The horizontal scale
  1560|      * @param float $scale_y The vertical scale
  1561|      */
  1562|     public function insertBitmap(int $row, int $col, GdImage|string $bitmap, int $x = 0, int $y = 0, float $scale_x = 1, float $scale_y = 1): void
  1563|     {
  1564|         $bitmap_array = $bitmap instanceof GdImage
  1565|             ? $this->processBitmapGd($bitmap)
  1566|             : $this->processBitmap($bitmap);
  1567|         [$width, $height, $size, $data] = $bitmap_array;
  1568|         $width *= $scale_x;
  1569|         $height *= $scale_y;
  1570|         $this->positionImage($col, $row, $x, $y, (int) $width, (int) $height);
  1571|         $record = 0x007F;
  1572|         $length = 8 + $size;
  1573|         $cf = 0x09;
  1574|         $env = 0x01;
  1575|         $lcb = $size;
  1576|         $header = pack('vvvvV', $record, $length, $cf, $env, $lcb);
  1577|         $this->append($header . $data);
  1578|     }
  1579|     /**
  1580|      * Calculate the vertices that define the position of the image as required by
  1581|      * the OBJ record.
  1582|      *
  1583|      *         +------------+------------+
  1584|      *         |     A      |      B     |
  1585|      *   +-----+------------+------------+
  1586|      *   |     |(x1,y1)     |            |
  1587|      *   |  1  |(A1)._______|______      |
  1588|      *   |     |    |              |     |
  1589|      *   |     |    |              |     |
  1590|      *   +-----+----|    BITMAP    |-----+
  1591|      *   |     |    |              |     |
  1592|      *   |  2  |    |______________.     |
  1593|      *   |     |            |        (B2)|
  1594|      *   |     |            |     (x2,y2)|
  1595|      *   +---- +------------+------------+
  1596|      *
  1597|      * Example of a bitmap that covers some of the area from cell A1 to cell B2.
  1598|      *
  1599|      * Based on the width and height of the bitmap we need to calculate 8 vars:
  1600|      *     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
  1601|      * The width and height of the cells are also variable and have to be taken into
  1602|      * account.
  1603|      * The values of $col_start and $row_start are passed in from the calling
  1604|      * function. The values of $col_end and $row_end are calculated by subtracting
  1605|      * the width and height of the bitmap from the width and height of the
  1606|      * underlying cells.
  1607|      * The vertices are expressed as a percentage of the underlying cell width as
  1608|      * follows (rhs values are in pixels):
  1609|      *
  1610|      *       x1 = X / W *1024
  1611|      *       y1 = Y / H *256
  1612|      *       x2 = (X-1) / W *1024
  1613|      *       y2 = (Y-1) / H *256
  1614|      *
  1615|      *       Where:  X is distance from the left side of the underlying cell
  1616|      *               Y is distance from the top of the underlying cell
  1617|      *               W is the width of the cell
  1618|      *               H is the height of the cell
  1619|      * The SDK incorrectly states that the height should be expressed as a
  1620|      *        percentage of 1024.
  1621|      *
  1622|      * @param int $col_start Col containing upper left corner of object
  1623|      * @param int $row_start Row containing top left corner of object
  1624|      * @param int $x1 Distance to left side of object
  1625|      * @param int $y1 Distance to top of object
  1626|      * @param int $width Width of image frame
  1627|      * @param int $height Height of image frame
  1628|      */
  1629|     public function positionImage(int $col_start, int $row_start, int $x1, int $y1, int $width, int $height): void
  1630|     {
  1631|         $col_end = $col_start; // Col containing lower right corner of object
  1632|         $row_end = $row_start; // Row containing bottom right corner of object
  1633|         if ($x1 >= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1))) {
  1634|             $x1 = 0;
  1635|         }
  1636|         if ($y1 >= Xls::sizeRow($this->phpSheet, $row_start + 1)) {
  1637|             $y1 = 0;
  1638|         }
  1639|         $width = $width + $x1 - 1;
  1640|         $height = $height + $y1 - 1;
  1641|         while ($width >= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1))) {
  1642|             $width -= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1));
  1643|             ++$col_end;
  1644|         }
  1645|         while ($height >= Xls::sizeRow($this->phpSheet, $row_end + 1)) {
  1646|             $height -= Xls::sizeRow($this->phpSheet, $row_end + 1);
  1647|             ++$row_end;
  1648|         }
  1649|         if (Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1)) == 0) {
  1650|             return;
  1651|         }
  1652|         if (Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1)) == 0) {
  1653|             return;
  1654|         }
  1655|         if (Xls::sizeRow($this->phpSheet, $row_start + 1) == 0) {
  1656|             return;
  1657|         }
  1658|         if (Xls::sizeRow($this->phpSheet, $row_end + 1) == 0) {
  1659|             return;
  1660|         }
  1661|         $x1 = $x1 / Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1)) * 1024;
  1662|         $y1 = $y1 / Xls::sizeRow($this->phpSheet, $row_start + 1) * 256;
  1663|         $x2 = $width / Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1)) * 1024; // Distance to right side of object
  1664|         $y2 = $height / Xls::sizeRow($this->phpSheet, $row_end + 1) * 256; // Distance to bottom of object
  1665|         $this->writeObjPicture($col_start, $x1, $row_start, $y1, $col_end, $x2, $row_end, $y2);
  1666|     }
  1667|     /**
  1668|      * Store the OBJ record that precedes an IMDATA record. This could be generalise
  1669|      * to support other Excel objects.
  1670|      *
  1671|      * @param int $colL Column containing upper left corner of object
  1672|      * @param int $dxL Distance from left side of cell
  1673|      * @param int $rwT Row containing top left corner of object
  1674|      * @param float|int $dyT Distance from top of cell
  1675|      * @param int $colR Column containing lower right corner of object
  1676|      * @param int $dxR Distance from right of cell
  1677|      * @param int $rwB Row containing bottom right corner of object
  1678|      * @param int $dyB Distance from bottom of cell
  1679|      */
  1680|     private function writeObjPicture(int $colL, int $dxL, int $rwT, int|float $dyT, int $colR, int $dxR, int $rwB, int $dyB): void
  1681|     {
  1682|         $record = 0x005D; // Record identifier
  1683|         $length = 0x003C; // Bytes to follow
  1684|         $cObj = 0x0001; // Count of objects in file (set to 1)
  1685|         $OT = 0x0008; // Object type. 8 = Picture
  1686|         $id = 0x0001; // Object ID
  1687|         $grbit = 0x0614; // Option flags
  1688|         $cbMacro = 0x0000; // Length of FMLA structure
  1689|         $Reserved1 = 0x0000; // Reserved
  1690|         $Reserved2 = 0x0000; // Reserved
  1691|         $icvBack = 0x09; // Background colour
  1692|         $icvFore = 0x09; // Foreground colour
  1693|         $fls = 0x00; // Fill pattern
  1694|         $fAuto = 0x00; // Automatic fill
  1695|         $icv = 0x08; // Line colour
  1696|         $lns = 0xFF; // Line style
  1697|         $lnw = 0x01; // Line weight
  1698|         $fAutoB = 0x00; // Automatic border
  1699|         $frs = 0x0000; // Frame style
  1700|         $cf = 0x0009; // Image format, 9 = bitmap
  1701|         $Reserved3 = 0x0000; // Reserved
  1702|         $cbPictFmla = 0x0000; // Length of FMLA structure
  1703|         $Reserved4 = 0x0000; // Reserved
  1704|         $grbit2 = 0x0001; // Option flags
  1705|         $Reserved5 = 0x0000; // Reserved
  1706|         $header = pack('vv', $record, $length);
  1707|         $data = pack('V', $cObj);
  1708|         $data .= pack('v', $OT);
  1709|         $data .= pack('v', $id);
  1710|         $data .= pack('v', $grbit);
  1711|         $data .= pack('v', $colL);
  1712|         $data .= pack('v', $dxL);
  1713|         $data .= pack('v', $rwT);
  1714|         $data .= pack('v', $dyT);
  1715|         $data .= pack('v', $colR);
  1716|         $data .= pack('v', $dxR);
  1717|         $data .= pack('v', $rwB);
  1718|         $data .= pack('v', $dyB);
  1719|         $data .= pack('v', $cbMacro);
  1720|         $data .= pack('V', $Reserved1);
  1721|         $data .= pack('v', $Reserved2);
  1722|         $data .= pack('C', $icvBack);
  1723|         $data .= pack('C', $icvFore);
  1724|         $data .= pack('C', $fls);
  1725|         $data .= pack('C', $fAuto);
  1726|         $data .= pack('C', $icv);
  1727|         $data .= pack('C', $lns);
  1728|         $data .= pack('C', $lnw);
  1729|         $data .= pack('C', $fAutoB);
  1730|         $data .= pack('v', $frs);
  1731|         $data .= pack('V', $cf);
  1732|         $data .= pack('v', $Reserved3);
  1733|         $data .= pack('v', $cbPictFmla);
  1734|         $data .= pack('v', $Reserved4);
  1735|         $data .= pack('v', $grbit2);
  1736|         $data .= pack('V', $Reserved5);
  1737|         $this->append($header . $data);
  1738|     }
  1739|     /**
  1740|      * Convert a GD-image into the internal format.
  1741|      *
  1742|      * @param GdImage $image The image to process
  1743|      *
  1744|      * @return array Array with data and properties of the bitmap
  1745|      */
  1746|     public function processBitmapGd(GdImage $image): array
  1747|     {
  1748|         $width = imagesx($image);
  1749|         $height = imagesy($image);
  1750|         $data = pack('Vvvvv', 0x000C, $width, $height, 0x01, 0x18);
  1751|         for ($j = $height; --$j;) {
  1752|             for ($i = 0; $i < $width; ++$i) {
  1753|                 /** @phpstan-ignore-next-line */
  1754|                 $color = imagecolorsforindex($image, imagecolorat($image, $i, $j));
  1755|                 if ($color !== false) {
  1756|                     foreach (['red', 'green', 'blue'] as $key) {
  1757|                         $color[$key] = $color[$key] + (int) round((255 - $color[$key]) * $color['alpha'] / 127);
  1758|                     }
  1759|                     $data .= chr($color['blue']) . chr($color['green']) . chr($color['red']);
  1760|                 }
  1761|             }
  1762|             if (3 * $width % 4) {
  1763|                 $data .= str_repeat("\x00", 4 - 3 * $width % 4);
  1764|             }
  1765|         }
  1766|         return [$width, $height, strlen($data), $data];
  1767|     }
  1768|     /**
  1769|      * Convert a 24 bit bitmap into the modified internal format used by Windows.
  1770|      * This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
  1771|      * MSDN library.
  1772|      *
  1773|      * @param string $bitmap The bitmap to process
  1774|      *
  1775|      * @return array Array with data and properties of the bitmap
  1776|      */
  1777|     public function processBitmap(string $bitmap): array
  1778|     {
  1779|         $bmp_fd = @fopen($bitmap, 'rb');
  1780|         if ($bmp_fd === false || 0 === (int) filesize($bitmap)) {
  1781|             throw new WriterException("Couldn't import $bitmap");
  1782|         }
  1783|         $data = (string) fread($bmp_fd, (int) filesize($bitmap));
  1784|         if (strlen($data) <= 0x36) {
  1785|             throw new WriterException("$bitmap doesn't contain enough data.\n");
  1786|         }
  1787|         $identity = unpack('A2ident', $data);
  1788|         if ($identity === false || $identity['ident'] != 'BM') {
  1789|             throw new WriterException("$bitmap doesn't appear to be a valid bitmap image.\n");
  1790|         }
  1791|         $data = substr($data, 2);
  1792|         $size_array = unpack('Vsa', substr($data, 0, 4)) ?: [];
  1793|         $size = $size_array['sa'];
  1794|         $data = substr($data, 4);
  1795|         $size -= 0x36; // Subtract size of bitmap header.
  1796|         $size += 0x0C; // Add size of BIFF header.
  1797|         $data = substr($data, 12);
  1798|         $width_and_height = unpack('V2', substr($data, 0, 8)) ?: [];
  1799|         $width = $width_and_height[1];
  1800|         $height = $width_and_height[2];
  1801|         $data = substr($data, 8);
  1802|         if ($width > 0xFFFF) {
  1803|             throw new WriterException("$bitmap: largest image width supported is 65k.\n");
  1804|         }
  1805|         if ($height > 0xFFFF) {
  1806|             throw new WriterException("$bitmap: largest image height supported is 65k.\n");
  1807|         }
  1808|         $planes_and_bitcount = unpack('v2', substr($data, 0, 4));
  1809|         $data = substr($data, 4);
  1810|         if ($planes_and_bitcount === false || $planes_and_bitcount[2] != 24) { // Bitcount
  1811|             throw new WriterException("$bitmap isn't a 24bit true color bitmap.\n");
  1812|         }
  1813|         if ($planes_and_bitcount[1] != 1) {
  1814|             throw new WriterException("$bitmap: only 1 plane supported in bitmap image.\n");
  1815|         }
  1816|         $compression = unpack('Vcomp', substr($data, 0, 4));
  1817|         $data = substr($data, 4);
  1818|         if ($compression === false || $compression['comp'] != 0) {
  1819|             throw new WriterException("$bitmap: compression not supported in bitmap image.\n");
  1820|         }
  1821|         $data = substr($data, 20);
  1822|         $header = pack('Vvvvv', 0x000C, $width, $height, 0x01, 0x18);
  1823|         $data = $header . $data;
  1824|         return [$width, $height, $size, $data];
  1825|     }
  1826|     /**
  1827|      * Store the window zoom factor. This should be a reduced fraction but for
  1828|      * simplicity we will store all fractions with a numerator of 100.
  1829|      */
  1830|     private function writeZoom(): void
  1831|     {
  1832|         if ($this->phpSheet->getSheetView()->getZoomScale() == 100) {
  1833|             return;
  1834|         }
  1835|         $record = 0x00A0; // Record identifier
  1836|         $length = 0x0004; // Bytes to follow
  1837|         $header = pack('vv', $record, $length);
  1838|         $data = pack('vv', $this->phpSheet->getSheetView()->getZoomScale(), 100);
  1839|         $this->append($header . $data);
  1840|     }
  1841|     /**
  1842|      * Get Escher object.
  1843|      */
  1844|     public function getEscher(): ?\PhpOffice\PhpSpreadsheet\Shared\Escher
  1845|     {
  1846|         return $this->escher;
  1847|     }
  1848|     /**
  1849|      * Set Escher object.
  1850|      */
  1851|     public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher): void
  1852|     {
  1853|         $this->escher = $escher;
  1854|     }
  1855|     /**
  1856|      * Write MSODRAWING record.
  1857|      */
  1858|     private function writeMsoDrawing(): void
  1859|     {
  1860|         if (isset($this->escher)) {
  1861|             $writer = new Escher($this->escher);
  1862|             $data = $writer->close();
  1863|             $spOffsets = $writer->getSpOffsets();
  1864|             $spTypes = $writer->getSpTypes();
  1865|             $spOffsets[0] = 0;
  1866|             $nm = count($spOffsets) - 1; // number of shapes excluding first shape
  1867|             for ($i = 1; $i <= $nm; ++$i) {
  1868|                 $record = 0x00EC; // Record identifier
  1869|                 $dataChunk = substr($data, $spOffsets[$i - 1], $spOffsets[$i] - $spOffsets[$i - 1]);
  1870|                 $length = strlen($dataChunk);
  1871|                 $header = pack('vv', $record, $length);
  1872|                 $this->append($header . $dataChunk);
  1873|                 $record = 0x005D; // record identifier
  1874|                 $objData = '';
  1875|                 if ($spTypes[$i] == 0x00C9) {
  1876|                     $objData
  1877|                         .= pack(
  1878|                             'vvvvvVVV',
  1879|                             0x0015, // 0x0015 = ftCmo
  1880|                             0x0012, // length of ftCmo data
  1881|                             0x0014, // object type, 0x0014 = filter
  1882|                             $i, // object id number, Excel seems to use 1-based index, local for the sheet
  1883|                             0x2101, // option flags, 0x2001 is what OpenOffice.org uses
  1884|                             0, // reserved
  1885|                             0, // reserved
  1886|                             0  // reserved
  1887|                         );
  1888|                     $objData .= pack('vv', 0x00C, 0x0014);
  1889|                     $objData .= pack('H*', '0000000000000000640001000A00000010000100');
  1890|                     $objData .= pack('vv', 0x0013, 0x1FEE);
  1891|                     $objData .= pack('H*', '00000000010001030000020008005700');
  1892|                 } else {
  1893|                     $objData
  1894|                         .= pack(
  1895|                             'vvvvvVVV',
  1896|                             0x0015, // 0x0015 = ftCmo
  1897|                             0x0012, // length of ftCmo data
  1898|                             0x0008, // object type, 0x0008 = picture
  1899|                             $i, // object id number, Excel seems to use 1-based index, local for the sheet
  1900|                             0x6011, // option flags, 0x6011 is what OpenOffice.org uses
  1901|                             0, // reserved
  1902|                             0, // reserved
  1903|                             0  // reserved
  1904|                         );
  1905|                 }
  1906|                 $objData
  1907|                     .= pack(
  1908|                         'vv',
  1909|                         0x0000, // 0x0000 = ftEnd
  1910|                         0x0000  // length of ftEnd data
  1911|                     );
  1912|                 $length = strlen($objData);
  1913|                 $header = pack('vv', $record, $length);
  1914|                 $this->append($header . $objData);
  1915|             }
  1916|         }
  1917|     }
  1918|     /**
  1919|      * Store the DATAVALIDATIONS and DATAVALIDATION records.
  1920|      */
  1921|     private function writeDataValidity(): void
  1922|     {
  1923|         $dataValidationCollection = $this->phpSheet->getDataValidationCollection();
  1924|         if (!empty($dataValidationCollection)) {
  1925|             $record = 0x01B2; // Record identifier
  1926|             $length = 0x0012; // Bytes to follow
  1927|             $grbit = 0x0000; // Prompt box at cell, no cached validity data at DV records
  1928|             $horPos = 0x00000000; // Horizontal position of prompt box, if fixed position
  1929|             $verPos = 0x00000000; // Vertical position of prompt box, if fixed position
  1930|             $objId = 0xFFFFFFFF; // Object identifier of drop down arrow object, or -1 if not visible
  1931|             $header = pack('vv', $record, $length);
  1932|             $data = pack('vVVVV', $grbit, $horPos, $verPos, $objId, count($dataValidationCollection));
  1933|             $this->append($header . $data);
  1934|             $record = 0x01BE; // Record identifier
  1935|             foreach ($dataValidationCollection as $cellCoordinate => $dataValidation) {
  1936|                 $options = 0x00000000;
  1937|                 $type = CellDataValidation::type($dataValidation);
  1938|                 $options |= $type << 0;
  1939|                 $errorStyle = CellDataValidation::errorStyle($dataValidation);
  1940|                 $options |= $errorStyle << 4;
  1941|                 if ($type == 0x03 && preg_match('/^\".*\"$/', $dataValidation->getFormula1())) {
  1942|                     $options |= 0x01 << 7;
  1943|                 }
  1944|                 $options |= $dataValidation->getAllowBlank() << 8;
  1945|                 $options |= (!$dataValidation->getShowDropDown()) << 9;
  1946|                 $options |= $dataValidation->getShowInputMessage() << 18;
  1947|                 $options |= $dataValidation->getShowErrorMessage() << 19;
  1948|                 $operator = CellDataValidation::operator($dataValidation);
  1949|                 $options |= $operator << 20;
  1950|                 $data = pack('V', $options);
  1951|                 $promptTitle = $dataValidation->getPromptTitle() !== ''
  1952|                     ? $dataValidation->getPromptTitle() : chr(0);
  1953|                 $data .= StringHelper::UTF8toBIFF8UnicodeLong($promptTitle);
  1954|                 $errorTitle = $dataValidation->getErrorTitle() !== ''
  1955|                     ? $dataValidation->getErrorTitle() : chr(0);
  1956|                 $data .= StringHelper::UTF8toBIFF8UnicodeLong($errorTitle);
  1957|                 $prompt = $dataValidation->getPrompt() !== ''
  1958|                     ? $dataValidation->getPrompt() : chr(0);
  1959|                 $data .= StringHelper::UTF8toBIFF8UnicodeLong($prompt);
  1960|                 $error = $dataValidation->getError() !== ''
  1961|                     ? $dataValidation->getError() : chr(0);
  1962|                 $data .= StringHelper::UTF8toBIFF8UnicodeLong($error);
  1963|                 try {
  1964|                     $formula1 = $dataValidation->getFormula1();
  1965|                     if ($type == 0x03) { // list type
  1966|                         $formula1 = str_replace(',', chr(0), $formula1);
  1967|                     }
  1968|                     $this->parser->parse($formula1);
  1969|                     $formula1 = $this->parser->toReversePolish();
  1970|                     $sz1 = strlen($formula1);
  1971|                 } catch (PhpSpreadsheetException $e) {
  1972|                     $sz1 = 0;
  1973|                     $formula1 = '';
  1974|                 }
  1975|                 $data .= pack('vv', $sz1, 0x0000);
  1976|                 $data .= $formula1;
  1977|                 try {
  1978|                     $formula2 = $dataValidation->getFormula2();
  1979|                     if ($formula2 === '') {
  1980|                         throw new WriterException('No formula2');
  1981|                     }
  1982|                     $this->parser->parse($formula2);
  1983|                     $formula2 = $this->parser->toReversePolish();
  1984|                     $sz2 = strlen($formula2);
  1985|                 } catch (PhpSpreadsheetException) {
  1986|                     $sz2 = 0;
  1987|                     $formula2 = '';
  1988|                 }
  1989|                 $data .= pack('vv', $sz2, 0x0000);
  1990|                 $data .= $formula2;
  1991|                 $data .= pack('v', 0x0001);
  1992|                 $data .= $this->writeBIFF8CellRangeAddressFixed($cellCoordinate);
  1993|                 $length = strlen($data);
  1994|                 $header = pack('vv', $record, $length);
  1995|                 $this->append($header . $data);
  1996|             }
  1997|         }
  1998|     }
  1999|     /**
  2000|      * Write PLV Record.
  2001|      */
  2002|     private function writePageLayoutView(): void
  2003|     {
  2004|         $record = 0x088B; // Record identifier
  2005|         $length = 0x0010; // Bytes to follow
  2006|         $rt = 0x088B; // 2
  2007|         $grbitFrt = 0x0000; // 2
  2008|         $wScalvePLV = $this->phpSheet->getSheetView()->getZoomScale(); // 2
  2009|         if ($this->phpSheet->getSheetView()->getView() == SheetView::SHEETVIEW_PAGE_LAYOUT) {
  2010|             $fPageLayoutView = 1;
  2011|         } else {
  2012|             $fPageLayoutView = 0;
  2013|         }
  2014|         $fRulerVisible = 0;
  2015|         $fWhitespaceHidden = 0;
  2016|         $grbit = $fPageLayoutView; // 2
  2017|         $grbit |= $fRulerVisible << 1;
  2018|         $grbit |= $fWhitespaceHidden << 3;
  2019|         $header = pack('vv', $record, $length);
  2020|         $data = pack('vvVVvv', $rt, $grbitFrt, 0x00000000, 0x00000000, $wScalvePLV, $grbit);
  2021|         $this->append($header . $data);
  2022|     }
  2023|     /**
  2024|      * Write CFRule Record.
  2025|      *
  2026|      * @see https://www.openoffice.org/sc/excelfileformat.pdf Search for CFHEADER followed by CFRULE
  2027|      */
  2028|     private function writeCFRule(
  2029|         ConditionalHelper $conditionalFormulaHelper,
  2030|         Conditional $conditional,
  2031|         string $cellRange
  2032|     ): void {
  2033|         $record = 0x01B1; // Record identifier
  2034|         $type = null; // Type of the CF
  2035|         $operatorType = null; // Comparison operator
  2036|         if ($conditional->getConditionType() == Conditional::CONDITION_EXPRESSION) {
  2037|             $type = 0x02;
  2038|             $operatorType = 0x00;
  2039|         } elseif ($conditional->getConditionType() == Conditional::CONDITION_CELLIS) {
  2040|             $type = 0x01;
  2041|             switch ($conditional->getOperatorType()) {
  2042|                 case Conditional::OPERATOR_NONE:
  2043|                     $operatorType = 0x00;
  2044|                     break;
  2045|                 case Conditional::OPERATOR_EQUAL:
  2046|                     $operatorType = 0x03;
  2047|                     break;
  2048|                 case Conditional::OPERATOR_GREATERTHAN:
  2049|                     $operatorType = 0x05;
  2050|                     break;
  2051|                 case Conditional::OPERATOR_GREATERTHANOREQUAL:
  2052|                     $operatorType = 0x07;
  2053|                     break;
  2054|                 case Conditional::OPERATOR_LESSTHAN:
  2055|                     $operatorType = 0x06;
  2056|                     break;
  2057|                 case Conditional::OPERATOR_LESSTHANOREQUAL:
  2058|                     $operatorType = 0x08;
  2059|                     break;
  2060|                 case Conditional::OPERATOR_NOTEQUAL:
  2061|                     $operatorType = 0x04;
  2062|                     break;
  2063|                 case Conditional::OPERATOR_BETWEEN:
  2064|                     $operatorType = 0x01;
  2065|                     break;
  2066|             }
  2067|         }
  2068|         $arrConditions = $conditional->getConditions();
  2069|         $numConditions = count($arrConditions);
  2070|         $szValue1 = 0x0000;
  2071|         $szValue2 = 0x0000;
  2072|         $operand1 = null;
  2073|         $operand2 = null;
  2074|         if ($numConditions === 1) {
  2075|             $conditionalFormulaHelper->processCondition($arrConditions[0], $cellRange);
  2076|             $szValue1 = $conditionalFormulaHelper->size();
  2077|             $operand1 = $conditionalFormulaHelper->tokens();
  2078|         } elseif ($numConditions === 2 && ($conditional->getOperatorType() === Conditional::OPERATOR_BETWEEN)) {
  2079|             $conditionalFormulaHelper->processCondition($arrConditions[0], $cellRange);
  2080|             $szValue1 = $conditionalFormulaHelper->size();
  2081|             $operand1 = $conditionalFormulaHelper->tokens();
  2082|             $conditionalFormulaHelper->processCondition($arrConditions[1], $cellRange);
  2083|             $szValue2 = $conditionalFormulaHelper->size();
  2084|             $operand2 = $conditionalFormulaHelper->tokens();
  2085|         }
  2086|         /*$bAlignHz = ($conditional->getStyle()->getAlignment()->getHorizontal() === null ? 1 : 0);
  2087|         $bAlignVt = ($conditional->getStyle()->getAlignment()->getVertical() === null ? 1 : 0);
  2088|         $bAlignWrapTx = ($conditional->getStyle()->getAlignment()->getWrapText() === false ? 1 : 0);
  2089|         $bTxRotation = ($conditional->getStyle()->getAlignment()->getTextRotation() === null ? 1 : 0);
  2090|         $bIndent = ($conditional->getStyle()->getAlignment()->getIndent() === 0 ? 1 : 0);
  2091|         $bShrinkToFit = ($conditional->getStyle()->getAlignment()->getShrinkToFit() === false ? 1 : 0);
  2092|         if ($bAlignHz == 0 || $bAlignVt == 0 || $bAlignWrapTx == 0 || $bTxRotation == 0 || $bIndent == 0 || $bShrinkToFit == 0) {
  2093|             $bFormatAlign = 1;
  2094|         } else {
  2095|             $bFormatAlign = 0;
  2096|         }*/
  2097|         /*$bProtLocked = ($conditional->getStyle()->getProtection()->getLocked() === null ? 1 : 0);
  2098|         $bProtHidden = ($conditional->getStyle()->getProtection()->getHidden() === null ? 1 : 0);
  2099|         if ($bProtLocked == 0 || $bProtHidden == 0) {
  2100|             $bFormatProt = 1;
  2101|         } else {
  2102|             $bFormatProt = 0;
  2103|         }*/
  2104|         $bBorderLeft = ($conditional->getStyle()->getBorders()->getLeft()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
  2105|         $bBorderRight = ($conditional->getStyle()->getBorders()->getRight()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
  2106|         $bBorderTop = ($conditional->getStyle()->getBorders()->getTop()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
  2107|         $bBorderBottom = ($conditional->getStyle()->getBorders()->getBottom()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
  2108|         $bBorderDiagTop = self::$always0; //$diagonalDirection === Borders::DIAGONAL_DOWN || $diagonalDirection === Borders::DIAGONAL_BOTH;
  2109|         $bBorderDiagBottom = self::$always0; //$diagonalDirection === Borders::DIAGONAL_UP || $diagonalDirection === Borders::DIAGONAL_BOTH;
  2110|         if ($bBorderLeft === 1 || $bBorderRight === 1 || $bBorderTop === 1 || $bBorderBottom === 1 || $bBorderDiagTop === 1 || $bBorderDiagBottom === 1) {
  2111|             $bFormatBorder = 1;
  2112|         } else {
  2113|             $bFormatBorder = 0;
  2114|         }
  2115|         $bFillStyle = ($conditional->getStyle()->getFill()->getFillType() === null ? 0 : 1);
  2116|         $bFillColor = ($conditional->getStyle()->getFill()->getStartColor()->getARGB() === null ? 0 : 1);
  2117|         $bFillColorBg = ($conditional->getStyle()->getFill()->getEndColor()->getARGB() === null ? 0 : 1);
  2118|         if ($bFillStyle == 1 || $bFillColor == 1 || $bFillColorBg == 1) {
  2119|             $bFormatFill = 1;
  2120|         } else {
  2121|             $bFormatFill = 0;
  2122|         }
  2123|         if (
  2124|             $conditional->getStyle()->getFont()->getName() !== null
  2125|             || $conditional->getStyle()->getFont()->getSize() !== null
  2126|             || $conditional->getStyle()->getFont()->getBold() !== null
  2127|             || $conditional->getStyle()->getFont()->getItalic() !== null
  2128|             || $conditional->getStyle()->getFont()->getSuperscript() !== null
  2129|             || $conditional->getStyle()->getFont()->getSubscript() !== null
  2130|             || $conditional->getStyle()->getFont()->getUnderline() !== null
  2131|             || $conditional->getStyle()->getFont()->getStrikethrough() !== null
  2132|             || $conditional->getStyle()->getFont()->getColor()->getARGB() !== null
  2133|         ) {
  2134|             $bFormatFont = 1;
  2135|         } else {
  2136|             $bFormatFont = 0;
  2137|         }
  2138|         $flags = 0;
  2139|         $flags |= (1 == self::$always1 ? 0x00000010 : 0);
  2140|         $flags |= (1 == self::$always1 ? 0x00000080 : 0);
  2141|         $flags |= (0 == $bBorderLeft ? 0x00000400 : 0);
  2142|         $flags |= (0 == $bBorderRight ? 0x00000800 : 0);
  2143|         $flags |= (0 == $bBorderTop ? 0x00001000 : 0);
  2144|         $flags |= (0 == $bBorderBottom ? 0x00002000 : 0);
  2145|         $flags |= (0 === $bBorderDiagTop ? 0x00004000 : 0); // Top left to Bottom right border
  2146|         $flags |= (0 === $bBorderDiagBottom ? 0x00008000 : 0); // Bottom left to Top right border
  2147|         $flags |= (1 == $bFillStyle ? 0x00010000 : 0);
  2148|         $flags |= (1 == $bFillColor ? 0x00020000 : 0);
  2149|         $flags |= (1 == $bFillColorBg ? 0x00040000 : 0);
  2150|         $flags |= (1 == self::$always1 ? 0x00380000 : 0);
  2151|         $flags |= (1 == $bFormatFont ? 0x04000000 : 0);
  2152|         $flags |= (1 == $bFormatBorder ? 0x10000000 : 0);
  2153|         $flags |= (1 == $bFormatFill ? 0x20000000 : 0);
  2154|         $flags |= (1 == self::$always0 ? 0x80000000 : 0);
  2155|         $dataBlockFont = null;
  2156|         $dataBlockBorder = null;
  2157|         $dataBlockFill = null;
  2158|         if ($bFormatFont == 1) {
  2159|             if ($conditional->getStyle()->getFont()->getName() === null) {
  2160|                 $dataBlockFont = pack('VVVVVVVV', 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);
  2161|                 $dataBlockFont .= pack('VVVVVVVV', 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);
  2162|             } else {
  2163|                 $dataBlockFont = StringHelper::UTF8toBIFF8UnicodeLong($conditional->getStyle()->getFont()->getName());
  2164|             }
  2165|             if ($conditional->getStyle()->getFont()->getSize() === null) {
  2166|                 $dataBlockFont .= pack('V', 20 * 11);
  2167|             } else {
  2168|                 $dataBlockFont .= pack('V', 20 * $conditional->getStyle()->getFont()->getSize());
  2169|             }
  2170|             $italicStrike = 0;
  2171|             if ($conditional->getStyle()->getFont()->getItalic() === true) {
  2172|                 $italicStrike |= 2;
  2173|             }
  2174|             if ($conditional->getStyle()->getFont()->getStrikethrough() === true) {
  2175|                 $italicStrike |= 0x80;
  2176|             }
  2177|             $dataBlockFont .= pack('V', $italicStrike);
  2178|             if ($conditional->getStyle()->getFont()->getBold() === true) {
  2179|                 $dataBlockFont .= pack('v', 0x02BC);
  2180|             } elseif ($conditional->getStyle()->getFont()->getBold() === null) {
  2181|                 $dataBlockFont .= pack('v', 0x0000);
  2182|             } else {
  2183|                 $dataBlockFont .= pack('v', 0x0190);
  2184|             }
  2185|             if ($conditional->getStyle()->getFont()->getSubscript() === true) {
  2186|                 $dataBlockFont .= pack('v', 0x02);
  2187|                 $fontEscapement = 0;
  2188|             } elseif ($conditional->getStyle()->getFont()->getSuperscript() === true) {
  2189|                 $dataBlockFont .= pack('v', 0x01);
  2190|                 $fontEscapement = 0;
  2191|             } else {
  2192|                 $dataBlockFont .= pack('v', 0x00);
  2193|                 $fontEscapement = 1;
  2194|             }
  2195|             switch ($conditional->getStyle()->getFont()->getUnderline()) {
  2196|                 case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_NONE:
  2197|                     $dataBlockFont .= pack('C', 0x00);
  2198|                     $fontUnderline = 0;
  2199|                     break;
  2200|                 case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLE:
  2201|                     $dataBlockFont .= pack('C', 0x02);
  2202|                     $fontUnderline = 0;
  2203|                     break;
  2204|                 case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLEACCOUNTING:
  2205|                     $dataBlockFont .= pack('C', 0x22);
  2206|                     $fontUnderline = 0;
  2207|                     break;
  2208|                 case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLE:
  2209|                     $dataBlockFont .= pack('C', 0x01);
  2210|                     $fontUnderline = 0;
  2211|                     break;
  2212|                 case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLEACCOUNTING:
  2213|                     $dataBlockFont .= pack('C', 0x21);
  2214|                     $fontUnderline = 0;
  2215|                     break;
  2216|                 default:
  2217|                     $dataBlockFont .= pack('C', 0x00);
  2218|                     $fontUnderline = 1;
  2219|                     break;
  2220|             }
  2221|             $dataBlockFont .= pack('vC', 0x0000, 0x00);
  2222|             $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getFont()->getColor()->getRgb(), 0);
  2223|             $dataBlockFont .= pack('V', $colorIdx);
  2224|             $dataBlockFont .= pack('V', 0x00000000);
  2225|             $optionsFlags = 0;
  2226|             $optionsFlags |= ($conditional->getStyle()->getFont()->getBold() === null && $conditional->getStyle()->getFont()->getItalic() === null) ? 2 : 0;
  2227|             $optionsFlags |= (1 == self::$always1 ? 0x00000008 : 0);
  2228|             $optionsFlags |= (1 == self::$always1 ? 0x00000010 : 0);
  2229|             $optionsFlags |= (1 == self::$always0 ? 0x00000020 : 0);
  2230|             $optionsFlags |= ($conditional->getStyle()->getFont()->getStrikethrough() === null) ? 0x80 : 0;
  2231|             $dataBlockFont .= pack('V', $optionsFlags);
  2232|             $dataBlockFont .= pack('V', $fontEscapement);
  2233|             $dataBlockFont .= pack('V', $fontUnderline);
  2234|             $dataBlockFont .= pack('V', 0x00000000);
  2235|             $dataBlockFont .= pack('V', 0x00000000);
  2236|             $dataBlockFont .= pack('VV', 0x00000000, 0x00000000);
  2237|             $dataBlockFont .= pack('v', 0x0001);
  2238|         }
  2239|         /*if ($bFormatAlign === 1) {
  2240|             $blockAlign = Style\CellAlignment::horizontal($conditional->getStyle()->getAlignment());
  2241|             $blockAlign |= Style\CellAlignment::wrap($conditional->getStyle()->getAlignment()) << 3;
  2242|             $blockAlign |= Style\CellAlignment::vertical($conditional->getStyle()->getAlignment()) << 4;
  2243|             $blockAlign |= 0 << 7;
  2244|             $blockRotation = $conditional->getStyle()->getAlignment()->getTextRotation();
  2245|             $blockIndent = $conditional->getStyle()->getAlignment()->getIndent();
  2246|             if ($conditional->getStyle()->getAlignment()->getShrinkToFit() === true) {
  2247|                 $blockIndent |= 1 << 4;
  2248|             } else {
  2249|                 $blockIndent |= 0 << 4;
  2250|             }
  2251|             $blockIndent |= 0 << 6;
  2252|             $blockIndentRelative = 255;
  2253|             $dataBlockAlign = pack('CCvvv', $blockAlign, $blockRotation, $blockIndent, $blockIndentRelative, 0x0000);
  2254|         }*/
  2255|         if ($bFormatBorder === 1) {
  2256|             $blockLineStyle = Style\CellBorder::style($conditional->getStyle()->getBorders()->getLeft());
  2257|             $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getRight()) << 4;
  2258|             $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getTop()) << 8;
  2259|             $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getBottom()) << 12;
  2260|             if ($bBorderLeft !== 0) {
  2261|                 $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getLeft()->getColor()->getRgb(), 0);
  2262|                 $blockLineStyle |= $colorIdx << 16;
  2263|             }
  2264|             if ($bBorderRight !== 0) {
  2265|                 $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getRight()->getColor()->getRgb(), 0);
  2266|                 $blockLineStyle |= $colorIdx << 23;
  2267|             }
  2268|             $blockColor = 0;
  2269|             if ($bBorderTop !== 0) {
  2270|                 $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getTop()->getColor()->getRgb(), 0);
  2271|                 $blockColor |= $colorIdx;
  2272|             }
  2273|             if ($bBorderBottom !== 0) {
  2274|                 $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getBottom()->getColor()->getRgb(), 0);
  2275|                 $blockColor |= $colorIdx << 7;
  2276|             }
  2277|             /* Excel does not support condtional diagonal borders even for xlsx
  2278|             if ($bBorderDiagTop !== 0 || $bBorderDiagBottom !== 0) {
  2279|                 $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getDiagonal()->getColor()->getRgb(), 0);
  2280|                 $blockColor |= $colorIdx << 14;
  2281|                 $blockColor |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getDiagonal()) << 21;
  2282|                 if ($bBorderDiagTop !== 0) {
  2283|                     $blockLineStyle |= 1 << 30;
  2284|                 }
  2285|                 if ($bBorderDiagBottom !== 0) {
  2286|                     $blockLineStyle |= 1 << 31;
  2287|                 }
  2288|             }
  2289|             */
  2290|             $dataBlockBorder = pack('VV', $blockLineStyle, $blockColor);
  2291|         }
  2292|         if ($bFormatFill === 1) {
  2293|             $blockFillPatternStyle = Style\CellFill::style($conditional->getStyle()->getFill());
  2294|             $colorIdxBg = $this->workbookColorIndex($conditional->getStyle()->getFill()->getStartColor()->getRgb(), 0x41);
  2295|             $colorIdxFg = $this->workbookColorIndex($conditional->getStyle()->getFill()->getEndColor()->getRgb(), 0x40);
  2296|             $dataBlockFill = pack('v', $blockFillPatternStyle);
  2297|             $dataBlockFill .= pack('v', $colorIdxFg | ($colorIdxBg << 7));
  2298|         }
  2299|         $data = pack('CCvvVv', $type, $operatorType, $szValue1, $szValue2, $flags, 0x0000);
  2300|         if ($bFormatFont === 1) { // Block Formatting : OK
  2301|             $data .= $dataBlockFont;
  2302|         }
  2303|         if ($bFormatBorder === 1) {
  2304|             $data .= $dataBlockBorder;
  2305|         }
  2306|         if ($bFormatFill === 1) { // Block Formatting : OK
  2307|             $data .= $dataBlockFill;
  2308|         }
  2309|         if ($operand1 !== null) {
  2310|             $data .= $operand1;
  2311|         }
  2312|         if ($operand2 !== null) {
  2313|             $data .= $operand2;
  2314|         }
  2315|         $header = pack('vv', $record, strlen($data));
  2316|         $this->append($header . $data);
  2317|     }
  2318|     /**
  2319|      * Write CFHeader record.
  2320|      *
  2321|      * @param Conditional[] $conditionalStyles
  2322|      */
  2323|     private function writeCFHeader(string $cellCoordinate, array $conditionalStyles): bool
  2324|     {
  2325|         $record = 0x01B0; // Record identifier
  2326|         $length = 0x0016; // Bytes to follow
  2327|         $numColumnMin = null;
  2328|         $numColumnMax = null;
  2329|         $numRowMin = null;
  2330|         $numRowMax = null;
  2331|         $arrConditional = [];
  2332|         foreach ($conditionalStyles as $conditional) {
  2333|             if (!in_array($conditional->getHashCode(), $arrConditional)) {
  2334|                 $arrConditional[] = $conditional->getHashCode();
  2335|             }
  2336|             $rangeCoordinates = Coordinate::rangeBoundaries($cellCoordinate);
  2337|             if ($numColumnMin === null || ($numColumnMin > $rangeCoordinates[0][0])) {
  2338|                 $numColumnMin = $rangeCoordinates[0][0];
  2339|             }
  2340|             if ($numColumnMax === null || ($numColumnMax < $rangeCoordinates[1][0])) {
  2341|                 $numColumnMax = $rangeCoordinates[1][0];
  2342|             }
  2343|             if ($numRowMin === null || ($numRowMin > $rangeCoordinates[0][1])) {
  2344|                 $numRowMin = (int) $rangeCoordinates[0][1];
  2345|             }
  2346|             if ($numRowMax === null || ($numRowMax < $rangeCoordinates[1][1])) {
  2347|                 $numRowMax = (int) $rangeCoordinates[1][1];
  2348|             }
  2349|         }
  2350|         if (count($arrConditional) === 0) {
  2351|             return false;
  2352|         }
  2353|         $needRedraw = 1;
  2354|         $cellRange = pack('vvvv', $numRowMin - 1, $numRowMax - 1, $numColumnMin - 1, $numColumnMax - 1);
  2355|         $header = pack('vv', $record, $length);
  2356|         $data = pack('vv', count($arrConditional), $needRedraw);
  2357|         $data .= $cellRange;
  2358|         $data .= pack('v', 0x0001);
  2359|         $data .= $cellRange;
  2360|         $this->append($header . $data);
  2361|         return true;
  2362|     }
  2363|     /*private function getDataBlockProtection(Conditional $conditional): int
  2364|     {
  2365|         $dataBlockProtection = 0;
  2366|         if ($conditional->getStyle()->getProtection()->getLocked() == Protection::PROTECTION_PROTECTED) {
  2367|             $dataBlockProtection = 1;
  2368|         }
  2369|         if ($conditional->getStyle()->getProtection()->getHidden() == Protection::PROTECTION_PROTECTED) {
  2370|             $dataBlockProtection = 1 << 1;
  2371|         }
  2372|         return $dataBlockProtection;
  2373|     }*/
  2374|     private function workbookColorIndex(?string $rgb, int $default): int
  2375|     {
  2376|         return (empty($rgb) || $this->writerWorkbook === null) ? $default : $this->writerWorkbook->addColor($rgb, $default);
  2377|     }
  2378| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx/Comments.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-172 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     4| use PhpOffice\PhpSpreadsheet\Comment;
     5| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
     6| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     7| use PhpOffice\PhpSpreadsheet\Style\Alignment;
     8| class Comments extends WriterPart
     9| {
    10|     private const VALID_HORIZONTAL_ALIGNMENT = [
    11|         Alignment::HORIZONTAL_CENTER,
    12|         Alignment::HORIZONTAL_DISTRIBUTED,
    13|         Alignment::HORIZONTAL_JUSTIFY,
    14|         Alignment::HORIZONTAL_LEFT,
    15|         Alignment::HORIZONTAL_RIGHT,
    16|     ];
    17|     /**
    18|      * Write comments to XML format.
    19|      *
    20|      * @return string XML Output
    21|      */
    22|     public function writeComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet): string
    23|     {
    24|         $objWriter = null;
    25|         if ($this->getParentWriter()->getUseDiskCaching()) {
    26|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    27|         } else {
    28|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    29|         }
    30|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    31|         $comments = $worksheet->getComments();
    32|         $authors = [];
    33|         $authorId = 0;
    34|         foreach ($comments as $comment) {
    35|             if (!isset($authors[$comment->getAuthor()])) {
    36|                 $authors[$comment->getAuthor()] = $authorId++;
    37|             }
    38|         }
    39|         $objWriter->startElement('comments');
    40|         $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
    41|         $objWriter->startElement('authors');
    42|         foreach ($authors as $author => $index) {
    43|             $objWriter->writeElement('author', $author);
    44|         }
    45|         $objWriter->endElement();
    46|         $objWriter->startElement('commentList');
    47|         foreach ($comments as $key => $value) {
    48|             $this->writeComment($objWriter, $key, $value, $authors);
    49|         }
    50|         $objWriter->endElement();
    51|         $objWriter->endElement();
    52|         return $objWriter->getData();
    53|     }
    54|     /**
    55|      * Write comment to XML format.
    56|      *
    57|      * @param string $cellReference Cell reference
    58|      * @param Comment $comment Comment
    59|      * @param array $authors Array of authors
    60|      */
    61|     private function writeComment(XMLWriter $objWriter, string $cellReference, Comment $comment, array $authors): void
    62|     {
    63|         $objWriter->startElement('comment');
    64|         $objWriter->writeAttribute('ref', $cellReference);
    65|         $objWriter->writeAttribute('authorId', $authors[$comment->getAuthor()]);
    66|         $objWriter->startElement('text');
    67|         $this->getParentWriter()->getWriterPartstringtable()->writeRichText($objWriter, $comment->getText());
    68|         $objWriter->endElement();
    69|         $objWriter->endElement();
    70|     }
    71|     /**
    72|      * Write VML comments to XML format.
    73|      *
    74|      * @return string XML Output
    75|      */
    76|     public function writeVMLComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet): string
    77|     {
    78|         $objWriter = null;
    79|         if ($this->getParentWriter()->getUseDiskCaching()) {
    80|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    81|         } else {
    82|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    83|         }
    84|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    85|         $comments = $worksheet->getComments();
    86|         $objWriter->startElement('xml');
    87|         $objWriter->writeAttribute('xmlns:v', Namespaces::URN_VML);
    88|         $objWriter->writeAttribute('xmlns:o', Namespaces::URN_MSOFFICE);
    89|         $objWriter->writeAttribute('xmlns:x', Namespaces::URN_EXCEL);
    90|         $objWriter->startElement('o:shapelayout');
    91|         $objWriter->writeAttribute('v:ext', 'edit');
    92|         $objWriter->startElement('o:idmap');
    93|         $objWriter->writeAttribute('v:ext', 'edit');
    94|         $objWriter->writeAttribute('data', '1');
    95|         $objWriter->endElement();
    96|         $objWriter->endElement();
    97|         $objWriter->startElement('v:shapetype');
    98|         $objWriter->writeAttribute('id', '_x0000_t202');
    99|         $objWriter->writeAttribute('coordsize', '21600,21600');
   100|         $objWriter->writeAttribute('o:spt', '202');
   101|         $objWriter->writeAttribute('path', 'm,l,21600r21600,l21600,xe');
   102|         $objWriter->startElement('v:stroke');
   103|         $objWriter->writeAttribute('joinstyle', 'miter');
   104|         $objWriter->endElement();
   105|         $objWriter->startElement('v:path');
   106|         $objWriter->writeAttribute('gradientshapeok', 't');
   107|         $objWriter->writeAttribute('o:connecttype', 'rect');
   108|         $objWriter->endElement();
   109|         $objWriter->endElement();
   110|         foreach ($comments as $key => $value) {
   111|             $this->writeVMLComment($objWriter, $key, $value);
   112|         }
   113|         $objWriter->endElement();
   114|         return $objWriter->getData();
   115|     }
   116|     /**
   117|      * Write VML comment to XML format.
   118|      *
   119|      * @param string $cellReference Cell reference, eg: 'A1'
   120|      * @param Comment $comment Comment
   121|      */
   122|     private function writeVMLComment(XMLWriter $objWriter, string $cellReference, Comment $comment): void
   123|     {
   124|         [$column, $row] = Coordinate::indexesFromString($cellReference);
   125|         $id = 1024 + $column + $row;
   126|         $id = substr("$id", 0, 4);
   127|         $objWriter->startElement('v:shape');
   128|         $objWriter->writeAttribute('id', '_x0000_s' . $id);
   129|         $objWriter->writeAttribute('type', '#_x0000_t202');
   130|         $objWriter->writeAttribute('style', 'position:absolute;margin-left:' . $comment->getMarginLeft() . ';margin-top:' . $comment->getMarginTop() . ';width:' . $comment->getWidth() . ';height:' . $comment->getHeight() . ';z-index:1;visibility:' . ($comment->getVisible() ? 'visible' : 'hidden'));
   131|         $objWriter->writeAttribute('fillcolor', '#' . $comment->getFillColor()->getRGB());
   132|         $objWriter->writeAttribute('o:insetmode', 'auto');
   133|         $objWriter->startElement('v:fill');
   134|         $objWriter->writeAttribute('color2', '#' . $comment->getFillColor()->getRGB());
   135|         if ($comment->hasBackgroundImage()) {
   136|             $bgImage = $comment->getBackgroundImage();
   137|             $objWriter->writeAttribute('o:relid', 'rId' . $bgImage->getImageIndex());
   138|             $objWriter->writeAttribute('o:title', $bgImage->getName());
   139|             $objWriter->writeAttribute('type', 'frame');
   140|         }
   141|         $objWriter->endElement();
   142|         $objWriter->startElement('v:shadow');
   143|         $objWriter->writeAttribute('on', 't');
   144|         $objWriter->writeAttribute('color', 'black');
   145|         $objWriter->writeAttribute('obscured', 't');
   146|         $objWriter->endElement();
   147|         $objWriter->startElement('v:path');
   148|         $objWriter->writeAttribute('o:connecttype', 'none');
   149|         $objWriter->endElement();
   150|         $textBoxArray = [Comment::TEXTBOX_DIRECTION_RTL => 'rtl', Comment::TEXTBOX_DIRECTION_LTR => 'ltr'];
   151|         $textboxRtl = $textBoxArray[strtolower($comment->getTextBoxDirection())] ?? 'auto';
   152|         $objWriter->startElement('v:textbox');
   153|         $objWriter->writeAttribute('style', "mso-direction-alt:$textboxRtl");
   154|         $objWriter->startElement('div');
   155|         $objWriter->writeAttribute('style', ($textboxRtl === 'rtl' ? 'text-align:right;direction:rtl' : 'text-align:left'));
   156|         $objWriter->endElement();
   157|         $objWriter->endElement();
   158|         $objWriter->startElement('x:ClientData');
   159|         $objWriter->writeAttribute('ObjectType', 'Note');
   160|         $objWriter->writeElement('x:MoveWithCells', '');
   161|         $objWriter->writeElement('x:SizeWithCells', '');
   162|         $objWriter->writeElement('x:AutoFill', 'False');
   163|         $alignment = strtolower($comment->getAlignment());
   164|         if (in_array($alignment, self::VALID_HORIZONTAL_ALIGNMENT, true)) {
   165|             $objWriter->writeElement('x:TextHAlign', ucfirst($alignment));
   166|         }
   167|         $objWriter->writeElement('x:Row', (string) ($row - 1));
   168|         $objWriter->writeElement('x:Column', (string) ($column - 1));
   169|         $objWriter->endElement();
   170|         $objWriter->endElement();
   171|     }
   172| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx/Style.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-504 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
     4| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
     5| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     6| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     7| use PhpOffice\PhpSpreadsheet\Style\Alignment;
     8| use PhpOffice\PhpSpreadsheet\Style\Border;
     9| use PhpOffice\PhpSpreadsheet\Style\Borders;
    10| use PhpOffice\PhpSpreadsheet\Style\Conditional;
    11| use PhpOffice\PhpSpreadsheet\Style\Fill;
    12| use PhpOffice\PhpSpreadsheet\Style\Font;
    13| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    14| use PhpOffice\PhpSpreadsheet\Style\Protection;
    15| class Style extends WriterPart
    16| {
    17|     /**
    18|      * Write styles to XML format.
    19|      *
    20|      * @return string XML Output
    21|      */
    22|     public function writeStyles(Spreadsheet $spreadsheet): string
    23|     {
    24|         $objWriter = null;
    25|         if ($this->getParentWriter()->getUseDiskCaching()) {
    26|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    27|         } else {
    28|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    29|         }
    30|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    31|         $objWriter->startElement('styleSheet');
    32|         $objWriter->writeAttribute('xml:space', 'preserve');
    33|         $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
    34|         $objWriter->startElement('numFmts');
    35|         $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getNumFmtHashTable()->count());
    36|         for ($i = 0; $i < $this->getParentWriter()->getNumFmtHashTable()->count(); ++$i) {
    37|             $this->writeNumFmt($objWriter, $this->getParentWriter()->getNumFmtHashTable()->getByIndex($i), $i);
    38|         }
    39|         $objWriter->endElement();
    40|         $objWriter->startElement('fonts');
    41|         $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getFontHashTable()->count());
    42|         for ($i = 0; $i < $this->getParentWriter()->getFontHashTable()->count(); ++$i) {
    43|             $thisfont = $this->getParentWriter()->getFontHashTable()->getByIndex($i);
    44|             if ($thisfont !== null) {
    45|                 $this->writeFont($objWriter, $thisfont);
    46|             }
    47|         }
    48|         $objWriter->endElement();
    49|         $objWriter->startElement('fills');
    50|         $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getFillHashTable()->count());
    51|         for ($i = 0; $i < $this->getParentWriter()->getFillHashTable()->count(); ++$i) {
    52|             $thisfill = $this->getParentWriter()->getFillHashTable()->getByIndex($i);
    53|             if ($thisfill !== null) {
    54|                 $this->writeFill($objWriter, $thisfill);
    55|             }
    56|         }
    57|         $objWriter->endElement();
    58|         $objWriter->startElement('borders');
    59|         $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getBordersHashTable()->count());
    60|         for ($i = 0; $i < $this->getParentWriter()->getBordersHashTable()->count(); ++$i) {
    61|             $thisborder = $this->getParentWriter()->getBordersHashTable()->getByIndex($i);
    62|             if ($thisborder !== null) {
    63|                 $this->writeBorder($objWriter, $thisborder);
    64|             }
    65|         }
    66|         $objWriter->endElement();
    67|         $objWriter->startElement('cellStyleXfs');
    68|         $objWriter->writeAttribute('count', '1');
    69|         $objWriter->startElement('xf');
    70|         $objWriter->writeAttribute('numFmtId', '0');
    71|         $objWriter->writeAttribute('fontId', '0');
    72|         $objWriter->writeAttribute('fillId', '0');
    73|         $objWriter->writeAttribute('borderId', '0');
    74|         $objWriter->endElement();
    75|         $objWriter->endElement();
    76|         $objWriter->startElement('cellXfs');
    77|         $objWriter->writeAttribute('count', (string) count($spreadsheet->getCellXfCollection()));
    78|         $alignment = new Alignment();
    79|         $defaultAlignHash = $alignment->getHashCode();
    80|         if ($defaultAlignHash !== $spreadsheet->getDefaultStyle()->getAlignment()->getHashCode()) {
    81|             $defaultAlignHash = '';
    82|         }
    83|         foreach ($spreadsheet->getCellXfCollection() as $cellXf) {
    84|             $this->writeCellStyleXf($objWriter, $cellXf, $spreadsheet, $defaultAlignHash);
    85|         }
    86|         $objWriter->endElement();
    87|         $objWriter->startElement('cellStyles');
    88|         $objWriter->writeAttribute('count', '1');
    89|         $objWriter->startElement('cellStyle');
    90|         $objWriter->writeAttribute('name', 'Normal');
    91|         $objWriter->writeAttribute('xfId', '0');
    92|         $objWriter->writeAttribute('builtinId', '0');
    93|         $objWriter->endElement();
    94|         $objWriter->endElement();
    95|         $objWriter->startElement('dxfs');
    96|         $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getStylesConditionalHashTable()->count());
    97|         for ($i = 0; $i < $this->getParentWriter()->getStylesConditionalHashTable()->count(); ++$i) {
    98|             $thisstyle = $this->getParentWriter()->getStylesConditionalHashTable()->getByIndex($i);
    99|             if ($thisstyle !== null) {
   100|                 $this->writeCellStyleDxf($objWriter, $thisstyle->getStyle());
   101|             }
   102|         }
   103|         $objWriter->endElement();
   104|         $objWriter->startElement('tableStyles');
   105|         $objWriter->writeAttribute('defaultTableStyle', 'TableStyleMedium9');
   106|         $objWriter->writeAttribute('defaultPivotStyle', 'PivotTableStyle1');
   107|         $objWriter->endElement();
   108|         $objWriter->endElement();
   109|         return $objWriter->getData();
   110|     }
   111|     /**
   112|      * Write Fill.
   113|      */
   114|     private function writeFill(XMLWriter $objWriter, Fill $fill): void
   115|     {
   116|         if (
   117|             $fill->getFillType() === Fill::FILL_GRADIENT_LINEAR
   118|             || $fill->getFillType() === Fill::FILL_GRADIENT_PATH
   119|         ) {
   120|             $this->writeGradientFill($objWriter, $fill);
   121|         } elseif ($fill->getFillType() !== null) {
   122|             $this->writePatternFill($objWriter, $fill);
   123|         }
   124|     }
   125|     /**
   126|      * Write Gradient Fill.
   127|      */
   128|     private function writeGradientFill(XMLWriter $objWriter, Fill $fill): void
   129|     {
   130|         $objWriter->startElement('fill');
   131|         $objWriter->startElement('gradientFill');
   132|         $objWriter->writeAttribute('type', (string) $fill->getFillType());
   133|         $objWriter->writeAttribute('degree', (string) $fill->getRotation());
   134|         $objWriter->startElement('stop');
   135|         $objWriter->writeAttribute('position', '0');
   136|         if ($fill->getStartColor()->getARGB() !== null) {
   137|             $objWriter->startElement('color');
   138|             $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
   139|             $objWriter->endElement();
   140|         }
   141|         $objWriter->endElement();
   142|         $objWriter->startElement('stop');
   143|         $objWriter->writeAttribute('position', '1');
   144|         if ($fill->getEndColor()->getARGB() !== null) {
   145|             $objWriter->startElement('color');
   146|             $objWriter->writeAttribute('rgb', $fill->getEndColor()->getARGB());
   147|             $objWriter->endElement();
   148|         }
   149|         $objWriter->endElement();
   150|         $objWriter->endElement();
   151|         $objWriter->endElement();
   152|     }
   153|     private static function writePatternColors(Fill $fill): bool
   154|     {
   155|         if ($fill->getFillType() === Fill::FILL_NONE) {
   156|             return false;
   157|         }
   158|         return $fill->getFillType() === Fill::FILL_SOLID || $fill->getColorsChanged();
   159|     }
   160|     /**
   161|      * Write Pattern Fill.
   162|      */
   163|     private function writePatternFill(XMLWriter $objWriter, Fill $fill): void
   164|     {
   165|         $objWriter->startElement('fill');
   166|         $objWriter->startElement('patternFill');
   167|         $objWriter->writeAttribute('patternType', (string) $fill->getFillType());
   168|         if (self::writePatternColors($fill)) {
   169|             if ($fill->getStartColor()->getARGB()) {
   170|                 if (!$fill->getEndColor()->getARGB() && $fill->getFillType() === Fill::FILL_SOLID) {
   171|                     $objWriter->startElement('bgColor');
   172|                     $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
   173|                 } else {
   174|                     $objWriter->startElement('fgColor');
   175|                     $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
   176|                 }
   177|                 $objWriter->endElement();
   178|             }
   179|             if ($fill->getEndColor()->getARGB()) {
   180|                 $objWriter->startElement('bgColor');
   181|                 $objWriter->writeAttribute('rgb', $fill->getEndColor()->getARGB());
   182|                 $objWriter->endElement();
   183|             }
   184|         }
   185|         $objWriter->endElement();
   186|         $objWriter->endElement();
   187|     }
   188|     private function startFont(XMLWriter $objWriter, bool &$fontStarted): void
   189|     {
   190|         if (!$fontStarted) {
   191|             $fontStarted = true;
   192|             $objWriter->startElement('font');
   193|         }
   194|     }
   195|     /**
   196|      * Write Font.
   197|      */
   198|     private function writeFont(XMLWriter $objWriter, Font $font): void
   199|     {
   200|         $fontStarted = false;
   201|         if ($font->getBold() !== null) {
   202|             $this->startFont($objWriter, $fontStarted);
   203|             $objWriter->startElement('b');
   204|             $objWriter->writeAttribute('val', $font->getBold() ? '1' : '0');
   205|             $objWriter->endElement();
   206|         }
   207|         if ($font->getItalic() !== null) {
   208|             $this->startFont($objWriter, $fontStarted);
   209|             $objWriter->startElement('i');
   210|             $objWriter->writeAttribute('val', $font->getItalic() ? '1' : '0');
   211|             $objWriter->endElement();
   212|         }
   213|         if ($font->getStrikethrough() !== null) {
   214|             $this->startFont($objWriter, $fontStarted);
   215|             $objWriter->startElement('strike');
   216|             $objWriter->writeAttribute('val', $font->getStrikethrough() ? '1' : '0');
   217|             $objWriter->endElement();
   218|         }
   219|         if ($font->getUnderline() !== null) {
   220|             $this->startFont($objWriter, $fontStarted);
   221|             $objWriter->startElement('u');
   222|             $objWriter->writeAttribute('val', $font->getUnderline());
   223|             $objWriter->endElement();
   224|         }
   225|         if ($font->getSuperscript() === true || $font->getSubscript() === true) {
   226|             $this->startFont($objWriter, $fontStarted);
   227|             $objWriter->startElement('vertAlign');
   228|             if ($font->getSuperscript() === true) {
   229|                 $objWriter->writeAttribute('val', 'superscript');
   230|             } elseif ($font->getSubscript() === true) {
   231|                 $objWriter->writeAttribute('val', 'subscript');
   232|             }
   233|             $objWriter->endElement();
   234|         }
   235|         if ($font->getSize() !== null) {
   236|             $this->startFont($objWriter, $fontStarted);
   237|             $objWriter->startElement('sz');
   238|             $objWriter->writeAttribute('val', StringHelper::formatNumber($font->getSize()));
   239|             $objWriter->endElement();
   240|         }
   241|         if ($font->getColor()->getARGB() !== null) {
   242|             $this->startFont($objWriter, $fontStarted);
   243|             $objWriter->startElement('color');
   244|             $objWriter->writeAttribute('rgb', $font->getColor()->getARGB());
   245|             $objWriter->endElement();
   246|         }
   247|         if ($font->getName() !== null) {
   248|             $this->startFont($objWriter, $fontStarted);
   249|             $objWriter->startElement('name');
   250|             $objWriter->writeAttribute('val', $font->getName());
   251|             $objWriter->endElement();
   252|         }
   253|         if (!empty($font->getScheme())) {
   254|             $this->startFont($objWriter, $fontStarted);
   255|             $objWriter->startElement('scheme');
   256|             $objWriter->writeAttribute('val', $font->getScheme());
   257|             $objWriter->endElement();
   258|         }
   259|         if ($fontStarted) {
   260|             $objWriter->endElement();
   261|         }
   262|     }
   263|     /**
   264|      * Write Border.
   265|      */
   266|     private function writeBorder(XMLWriter $objWriter, Borders $borders): void
   267|     {
   268|         $objWriter->startElement('border');
   269|         switch ($borders->getDiagonalDirection()) {
   270|             case Borders::DIAGONAL_UP:
   271|                 $objWriter->writeAttribute('diagonalUp', 'true');
   272|                 $objWriter->writeAttribute('diagonalDown', 'false');
   273|                 break;
   274|             case Borders::DIAGONAL_DOWN:
   275|                 $objWriter->writeAttribute('diagonalUp', 'false');
   276|                 $objWriter->writeAttribute('diagonalDown', 'true');
   277|                 break;
   278|             case Borders::DIAGONAL_BOTH:
   279|                 $objWriter->writeAttribute('diagonalUp', 'true');
   280|                 $objWriter->writeAttribute('diagonalDown', 'true');
   281|                 break;
   282|         }
   283|         $this->writeBorderPr($objWriter, 'left', $borders->getLeft());
   284|         $this->writeBorderPr($objWriter, 'right', $borders->getRight());
   285|         $this->writeBorderPr($objWriter, 'top', $borders->getTop());
   286|         $this->writeBorderPr($objWriter, 'bottom', $borders->getBottom());
   287|         $this->writeBorderPr($objWriter, 'diagonal', $borders->getDiagonal());
   288|         $objWriter->endElement();
   289|     }
   290|     /**
   291|      * Write Cell Style Xf.
   292|      */
   293|     private function writeCellStyleXf(XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $style, Spreadsheet $spreadsheet, string $defaultAlignHash): void
   294|     {
   295|         $objWriter->startElement('xf');
   296|         $objWriter->writeAttribute('xfId', '0');
   297|         $objWriter->writeAttribute('fontId', (string) (int) $this->getParentWriter()->getFontHashTable()->getIndexForHashCode($style->getFont()->getHashCode()));
   298|         if ($style->getQuotePrefix()) {
   299|             $objWriter->writeAttribute('quotePrefix', '1');
   300|         }
   301|         if ($style->getNumberFormat()->getBuiltInFormatCode() === false) {
   302|             $objWriter->writeAttribute('numFmtId', (string) (int) ($this->getParentWriter()->getNumFmtHashTable()->getIndexForHashCode($style->getNumberFormat()->getHashCode()) + 164));
   303|         } else {
   304|             $objWriter->writeAttribute('numFmtId', (string) (int) $style->getNumberFormat()->getBuiltInFormatCode());
   305|         }
   306|         $objWriter->writeAttribute('fillId', (string) (int) $this->getParentWriter()->getFillHashTable()->getIndexForHashCode($style->getFill()->getHashCode()));
   307|         $objWriter->writeAttribute('borderId', (string) (int) $this->getParentWriter()->getBordersHashTable()->getIndexForHashCode($style->getBorders()->getHashCode()));
   308|         $objWriter->writeAttribute('applyFont', ($spreadsheet->getDefaultStyle()->getFont()->getHashCode() != $style->getFont()->getHashCode()) ? '1' : '0');
   309|         $objWriter->writeAttribute('applyNumberFormat', ($spreadsheet->getDefaultStyle()->getNumberFormat()->getHashCode() != $style->getNumberFormat()->getHashCode()) ? '1' : '0');
   310|         $objWriter->writeAttribute('applyFill', ($spreadsheet->getDefaultStyle()->getFill()->getHashCode() != $style->getFill()->getHashCode()) ? '1' : '0');
   311|         $objWriter->writeAttribute('applyBorder', ($spreadsheet->getDefaultStyle()->getBorders()->getHashCode() != $style->getBorders()->getHashCode()) ? '1' : '0');
   312|         if ($defaultAlignHash !== '' && $defaultAlignHash === $style->getAlignment()->getHashCode()) {
   313|             $applyAlignment = '0';
   314|         } else {
   315|             $applyAlignment = '1';
   316|         }
   317|         $objWriter->writeAttribute('applyAlignment', $applyAlignment);
   318|         if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT || $style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
   319|             $objWriter->writeAttribute('applyProtection', 'true');
   320|         }
   321|         if ($applyAlignment === '1') {
   322|             $objWriter->startElement('alignment');
   323|             $vertical = Alignment::VERTICAL_ALIGNMENT_FOR_XLSX[$style->getAlignment()->getVertical()] ?? '';
   324|             $horizontal = Alignment::HORIZONTAL_ALIGNMENT_FOR_XLSX[$style->getAlignment()->getHorizontal()] ?? '';
   325|             if ($horizontal !== '') {
   326|                 $objWriter->writeAttribute('horizontal', $horizontal);
   327|             }
   328|             if ($vertical !== '') {
   329|                 $objWriter->writeAttribute('vertical', $vertical);
   330|             }
   331|             if ($style->getAlignment()->getTextRotation() >= 0) {
   332|                 $textRotation = $style->getAlignment()->getTextRotation();
   333|             } else {
   334|                 $textRotation = 90 - $style->getAlignment()->getTextRotation();
   335|             }
   336|             $objWriter->writeAttribute('textRotation', (string) $textRotation);
   337|             $objWriter->writeAttribute('wrapText', ($style->getAlignment()->getWrapText() ? 'true' : 'false'));
   338|             $objWriter->writeAttribute('shrinkToFit', ($style->getAlignment()->getShrinkToFit() ? 'true' : 'false'));
   339|             if ($style->getAlignment()->getIndent() > 0) {
   340|                 $objWriter->writeAttribute('indent', (string) $style->getAlignment()->getIndent());
   341|             }
   342|             if ($style->getAlignment()->getReadOrder() > 0) {
   343|                 $objWriter->writeAttribute('readingOrder', (string) $style->getAlignment()->getReadOrder());
   344|             }
   345|             $objWriter->endElement();
   346|         }
   347|         if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT || $style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
   348|             $objWriter->startElement('protection');
   349|             if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT) {
   350|                 $objWriter->writeAttribute('locked', ($style->getProtection()->getLocked() == Protection::PROTECTION_PROTECTED ? 'true' : 'false'));
   351|             }
   352|             if ($style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
   353|                 $objWriter->writeAttribute('hidden', ($style->getProtection()->getHidden() == Protection::PROTECTION_PROTECTED ? 'true' : 'false'));
   354|             }
   355|             $objWriter->endElement();
   356|         }
   357|         $objWriter->endElement();
   358|     }
   359|     /**
   360|      * Write Cell Style Dxf.
   361|      */
   362|     private function writeCellStyleDxf(XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $style): void
   363|     {
   364|         $objWriter->startElement('dxf');
   365|         $this->writeFont($objWriter, $style->getFont());
   366|         $this->writeNumFmt($objWriter, $style->getNumberFormat());
   367|         $this->writeFill($objWriter, $style->getFill());
   368|         $this->writeBorder($objWriter, $style->getBorders());
   369|         $objWriter->endElement();
   370|     }
   371|     /**
   372|      * Write BorderPr.
   373|      *
   374|      * @param string $name Element name
   375|      */
   376|     private function writeBorderPr(XMLWriter $objWriter, string $name, Border $border): void
   377|     {
   378|         if ($border->getBorderStyle() === Border::BORDER_OMIT) {
   379|             return;
   380|         }
   381|         $objWriter->startElement($name);
   382|         if ($border->getBorderStyle() !== Border::BORDER_NONE) {
   383|             $objWriter->writeAttribute('style', $border->getBorderStyle());
   384|             if ($border->getColor()->getARGB() !== null) {
   385|                 $objWriter->startElement('color');
   386|                 $objWriter->writeAttribute('rgb', $border->getColor()->getARGB());
   387|                 $objWriter->endElement();
   388|             }
   389|         }
   390|         $objWriter->endElement();
   391|     }
   392|     /**
   393|      * Write NumberFormat.
   394|      *
   395|      * @param int $id Number Format identifier
   396|      */
   397|     private function writeNumFmt(XMLWriter $objWriter, ?NumberFormat $numberFormat, int $id = 0): void
   398|     {
   399|         $formatCode = ($numberFormat === null) ? null : $numberFormat->getFormatCode();
   400|         if ($formatCode !== null) {
   401|             $objWriter->startElement('numFmt');
   402|             $objWriter->writeAttribute('numFmtId', (string) ($id + 164));
   403|             $objWriter->writeAttribute('formatCode', $formatCode);
   404|             $objWriter->endElement();
   405|         }
   406|     }
   407|     /**
   408|      * Get an array of all styles.
   409|      *
   410|      * @return \PhpOffice\PhpSpreadsheet\Style\Style[] All styles in PhpSpreadsheet
   411|      */
   412|     public function allStyles(Spreadsheet $spreadsheet): array
   413|     {
   414|         return $spreadsheet->getCellXfCollection();
   415|     }
   416|     /**
   417|      * Get an array of all conditional styles.
   418|      *
   419|      * @return Conditional[] All conditional styles in PhpSpreadsheet
   420|      */
   421|     public function allConditionalStyles(Spreadsheet $spreadsheet): array
   422|     {
   423|         $aStyles = [];
   424|         $sheetCount = $spreadsheet->getSheetCount();
   425|         for ($i = 0; $i < $sheetCount; ++$i) {
   426|             foreach ($spreadsheet->getSheet($i)->getConditionalStylesCollection() as $conditionalStyles) {
   427|                 foreach ($conditionalStyles as $conditionalStyle) {
   428|                     $aStyles[] = $conditionalStyle;
   429|                 }
   430|             }
   431|         }
   432|         return $aStyles;
   433|     }
   434|     /**
   435|      * Get an array of all fills.
   436|      *
   437|      * @return Fill[] All fills in PhpSpreadsheet
   438|      */
   439|     public function allFills(Spreadsheet $spreadsheet): array
   440|     {
   441|         $aFills = [];
   442|         $fill0 = new Fill();
   443|         $fill0->setFillType(Fill::FILL_NONE);
   444|         $aFills[] = $fill0;
   445|         $fill1 = new Fill();
   446|         $fill1->setFillType(Fill::FILL_PATTERN_GRAY125);
   447|         $aFills[] = $fill1;
   448|         $aStyles = $this->allStyles($spreadsheet);
   449|         foreach ($aStyles as $style) {
   450|             if (!isset($aFills[$style->getFill()->getHashCode()])) {
   451|                 $aFills[$style->getFill()->getHashCode()] = $style->getFill();
   452|             }
   453|         }
   454|         return $aFills;
   455|     }
   456|     /**
   457|      * Get an array of all fonts.
   458|      *
   459|      * @return Font[] All fonts in PhpSpreadsheet
   460|      */
   461|     public function allFonts(Spreadsheet $spreadsheet): array
   462|     {
   463|         $aFonts = [];
   464|         $aStyles = $this->allStyles($spreadsheet);
   465|         foreach ($aStyles as $style) {
   466|             if (!isset($aFonts[$style->getFont()->getHashCode()])) {
   467|                 $aFonts[$style->getFont()->getHashCode()] = $style->getFont();
   468|             }
   469|         }
   470|         return $aFonts;
   471|     }
   472|     /**
   473|      * Get an array of all borders.
   474|      *
   475|      * @return Borders[] All borders in PhpSpreadsheet
   476|      */
   477|     public function allBorders(Spreadsheet $spreadsheet): array
   478|     {
   479|         $aBorders = [];
   480|         $aStyles = $this->allStyles($spreadsheet);
   481|         foreach ($aStyles as $style) {
   482|             if (!isset($aBorders[$style->getBorders()->getHashCode()])) {
   483|                 $aBorders[$style->getBorders()->getHashCode()] = $style->getBorders();
   484|             }
   485|         }
   486|         return $aBorders;
   487|     }
   488|     /**
   489|      * Get an array of all number formats.
   490|      *
   491|      * @return NumberFormat[] All number formats in PhpSpreadsheet
   492|      */
   493|     public function allNumberFormats(Spreadsheet $spreadsheet): array
   494|     {
   495|         $aNumFmts = [];
   496|         $aStyles = $this->allStyles($spreadsheet);
   497|         foreach ($aStyles as $style) {
   498|             if ($style->getNumberFormat()->getBuiltInFormatCode() === false && !isset($aNumFmts[$style->getNumberFormat()->getHashCode()])) {
   499|                 $aNumFmts[$style->getNumberFormat()->getHashCode()] = $style->getNumberFormat();
   500|             }
   501|         }
   502|         return $aNumFmts;
   503|     }
   504| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx/Workbook.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-160 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
     4| use PhpOffice\PhpSpreadsheet\Shared\Date;
     5| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     6| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     7| use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
     8| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\DefinedNames as DefinedNamesWriter;
     9| class Workbook extends WriterPart
    10| {
    11|     /**
    12|      * Write workbook to XML format.
    13|      *
    14|      * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
    15|      *
    16|      * @return string XML Output
    17|      */
    18|     public function writeWorkbook(Spreadsheet $spreadsheet, bool $recalcRequired = false): string
    19|     {
    20|         if ($this->getParentWriter()->getUseDiskCaching()) {
    21|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    22|         } else {
    23|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    24|         }
    25|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    26|         $objWriter->startElement('workbook');
    27|         $objWriter->writeAttribute('xml:space', 'preserve');
    28|         $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
    29|         $objWriter->writeAttribute('xmlns:r', Namespaces::SCHEMA_OFFICE_DOCUMENT);
    30|         $this->writeFileVersion($objWriter);
    31|         $this->writeWorkbookPr($objWriter, $spreadsheet);
    32|         $this->writeWorkbookProtection($objWriter, $spreadsheet);
    33|         if ($this->getParentWriter()->getOffice2003Compatibility() === false) {
    34|             $this->writeBookViews($objWriter, $spreadsheet);
    35|         }
    36|         $this->writeSheets($objWriter, $spreadsheet);
    37|         (new DefinedNamesWriter($objWriter, $spreadsheet))->write();
    38|         $this->writeCalcPr($objWriter, $recalcRequired);
    39|         $objWriter->endElement();
    40|         return $objWriter->getData();
    41|     }
    42|     /**
    43|      * Write file version.
    44|      */
    45|     private function writeFileVersion(XMLWriter $objWriter): void
    46|     {
    47|         $objWriter->startElement('fileVersion');
    48|         $objWriter->writeAttribute('appName', 'xl');
    49|         $objWriter->writeAttribute('lastEdited', '4');
    50|         $objWriter->writeAttribute('lowestEdited', '4');
    51|         $objWriter->writeAttribute('rupBuild', '4505');
    52|         $objWriter->endElement();
    53|     }
    54|     /**
    55|      * Write WorkbookPr.
    56|      */
    57|     private function writeWorkbookPr(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
    58|     {
    59|         $objWriter->startElement('workbookPr');
    60|         if ($spreadsheet->getExcelCalendar() === Date::CALENDAR_MAC_1904) {
    61|             $objWriter->writeAttribute('date1904', '1');
    62|         }
    63|         $objWriter->writeAttribute('codeName', 'ThisWorkbook');
    64|         $objWriter->endElement();
    65|     }
    66|     /**
    67|      * Write BookViews.
    68|      */
    69|     private function writeBookViews(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
    70|     {
    71|         $objWriter->startElement('bookViews');
    72|         $objWriter->startElement('workbookView');
    73|         $objWriter->writeAttribute('activeTab', (string) $spreadsheet->getActiveSheetIndex());
    74|         $objWriter->writeAttribute('autoFilterDateGrouping', ($spreadsheet->getAutoFilterDateGrouping() ? 'true' : 'false'));
    75|         $objWriter->writeAttribute('firstSheet', (string) $spreadsheet->getFirstSheetIndex());
    76|         $objWriter->writeAttribute('minimized', ($spreadsheet->getMinimized() ? 'true' : 'false'));
    77|         $objWriter->writeAttribute('showHorizontalScroll', ($spreadsheet->getShowHorizontalScroll() ? 'true' : 'false'));
    78|         $objWriter->writeAttribute('showSheetTabs', ($spreadsheet->getShowSheetTabs() ? 'true' : 'false'));
    79|         $objWriter->writeAttribute('showVerticalScroll', ($spreadsheet->getShowVerticalScroll() ? 'true' : 'false'));
    80|         $objWriter->writeAttribute('tabRatio', (string) $spreadsheet->getTabRatio());
    81|         $objWriter->writeAttribute('visibility', $spreadsheet->getVisibility());
    82|         $objWriter->endElement();
    83|         $objWriter->endElement();
    84|     }
    85|     /**
    86|      * Write WorkbookProtection.
    87|      */
    88|     private function writeWorkbookProtection(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
    89|     {
    90|         if ($spreadsheet->getSecurity()->isSecurityEnabled()) {
    91|             $objWriter->startElement('workbookProtection');
    92|             $objWriter->writeAttribute('lockRevision', ($spreadsheet->getSecurity()->getLockRevision() ? 'true' : 'false'));
    93|             $objWriter->writeAttribute('lockStructure', ($spreadsheet->getSecurity()->getLockStructure() ? 'true' : 'false'));
    94|             $objWriter->writeAttribute('lockWindows', ($spreadsheet->getSecurity()->getLockWindows() ? 'true' : 'false'));
    95|             if ($spreadsheet->getSecurity()->getRevisionsPassword() != '') {
    96|                 $objWriter->writeAttribute('revisionsPassword', $spreadsheet->getSecurity()->getRevisionsPassword());
    97|             }
    98|             if ($spreadsheet->getSecurity()->getWorkbookPassword() != '') {
    99|                 $objWriter->writeAttribute('workbookPassword', $spreadsheet->getSecurity()->getWorkbookPassword());
   100|             }
   101|             $objWriter->endElement();
   102|         }
   103|     }
   104|     /**
   105|      * Write calcPr.
   106|      *
   107|      * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
   108|      */
   109|     private function writeCalcPr(XMLWriter $objWriter, bool $recalcRequired = true): void
   110|     {
   111|         $objWriter->startElement('calcPr');
   112|         $objWriter->writeAttribute('calcId', '999999');
   113|         $objWriter->writeAttribute('calcMode', 'auto');
   114|         $objWriter->writeAttribute('calcCompleted', ($recalcRequired) ? '1' : '0');
   115|         $objWriter->writeAttribute('fullCalcOnLoad', ($recalcRequired) ? '0' : '1');
   116|         $objWriter->writeAttribute('forceFullCalc', ($recalcRequired) ? '0' : '1');
   117|         $objWriter->endElement();
   118|     }
   119|     /**
   120|      * Write sheets.
   121|      */
   122|     private function writeSheets(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
   123|     {
   124|         $objWriter->startElement('sheets');
   125|         $sheetCount = $spreadsheet->getSheetCount();
   126|         for ($i = 0; $i < $sheetCount; ++$i) {
   127|             $this->writeSheet(
   128|                 $objWriter,
   129|                 $spreadsheet->getSheet($i)->getTitle(),
   130|                 ($i + 1),
   131|                 ($i + 1 + 3),
   132|                 $spreadsheet->getSheet($i)->getSheetState()
   133|             );
   134|         }
   135|         $objWriter->endElement();
   136|     }
   137|     /**
   138|      * Write sheet.
   139|      *
   140|      * @param string $worksheetName Sheet name
   141|      * @param int $worksheetId Sheet id
   142|      * @param int $relId Relationship ID
   143|      * @param string $sheetState Sheet state (visible, hidden, veryHidden)
   144|      */
   145|     private function writeSheet(XMLWriter $objWriter, string $worksheetName, int $worksheetId = 1, int $relId = 1, string $sheetState = 'visible'): void
   146|     {
   147|         if ($worksheetName != '') {
   148|             $objWriter->startElement('sheet');
   149|             $objWriter->writeAttribute('name', $worksheetName);
   150|             $objWriter->writeAttribute('sheetId', (string) $worksheetId);
   151|             if ($sheetState !== 'visible' && $sheetState != '') {
   152|                 $objWriter->writeAttribute('state', $sheetState);
   153|             }
   154|             $objWriter->writeAttribute('r:id', 'rId' . $relId);
   155|             $objWriter->endElement();
   156|         } else {
   157|             throw new WriterException('Invalid parameters passed.');
   158|         }
   159|     }
   160| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx/Worksheet.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1313 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
     4| use PhpOffice\PhpSpreadsheet\Cell\Cell;
     5| use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
     6| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
     7| use PhpOffice\PhpSpreadsheet\RichText\RichText;
     8| use PhpOffice\PhpSpreadsheet\Settings;
     9| use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
    10| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
    11| use PhpOffice\PhpSpreadsheet\Style\Conditional;
    12| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalColorScale;
    13| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalDataBar;
    14| use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormattingRuleExtension;
    15| use PhpOffice\PhpSpreadsheet\Worksheet\RowDimension;
    16| use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
    17| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet as PhpspreadsheetWorksheet;
    18| class Worksheet extends WriterPart
    19| {
    20|     private string $numberStoredAsText = '';
    21|     private string $formula = '';
    22|     private string $twoDigitTextYear = '';
    23|     private string $evalError = '';
    24|     private bool $explicitStyle0;
    25|     /**
    26|      * Write worksheet to XML format.
    27|      *
    28|      * @param string[] $stringTable
    29|      * @param bool $includeCharts Flag indicating if we should write charts
    30|      *
    31|      * @return string XML Output
    32|      */
    33|     public function writeWorksheet(PhpspreadsheetWorksheet $worksheet, array $stringTable = [], bool $includeCharts = false): string
    34|     {
    35|         $this->explicitStyle0 = $this->getParentWriter()->getExplicitStyle0();
    36|         $this->numberStoredAsText = '';
    37|         $this->formula = '';
    38|         $this->twoDigitTextYear = '';
    39|         $this->evalError = '';
    40|         $objWriter = null;
    41|         if ($this->getParentWriter()->getUseDiskCaching()) {
    42|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    43|         } else {
    44|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    45|         }
    46|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    47|         $objWriter->startElement('worksheet');
    48|         $objWriter->writeAttribute('xml:space', 'preserve');
    49|         $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
    50|         $objWriter->writeAttribute('xmlns:r', Namespaces::SCHEMA_OFFICE_DOCUMENT);
    51|         $objWriter->writeAttribute('xmlns:xdr', Namespaces::SPREADSHEET_DRAWING);
    52|         $objWriter->writeAttribute('xmlns:x14', Namespaces::DATA_VALIDATIONS1);
    53|         $objWriter->writeAttribute('xmlns:xm', Namespaces::DATA_VALIDATIONS2);
    54|         $objWriter->writeAttribute('xmlns:mc', Namespaces::COMPATIBILITY);
    55|         $objWriter->writeAttribute('mc:Ignorable', 'x14ac');
    56|         $objWriter->writeAttribute('xmlns:x14ac', Namespaces::SPREADSHEETML_AC);
    57|         $this->writeSheetPr($objWriter, $worksheet);
    58|         $this->writeDimension($objWriter, $worksheet);
    59|         $this->writeSheetViews($objWriter, $worksheet);
    60|         $this->writeSheetFormatPr($objWriter, $worksheet);
    61|         $this->writeCols($objWriter, $worksheet);
    62|         $this->writeSheetData($objWriter, $worksheet, $stringTable);
    63|         $this->writeSheetProtection($objWriter, $worksheet);
    64|         $this->writeProtectedRanges($objWriter, $worksheet);
    65|         $this->writeAutoFilter($objWriter, $worksheet);
    66|         $this->writeMergeCells($objWriter, $worksheet);
    67|         $this->writeConditionalFormatting($objWriter, $worksheet);
    68|         $this->writeDataValidations($objWriter, $worksheet);
    69|         $this->writeHyperlinks($objWriter, $worksheet);
    70|         $this->writePrintOptions($objWriter, $worksheet);
    71|         $this->writePageMargins($objWriter, $worksheet);
    72|         $this->writePageSetup($objWriter, $worksheet);
    73|         $this->writeHeaderFooter($objWriter, $worksheet);
    74|         $this->writeBreaks($objWriter, $worksheet);
    75|         $this->writeDrawings($objWriter, $worksheet, $includeCharts);
    76|         $this->writeLegacyDrawing($objWriter, $worksheet);
    77|         $this->writeLegacyDrawingHF($objWriter, $worksheet);
    78|         $this->writeAlternateContent($objWriter, $worksheet);
    79|         $this->writeIgnoredErrors($objWriter);
    80|         $this->writeBackgroundImage($objWriter, $worksheet);
    81|         $this->writeTable($objWriter, $worksheet);
    82|         $this->writeExtLst($objWriter, $worksheet);
    83|         $objWriter->endElement();
    84|         return $objWriter->getData();
    85|     }
    86|     private function writeIgnoredError(XMLWriter $objWriter, bool &$started, string $attr, string $cells): void
    87|     {
    88|         if ($cells !== '') {
    89|             if (!$started) {
    90|                 $objWriter->startElement('ignoredErrors');
    91|                 $started = true;
    92|             }
    93|             $objWriter->startElement('ignoredError');
    94|             $objWriter->writeAttribute('sqref', substr($cells, 1));
    95|             $objWriter->writeAttribute($attr, '1');
    96|             $objWriter->endElement();
    97|         }
    98|     }
    99|     private function writeIgnoredErrors(XMLWriter $objWriter): void
   100|     {
   101|         $started = false;
   102|         $this->writeIgnoredError($objWriter, $started, 'numberStoredAsText', $this->numberStoredAsText);
   103|         $this->writeIgnoredError($objWriter, $started, 'formula', $this->formula);
   104|         $this->writeIgnoredError($objWriter, $started, 'twoDigitTextYear', $this->twoDigitTextYear);
   105|         $this->writeIgnoredError($objWriter, $started, 'evalError', $this->evalError);
   106|         if ($started) {
   107|             $objWriter->endElement();
   108|         }
   109|     }
   110|     /**
   111|      * Write SheetPr.
   112|      */
   113|     private function writeSheetPr(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   114|     {
   115|         $objWriter->startElement('sheetPr');
   116|         if ($worksheet->getParentOrThrow()->hasMacros()) {
   117|             if (!$worksheet->hasCodeName()) {
   118|                 $worksheet->setCodeName($worksheet->getTitle());
   119|             }
   120|             self::writeAttributeNotNull($objWriter, 'codeName', $worksheet->getCodeName());
   121|         }
   122|         $autoFilterRange = $worksheet->getAutoFilter()->getRange();
   123|         if (!empty($autoFilterRange)) {
   124|             $objWriter->writeAttribute('filterMode', '1');
   125|             if (!$worksheet->getAutoFilter()->getEvaluated()) {
   126|                 $worksheet->getAutoFilter()->showHideRows();
   127|             }
   128|         }
   129|         $tables = $worksheet->getTableCollection();
   130|         if (count($tables)) {
   131|             foreach ($tables as $table) {
   132|                 if (!$table->getAutoFilter()->getEvaluated()) {
   133|                     $table->getAutoFilter()->showHideRows();
   134|                 }
   135|             }
   136|         }
   137|         if ($worksheet->isTabColorSet()) {
   138|             $objWriter->startElement('tabColor');
   139|             $objWriter->writeAttribute('rgb', $worksheet->getTabColor()->getARGB() ?? '');
   140|             $objWriter->endElement();
   141|         }
   142|         $objWriter->startElement('outlinePr');
   143|         $objWriter->writeAttribute('summaryBelow', ($worksheet->getShowSummaryBelow() ? '1' : '0'));
   144|         $objWriter->writeAttribute('summaryRight', ($worksheet->getShowSummaryRight() ? '1' : '0'));
   145|         $objWriter->endElement();
   146|         if ($worksheet->getPageSetup()->getFitToPage()) {
   147|             $objWriter->startElement('pageSetUpPr');
   148|             $objWriter->writeAttribute('fitToPage', '1');
   149|             $objWriter->endElement();
   150|         }
   151|         $objWriter->endElement();
   152|     }
   153|     /**
   154|      * Write Dimension.
   155|      */
   156|     private function writeDimension(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   157|     {
   158|         $objWriter->startElement('dimension');
   159|         $objWriter->writeAttribute('ref', $worksheet->calculateWorksheetDimension());
   160|         $objWriter->endElement();
   161|     }
   162|     /**
   163|      * Write SheetViews.
   164|      */
   165|     private function writeSheetViews(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   166|     {
   167|         $objWriter->startElement('sheetViews');
   168|         $sheetSelected = false;
   169|         if ($this->getParentWriter()->getSpreadsheet()->getIndex($worksheet) == $this->getParentWriter()->getSpreadsheet()->getActiveSheetIndex()) {
   170|             $sheetSelected = true;
   171|         }
   172|         $objWriter->startElement('sheetView');
   173|         $objWriter->writeAttribute('tabSelected', $sheetSelected ? '1' : '0');
   174|         $objWriter->writeAttribute('workbookViewId', '0');
   175|         $zoomScale = $worksheet->getSheetView()->getZoomScale();
   176|         if ($zoomScale !== 100 && $zoomScale !== null) {
   177|             $objWriter->writeAttribute('zoomScale', (string) $zoomScale);
   178|         }
   179|         $zoomScale = $worksheet->getSheetView()->getZoomScaleNormal();
   180|         if ($zoomScale !== 100 && $zoomScale !== null) {
   181|             $objWriter->writeAttribute('zoomScaleNormal', (string) $zoomScale);
   182|         }
   183|         $zoomScale = $worksheet->getSheetView()->getZoomScalePageLayoutView();
   184|         if ($zoomScale !== 100) {
   185|             $objWriter->writeAttribute('zoomScalePageLayoutView', (string) $zoomScale);
   186|         }
   187|         $zoomScale = $worksheet->getSheetView()->getZoomScaleSheetLayoutView();
   188|         if ($zoomScale !== 100) {
   189|             $objWriter->writeAttribute('zoomScaleSheetLayoutView', (string) $zoomScale);
   190|         }
   191|         if ($worksheet->getSheetView()->getShowZeros() === false) {
   192|             $objWriter->writeAttribute('showZeros', '0');
   193|         }
   194|         if ($worksheet->getSheetView()->getView() !== SheetView::SHEETVIEW_NORMAL) {
   195|             $objWriter->writeAttribute('view', $worksheet->getSheetView()->getView());
   196|         }
   197|         if ($worksheet->getShowGridlines()) {
   198|             $objWriter->writeAttribute('showGridLines', 'true');
   199|         } else {
   200|             $objWriter->writeAttribute('showGridLines', 'false');
   201|         }
   202|         if ($worksheet->getShowRowColHeaders()) {
   203|             $objWriter->writeAttribute('showRowColHeaders', '1');
   204|         } else {
   205|             $objWriter->writeAttribute('showRowColHeaders', '0');
   206|         }
   207|         if ($worksheet->getRightToLeft()) {
   208|             $objWriter->writeAttribute('rightToLeft', 'true');
   209|         }
   210|         $topLeftCell = $worksheet->getTopLeftCell();
   211|         if (!empty($topLeftCell) && $worksheet->getPaneState() !== PhpspreadsheetWorksheet::PANE_FROZEN && $worksheet->getPaneState() !== PhpspreadsheetWorksheet::PANE_FROZENSPLIT) {
   212|             $objWriter->writeAttribute('topLeftCell', $topLeftCell);
   213|         }
   214|         $activeCell = $worksheet->getActiveCell();
   215|         $sqref = $worksheet->getSelectedCells();
   216|         if ($worksheet->usesPanes()) {
   217|             $objWriter->startElement('pane');
   218|             $xSplit = $worksheet->getXSplit();
   219|             $ySplit = $worksheet->getYSplit();
   220|             $pane = $worksheet->getActivePane();
   221|             $paneTopLeftCell = $worksheet->getPaneTopLeftCell();
   222|             $paneState = $worksheet->getPaneState();
   223|             $normalFreeze = '';
   224|             if ($paneState === PhpspreadsheetWorksheet::PANE_FROZEN) {
   225|                 if ($ySplit > 0) {
   226|                     $normalFreeze = ($xSplit <= 0) ? 'bottomLeft' : 'bottomRight';
   227|                 } else {
   228|                     $normalFreeze = 'topRight';
   229|                 }
   230|             }
   231|             if ($xSplit > 0) {
   232|                 $objWriter->writeAttribute('xSplit', "$xSplit");
   233|             }
   234|             if ($ySplit > 0) {
   235|                 $objWriter->writeAttribute('ySplit', "$ySplit");
   236|             }
   237|             if ($normalFreeze !== '') {
   238|                 $objWriter->writeAttribute('activePane', $normalFreeze);
   239|             } elseif ($pane !== '') {
   240|                 $objWriter->writeAttribute('activePane', $pane);
   241|             }
   242|             if ($paneState !== '') {
   243|                 $objWriter->writeAttribute('state', $paneState);
   244|             }
   245|             if ($paneTopLeftCell !== '') {
   246|                 $objWriter->writeAttribute('topLeftCell', $paneTopLeftCell);
   247|             }
   248|             $objWriter->endElement(); // pane
   249|             if ($normalFreeze !== '') {
   250|                 $objWriter->startElement('selection');
   251|                 $objWriter->writeAttribute('pane', $normalFreeze);
   252|                 if ($activeCell !== '') {
   253|                     $objWriter->writeAttribute('activeCell', $activeCell);
   254|                 }
   255|                 if ($sqref !== '') {
   256|                     $objWriter->writeAttribute('sqref', $sqref);
   257|                 }
   258|                 $objWriter->endElement(); // selection
   259|                 $sqref = $activeCell = '';
   260|             } else {
   261|                 foreach ($worksheet->getPanes() as $panex) {
   262|                     if ($panex !== null) {
   263|                         $sqref = $activeCell = '';
   264|                         $objWriter->startElement('selection');
   265|                         $objWriter->writeAttribute('pane', $panex->getPosition());
   266|                         $activeCellPane = $panex->getActiveCell();
   267|                         if ($activeCellPane !== '') {
   268|                             $objWriter->writeAttribute('activeCell', $activeCellPane);
   269|                         }
   270|                         $sqrefPane = $panex->getSqref();
   271|                         if ($sqrefPane !== '') {
   272|                             $objWriter->writeAttribute('sqref', $sqrefPane);
   273|                         }
   274|                         $objWriter->endElement(); // selection
   275|                     }
   276|                 }
   277|             }
   278|         }
   279|         if (!empty($sqref) || !empty($activeCell)) {
   280|             $objWriter->startElement('selection');
   281|             if (!empty($activeCell)) {
   282|                 $objWriter->writeAttribute('activeCell', $activeCell);
   283|             }
   284|             if (!empty($sqref)) {
   285|                 $objWriter->writeAttribute('sqref', $sqref);
   286|             }
   287|             $objWriter->endElement(); // selection
   288|         }
   289|         $objWriter->endElement();
   290|         $objWriter->endElement();
   291|     }
   292|     /**
   293|      * Write SheetFormatPr.
   294|      */
   295|     private function writeSheetFormatPr(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   296|     {
   297|         $objWriter->startElement('sheetFormatPr');
   298|         if ($worksheet->getDefaultRowDimension()->getRowHeight() >= 0) {
   299|             $objWriter->writeAttribute('customHeight', 'true');
   300|             $objWriter->writeAttribute('defaultRowHeight', StringHelper::formatNumber($worksheet->getDefaultRowDimension()->getRowHeight()));
   301|         } else {
   302|             $objWriter->writeAttribute('defaultRowHeight', '14.4');
   303|         }
   304|         if ($worksheet->getDefaultRowDimension()->getZeroHeight()) {
   305|             $objWriter->writeAttribute('zeroHeight', '1');
   306|         }
   307|         if ($worksheet->getDefaultColumnDimension()->getWidth() >= 0) {
   308|             $objWriter->writeAttribute('defaultColWidth', StringHelper::formatNumber($worksheet->getDefaultColumnDimension()->getWidth()));
   309|         }
   310|         $outlineLevelRow = 0;
   311|         foreach ($worksheet->getRowDimensions() as $dimension) {
   312|             if ($dimension->getOutlineLevel() > $outlineLevelRow) {
   313|                 $outlineLevelRow = $dimension->getOutlineLevel();
   314|             }
   315|         }
   316|         $objWriter->writeAttribute('outlineLevelRow', (string) (int) $outlineLevelRow);
   317|         $outlineLevelCol = 0;
   318|         foreach ($worksheet->getColumnDimensions() as $dimension) {
   319|             if ($dimension->getOutlineLevel() > $outlineLevelCol) {
   320|                 $outlineLevelCol = $dimension->getOutlineLevel();
   321|             }
   322|         }
   323|         $objWriter->writeAttribute('outlineLevelCol', (string) (int) $outlineLevelCol);
   324|         $objWriter->endElement();
   325|     }
   326|     /**
   327|      * Write Cols.
   328|      */
   329|     private function writeCols(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   330|     {
   331|         if (count($worksheet->getColumnDimensions()) > 0) {
   332|             $objWriter->startElement('cols');
   333|             $worksheet->calculateColumnWidths();
   334|             foreach ($worksheet->getColumnDimensions() as $colDimension) {
   335|                 $objWriter->startElement('col');
   336|                 $objWriter->writeAttribute('min', (string) Coordinate::columnIndexFromString($colDimension->getColumnIndex()));
   337|                 $objWriter->writeAttribute('max', (string) Coordinate::columnIndexFromString($colDimension->getColumnIndex()));
   338|                 if ($colDimension->getWidth() < 0) {
   339|                     $objWriter->writeAttribute('width', '9.10');
   340|                 } else {
   341|                     $objWriter->writeAttribute('width', StringHelper::formatNumber($colDimension->getWidth()));
   342|                 }
   343|                 if ($colDimension->getVisible() === false) {
   344|                     $objWriter->writeAttribute('hidden', 'true');
   345|                 }
   346|                 if ($colDimension->getAutoSize()) {
   347|                     $objWriter->writeAttribute('bestFit', 'true');
   348|                 }
   349|                 if ($colDimension->getWidth() != $worksheet->getDefaultColumnDimension()->getWidth()) {
   350|                     $objWriter->writeAttribute('customWidth', 'true');
   351|                 }
   352|                 if ($colDimension->getCollapsed() === true) {
   353|                     $objWriter->writeAttribute('collapsed', 'true');
   354|                 }
   355|                 if ($colDimension->getOutlineLevel() > 0) {
   356|                     $objWriter->writeAttribute('outlineLevel', (string) $colDimension->getOutlineLevel());
   357|                 }
   358|                 $objWriter->writeAttribute('style', (string) $colDimension->getXfIndex());
   359|                 $objWriter->endElement();
   360|             }
   361|             $objWriter->endElement();
   362|         }
   363|     }
   364|     /**
   365|      * Write SheetProtection.
   366|      */
   367|     private function writeSheetProtection(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   368|     {
   369|         $protection = $worksheet->getProtection();
   370|         if (!$protection->isProtectionEnabled()) {
   371|             return;
   372|         }
   373|         $objWriter->startElement('sheetProtection');
   374|         if ($protection->getAlgorithm()) {
   375|             $objWriter->writeAttribute('algorithmName', $protection->getAlgorithm());
   376|             $objWriter->writeAttribute('hashValue', $protection->getPassword());
   377|             $objWriter->writeAttribute('saltValue', $protection->getSalt());
   378|             $objWriter->writeAttribute('spinCount', (string) $protection->getSpinCount());
   379|         } elseif ($protection->getPassword() !== '') {
   380|             $objWriter->writeAttribute('password', $protection->getPassword());
   381|         }
   382|         self::writeProtectionAttribute($objWriter, 'sheet', $protection->getSheet());
   383|         self::writeProtectionAttribute($objWriter, 'objects', $protection->getObjects());
   384|         self::writeProtectionAttribute($objWriter, 'scenarios', $protection->getScenarios());
   385|         self::writeProtectionAttribute($objWriter, 'formatCells', $protection->getFormatCells());
   386|         self::writeProtectionAttribute($objWriter, 'formatColumns', $protection->getFormatColumns());
   387|         self::writeProtectionAttribute($objWriter, 'formatRows', $protection->getFormatRows());
   388|         self::writeProtectionAttribute($objWriter, 'insertColumns', $protection->getInsertColumns());
   389|         self::writeProtectionAttribute($objWriter, 'insertRows', $protection->getInsertRows());
   390|         self::writeProtectionAttribute($objWriter, 'insertHyperlinks', $protection->getInsertHyperlinks());
   391|         self::writeProtectionAttribute($objWriter, 'deleteColumns', $protection->getDeleteColumns());
   392|         self::writeProtectionAttribute($objWriter, 'deleteRows', $protection->getDeleteRows());
   393|         self::writeProtectionAttribute($objWriter, 'sort', $protection->getSort());
   394|         self::writeProtectionAttribute($objWriter, 'autoFilter', $protection->getAutoFilter());
   395|         self::writeProtectionAttribute($objWriter, 'pivotTables', $protection->getPivotTables());
   396|         self::writeProtectionAttribute($objWriter, 'selectLockedCells', $protection->getSelectLockedCells());
   397|         self::writeProtectionAttribute($objWriter, 'selectUnlockedCells', $protection->getSelectUnlockedCells());
   398|         $objWriter->endElement();
   399|     }
   400|     private static function writeProtectionAttribute(XMLWriter $objWriter, string $name, ?bool $value): void
   401|     {
   402|         if ($value === true) {
   403|             $objWriter->writeAttribute($name, '1');
   404|         } elseif ($value === false) {
   405|             $objWriter->writeAttribute($name, '0');
   406|         }
   407|     }
   408|     private static function writeAttributeIf(XMLWriter $objWriter, ?bool $condition, string $attr, string $val): void
   409|     {
   410|         if ($condition) {
   411|             $objWriter->writeAttribute($attr, $val);
   412|         }
   413|     }
   414|     private static function writeAttributeNotNull(XMLWriter $objWriter, string $attr, ?string $val): void
   415|     {
   416|         if ($val !== null) {
   417|             $objWriter->writeAttribute($attr, $val);
   418|         }
   419|     }
   420|     private static function writeElementIf(XMLWriter $objWriter, bool $condition, string $attr, string $val): void
   421|     {
   422|         if ($condition) {
   423|             $objWriter->writeElement($attr, $val);
   424|         }
   425|     }
   426|     private static function writeOtherCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
   427|     {
   428|         $conditions = $conditional->getConditions();
   429|         if (
   430|             $conditional->getConditionType() == Conditional::CONDITION_CELLIS
   431|             || $conditional->getConditionType() == Conditional::CONDITION_EXPRESSION
   432|             || !empty($conditions)
   433|         ) {
   434|             foreach ($conditions as $formula) {
   435|                 if (is_bool($formula)) {
   436|                     $formula = $formula ? 'TRUE' : 'FALSE';
   437|                 }
   438|                 $objWriter->writeElement('formula', FunctionPrefix::addFunctionPrefix("$formula"));
   439|             }
   440|         } else {
   441|             if ($conditional->getConditionType() == Conditional::CONDITION_CONTAINSBLANKS) {
   442|                 $objWriter->writeElement('formula', 'LEN(TRIM(' . $cellCoordinate . '))=0');
   443|             } elseif ($conditional->getConditionType() == Conditional::CONDITION_NOTCONTAINSBLANKS) {
   444|                 $objWriter->writeElement('formula', 'LEN(TRIM(' . $cellCoordinate . '))>0');
   445|             } elseif ($conditional->getConditionType() == Conditional::CONDITION_CONTAINSERRORS) {
   446|                 $objWriter->writeElement('formula', 'ISERROR(' . $cellCoordinate . ')');
   447|             } elseif ($conditional->getConditionType() == Conditional::CONDITION_NOTCONTAINSERRORS) {
   448|                 $objWriter->writeElement('formula', 'NOT(ISERROR(' . $cellCoordinate . '))');
   449|             }
   450|         }
   451|     }
   452|     private static function writeTimePeriodCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
   453|     {
   454|         $txt = $conditional->getText();
   455|         if (!empty($txt)) {
   456|             $objWriter->writeAttribute('timePeriod', $txt);
   457|             if (empty($conditional->getConditions())) {
   458|                 if ($conditional->getOperatorType() == Conditional::TIMEPERIOD_TODAY) {
   459|                     $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()');
   460|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_TOMORROW) {
   461|                     $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()+1');
   462|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_YESTERDAY) {
   463|                     $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()-1');
   464|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_7_DAYS) {
   465|                     $objWriter->writeElement('formula', 'AND(TODAY()-FLOOR(' . $cellCoordinate . ',1)<=6,FLOOR(' . $cellCoordinate . ',1)<=TODAY())');
   466|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_WEEK) {
   467|                     $objWriter->writeElement('formula', 'AND(TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)<(WEEKDAY(TODAY())+7))');
   468|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_THIS_WEEK) {
   469|                     $objWriter->writeElement('formula', 'AND(TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()<=7-WEEKDAY(TODAY()))');
   470|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_NEXT_WEEK) {
   471|                     $objWriter->writeElement('formula', 'AND(ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()<(15-WEEKDAY(TODAY())))');
   472|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_MONTH) {
   473|                     $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(EDATE(TODAY(),0-1)),YEAR(' . $cellCoordinate . ')=YEAR(EDATE(TODAY(),0-1)))');
   474|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_THIS_MONTH) {
   475|                     $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(TODAY()),YEAR(' . $cellCoordinate . ')=YEAR(TODAY()))');
   476|                 } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_NEXT_MONTH) {
   477|                     $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(EDATE(TODAY(),0+1)),YEAR(' . $cellCoordinate . ')=YEAR(EDATE(TODAY(),0+1)))');
   478|                 }
   479|             } else {
   480|                 $objWriter->writeElement('formula', (string) ($conditional->getConditions()[0]));
   481|             }
   482|         }
   483|     }
   484|     private static function writeTextCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
   485|     {
   486|         $txt = $conditional->getText();
   487|         if (!empty($txt)) {
   488|             $objWriter->writeAttribute('text', $txt);
   489|             if (empty($conditional->getConditions())) {
   490|                 if ($conditional->getOperatorType() == Conditional::OPERATOR_CONTAINSTEXT) {
   491|                     $objWriter->writeElement('formula', 'NOT(ISERROR(SEARCH("' . $txt . '",' . $cellCoordinate . ')))');
   492|                 } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_BEGINSWITH) {
   493|                     $objWriter->writeElement('formula', 'LEFT(' . $cellCoordinate . ',LEN("' . $txt . '"))="' . $txt . '"');
   494|                 } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_ENDSWITH) {
   495|                     $objWriter->writeElement('formula', 'RIGHT(' . $cellCoordinate . ',LEN("' . $txt . '"))="' . $txt . '"');
   496|                 } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_NOTCONTAINS) {
   497|                     $objWriter->writeElement('formula', 'ISERROR(SEARCH("' . $txt . '",' . $cellCoordinate . '))');
   498|                 }
   499|             } else {
   500|                 $objWriter->writeElement('formula', (string) ($conditional->getConditions()[0]));
   501|             }
   502|         }
   503|     }
   504|     private static function writeExtConditionalFormattingElements(XMLWriter $objWriter, ConditionalFormattingRuleExtension $ruleExtension): void
   505|     {
   506|         $prefix = 'x14';
   507|         $objWriter->startElementNs($prefix, 'conditionalFormatting', null);
   508|         $objWriter->startElementNs($prefix, 'cfRule', null);
   509|         $objWriter->writeAttribute('type', $ruleExtension->getCfRule());
   510|         $objWriter->writeAttribute('id', $ruleExtension->getId());
   511|         $objWriter->startElementNs($prefix, 'dataBar', null);
   512|         $dataBar = $ruleExtension->getDataBarExt();
   513|         foreach ($dataBar->getXmlAttributes() as $attrKey => $val) {
   514|             $objWriter->writeAttribute($attrKey, $val);
   515|         }
   516|         $minCfvo = $dataBar->getMinimumConditionalFormatValueObject();
   517|         if ($minCfvo !== null) {
   518|             $objWriter->startElementNs($prefix, 'cfvo', null);
   519|             $objWriter->writeAttribute('type', $minCfvo->getType());
   520|             if ($minCfvo->getCellFormula()) {
   521|                 $objWriter->writeElement('xm:f', $minCfvo->getCellFormula());
   522|             }
   523|             $objWriter->endElement(); //end cfvo
   524|         }
   525|         $maxCfvo = $dataBar->getMaximumConditionalFormatValueObject();
   526|         if ($maxCfvo !== null) {
   527|             $objWriter->startElementNs($prefix, 'cfvo', null);
   528|             $objWriter->writeAttribute('type', $maxCfvo->getType());
   529|             if ($maxCfvo->getCellFormula()) {
   530|                 $objWriter->writeElement('xm:f', $maxCfvo->getCellFormula());
   531|             }
   532|             $objWriter->endElement(); //end cfvo
   533|         }
   534|         foreach ($dataBar->getXmlElements() as $elmKey => $elmAttr) {
   535|             $objWriter->startElementNs($prefix, $elmKey, null);
   536|             foreach ($elmAttr as $attrKey => $attrVal) {
   537|                 $objWriter->writeAttribute($attrKey, $attrVal);
   538|             }
   539|             $objWriter->endElement(); //end elmKey
   540|         }
   541|         $objWriter->endElement(); //end dataBar
   542|         $objWriter->endElement(); //end cfRule
   543|         $objWriter->writeElement('xm:sqref', $ruleExtension->getSqref());
   544|         $objWriter->endElement(); //end conditionalFormatting
   545|     }
   546|     private static function writeDataBarElements(XMLWriter $objWriter, ?ConditionalDataBar $dataBar): void
   547|     {
   548|         if ($dataBar) {
   549|             $objWriter->startElement('dataBar');
   550|             self::writeAttributeIf($objWriter, null !== $dataBar->getShowValue(), 'showValue', $dataBar->getShowValue() ? '1' : '0');
   551|             $minCfvo = $dataBar->getMinimumConditionalFormatValueObject();
   552|             if ($minCfvo) {
   553|                 $objWriter->startElement('cfvo');
   554|                 $objWriter->writeAttribute('type', $minCfvo->getType());
   555|                 self::writeAttributeIf($objWriter, $minCfvo->getValue() !== null, 'val', (string) $minCfvo->getValue());
   556|                 $objWriter->endElement();
   557|             }
   558|             $maxCfvo = $dataBar->getMaximumConditionalFormatValueObject();
   559|             if ($maxCfvo) {
   560|                 $objWriter->startElement('cfvo');
   561|                 $objWriter->writeAttribute('type', $maxCfvo->getType());
   562|                 self::writeAttributeIf($objWriter, $maxCfvo->getValue() !== null, 'val', (string) $maxCfvo->getValue());
   563|                 $objWriter->endElement();
   564|             }
   565|             if ($dataBar->getColor()) {
   566|                 $objWriter->startElement('color');
   567|                 $objWriter->writeAttribute('rgb', $dataBar->getColor());
   568|                 $objWriter->endElement();
   569|             }
   570|             $objWriter->endElement(); // end dataBar
   571|             if ($dataBar->getConditionalFormattingRuleExt()) {
   572|                 $objWriter->startElement('extLst');
   573|                 $extension = $dataBar->getConditionalFormattingRuleExt();
   574|                 $objWriter->startElement('ext');
   575|                 $objWriter->writeAttribute('uri', '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}');
   576|                 $objWriter->startElementNs('x14', 'id', null);
   577|                 $objWriter->text($extension->getId());
   578|                 $objWriter->endElement();
   579|                 $objWriter->endElement();
   580|                 $objWriter->endElement(); //end extLst
   581|             }
   582|         }
   583|     }
   584|     private static function writeColorScaleElements(XMLWriter $objWriter, ?ConditionalColorScale $colorScale): void
   585|     {
   586|         if ($colorScale) {
   587|             $objWriter->startElement('colorScale');
   588|             $minCfvo = $colorScale->getMinimumConditionalFormatValueObject();
   589|             $minArgb = $colorScale->getMinimumColor()?->getARGB();
   590|             $useMin = $minCfvo !== null || $minArgb !== null;
   591|             if ($useMin) {
   592|                 $objWriter->startElement('cfvo');
   593|                 $type = 'min';
   594|                 $value = null;
   595|                 if ($minCfvo !== null) {
   596|                     $typex = $minCfvo->getType();
   597|                     if ($typex === 'formula') {
   598|                         $value = $minCfvo->getCellFormula();
   599|                         if ($value !== null) {
   600|                             $type = $typex;
   601|                         }
   602|                     } else {
   603|                         $type = $typex;
   604|                         $defaults = ['number' => '0', 'percent' => '0', 'percentile' => '10'];
   605|                         $value = $minCfvo->getValue() ?? $defaults[$type] ?? null;
   606|                     }
   607|                 }
   608|                 $objWriter->writeAttribute('type', $type);
   609|                 self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
   610|                 $objWriter->endElement();
   611|             }
   612|             $midCfvo = $colorScale->getMidpointConditionalFormatValueObject();
   613|             $midArgb = $colorScale->getMidpointColor()?->getARGB();
   614|             $useMid = $midCfvo !== null || $midArgb !== null;
   615|             if ($useMid) {
   616|                 $objWriter->startElement('cfvo');
   617|                 $type = 'percentile';
   618|                 $value = '50';
   619|                 if ($midCfvo !== null) {
   620|                     $type = $midCfvo->getType();
   621|                     if ($type === 'formula') {
   622|                         $value = $midCfvo->getCellFormula();
   623|                         if ($value === null) {
   624|                             $type = 'percentile';
   625|                             $value = '50';
   626|                         }
   627|                     } else {
   628|                         $defaults = ['number' => '0', 'percent' => '50', 'percentile' => '50'];
   629|                         $value = $midCfvo->getValue() ?? $defaults[$type] ?? null;
   630|                     }
   631|                 }
   632|                 $objWriter->writeAttribute('type', $type);
   633|                 self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
   634|                 $objWriter->endElement();
   635|             }
   636|             $maxCfvo = $colorScale->getMaximumConditionalFormatValueObject();
   637|             $maxArgb = $colorScale->getMaximumColor()?->getARGB();
   638|             $useMax = $maxCfvo !== null || $maxArgb !== null;
   639|             if ($useMax) {
   640|                 $objWriter->startElement('cfvo');
   641|                 $type = 'max';
   642|                 $value = null;
   643|                 if ($maxCfvo !== null) {
   644|                     $typex = $maxCfvo->getType();
   645|                     if ($typex === 'formula') {
   646|                         $value = $maxCfvo->getCellFormula();
   647|                         if ($value !== null) {
   648|                             $type = $typex;
   649|                         }
   650|                     } else {
   651|                         $type = $typex;
   652|                         $defaults = ['number' => '0', 'percent' => '100', 'percentile' => '90'];
   653|                         $value = $maxCfvo->getValue() ?? $defaults[$type] ?? null;
   654|                     }
   655|                 }
   656|                 $objWriter->writeAttribute('type', $type);
   657|                 self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
   658|                 $objWriter->endElement();
   659|             }
   660|             if ($useMin) {
   661|                 $objWriter->startElement('color');
   662|                 self::writeAttributeIf($objWriter, $minArgb !== null, 'rgb', "$minArgb");
   663|                 $objWriter->endElement();
   664|             }
   665|             if ($useMid) {
   666|                 $objWriter->startElement('color');
   667|                 self::writeAttributeIf($objWriter, $midArgb !== null, 'rgb', "$midArgb");
   668|                 $objWriter->endElement();
   669|             }
   670|             if ($useMax) {
   671|                 $objWriter->startElement('color');
   672|                 self::writeAttributeIf($objWriter, $maxArgb !== null, 'rgb', "$maxArgb");
   673|                 $objWriter->endElement();
   674|             }
   675|             $objWriter->endElement(); // end colorScale
   676|         }
   677|     }
   678|     /**
   679|      * Write ConditionalFormatting.
   680|      */
   681|     private function writeConditionalFormatting(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   682|     {
   683|         $id = 1;
   684|         foreach ($worksheet->getConditionalStylesCollection() as $cellCoordinate => $conditionalStyles) {
   685|             $objWriter->startElement('conditionalFormatting');
   686|             $outCoordinate = Coordinate::resolveUnionAndIntersection(str_replace('$', '', $cellCoordinate), ' ');
   687|             $objWriter->writeAttribute('sqref', $outCoordinate);
   688|             foreach ($conditionalStyles as $conditional) {
   689|                 $objWriter->startElement('cfRule');
   690|                 $objWriter->writeAttribute('type', $conditional->getConditionType());
   691|                 self::writeAttributeIf(
   692|                     $objWriter,
   693|                     ($conditional->getConditionType() !== Conditional::CONDITION_COLORSCALE
   694|                         && $conditional->getConditionType() !== Conditional::CONDITION_DATABAR
   695|                         && $conditional->getNoFormatSet() === false),
   696|                     'dxfId',
   697|                     (string) $this->getParentWriter()->getStylesConditionalHashTable()->getIndexForHashCode($conditional->getHashCode())
   698|                 );
   699|                 $objWriter->writeAttribute('priority', (string) $id++);
   700|                 self::writeAttributeif(
   701|                     $objWriter,
   702|                     (
   703|                         $conditional->getConditionType() === Conditional::CONDITION_CELLIS
   704|                         || $conditional->getConditionType() === Conditional::CONDITION_CONTAINSTEXT
   705|                         || $conditional->getConditionType() === Conditional::CONDITION_NOTCONTAINSTEXT
   706|                         || $conditional->getConditionType() === Conditional::CONDITION_BEGINSWITH
   707|                         || $conditional->getConditionType() === Conditional::CONDITION_ENDSWITH
   708|                     ) && $conditional->getOperatorType() !== Conditional::OPERATOR_NONE,
   709|                     'operator',
   710|                     $conditional->getOperatorType()
   711|                 );
   712|                 self::writeAttributeIf($objWriter, $conditional->getStopIfTrue(), 'stopIfTrue', '1');
   713|                 $cellRange = Coordinate::splitRange(str_replace('$', '', strtoupper($cellCoordinate)));
   714|                 [$topLeftCell] = $cellRange[0];
   715|                 if (
   716|                     $conditional->getConditionType() === Conditional::CONDITION_CONTAINSTEXT
   717|                     || $conditional->getConditionType() === Conditional::CONDITION_NOTCONTAINSTEXT
   718|                     || $conditional->getConditionType() === Conditional::CONDITION_BEGINSWITH
   719|                     || $conditional->getConditionType() === Conditional::CONDITION_ENDSWITH
   720|                 ) {
   721|                     self::writeTextCondElements($objWriter, $conditional, $topLeftCell);
   722|                 } elseif ($conditional->getConditionType() === Conditional::CONDITION_TIMEPERIOD) {
   723|                     self::writeTimePeriodCondElements($objWriter, $conditional, $topLeftCell);
   724|                 } elseif ($conditional->getConditionType() === Conditional::CONDITION_COLORSCALE) {
   725|                     self::writeColorScaleElements($objWriter, $conditional->getColorScale());
   726|                 } else {
   727|                     self::writeOtherCondElements($objWriter, $conditional, $topLeftCell);
   728|                 }
   729|                 self::writeDataBarElements($objWriter, $conditional->getDataBar());
   730|                 $objWriter->endElement(); //end cfRule
   731|             }
   732|             $objWriter->endElement(); //end conditionalFormatting
   733|         }
   734|     }
   735|     /**
   736|      * Write DataValidations.
   737|      */
   738|     private function writeDataValidations(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   739|     {
   740|         $dataValidationCollection = $worksheet->getDataValidationCollection();
   741|         if (!empty($dataValidationCollection)) {
   742|             $dataValidationCollection = Coordinate::mergeRangesInCollection($dataValidationCollection);
   743|             $objWriter->startElement('dataValidations');
   744|             $objWriter->writeAttribute('count', (string) count($dataValidationCollection));
   745|             foreach ($dataValidationCollection as $coordinate => $dv) {
   746|                 $objWriter->startElement('dataValidation');
   747|                 if ($dv->getType() != '') {
   748|                     $objWriter->writeAttribute('type', $dv->getType());
   749|                 }
   750|                 if ($dv->getErrorStyle() != '') {
   751|                     $objWriter->writeAttribute('errorStyle', $dv->getErrorStyle());
   752|                 }
   753|                 if ($dv->getOperator() != '') {
   754|                     $objWriter->writeAttribute('operator', $dv->getOperator());
   755|                 }
   756|                 $objWriter->writeAttribute('allowBlank', ($dv->getAllowBlank() ? '1' : '0'));
   757|                 $objWriter->writeAttribute('showDropDown', (!$dv->getShowDropDown() ? '1' : '0'));
   758|                 $objWriter->writeAttribute('showInputMessage', ($dv->getShowInputMessage() ? '1' : '0'));
   759|                 $objWriter->writeAttribute('showErrorMessage', ($dv->getShowErrorMessage() ? '1' : '0'));
   760|                 if ($dv->getErrorTitle() !== '') {
   761|                     $objWriter->writeAttribute('errorTitle', $dv->getErrorTitle());
   762|                 }
   763|                 if ($dv->getError() !== '') {
   764|                     $objWriter->writeAttribute('error', $dv->getError());
   765|                 }
   766|                 if ($dv->getPromptTitle() !== '') {
   767|                     $objWriter->writeAttribute('promptTitle', $dv->getPromptTitle());
   768|                 }
   769|                 if ($dv->getPrompt() !== '') {
   770|                     $objWriter->writeAttribute('prompt', $dv->getPrompt());
   771|                 }
   772|                 $objWriter->writeAttribute('sqref', $dv->getSqref() ?? $coordinate);
   773|                 if ($dv->getFormula1() !== '') {
   774|                     $objWriter->writeElement('formula1', $dv->getFormula1());
   775|                 }
   776|                 if ($dv->getFormula2() !== '') {
   777|                     $objWriter->writeElement('formula2', $dv->getFormula2());
   778|                 }
   779|                 $objWriter->endElement();
   780|             }
   781|             $objWriter->endElement();
   782|         }
   783|     }
   784|     /**
   785|      * Write Hyperlinks.
   786|      */
   787|     private function writeHyperlinks(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   788|     {
   789|         $hyperlinkCollection = $worksheet->getHyperlinkCollection();
   790|         $relationId = 1;
   791|         if (!empty($hyperlinkCollection)) {
   792|             $objWriter->startElement('hyperlinks');
   793|             foreach ($hyperlinkCollection as $coordinate => $hyperlink) {
   794|                 $objWriter->startElement('hyperlink');
   795|                 $objWriter->writeAttribute('ref', $coordinate);
   796|                 if (!$hyperlink->isInternal()) {
   797|                     $objWriter->writeAttribute('r:id', 'rId_hyperlink_' . $relationId);
   798|                     ++$relationId;
   799|                 } else {
   800|                     $objWriter->writeAttribute('location', str_replace('sheet://', '', $hyperlink->getUrl()));
   801|                 }
   802|                 if ($hyperlink->getTooltip() !== '') {
   803|                     $objWriter->writeAttribute('tooltip', $hyperlink->getTooltip());
   804|                     $objWriter->writeAttribute('display', $hyperlink->getTooltip());
   805|                 }
   806|                 $objWriter->endElement();
   807|             }
   808|             $objWriter->endElement();
   809|         }
   810|     }
   811|     /**
   812|      * Write ProtectedRanges.
   813|      */
   814|     private function writeProtectedRanges(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   815|     {
   816|         if (count($worksheet->getProtectedCellRanges()) > 0) {
   817|             $objWriter->startElement('protectedRanges');
   818|             foreach ($worksheet->getProtectedCellRanges() as $protectedCell => $protectedRange) {
   819|                 $objWriter->startElement('protectedRange');
   820|                 $objWriter->writeAttribute('name', $protectedRange->getName());
   821|                 $objWriter->writeAttribute('sqref', $protectedCell);
   822|                 $passwordHash = $protectedRange->getPassword();
   823|                 $this->writeAttributeIf($objWriter, $passwordHash !== '', 'password', $passwordHash);
   824|                 $securityDescriptor = $protectedRange->getSecurityDescriptor();
   825|                 $this->writeAttributeIf($objWriter, $securityDescriptor !== '', 'securityDescriptor', $securityDescriptor);
   826|                 $objWriter->endElement();
   827|             }
   828|             $objWriter->endElement();
   829|         }
   830|     }
   831|     /**
   832|      * Write MergeCells.
   833|      */
   834|     private function writeMergeCells(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   835|     {
   836|         if (count($worksheet->getMergeCells()) > 0) {
   837|             $objWriter->startElement('mergeCells');
   838|             foreach ($worksheet->getMergeCells() as $mergeCell) {
   839|                 $objWriter->startElement('mergeCell');
   840|                 $objWriter->writeAttribute('ref', $mergeCell);
   841|                 $objWriter->endElement();
   842|             }
   843|             $objWriter->endElement();
   844|         }
   845|     }
   846|     /**
   847|      * Write PrintOptions.
   848|      */
   849|     private function writePrintOptions(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   850|     {
   851|         $objWriter->startElement('printOptions');
   852|         $objWriter->writeAttribute('gridLines', ($worksheet->getPrintGridlines() ? 'true' : 'false'));
   853|         $objWriter->writeAttribute('gridLinesSet', 'true');
   854|         if ($worksheet->getPageSetup()->getHorizontalCentered()) {
   855|             $objWriter->writeAttribute('horizontalCentered', 'true');
   856|         }
   857|         if ($worksheet->getPageSetup()->getVerticalCentered()) {
   858|             $objWriter->writeAttribute('verticalCentered', 'true');
   859|         }
   860|         $objWriter->endElement();
   861|     }
   862|     /**
   863|      * Write PageMargins.
   864|      */
   865|     private function writePageMargins(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   866|     {
   867|         $objWriter->startElement('pageMargins');
   868|         $objWriter->writeAttribute('left', StringHelper::formatNumber($worksheet->getPageMargins()->getLeft()));
   869|         $objWriter->writeAttribute('right', StringHelper::formatNumber($worksheet->getPageMargins()->getRight()));
   870|         $objWriter->writeAttribute('top', StringHelper::formatNumber($worksheet->getPageMargins()->getTop()));
   871|         $objWriter->writeAttribute('bottom', StringHelper::formatNumber($worksheet->getPageMargins()->getBottom()));
   872|         $objWriter->writeAttribute('header', StringHelper::formatNumber($worksheet->getPageMargins()->getHeader()));
   873|         $objWriter->writeAttribute('footer', StringHelper::formatNumber($worksheet->getPageMargins()->getFooter()));
   874|         $objWriter->endElement();
   875|     }
   876|     /**
   877|      * Write AutoFilter.
   878|      */
   879|     private function writeAutoFilter(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   880|     {
   881|         AutoFilter::writeAutoFilter($objWriter, $worksheet);
   882|     }
   883|     /**
   884|      * Write Table.
   885|      */
   886|     private function writeTable(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   887|     {
   888|         $tableCount = $worksheet->getTableCollection()->count();
   889|         if ($tableCount === 0) {
   890|             return;
   891|         }
   892|         $objWriter->startElement('tableParts');
   893|         $objWriter->writeAttribute('count', (string) $tableCount);
   894|         for ($t = 1; $t <= $tableCount; ++$t) {
   895|             $objWriter->startElement('tablePart');
   896|             $objWriter->writeAttribute('r:id', 'rId_table_' . $t);
   897|             $objWriter->endElement();
   898|         }
   899|         $objWriter->endElement();
   900|     }
   901|     /**
   902|      * Write Background Image.
   903|      */
   904|     private function writeBackgroundImage(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   905|     {
   906|         if ($worksheet->getBackgroundImage() !== '') {
   907|             $objWriter->startElement('picture');
   908|             $objWriter->writeAttribute('r:id', 'rIdBg');
   909|             $objWriter->endElement();
   910|         }
   911|     }
   912|     /**
   913|      * Write PageSetup.
   914|      */
   915|     private function writePageSetup(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   916|     {
   917|         $objWriter->startElement('pageSetup');
   918|         $objWriter->writeAttribute('paperSize', (string) $worksheet->getPageSetup()->getPaperSize());
   919|         $objWriter->writeAttribute('orientation', $worksheet->getPageSetup()->getOrientation());
   920|         if ($worksheet->getPageSetup()->getScale() !== null) {
   921|             $objWriter->writeAttribute('scale', (string) $worksheet->getPageSetup()->getScale());
   922|         }
   923|         if ($worksheet->getPageSetup()->getFitToHeight() !== null) {
   924|             $objWriter->writeAttribute('fitToHeight', (string) $worksheet->getPageSetup()->getFitToHeight());
   925|         } else {
   926|             $objWriter->writeAttribute('fitToHeight', '0');
   927|         }
   928|         if ($worksheet->getPageSetup()->getFitToWidth() !== null) {
   929|             $objWriter->writeAttribute('fitToWidth', (string) $worksheet->getPageSetup()->getFitToWidth());
   930|         } else {
   931|             $objWriter->writeAttribute('fitToWidth', '0');
   932|         }
   933|         if (!empty($worksheet->getPageSetup()->getFirstPageNumber())) {
   934|             $objWriter->writeAttribute('firstPageNumber', (string) $worksheet->getPageSetup()->getFirstPageNumber());
   935|             $objWriter->writeAttribute('useFirstPageNumber', '1');
   936|         }
   937|         $objWriter->writeAttribute('pageOrder', $worksheet->getPageSetup()->getPageOrder());
   938|         $getUnparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
   939|         if (isset($getUnparsedLoadedData['sheets'][$worksheet->getCodeName()]['pageSetupRelId'])) {
   940|             $objWriter->writeAttribute('r:id', $getUnparsedLoadedData['sheets'][$worksheet->getCodeName()]['pageSetupRelId']);
   941|         }
   942|         $objWriter->endElement();
   943|     }
   944|     /**
   945|      * Write Header / Footer.
   946|      */
   947|     private function writeHeaderFooter(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   948|     {
   949|         $headerFooter = $worksheet->getHeaderFooter();
   950|         $oddHeader = $headerFooter->getOddHeader();
   951|         $oddFooter = $headerFooter->getOddFooter();
   952|         $evenHeader = $headerFooter->getEvenHeader();
   953|         $evenFooter = $headerFooter->getEvenFooter();
   954|         $firstHeader = $headerFooter->getFirstHeader();
   955|         $firstFooter = $headerFooter->getFirstFooter();
   956|         if ("$oddHeader$oddFooter$evenHeader$evenFooter$firstHeader$firstFooter" === '') {
   957|             return;
   958|         }
   959|         $objWriter->startElement('headerFooter');
   960|         $objWriter->writeAttribute('differentOddEven', ($worksheet->getHeaderFooter()->getDifferentOddEven() ? 'true' : 'false'));
   961|         $objWriter->writeAttribute('differentFirst', ($worksheet->getHeaderFooter()->getDifferentFirst() ? 'true' : 'false'));
   962|         $objWriter->writeAttribute('scaleWithDoc', ($worksheet->getHeaderFooter()->getScaleWithDocument() ? 'true' : 'false'));
   963|         $objWriter->writeAttribute('alignWithMargins', ($worksheet->getHeaderFooter()->getAlignWithMargins() ? 'true' : 'false'));
   964|         self::writeElementIf($objWriter, $oddHeader !== '', 'oddHeader', $oddHeader);
   965|         self::writeElementIf($objWriter, $oddFooter !== '', 'oddFooter', $oddFooter);
   966|         self::writeElementIf($objWriter, $evenHeader !== '', 'evenHeader', $evenHeader);
   967|         self::writeElementIf($objWriter, $evenFooter !== '', 'evenFooter', $evenFooter);
   968|         self::writeElementIf($objWriter, $firstHeader !== '', 'firstHeader', $firstHeader);
   969|         self::writeElementIf($objWriter, $firstFooter !== '', 'firstFooter', $firstFooter);
   970|         $objWriter->endElement(); // headerFooter
   971|     }
   972|     /**
   973|      * Write Breaks.
   974|      */
   975|     private function writeBreaks(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
   976|     {
   977|         $aRowBreaks = [];
   978|         $aColumnBreaks = [];
   979|         foreach ($worksheet->getRowBreaks() as $cell => $break) {
   980|             $aRowBreaks[$cell] = $break;
   981|         }
   982|         foreach ($worksheet->getColumnBreaks() as $cell => $break) {
   983|             $aColumnBreaks[$cell] = $break;
   984|         }
   985|         if (!empty($aRowBreaks)) {
   986|             $objWriter->startElement('rowBreaks');
   987|             $objWriter->writeAttribute('count', (string) count($aRowBreaks));
   988|             $objWriter->writeAttribute('manualBreakCount', (string) count($aRowBreaks));
   989|             foreach ($aRowBreaks as $cell => $break) {
   990|                 $coords = Coordinate::coordinateFromString($cell);
   991|                 $objWriter->startElement('brk');
   992|                 $objWriter->writeAttribute('id', $coords[1]);
   993|                 $objWriter->writeAttribute('man', '1');
   994|                 $rowBreakMax = $break->getMaxColOrRow();
   995|                 if ($rowBreakMax >= 0) {
   996|                     $objWriter->writeAttribute('max', "$rowBreakMax");
   997|                 }
   998|                 $objWriter->endElement();
   999|             }
  1000|             $objWriter->endElement();
  1001|         }
  1002|         if (!empty($aColumnBreaks)) {
  1003|             $objWriter->startElement('colBreaks');
  1004|             $objWriter->writeAttribute('count', (string) count($aColumnBreaks));
  1005|             $objWriter->writeAttribute('manualBreakCount', (string) count($aColumnBreaks));
  1006|             foreach ($aColumnBreaks as $cell => $break) {
  1007|                 $coords = Coordinate::indexesFromString($cell);
  1008|                 $objWriter->startElement('brk');
  1009|                 $objWriter->writeAttribute('id', (string) ((int) $coords[0] - 1));
  1010|                 $objWriter->writeAttribute('man', '1');
  1011|                 $objWriter->endElement();
  1012|             }
  1013|             $objWriter->endElement();
  1014|         }
  1015|     }
  1016|     /**
  1017|      * Write SheetData.
  1018|      *
  1019|      * @param string[] $stringTable String table
  1020|      */
  1021|     private function writeSheetData(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, array $stringTable): void
  1022|     {
  1023|         $aFlippedStringTable = $this->getParentWriter()->getWriterPartstringtable()->flipStringTable($stringTable);
  1024|         $objWriter->startElement('sheetData');
  1025|         $colCount = Coordinate::columnIndexFromString($worksheet->getHighestColumn());
  1026|         $highestRow = $worksheet->getHighestRow();
  1027|         /** @var array<int, string> $cellsByRow */
  1028|         $cellsByRow = [];
  1029|         foreach ($worksheet->getCoordinates() as $coordinate) {
  1030|             [$column, $row] = Coordinate::coordinateFromString($coordinate);
  1031|             $cellsByRow[$row] = $cellsByRow[$row] ?? '';
  1032|             $cellsByRow[$row] .= "{$column},";
  1033|         }
  1034|         $currentRow = 0;
  1035|         $emptyDimension = new RowDimension();
  1036|         while ($currentRow++ < $highestRow) {
  1037|             $isRowSet = isset($cellsByRow[$currentRow]);
  1038|             if ($isRowSet || $worksheet->rowDimensionExists($currentRow)) {
  1039|                 $rowDimension = $worksheet->rowDimensionExists($currentRow) ? $worksheet->getRowDimension($currentRow) : $emptyDimension;
  1040|                 $writeCurrentRow = $isRowSet || $rowDimension->getRowHeight() >= 0 || $rowDimension->getVisible() === false || $rowDimension->getCollapsed() === true || $rowDimension->getOutlineLevel() > 0 || $rowDimension->getXfIndex() !== null;
  1041|                 if ($writeCurrentRow) {
  1042|                     $objWriter->startElement('row');
  1043|                     $objWriter->writeAttribute('r', "$currentRow");
  1044|                     $objWriter->writeAttribute('spans', '1:' . $colCount);
  1045|                     if ($rowDimension->getRowHeight() >= 0) {
  1046|                         $objWriter->writeAttribute('customHeight', '1');
  1047|                         $objWriter->writeAttribute('ht', StringHelper::formatNumber($rowDimension->getRowHeight()));
  1048|                     }
  1049|                     if (!$rowDimension->getVisible() === true) {
  1050|                         $objWriter->writeAttribute('hidden', 'true');
  1051|                     }
  1052|                     if ($rowDimension->getCollapsed() === true) {
  1053|                         $objWriter->writeAttribute('collapsed', 'true');
  1054|                     }
  1055|                     if ($rowDimension->getOutlineLevel() > 0) {
  1056|                         $objWriter->writeAttribute('outlineLevel', (string) $rowDimension->getOutlineLevel());
  1057|                     }
  1058|                     if ($rowDimension->getXfIndex() !== null) {
  1059|                         $objWriter->writeAttribute('s', (string) $rowDimension->getXfIndex());
  1060|                         $objWriter->writeAttribute('customFormat', '1');
  1061|                     }
  1062|                     if (isset($cellsByRow[$currentRow])) {
  1063|                         $columnsInRow = explode(',', $cellsByRow[$currentRow]);
  1064|                         array_pop($columnsInRow);
  1065|                         foreach ($columnsInRow as $column) {
  1066|                             $coord = "$column$currentRow";
  1067|                             if ($worksheet->getCell($coord)->getIgnoredErrors()->getNumberStoredAsText()) {
  1068|                                 $this->numberStoredAsText .= " $coord";
  1069|                             }
  1070|                             if ($worksheet->getCell($coord)->getIgnoredErrors()->getFormula()) {
  1071|                                 $this->formula .= " $coord";
  1072|                             }
  1073|                             if ($worksheet->getCell($coord)->getIgnoredErrors()->getTwoDigitTextYear()) {
  1074|                                 $this->twoDigitTextYear .= " $coord";
  1075|                             }
  1076|                             if ($worksheet->getCell($coord)->getIgnoredErrors()->getEvalError()) {
  1077|                                 $this->evalError .= " $coord";
  1078|                             }
  1079|                             $this->writeCell($objWriter, $worksheet, $coord, $aFlippedStringTable);
  1080|                         }
  1081|                     }
  1082|                     $objWriter->endElement();
  1083|                 }
  1084|             }
  1085|         }
  1086|         $objWriter->endElement();
  1087|     }
  1088|     private function writeCellInlineStr(XMLWriter $objWriter, string $mappedType, RichText|string $cellValue): void
  1089|     {
  1090|         $objWriter->writeAttribute('t', $mappedType);
  1091|         if (!$cellValue instanceof RichText) {
  1092|             $objWriter->startElement('is');
  1093|             $objWriter->writeElement(
  1094|                 't',
  1095|                 StringHelper::controlCharacterPHP2OOXML(htmlspecialchars($cellValue, Settings::htmlEntityFlags()))
  1096|             );
  1097|             $objWriter->endElement();
  1098|         } else {
  1099|             $objWriter->startElement('is');
  1100|             $this->getParentWriter()->getWriterPartstringtable()->writeRichText($objWriter, $cellValue);
  1101|             $objWriter->endElement();
  1102|         }
  1103|     }
  1104|     /**
  1105|      * @param string[] $flippedStringTable
  1106|      */
  1107|     private function writeCellString(XMLWriter $objWriter, string $mappedType, RichText|string $cellValue, array $flippedStringTable): void
  1108|     {
  1109|         $objWriter->writeAttribute('t', $mappedType);
  1110|         if (!$cellValue instanceof RichText) {
  1111|             self::writeElementIf($objWriter, isset($flippedStringTable[$cellValue]), 'v', $flippedStringTable[$cellValue] ?? '');
  1112|         } else {
  1113|             $objWriter->writeElement('v', $flippedStringTable[$cellValue->getHashCode()]);
  1114|         }
  1115|     }
  1116|     private function writeCellNumeric(XMLWriter $objWriter, float|int $cellValue): void
  1117|     {
  1118|         if (is_float($cellValue)) {
  1119|             $cellValue = str_replace(',', '.', (string) $cellValue);
  1120|             if (!str_contains($cellValue, '.')) {
  1121|                 $cellValue = $cellValue . '.0';
  1122|             }
  1123|         }
  1124|         $objWriter->writeElement('v', "$cellValue");
  1125|     }
  1126|     private function writeCellBoolean(XMLWriter $objWriter, string $mappedType, bool $cellValue): void
  1127|     {
  1128|         $objWriter->writeAttribute('t', $mappedType);
  1129|         $objWriter->writeElement('v', $cellValue ? '1' : '0');
  1130|     }
  1131|     private function writeCellError(XMLWriter $objWriter, string $mappedType, string $cellValue, string $formulaerr = '#NULL!'): void
  1132|     {
  1133|         $objWriter->writeAttribute('t', $mappedType);
  1134|         $cellIsFormula = str_starts_with($cellValue, '=');
  1135|         self::writeElementIf($objWriter, $cellIsFormula, 'f', FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
  1136|         $objWriter->writeElement('v', $cellIsFormula ? $formulaerr : $cellValue);
  1137|     }
  1138|     private function writeCellFormula(XMLWriter $objWriter, string $cellValue, Cell $cell): void
  1139|     {
  1140|         $calculatedValue = $this->getParentWriter()->getPreCalculateFormulas() ? $cell->getCalculatedValue() : $cellValue;
  1141|         $calculatedValueString = $this->getParentWriter()->getPreCalculateFormulas() ? $cell->getCalculatedValueString() : $cellValue;
  1142|         if (is_string($calculatedValue)) {
  1143|             if (ErrorValue::isError($calculatedValue)) {
  1144|                 $this->writeCellError($objWriter, 'e', $cellValue, $calculatedValue);
  1145|                 return;
  1146|             }
  1147|             $objWriter->writeAttribute('t', 'str');
  1148|             $calculatedValue = StringHelper::controlCharacterPHP2OOXML($calculatedValue);
  1149|             $calculatedValueString = $calculatedValue;
  1150|         } elseif (is_bool($calculatedValue)) {
  1151|             $objWriter->writeAttribute('t', 'b');
  1152|             $calculatedValue = (int) $calculatedValue;
  1153|             $calculatedValueString = (string) $calculatedValue;
  1154|         }
  1155|         $attributes = $cell->getFormulaAttributes();
  1156|         if (is_array($attributes) && ($attributes['t'] ?? null) === 'array') {
  1157|             $objWriter->startElement('f');
  1158|             $objWriter->writeAttribute('t', 'array');
  1159|             $objWriter->writeAttribute('ref', $cell->getCoordinate());
  1160|             $objWriter->writeAttribute('aca', '1');
  1161|             $objWriter->writeAttribute('ca', '1');
  1162|             $objWriter->text(FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
  1163|             $objWriter->endElement();
  1164|         } else {
  1165|             $objWriter->writeElement('f', FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
  1166|             self::writeElementIf(
  1167|                 $objWriter,
  1168|                 $this->getParentWriter()->getOffice2003Compatibility() === false
  1169|                 && $this->getParentWriter()->getPreCalculateFormulas()
  1170|                 && $calculatedValue !== null,
  1171|                 'v',
  1172|                 (!is_array($calculatedValue) && !str_starts_with($calculatedValueString, '#'))
  1173|                     ? StringHelper::formatNumber($calculatedValueString) : '0'
  1174|             );
  1175|         }
  1176|     }
  1177|     /**
  1178|      * Write Cell.
  1179|      *
  1180|      * @param string $cellAddress Cell Address
  1181|      * @param string[] $flippedStringTable String table (flipped), for faster index searching
  1182|      */
  1183|     private function writeCell(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, string $cellAddress, array $flippedStringTable): void
  1184|     {
  1185|         $pCell = $worksheet->getCell($cellAddress);
  1186|         $xfi = $pCell->getXfIndex();
  1187|         $cellValue = $pCell->getValue();
  1188|         $cellValueString = $pCell->getValueString();
  1189|         $writeValue = $cellValue !== '' && $cellValue !== null;
  1190|         if (empty($xfi) && !$writeValue) {
  1191|             return;
  1192|         }
  1193|         $objWriter->startElement('c');
  1194|         $objWriter->writeAttribute('r', $cellAddress);
  1195|         if ($xfi) {
  1196|             $objWriter->writeAttribute('s', "$xfi");
  1197|         } elseif ($this->explicitStyle0) {
  1198|             $objWriter->writeAttribute('s', '0');
  1199|         }
  1200|         if ($writeValue) {
  1201|             $mappedType = $pCell->getDataType();
  1202|             switch (strtolower($mappedType)) {
  1203|                 case 'inlinestr':    // Inline string
  1204|                     /** @var RichText|string */
  1205|                     $richText = $cellValue;
  1206|                     $this->writeCellInlineStr($objWriter, $mappedType, $richText);
  1207|                     break;
  1208|                 case 's':            // String
  1209|                     $this->writeCellString($objWriter, $mappedType, ($cellValue instanceof RichText) ? $cellValue : $cellValueString, $flippedStringTable);
  1210|                     break;
  1211|                 case 'f':            // Formula
  1212|                     $this->writeCellFormula($objWriter, $cellValueString, $pCell);
  1213|                     break;
  1214|                 case 'n':            // Numeric
  1215|                     $cellValueNumeric = is_numeric($cellValue) ? ($cellValue + 0) : 0;
  1216|                     $this->writeCellNumeric($objWriter, $cellValueNumeric);
  1217|                     break;
  1218|                 case 'b':            // Boolean
  1219|                     $this->writeCellBoolean($objWriter, $mappedType, (bool) $cellValue);
  1220|                     break;
  1221|                 case 'e':            // Error
  1222|                     $this->writeCellError($objWriter, $mappedType, $cellValueString);
  1223|             }
  1224|         }
  1225|         $objWriter->endElement();
  1226|     }
  1227|     /**
  1228|      * Write Drawings.
  1229|      *
  1230|      * @param bool $includeCharts Flag indicating if we should include drawing details for charts
  1231|      */
  1232|     private function writeDrawings(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, bool $includeCharts = false): void
  1233|     {
  1234|         $unparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
  1235|         $hasUnparsedDrawing = isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds']);
  1236|         $chartCount = ($includeCharts) ? $worksheet->getChartCollection()->count() : 0;
  1237|         if ($chartCount == 0 && $worksheet->getDrawingCollection()->count() == 0 && !$hasUnparsedDrawing) {
  1238|             return;
  1239|         }
  1240|         $objWriter->startElement('drawing');
  1241|         $rId = 'rId1';
  1242|         if (isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds'])) {
  1243|             $drawingOriginalIds = $unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds'];
  1244|             $rId = reset($drawingOriginalIds);
  1245|         }
  1246|         $objWriter->writeAttribute('r:id', $rId);
  1247|         $objWriter->endElement();
  1248|     }
  1249|     /**
  1250|      * Write LegacyDrawing.
  1251|      */
  1252|     private function writeLegacyDrawing(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
  1253|     {
  1254|         $unparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
  1255|         if (count($worksheet->getComments()) > 0 || isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['legacyDrawing'])) {
  1256|             $objWriter->startElement('legacyDrawing');
  1257|             $objWriter->writeAttribute('r:id', 'rId_comments_vml1');
  1258|             $objWriter->endElement();
  1259|         }
  1260|     }
  1261|     /**
  1262|      * Write LegacyDrawingHF.
  1263|      */
  1264|     private function writeLegacyDrawingHF(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
  1265|     {
  1266|         if (count($worksheet->getHeaderFooter()->getImages()) > 0) {
  1267|             $objWriter->startElement('legacyDrawingHF');
  1268|             $objWriter->writeAttribute('r:id', 'rId_headerfooter_vml1');
  1269|             $objWriter->endElement();
  1270|         }
  1271|     }
  1272|     private function writeAlternateContent(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
  1273|     {
  1274|         if (empty($worksheet->getParentOrThrow()->getUnparsedLoadedData()['sheets'][$worksheet->getCodeName()]['AlternateContents'])) {
  1275|             return;
  1276|         }
  1277|         foreach ($worksheet->getParentOrThrow()->getUnparsedLoadedData()['sheets'][$worksheet->getCodeName()]['AlternateContents'] as $alternateContent) {
  1278|             $objWriter->writeRaw($alternateContent);
  1279|         }
  1280|     }
  1281|     /**
  1282|      * write <ExtLst>
  1283|      * only implementation conditionalFormattings.
  1284|      *
  1285|      * @url https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/07d607af-5618-4ca2-b683-6a78dc0d9627
  1286|      */
  1287|     private function writeExtLst(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
  1288|     {
  1289|         $conditionalFormattingRuleExtList = [];
  1290|         foreach ($worksheet->getConditionalStylesCollection() as $cellCoordinate => $conditionalStyles) {
  1291|             /** @var Conditional $conditional */
  1292|             foreach ($conditionalStyles as $conditional) {
  1293|                 $dataBar = $conditional->getDataBar();
  1294|                 if ($dataBar && $dataBar->getConditionalFormattingRuleExt()) {
  1295|                     $conditionalFormattingRuleExtList[] = $dataBar->getConditionalFormattingRuleExt();
  1296|                 }
  1297|             }
  1298|         }
  1299|         if (count($conditionalFormattingRuleExtList) > 0) {
  1300|             $conditionalFormattingRuleExtNsPrefix = 'x14';
  1301|             $objWriter->startElement('extLst');
  1302|             $objWriter->startElement('ext');
  1303|             $objWriter->writeAttribute('uri', '{78C0D931-6437-407d-A8EE-F0AAD7539E65}');
  1304|             $objWriter->startElementNs($conditionalFormattingRuleExtNsPrefix, 'conditionalFormattings', null);
  1305|             foreach ($conditionalFormattingRuleExtList as $extension) {
  1306|                 self::writeExtConditionalFormattingElements($objWriter, $extension);
  1307|             }
  1308|             $objWriter->endElement(); //end conditionalFormattings
  1309|             $objWriter->endElement(); //end ext
  1310|             $objWriter->endElement(); //end extLst
  1311|         }
  1312|     }
  1313| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/ZipStream3.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer;
     3| use ZipStream\ZipStream;
     4| class ZipStream3
     5| {
     6|     /**
     7|      * @param resource $fileHandle
     8|      */
     9|     public static function newZipStream($fileHandle): ZipStream
    10|     {
    11|         return new ZipStream(
    12|             enableZip64: false,
    13|             outputStream: $fileHandle,
    14|             sendHttpHeaders: false,
    15|             defaultEnableZeroHeader: false,
    16|         );
    17|     }
    18| }

