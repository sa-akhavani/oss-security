--- a/samples/Basic4/45_Quadratic_equation_solver.php
+++ b//dev/null
@@ -1,64 +0,0 @@
-<?php
-use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
-use PhpOffice\PhpSpreadsheet\Helper\Sample;
-use PhpOffice\PhpSpreadsheet\Settings;
-require __DIR__ . '/../Header.php';
-$helper = new Sample();
-if ($helper->isCli()) {
-    $helper->log('This example should only be run from a Web Browser' . PHP_EOL);
-    return;
-}
-?>
-<form action="45_Quadratic_equation_solver.php" method="POST">
-    Enter the coefficients for Ax<sup>2</sup> + Bx + C = 0
-    <table border="0" cellpadding="0" cellspacing="0">
-        <tr>
-            <td>
-                <b>A&nbsp;</b>
-            </td>
-            <td>
-                <input name="A" type="text" size="8" value="<?php echo (isset($_POST['A'])) ? htmlentities($_POST['A'], Settings::htmlEntityFlags()) : ''; ?>">
-            </td>
-        </tr>
-        <tr>
-            <td>
-                <b>B&nbsp;</b>
-            </td>
-            <td>
-                <input name="B" type="text" size="8" value="<?php echo (isset($_POST['B'])) ? htmlentities($_POST['B'], Settings::htmlEntityFlags()) : ''; ?>">
-            </td>
-        </tr>
-        <tr>
-            <td><b>C&nbsp;</b>
-            </td>
-            <td>
-                <input name="C" type="text" size="8" value="<?php echo (isset($_POST['C'])) ? htmlentities($_POST['C'], Settings::htmlEntityFlags()) : ''; ?>">
-            </td>
-        </tr>
-    </table>
-    <input name="submit" type="submit" value="calculate"><br />
-    If A=0, the equation is not quadratic.
-</form>
-<?php
-/**     If the user has submitted the form, then we need to execute a calculation * */
-if (isset($_POST['submit'])) {
-    if (!is_numeric($_POST['A']) || !is_numeric($_POST['B']) || !is_numeric($_POST['C'])) { // validate input
-        $helper->log('Non-numeric input');
-    } elseif ($_POST['A'] == 0) {
-        $helper->log('The equation is not quadratic');
-    } else {
-        $helper->log('<hr /><b>Roots:</b><br />');
-        $discriminantFormula = '=POWER(' . $_POST['B'] . ',2) - (4 * ' . $_POST['A'] . ' * ' . $_POST['C'] . ')';
-        $discriminant = Calculation::getInstance()->calculateFormula($discriminantFormula);
-        $r1Formula = '=IMDIV(IMSUM(-' . $_POST['B'] . ',IMSQRT(' . $discriminant . ')),2 * ' . $_POST['A'] . ')';
-        $r2Formula = '=IF(' . $discriminant . '=0,"Only one root",IMDIV(IMSUB(-' . $_POST['B'] . ',IMSQRT(' . $discriminant . ')),2 * ' . $_POST['A'] . '))';
-        /** @var string */
-        $output = Calculation::getInstance()->calculateFormula($r1Formula);
-        $helper->log("$output");
-        /** @var string */
-        $output = Calculation::getInstance()->calculateFormula($r2Formula);
-        $helper->log("$output");
-        $callEndTime = microtime(true);
-        $helper->logEndingNotes();
-    }
-}

--- a//dev/null
+++ b/samples/ConditionalFormatting/01_Basic_Comparisons.php
@@ -0,0 +1,165 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Literal Value Comparison')
+    ->setCellValue('A9', 'Value Comparison with Absolute Cell Reference $H$9')
+    ->setCellValue('A17', 'Value Comparison with Relative Cell References')
+    ->setCellValue('A23', 'Value Comparison with Formula based on AVERAGE() ± STDEV()')
+    ->setCellValue('A30', 'Literal String Value Comparison');
+$dataArray = [
+    [-2, -1, 0, 1, 2],
+    [-1, 0, 1, 2, 3],
+    [0, 1, 2, 3, 4],
+    [1, 2, 3, 4, 5],
+];
+$betweenDataArray = [
+    [2, 7, 6],
+    [9, 5, 1],
+    [4, 3, 8],
+];
+$stringArray = [
+    ['I'],
+    ['Love'],
+    ['PHP'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true)
+    ->fromArray($dataArray, null, 'A10', true)
+    ->fromArray($betweenDataArray, null, 'A18', true)
+    ->fromArray($dataArray, null, 'A24', true)
+    ->fromArray($stringArray, null, 'A31', true)
+    ->setCellValue('H9', 1);
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:E1')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A9:E9')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A17:E17')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A23:E23')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A30:E30')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$yellowStyle = new Style(false, true);
+$yellowStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_YELLOW);
+$yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$redStyle = new Style(false, true);
+$redStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_RED);
+$redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'A2:E5';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->equals(0)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->greaterThan(0)
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->lessThan(0)
+    ->setStyle($redStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A10:E13';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->equals('$H$9', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->greaterThan('$H$9', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->lessThan('$H$9', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($redStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A18:A20';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->between('$B1', Wizard::VALUE_TYPE_CELL)
+    ->and('$C1', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A24:E27';
+$formulaRange = implode(
+    ':',
+    array_map(
+        [Coordinate::class, 'absoluteCoordinate'],
+        Coordinate::splitRange($cellRange)[0]
+    )
+);
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->between('AVERAGE(' . $formulaRange . ')-STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
+    ->and('AVERAGE(' . $formulaRange . ')+STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->greaterThan('AVERAGE(' . $formulaRange . ')+STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->lessThan('AVERAGE(' . $formulaRange . ')-STDEV(' . $formulaRange . ')', Wizard::VALUE_TYPE_FORMULA)
+    ->setStyle($redStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A31:A33';
+$formulaRange = implode(
+    ':',
+    array_map(
+        [Coordinate::class, 'absoluteCoordinate'],
+        Coordinate::splitRange($cellRange)[0]
+    )
+);
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->equals('LOVE')
+    ->setStyle($redStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$cellWizard->equals('PHP')
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/02_Text_Comparisons.php
@@ -0,0 +1,175 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Value Begins With Literal')
+    ->setCellValue('A7', 'Value Ends With Literal')
+    ->setCellValue('A13', 'Value Contains Literal')
+    ->setCellValue('A19', "Value Doesn't Contain Literal")
+    ->setCellValue('E1', 'Value Begins With using Cell Reference')
+    ->setCellValue('E7', 'Value Ends With using Cell Reference')
+    ->setCellValue('E13', 'Value Contains using Cell Reference')
+    ->setCellValue('E19', "Value Doesn't Contain using Cell Reference")
+    ->setCellValue('A25', 'Simple Comparison using Concatenation Formula');
+$dataArray = [
+    ['HELLO', 'WORLD'],
+    ['MELLOW', 'YELLOW'],
+    ['SLEEPY', 'HOLLOW'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true)
+    ->fromArray($dataArray, null, 'A8', true)
+    ->fromArray($dataArray, null, 'A14', true)
+    ->fromArray($dataArray, null, 'A20', true)
+    ->fromArray($dataArray, null, 'E2', true)
+    ->fromArray($dataArray, null, 'E8', true)
+    ->fromArray($dataArray, null, 'E14', true)
+    ->fromArray($dataArray, null, 'E20', true)
+    ->fromArray($dataArray, null, 'A26', true)
+    ->setCellValue('D1', 'H')
+    ->setCellValue('D7', 'OW')
+    ->setCellValue('D13', 'LL')
+    ->setCellValue('D19', 'EL')
+    ->setCellValue('C26', 'HELLO WORLD')
+    ->setCellValue('C27', 'SOYLENT GREEN')
+    ->setCellValue('C28', 'SLEEPY HOLLOW');
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:G1')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A7:G7')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A13:G13')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A19:G19')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A25:C25')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$yellowStyle = new Style(false, true);
+$yellowStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_YELLOW);
+$yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$redStyle = new Style(false, true);
+$redStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_RED);
+$redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'A2:B4';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->beginsWith('H')
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'E2:F4';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->beginsWith('$D$1', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A8:B10';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->endsWith('OW')
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'E8:F10';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->endsWith('$D$7', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A14:B16';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->contains('LL')
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'E14:F16';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->contains('$D$13', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A20:B22';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->doesNotContain('EL')
+    ->setStyle($redStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'E20:F22';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\TextValue $textWizard */
+$textWizard = $wizardFactory->newRule(Wizard::TEXT_VALUE);
+$textWizard->doesNotContain('$D$19', Wizard::VALUE_TYPE_CELL)
+    ->setStyle($redStyle);
+$conditionalStyles[] = $textWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($textWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'C26:C28';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\CellValue $cellWizard */
+$cellWizard = $wizardFactory->newRule(Wizard::CELL_VALUE);
+$cellWizard->equals('CONCATENATE($A1," ",$B1)', Wizard::VALUE_TYPE_FORMULA)
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $cellWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($cellWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$spreadsheet->getActiveSheet()->getColumnDimension('C')->setAutoSize(true);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/03_Blank_Comparisons.php
@@ -0,0 +1,55 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Blank Comparison');
+$dataArray = [
+    ['HELLO', null],
+    [null, 'WORLD'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true);
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:B1')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$redStyle = new Style(false, true);
+$redStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_RED);
+$redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'A2:B3';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Blanks $blanksWizard */
+$blanksWizard = $wizardFactory->newRule(Wizard::BLANKS);
+$blanksWizard->setStyle($redStyle);
+$conditionalStyles[] = $blanksWizard->getConditional();
+$blanksWizard->notBlank()
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $blanksWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($blanksWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/04_Error_Comparisons.php
@@ -0,0 +1,58 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Error Comparison');
+$dataArray = [
+    [5, -2, '=A2/B2'],
+    [5, -1, '=A3/B3'],
+    [5, 0, '=A4/B4'],
+    [5, 1, '=A5/B5'],
+    [5, 2, '=A6/B6'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true);
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:C1')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$redStyle = new Style(false, true);
+$redStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_RED);
+$redStyle->getFont()->setColor(new Color(Color::COLOR_GREEN));
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'C2:C6';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Errors $errorsWizard */
+$errorsWizard = $wizardFactory->newRule(Wizard::ERRORS);
+$errorsWizard->setStyle($redStyle);
+$conditionalStyles[] = $errorsWizard->getConditional();
+$errorsWizard->notError()
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $errorsWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($errorsWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/05_Date_Comparisons.php
@@ -0,0 +1,128 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Alignment;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('B1', 'yesterday()')
+    ->setCellValue('C1', 'today()')
+    ->setCellValue('D1', 'tomorrow()')
+    ->setCellValue('E1', 'last7Days()')
+    ->setCellValue('F1', 'lastWeek()')
+    ->setCellValue('G1', 'thisWeek()')
+    ->setCellValue('H1', 'nextWeek()')
+    ->setCellValue('I1', 'lastMonth()')
+    ->setCellValue('J1', 'thisMonth()')
+    ->setCellValue('K1', 'nextMonth()');
+$dateFunctionArray = [
+    'yesterday()',
+    'today()',
+    'tomorrow()',
+    'last7Days()',
+    'lastWeek()',
+    'thisWeek()',
+    'nextWeek()',
+    'lastMonth()',
+    'thisMonth()',
+    'nextMonth()',
+];
+$dateTitleArray = [
+    ['First day of last month'],
+    ['Last day of last month'],
+    ['Last Monday'],
+    ['Last Friday'],
+    ['Monday last week'],
+    ['Wednesday last week'],
+    ['Friday last week'],
+    ['Yesterday'],
+    ['Today'],
+    ['Tomorrow'],
+    ['Monday this week'],
+    ['Wednesday this week'],
+    ['Friday this week'],
+    ['Monday next week'],
+    ['Wednesday next week'],
+    ['Friday next week'],
+    ['First day of next month'],
+    ['Last day of next month'],
+];
+$dataArray = [
+    ['=EOMONTH(TODAY(),-2)+1'],
+    ['=EOMONTH(TODAY(),-1)'],
+    ['=TODAY()-WEEKDAY(TODAY(),3)'],
+    ['=TODAY()-WEEKDAY(TODAY())-1'],
+    ['=2-WEEKDAY(TODAY())+TODAY()-7'],
+    ['=4-WEEKDAY(TODAY())+TODAY()-7'],
+    ['=6-WEEKDAY(TODAY())+TODAY()-7'],
+    ['=TODAY()-1'],
+    ['=TODAY()'],
+    ['=TODAY()+1'],
+    ['=2-WEEKDAY(TODAY())+TODAY()'],
+    ['=4-WEEKDAY(TODAY())+TODAY()'],
+    ['=6-WEEKDAY(TODAY())+TODAY()'],
+    ['=2-WEEKDAY(TODAY())+TODAY()+7'],
+    ['=4-WEEKDAY(TODAY())+TODAY()+7'],
+    ['=6-WEEKDAY(TODAY())+TODAY()+7'],
+    ['=EOMONTH(TODAY(),0)+1'],
+    ['=EOMONTH(TODAY(),1)'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dateFunctionArray, null, 'B1', true);
+$spreadsheet->getActiveSheet()
+    ->fromArray($dateTitleArray, null, 'A2', true);
+for ($column = 'B'; $column !== 'L'; ++$column) {
+    $spreadsheet->getActiveSheet()
+        ->fromArray($dataArray, null, "{$column}2", true);
+}
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('B1:K1')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('B1:K1')->getAlignment()->setHorizontal(Alignment::HORIZONTAL_RIGHT);
+$helper->log('Define some styles for our Conditionals');
+$yellowStyle = new Style(false, true);
+$yellowStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_YELLOW);
+$yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
+$helper->log('Define conditional formatting and set styles');
+for ($column = 'B'; $column !== 'L'; ++$column) {
+    $wizardFactory = new Wizard("{$column}2:{$column}19");
+    /** @var Wizard\DateValue $dateWizard */
+    $dateWizard = $wizardFactory->newRule(Wizard::DATES_OCCURRING);
+    $conditionalStyles = [];
+    /** @var string */
+    $cellContents = $spreadsheet->getActiveSheet()->getCell("{$column}1")->getValue();
+    $methodName = trim($cellContents, '()');
+    $dateWizard->$methodName()
+        ->setStyle($yellowStyle);
+    $conditionalStyles[] = $dateWizard->getConditional();
+    $spreadsheet->getActiveSheet()
+        ->getStyle($dateWizard->getCellRange())
+        ->setConditionalStyles($conditionalStyles);
+}
+$helper->log('Set some additional styling for date formats');
+$spreadsheet->getActiveSheet()->getStyle('B:B')->getNumberFormat()->setFormatCode('ddd dd-mmm-yyyy');
+for ($column = 'A'; $column !== 'L'; ++$column) {
+    if ($column !== 'A') {
+        $spreadsheet->getActiveSheet()->getStyle("{$column}:{$column}")
+            ->getNumberFormat()->setFormatCode('ddd dd-mmm-yyyy');
+    }
+    $spreadsheet->getActiveSheet()->getColumnDimension($column)
+        ->setAutoSize(true);
+}
+$spreadsheet->getActiveSheet()->getStyle('A:A')->getFont()->setBold(true);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/06_Duplicate_Comparisons.php
@@ -0,0 +1,64 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Duplicates Comparison');
+$dataArray = [
+    [1, 0, 3],
+    [2, 1, 1],
+    [3, 1, 4],
+    [4, 2, 1],
+    [5, 3, 5],
+    [6, 5, 9],
+    [7, 8, 2],
+    [8, 13, 6],
+    [9, 21, 5],
+    [10, 34, 3],
+    [11, 55, 5],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true);
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:C1')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$yellowStyle = new Style(false, true);
+$yellowStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_YELLOW);
+$yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'A2:C12';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Duplicates $duplicatesWizard */
+$duplicatesWizard = $wizardFactory->newRule(Wizard::DUPLICATES);
+$duplicatesWizard->setStyle($yellowStyle);
+$conditionalStyles[] = $duplicatesWizard->getConditional();
+$duplicatesWizard->unique()
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $duplicatesWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($duplicatesWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/ConditionalFormatting/07_Expression_Comparisons.php
@@ -0,0 +1,114 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+require __DIR__ . '/../Header.php';
+$helper->log('Create new Spreadsheet object');
+$spreadsheet = new Spreadsheet();
+$helper->log('Set document properties');
+$spreadsheet->getProperties()->setCreator('Mark Baker')
+    ->setLastModifiedBy('Mark Baker')
+    ->setTitle('PhpSpreadsheet Test Document')
+    ->setSubject('PhpSpreadsheet Test Document')
+    ->setDescription('Test document for PhpSpreadsheet, generated using PHP classes.')
+    ->setKeywords('office PhpSpreadsheet php')
+    ->setCategory('Test result file');
+$helper->log('Add data');
+$spreadsheet->setActiveSheetIndex(0);
+$spreadsheet->getActiveSheet()
+    ->setCellValue('A1', 'Odd/Even Expression Comparison')
+    ->setCellValue('A4', 'Note that these functions are not available for Xls files')
+    ->setCellValue('A15', 'Sales Grid Expression Comparison')
+    ->setCellValue('A25', 'Sales Grid Multiple Expression Comparison');
+$dataArray = [
+    [1, 0, 3],
+    [2, 1, 1],
+    [3, 1, 4],
+    [4, 2, 1],
+    [5, 3, 5],
+    [6, 5, 9],
+    [7, 8, 2],
+    [8, 13, 6],
+    [9, 21, 5],
+    [10, 34, 4],
+];
+$salesGrid = [
+    ['Name', 'Sales', 'Country', 'Quarter'],
+    ['Smith', 16753, 'UK', 'Q3'],
+    ['Johnson', 14808, 'USA', 'Q4'],
+    ['Williams', 10644, 'UK', 'Q2'],
+    ['Jones', 1390, 'USA', 'Q3'],
+    ['Brown', 4865, 'USA', 'Q4'],
+    ['Williams', 12438, 'UK', 'Q2'],
+];
+$spreadsheet->getActiveSheet()
+    ->fromArray($dataArray, null, 'A2', true);
+$spreadsheet->getActiveSheet()
+    ->fromArray($salesGrid, null, 'A16', true);
+$spreadsheet->getActiveSheet()
+    ->fromArray($salesGrid, null, 'A26', true);
+$helper->log('Set title row bold');
+$spreadsheet->getActiveSheet()->getStyle('A1:B1')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A15:D16')->getFont()->setBold(true);
+$spreadsheet->getActiveSheet()->getStyle('A25:D26')->getFont()->setBold(true);
+$helper->log('Define some styles for our Conditionals');
+$yellowStyle = new Style(false, true);
+$yellowStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_YELLOW);
+$yellowStyle->getFont()->setColor(new Color(Color::COLOR_BLUE));
+$greenStyle = new Style(false, true);
+$greenStyle->getFill()
+    ->setFillType(Fill::FILL_SOLID)
+    ->getStartColor()->setARGB(Color::COLOR_GREEN);
+$greenStyle->getFont()->setColor(new Color(Color::COLOR_DARKRED));
+$greenStyleMoney = clone $greenStyle;
+$greenStyleMoney->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
+$helper->log('Define conditional formatting and set styles');
+$cellRange = 'A2:C11';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Expression $expressionWizard */
+$expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
+$expressionWizard->expression('ISODD(A1)')
+    ->setStyle($greenStyle);
+$conditionalStyles[] = $expressionWizard->getConditional();
+$expressionWizard->expression('ISEVEN(A1)')
+    ->setStyle($yellowStyle);
+$conditionalStyles[] = $expressionWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($expressionWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A17:D22';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Expression $expressionWizard */
+$expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
+$expressionWizard->expression('$C1="USA"')
+    ->setStyle($greenStyleMoney);
+$conditionalStyles[] = $expressionWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($expressionWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$cellRange = 'A27:D32';
+$conditionalStyles = [];
+$wizardFactory = new Wizard($cellRange);
+/** @var Wizard\Expression $expressionWizard */
+$expressionWizard = $wizardFactory->newRule(Wizard::EXPRESSION);
+$expressionWizard->expression('AND($C1="USA",$D1="Q4")')
+    ->setStyle($greenStyleMoney);
+$conditionalStyles[] = $expressionWizard->getConditional();
+$spreadsheet->getActiveSheet()
+    ->getStyle($expressionWizard->getCellRange())
+    ->setConditionalStyles($conditionalStyles);
+$helper->log('Set some additional styling for money formats');
+$spreadsheet->getActiveSheet()->getStyle('B17:B22')
+    ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
+$spreadsheet->getActiveSheet()->getStyle('B27:B32')
+    ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_ACCOUNTING_USD);
+$spreadsheet->getActiveSheet()->getColumnDimension('B')
+    ->setAutoSize(true);
+$helper->write($spreadsheet, __FILE__);

--- a//dev/null
+++ b/samples/Financial2/DISC.php
@@ -0,0 +1,20 @@
+<?php
+use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel\Helpers as DateHelper;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+require __DIR__ . '/../Header.php';
+$helper->log('Returns the Discount Rate for a security.');
+$spreadsheet = new Spreadsheet();
+$worksheet = $spreadsheet->getActiveSheet();
+$arguments = [
+    ['Settlement Date', DateHelper::getDateValue('01-Apr-2016')],
+    ['Maturity Date', DateHelper::getDateValue('31-Mar-2021')],
+    ['Par Value', 95.00],
+    ['Redemption Value', 100.00],
+];
+$worksheet->fromArray($arguments, null, 'A1');
+$worksheet->getStyle('B1:B2')->getNumberFormat()->setFormatCode('dd-mmm-yyyy');
+$worksheet->getStyle('B3:B4')->getNumberFormat()->setFormatCode('$#,##0.00');
+$worksheet->setCellValue('B7', '=DISC(B1, B2, B3, B4)');
+$worksheet->getStyle('B7')->getNumberFormat()->setFormatCode('0.00%');
+$helper->log($worksheet->getCell('B7')->getValue());
+$helper->log('DISC() Result is ' . $worksheet->getCell('B7')->getFormattedValue());

--- a//dev/null
+++ b/samples/Reader2/23_iterateRowsYield.php
@@ -0,0 +1,20 @@
+<?php
+/**
+ * Use rangeToArrayYieldRows() to efficiently iterate over all rows.
+ */
+require __DIR__ . '/../Header.php';
+$inputFileName = __DIR__ . '/../Reader/sampleData/example1.xls';
+$spreadsheet = PhpOffice\PhpSpreadsheet\IOFactory::load(
+    $inputFileName,
+    PhpOffice\PhpSpreadsheet\Reader\IReader::READ_DATA_ONLY
+);
+$sheet = $spreadsheet->getSheet(0);
+$rowGenerator = $sheet->rangeToArrayYieldRows(
+    $spreadsheet->getActiveSheet()->calculateWorksheetDataDimension(),
+    null,
+    false,
+    false
+);
+foreach ($rowGenerator as $row) {
+    echo '| ' . $row[0] . ' | ' . $row[1] . "|\n";
+}

--- a//dev/null
+++ b/samples/index.php
@@ -0,0 +1,36 @@
+<?php
+require_once 'Header.php';
+$requirements = [
+    'PHP 8.1' => version_compare(PHP_VERSION, '8.1', '>='),
+    'PHP extension XML' => extension_loaded('xml'),
+    'PHP extension xmlwriter' => extension_loaded('xmlwriter'),
+    'PHP extension mbstring' => extension_loaded('mbstring'),
+    'PHP extension ZipArchive' => extension_loaded('zip'),
+    'PHP extension GD (optional)' => extension_loaded('gd'),
+    'PHP extension dom (optional)' => extension_loaded('dom'),
+];
+if (!$helper->isCli()) {
+    ?>
+    <div class="jumbotron">
+        <p>Welcome to PHPSpreadsheet, a library written in pure PHP and providing a set of classes that allow you to read from and to write to different spreadsheet file formats, like Excel and LibreOffice Calc.</p>
+        <p>&nbsp;</p>
+        <p>
+            <a class="btn btn-lg btn-primary" href="https://github.com/PHPOffice/PHPSpreadsheet" role="button"><i class="fa fa-github fa-lg" title="GitHub"></i>  Fork us on Github!</a>
+            <a class="btn btn-lg btn-primary" href="https://phpspreadsheet.readthedocs.io" role="button"><i class="fa fa-book fa-lg" title="Docs"></i>  Read the Docs</a>
+        </p>
+    </div>
+    <?php
+    echo '<h3>Requirement check</h3>';
+    echo '<ul>';
+    foreach ($requirements as $label => $result) {
+        $status = $result ? 'passed' : 'failed';
+        echo "<li>{$label} ... <span class='{$status}'>{$status}</span></li>";
+    }
+    echo '</ul>';
+} else {
+    echo 'Requirement check:' . PHP_EOL;
+    foreach ($requirements as $label => $result) {
+        $status = $result ? '32m passed' : '31m failed';
+        echo "{$label} ... \033[{$status}\033[0m" . PHP_EOL;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/Calculation.php
@@ -0,0 +1,5141 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Engine\BranchPruner;
+use PhpOffice\PhpSpreadsheet\Calculation\Engine\CyclicReferenceStack;
+use PhpOffice\PhpSpreadsheet\Calculation\Engine\Logger;
+use PhpOffice\PhpSpreadsheet\Calculation\Engine\Operands;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Calculation\Token\Stack;
+use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\DefinedName;
+use PhpOffice\PhpSpreadsheet\NamedRange;
+use PhpOffice\PhpSpreadsheet\ReferenceHelper;
+use PhpOffice\PhpSpreadsheet\Shared;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use ReflectionClassConstant;
+use ReflectionMethod;
+use ReflectionParameter;
+use Throwable;
+class Calculation
+{
+    /** Constants                */
+    /** Regular Expressions        */
+    const CALCULATION_REGEXP_NUMBER = '[-+]?\d*\.?\d+(e[-+]?\d+)?';
+    const CALCULATION_REGEXP_STRING = '"(?:[^"]|"")*"';
+    const CALCULATION_REGEXP_OPENBRACE = '\(';
+    const CALCULATION_REGEXP_FUNCTION = '@?(?:_xlfn\.)?(?:_xlws\.)?([\p{L}][\p{L}\p{N}\.]*)[\s]*\(';
+    const CALCULATION_REGEXP_STRIP_XLFN_XLWS = '/(_xlfn[.])?(_xlws[.])?(?=[\p{L}][\p{L}\p{N}\.]*[\s]*[(])/';
+    const CALCULATION_REGEXP_CELLREF = '((([^\s,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?\$?\b([a-z]{1,3})\$?(\d{1,7})(?![\w.])';
+    const CALCULATION_REGEXP_CELLREF_RELATIVE = '((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?(\$?\b[a-z]{1,3})(\$?\d{1,7})(?![\w.])';
+    const CALCULATION_REGEXP_COLUMN_RANGE = '(((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\".(?:[^\"]|\"[^!])?\"))!)?(\$?[a-z]{1,3})):(?![.*])';
+    const CALCULATION_REGEXP_ROW_RANGE = '(((([^\s\(,!&%^\/\*\+<>=:`-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?(\$?[1-9][0-9]{0,6})):(?![.*])';
+    const CALCULATION_REGEXP_COLUMNRANGE_RELATIVE = '(\$?[a-z]{1,3}):(\$?[a-z]{1,3})';
+    const CALCULATION_REGEXP_ROWRANGE_RELATIVE = '(\$?\d{1,7}):(\$?\d{1,7})';
+    const CALCULATION_REGEXP_DEFINEDNAME = '((([^\s,!&%^\/\*\+<>=-]*)|(\'(?:[^\']|\'[^!])+?\')|(\"(?:[^\"]|\"[^!])+?\"))!)?([_\p{L}][_\p{L}\p{N}\.]*)';
+    const CALCULATION_REGEXP_STRUCTURED_REFERENCE = '([\p{L}_\\\\][\p{L}\p{N}\._]+)?(\[(?:[^\d\]+-])?)';
+    const CALCULATION_REGEXP_ERROR = '\#[A-Z][A-Z0_\/]*[!\?]?';
+    /** constants */
+    const RETURN_ARRAY_AS_ERROR = 'error';
+    const RETURN_ARRAY_AS_VALUE = 'value';
+    const RETURN_ARRAY_AS_ARRAY = 'array';
+    const FORMULA_OPEN_FUNCTION_BRACE = '(';
+    const FORMULA_CLOSE_FUNCTION_BRACE = ')';
+    const FORMULA_OPEN_MATRIX_BRACE = '{';
+    const FORMULA_CLOSE_MATRIX_BRACE = '}';
+    const FORMULA_STRING_QUOTE = '"';
+    private static string $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;
+    /**
+     * Instance of this class.
+     *
+     * @var ?Calculation
+     */
+    private static ?Calculation $instance = null;
+    /**
+     * Instance of the spreadsheet this Calculation Engine is using.
+     */
+    private ?Spreadsheet $spreadsheet;
+    /**
+     * Calculation cache.
+     */
+    private array $calculationCache = [];
+    /**
+     * Calculation cache enabled.
+     */
+    private bool $calculationCacheEnabled = true;
+    private BranchPruner $branchPruner;
+    private bool $branchPruningEnabled = true;
+    /**
+     * List of operators that can be used within formulae
+     * The true/false value indicates whether it is a binary operator or a unary operator.
+     */
+    private const CALCULATION_OPERATORS = [
+        '+' => true, '-' => true, '*' => true, '/' => true,
+        '^' => true, '&' => true, '%' => false, '~' => false,
+        '>' => true, '<' => true, '=' => true, '>=' => true,
+        '<=' => true, '<>' => true, '∩' => true, '∪' => true,
+        ':' => true,
+    ];
+    /**
+     * List of binary operators (those that expect two operands).
+     */
+    private const BINARY_OPERATORS = [
+        '+' => true, '-' => true, '*' => true, '/' => true,
+        '^' => true, '&' => true, '>' => true, '<' => true,
+        '=' => true, '>=' => true, '<=' => true, '<>' => true,
+        '∩' => true, '∪' => true, ':' => true,
+    ];
+    /**
+     * The debug log generated by the calculation engine.
+     */
+    private Logger $debugLog;
+    private bool $suppressFormulaErrors = false;
+    /**
+     * Error message for any error that was raised/thrown by the calculation engine.
+     */
+    public ?string $formulaError = null;
+    /**
+     * Reference Helper.
+     */
+    private static ReferenceHelper $referenceHelper;
+    /**
+     * An array of the nested cell references accessed by the calculation engine, used for the debug log.
+     */
+    private CyclicReferenceStack $cyclicReferenceStack;
+    private array $cellStack = [];
+    /**
+     * Current iteration counter for cyclic formulae
+     * If the value is 0 (or less) then cyclic formulae will throw an exception,
+     * otherwise they will iterate to the limit defined here before returning a result.
+     */
+    private int $cyclicFormulaCounter = 1;
+    private string $cyclicFormulaCell = '';
+    /**
+     * Number of iterations for cyclic formulae.
+     */
+    public int $cyclicFormulaCount = 1;
+    /**
+     * The current locale setting.
+     */
+    private static string $localeLanguage = 'en_us'; //    US English    (default locale)
+    /**
+     * List of available locale settings
+     * Note that this is read for the locale subdirectory only when requested.
+     *
+     * @var string[]
+     */
+    private static array $validLocaleLanguages = [
+        'en', //    English        (default language)
+    ];
+    /**
+     * Locale-specific argument separator for function arguments.
+     */
+    private static string $localeArgumentSeparator = ',';
+    private static array $localeFunctions = [];
+    /**
+     * Locale-specific translations for Excel constants (True, False and Null).
+     *
+     * @var array<string, string>
+     */
+    private static array $localeBoolean = [
+        'TRUE' => 'TRUE',
+        'FALSE' => 'FALSE',
+        'NULL' => 'NULL',
+    ];
+    public static function getLocaleBoolean(string $index): string
+    {
+        return self::$localeBoolean[$index];
+    }
+    /**
+     * Excel constant string translations to their PHP equivalents
+     * Constant conversion from text name/value to actual (datatyped) value.
+     *
+     * @var array<string, null|bool>
+     */
+    private static array $excelConstants = [
+        'TRUE' => true,
+        'FALSE' => false,
+        'NULL' => null,
+    ];
+    public static function keyInExcelConstants(string $key): bool
+    {
+        return array_key_exists($key, self::$excelConstants);
+    }
+    public static function getExcelConstants(string $key): bool|null
+    {
+        return self::$excelConstants[$key];
+    }
+    /**
+     * Array of functions usable on Spreadsheet.
+     * In theory, this could be const rather than static;
+     *   however, Phpstan breaks trying to analyze it when attempted.
+     */
+    private static array $phpSpreadsheetFunctions = [
+        'ABS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Absolute::class, 'evaluate'],
+            'argumentCount' => '1',
+        ],
+        'ACCRINT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\AccruedInterest::class, 'periodic'],
+            'argumentCount' => '4-8',
+        ],
+        'ACCRINTM' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\AccruedInterest::class, 'atMaturity'],
+            'argumentCount' => '3-5',
+        ],
+        'ACOS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosine::class, 'acos'],
+            'argumentCount' => '1',
+        ],
+        'ACOSH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosine::class, 'acosh'],
+            'argumentCount' => '1',
+        ],
+        'ACOT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cotangent::class, 'acot'],
+            'argumentCount' => '1',
+        ],
+        'ACOTH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cotangent::class, 'acoth'],
+            'argumentCount' => '1',
+        ],
+        'ADDRESS' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Address::class, 'cell'],
+            'argumentCount' => '2-5',
+        ],
+        'AGGREGATE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3+',
+        ],
+        'AMORDEGRC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Amortization::class, 'AMORDEGRC'],
+            'argumentCount' => '6,7',
+        ],
+        'AMORLINC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Amortization::class, 'AMORLINC'],
+            'argumentCount' => '6,7',
+        ],
+        'ANCHORARRAY' => [
+            'category' => Category::CATEGORY_UNCATEGORISED,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'AND' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Operations::class, 'logicalAnd'],
+            'argumentCount' => '1+',
+        ],
+        'ARABIC' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Arabic::class, 'evaluate'],
+            'argumentCount' => '1',
+        ],
+        'AREAS' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'ARRAYTOTEXT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'fromArray'],
+            'argumentCount' => '1,2',
+        ],
+        'ASC' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'ASIN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Sine::class, 'asin'],
+            'argumentCount' => '1',
+        ],
+        'ASINH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Sine::class, 'asinh'],
+            'argumentCount' => '1',
+        ],
+        'ATAN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Tangent::class, 'atan'],
+            'argumentCount' => '1',
+        ],
+        'ATAN2' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Tangent::class, 'atan2'],
+            'argumentCount' => '2',
+        ],
+        'ATANH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Tangent::class, 'atanh'],
+            'argumentCount' => '1',
+        ],
+        'AVEDEV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'averageDeviations'],
+            'argumentCount' => '1+',
+        ],
+        'AVERAGE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'average'],
+            'argumentCount' => '1+',
+        ],
+        'AVERAGEA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'averageA'],
+            'argumentCount' => '1+',
+        ],
+        'AVERAGEIF' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'AVERAGEIF'],
+            'argumentCount' => '2,3',
+        ],
+        'AVERAGEIFS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'AVERAGEIFS'],
+            'argumentCount' => '3+',
+        ],
+        'BAHTTEXT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'BASE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Base::class, 'evaluate'],
+            'argumentCount' => '2,3',
+        ],
+        'BESSELI' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BesselI::class, 'BESSELI'],
+            'argumentCount' => '2',
+        ],
+        'BESSELJ' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BesselJ::class, 'BESSELJ'],
+            'argumentCount' => '2',
+        ],
+        'BESSELK' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BesselK::class, 'BESSELK'],
+            'argumentCount' => '2',
+        ],
+        'BESSELY' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BesselY::class, 'BESSELY'],
+            'argumentCount' => '2',
+        ],
+        'BETADIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Beta::class, 'distribution'],
+            'argumentCount' => '3-5',
+        ],
+        'BETA.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '4-6',
+        ],
+        'BETAINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Beta::class, 'inverse'],
+            'argumentCount' => '3-5',
+        ],
+        'BETA.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Beta::class, 'inverse'],
+            'argumentCount' => '3-5',
+        ],
+        'BIN2DEC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertBinary::class, 'toDecimal'],
+            'argumentCount' => '1',
+        ],
+        'BIN2HEX' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertBinary::class, 'toHex'],
+            'argumentCount' => '1,2',
+        ],
+        'BIN2OCT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertBinary::class, 'toOctal'],
+            'argumentCount' => '1,2',
+        ],
+        'BINOMDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'BINOM.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'BINOM.DIST.RANGE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'range'],
+            'argumentCount' => '3,4',
+        ],
+        'BINOM.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'BITAND' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BitWise::class, 'BITAND'],
+            'argumentCount' => '2',
+        ],
+        'BITOR' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BitWise::class, 'BITOR'],
+            'argumentCount' => '2',
+        ],
+        'BITXOR' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BitWise::class, 'BITXOR'],
+            'argumentCount' => '2',
+        ],
+        'BITLSHIFT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BitWise::class, 'BITLSHIFT'],
+            'argumentCount' => '2',
+        ],
+        'BITRSHIFT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\BitWise::class, 'BITRSHIFT'],
+            'argumentCount' => '2',
+        ],
+        'BYCOL' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'BYROW' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'CEILING' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Ceiling::class, 'ceiling'],
+            'argumentCount' => '1-2', // 2 for Excel, 1-2 for Ods/Gnumeric
+        ],
+        'CEILING.MATH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Ceiling::class, 'math'],
+            'argumentCount' => '1-3',
+        ],
+        'CEILING.PRECISE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Ceiling::class, 'precise'],
+            'argumentCount' => '1,2',
+        ],
+        'CELL' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1,2',
+        ],
+        'CHAR' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CharacterConvert::class, 'character'],
+            'argumentCount' => '1',
+        ],
+        'CHIDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionRightTail'],
+            'argumentCount' => '2',
+        ],
+        'CHISQ.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionLeftTail'],
+            'argumentCount' => '3',
+        ],
+        'CHISQ.DIST.RT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'distributionRightTail'],
+            'argumentCount' => '2',
+        ],
+        'CHIINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseRightTail'],
+            'argumentCount' => '2',
+        ],
+        'CHISQ.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseLeftTail'],
+            'argumentCount' => '2',
+        ],
+        'CHISQ.INV.RT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'inverseRightTail'],
+            'argumentCount' => '2',
+        ],
+        'CHITEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'test'],
+            'argumentCount' => '2',
+        ],
+        'CHISQ.TEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\ChiSquared::class, 'test'],
+            'argumentCount' => '2',
+        ],
+        'CHOOSE' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Selection::class, 'CHOOSE'],
+            'argumentCount' => '2+',
+        ],
+        'CHOOSECOLS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2+',
+        ],
+        'CHOOSEROWS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2+',
+        ],
+        'CLEAN' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Trim::class, 'nonPrintable'],
+            'argumentCount' => '1',
+        ],
+        'CODE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CharacterConvert::class, 'code'],
+            'argumentCount' => '1',
+        ],
+        'COLUMN' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\RowColumnInformation::class, 'COLUMN'],
+            'argumentCount' => '-1',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'COLUMNS' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\RowColumnInformation::class, 'COLUMNS'],
+            'argumentCount' => '1',
+        ],
+        'COMBIN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Combinations::class, 'withoutRepetition'],
+            'argumentCount' => '2',
+        ],
+        'COMBINA' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Combinations::class, 'withRepetition'],
+            'argumentCount' => '2',
+        ],
+        'COMPLEX' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Complex::class, 'COMPLEX'],
+            'argumentCount' => '2,3',
+        ],
+        'CONCAT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Concatenate::class, 'CONCATENATE'],
+            'argumentCount' => '1+',
+        ],
+        'CONCATENATE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Concatenate::class, 'CONCATENATE'],
+            'argumentCount' => '1+',
+        ],
+        'CONFIDENCE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Confidence::class, 'CONFIDENCE'],
+            'argumentCount' => '3',
+        ],
+        'CONFIDENCE.NORM' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Confidence::class, 'CONFIDENCE'],
+            'argumentCount' => '3',
+        ],
+        'CONFIDENCE.T' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'CONVERT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertUOM::class, 'CONVERT'],
+            'argumentCount' => '3',
+        ],
+        'CORREL' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'CORREL'],
+            'argumentCount' => '2',
+        ],
+        'COS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosine::class, 'cos'],
+            'argumentCount' => '1',
+        ],
+        'COSH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosine::class, 'cosh'],
+            'argumentCount' => '1',
+        ],
+        'COT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cotangent::class, 'cot'],
+            'argumentCount' => '1',
+        ],
+        'COTH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cotangent::class, 'coth'],
+            'argumentCount' => '1',
+        ],
+        'COUNT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Counts::class, 'COUNT'],
+            'argumentCount' => '1+',
+        ],
+        'COUNTA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Counts::class, 'COUNTA'],
+            'argumentCount' => '1+',
+        ],
+        'COUNTBLANK' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Counts::class, 'COUNTBLANK'],
+            'argumentCount' => '1',
+        ],
+        'COUNTIF' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'COUNTIF'],
+            'argumentCount' => '2',
+        ],
+        'COUNTIFS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'COUNTIFS'],
+            'argumentCount' => '2+',
+        ],
+        'COUPDAYBS' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPDAYBS'],
+            'argumentCount' => '3,4',
+        ],
+        'COUPDAYS' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPDAYS'],
+            'argumentCount' => '3,4',
+        ],
+        'COUPDAYSNC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPDAYSNC'],
+            'argumentCount' => '3,4',
+        ],
+        'COUPNCD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPNCD'],
+            'argumentCount' => '3,4',
+        ],
+        'COUPNUM' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPNUM'],
+            'argumentCount' => '3,4',
+        ],
+        'COUPPCD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Coupons::class, 'COUPPCD'],
+            'argumentCount' => '3,4',
+        ],
+        'COVAR' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'COVAR'],
+            'argumentCount' => '2',
+        ],
+        'COVARIANCE.P' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'COVAR'],
+            'argumentCount' => '2',
+        ],
+        'COVARIANCE.S' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'CRITBINOM' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'CSC' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosecant::class, 'csc'],
+            'argumentCount' => '1',
+        ],
+        'CSCH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Cosecant::class, 'csch'],
+            'argumentCount' => '1',
+        ],
+        'CUBEKPIMEMBER' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBEMEMBER' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBEMEMBERPROPERTY' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBERANKEDMEMBER' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBESET' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBESETCOUNT' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUBEVALUE' => [
+            'category' => Category::CATEGORY_CUBE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'CUMIPMT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Cumulative::class, 'interest'],
+            'argumentCount' => '6',
+        ],
+        'CUMPRINC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Cumulative::class, 'principal'],
+            'argumentCount' => '6',
+        ],
+        'DATE' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Date::class, 'fromYMD'],
+            'argumentCount' => '3',
+        ],
+        'DATEDIF' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Difference::class, 'interval'],
+            'argumentCount' => '2,3',
+        ],
+        'DATESTRING' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'DATEVALUE' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\DateValue::class, 'fromString'],
+            'argumentCount' => '1',
+        ],
+        'DAVERAGE' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DAverage::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DAY' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\DateParts::class, 'day'],
+            'argumentCount' => '1',
+        ],
+        'DAYS' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Days::class, 'between'],
+            'argumentCount' => '2',
+        ],
+        'DAYS360' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Days360::class, 'between'],
+            'argumentCount' => '2,3',
+        ],
+        'DB' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Depreciation::class, 'DB'],
+            'argumentCount' => '4,5',
+        ],
+        'DBCS' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'DCOUNT' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DCount::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DCOUNTA' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DCountA::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DDB' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Depreciation::class, 'DDB'],
+            'argumentCount' => '4,5',
+        ],
+        'DEC2BIN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertDecimal::class, 'toBinary'],
+            'argumentCount' => '1,2',
+        ],
+        'DEC2HEX' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertDecimal::class, 'toHex'],
+            'argumentCount' => '1,2',
+        ],
+        'DEC2OCT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertDecimal::class, 'toOctal'],
+            'argumentCount' => '1,2',
+        ],
+        'DECIMAL' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'DEGREES' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Angle::class, 'toDegrees'],
+            'argumentCount' => '1',
+        ],
+        'DELTA' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Compare::class, 'DELTA'],
+            'argumentCount' => '1,2',
+        ],
+        'DEVSQ' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Deviations::class, 'sumSquares'],
+            'argumentCount' => '1+',
+        ],
+        'DGET' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DGet::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DISC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Rates::class, 'discount'],
+            'argumentCount' => '4,5',
+        ],
+        'DMAX' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DMax::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DMIN' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DMin::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DOLLAR' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'DOLLAR'],
+            'argumentCount' => '1,2',
+        ],
+        'DOLLARDE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Dollar::class, 'decimal'],
+            'argumentCount' => '2',
+        ],
+        'DOLLARFR' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Dollar::class, 'fractional'],
+            'argumentCount' => '2',
+        ],
+        'DPRODUCT' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DProduct::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DROP' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-3',
+        ],
+        'DSTDEV' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DStDev::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DSTDEVP' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DStDevP::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DSUM' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DSum::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DURATION' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '5,6',
+        ],
+        'DVAR' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DVar::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'DVARP' => [
+            'category' => Category::CATEGORY_DATABASE,
+            'functionCall' => [Database\DVarP::class, 'evaluate'],
+            'argumentCount' => '3',
+        ],
+        'ECMA.CEILING' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1,2',
+        ],
+        'EDATE' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Month::class, 'adjust'],
+            'argumentCount' => '2',
+        ],
+        'EFFECT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\InterestRate::class, 'effective'],
+            'argumentCount' => '2',
+        ],
+        'ENCODEURL' => [
+            'category' => Category::CATEGORY_WEB,
+            'functionCall' => [Web\Service::class, 'urlEncode'],
+            'argumentCount' => '1',
+        ],
+        'EOMONTH' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Month::class, 'lastDay'],
+            'argumentCount' => '2',
+        ],
+        'ERF' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Erf::class, 'ERF'],
+            'argumentCount' => '1,2',
+        ],
+        'ERF.PRECISE' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Erf::class, 'ERFPRECISE'],
+            'argumentCount' => '1',
+        ],
+        'ERFC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ErfC::class, 'ERFC'],
+            'argumentCount' => '1',
+        ],
+        'ERFC.PRECISE' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ErfC::class, 'ERFC'],
+            'argumentCount' => '1',
+        ],
+        'ERROR.TYPE' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [ExcelError::class, 'type'],
+            'argumentCount' => '1',
+        ],
+        'EVEN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'even'],
+            'argumentCount' => '1',
+        ],
+        'EXACT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'exact'],
+            'argumentCount' => '2',
+        ],
+        'EXP' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Exp::class, 'evaluate'],
+            'argumentCount' => '1',
+        ],
+        'EXPAND' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-4',
+        ],
+        'EXPONDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Exponential::class, 'distribution'],
+            'argumentCount' => '3',
+        ],
+        'EXPON.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Exponential::class, 'distribution'],
+            'argumentCount' => '3',
+        ],
+        'FACT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Factorial::class, 'fact'],
+            'argumentCount' => '1',
+        ],
+        'FACTDOUBLE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Factorial::class, 'factDouble'],
+            'argumentCount' => '1',
+        ],
+        'FALSE' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Boolean::class, 'FALSE'],
+            'argumentCount' => '0',
+        ],
+        'FDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'F.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\F::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'F.DIST.RT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'FILTER' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Filter::class, 'filter'],
+            'argumentCount' => '2-3',
+        ],
+        'FILTERXML' => [
+            'category' => Category::CATEGORY_WEB,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'FIND' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Search::class, 'sensitive'],
+            'argumentCount' => '2,3',
+        ],
+        'FINDB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Search::class, 'sensitive'],
+            'argumentCount' => '2,3',
+        ],
+        'FINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'F.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'F.INV.RT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'FISHER' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Fisher::class, 'distribution'],
+            'argumentCount' => '1',
+        ],
+        'FISHERINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Fisher::class, 'inverse'],
+            'argumentCount' => '1',
+        ],
+        'FIXED' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'FIXEDFORMAT'],
+            'argumentCount' => '1-3',
+        ],
+        'FLOOR' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Floor::class, 'floor'],
+            'argumentCount' => '1-2', // Excel requries 2, Ods/Gnumeric 1-2
+        ],
+        'FLOOR.MATH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Floor::class, 'math'],
+            'argumentCount' => '1-3',
+        ],
+        'FLOOR.PRECISE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Floor::class, 'precise'],
+            'argumentCount' => '1-2',
+        ],
+        'FORECAST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'FORECAST'],
+            'argumentCount' => '3',
+        ],
+        'FORECAST.ETS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3-6',
+        ],
+        'FORECAST.ETS.CONFINT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3-6',
+        ],
+        'FORECAST.ETS.SEASONALITY' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-4',
+        ],
+        'FORECAST.ETS.STAT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3-6',
+        ],
+        'FORECAST.LINEAR' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'FORECAST'],
+            'argumentCount' => '3',
+        ],
+        'FORMULATEXT' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Formula::class, 'text'],
+            'argumentCount' => '1',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'FREQUENCY' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'FTEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'F.TEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'FV' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'futureValue'],
+            'argumentCount' => '3-5',
+        ],
+        'FVSCHEDULE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Single::class, 'futureValue'],
+            'argumentCount' => '2',
+        ],
+        'GAMMA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'gamma'],
+            'argumentCount' => '1',
+        ],
+        'GAMMADIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'GAMMA.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'GAMMAINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'GAMMA.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'GAMMALN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'ln'],
+            'argumentCount' => '1',
+        ],
+        'GAMMALN.PRECISE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Gamma::class, 'ln'],
+            'argumentCount' => '1',
+        ],
+        'GAUSS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'gauss'],
+            'argumentCount' => '1',
+        ],
+        'GCD' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Gcd::class, 'evaluate'],
+            'argumentCount' => '1+',
+        ],
+        'GEOMEAN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages\Mean::class, 'geometric'],
+            'argumentCount' => '1+',
+        ],
+        'GESTEP' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Compare::class, 'GESTEP'],
+            'argumentCount' => '1,2',
+        ],
+        'GETPIVOTDATA' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2+',
+        ],
+        'GROWTH' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'GROWTH'],
+            'argumentCount' => '1-4',
+        ],
+        'HARMEAN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages\Mean::class, 'harmonic'],
+            'argumentCount' => '1+',
+        ],
+        'HEX2BIN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertHex::class, 'toBinary'],
+            'argumentCount' => '1,2',
+        ],
+        'HEX2DEC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertHex::class, 'toDecimal'],
+            'argumentCount' => '1',
+        ],
+        'HEX2OCT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertHex::class, 'toOctal'],
+            'argumentCount' => '1,2',
+        ],
+        'HLOOKUP' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\HLookup::class, 'lookup'],
+            'argumentCount' => '3,4',
+        ],
+        'HOUR' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\TimeParts::class, 'hour'],
+            'argumentCount' => '1',
+        ],
+        'HSTACK' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1+',
+        ],
+        'HYPERLINK' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Hyperlink::class, 'set'],
+            'argumentCount' => '1,2',
+            'passCellReference' => true,
+        ],
+        'HYPGEOMDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\HyperGeometric::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'HYPGEOM.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '5',
+        ],
+        'IF' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Conditional::class, 'statementIf'],
+            'argumentCount' => '2-3',
+        ],
+        'IFERROR' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Conditional::class, 'IFERROR'],
+            'argumentCount' => '2',
+        ],
+        'IFNA' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Conditional::class, 'IFNA'],
+            'argumentCount' => '2',
+        ],
+        'IFS' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Conditional::class, 'IFS'],
+            'argumentCount' => '2+',
+        ],
+        'IMABS' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMABS'],
+            'argumentCount' => '1',
+        ],
+        'IMAGINARY' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Complex::class, 'IMAGINARY'],
+            'argumentCount' => '1',
+        ],
+        'IMARGUMENT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMARGUMENT'],
+            'argumentCount' => '1',
+        ],
+        'IMCONJUGATE' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCONJUGATE'],
+            'argumentCount' => '1',
+        ],
+        'IMCOS' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOS'],
+            'argumentCount' => '1',
+        ],
+        'IMCOSH' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOSH'],
+            'argumentCount' => '1',
+        ],
+        'IMCOT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCOT'],
+            'argumentCount' => '1',
+        ],
+        'IMCSC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCSC'],
+            'argumentCount' => '1',
+        ],
+        'IMCSCH' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMCSCH'],
+            'argumentCount' => '1',
+        ],
+        'IMDIV' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexOperations::class, 'IMDIV'],
+            'argumentCount' => '2',
+        ],
+        'IMEXP' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMEXP'],
+            'argumentCount' => '1',
+        ],
+        'IMLN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMLN'],
+            'argumentCount' => '1',
+        ],
+        'IMLOG10' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMLOG10'],
+            'argumentCount' => '1',
+        ],
+        'IMLOG2' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMLOG2'],
+            'argumentCount' => '1',
+        ],
+        'IMPOWER' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMPOWER'],
+            'argumentCount' => '2',
+        ],
+        'IMPRODUCT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexOperations::class, 'IMPRODUCT'],
+            'argumentCount' => '1+',
+        ],
+        'IMREAL' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\Complex::class, 'IMREAL'],
+            'argumentCount' => '1',
+        ],
+        'IMSEC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMSEC'],
+            'argumentCount' => '1',
+        ],
+        'IMSECH' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMSECH'],
+            'argumentCount' => '1',
+        ],
+        'IMSIN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMSIN'],
+            'argumentCount' => '1',
+        ],
+        'IMSINH' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMSINH'],
+            'argumentCount' => '1',
+        ],
+        'IMSQRT' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMSQRT'],
+            'argumentCount' => '1',
+        ],
+        'IMSUB' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexOperations::class, 'IMSUB'],
+            'argumentCount' => '2',
+        ],
+        'IMSUM' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexOperations::class, 'IMSUM'],
+            'argumentCount' => '1+',
+        ],
+        'IMTAN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ComplexFunctions::class, 'IMTAN'],
+            'argumentCount' => '1',
+        ],
+        'INDEX' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Matrix::class, 'index'],
+            'argumentCount' => '2-4',
+        ],
+        'INDIRECT' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Indirect::class, 'INDIRECT'],
+            'argumentCount' => '1,2',
+            'passCellReference' => true,
+        ],
+        'INFO' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'INT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\IntClass::class, 'evaluate'],
+            'argumentCount' => '1',
+        ],
+        'INTERCEPT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'INTERCEPT'],
+            'argumentCount' => '2',
+        ],
+        'INTRATE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Rates::class, 'interest'],
+            'argumentCount' => '4,5',
+        ],
+        'IPMT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'payment'],
+            'argumentCount' => '4-6',
+        ],
+        'IRR' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'rate'],
+            'argumentCount' => '1,2',
+        ],
+        'ISBLANK' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isBlank'],
+            'argumentCount' => '1',
+        ],
+        'ISERR' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\ErrorValue::class, 'isErr'],
+            'argumentCount' => '1',
+        ],
+        'ISERROR' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\ErrorValue::class, 'isError'],
+            'argumentCount' => '1',
+        ],
+        'ISEVEN' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isEven'],
+            'argumentCount' => '1',
+        ],
+        'ISFORMULA' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isFormula'],
+            'argumentCount' => '1',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'ISLOGICAL' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isLogical'],
+            'argumentCount' => '1',
+        ],
+        'ISNA' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\ErrorValue::class, 'isNa'],
+            'argumentCount' => '1',
+        ],
+        'ISNONTEXT' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isNonText'],
+            'argumentCount' => '1',
+        ],
+        'ISNUMBER' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isNumber'],
+            'argumentCount' => '1',
+        ],
+        'ISO.CEILING' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1,2',
+        ],
+        'ISODD' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isOdd'],
+            'argumentCount' => '1',
+        ],
+        'ISOMITTED' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'ISOWEEKNUM' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Week::class, 'isoWeekNumber'],
+            'argumentCount' => '1',
+        ],
+        'ISPMT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'schedulePayment'],
+            'argumentCount' => '4',
+        ],
+        'ISREF' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isRef'],
+            'argumentCount' => '1',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'ISTEXT' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'isText'],
+            'argumentCount' => '1',
+        ],
+        'ISTHAIDIGIT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'JIS' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'KURT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Deviations::class, 'kurtosis'],
+            'argumentCount' => '1+',
+        ],
+        'LAMBDA' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'LARGE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Size::class, 'large'],
+            'argumentCount' => '2',
+        ],
+        'LCM' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Lcm::class, 'evaluate'],
+            'argumentCount' => '1+',
+        ],
+        'LEFT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'left'],
+            'argumentCount' => '1,2',
+        ],
+        'LEFTB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'left'],
+            'argumentCount' => '1,2',
+        ],
+        'LEN' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'length'],
+            'argumentCount' => '1',
+        ],
+        'LENB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'length'],
+            'argumentCount' => '1',
+        ],
+        'LET' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'LINEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'LINEST'],
+            'argumentCount' => '1-4',
+        ],
+        'LN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Logarithms::class, 'natural'],
+            'argumentCount' => '1',
+        ],
+        'LOG' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Logarithms::class, 'withBase'],
+            'argumentCount' => '1,2',
+        ],
+        'LOG10' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Logarithms::class, 'base10'],
+            'argumentCount' => '1',
+        ],
+        'LOGEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'LOGEST'],
+            'argumentCount' => '1-4',
+        ],
+        'LOGINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\LogNormal::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'LOGNORMDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\LogNormal::class, 'cumulative'],
+            'argumentCount' => '3',
+        ],
+        'LOGNORM.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\LogNormal::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'LOGNORM.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\LogNormal::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'LOOKUP' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Lookup::class, 'lookup'],
+            'argumentCount' => '2,3',
+        ],
+        'LOWER' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CaseConvert::class, 'lower'],
+            'argumentCount' => '1',
+        ],
+        'MAKEARRAY' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'MAP' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'MATCH' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\ExcelMatch::class, 'MATCH'],
+            'argumentCount' => '2,3',
+        ],
+        'MAX' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Maximum::class, 'max'],
+            'argumentCount' => '1+',
+        ],
+        'MAXA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Maximum::class, 'maxA'],
+            'argumentCount' => '1+',
+        ],
+        'MAXIFS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'MAXIFS'],
+            'argumentCount' => '3+',
+        ],
+        'MDETERM' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\MatrixFunctions::class, 'determinant'],
+            'argumentCount' => '1',
+        ],
+        'MDURATION' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '5,6',
+        ],
+        'MEDIAN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'median'],
+            'argumentCount' => '1+',
+        ],
+        'MEDIANIF' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2+',
+        ],
+        'MID' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'mid'],
+            'argumentCount' => '3',
+        ],
+        'MIDB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'mid'],
+            'argumentCount' => '3',
+        ],
+        'MIN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Minimum::class, 'min'],
+            'argumentCount' => '1+',
+        ],
+        'MINA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Minimum::class, 'minA'],
+            'argumentCount' => '1+',
+        ],
+        'MINIFS' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Conditional::class, 'MINIFS'],
+            'argumentCount' => '3+',
+        ],
+        'MINUTE' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\TimeParts::class, 'minute'],
+            'argumentCount' => '1',
+        ],
+        'MINVERSE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\MatrixFunctions::class, 'inverse'],
+            'argumentCount' => '1',
+        ],
+        'MIRR' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'modifiedRate'],
+            'argumentCount' => '3',
+        ],
+        'MMULT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\MatrixFunctions::class, 'multiply'],
+            'argumentCount' => '2',
+        ],
+        'MOD' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Operations::class, 'mod'],
+            'argumentCount' => '2',
+        ],
+        'MODE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'mode'],
+            'argumentCount' => '1+',
+        ],
+        'MODE.MULT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1+',
+        ],
+        'MODE.SNGL' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages::class, 'mode'],
+            'argumentCount' => '1+',
+        ],
+        'MONTH' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\DateParts::class, 'month'],
+            'argumentCount' => '1',
+        ],
+        'MROUND' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'multiple'],
+            'argumentCount' => '2',
+        ],
+        'MULTINOMIAL' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Factorial::class, 'multinomial'],
+            'argumentCount' => '1+',
+        ],
+        'MUNIT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\MatrixFunctions::class, 'identity'],
+            'argumentCount' => '1',
+        ],
+        'N' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'asNumber'],
+            'argumentCount' => '1',
+        ],
+        'NA' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [ExcelError::class, 'NA'],
+            'argumentCount' => '0',
+        ],
+        'NEGBINOMDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Binomial::class, 'negative'],
+            'argumentCount' => '3',
+        ],
+        'NEGBINOM.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '4',
+        ],
+        'NETWORKDAYS' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\NetworkDays::class, 'count'],
+            'argumentCount' => '2-3',
+        ],
+        'NETWORKDAYS.INTL' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-4',
+        ],
+        'NOMINAL' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\InterestRate::class, 'nominal'],
+            'argumentCount' => '2',
+        ],
+        'NORMDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Normal::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'NORM.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Normal::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'NORMINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Normal::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'NORM.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Normal::class, 'inverse'],
+            'argumentCount' => '3',
+        ],
+        'NORMSDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'cumulative'],
+            'argumentCount' => '1',
+        ],
+        'NORM.S.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'distribution'],
+            'argumentCount' => '1,2',
+        ],
+        'NORMSINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'inverse'],
+            'argumentCount' => '1',
+        ],
+        'NORM.S.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'inverse'],
+            'argumentCount' => '1',
+        ],
+        'NOT' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Operations::class, 'NOT'],
+            'argumentCount' => '1',
+        ],
+        'NOW' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Current::class, 'now'],
+            'argumentCount' => '0',
+        ],
+        'NPER' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'periods'],
+            'argumentCount' => '3-5',
+        ],
+        'NPV' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Variable\Periodic::class, 'presentValue'],
+            'argumentCount' => '2+',
+        ],
+        'NUMBERSTRING' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'NUMBERVALUE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'NUMBERVALUE'],
+            'argumentCount' => '1+',
+        ],
+        'OCT2BIN' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertOctal::class, 'toBinary'],
+            'argumentCount' => '1,2',
+        ],
+        'OCT2DEC' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertOctal::class, 'toDecimal'],
+            'argumentCount' => '1',
+        ],
+        'OCT2HEX' => [
+            'category' => Category::CATEGORY_ENGINEERING,
+            'functionCall' => [Engineering\ConvertOctal::class, 'toHex'],
+            'argumentCount' => '1,2',
+        ],
+        'ODD' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'odd'],
+            'argumentCount' => '1',
+        ],
+        'ODDFPRICE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '8,9',
+        ],
+        'ODDFYIELD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '8,9',
+        ],
+        'ODDLPRICE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '7,8',
+        ],
+        'ODDLYIELD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '7,8',
+        ],
+        'OFFSET' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Offset::class, 'OFFSET'],
+            'argumentCount' => '3-5',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'OR' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Operations::class, 'logicalOr'],
+            'argumentCount' => '1+',
+        ],
+        'PDURATION' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Single::class, 'periods'],
+            'argumentCount' => '3',
+        ],
+        'PEARSON' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'CORREL'],
+            'argumentCount' => '2',
+        ],
+        'PERCENTILE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'PERCENTILE'],
+            'argumentCount' => '2',
+        ],
+        'PERCENTILE.EXC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'PERCENTILE.INC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'PERCENTILE'],
+            'argumentCount' => '2',
+        ],
+        'PERCENTRANK' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'PERCENTRANK'],
+            'argumentCount' => '2,3',
+        ],
+        'PERCENTRANK.EXC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2,3',
+        ],
+        'PERCENTRANK.INC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'PERCENTRANK'],
+            'argumentCount' => '2,3',
+        ],
+        'PERMUT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Permutations::class, 'PERMUT'],
+            'argumentCount' => '2',
+        ],
+        'PERMUTATIONA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Permutations::class, 'PERMUTATIONA'],
+            'argumentCount' => '2',
+        ],
+        'PHONETIC' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'PHI' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1',
+        ],
+        'PI' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => 'pi',
+            'argumentCount' => '0',
+        ],
+        'PMT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Payments::class, 'annuity'],
+            'argumentCount' => '3-5',
+        ],
+        'POISSON' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Poisson::class, 'distribution'],
+            'argumentCount' => '3',
+        ],
+        'POISSON.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Poisson::class, 'distribution'],
+            'argumentCount' => '3',
+        ],
+        'POWER' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Operations::class, 'power'],
+            'argumentCount' => '2',
+        ],
+        'PPMT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Payments::class, 'interestPayment'],
+            'argumentCount' => '4-6',
+        ],
+        'PRICE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Price::class, 'price'],
+            'argumentCount' => '6,7',
+        ],
+        'PRICEDISC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Price::class, 'priceDiscounted'],
+            'argumentCount' => '4,5',
+        ],
+        'PRICEMAT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Price::class, 'priceAtMaturity'],
+            'argumentCount' => '5,6',
+        ],
+        'PROB' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3,4',
+        ],
+        'PRODUCT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Operations::class, 'product'],
+            'argumentCount' => '1+',
+        ],
+        'PROPER' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CaseConvert::class, 'proper'],
+            'argumentCount' => '1',
+        ],
+        'PV' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic::class, 'presentValue'],
+            'argumentCount' => '3-5',
+        ],
+        'QUARTILE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'QUARTILE'],
+            'argumentCount' => '2',
+        ],
+        'QUARTILE.EXC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'QUARTILE.INC' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'QUARTILE'],
+            'argumentCount' => '2',
+        ],
+        'QUOTIENT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Operations::class, 'quotient'],
+            'argumentCount' => '2',
+        ],
+        'RADIANS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Angle::class, 'toRadians'],
+            'argumentCount' => '1',
+        ],
+        'RAND' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Random::class, 'rand'],
+            'argumentCount' => '0',
+        ],
+        'RANDARRAY' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Random::class, 'randArray'],
+            'argumentCount' => '0-5',
+        ],
+        'RANDBETWEEN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Random::class, 'randBetween'],
+            'argumentCount' => '2',
+        ],
+        'RANK' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'RANK'],
+            'argumentCount' => '2,3',
+        ],
+        'RANK.AVG' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2,3',
+        ],
+        'RANK.EQ' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Percentiles::class, 'RANK'],
+            'argumentCount' => '2,3',
+        ],
+        'RATE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Constant\Periodic\Interest::class, 'rate'],
+            'argumentCount' => '3-6',
+        ],
+        'RECEIVED' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Price::class, 'received'],
+            'argumentCount' => '4-5',
+        ],
+        'REDUCE' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'REPLACE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Replace::class, 'replace'],
+            'argumentCount' => '4',
+        ],
+        'REPLACEB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Replace::class, 'replace'],
+            'argumentCount' => '4',
+        ],
+        'REPT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Concatenate::class, 'builtinREPT'],
+            'argumentCount' => '2',
+        ],
+        'RIGHT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'right'],
+            'argumentCount' => '1,2',
+        ],
+        'RIGHTB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'right'],
+            'argumentCount' => '1,2',
+        ],
+        'ROMAN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Roman::class, 'evaluate'],
+            'argumentCount' => '1,2',
+        ],
+        'ROUND' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'round'],
+            'argumentCount' => '2',
+        ],
+        'ROUNDBAHTDOWN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'ROUNDBAHTUP' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'ROUNDDOWN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'down'],
+            'argumentCount' => '2',
+        ],
+        'ROUNDUP' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Round::class, 'up'],
+            'argumentCount' => '2',
+        ],
+        'ROW' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\RowColumnInformation::class, 'ROW'],
+            'argumentCount' => '-1',
+            'passCellReference' => true,
+            'passByReference' => [true],
+        ],
+        'ROWS' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\RowColumnInformation::class, 'ROWS'],
+            'argumentCount' => '1',
+        ],
+        'RRI' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Single::class, 'interestRate'],
+            'argumentCount' => '3',
+        ],
+        'RSQ' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'RSQ'],
+            'argumentCount' => '2',
+        ],
+        'RTD' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1+',
+        ],
+        'SEARCH' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Search::class, 'insensitive'],
+            'argumentCount' => '2,3',
+        ],
+        'SCAN' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'SEARCHB' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Search::class, 'insensitive'],
+            'argumentCount' => '2,3',
+        ],
+        'SEC' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Secant::class, 'sec'],
+            'argumentCount' => '1',
+        ],
+        'SECH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Secant::class, 'sech'],
+            'argumentCount' => '1',
+        ],
+        'SECOND' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\TimeParts::class, 'second'],
+            'argumentCount' => '1',
+        ],
+        'SEQUENCE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\MatrixFunctions::class, 'sequence'],
+            'argumentCount' => '1-4',
+        ],
+        'SERIESSUM' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\SeriesSum::class, 'evaluate'],
+            'argumentCount' => '4',
+        ],
+        'SHEET' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '0,1',
+        ],
+        'SHEETS' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '0,1',
+        ],
+        'SIGN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Sign::class, 'evaluate'],
+            'argumentCount' => '1',
+        ],
+        'SIN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Sine::class, 'sin'],
+            'argumentCount' => '1',
+        ],
+        'SINGLE' => [
+            'category' => Category::CATEGORY_UNCATEGORISED,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '*',
+        ],
+        'SINH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Sine::class, 'sinh'],
+            'argumentCount' => '1',
+        ],
+        'SKEW' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Deviations::class, 'skew'],
+            'argumentCount' => '1+',
+        ],
+        'SKEW.P' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1+',
+        ],
+        'SLN' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Depreciation::class, 'SLN'],
+            'argumentCount' => '3',
+        ],
+        'SLOPE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'SLOPE'],
+            'argumentCount' => '2',
+        ],
+        'SMALL' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Size::class, 'small'],
+            'argumentCount' => '2',
+        ],
+        'SORT' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Sort::class, 'sort'],
+            'argumentCount' => '1-4',
+        ],
+        'SORTBY' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Sort::class, 'sortBy'],
+            'argumentCount' => '2+',
+        ],
+        'SQRT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Sqrt::class, 'sqrt'],
+            'argumentCount' => '1',
+        ],
+        'SQRTPI' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Sqrt::class, 'pi'],
+            'argumentCount' => '1',
+        ],
+        'STANDARDIZE' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Standardize::class, 'execute'],
+            'argumentCount' => '3',
+        ],
+        'STDEV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEV'],
+            'argumentCount' => '1+',
+        ],
+        'STDEV.S' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEV'],
+            'argumentCount' => '1+',
+        ],
+        'STDEV.P' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEVP'],
+            'argumentCount' => '1+',
+        ],
+        'STDEVA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEVA'],
+            'argumentCount' => '1+',
+        ],
+        'STDEVP' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEVP'],
+            'argumentCount' => '1+',
+        ],
+        'STDEVPA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\StandardDeviations::class, 'STDEVPA'],
+            'argumentCount' => '1+',
+        ],
+        'STEYX' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'STEYX'],
+            'argumentCount' => '2',
+        ],
+        'SUBSTITUTE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Replace::class, 'substitute'],
+            'argumentCount' => '3,4',
+        ],
+        'SUBTOTAL' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Subtotal::class, 'evaluate'],
+            'argumentCount' => '2+',
+            'passCellReference' => true,
+        ],
+        'SUM' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Sum::class, 'sumErroringStrings'],
+            'argumentCount' => '1+',
+        ],
+        'SUMIF' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Statistical\Conditional::class, 'SUMIF'],
+            'argumentCount' => '2,3',
+        ],
+        'SUMIFS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Statistical\Conditional::class, 'SUMIFS'],
+            'argumentCount' => '3+',
+        ],
+        'SUMPRODUCT' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Sum::class, 'product'],
+            'argumentCount' => '1+',
+        ],
+        'SUMSQ' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\SumSquares::class, 'sumSquare'],
+            'argumentCount' => '1+',
+        ],
+        'SUMX2MY2' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\SumSquares::class, 'sumXSquaredMinusYSquared'],
+            'argumentCount' => '2',
+        ],
+        'SUMX2PY2' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\SumSquares::class, 'sumXSquaredPlusYSquared'],
+            'argumentCount' => '2',
+        ],
+        'SUMXMY2' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\SumSquares::class, 'sumXMinusYSquared'],
+            'argumentCount' => '2',
+        ],
+        'SWITCH' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Conditional::class, 'statementSwitch'],
+            'argumentCount' => '3+',
+        ],
+        'SYD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Depreciation::class, 'SYD'],
+            'argumentCount' => '4',
+        ],
+        'T' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'test'],
+            'argumentCount' => '1',
+        ],
+        'TAKE' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-3',
+        ],
+        'TAN' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Tangent::class, 'tan'],
+            'argumentCount' => '1',
+        ],
+        'TANH' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trig\Tangent::class, 'tanh'],
+            'argumentCount' => '1',
+        ],
+        'TBILLEQ' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\TreasuryBill::class, 'bondEquivalentYield'],
+            'argumentCount' => '3',
+        ],
+        'TBILLPRICE' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\TreasuryBill::class, 'price'],
+            'argumentCount' => '3',
+        ],
+        'TBILLYIELD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\TreasuryBill::class, 'yield'],
+            'argumentCount' => '3',
+        ],
+        'TDIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StudentT::class, 'distribution'],
+            'argumentCount' => '3',
+        ],
+        'T.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3',
+        ],
+        'T.DIST.2T' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'T.DIST.RT' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'TEXT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'TEXTFORMAT'],
+            'argumentCount' => '2',
+        ],
+        'TEXTAFTER' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'after'],
+            'argumentCount' => '2-6',
+        ],
+        'TEXTBEFORE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Extract::class, 'before'],
+            'argumentCount' => '2-6',
+        ],
+        'TEXTJOIN' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Concatenate::class, 'TEXTJOIN'],
+            'argumentCount' => '3+',
+        ],
+        'TEXTSPLIT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Text::class, 'split'],
+            'argumentCount' => '2-6',
+        ],
+        'THAIDAYOFWEEK' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAIDIGIT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAIMONTHOFYEAR' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAINUMSOUND' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAINUMSTRING' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAISTRINGLENGTH' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'THAIYEAR' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '?',
+        ],
+        'TIME' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Time::class, 'fromHMS'],
+            'argumentCount' => '3',
+        ],
+        'TIMEVALUE' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\TimeValue::class, 'fromString'],
+            'argumentCount' => '1',
+        ],
+        'TINV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StudentT::class, 'inverse'],
+            'argumentCount' => '2',
+        ],
+        'T.INV' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StudentT::class, 'inverse'],
+            'argumentCount' => '2',
+        ],
+        'T.INV.2T' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2',
+        ],
+        'TODAY' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Current::class, 'today'],
+            'argumentCount' => '0',
+        ],
+        'TOCOL' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1-3',
+        ],
+        'TOROW' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1-3',
+        ],
+        'TRANSPOSE' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Matrix::class, 'transpose'],
+            'argumentCount' => '1',
+        ],
+        'TREND' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Trends::class, 'TREND'],
+            'argumentCount' => '1-4',
+        ],
+        'TRIM' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Trim::class, 'spaces'],
+            'argumentCount' => '1',
+        ],
+        'TRIMMEAN' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Averages\Mean::class, 'trim'],
+            'argumentCount' => '2',
+        ],
+        'TRUE' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Boolean::class, 'TRUE'],
+            'argumentCount' => '0',
+        ],
+        'TRUNC' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [MathTrig\Trunc::class, 'evaluate'],
+            'argumentCount' => '1,2',
+        ],
+        'TTEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '4',
+        ],
+        'T.TEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '4',
+        ],
+        'TYPE' => [
+            'category' => Category::CATEGORY_INFORMATION,
+            'functionCall' => [Information\Value::class, 'type'],
+            'argumentCount' => '1',
+        ],
+        'UNICHAR' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CharacterConvert::class, 'character'],
+            'argumentCount' => '1',
+        ],
+        'UNICODE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CharacterConvert::class, 'code'],
+            'argumentCount' => '1',
+        ],
+        'UNIQUE' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\Unique::class, 'unique'],
+            'argumentCount' => '1+',
+        ],
+        'UPPER' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\CaseConvert::class, 'upper'],
+            'argumentCount' => '1',
+        ],
+        'USDOLLAR' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Dollar::class, 'format'],
+            'argumentCount' => '2',
+        ],
+        'VALUE' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'VALUE'],
+            'argumentCount' => '1',
+        ],
+        'VALUETOTEXT' => [
+            'category' => Category::CATEGORY_TEXT_AND_DATA,
+            'functionCall' => [TextData\Format::class, 'valueToText'],
+            'argumentCount' => '1,2',
+        ],
+        'VAR' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VAR'],
+            'argumentCount' => '1+',
+        ],
+        'VAR.P' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VARP'],
+            'argumentCount' => '1+',
+        ],
+        'VAR.S' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VAR'],
+            'argumentCount' => '1+',
+        ],
+        'VARA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VARA'],
+            'argumentCount' => '1+',
+        ],
+        'VARP' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VARP'],
+            'argumentCount' => '1+',
+        ],
+        'VARPA' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Variances::class, 'VARPA'],
+            'argumentCount' => '1+',
+        ],
+        'VDB' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '5-7',
+        ],
+        'VLOOKUP' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [LookupRef\VLookup::class, 'lookup'],
+            'argumentCount' => '3,4',
+        ],
+        'VSTACK' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '1+',
+        ],
+        'WEBSERVICE' => [
+            'category' => Category::CATEGORY_WEB,
+            'functionCall' => [Web\Service::class, 'webService'],
+            'argumentCount' => '1',
+        ],
+        'WEEKDAY' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Week::class, 'day'],
+            'argumentCount' => '1,2',
+        ],
+        'WEEKNUM' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\Week::class, 'number'],
+            'argumentCount' => '1,2',
+        ],
+        'WEIBULL' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Weibull::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'WEIBULL.DIST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\Weibull::class, 'distribution'],
+            'argumentCount' => '4',
+        ],
+        'WORKDAY' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\WorkDay::class, 'date'],
+            'argumentCount' => '2-3',
+        ],
+        'WORKDAY.INTL' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-4',
+        ],
+        'WRAPCOLS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-3',
+        ],
+        'WRAPROWS' => [
+            'category' => Category::CATEGORY_MATH_AND_TRIG,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2-3',
+        ],
+        'XIRR' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Variable\NonPeriodic::class, 'rate'],
+            'argumentCount' => '2,3',
+        ],
+        'XLOOKUP' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '3-6',
+        ],
+        'XNPV' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\CashFlow\Variable\NonPeriodic::class, 'presentValue'],
+            'argumentCount' => '3',
+        ],
+        'XMATCH' => [
+            'category' => Category::CATEGORY_LOOKUP_AND_REFERENCE,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '2,3',
+        ],
+        'XOR' => [
+            'category' => Category::CATEGORY_LOGICAL,
+            'functionCall' => [Logical\Operations::class, 'logicalXor'],
+            'argumentCount' => '1+',
+        ],
+        'YEAR' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\DateParts::class, 'year'],
+            'argumentCount' => '1',
+        ],
+        'YEARFRAC' => [
+            'category' => Category::CATEGORY_DATE_AND_TIME,
+            'functionCall' => [DateTimeExcel\YearFrac::class, 'fraction'],
+            'argumentCount' => '2,3',
+        ],
+        'YIELD' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Functions::class, 'DUMMY'],
+            'argumentCount' => '6,7',
+        ],
+        'YIELDDISC' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Yields::class, 'yieldDiscounted'],
+            'argumentCount' => '4,5',
+        ],
+        'YIELDMAT' => [
+            'category' => Category::CATEGORY_FINANCIAL,
+            'functionCall' => [Financial\Securities\Yields::class, 'yieldAtMaturity'],
+            'argumentCount' => '5,6',
+        ],
+        'ZTEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'zTest'],
+            'argumentCount' => '2-3',
+        ],
+        'Z.TEST' => [
+            'category' => Category::CATEGORY_STATISTICAL,
+            'functionCall' => [Statistical\Distributions\StandardNormal::class, 'zTest'],
+            'argumentCount' => '2-3',
+        ],
+    ];
+    /**
+     *    Internal functions used for special control purposes.
+     */
+    private static array $controlFunctions = [
+        'MKMATRIX' => [
+            'argumentCount' => '*',
+            'functionCall' => [Internal\MakeMatrix::class, 'make'],
+        ],
+        'NAME.ERROR' => [
+            'argumentCount' => '*',
+            'functionCall' => [ExcelError::class, 'NAME'],
+        ],
+        'WILDCARDMATCH' => [
+            'argumentCount' => '2',
+            'functionCall' => [Internal\WildcardMatch::class, 'compare'],
+        ],
+    ];
+    public function __construct(?Spreadsheet $spreadsheet = null)
+    {
+        $this->spreadsheet = $spreadsheet;
+        $this->cyclicReferenceStack = new CyclicReferenceStack();
+        $this->debugLog = new Logger($this->cyclicReferenceStack);
+        $this->branchPruner = new BranchPruner($this->branchPruningEnabled);
+        self::$referenceHelper = ReferenceHelper::getInstance();
+    }
+    private static function loadLocales(): void
+    {
+        $localeFileDirectory = __DIR__ . '/locale/';
+        $localeFileNames = glob($localeFileDirectory . '*', GLOB_ONLYDIR) ?: [];
+        foreach ($localeFileNames as $filename) {
+            $filename = substr($filename, strlen($localeFileDirectory));
+            if ($filename != 'en') {
+                self::$validLocaleLanguages[] = $filename;
+            }
+        }
+    }
+    /**
+     * Get an instance of this class.
+     *
+     * @param ?Spreadsheet $spreadsheet Injected spreadsheet for working with a PhpSpreadsheet Spreadsheet object,
+     *                                    or NULL to create a standalone calculation engine
+     */
+    public static function getInstance(?Spreadsheet $spreadsheet = null): self
+    {
+        if ($spreadsheet !== null) {
+            $instance = $spreadsheet->getCalculationEngine();
+            if (isset($instance)) {
+                return $instance;
+            }
+        }
+        if (!self::$instance) {
+            self::$instance = new self();
+        }
+        return self::$instance;
+    }
+    /**
+     * Flush the calculation cache for any existing instance of this class
+     *        but only if a Calculation instance exists.
+     */
+    public function flushInstance(): void
+    {
+        $this->clearCalculationCache();
+        $this->branchPruner->clearBranchStore();
+    }
+    /**
+     * Get the Logger for this calculation engine instance.
+     */
+    public function getDebugLog(): Logger
+    {
+        return $this->debugLog;
+    }
+    /**
+     * __clone implementation. Cloning should not be allowed in a Singleton!
+     */
+    final public function __clone()
+    {
+        throw new Exception('Cloning the calculation engine is not allowed!');
+    }
+    /**
+     * Return the locale-specific translation of TRUE.
+     *
+     * @return string locale-specific translation of TRUE
+     */
+    public static function getTRUE(): string
+    {
+        return self::$localeBoolean['TRUE'];
+    }
+    /**
+     * Return the locale-specific translation of FALSE.
+     *
+     * @return string locale-specific translation of FALSE
+     */
+    public static function getFALSE(): string
+    {
+        return self::$localeBoolean['FALSE'];
+    }
+    /**
+     * Set the Array Return Type (Array or Value of first element in the array).
+     *
+     * @param string $returnType Array return type
+     *
+     * @return bool Success or failure
+     */
+    public static function setArrayReturnType(string $returnType): bool
+    {
+        if (
+            ($returnType == self::RETURN_ARRAY_AS_VALUE)
+            || ($returnType == self::RETURN_ARRAY_AS_ERROR)
+            || ($returnType == self::RETURN_ARRAY_AS_ARRAY)
+        ) {
+            self::$returnArrayAsType = $returnType;
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Return the Array Return Type (Array or Value of first element in the array).
+     *
+     * @return string $returnType Array return type
+     */
+    public static function getArrayReturnType(): string
+    {
+        return self::$returnArrayAsType;
+    }
+    /**
+     * Is calculation caching enabled?
+     */
+    public function getCalculationCacheEnabled(): bool
+    {
+        return $this->calculationCacheEnabled;
+    }
+    /**
+     * Enable/disable calculation cache.
+     */
+    public function setCalculationCacheEnabled(bool $calculationCacheEnabled): void
+    {
+        $this->calculationCacheEnabled = $calculationCacheEnabled;
+        $this->clearCalculationCache();
+    }
+    /**
+     * Enable calculation cache.
+     */
+    public function enableCalculationCache(): void
+    {
+        $this->setCalculationCacheEnabled(true);
+    }
+    /**
+     * Disable calculation cache.
+     */
+    public function disableCalculationCache(): void
+    {
+        $this->setCalculationCacheEnabled(false);
+    }
+    /**
+     * Clear calculation cache.
+     */
+    public function clearCalculationCache(): void
+    {
+        $this->calculationCache = [];
+    }
+    /**
+     * Clear calculation cache for a specified worksheet.
+     */
+    public function clearCalculationCacheForWorksheet(string $worksheetName): void
+    {
+        if (isset($this->calculationCache[$worksheetName])) {
+            unset($this->calculationCache[$worksheetName]);
+        }
+    }
+    /**
+     * Rename calculation cache for a specified worksheet.
+     */
+    public function renameCalculationCacheForWorksheet(string $fromWorksheetName, string $toWorksheetName): void
+    {
+        if (isset($this->calculationCache[$fromWorksheetName])) {
+            $this->calculationCache[$toWorksheetName] = &$this->calculationCache[$fromWorksheetName];
+            unset($this->calculationCache[$fromWorksheetName]);
+        }
+    }
+    /**
+     * Enable/disable calculation cache.
+     */
+    public function setBranchPruningEnabled(mixed $enabled): void
+    {
+        $this->branchPruningEnabled = $enabled;
+        $this->branchPruner = new BranchPruner($this->branchPruningEnabled);
+    }
+    public function enableBranchPruning(): void
+    {
+        $this->setBranchPruningEnabled(true);
+    }
+    public function disableBranchPruning(): void
+    {
+        $this->setBranchPruningEnabled(false);
+    }
+    /**
+     * Get the currently defined locale code.
+     */
+    public function getLocale(): string
+    {
+        return self::$localeLanguage;
+    }
+    private function getLocaleFile(string $localeDir, string $locale, string $language, string $file): string
+    {
+        $localeFileName = $localeDir . str_replace('_', DIRECTORY_SEPARATOR, $locale)
+            . DIRECTORY_SEPARATOR . $file;
+        if (!file_exists($localeFileName)) {
+            $localeFileName = $localeDir . $language . DIRECTORY_SEPARATOR . $file;
+            if (!file_exists($localeFileName)) {
+                throw new Exception('Locale file not found');
+            }
+        }
+        return $localeFileName;
+    }
+    /**
+     * Set the locale code.
+     *
+     * @param string $locale The locale to use for formula translation, eg: 'en_us'
+     */
+    public function setLocale(string $locale): bool
+    {
+        $language = $locale = strtolower($locale);
+        if (str_contains($locale, '_')) {
+            [$language] = explode('_', $locale);
+        }
+        if (count(self::$validLocaleLanguages) == 1) {
+            self::loadLocales();
+        }
+        if (in_array($language, self::$validLocaleLanguages, true)) {
+            self::$localeFunctions = [];
+            self::$localeArgumentSeparator = ',';
+            self::$localeBoolean = ['TRUE' => 'TRUE', 'FALSE' => 'FALSE', 'NULL' => 'NULL'];
+            if ($locale !== 'en_us') {
+                $localeDir = implode(DIRECTORY_SEPARATOR, [__DIR__, 'locale', null]);
+                try {
+                    $functionNamesFile = $this->getLocaleFile($localeDir, $locale, $language, 'functions');
+                } catch (Exception $e) {
+                    return false;
+                }
+                $localeFunctions = file($functionNamesFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
+                foreach ($localeFunctions as $localeFunction) {
+                    [$localeFunction] = explode('##', $localeFunction); //    Strip out comments
+                    if (str_contains($localeFunction, '=')) {
+                        [$fName, $lfName] = array_map('trim', explode('=', $localeFunction));
+                        if ((str_starts_with($fName, '*') || isset(self::$phpSpreadsheetFunctions[$fName])) && ($lfName != '') && ($fName != $lfName)) {
+                            self::$localeFunctions[$fName] = $lfName;
+                        }
+                    }
+                }
+                if (isset(self::$localeFunctions['TRUE'])) {
+                    self::$localeBoolean['TRUE'] = self::$localeFunctions['TRUE'];
+                }
+                if (isset(self::$localeFunctions['FALSE'])) {
+                    self::$localeBoolean['FALSE'] = self::$localeFunctions['FALSE'];
+                }
+                try {
+                    $configFile = $this->getLocaleFile($localeDir, $locale, $language, 'config');
+                } catch (Exception) {
+                    return false;
+                }
+                $localeSettings = file($configFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
+                foreach ($localeSettings as $localeSetting) {
+                    [$localeSetting] = explode('##', $localeSetting); //    Strip out comments
+                    if (str_contains($localeSetting, '=')) {
+                        [$settingName, $settingValue] = array_map('trim', explode('=', $localeSetting));
+                        $settingName = strtoupper($settingName);
+                        if ($settingValue !== '') {
+                            switch ($settingName) {
+                                case 'ARGUMENTSEPARATOR':
+                                    self::$localeArgumentSeparator = $settingValue;
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+            self::$functionReplaceFromExcel = self::$functionReplaceToExcel
+            = self::$functionReplaceFromLocale = self::$functionReplaceToLocale = null;
+            self::$localeLanguage = $locale;
+            return true;
+        }
+        return false;
+    }
+    public static function translateSeparator(
+        string $fromSeparator,
+        string $toSeparator,
+        string $formula,
+        int &$inBracesLevel,
+        string $openBrace = self::FORMULA_OPEN_FUNCTION_BRACE,
+        string $closeBrace = self::FORMULA_CLOSE_FUNCTION_BRACE
+    ): string {
+        $strlen = mb_strlen($formula);
+        for ($i = 0; $i < $strlen; ++$i) {
+            $chr = mb_substr($formula, $i, 1);
+            switch ($chr) {
+                case $openBrace:
+                    ++$inBracesLevel;
+                    break;
+                case $closeBrace:
+                    --$inBracesLevel;
+                    break;
+                case $fromSeparator:
+                    if ($inBracesLevel > 0) {
+                        $formula = mb_substr($formula, 0, $i) . $toSeparator . mb_substr($formula, $i + 1);
+                    }
+            }
+        }
+        return $formula;
+    }
+    private static function translateFormulaBlock(
+        array $from,
+        array $to,
+        string $formula,
+        int &$inFunctionBracesLevel,
+        int &$inMatrixBracesLevel,
+        string $fromSeparator,
+        string $toSeparator
+    ): string {
+        $formula = (string) preg_replace($from, $to, $formula);
+        $formula = self::translateSeparator(';', '|', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
+        $formula = self::translateSeparator(',', '!', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
+        $formula = self::translateSeparator($fromSeparator, $toSeparator, $formula, $inFunctionBracesLevel);
+        $formula = self::translateSeparator('|', ';', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
+        $formula = self::translateSeparator('!', ',', $formula, $inMatrixBracesLevel, self::FORMULA_OPEN_MATRIX_BRACE, self::FORMULA_CLOSE_MATRIX_BRACE);
+        return $formula;
+    }
+    private static function translateFormula(array $from, array $to, string $formula, string $fromSeparator, string $toSeparator): string
+    {
+        if (self::$localeLanguage !== 'en_us') {
+            $inFunctionBracesLevel = 0;
+            $inMatrixBracesLevel = 0;
+            if (str_contains($formula, self::FORMULA_STRING_QUOTE)) {
+                $temp = explode(self::FORMULA_STRING_QUOTE, $formula);
+                $notWithinQuotes = false;
+                foreach ($temp as &$value) {
+                    $notWithinQuotes = $notWithinQuotes === false;
+                    if ($notWithinQuotes === true) {
+                        $value = self::translateFormulaBlock($from, $to, $value, $inFunctionBracesLevel, $inMatrixBracesLevel, $fromSeparator, $toSeparator);
+                    }
+                }
+                unset($value);
+                $formula = implode(self::FORMULA_STRING_QUOTE, $temp);
+            } else {
+                $formula = self::translateFormulaBlock($from, $to, $formula, $inFunctionBracesLevel, $inMatrixBracesLevel, $fromSeparator, $toSeparator);
+            }
+        }
+        return $formula;
+    }
+    /** @var ?array */
+    private static ?array $functionReplaceFromExcel;
+    /** @var ?array */
+    private static ?array $functionReplaceToLocale;
+    /**
+     * @deprecated 1.30.0 use translateFormulaToLocale() instead
+     *
+     * @codeCoverageIgnore
+     */
+    public function _translateFormulaToLocale(string $formula): string
+    {
+        return $this->translateFormulaToLocale($formula);
+    }
+    public function translateFormulaToLocale(string $formula): string
+    {
+        $formula = preg_replace(self::CALCULATION_REGEXP_STRIP_XLFN_XLWS, '', $formula) ?? '';
+        if (self::$functionReplaceFromExcel === null) {
+            self::$functionReplaceFromExcel = [];
+            foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
+                self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelFunctionName, '/') . '([\s]*\()/ui';
+            }
+            foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
+                self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/ui';
+            }
+        }
+        if (self::$functionReplaceToLocale === null) {
+            self::$functionReplaceToLocale = [];
+            foreach (self::$localeFunctions as $localeFunctionName) {
+                self::$functionReplaceToLocale[] = '$1' . trim($localeFunctionName) . '$2';
+            }
+            foreach (self::$localeBoolean as $localeBoolean) {
+                self::$functionReplaceToLocale[] = '$1' . trim($localeBoolean) . '$2';
+            }
+        }
+        return self::translateFormula(
+            self::$functionReplaceFromExcel,
+            self::$functionReplaceToLocale,
+            $formula,
+            ',',
+            self::$localeArgumentSeparator
+        );
+    }
+    /** @var ?array */
+    private static ?array $functionReplaceFromLocale;
+    /** @var ?array */
+    private static ?array $functionReplaceToExcel;
+    /**
+     * @deprecated 1.30.0 use translateFormulaToEnglish() instead
+     *
+     * @codeCoverageIgnore
+     */
+    public function _translateFormulaToEnglish(string $formula): string
+    {
+        return $this->translateFormulaToEnglish($formula);
+    }
+    public function translateFormulaToEnglish(string $formula): string
+    {
+        if (self::$functionReplaceFromLocale === null) {
+            self::$functionReplaceFromLocale = [];
+            foreach (self::$localeFunctions as $localeFunctionName) {
+                self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($localeFunctionName, '/') . '([\s]*\()/ui';
+            }
+            foreach (self::$localeBoolean as $excelBoolean) {
+                self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/ui';
+            }
+        }
+        if (self::$functionReplaceToExcel === null) {
+            self::$functionReplaceToExcel = [];
+            foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
+                self::$functionReplaceToExcel[] = '$1' . trim($excelFunctionName) . '$2';
+            }
+            foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
+                self::$functionReplaceToExcel[] = '$1' . trim($excelBoolean) . '$2';
+            }
+        }
+        return self::translateFormula(self::$functionReplaceFromLocale, self::$functionReplaceToExcel, $formula, self::$localeArgumentSeparator, ',');
+    }
+    public static function localeFunc(string $function): string
+    {
+        if (self::$localeLanguage !== 'en_us') {
+            $functionName = trim($function, '(');
+            if (isset(self::$localeFunctions[$functionName])) {
+                $brace = ($functionName != $function);
+                $function = self::$localeFunctions[$functionName];
+                if ($brace) {
+                    $function .= '(';
+                }
+            }
+        }
+        return $function;
+    }
+    /**
+     * Wrap string values in quotes.
+     */
+    public static function wrapResult(mixed $value): mixed
+    {
+        if (is_string($value)) {
+            if (preg_match('/^' . self::CALCULATION_REGEXP_ERROR . '$/i', $value, $match)) {
+                return $value;
+            }
+            return self::FORMULA_STRING_QUOTE . $value . self::FORMULA_STRING_QUOTE;
+        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
+            return ExcelError::NAN();
+        }
+        return $value;
+    }
+    /**
+     * Remove quotes used as a wrapper to identify string values.
+     */
+    public static function unwrapResult(mixed $value): mixed
+    {
+        if (is_string($value)) {
+            if ((isset($value[0])) && ($value[0] == self::FORMULA_STRING_QUOTE) && (substr($value, -1) == self::FORMULA_STRING_QUOTE)) {
+                return substr($value, 1, -1);
+            }
+        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
+            return ExcelError::NAN();
+        }
+        return $value;
+    }
+    /**
+     * Calculate cell value (using formula from a cell ID)
+     * Retained for backward compatibility.
+     *
+     * @param ?Cell $cell Cell to calculate
+     */
+    public function calculate(?Cell $cell = null): mixed
+    {
+        try {
+            return $this->calculateCellValue($cell);
+        } catch (\Exception $e) {
+            throw new Exception($e->getMessage());
+        }
+    }
+    /**
+     * Calculate the value of a cell formula.
+     *
+     * @param ?Cell $cell Cell to calculate
+     * @param bool $resetLog Flag indicating whether the debug log should be reset or not
+     */
+    public function calculateCellValue(?Cell $cell = null, bool $resetLog = true): mixed
+    {
+        if ($cell === null) {
+            return null;
+        }
+        $returnArrayAsType = self::$returnArrayAsType;
+        if ($resetLog) {
+            $this->formulaError = null;
+            $this->debugLog->clearLog();
+            $this->cyclicReferenceStack->clear();
+            $this->cyclicFormulaCounter = 1;
+            self::$returnArrayAsType = self::RETURN_ARRAY_AS_ARRAY;
+        }
+        $this->cellStack[] = [
+            'sheet' => $cell->getWorksheet()->getTitle(),
+            'cell' => $cell->getCoordinate(),
+        ];
+        $cellAddressAttempted = false;
+        $cellAddress = null;
+        try {
+            $result = self::unwrapResult($this->_calculateFormulaValue($cell->getValue(), $cell->getCoordinate(), $cell));
+            if ($this->spreadsheet === null) {
+                throw new Exception('null spreadsheet in calculateCellValue');
+            }
+            $cellAddressAttempted = true;
+            $cellAddress = array_pop($this->cellStack);
+            if ($cellAddress === null) {
+                throw new Exception('null cellAddress in calculateCellValue');
+            }
+            $testSheet = $this->spreadsheet->getSheetByName($cellAddress['sheet']);
+            if ($testSheet === null) {
+                throw new Exception('worksheet not found in calculateCellValue');
+            }
+            $testSheet->getCell($cellAddress['cell']);
+        } catch (\Exception $e) {
+            if (!$cellAddressAttempted) {
+                $cellAddress = array_pop($this->cellStack);
+            }
+            if ($this->spreadsheet !== null && is_array($cellAddress) && array_key_exists('sheet', $cellAddress)) {
+                $testSheet = $this->spreadsheet->getSheetByName($cellAddress['sheet']);
+                if ($testSheet !== null && array_key_exists('cell', $cellAddress)) {
+                    $testSheet->getCell($cellAddress['cell']);
+                }
+            }
+            throw new Exception($e->getMessage(), $e->getCode(), $e);
+        }
+        if ((is_array($result)) && (self::$returnArrayAsType != self::RETURN_ARRAY_AS_ARRAY)) {
+            self::$returnArrayAsType = $returnArrayAsType;
+            $testResult = Functions::flattenArray($result);
+            if (self::$returnArrayAsType == self::RETURN_ARRAY_AS_ERROR) {
+                return ExcelError::VALUE();
+            }
+            if (count($testResult) != 1) {
+                $r = array_keys($result);
+                $r = array_shift($r);
+                if (!is_numeric($r)) {
+                    return ExcelError::VALUE();
+                }
+                if (is_array($result[$r])) {
+                    $c = array_keys($result[$r]);
+                    $c = array_shift($c);
+                    if (!is_numeric($c)) {
+                        return ExcelError::VALUE();
+                    }
+                }
+            }
+            $result = array_shift($testResult);
+        }
+        self::$returnArrayAsType = $returnArrayAsType;
+        if ($result === null && $cell->getWorksheet()->getSheetView()->getShowZeros()) {
+            return 0;
+        } elseif ((is_float($result)) && ((is_nan($result)) || (is_infinite($result)))) {
+            return ExcelError::NAN();
+        }
+        return $result;
+    }
+    /**
+     * Validate and parse a formula string.
+     *
+     * @param string $formula Formula to parse
+     */
+    public function parseFormula(string $formula): array|bool
+    {
+        $formula = trim($formula);
+        if ((!isset($formula[0])) || ($formula[0] != '=')) {
+            return [];
+        }
+        $formula = ltrim(substr($formula, 1));
+        if (!isset($formula[0])) {
+            return [];
+        }
+        return $this->internalParseFormula($formula);
+    }
+    /**
+     * Calculate the value of a formula.
+     *
+     * @param string $formula Formula to parse
+     * @param ?string $cellID Address of the cell to calculate
+     * @param ?Cell $cell Cell to calculate
+     */
+    public function calculateFormula(string $formula, ?string $cellID = null, ?Cell $cell = null): mixed
+    {
+        $this->formulaError = null;
+        $this->debugLog->clearLog();
+        $this->cyclicReferenceStack->clear();
+        $resetCache = $this->getCalculationCacheEnabled();
+        if ($this->spreadsheet !== null && $cellID === null && $cell === null) {
+            $cellID = 'A1';
+            $cell = $this->spreadsheet->getActiveSheet()->getCell($cellID);
+        } else {
+            $this->calculationCacheEnabled = false;
+        }
+        try {
+            $result = self::unwrapResult($this->_calculateFormulaValue($formula, $cellID, $cell));
+        } catch (\Exception $e) {
+            throw new Exception($e->getMessage());
+        }
+        if ($this->spreadsheet === null) {
+            $this->calculationCacheEnabled = $resetCache;
+        }
+        return $result;
+    }
+    public function getValueFromCache(string $cellReference, mixed &$cellValue): bool
+    {
+        $this->debugLog->writeDebugLog('Testing cache value for cell %s', $cellReference);
+        if (($this->calculationCacheEnabled) && (isset($this->calculationCache[$cellReference]))) {
+            $this->debugLog->writeDebugLog('Retrieving value for cell %s from cache', $cellReference);
+            $cellValue = $this->calculationCache[$cellReference];
+            return true;
+        }
+        return false;
+    }
+    public function saveValueToCache(string $cellReference, mixed $cellValue): void
+    {
+        if ($this->calculationCacheEnabled) {
+            $this->calculationCache[$cellReference] = $cellValue;
+        }
+    }
+    /**
+     * Parse a cell formula and calculate its value.
+     *
+     * @param string $formula The formula to parse and calculate
+     * @param ?string $cellID The ID (e.g. A3) of the cell that we are calculating
+     * @param ?Cell $cell Cell to calculate
+     * @param bool $ignoreQuotePrefix If set to true, evaluate the formyla even if the referenced cell is quote prefixed
+     */
+    public function _calculateFormulaValue(string $formula, ?string $cellID = null, ?Cell $cell = null, bool $ignoreQuotePrefix = false): mixed
+    {
+        $cellValue = null;
+        if ($cell !== null && $ignoreQuotePrefix === false && $cell->getStyle()->getQuotePrefix() === true) {
+            return self::wrapResult((string) $formula);
+        }
+        if (preg_match('/^=\s*cmd\s*\|/miu', $formula) !== 0) {
+            return self::wrapResult($formula);
+        }
+        $formula = trim($formula);
+        if ($formula[0] != '=') {
+            return self::wrapResult($formula);
+        }
+        $formula = ltrim(substr($formula, 1));
+        if (!isset($formula[0])) {
+            return self::wrapResult($formula);
+        }
+        $pCellParent = ($cell !== null) ? $cell->getWorksheet() : null;
+        $wsTitle = ($pCellParent !== null) ? $pCellParent->getTitle() : "\x00Wrk";
+        $wsCellReference = $wsTitle . '!' . $cellID;
+        if (($cellID !== null) && ($this->getValueFromCache($wsCellReference, $cellValue))) {
+            return $cellValue;
+        }
+        $this->debugLog->writeDebugLog('Evaluating formula for cell %s', $wsCellReference);
+        if (($wsTitle[0] !== "\x00") && ($this->cyclicReferenceStack->onStack($wsCellReference))) {
+            if ($this->cyclicFormulaCount <= 0) {
+                $this->cyclicFormulaCell = '';
+                return $this->raiseFormulaError('Cyclic Reference in Formula');
+            } elseif ($this->cyclicFormulaCell === $wsCellReference) {
+                ++$this->cyclicFormulaCounter;
+                if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
+                    $this->cyclicFormulaCell = '';
+                    return $cellValue;
+                }
+            } elseif ($this->cyclicFormulaCell == '') {
+                if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
+                    return $cellValue;
+                }
+                $this->cyclicFormulaCell = $wsCellReference;
+            }
+        }
+        $this->debugLog->writeDebugLog('Formula for cell %s is %s', $wsCellReference, $formula);
+        $this->cyclicReferenceStack->push($wsCellReference);
+        $cellValue = $this->processTokenStack($this->internalParseFormula($formula, $cell), $cellID, $cell);
+        $this->cyclicReferenceStack->pop();
+        if ($cellID !== null) {
+            $this->saveValueToCache($wsCellReference, $cellValue);
+        }
+        return $cellValue;
+    }
+    /**
+     * Ensure that paired matrix operands are both matrices and of the same size.
+     *
+     * @param mixed $operand1 First matrix operand
+     * @param mixed $operand2 Second matrix operand
+     * @param int $resize Flag indicating whether the matrices should be resized to match
+     *                                        and (if so), whether the smaller dimension should grow or the
+     *                                        larger should shrink.
+     *                                            0 = no resize
+     *                                            1 = shrink to fit
+     *                                            2 = extend to fit
+     */
+    private static function checkMatrixOperands(mixed &$operand1, mixed &$operand2, int $resize = 1): array
+    {
+        if (!is_array($operand1)) {
+            [$matrixRows, $matrixColumns] = self::getMatrixDimensions($operand2);
+            $operand1 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand1));
+            $resize = 0;
+        } elseif (!is_array($operand2)) {
+            [$matrixRows, $matrixColumns] = self::getMatrixDimensions($operand1);
+            $operand2 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand2));
+            $resize = 0;
+        }
+        [$matrix1Rows, $matrix1Columns] = self::getMatrixDimensions($operand1);
+        [$matrix2Rows, $matrix2Columns] = self::getMatrixDimensions($operand2);
+        if (($matrix1Rows == $matrix2Columns) && ($matrix2Rows == $matrix1Columns)) {
+            $resize = 1;
+        }
+        if ($resize == 2) {
+            self::resizeMatricesExtend($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
+        } elseif ($resize == 1) {
+            self::resizeMatricesShrink($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
+        }
+        [$matrix1Rows, $matrix1Columns] = self::getMatrixDimensions($operand1);
+        [$matrix2Rows, $matrix2Columns] = self::getMatrixDimensions($operand2);
+        return [$matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns];
+    }
+    /**
+     * Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0.
+     *
+     * @param array $matrix matrix operand
+     *
+     * @return int[] An array comprising the number of rows, and number of columns
+     */
+    public static function getMatrixDimensions(array &$matrix): array
+    {
+        $matrixRows = count($matrix);
+        $matrixColumns = 0;
+        foreach ($matrix as $rowKey => $rowValue) {
+            if (!is_array($rowValue)) {
+                $matrix[$rowKey] = [$rowValue];
+                $matrixColumns = max(1, $matrixColumns);
+            } else {
+                $matrix[$rowKey] = array_values($rowValue);
+                $matrixColumns = max(count($rowValue), $matrixColumns);
+            }
+        }
+        $matrix = array_values($matrix);
+        return [$matrixRows, $matrixColumns];
+    }
+    /**
+     * Ensure that paired matrix operands are both matrices of the same size.
+     *
+     * @param array $matrix1 First matrix operand
+     * @param array $matrix2 Second matrix operand
+     * @param int $matrix1Rows Row size of first matrix operand
+     * @param int $matrix1Columns Column size of first matrix operand
+     * @param int $matrix2Rows Row size of second matrix operand
+     * @param int $matrix2Columns Column size of second matrix operand
+     */
+    private static function resizeMatricesShrink(array &$matrix1, array &$matrix2, int $matrix1Rows, int $matrix1Columns, int $matrix2Rows, int $matrix2Columns): void
+    {
+        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
+            if ($matrix2Rows < $matrix1Rows) {
+                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {
+                    unset($matrix1[$i]);
+                }
+            }
+            if ($matrix2Columns < $matrix1Columns) {
+                for ($i = 0; $i < $matrix1Rows; ++$i) {
+                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
+                        unset($matrix1[$i][$j]);
+                    }
+                }
+            }
+        }
+        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
+            if ($matrix1Rows < $matrix2Rows) {
+                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {
+                    unset($matrix2[$i]);
+                }
+            }
+            if ($matrix1Columns < $matrix2Columns) {
+                for ($i = 0; $i < $matrix2Rows; ++$i) {
+                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
+                        unset($matrix2[$i][$j]);
+                    }
+                }
+            }
+        }
+    }
+    /**
+     * Ensure that paired matrix operands are both matrices of the same size.
+     *
+     * @param array $matrix1 First matrix operand
+     * @param array $matrix2 Second matrix operand
+     * @param int $matrix1Rows Row size of first matrix operand
+     * @param int $matrix1Columns Column size of first matrix operand
+     * @param int $matrix2Rows Row size of second matrix operand
+     * @param int $matrix2Columns Column size of second matrix operand
+     */
+    private static function resizeMatricesExtend(array &$matrix1, array &$matrix2, int $matrix1Rows, int $matrix1Columns, int $matrix2Rows, int $matrix2Columns): void
+    {
+        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
+            if ($matrix2Columns < $matrix1Columns) {
+                for ($i = 0; $i < $matrix2Rows; ++$i) {
+                    $x = $matrix2[$i][$matrix2Columns - 1];
+                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
+                        $matrix2[$i][$j] = $x;
+                    }
+                }
+            }
+            if ($matrix2Rows < $matrix1Rows) {
+                $x = $matrix2[$matrix2Rows - 1];
+                for ($i = 0; $i < $matrix1Rows; ++$i) {
+                    $matrix2[$i] = $x;
+                }
+            }
+        }
+        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
+            if ($matrix1Columns < $matrix2Columns) {
+                for ($i = 0; $i < $matrix1Rows; ++$i) {
+                    $x = $matrix1[$i][$matrix1Columns - 1];
+                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
+                        $matrix1[$i][$j] = $x;
+                    }
+                }
+            }
+            if ($matrix1Rows < $matrix2Rows) {
+                $x = $matrix1[$matrix1Rows - 1];
+                for ($i = 0; $i < $matrix2Rows; ++$i) {
+                    $matrix1[$i] = $x;
+                }
+            }
+        }
+    }
+    /**
+     * Format details of an operand for display in the log (based on operand type).
+     *
+     * @param mixed $value First matrix operand
+     */
+    private function showValue(mixed $value): mixed
+    {
+        if ($this->debugLog->getWriteDebugLog()) {
+            $testArray = Functions::flattenArray($value);
+            if (count($testArray) == 1) {
+                $value = array_pop($testArray);
+            }
+            if (is_array($value)) {
+                $returnMatrix = [];
+                $pad = $rpad = ', ';
+                foreach ($value as $row) {
+                    if (is_array($row)) {
+                        $returnMatrix[] = implode($pad, array_map([$this, 'showValue'], $row));
+                        $rpad = '; ';
+                    } else {
+                        $returnMatrix[] = $this->showValue($row);
+                    }
+                }
+                return '{ ' . implode($rpad, $returnMatrix) . ' }';
+            } elseif (is_string($value) && (trim($value, self::FORMULA_STRING_QUOTE) == $value)) {
+                return self::FORMULA_STRING_QUOTE . $value . self::FORMULA_STRING_QUOTE;
+            } elseif (is_bool($value)) {
+                return ($value) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
+            } elseif ($value === null) {
+                return self::$localeBoolean['NULL'];
+            }
+        }
+        return Functions::flattenSingleValue($value);
+    }
+    /**
+     * Format type and details of an operand for display in the log (based on operand type).
+     *
+     * @param mixed $value First matrix operand
+     */
+    private function showTypeDetails(mixed $value): ?string
+    {
+        if ($this->debugLog->getWriteDebugLog()) {
+            $testArray = Functions::flattenArray($value);
+            if (count($testArray) == 1) {
+                $value = array_pop($testArray);
+            }
+            if ($value === null) {
+                return 'a NULL value';
+            } elseif (is_float($value)) {
+                $typeString = 'a floating point number';
+            } elseif (is_int($value)) {
+                $typeString = 'an integer number';
+            } elseif (is_bool($value)) {
+                $typeString = 'a boolean';
+            } elseif (is_array($value)) {
+                $typeString = 'a matrix';
+            } else {
+                if ($value == '') {
+                    return 'an empty string';
+                } elseif ($value[0] == '#') {
+                    return 'a ' . $value . ' error';
+                }
+                $typeString = 'a string';
+            }
+            return $typeString . ' with a value of ' . $this->showValue($value);
+        }
+        return null;
+    }
+    /**
+     * @return false|string False indicates an error
+     */
+    private function convertMatrixReferences(string $formula): false|string
+    {
+        static $matrixReplaceFrom = [self::FORMULA_OPEN_MATRIX_BRACE, ';', self::FORMULA_CLOSE_MATRIX_BRACE];
+        static $matrixReplaceTo = ['MKMATRIX(MKMATRIX(', '),MKMATRIX(', '))'];
+        if (str_contains($formula, self::FORMULA_OPEN_MATRIX_BRACE)) {
+            if (str_contains($formula, self::FORMULA_STRING_QUOTE)) {
+                $temp = explode(self::FORMULA_STRING_QUOTE, $formula);
+                $openCount = $closeCount = 0;
+                $notWithinQuotes = false;
+                foreach ($temp as &$value) {
+                    $notWithinQuotes = $notWithinQuotes === false;
+                    if ($notWithinQuotes === true) {
+                        $openCount += substr_count($value, self::FORMULA_OPEN_MATRIX_BRACE);
+                        $closeCount += substr_count($value, self::FORMULA_CLOSE_MATRIX_BRACE);
+                        $value = str_replace($matrixReplaceFrom, $matrixReplaceTo, $value);
+                    }
+                }
+                unset($value);
+                $formula = implode(self::FORMULA_STRING_QUOTE, $temp);
+            } else {
+                $openCount = substr_count($formula, self::FORMULA_OPEN_MATRIX_BRACE);
+                $closeCount = substr_count($formula, self::FORMULA_CLOSE_MATRIX_BRACE);
+                $formula = str_replace($matrixReplaceFrom, $matrixReplaceTo, $formula);
+            }
+            if ($openCount < $closeCount) {
+                if ($openCount > 0) {
+                    return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '}'");
+                }
+                return $this->raiseFormulaError("Formula Error: Unexpected '}' encountered");
+            } elseif ($openCount > $closeCount) {
+                if ($closeCount > 0) {
+                    return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '{'");
+                }
+                return $this->raiseFormulaError("Formula Error: Unexpected '{' encountered");
+            }
+        }
+        return $formula;
+    }
+    /**
+     *    Binary Operators.
+     *    These operators always work on two values.
+     *    Array key is the operator, the value indicates whether this is a left or right associative operator.
+     */
+    private static array $operatorAssociativity = [
+        '^' => 0, //    Exponentiation
+        '*' => 0, '/' => 0, //    Multiplication and Division
+        '+' => 0, '-' => 0, //    Addition and Subtraction
+        '&' => 0, //    Concatenation
+        '∪' => 0, '∩' => 0, ':' => 0, //    Union, Intersect and Range
+        '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
+    ];
+    /**
+     *    Comparison (Boolean) Operators.
+     *    These operators work on two values, but always return a boolean result.
+     */
+    private static array $comparisonOperators = ['>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true];
+    /**
+     *    Operator Precedence.
+     *    This list includes all valid operators, whether binary (including boolean) or unary (such as %).
+     *    Array key is the operator, the value is its precedence.
+     */
+    private static array $operatorPrecedence = [
+        ':' => 9, //    Range
+        '∩' => 8, //    Intersect
+        '∪' => 7, //    Union
+        '~' => 6, //    Negation
+        '%' => 5, //    Percentage
+        '^' => 4, //    Exponentiation
+        '*' => 3, '/' => 3, //    Multiplication and Division
+        '+' => 2, '-' => 2, //    Addition and Subtraction
+        '&' => 1, //    Concatenation
+        '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
+    ];
+    /**
+     * @return array<int, mixed>|false
+     */
+    private function internalParseFormula(string $formula, ?Cell $cell = null): bool|array
+    {
+        if (($formula = $this->convertMatrixReferences(trim($formula))) === false) {
+            return false;
+        }
+        $pCellParent = ($cell !== null) ? $cell->getWorksheet() : null;
+        $regexpMatchString = '/^((?<string>' . self::CALCULATION_REGEXP_STRING
+                                . ')|(?<function>' . self::CALCULATION_REGEXP_FUNCTION
+                                . ')|(?<cellRef>' . self::CALCULATION_REGEXP_CELLREF
+                                . ')|(?<colRange>' . self::CALCULATION_REGEXP_COLUMN_RANGE
+                                . ')|(?<rowRange>' . self::CALCULATION_REGEXP_ROW_RANGE
+                                . ')|(?<number>' . self::CALCULATION_REGEXP_NUMBER
+                                . ')|(?<openBrace>' . self::CALCULATION_REGEXP_OPENBRACE
+                                . ')|(?<structuredReference>' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE
+                                . ')|(?<definedName>' . self::CALCULATION_REGEXP_DEFINEDNAME
+                                . ')|(?<error>' . self::CALCULATION_REGEXP_ERROR
+                                . '))/sui';
+        $index = 0;
+        $stack = new Stack($this->branchPruner);
+        $output = [];
+        $expectingOperator = false; //    We use this test in syntax-checking the expression to determine when a
+        $expectingOperand = false; //    We use this test in syntax-checking the expression to determine whether an operand
+        while (true) {
+            $this->branchPruner->initialiseForLoop();
+            $opCharacter = $formula[$index]; //    Get the first character of the value at the current index position
+            if ((isset(self::$comparisonOperators[$opCharacter])) && (strlen($formula) > $index) && isset($formula[$index + 1], self::$comparisonOperators[$formula[$index + 1]])) {
+                $opCharacter .= $formula[++$index];
+            }
+            $isOperandOrFunction = (bool) preg_match($regexpMatchString, substr($formula, $index), $match);
+            $expectingOperatorCopy = $expectingOperator;
+            if ($opCharacter === '-' && !$expectingOperator) {                //    Is it a negation instead of a minus?
+                $stack->push('Unary Operator', '~');
+                ++$index; //        and drop the negation symbol
+            } elseif ($opCharacter === '%' && $expectingOperator) {
+                $stack->push('Unary Operator', '%');
+                ++$index;
+            } elseif ($opCharacter === '+' && !$expectingOperator) {            //    Positive (unary plus rather than binary operator plus) can be discarded?
+                ++$index; //    Drop the redundant plus symbol
+            } elseif ((($opCharacter === '~') || ($opCharacter === '∩') || ($opCharacter === '∪')) && (!$isOperandOrFunction)) {
+                return $this->raiseFormulaError("Formula Error: Illegal character '~'"); //        on the stack but not in the input expression
+            } elseif ((isset(self::CALCULATION_OPERATORS[$opCharacter]) || $isOperandOrFunction) && $expectingOperator) {    //    Are we putting an operator on the stack?
+                while (
+                    $stack->count() > 0
+                    && ($o2 = $stack->last())
+                    && isset(self::CALCULATION_OPERATORS[$o2['value']])
+                    && @(self::$operatorAssociativity[$opCharacter] ? self::$operatorPrecedence[$opCharacter] < self::$operatorPrecedence[$o2['value']] : self::$operatorPrecedence[$opCharacter] <= self::$operatorPrecedence[$o2['value']])
+                ) {
+                    $output[] = $stack->pop(); //    Swap operands and higher precedence operators from the stack to the output
+                }
+                $stack->push('Binary Operator', $opCharacter);
+                ++$index;
+                $expectingOperator = false;
+            } elseif ($opCharacter === ')' && $expectingOperator) { //    Are we expecting to close a parenthesis?
+                $expectingOperand = false;
+                while (($o2 = $stack->pop()) && $o2['value'] !== '(') { //    Pop off the stack back to the last (
+                    $output[] = $o2;
+                }
+                $d = $stack->last(2);
+                $this->branchPruner->decrementDepth();
+                if (is_array($d) && preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $d['value'], $matches)) {
+                    try {
+                        $this->branchPruner->closingBrace($d['value']);
+                    } catch (Exception $e) {
+                        return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
+                    }
+                    $functionName = $matches[1]; //    Get the function name
+                    $d = $stack->pop();
+                    $argumentCount = $d['value'] ?? 0; //    See how many arguments there were (argument count is the next value stored on the stack)
+                    $output[] = $d; //    Dump the argument count on the output
+                    $output[] = $stack->pop(); //    Pop the function and push onto the output
+                    if (isset(self::$controlFunctions[$functionName])) {
+                        $expectedArgumentCount = self::$controlFunctions[$functionName]['argumentCount'];
+                    } elseif (isset(self::$phpSpreadsheetFunctions[$functionName])) {
+                        $expectedArgumentCount = self::$phpSpreadsheetFunctions[$functionName]['argumentCount'];
+                    } else {    // did we somehow push a non-function on the stack? this should never happen
+                        return $this->raiseFormulaError('Formula Error: Internal error, non-function on stack');
+                    }
+                    $argumentCountError = false;
+                    $expectedArgumentCountString = null;
+                    if (is_numeric($expectedArgumentCount)) {
+                        if ($expectedArgumentCount < 0) {
+                            if ($argumentCount > abs($expectedArgumentCount)) {
+                                $argumentCountError = true;
+                                $expectedArgumentCountString = 'no more than ' . abs($expectedArgumentCount);
+                            }
+                        } else {
+                            if ($argumentCount != $expectedArgumentCount) {
+                                $argumentCountError = true;
+                                $expectedArgumentCountString = $expectedArgumentCount;
+                            }
+                        }
+                    } elseif ($expectedArgumentCount != '*') {
+                        preg_match('/(\d*)([-+,])(\d*)/', $expectedArgumentCount, $argMatch);
+                        switch ($argMatch[2] ?? '') {
+                            case '+':
+                                if ($argumentCount < $argMatch[1]) {
+                                    $argumentCountError = true;
+                                    $expectedArgumentCountString = $argMatch[1] . ' or more ';
+                                }
+                                break;
+                            case '-':
+                                if (($argumentCount < $argMatch[1]) || ($argumentCount > $argMatch[3])) {
+                                    $argumentCountError = true;
+                                    $expectedArgumentCountString = 'between ' . $argMatch[1] . ' and ' . $argMatch[3];
+                                }
+                                break;
+                            case ',':
+                                if (($argumentCount != $argMatch[1]) && ($argumentCount != $argMatch[3])) {
+                                    $argumentCountError = true;
+                                    $expectedArgumentCountString = 'either ' . $argMatch[1] . ' or ' . $argMatch[3];
+                                }
+                                break;
+                        }
+                    }
+                    if ($argumentCountError) {
+                        return $this->raiseFormulaError("Formula Error: Wrong number of arguments for $functionName() function: $argumentCount given, " . $expectedArgumentCountString . ' expected');
+                    }
+                }
+                ++$index;
+            } elseif ($opCharacter === ',') { // Is this the separator for function arguments?
+                try {
+                    $this->branchPruner->argumentSeparator();
+                } catch (Exception $e) {
+                    return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
+                }
+                while (($o2 = $stack->pop()) && $o2['value'] !== '(') {        //    Pop off the stack back to the last (
+                    $output[] = $o2; // pop the argument expression stuff and push onto the output
+                }
+                if (($expectingOperand) || (!$expectingOperator)) {
+                    $output[] = $stack->getStackItem('Empty Argument', null, 'NULL');
+                }
+                $d = $stack->last(2);
+                if (!preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $d['value'] ?? '', $matches)) {
+                    return $this->raiseFormulaError('Formula Error: Unexpected ,');
+                }
+                /** @var array $d */
+                $d = $stack->pop();
+                ++$d['value']; // increment the argument count
+                $stack->pushStackItem($d);
+                $stack->push('Brace', '('); // put the ( back on, we'll need to pop back to it again
+                $expectingOperator = false;
+                $expectingOperand = true;
+                ++$index;
+            } elseif ($opCharacter === '(' && !$expectingOperator) {
+                $this->branchPruner->incrementDepth();
+                $stack->push('Brace', '(', null);
+                ++$index;
+            } elseif ($isOperandOrFunction && !$expectingOperatorCopy) {
+                $expectingOperator = true;
+                $expectingOperand = false;
+                $val = $match[1];
+                $length = strlen($val);
+                if (preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $val, $matches)) {
+                    $val = (string) preg_replace('/\s/u', '', $val);
+                    if (isset(self::$phpSpreadsheetFunctions[strtoupper($matches[1])]) || isset(self::$controlFunctions[strtoupper($matches[1])])) {    // it's a function
+                        $valToUpper = strtoupper($val);
+                    } else {
+                        $valToUpper = 'NAME.ERROR(';
+                    }
+                    $this->branchPruner->functionCall($valToUpper);
+                    $stack->push('Function', $valToUpper);
+                    $ax = preg_match('/^\s*\)/u', substr($formula, $index + $length));
+                    if ($ax) {
+                        $stack->push('Operand Count for Function ' . $valToUpper . ')', 0);
+                        $expectingOperator = true;
+                    } else {
+                        $stack->push('Operand Count for Function ' . $valToUpper . ')', 1);
+                        $expectingOperator = false;
+                    }
+                    $stack->push('Brace', '(');
+                } elseif (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $val, $matches)) {
+                    $testPrevOp = $stack->last(1);
+                    if ($testPrevOp !== null && $testPrevOp['value'] === ':') {
+                        if ($matches[2] === '') {
+                            $rangeStartCellRef = $output[count($output) - 1]['value'] ?? '';
+                            if ($rangeStartCellRef === ':') {
+                                $rangeStartCellRef = $output[count($output) - 2]['value'] ?? '';
+                            }
+                            preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $rangeStartCellRef, $rangeStartMatches);
+                            if (array_key_exists(2, $rangeStartMatches)) {
+                                if ($rangeStartMatches[2] > '') {
+                                    $val = $rangeStartMatches[2] . '!' . $val;
+                                }
+                            } else {
+                                $val = ExcelError::REF();
+                            }
+                        } else {
+                            $rangeStartCellRef = $output[count($output) - 1]['value'] ?? '';
+                            if ($rangeStartCellRef === ':') {
+                                $rangeStartCellRef = $output[count($output) - 2]['value'] ?? '';
+                            }
+                            preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/miu', $rangeStartCellRef, $rangeStartMatches);
+                            if ($rangeStartMatches[2] !== $matches[2]) {
+                                return $this->raiseFormulaError('3D Range references are not yet supported');
+                            }
+                        }
+                    } elseif (!str_contains($val, '!') && $pCellParent !== null) {
+                        $worksheet = $pCellParent->getTitle();
+                        $val = "'{$worksheet}'!{$val}";
+                    }
+                    $val = str_replace(["''", '""'], ["'", '"'], $val);
+                    $outputItem = $stack->getStackItem('Cell Reference', $val, $val);
+                    $output[] = $outputItem;
+                } elseif (preg_match('/^' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE . '$/miu', $val, $matches)) {
+                    try {
+                        $structuredReference = Operands\StructuredReference::fromParser($formula, $index, $matches);
+                    } catch (Exception $e) {
+                        return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
+                    }
+                    $val = $structuredReference->value();
+                    $length = strlen($val);
+                    $outputItem = $stack->getStackItem(Operands\StructuredReference::NAME, $structuredReference, null);
+                    $output[] = $outputItem;
+                    $expectingOperator = true;
+                } else {
+                    $localeConstant = false;
+                    $stackItemType = 'Value';
+                    $stackItemReference = null;
+                    $testPrevOp = $stack->last(1);
+                    if ($testPrevOp !== null && $testPrevOp['value'] === ':') {
+                        $stackItemType = 'Cell Reference';
+                        if (
+                            !is_numeric($val)
+                            && ((ctype_alpha($val) === false || strlen($val) > 3))
+                            && (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '$/mui', $val) !== false)
+                            && ($this->spreadsheet === null || $this->spreadsheet->getNamedRange($val) !== null)
+                        ) {
+                            $namedRange = ($this->spreadsheet === null) ? null : $this->spreadsheet->getNamedRange($val);
+                            if ($namedRange !== null) {
+                                $stackItemType = 'Defined Name';
+                                $address = str_replace('$', '', $namedRange->getValue());
+                                $stackItemReference = $val;
+                                if (str_contains($address, ':')) {
+                                    $fromTo = explode(':', $address);
+                                    $to = array_pop($fromTo);
+                                    foreach ($fromTo as $from) {
+                                        $output[] = $stack->getStackItem($stackItemType, $from, $stackItemReference);
+                                        $output[] = $stack->getStackItem('Binary Operator', ':');
+                                    }
+                                    $address = $to;
+                                }
+                                $val = $address;
+                            }
+                        } elseif ($val === ExcelError::REF()) {
+                            $stackItemReference = $val;
+                        } else {
+                            /** @var non-empty-string $startRowColRef */
+                            $startRowColRef = $output[count($output) - 1]['value'] ?? '';
+                            [$rangeWS1, $startRowColRef] = Worksheet::extractSheetTitle($startRowColRef, true);
+                            $rangeSheetRef = $rangeWS1;
+                            if ($rangeWS1 !== '') {
+                                $rangeWS1 .= '!';
+                            }
+                            $rangeSheetRef = trim($rangeSheetRef, "'");
+                            [$rangeWS2, $val] = Worksheet::extractSheetTitle($val, true);
+                            if ($rangeWS2 !== '') {
+                                $rangeWS2 .= '!';
+                            } else {
+                                $rangeWS2 = $rangeWS1;
+                            }
+                            $refSheet = $pCellParent;
+                            if ($pCellParent !== null && $rangeSheetRef !== '' && $rangeSheetRef !== $pCellParent->getTitle()) {
+                                $refSheet = $pCellParent->getParentOrThrow()->getSheetByName($rangeSheetRef);
+                            }
+                            if (ctype_digit($val) && $val <= 1048576) {
+                                $stackItemType = 'Row Reference';
+                                /** @var int $valx */
+                                $valx = $val;
+                                $endRowColRef = ($refSheet !== null) ? $refSheet->getHighestDataColumn($valx) : AddressRange::MAX_COLUMN; //    Max 16,384 columns for Excel2007
+                                $val = "{$rangeWS2}{$endRowColRef}{$val}";
+                            } elseif (ctype_alpha($val) && strlen($val ?? '') <= 3) {
+                                $stackItemType = 'Column Reference';
+                                $endRowColRef = ($refSheet !== null) ? $refSheet->getHighestDataRow($val) : AddressRange::MAX_ROW; //    Max 1,048,576 rows for Excel2007
+                                $val = "{$rangeWS2}{$val}{$endRowColRef}";
+                            }
+                            $stackItemReference = $val;
+                        }
+                    } elseif ($opCharacter === self::FORMULA_STRING_QUOTE) {
+                        $val = self::wrapResult(str_replace('""', self::FORMULA_STRING_QUOTE, self::unwrapResult($val)));
+                    } elseif (isset(self::$excelConstants[trim(strtoupper($val))])) {
+                        $stackItemType = 'Constant';
+                        $excelConstant = trim(strtoupper($val));
+                        $val = self::$excelConstants[$excelConstant];
+                        $stackItemReference = $excelConstant;
+                    } elseif (($localeConstant = array_search(trim(strtoupper($val)), self::$localeBoolean)) !== false) {
+                        $stackItemType = 'Constant';
+                        $val = self::$excelConstants[$localeConstant];
+                        $stackItemReference = $localeConstant;
+                    } elseif (
+                        preg_match('/^' . self::CALCULATION_REGEXP_ROW_RANGE . '/miu', substr($formula, $index), $rowRangeReference)
+                    ) {
+                        $val = $rowRangeReference[1];
+                        $length = strlen($rowRangeReference[1]);
+                        $stackItemType = 'Row Reference';
+                        $val = str_replace(["''", '""'], ["'", '"'], $val);
+                        $column = 'A';
+                        if (($testPrevOp !== null && $testPrevOp['value'] === ':') && $pCellParent !== null) {
+                            $column = $pCellParent->getHighestDataColumn($val);
+                        }
+                        $val = "{$rowRangeReference[2]}{$column}{$rowRangeReference[7]}";
+                        $stackItemReference = $val;
+                    } elseif (
+                        preg_match('/^' . self::CALCULATION_REGEXP_COLUMN_RANGE . '/miu', substr($formula, $index), $columnRangeReference)
+                    ) {
+                        $val = $columnRangeReference[1];
+                        $length = strlen($val);
+                        $stackItemType = 'Column Reference';
+                        $val = str_replace(["''", '""'], ["'", '"'], $val);
+                        $row = '1';
+                        if (($testPrevOp !== null && $testPrevOp['value'] === ':') && $pCellParent !== null) {
+                            $row = $pCellParent->getHighestDataRow($val);
+                        }
+                        $val = "{$val}{$row}";
+                        $stackItemReference = $val;
+                    } elseif (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '.*/miu', $val, $match)) {
+                        $stackItemType = 'Defined Name';
+                        $stackItemReference = $val;
+                    } elseif (is_numeric($val)) {
+                        if ((str_contains((string) $val, '.')) || (stripos((string) $val, 'e') !== false) || ($val > PHP_INT_MAX) || ($val < -PHP_INT_MAX)) {
+                            $val = (float) $val;
+                        } else {
+                            $val = (int) $val;
+                        }
+                    }
+                    $details = $stack->getStackItem($stackItemType, $val, $stackItemReference);
+                    if ($localeConstant) {
+                        $details['localeValue'] = $localeConstant;
+                    }
+                    $output[] = $details;
+                }
+                $index += $length;
+            } elseif ($opCharacter === '$') { // absolute row or column range
+                ++$index;
+            } elseif ($opCharacter === ')') { // miscellaneous error checking
+                if ($expectingOperand) {
+                    $output[] = $stack->getStackItem('Empty Argument', null, 'NULL');
+                    $expectingOperand = false;
+                    $expectingOperator = true;
+                } else {
+                    return $this->raiseFormulaError("Formula Error: Unexpected ')'");
+                }
+            } elseif (isset(self::CALCULATION_OPERATORS[$opCharacter]) && !$expectingOperator) {
+                return $this->raiseFormulaError("Formula Error: Unexpected operator '$opCharacter'");
+            } else {    // I don't even want to know what you did to get here
+                return $this->raiseFormulaError('Formula Error: An unexpected error occurred');
+            }
+            if ($index == strlen($formula)) {
+                if ((isset(self::CALCULATION_OPERATORS[$opCharacter])) && ($opCharacter != '%')) {
+                    return $this->raiseFormulaError("Formula Error: Operator '$opCharacter' has no operands");
+                }
+                break;
+            }
+            while (($formula[$index] === "\n") || ($formula[$index] === "\r")) {
+                ++$index;
+            }
+            if ($formula[$index] === ' ') {
+                while ($formula[$index] === ' ') {
+                    ++$index;
+                }
+                $countOutputMinus1 = count($output) - 1;
+                if (
+                    ($expectingOperator)
+                    && array_key_exists($countOutputMinus1, $output)
+                    && is_array($output[$countOutputMinus1])
+                    && array_key_exists('type', $output[$countOutputMinus1])
+                    && (
+                        (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '.*/miu', substr($formula, $index), $match))
+                            && ($output[$countOutputMinus1]['type'] === 'Cell Reference')
+                        || (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '.*/miu', substr($formula, $index), $match))
+                            && ($output[$countOutputMinus1]['type'] === 'Defined Name' || $output[$countOutputMinus1]['type'] === 'Value')
+                        || (preg_match('/^' . self::CALCULATION_REGEXP_STRUCTURED_REFERENCE . '.*/miu', substr($formula, $index), $match))
+                            && ($output[$countOutputMinus1]['type'] === Operands\StructuredReference::NAME || $output[$countOutputMinus1]['type'] === 'Value')
+                    )
+                ) {
+                    while (
+                        $stack->count() > 0
+                        && ($o2 = $stack->last())
+                        && isset(self::CALCULATION_OPERATORS[$o2['value']])
+                        && @(self::$operatorAssociativity[$opCharacter] ? self::$operatorPrecedence[$opCharacter] < self::$operatorPrecedence[$o2['value']] : self::$operatorPrecedence[$opCharacter] <= self::$operatorPrecedence[$o2['value']])
+                    ) {
+                        $output[] = $stack->pop(); //    Swap operands and higher precedence operators from the stack to the output
+                    }
+                    $stack->push('Binary Operator', '∩'); //    Put an Intersect Operator on the stack
+                    $expectingOperator = false;
+                }
+            }
+        }
+        while (($op = $stack->pop()) !== null) {
+            if ((is_array($op) && $op['value'] == '(')) {
+                return $this->raiseFormulaError("Formula Error: Expecting ')'"); // if there are any opening braces on the stack, then braces were unbalanced
+            }
+            $output[] = $op;
+        }
+        return $output;
+    }
+    private static function dataTestReference(array &$operandData): mixed
+    {
+        $operand = $operandData['value'];
+        if (($operandData['reference'] === null) && (is_array($operand))) {
+            $rKeys = array_keys($operand);
+            $rowKey = array_shift($rKeys);
+            if (is_array($operand[$rowKey]) === false) {
+                $operandData['value'] = $operand[$rowKey];
+                return $operand[$rowKey];
+            }
+            $cKeys = array_keys(array_keys($operand[$rowKey]));
+            $colKey = array_shift($cKeys);
+            if (ctype_upper("$colKey")) {
+                $operandData['reference'] = $colKey . $rowKey;
+            }
+        }
+        return $operand;
+    }
+    /**
+     * @return array<int, mixed>|false
+     */
+    private function processTokenStack(mixed $tokens, ?string $cellID = null, ?Cell $cell = null)
+    {
+        if ($tokens === false) {
+            return false;
+        }
+        $pCellWorksheet = ($cell !== null) ? $cell->getWorksheet() : null;
+        $pCellParent = ($cell !== null) ? $cell->getParent() : null;
+        $stack = new Stack($this->branchPruner);
+        $fakedForBranchPruning = [];
+        $branchStore = [];
+        foreach ($tokens as $tokenData) {
+            $token = $tokenData['value'];
+            $storeKey = $tokenData['storeKey'] ?? null;
+            if ($this->branchPruningEnabled && isset($tokenData['onlyIf'])) {
+                $onlyIfStoreKey = $tokenData['onlyIf'];
+                $storeValue = $branchStore[$onlyIfStoreKey] ?? null;
+                $storeValueAsBool = ($storeValue === null)
+                    ? true : (bool) Functions::flattenSingleValue($storeValue);
+                if (is_array($storeValue)) {
+                    $wrappedItem = end($storeValue);
+                    $storeValue = is_array($wrappedItem) ? end($wrappedItem) : $wrappedItem;
+                }
+                if (
+                    (isset($storeValue) || $tokenData['reference'] === 'NULL')
+                    && (!$storeValueAsBool || Information\ErrorValue::isError($storeValue) || ($storeValue === 'Pruned branch'))
+                ) {
+                    if (!isset($fakedForBranchPruning['onlyIf-' . $onlyIfStoreKey])) {
+                        $stack->push('Value', 'Pruned branch (only if ' . $onlyIfStoreKey . ') ' . $token);
+                        $fakedForBranchPruning['onlyIf-' . $onlyIfStoreKey] = true;
+                    }
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = 'Pruned branch';
+                        $fakedForBranchPruning['onlyIfNot-' . $storeKey] = true;
+                        $fakedForBranchPruning['onlyIf-' . $storeKey] = true;
+                    }
+                    continue;
+                }
+            }
+            if ($this->branchPruningEnabled && isset($tokenData['onlyIfNot'])) {
+                $onlyIfNotStoreKey = $tokenData['onlyIfNot'];
+                $storeValue = $branchStore[$onlyIfNotStoreKey] ?? null;
+                $storeValueAsBool = ($storeValue === null)
+                    ? true : (bool) Functions::flattenSingleValue($storeValue);
+                if (is_array($storeValue)) {
+                    $wrappedItem = end($storeValue);
+                    $storeValue = is_array($wrappedItem) ? end($wrappedItem) : $wrappedItem;
+                }
+                if (
+                    (isset($storeValue) || $tokenData['reference'] === 'NULL')
+                    && ($storeValueAsBool || Information\ErrorValue::isError($storeValue) || ($storeValue === 'Pruned branch'))
+                ) {
+                    if (!isset($fakedForBranchPruning['onlyIfNot-' . $onlyIfNotStoreKey])) {
+                        $stack->push('Value', 'Pruned branch (only if not ' . $onlyIfNotStoreKey . ') ' . $token);
+                        $fakedForBranchPruning['onlyIfNot-' . $onlyIfNotStoreKey] = true;
+                    }
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = 'Pruned branch';
+                        $fakedForBranchPruning['onlyIfNot-' . $storeKey] = true;
+                        $fakedForBranchPruning['onlyIf-' . $storeKey] = true;
+                    }
+                    continue;
+                }
+            }
+            if ($token instanceof Operands\StructuredReference) {
+                if ($cell === null) {
+                    return $this->raiseFormulaError('Structured References must exist in a Cell context');
+                }
+                try {
+                    $cellRange = $token->parse($cell);
+                    if (str_contains($cellRange, ':')) {
+                        $this->debugLog->writeDebugLog('Evaluating Structured Reference %s as Cell Range %s', $token->value(), $cellRange);
+                        $rangeValue = self::getInstance($cell->getWorksheet()->getParent())->_calculateFormulaValue("={$cellRange}", $cellRange, $cell);
+                        $stack->push('Value', $rangeValue);
+                        $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as value %s', $token->value(), $this->showValue($rangeValue));
+                    } else {
+                        $this->debugLog->writeDebugLog('Evaluating Structured Reference %s as Cell %s', $token->value(), $cellRange);
+                        $cellValue = $cell->getWorksheet()->getCell($cellRange)->getCalculatedValue(false);
+                        $stack->push('Cell Reference', $cellValue, $cellRange);
+                        $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as value %s', $token->value(), $this->showValue($cellValue));
+                    }
+                } catch (Exception $e) {
+                    if ($e->getCode() === Exception::CALCULATION_ENGINE_PUSH_TO_STACK) {
+                        $stack->push('Error', ExcelError::REF(), null);
+                        $this->debugLog->writeDebugLog('Evaluated Structured Reference %s as error value %s', $token->value(), ExcelError::REF());
+                    } else {
+                        return $this->raiseFormulaError($e->getMessage(), $e->getCode(), $e);
+                    }
+                }
+            } elseif (!is_numeric($token) && !is_object($token) && isset(self::BINARY_OPERATORS[$token])) {
+                $operand2Data = $stack->pop();
+                if ($operand2Data === null) {
+                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
+                }
+                $operand1Data = $stack->pop();
+                if ($operand1Data === null) {
+                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
+                }
+                $operand1 = self::dataTestReference($operand1Data);
+                $operand2 = self::dataTestReference($operand2Data);
+                if ($token == ':') {
+                    $this->debugLog->writeDebugLog('Evaluating Range %s %s %s', $this->showValue($operand1Data['reference']), $token, $this->showValue($operand2Data['reference']));
+                } else {
+                    $this->debugLog->writeDebugLog('Evaluating %s %s %s', $this->showValue($operand1), $token, $this->showValue($operand2));
+                }
+                switch ($token) {
+                    case '>': // Greater than
+                    case '<': // Less than
+                    case '>=': // Greater than or Equal to
+                    case '<=': // Less than or Equal to
+                    case '=': // Equality
+                    case '<>': // Inequality
+                        $result = $this->executeBinaryComparisonOperation($operand1, $operand2, (string) $token, $stack);
+                        if (isset($storeKey)) {
+                            $branchStore[$storeKey] = $result;
+                        }
+                        break;
+                    case ':': // Range
+                        if ($operand1Data['type'] === 'Defined Name') {
+                            if (preg_match('/$' . self::CALCULATION_REGEXP_DEFINEDNAME . '^/mui', $operand1Data['reference']) !== false && $this->spreadsheet !== null) {
+                                $definedName = $this->spreadsheet->getNamedRange($operand1Data['reference']);
+                                if ($definedName !== null) {
+                                    $operand1Data['reference'] = $operand1Data['value'] = str_replace('$', '', $definedName->getValue());
+                                }
+                            }
+                        }
+                        if (str_contains($operand1Data['reference'] ?? '', '!')) {
+                            [$sheet1, $operand1Data['reference']] = Worksheet::extractSheetTitle($operand1Data['reference'], true);
+                        } else {
+                            $sheet1 = ($pCellWorksheet !== null) ? $pCellWorksheet->getTitle() : '';
+                        }
+                        $sheet1 ??= '';
+                        [$sheet2, $operand2Data['reference']] = Worksheet::extractSheetTitle($operand2Data['reference'], true);
+                        if (empty($sheet2)) {
+                            $sheet2 = $sheet1;
+                        }
+                        if (trim($sheet1, "'") === trim($sheet2, "'")) {
+                            if ($operand1Data['reference'] === null && $cell !== null) {
+                                if (is_array($operand1Data['value'])) {
+                                    $operand1Data['reference'] = $cell->getCoordinate();
+                                } elseif ((trim($operand1Data['value']) != '') && (is_numeric($operand1Data['value']))) {
+                                    $operand1Data['reference'] = $cell->getColumn() . $operand1Data['value'];
+                                } elseif (trim($operand1Data['value']) == '') {
+                                    $operand1Data['reference'] = $cell->getCoordinate();
+                                } else {
+                                    $operand1Data['reference'] = $operand1Data['value'] . $cell->getRow();
+                                }
+                            }
+                            if ($operand2Data['reference'] === null && $cell !== null) {
+                                if (is_array($operand2Data['value'])) {
+                                    $operand2Data['reference'] = $cell->getCoordinate();
+                                } elseif ((trim($operand2Data['value']) != '') && (is_numeric($operand2Data['value']))) {
+                                    $operand2Data['reference'] = $cell->getColumn() . $operand2Data['value'];
+                                } elseif (trim($operand2Data['value']) == '') {
+                                    $operand2Data['reference'] = $cell->getCoordinate();
+                                } else {
+                                    $operand2Data['reference'] = $operand2Data['value'] . $cell->getRow();
+                                }
+                            }
+                            $oData = array_merge(explode(':', $operand1Data['reference'] ?? ''), explode(':', $operand2Data['reference'] ?? ''));
+                            $oCol = $oRow = [];
+                            $breakNeeded = false;
+                            foreach ($oData as $oDatum) {
+                                try {
+                                    $oCR = Coordinate::coordinateFromString($oDatum);
+                                    $oCol[] = Coordinate::columnIndexFromString($oCR[0]) - 1;
+                                    $oRow[] = $oCR[1];
+                                } catch (\Exception) {
+                                    $stack->push('Error', ExcelError::REF(), null);
+                                    $breakNeeded = true;
+                                    break;
+                                }
+                            }
+                            if ($breakNeeded) {
+                                break;
+                            }
+                            $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':' . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
+                            if ($pCellParent !== null && $this->spreadsheet !== null) {
+                                $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($sheet1), false);
+                            } else {
+                                return $this->raiseFormulaError('Unable to access Cell Reference');
+                            }
+                            $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellValue));
+                            $stack->push('Cell Reference', $cellValue, $cellRef);
+                        } else {
+                            $this->debugLog->writeDebugLog('Evaluation Result is a #REF! Error');
+                            $stack->push('Error', ExcelError::REF(), null);
+                        }
+                        break;
+                    case '+':            //    Addition
+                    case '-':            //    Subtraction
+                    case '*':            //    Multiplication
+                    case '/':            //    Division
+                    case '^':            //    Exponential
+                        $result = $this->executeNumericBinaryOperation($operand1, $operand2, $token, $stack);
+                        if (isset($storeKey)) {
+                            $branchStore[$storeKey] = $result;
+                        }
+                        break;
+                    case '&':            //    Concatenation
+                        $operand1 = self::boolToString($operand1);
+                        $operand2 = self::boolToString($operand2);
+                        if (is_array($operand1) || is_array($operand2)) {
+                            if (is_string($operand1)) {
+                                $operand1 = self::unwrapResult($operand1);
+                            }
+                            if (is_string($operand2)) {
+                                $operand2 = self::unwrapResult($operand2);
+                            }
+                            [$rows, $columns] = self::checkMatrixOperands($operand1, $operand2, 2);
+                            for ($row = 0; $row < $rows; ++$row) {
+                                for ($column = 0; $column < $columns; ++$column) {
+                                    $op1x = self::boolToString($operand1[$row][$column]);
+                                    $op2x = self::boolToString($operand2[$row][$column]);
+                                    if (Information\ErrorValue::isError($op1x)) {
+                                    } elseif (Information\ErrorValue::isError($op2x)) {
+                                        $operand1[$row][$column] = $op2x;
+                                    } else {
+                                        $operand1[$row][$column]
+                                            = Shared\StringHelper::substring(
+                                                $op1x . $op2x,
+                                                0,
+                                                DataType::MAX_STRING_LENGTH
+                                            );
+                                    }
+                                }
+                            }
+                            $result = $operand1;
+                        } else {
+                            if (Information\ErrorValue::isError($operand1)) {
+                                $result = $operand1;
+                            } elseif (Information\ErrorValue::isError($operand2)) {
+                                $result = $operand2;
+                            } else {
+                                $result = self::FORMULA_STRING_QUOTE . str_replace('""', self::FORMULA_STRING_QUOTE, self::unwrapResult($operand1) . self::unwrapResult($operand2)) . self::FORMULA_STRING_QUOTE;
+                            }
+                        }
+                        $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
+                        $stack->push('Value', $result);
+                        if (isset($storeKey)) {
+                            $branchStore[$storeKey] = $result;
+                        }
+                        break;
+                    case '∩':            //    Intersect
+                        $rowIntersect = array_intersect_key($operand1, $operand2);
+                        $cellIntersect = $oCol = $oRow = [];
+                        foreach (array_keys($rowIntersect) as $row) {
+                            $oRow[] = $row;
+                            foreach ($rowIntersect[$row] as $col => $data) {
+                                $oCol[] = Coordinate::columnIndexFromString($col) - 1;
+                                $cellIntersect[$row] = array_intersect_key($operand1[$row], $operand2[$row]);
+                            }
+                        }
+                        if (count(Functions::flattenArray($cellIntersect)) === 0) {
+                            $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellIntersect));
+                            $stack->push('Error', ExcelError::null(), null);
+                        } else {
+                            $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':'
+                                . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
+                            $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($cellIntersect));
+                            $stack->push('Value', $cellIntersect, $cellRef);
+                        }
+                        break;
+                }
+            } elseif (($token === '~') || ($token === '%')) {
+                if (($arg = $stack->pop()) === null) {
+                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
+                }
+                $arg = $arg['value'];
+                if ($token === '~') {
+                    $this->debugLog->writeDebugLog('Evaluating Negation of %s', $this->showValue($arg));
+                    $multiplier = -1;
+                } else {
+                    $this->debugLog->writeDebugLog('Evaluating Percentile of %s', $this->showValue($arg));
+                    $multiplier = 0.01;
+                }
+                if (is_array($arg)) {
+                    $operand2 = $multiplier;
+                    $result = $arg;
+                    [$rows, $columns] = self::checkMatrixOperands($result, $operand2, 0);
+                    for ($row = 0; $row < $rows; ++$row) {
+                        for ($column = 0; $column < $columns; ++$column) {
+                            if (self::isNumericOrBool($result[$row][$column])) {
+                                $result[$row][$column] *= $multiplier;
+                            } else {
+                                $result[$row][$column] = self::makeError($result[$row][$column]);
+                            }
+                        }
+                    }
+                    $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
+                    $stack->push('Value', $result);
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = $result;
+                    }
+                } else {
+                    $this->executeNumericBinaryOperation($multiplier, $arg, '*', $stack);
+                }
+            } elseif (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/i', $token ?? '', $matches)) {
+                $cellRef = null;
+                if (isset($matches[8])) {
+                    if ($cell === null) {
+                        $cellValue = ExcelError::REF();
+                    } else {
+                        $cellRef = $matches[6] . $matches[7] . ':' . $matches[9] . $matches[10];
+                        if ($matches[2] > '') {
+                            $matches[2] = trim($matches[2], "\"'");
+                            if ((str_contains($matches[2], '[')) || (str_contains($matches[2], ']'))) {
+                                return $this->raiseFormulaError('Unable to access External Workbook');
+                            }
+                            $matches[2] = trim($matches[2], "\"'");
+                            $this->debugLog->writeDebugLog('Evaluating Cell Range %s in worksheet %s', $cellRef, $matches[2]);
+                            if ($pCellParent !== null && $this->spreadsheet !== null) {
+                                $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
+                            } else {
+                                return $this->raiseFormulaError('Unable to access Cell Reference');
+                            }
+                            $this->debugLog->writeDebugLog('Evaluation Result for cells %s in worksheet %s is %s', $cellRef, $matches[2], $this->showTypeDetails($cellValue));
+                        } else {
+                            $this->debugLog->writeDebugLog('Evaluating Cell Range %s in current worksheet', $cellRef);
+                            if ($pCellParent !== null) {
+                                $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
+                            } else {
+                                return $this->raiseFormulaError('Unable to access Cell Reference');
+                            }
+                            $this->debugLog->writeDebugLog('Evaluation Result for cells %s is %s', $cellRef, $this->showTypeDetails($cellValue));
+                        }
+                    }
+                } else {
+                    if ($cell === null) {
+                        $cellValue = ExcelError::REF();
+                    } else {
+                        $cellRef = $matches[6] . $matches[7];
+                        if ($matches[2] > '') {
+                            $matches[2] = trim($matches[2], "\"'");
+                            if ((str_contains($matches[2], '[')) || (str_contains($matches[2], ']'))) {
+                                return $this->raiseFormulaError('Unable to access External Workbook');
+                            }
+                            $this->debugLog->writeDebugLog('Evaluating Cell %s in worksheet %s', $cellRef, $matches[2]);
+                            if ($pCellParent !== null && $this->spreadsheet !== null) {
+                                $cellSheet = $this->spreadsheet->getSheetByName($matches[2]);
+                                if ($cellSheet && $cellSheet->cellExists($cellRef)) {
+                                    $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
+                                    $cell->attach($pCellParent);
+                                } else {
+                                    $cellRef = ($cellSheet !== null) ? "'{$matches[2]}'!{$cellRef}" : $cellRef;
+                                    $cellValue = ($cellSheet !== null) ? null : ExcelError::REF();
+                                }
+                            } else {
+                                return $this->raiseFormulaError('Unable to access Cell Reference');
+                            }
+                            $this->debugLog->writeDebugLog('Evaluation Result for cell %s in worksheet %s is %s', $cellRef, $matches[2], $this->showTypeDetails($cellValue));
+                        } else {
+                            $this->debugLog->writeDebugLog('Evaluating Cell %s in current worksheet', $cellRef);
+                            if ($pCellParent !== null && $pCellParent->has($cellRef)) {
+                                $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
+                                $cell->attach($pCellParent);
+                            } else {
+                                $cellValue = null;
+                            }
+                            $this->debugLog->writeDebugLog('Evaluation Result for cell %s is %s', $cellRef, $this->showTypeDetails($cellValue));
+                        }
+                    }
+                }
+                $stack->push('Cell Value', $cellValue, $cellRef);
+                if (isset($storeKey)) {
+                    $branchStore[$storeKey] = $cellValue;
+                }
+            } elseif (preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/miu', $token ?? '', $matches)) {
+                if ($cell !== null && $pCellParent !== null) {
+                    $cell->attach($pCellParent);
+                }
+                $functionName = $matches[1];
+                $argCount = $stack->pop();
+                $argCount = $argCount['value'];
+                if ($functionName !== 'MKMATRIX') {
+                    $this->debugLog->writeDebugLog('Evaluating Function %s() with %s argument%s', self::localeFunc($functionName), (($argCount == 0) ? 'no' : $argCount), (($argCount == 1) ? '' : 's'));
+                }
+                if ((isset(self::$phpSpreadsheetFunctions[$functionName])) || (isset(self::$controlFunctions[$functionName]))) {    // function
+                    $passByReference = false;
+                    $passCellReference = false;
+                    $functionCall = null;
+                    if (isset(self::$phpSpreadsheetFunctions[$functionName])) {
+                        $functionCall = self::$phpSpreadsheetFunctions[$functionName]['functionCall'];
+                        $passByReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference']);
+                        $passCellReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passCellReference']);
+                    } elseif (isset(self::$controlFunctions[$functionName])) {
+                        $functionCall = self::$controlFunctions[$functionName]['functionCall'];
+                        $passByReference = isset(self::$controlFunctions[$functionName]['passByReference']);
+                        $passCellReference = isset(self::$controlFunctions[$functionName]['passCellReference']);
+                    }
+                    $args = $argArrayVals = [];
+                    $emptyArguments = [];
+                    for ($i = 0; $i < $argCount; ++$i) {
+                        $arg = $stack->pop();
+                        $a = $argCount - $i - 1;
+                        if (
+                            ($passByReference)
+                            && (isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a]))
+                            && (self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a])
+                        ) {
+                            if ($arg['reference'] === null) {
+                                $args[] = $cellID;
+                                if ($functionName !== 'MKMATRIX') {
+                                    $argArrayVals[] = $this->showValue($cellID);
+                                }
+                            } else {
+                                $args[] = $arg['reference'];
+                                if ($functionName !== 'MKMATRIX') {
+                                    $argArrayVals[] = $this->showValue($arg['reference']);
+                                }
+                            }
+                        } else {
+                            if ($arg['type'] === 'Empty Argument' && in_array($functionName, ['MIN', 'MINA', 'MAX', 'MAXA', 'IF'], true)) {
+                                $emptyArguments[] = false;
+                                $args[] = $arg['value'] = 0;
+                                $this->debugLog->writeDebugLog('Empty Argument reevaluated as 0');
+                            } else {
+                                $emptyArguments[] = $arg['type'] === 'Empty Argument';
+                                $args[] = self::unwrapResult($arg['value']);
+                            }
+                            if ($functionName !== 'MKMATRIX') {
+                                $argArrayVals[] = $this->showValue($arg['value']);
+                            }
+                        }
+                    }
+                    krsort($args);
+                    krsort($emptyArguments);
+                    if ($argCount > 0 && is_array($functionCall)) {
+                        $args = $this->addDefaultArgumentValues($functionCall, $args, $emptyArguments);
+                    }
+                    if (($passByReference) && ($argCount == 0)) {
+                        $args[] = $cellID;
+                        $argArrayVals[] = $this->showValue($cellID);
+                    }
+                    if ($functionName !== 'MKMATRIX') {
+                        if ($this->debugLog->getWriteDebugLog()) {
+                            krsort($argArrayVals);
+                            $this->debugLog->writeDebugLog('Evaluating %s ( %s )', self::localeFunc($functionName), implode(self::$localeArgumentSeparator . ' ', Functions::flattenArray($argArrayVals)));
+                        }
+                    }
+                    $args = $this->addCellReference($args, $passCellReference, $functionCall, $cell);
+                    if (!is_array($functionCall)) {
+                        foreach ($args as &$arg) {
+                            $arg = Functions::flattenSingleValue($arg);
+                        }
+                        unset($arg);
+                    }
+                    $result = call_user_func_array($functionCall, $args);
+                    if ($functionName !== 'MKMATRIX') {
+                        $this->debugLog->writeDebugLog('Evaluation Result for %s() function call is %s', self::localeFunc($functionName), $this->showTypeDetails($result));
+                    }
+                    $stack->push('Value', self::wrapResult($result));
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = $result;
+                    }
+                }
+            } else {
+                if (isset(self::$excelConstants[strtoupper($token ?? '')])) {
+                    $excelConstant = strtoupper($token);
+                    $stack->push('Constant Value', self::$excelConstants[$excelConstant]);
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = self::$excelConstants[$excelConstant];
+                    }
+                    $this->debugLog->writeDebugLog('Evaluating Constant %s as %s', $excelConstant, $this->showTypeDetails(self::$excelConstants[$excelConstant]));
+                } elseif ((is_numeric($token)) || ($token === null) || (is_bool($token)) || ($token == '') || ($token[0] == self::FORMULA_STRING_QUOTE) || ($token[0] == '#')) {
+                    $stack->push($tokenData['type'], $token, $tokenData['reference']);
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = $token;
+                    }
+                } elseif (preg_match('/^' . self::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $token, $matches)) {
+                    $definedName = $matches[6];
+                    if ($cell === null || $pCellWorksheet === null) {
+                        return $this->raiseFormulaError("undefined name '$token'");
+                    }
+                    $this->debugLog->writeDebugLog('Evaluating Defined Name %s', $definedName);
+                    $namedRange = DefinedName::resolveName($definedName, $pCellWorksheet);
+                    if ($namedRange === null && $this->spreadsheet !== null) {
+                        $table = $this->spreadsheet->getTableByName($definedName);
+                        if ($table !== null) {
+                            $tableRange = Coordinate::getRangeBoundaries($table->getRange());
+                            if ($table->getShowHeaderRow()) {
+                                ++$tableRange[0][1];
+                            }
+                            if ($table->getShowTotalsRow()) {
+                                --$tableRange[1][1];
+                            }
+                            $tableRangeString
+                                = '$' . $tableRange[0][0]
+                                . '$' . $tableRange[0][1]
+                                . ':'
+                                . '$' . $tableRange[1][0]
+                                . '$' . $tableRange[1][1];
+                            $namedRange = new NamedRange($definedName, $table->getWorksheet(), $tableRangeString);
+                        }
+                    }
+                    if ($namedRange === null) {
+                        return $this->raiseFormulaError("undefined name '$definedName'");
+                    }
+                    $result = $this->evaluateDefinedName($cell, $namedRange, $pCellWorksheet, $stack);
+                    if (isset($storeKey)) {
+                        $branchStore[$storeKey] = $result;
+                    }
+                } else {
+                    return $this->raiseFormulaError("undefined name '$token'");
+                }
+            }
+        }
+        if ($stack->count() != 1) {
+            return $this->raiseFormulaError('internal error');
+        }
+        $output = $stack->pop();
+        $output = $output['value'];
+        return $output;
+    }
+    private function validateBinaryOperand(mixed &$operand, mixed &$stack): bool
+    {
+        if (is_array($operand)) {
+            if ((count($operand, COUNT_RECURSIVE) - count($operand)) == 1) {
+                do {
+                    $operand = array_pop($operand);
+                } while (is_array($operand));
+            }
+        }
+        if (is_string($operand)) {
+            if ($operand > '' && $operand[0] == self::FORMULA_STRING_QUOTE) {
+                $operand = self::unwrapResult($operand);
+            }
+            if (!is_numeric($operand)) {
+                if ($operand > '' && $operand[0] == '#') {
+                    $stack->push('Value', $operand);
+                    $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($operand));
+                    return false;
+                } elseif (Engine\FormattedNumber::convertToNumberIfFormatted($operand) === false) {
+                    $stack->push('Error', '#VALUE!');
+                    $this->debugLog->writeDebugLog('Evaluation Result is a %s', $this->showTypeDetails('#VALUE!'));
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+    private function executeArrayComparison(mixed $operand1, mixed $operand2, string $operation, Stack &$stack, bool $recursingArrays): array
+    {
+        $result = [];
+        if (!is_array($operand2)) {
+            foreach ($operand1 as $x => $operandData) {
+                $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operandData), $operation, $this->showValue($operand2));
+                $this->executeBinaryComparisonOperation($operandData, $operand2, $operation, $stack);
+                $r = $stack->pop();
+                $result[$x] = $r['value'];
+            }
+        } elseif (!is_array($operand1)) {
+            foreach ($operand2 as $x => $operandData) {
+                $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operand1), $operation, $this->showValue($operandData));
+                $this->executeBinaryComparisonOperation($operand1, $operandData, $operation, $stack);
+                $r = $stack->pop();
+                $result[$x] = $r['value'];
+            }
+        } else {
+            if (!$recursingArrays) {
+                self::checkMatrixOperands($operand1, $operand2, 2);
+            }
+            foreach ($operand1 as $x => $operandData) {
+                $this->debugLog->writeDebugLog('Evaluating Comparison %s %s %s', $this->showValue($operandData), $operation, $this->showValue($operand2[$x]));
+                $this->executeBinaryComparisonOperation($operandData, $operand2[$x], $operation, $stack, true);
+                $r = $stack->pop();
+                $result[$x] = $r['value'];
+            }
+        }
+        $this->debugLog->writeDebugLog('Comparison Evaluation Result is %s', $this->showTypeDetails($result));
+        $stack->push('Array', $result);
+        return $result;
+    }
+    private function executeBinaryComparisonOperation(mixed $operand1, mixed $operand2, string $operation, Stack &$stack, bool $recursingArrays = false): array|bool
+    {
+        if ((is_array($operand1)) || (is_array($operand2))) {
+            return $this->executeArrayComparison($operand1, $operand2, $operation, $stack, $recursingArrays);
+        }
+        $result = BinaryComparison::compare($operand1, $operand2, $operation);
+        $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
+        $stack->push('Value', $result);
+        return $result;
+    }
+    private function executeNumericBinaryOperation(mixed $operand1, mixed $operand2, string $operation, Stack &$stack): mixed
+    {
+        if (
+            ($this->validateBinaryOperand($operand1, $stack) === false)
+            || ($this->validateBinaryOperand($operand2, $stack) === false)
+        ) {
+            return false;
+        }
+        if (
+            (Functions::getCompatibilityMode() != Functions::COMPATIBILITY_OPENOFFICE)
+            && ((is_string($operand1) && !is_numeric($operand1) && $operand1 !== '')
+                || (is_string($operand2) && !is_numeric($operand2) && $operand2 !== ''))
+        ) {
+            $result = ExcelError::VALUE();
+        } elseif (is_array($operand1) || is_array($operand2)) {
+            if (is_array($operand1)) {
+                foreach ($operand1 as $key => $value) {
+                    $operand1[$key] = Functions::flattenArray($value);
+                }
+            }
+            if (is_array($operand2)) {
+                foreach ($operand2 as $key => $value) {
+                    $operand2[$key] = Functions::flattenArray($value);
+                }
+            }
+            [$rows, $columns] = self::checkMatrixOperands($operand1, $operand2, 2);
+            for ($row = 0; $row < $rows; ++$row) {
+                for ($column = 0; $column < $columns; ++$column) {
+                    if ($operand1[$row][$column] === null) {
+                        $operand1[$row][$column] = 0;
+                    } elseif (!self::isNumericOrBool($operand1[$row][$column])) {
+                        $operand1[$row][$column] = self::makeError($operand1[$row][$column]);
+                        continue;
+                    }
+                    if ($operand2[$row][$column] === null) {
+                        $operand2[$row][$column] = 0;
+                    } elseif (!self::isNumericOrBool($operand2[$row][$column])) {
+                        $operand1[$row][$column] = self::makeError($operand2[$row][$column]);
+                        continue;
+                    }
+                    switch ($operation) {
+                        case '+':
+                            $operand1[$row][$column] += $operand2[$row][$column];
+                            break;
+                        case '-':
+                            $operand1[$row][$column] -= $operand2[$row][$column];
+                            break;
+                        case '*':
+                            $operand1[$row][$column] *= $operand2[$row][$column];
+                            break;
+                        case '/':
+                            if ($operand2[$row][$column] == 0) {
+                                $operand1[$row][$column] = ExcelError::DIV0();
+                            } else {
+                                $operand1[$row][$column] /= $operand2[$row][$column];
+                            }
+                            break;
+                        case '^':
+                            $operand1[$row][$column] = $operand1[$row][$column] ** $operand2[$row][$column];
+                            break;
+                        default:
+                            throw new Exception('Unsupported numeric binary operation');
+                    }
+                }
+            }
+            $result = $operand1;
+        } else {
+            switch ($operation) {
+                case '+':
+                    $result = $operand1 + $operand2;
+                    break;
+                case '-':
+                    $result = $operand1 - $operand2;
+                    break;
+                case '*':
+                    $result = $operand1 * $operand2;
+                    break;
+                case '/':
+                    if ($operand2 == 0) {
+                        $stack->push('Error', ExcelError::DIV0());
+                        $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails(ExcelError::DIV0()));
+                        return false;
+                    }
+                    $result = $operand1 / $operand2;
+                    break;
+                case '^':
+                    $result = $operand1 ** $operand2;
+                    break;
+                default:
+                    throw new Exception('Unsupported numeric binary operation');
+            }
+        }
+        $this->debugLog->writeDebugLog('Evaluation Result is %s', $this->showTypeDetails($result));
+        $stack->push('Value', $result);
+        return $result;
+    }
+    /**
+     * Trigger an error, but nicely, if need be.
+     *
+     * @return false
+     */
+    protected function raiseFormulaError(string $errorMessage, int $code = 0, ?Throwable $exception = null): bool
+    {
+        $this->formulaError = $errorMessage;
+        $this->cyclicReferenceStack->clear();
+        $suppress = $this->suppressFormulaErrors;
+        if (!$suppress) {
+            throw new Exception($errorMessage, $code, $exception);
+        }
+        return false;
+    }
+    /**
+     * Extract range values.
+     *
+     * @param string $range String based range representation
+     * @param ?Worksheet $worksheet Worksheet
+     * @param bool $resetLog Flag indicating whether calculation log should be reset or not
+     *
+     * @return array Array of values in range if range contains more than one element. Otherwise, a single value is returned.
+     */
+    public function extractCellRange(string &$range = 'A1', ?Worksheet $worksheet = null, bool $resetLog = true): array
+    {
+        $returnValue = [];
+        if ($worksheet !== null) {
+            $worksheetName = $worksheet->getTitle();
+            if (str_contains($range, '!')) {
+                [$worksheetName, $range] = Worksheet::extractSheetTitle($range, true);
+                $worksheet = ($this->spreadsheet === null) ? null : $this->spreadsheet->getSheetByName($worksheetName);
+            }
+            $aReferences = Coordinate::extractAllCellReferencesInRange($range);
+            $range = "'" . $worksheetName . "'" . '!' . $range;
+            $currentCol = '';
+            $currentRow = 0;
+            if (!isset($aReferences[1])) {
+                sscanf($aReferences[0], '%[A-Z]%d', $currentCol, $currentRow);
+                if ($worksheet !== null && $worksheet->cellExists($aReferences[0])) {
+                    $returnValue[$currentRow][$currentCol] = $worksheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
+                } else {
+                    $returnValue[$currentRow][$currentCol] = null;
+                }
+            } else {
+                foreach ($aReferences as $reference) {
+                    sscanf($reference, '%[A-Z]%d', $currentCol, $currentRow);
+                    if ($worksheet !== null && $worksheet->cellExists($reference)) {
+                        $returnValue[$currentRow][$currentCol] = $worksheet->getCell($reference)->getCalculatedValue($resetLog);
+                    } else {
+                        $returnValue[$currentRow][$currentCol] = null;
+                    }
+                }
+            }
+        }
+        return $returnValue;
+    }
+    /**
+     * Extract range values.
+     *
+     * @param string $range String based range representation
+     * @param null|Worksheet $worksheet Worksheet
+     * @param bool $resetLog Flag indicating whether calculation log should be reset or not
+     *
+     * @return array|string Array of values in range if range contains more than one element. Otherwise, a single value is returned.
+     */
+    public function extractNamedRange(string &$range = 'A1', ?Worksheet $worksheet = null, bool $resetLog = true): string|array
+    {
+        $returnValue = [];
+        if ($worksheet !== null) {
+            if (str_contains($range, '!')) {
+                [$worksheetName, $range] = Worksheet::extractSheetTitle($range, true);
+                $worksheet = ($this->spreadsheet === null) ? null : $this->spreadsheet->getSheetByName($worksheetName);
+            }
+            $namedRange = ($worksheet === null) ? null : DefinedName::resolveName($range, $worksheet);
+            if ($namedRange === null) {
+                return ExcelError::REF();
+            }
+            $worksheet = $namedRange->getWorksheet();
+            $range = $namedRange->getValue();
+            $splitRange = Coordinate::splitRange($range);
+            if ($worksheet !== null && ctype_alpha($splitRange[0][0])) {
+                $range = $splitRange[0][0] . '1:' . $splitRange[0][1] . $worksheet->getHighestRow();
+            } elseif ($worksheet !== null && ctype_digit($splitRange[0][0])) {
+                $range = 'A' . $splitRange[0][0] . ':' . $worksheet->getHighestColumn() . $splitRange[0][1];
+            }
+            $aReferences = Coordinate::extractAllCellReferencesInRange($range);
+            if (!isset($aReferences[1])) {
+                [$currentCol, $currentRow] = Coordinate::coordinateFromString($aReferences[0]);
+                if ($worksheet !== null && $worksheet->cellExists($aReferences[0])) {
+                    $returnValue[$currentRow][$currentCol] = $worksheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
+                } else {
+                    $returnValue[$currentRow][$currentCol] = null;
+                }
+            } else {
+                foreach ($aReferences as $reference) {
+                    [$currentCol, $currentRow] = Coordinate::coordinateFromString($reference);
+                    if ($worksheet !== null && $worksheet->cellExists($reference)) {
+                        $returnValue[$currentRow][$currentCol] = $worksheet->getCell($reference)->getCalculatedValue($resetLog);
+                    } else {
+                        $returnValue[$currentRow][$currentCol] = null;
+                    }
+                }
+            }
+        }
+        return $returnValue;
+    }
+    /**
+     * Is a specific function implemented?
+     *
+     * @param string $function Function Name
+     */
+    public function isImplemented(string $function): bool
+    {
+        $function = strtoupper($function);
+        $notImplemented = !isset(self::$phpSpreadsheetFunctions[$function]) || (is_array(self::$phpSpreadsheetFunctions[$function]['functionCall']) && self::$phpSpreadsheetFunctions[$function]['functionCall'][1] === 'DUMMY');
+        return !$notImplemented;
+    }
+    /**
+     * Get a list of all implemented functions as an array of function objects.
+     */
+    public static function getFunctions(): array
+    {
+        return self::$phpSpreadsheetFunctions;
+    }
+    /**
+     * Get a list of implemented Excel function names.
+     */
+    public function getImplementedFunctionNames(): array
+    {
+        $returnValue = [];
+        foreach (self::$phpSpreadsheetFunctions as $functionName => $function) {
+            if ($this->isImplemented($functionName)) {
+                $returnValue[] = $functionName;
+            }
+        }
+        return $returnValue;
+    }
+    private function addDefaultArgumentValues(array $functionCall, array $args, array $emptyArguments): array
+    {
+        $reflector = new ReflectionMethod($functionCall[0], $functionCall[1]);
+        $methodArguments = $reflector->getParameters();
+        if (count($methodArguments) > 0) {
+            foreach ($emptyArguments as $argumentId => $isArgumentEmpty) {
+                if ($isArgumentEmpty === true) {
+                    $reflectedArgumentId = count($args) - (int) $argumentId - 1;
+                    if (
+                        !array_key_exists($reflectedArgumentId, $methodArguments)
+                        || $methodArguments[$reflectedArgumentId]->isVariadic()
+                    ) {
+                        break;
+                    }
+                    $args[$argumentId] = $this->getArgumentDefaultValue($methodArguments[$reflectedArgumentId]);
+                }
+            }
+        }
+        return $args;
+    }
+    private function getArgumentDefaultValue(ReflectionParameter $methodArgument): mixed
+    {
+        $defaultValue = null;
+        if ($methodArgument->isDefaultValueAvailable()) {
+            $defaultValue = $methodArgument->getDefaultValue();
+            if ($methodArgument->isDefaultValueConstant()) {
+                $constantName = $methodArgument->getDefaultValueConstantName() ?? '';
+                if (str_contains($constantName, '::')) {
+                    [$className, $constantName] = explode('::', $constantName);
+                    $constantReflector = new ReflectionClassConstant($className, $constantName);
+                    return $constantReflector->getValue();
+                }
+                return constant($constantName);
+            }
+        }
+        return $defaultValue;
+    }
+    /**
+     * Add cell reference if needed while making sure that it is the last argument.
+     */
+    private function addCellReference(array $args, bool $passCellReference, array|string $functionCall, ?Cell $cell = null): array
+    {
+        if ($passCellReference) {
+            if (is_array($functionCall)) {
+                $className = $functionCall[0];
+                $methodName = $functionCall[1];
+                $reflectionMethod = new ReflectionMethod($className, $methodName);
+                $argumentCount = count($reflectionMethod->getParameters());
+                while (count($args) < $argumentCount - 1) {
+                    $args[] = null;
+                }
+            }
+            $args[] = $cell;
+        }
+        return $args;
+    }
+    private function evaluateDefinedName(Cell $cell, DefinedName $namedRange, Worksheet $cellWorksheet, Stack $stack): mixed
+    {
+        $definedNameScope = $namedRange->getScope();
+        if ($definedNameScope !== null && $definedNameScope !== $cellWorksheet) {
+            $result = ExcelError::REF();
+            $stack->push('Error', $result, $namedRange->getName());
+            return $result;
+        }
+        $definedNameValue = $namedRange->getValue();
+        $definedNameType = $namedRange->isFormula() ? 'Formula' : 'Range';
+        $definedNameWorksheet = $namedRange->getWorksheet();
+        if ($definedNameValue[0] !== '=') {
+            $definedNameValue = '=' . $definedNameValue;
+        }
+        $this->debugLog->writeDebugLog('Defined Name is a %s with a value of %s', $definedNameType, $definedNameValue);
+        $originalCoordinate = $cell->getCoordinate();
+        $recursiveCalculationCell = ($definedNameType !== 'Formula' && $definedNameWorksheet !== null && $definedNameWorksheet !== $cellWorksheet)
+            ? $definedNameWorksheet->getCell('A1')
+            : $cell;
+        $recursiveCalculationCellAddress = $recursiveCalculationCell->getCoordinate();
+        $definedNameValue = self::$referenceHelper->updateFormulaReferencesAnyWorksheet(
+            $definedNameValue,
+            Coordinate::columnIndexFromString($cell->getColumn()) - 1,
+            $cell->getRow() - 1
+        );
+        $this->debugLog->writeDebugLog('Value adjusted for relative references is %s', $definedNameValue);
+        $recursiveCalculator = new self($this->spreadsheet);
+        $recursiveCalculator->getDebugLog()->setWriteDebugLog($this->getDebugLog()->getWriteDebugLog());
+        $recursiveCalculator->getDebugLog()->setEchoDebugLog($this->getDebugLog()->getEchoDebugLog());
+        $result = $recursiveCalculator->_calculateFormulaValue($definedNameValue, $recursiveCalculationCellAddress, $recursiveCalculationCell, true);
+        $cellWorksheet->getCell($originalCoordinate);
+        if ($this->getDebugLog()->getWriteDebugLog()) {
+            $this->debugLog->mergeDebugLog(array_slice($recursiveCalculator->getDebugLog()->getLog(), 3));
+            $this->debugLog->writeDebugLog('Evaluation Result for Named %s %s is %s', $definedNameType, $namedRange->getName(), $this->showTypeDetails($result));
+        }
+        $stack->push('Defined Name', $result, $namedRange->getName());
+        return $result;
+    }
+    public function setSuppressFormulaErrors(bool $suppressFormulaErrors): void
+    {
+        $this->suppressFormulaErrors = $suppressFormulaErrors;
+    }
+    public function getSuppressFormulaErrors(): bool
+    {
+        return $this->suppressFormulaErrors;
+    }
+    private static function boolToString(mixed $operand1): mixed
+    {
+        if (is_bool($operand1)) {
+            $operand1 = ($operand1) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
+        } elseif ($operand1 === null) {
+            $operand1 = '';
+        }
+        return $operand1;
+    }
+    private static function isNumericOrBool(mixed $operand): bool
+    {
+        return is_numeric($operand) || is_bool($operand);
+    }
+    private static function makeError(mixed $operand = ''): string
+    {
+        return Information\ErrorValue::isError($operand) ? $operand : ExcelError::VALUE();
+    }
+}

--- a/src/PhpSpreadsheet/Calculation/Financial/Amortization.php
+++ b//dev/null
@@ -1,186 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Calculation\Financial;
-use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
-use PhpOffice\PhpSpreadsheet\Calculation\Exception;
-use PhpOffice\PhpSpreadsheet\Calculation\Financial\Constants as FinancialConstants;
-use PhpOffice\PhpSpreadsheet\Calculation\Functions;
-class Amortization
-{
-    /**
-     * AMORDEGRC.
-     *
-     * Returns the depreciation for each accounting period.
-     * This function is provided for the French accounting system. If an asset is purchased in
-     * the middle of the accounting period, the prorated depreciation is taken into account.
-     * The function is similar to AMORLINC, except that a depreciation coefficient is applied in
-     * the calculation depending on the life of the assets.
-     * This function will return the depreciation until the last period of the life of the assets
-     * or until the cumulated value of depreciation is greater than the cost of the assets minus
-     * the salvage value.
-     *
-     * Excel Function:
-     *        AMORDEGRC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
-     *
-     * @param mixed $cost The float cost of the asset
-     * @param mixed $purchased Date of the purchase of the asset
-     * @param mixed $firstPeriod Date of the end of the first period
-     * @param mixed $salvage The salvage value at the end of the life of the asset
-     * @param mixed $period the period (float)
-     * @param mixed $rate rate of depreciation (float)
-     * @param mixed $basis The type of day count to use (int).
-     *                         0 or omitted    US (NASD) 30/360
-     *                         1               Actual/actual
-     *                         2               Actual/360
-     *                         3               Actual/365
-     *                         4               European 30/360
-     *
-     * @return float|string (string containing the error type if there is an error)
-     */
-    public static function AMORDEGRC(
-        mixed $cost,
-        mixed $purchased,
-        mixed $firstPeriod,
-        mixed $salvage,
-        mixed $period,
-        mixed $rate,
-        mixed $basis = FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
-    ): string|float {
-        $cost = Functions::flattenSingleValue($cost);
-        $purchased = Functions::flattenSingleValue($purchased);
-        $firstPeriod = Functions::flattenSingleValue($firstPeriod);
-        $salvage = Functions::flattenSingleValue($salvage);
-        $period = Functions::flattenSingleValue($period);
-        $rate = Functions::flattenSingleValue($rate);
-        $basis = ($basis === null)
-            ? FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
-            : Functions::flattenSingleValue($basis);
-        try {
-            $cost = FinancialValidations::validateFloat($cost);
-            $purchased = FinancialValidations::validateDate($purchased);
-            $firstPeriod = FinancialValidations::validateDate($firstPeriod);
-            $salvage = FinancialValidations::validateFloat($salvage);
-            $period = FinancialValidations::validateInt($period);
-            $rate = FinancialValidations::validateFloat($rate);
-            $basis = FinancialValidations::validateBasis($basis);
-        } catch (Exception $e) {
-            return $e->getMessage();
-        }
-        $yearFracx = DateTimeExcel\YearFrac::fraction($purchased, $firstPeriod, $basis);
-        if (is_string($yearFracx)) {
-            return $yearFracx;
-        }
-        /** @var float $yearFrac */
-        $yearFrac = $yearFracx;
-        $amortiseCoeff = self::getAmortizationCoefficient($rate);
-        $rate *= $amortiseCoeff;
-        $rate = (float) (string) $rate; // ugly way to avoid rounding problem
-        $fNRate = round($yearFrac * $rate * $cost, 0);
-        $cost -= $fNRate;
-        $fRest = $cost - $salvage;
-        for ($n = 0; $n < $period; ++$n) {
-            $fNRate = round($rate * $cost, 0);
-            $fRest -= $fNRate;
-            if ($fRest < 0.0) {
-                return match ($period - $n) {
-                    1 => round($cost * 0.5, 0),
-                    default => 0.0,
-                };
-            }
-            $cost -= $fNRate;
-        }
-        return $fNRate;
-    }
-    /**
-     * AMORLINC.
-     *
-     * Returns the depreciation for each accounting period.
-     * This function is provided for the French accounting system. If an asset is purchased in
-     * the middle of the accounting period, the prorated depreciation is taken into account.
-     *
-     * Excel Function:
-     *        AMORLINC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
-     *
-     * @param mixed $cost The cost of the asset as a float
-     * @param mixed $purchased Date of the purchase of the asset
-     * @param mixed $firstPeriod Date of the end of the first period
-     * @param mixed $salvage The salvage value at the end of the life of the asset
-     * @param mixed $period The period as a float
-     * @param mixed $rate Rate of depreciation as  float
-     * @param mixed $basis Integer indicating the type of day count to use.
-     *                             0 or omitted    US (NASD) 30/360
-     *                             1               Actual/actual
-     *                             2               Actual/360
-     *                             3               Actual/365
-     *                             4               European 30/360
-     *
-     * @return float|string (string containing the error type if there is an error)
-     */
-    public static function AMORLINC(
-        mixed $cost,
-        mixed $purchased,
-        mixed $firstPeriod,
-        mixed $salvage,
-        mixed $period,
-        mixed $rate,
-        mixed $basis = FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
-    ): string|float {
-        $cost = Functions::flattenSingleValue($cost);
-        $purchased = Functions::flattenSingleValue($purchased);
-        $firstPeriod = Functions::flattenSingleValue($firstPeriod);
-        $salvage = Functions::flattenSingleValue($salvage);
-        $period = Functions::flattenSingleValue($period);
-        $rate = Functions::flattenSingleValue($rate);
-        $basis = ($basis === null)
-            ? FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
-            : Functions::flattenSingleValue($basis);
-        try {
-            $cost = FinancialValidations::validateFloat($cost);
-            $purchased = FinancialValidations::validateDate($purchased);
-            $firstPeriod = FinancialValidations::validateDate($firstPeriod);
-            $salvage = FinancialValidations::validateFloat($salvage);
-            $period = FinancialValidations::validateFloat($period);
-            $rate = FinancialValidations::validateFloat($rate);
-            $basis = FinancialValidations::validateBasis($basis);
-        } catch (Exception $e) {
-            return $e->getMessage();
-        }
-        $fOneRate = $cost * $rate;
-        $fCostDelta = $cost - $salvage;
-        $purchasedYear = DateTimeExcel\DateParts::year($purchased);
-        $yearFracx = DateTimeExcel\YearFrac::fraction($purchased, $firstPeriod, $basis);
-        if (is_string($yearFracx)) {
-            return $yearFracx;
-        }
-        /** @var float $yearFrac */
-        $yearFrac = $yearFracx;
-        if (
-            $basis == FinancialConstants::BASIS_DAYS_PER_YEAR_ACTUAL
-            && $yearFrac < 1
-            && DateTimeExcel\Helpers::isLeapYear(Functions::scalar($purchasedYear))
-        ) {
-            $yearFrac *= 365 / 366;
-        }
-        $f0Rate = $yearFrac * $rate * $cost;
-        $nNumOfFullPeriods = (int) (($cost - $salvage - $f0Rate) / $fOneRate);
-        if ($period == 0) {
-            return $f0Rate;
-        } elseif ($period <= $nNumOfFullPeriods) {
-            return $fOneRate;
-        } elseif ($period == ($nNumOfFullPeriods + 1)) {
-            return $fCostDelta - $fOneRate * $nNumOfFullPeriods - $f0Rate;
-        }
-        return 0.0;
-    }
-    private static function getAmortizationCoefficient(float $rate): float
-    {
-        $fUsePer = 1.0 / $rate;
-        if ($fUsePer < 3.0) {
-            return 1.0;
-        } elseif ($fUsePer < 4.0) {
-            return 1.5;
-        } elseif ($fUsePer <= 6.0) {
-            return 2.0;
-        }
-        return 2.5;
-    }
-}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/Functions.php
@@ -0,0 +1,271 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+class Functions
+{
+    const PRECISION = 8.88E-016;
+    /**
+     * 2 / PI.
+     */
+    const M_2DIVPI = 0.63661977236758134307553505349006;
+    const COMPATIBILITY_EXCEL = 'Excel';
+    const COMPATIBILITY_GNUMERIC = 'Gnumeric';
+    const COMPATIBILITY_OPENOFFICE = 'OpenOfficeCalc';
+    /** Use of RETURNDATE_PHP_NUMERIC is discouraged - not 32-bit Y2038-safe, no timezone. */
+    const RETURNDATE_PHP_NUMERIC = 'P';
+    /** Use of RETURNDATE_UNIX_TIMESTAMP is discouraged - not 32-bit Y2038-safe, no timezone. */
+    const RETURNDATE_UNIX_TIMESTAMP = 'P';
+    const RETURNDATE_PHP_OBJECT = 'O';
+    const RETURNDATE_PHP_DATETIME_OBJECT = 'O';
+    const RETURNDATE_EXCEL = 'E';
+    public const NOT_YET_IMPLEMENTED = '#Not Yet Implemented';
+    /**
+     * Compatibility mode to use for error checking and responses.
+     */
+    protected static string $compatibilityMode = self::COMPATIBILITY_EXCEL;
+    /**
+     * Data Type to use when returning date values.
+     */
+    protected static string $returnDateType = self::RETURNDATE_EXCEL;
+    /**
+     * Set the Compatibility Mode.
+     *
+     * @param string $compatibilityMode Compatibility Mode
+     *                                  Permitted values are:
+     *                                      Functions::COMPATIBILITY_EXCEL        'Excel'
+     *                                      Functions::COMPATIBILITY_GNUMERIC     'Gnumeric'
+     *                                      Functions::COMPATIBILITY_OPENOFFICE   'OpenOfficeCalc'
+     *
+     * @return bool (Success or Failure)
+     */
+    public static function setCompatibilityMode(string $compatibilityMode): bool
+    {
+        if (
+            ($compatibilityMode == self::COMPATIBILITY_EXCEL)
+            || ($compatibilityMode == self::COMPATIBILITY_GNUMERIC)
+            || ($compatibilityMode == self::COMPATIBILITY_OPENOFFICE)
+        ) {
+            self::$compatibilityMode = $compatibilityMode;
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Return the current Compatibility Mode.
+     *
+     * @return string Compatibility Mode
+     *                Possible Return values are:
+     *                    Functions::COMPATIBILITY_EXCEL        'Excel'
+     *                    Functions::COMPATIBILITY_GNUMERIC     'Gnumeric'
+     *                    Functions::COMPATIBILITY_OPENOFFICE   'OpenOfficeCalc'
+     */
+    public static function getCompatibilityMode(): string
+    {
+        return self::$compatibilityMode;
+    }
+    /**
+     * Set the Return Date Format used by functions that return a date/time (Excel, PHP Serialized Numeric or PHP DateTime Object).
+     *
+     * @param string $returnDateType Return Date Format
+     *                               Permitted values are:
+     *                                   Functions::RETURNDATE_UNIX_TIMESTAMP       'P'
+     *                                   Functions::RETURNDATE_PHP_DATETIME_OBJECT  'O'
+     *                                   Functions::RETURNDATE_EXCEL                'E'
+     *
+     * @return bool Success or failure
+     */
+    public static function setReturnDateType(string $returnDateType): bool
+    {
+        if (
+            ($returnDateType == self::RETURNDATE_UNIX_TIMESTAMP)
+            || ($returnDateType == self::RETURNDATE_PHP_DATETIME_OBJECT)
+            || ($returnDateType == self::RETURNDATE_EXCEL)
+        ) {
+            self::$returnDateType = $returnDateType;
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Return the current Return Date Format for functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object).
+     *
+     * @return string Return Date Format
+     *                Possible Return values are:
+     *                    Functions::RETURNDATE_UNIX_TIMESTAMP         'P'
+     *                    Functions::RETURNDATE_PHP_DATETIME_OBJECT    'O'
+     *                    Functions::RETURNDATE_EXCEL            '     'E'
+     */
+    public static function getReturnDateType(): string
+    {
+        return self::$returnDateType;
+    }
+    /**
+     * DUMMY.
+     *
+     * @return string #Not Yet Implemented
+     */
+    public static function DUMMY(): string
+    {
+        return self::NOT_YET_IMPLEMENTED;
+    }
+    public static function isMatrixValue(mixed $idx): bool
+    {
+        return (substr_count($idx, '.') <= 1) || (preg_match('/\.[A-Z]/', $idx) > 0);
+    }
+    public static function isValue(mixed $idx): bool
+    {
+        return substr_count($idx, '.') === 0;
+    }
+    public static function isCellValue(mixed $idx): bool
+    {
+        return substr_count($idx, '.') > 1;
+    }
+    public static function ifCondition(mixed $condition): string
+    {
+        $condition = self::flattenSingleValue($condition);
+        if ($condition === '' || $condition === null) {
+            return '=""';
+        }
+        if (!is_string($condition) || !in_array($condition[0], ['>', '<', '='], true)) {
+            $condition = self::operandSpecialHandling($condition);
+            if (is_bool($condition)) {
+                return '=' . ($condition ? 'TRUE' : 'FALSE');
+            } elseif (!is_numeric($condition)) {
+                if ($condition !== '""') { // Not an empty string
+                    $condition = (string) preg_replace('/"/ui', '""', $condition);
+                }
+                $condition = Calculation::wrapResult(strtoupper($condition));
+            }
+            return str_replace('""""', '""', '=' . $condition);
+        }
+        preg_match('/(=|<[>=]?|>=?)(.*)/', $condition, $matches);
+        [, $operator, $operand] = $matches;
+        $operand = self::operandSpecialHandling($operand);
+        if (is_numeric(trim($operand, '"'))) {
+            $operand = trim($operand, '"');
+        } elseif (!is_numeric($operand) && $operand !== 'FALSE' && $operand !== 'TRUE') {
+            $operand = str_replace('"', '""', $operand);
+            $operand = Calculation::wrapResult(strtoupper($operand));
+        }
+        return str_replace('""""', '""', $operator . $operand);
+    }
+    private static function operandSpecialHandling(mixed $operand): mixed
+    {
+        if (is_numeric($operand) || is_bool($operand)) {
+            return $operand;
+        } elseif (strtoupper($operand) === Calculation::getTRUE() || strtoupper($operand) === Calculation::getFALSE()) {
+            return strtoupper($operand);
+        }
+        if (preg_match('/^\-?\d*\.?\d*\s?\%$/', $operand)) {
+            return ((float) rtrim($operand, '%')) / 100;
+        }
+        if (($dateValueOperand = Date::stringToExcel($operand)) !== false) {
+            return $dateValueOperand;
+        }
+        return $operand;
+    }
+    /**
+     * Convert a multi-dimensional array to a simple 1-dimensional array.
+     *
+     * @param mixed $array Array to be flattened
+     *
+     * @return array Flattened array
+     */
+    public static function flattenArray(mixed $array): array
+    {
+        if (!is_array($array)) {
+            return (array) $array;
+        }
+        $flattened = [];
+        $stack = array_values($array);
+        while (!empty($stack)) {
+            $value = array_shift($stack);
+            if (is_array($value)) {
+                array_unshift($stack, ...array_values($value));
+            } else {
+                $flattened[] = $value;
+            }
+        }
+        return $flattened;
+    }
+    public static function scalar(mixed $value): mixed
+    {
+        if (!is_array($value)) {
+            return $value;
+        }
+        do {
+            $value = array_pop($value);
+        } while (is_array($value));
+        return $value;
+    }
+    /**
+     * Convert a multi-dimensional array to a simple 1-dimensional array, but retain an element of indexing.
+     *
+     * @param array|mixed $array Array to be flattened
+     *
+     * @return array Flattened array
+     */
+    public static function flattenArrayIndexed($array): array
+    {
+        if (!is_array($array)) {
+            return (array) $array;
+        }
+        $arrayValues = [];
+        foreach ($array as $k1 => $value) {
+            if (is_array($value)) {
+                foreach ($value as $k2 => $val) {
+                    if (is_array($val)) {
+                        foreach ($val as $k3 => $v) {
+                            $arrayValues[$k1 . '.' . $k2 . '.' . $k3] = $v;
+                        }
+                    } else {
+                        $arrayValues[$k1 . '.' . $k2] = $val;
+                    }
+                }
+            } else {
+                $arrayValues[$k1] = $value;
+            }
+        }
+        return $arrayValues;
+    }
+    /**
+     * Convert an array to a single scalar value by extracting the first element.
+     *
+     * @param mixed $value Array or scalar value
+     */
+    public static function flattenSingleValue(mixed $value): mixed
+    {
+        while (is_array($value)) {
+            $value = array_shift($value);
+        }
+        return $value;
+    }
+    public static function expandDefinedName(string $coordinate, Cell $cell): string
+    {
+        $worksheet = $cell->getWorksheet();
+        $spreadsheet = $worksheet->getParentOrThrow();
+        $pCoordinatex = strtoupper($coordinate);
+        $pCoordinatex = (string) preg_replace('/^=/', '', $pCoordinatex);
+        $defined = $spreadsheet->getDefinedName($pCoordinatex, $worksheet);
+        if ($defined !== null) {
+            $worksheet2 = $defined->getWorkSheet();
+            if (!$defined->isFormula() && $worksheet2 !== null) {
+                $coordinate = "'" . $worksheet2->getTitle() . "'!"
+                    . (string) preg_replace('/^=/', '', str_replace('$', '', $defined->getValue()));
+            }
+        }
+        return $coordinate;
+    }
+    public static function trimTrailingRange(string $coordinate): string
+    {
+        return (string) preg_replace('/:[\\w\$]+$/', '', $coordinate);
+    }
+    public static function trimSheetFromCellReference(string $coordinate): string
+    {
+        if (str_contains($coordinate, '!')) {
+            $coordinate = substr($coordinate, strrpos($coordinate, '!') + 1);
+        }
+        return $coordinate;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/Information/ErrorValue.php
@@ -0,0 +1,62 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\Information;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+class ErrorValue
+{
+    use ArrayEnabled;
+    /**
+     * IS_ERR.
+     *
+     * @param mixed $value Value to check
+     *                      Or can be an array of values
+     *
+     * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function isErr(mixed $value = ''): array|bool
+    {
+        if (is_array($value)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
+        }
+        return self::isError($value) && (!self::isNa(($value)));
+    }
+    /**
+     * IS_ERROR.
+     *
+     * @param mixed $value Value to check
+     *                      Or can be an array of values
+     *
+     * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function isError(mixed $value = '', bool $tryNotImplemented = false): array|bool
+    {
+        if (is_array($value)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
+        }
+        if (!is_string($value)) {
+            return false;
+        }
+        if ($tryNotImplemented && $value === Functions::NOT_YET_IMPLEMENTED) {
+            return true;
+        }
+        return in_array($value, ExcelError::ERROR_CODES, true);
+    }
+    /**
+     * IS_NA.
+     *
+     * @param mixed $value Value to check
+     *                      Or can be an array of values
+     *
+     * @return array|bool If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function isNa(mixed $value = ''): array|bool
+    {
+        if (is_array($value)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
+        }
+        return $value === ExcelError::NA();
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/LookupRef/Matrix.php
@@ -0,0 +1,124 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\LookupRef;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+class Matrix
+{
+    use ArrayEnabled;
+    /**
+     * Helper function; NOT an implementation of any Excel Function.
+     */
+    public static function isColumnVector(array $values): bool
+    {
+        return count($values, COUNT_RECURSIVE) === (count($values, COUNT_NORMAL) * 2);
+    }
+    /**
+     * Helper function; NOT an implementation of any Excel Function.
+     */
+    public static function isRowVector(array $values): bool
+    {
+        return count($values, COUNT_RECURSIVE) > 1
+            && (count($values, COUNT_NORMAL) === 1 || count($values, COUNT_RECURSIVE) === count($values, COUNT_NORMAL));
+    }
+    /**
+     * TRANSPOSE.
+     *
+     * @param array|mixed $matrixData A matrix of values
+     */
+    public static function transpose($matrixData): array
+    {
+        $returnMatrix = [];
+        if (!is_array($matrixData)) {
+            $matrixData = [[$matrixData]];
+        }
+        $column = 0;
+        foreach ($matrixData as $matrixRow) {
+            $row = 0;
+            foreach ($matrixRow as $matrixCell) {
+                $returnMatrix[$row][$column] = $matrixCell;
+                ++$row;
+            }
+            ++$column;
+        }
+        return $returnMatrix;
+    }
+    /**
+     * INDEX.
+     *
+     * Uses an index to choose a value from a reference or array
+     *
+     * Excel Function:
+     *        =INDEX(range_array, row_num, [column_num], [area_num])
+     *
+     * @param mixed $matrix A range of cells or an array constant
+     * @param mixed $rowNum The row in the array or range from which to return a value.
+     *                          If row_num is omitted, column_num is required.
+     *                      Or can be an array of values
+     * @param mixed $columnNum The column in the array or range from which to return a value.
+     *                          If column_num is omitted, row_num is required.
+     *                      Or can be an array of values
+     *
+     * TODO Provide support for area_num, currently not supported
+     *
+     * @return mixed the value of a specified cell or array of cells
+     *         If an array of values is passed as the $rowNum and/or $columnNum arguments, then the returned result
+     *            will also be an array with the same dimensions
+     */
+    public static function index(mixed $matrix, mixed $rowNum = 0, mixed $columnNum = null): mixed
+    {
+        if (is_array($rowNum) || is_array($columnNum)) {
+            return self::evaluateArrayArgumentsSubsetFrom([self::class, __FUNCTION__], 1, $matrix, $rowNum, $columnNum);
+        }
+        $rowNum = $rowNum ?? 0;
+        $columnNum = $columnNum ?? 0;
+        try {
+            $rowNum = LookupRefValidations::validatePositiveInt($rowNum);
+            $columnNum = LookupRefValidations::validatePositiveInt($columnNum);
+        } catch (Exception $e) {
+            return $e->getMessage();
+        }
+        if (is_array($matrix) && count($matrix) === 1 && $rowNum > 1) {
+            $matrixKey = array_keys($matrix)[0];
+            if (is_array($matrix[$matrixKey])) {
+                $tempMatrix = [];
+                foreach ($matrix[$matrixKey] as $key => $value) {
+                    $tempMatrix[$key] = [$value];
+                }
+                $matrix = $tempMatrix;
+            }
+        }
+        if (!is_array($matrix) || ($rowNum > count($matrix))) {
+            return ExcelError::REF();
+        }
+        $rowKeys = array_keys($matrix);
+        $columnKeys = @array_keys($matrix[$rowKeys[0]]);
+        if ($columnNum > count($columnKeys)) {
+            return ExcelError::REF();
+        }
+        if ($columnNum === 0) {
+            return self::extractRowValue($matrix, $rowKeys, $rowNum);
+        }
+        $columnNum = $columnKeys[--$columnNum];
+        if ($rowNum === 0) {
+            return array_map(
+                fn ($value): array => [$value],
+                array_column($matrix, $columnNum)
+            );
+        }
+        $rowNum = $rowKeys[--$rowNum];
+        return $matrix[$rowNum][$columnNum];
+    }
+    private static function extractRowValue(array $matrix, array $rowKeys, int $rowNum): mixed
+    {
+        if ($rowNum === 0) {
+            return $matrix;
+        }
+        $rowNum = $rowKeys[--$rowNum];
+        $row = $matrix[$rowNum];
+        if (is_array($row)) {
+            return [$rowNum => $row];
+        }
+        return $row;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/MathTrig/Operations.php
@@ -0,0 +1,131 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\MathTrig;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+class Operations
+{
+    use ArrayEnabled;
+    /**
+     * MOD.
+     *
+     * @param mixed $dividend Dividend
+     *                      Or can be an array of values
+     * @param mixed $divisor Divisor
+     *                      Or can be an array of values
+     *
+     * @return array|float|string Remainder, or a string containing an error
+     *         If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function mod(mixed $dividend, mixed $divisor): array|string|float
+    {
+        if (is_array($dividend) || is_array($divisor)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $dividend, $divisor);
+        }
+        try {
+            $dividend = Helpers::validateNumericNullBool($dividend);
+            $divisor = Helpers::validateNumericNullBool($divisor);
+            Helpers::validateNotZero($divisor);
+        } catch (Exception $e) {
+            return $e->getMessage();
+        }
+        if (($dividend < 0.0) && ($divisor > 0.0)) {
+            return $divisor - fmod(abs($dividend), $divisor);
+        }
+        if (($dividend > 0.0) && ($divisor < 0.0)) {
+            return $divisor + fmod($dividend, abs($divisor));
+        }
+        return fmod($dividend, $divisor);
+    }
+    /**
+     * POWER.
+     *
+     * Computes x raised to the power y.
+     *
+     * @param null|array|bool|float|int|string $x Or can be an array of values
+     * @param null|array|bool|float|int|string $y Or can be an array of values
+     *
+     * @return array|float|int|string The result, or a string containing an error
+     *         If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function power(null|array|bool|float|int|string $x, null|array|bool|float|int|string $y): array|float|int|string
+    {
+        if (is_array($x) || is_array($y)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $x, $y);
+        }
+        try {
+            $x = Helpers::validateNumericNullBool($x);
+            $y = Helpers::validateNumericNullBool($y);
+        } catch (Exception $e) {
+            return $e->getMessage();
+        }
+        if (!$x && !$y) {
+            return ExcelError::NAN();
+        }
+        if (!$x && $y < 0.0) {
+            return ExcelError::DIV0();
+        }
+        $result = $x ** $y;
+        return Helpers::numberOrNan($result);
+    }
+    /**
+     * PRODUCT.
+     *
+     * PRODUCT returns the product of all the values and cells referenced in the argument list.
+     *
+     * Excel Function:
+     *        PRODUCT(value1[,value2[, ...]])
+     *
+     * @param mixed ...$args Data values
+     */
+    public static function product(mixed ...$args): string|float
+    {
+        $args = array_filter(
+            Functions::flattenArray($args),
+            fn ($value): bool => $value !== null
+        );
+        $returnValue = (count($args) === 0) ? 0.0 : 1.0;
+        foreach ($args as $arg) {
+            if (is_numeric($arg)) {
+                $returnValue *= $arg;
+            } else {
+                return ExcelError::throwError($arg);
+            }
+        }
+        return (float) $returnValue;
+    }
+    /**
+     * QUOTIENT.
+     *
+     * QUOTIENT function returns the integer portion of a division. Numerator is the divided number
+     *        and denominator is the divisor.
+     *
+     * Excel Function:
+     *        QUOTIENT(value1,value2)
+     *
+     * @param mixed $numerator Expect float|int
+     *                      Or can be an array of values
+     * @param mixed $denominator Expect float|int
+     *                      Or can be an array of values
+     *
+     * @return array|int|string If an array of numbers is passed as an argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function quotient(mixed $numerator, mixed $denominator): array|string|int
+    {
+        if (is_array($numerator) || is_array($denominator)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $numerator, $denominator);
+        }
+        try {
+            $numerator = Helpers::validateNumericNullSubstitution($numerator, 0);
+            $denominator = Helpers::validateNumericNullSubstitution($denominator, 0);
+            Helpers::validateNotZero($denominator);
+        } catch (Exception $e) {
+            return $e->getMessage();
+        }
+        return (int) ($numerator / $denominator);
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/CaseConvert.php
@@ -0,0 +1,78 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+class CaseConvert
+{
+    use ArrayEnabled;
+    /**
+     * LOWERCASE.
+     *
+     * Converts a string value to upper case.
+     *
+     * @param mixed $mixedCaseValue The string value to convert to lower case
+     *                              Or can be an array of values
+     *
+     * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function lower(mixed $mixedCaseValue): array|string
+    {
+        if (is_array($mixedCaseValue)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
+        }
+        try {
+            $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return StringHelper::strToLower($mixedCaseValue);
+    }
+    /**
+     * UPPERCASE.
+     *
+     * Converts a string value to upper case.
+     *
+     * @param mixed $mixedCaseValue The string value to convert to upper case
+     *                              Or can be an array of values
+     *
+     * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function upper(mixed $mixedCaseValue): array|string
+    {
+        if (is_array($mixedCaseValue)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
+        }
+        try {
+            $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return StringHelper::strToUpper($mixedCaseValue);
+    }
+    /**
+     * PROPERCASE.
+     *
+     * Converts a string value to proper or title case.
+     *
+     * @param mixed $mixedCaseValue The string value to convert to title case
+     *                              Or can be an array of values
+     *
+     * @return array|string If an array of values is passed as the argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function proper(mixed $mixedCaseValue): array|string
+    {
+        if (is_array($mixedCaseValue)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $mixedCaseValue);
+        }
+        try {
+            $mixedCaseValue = Helpers::extractString($mixedCaseValue, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return StringHelper::strToTitle($mixedCaseValue);
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/CharacterConvert.php
@@ -0,0 +1,78 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+class CharacterConvert
+{
+    use ArrayEnabled;
+    /**
+     * CHAR.
+     *
+     * @param mixed $character Integer Value to convert to its character representation
+     *                              Or can be an array of values
+     *
+     * @return array|string The character string
+     *         If an array of values is passed as the argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function character(mixed $character): array|string
+    {
+        if (is_array($character)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $character);
+        }
+        try {
+            $character = Helpers::validateInt($character, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $min = Functions::getCompatibilityMode() === Functions::COMPATIBILITY_OPENOFFICE ? 0 : 1;
+        if ($character < $min || $character > 255) {
+            return ExcelError::VALUE();
+        }
+        $result = iconv('UCS-4LE', 'UTF-8', pack('V', $character));
+        return ($result === false) ? '' : $result;
+    }
+    /**
+     * CODE.
+     *
+     * @param mixed $characters String character to convert to its ASCII value
+     *                              Or can be an array of values
+     *
+     * @return array|int|string A string if arguments are invalid
+     *         If an array of values is passed as the argument, then the returned result will also be an array
+     *            with the same dimensions
+     */
+    public static function code(mixed $characters): array|string|int
+    {
+        if (is_array($characters)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $characters);
+        }
+        try {
+            $characters = Helpers::extractString($characters, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        if ($characters === '') {
+            return ExcelError::VALUE();
+        }
+        $character = $characters;
+        if (mb_strlen($characters, 'UTF-8') > 1) {
+            $character = mb_substr($characters, 0, 1, 'UTF-8');
+        }
+        return self::unicodeToOrd($character);
+    }
+    private static function unicodeToOrd(string $character): int
+    {
+        $retVal = 0;
+        $iconv = iconv('UTF-8', 'UCS-4LE', $character);
+        if ($iconv !== false) {
+            $result = unpack('V', $iconv);
+            if (is_array($result) && isset($result[1])) {
+                $retVal = $result[1];
+            }
+        }
+        return $retVal;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Concatenate.php
@@ -0,0 +1,116 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+class Concatenate
+{
+    use ArrayEnabled;
+    /**
+     * CONCATENATE.
+     *
+     * @param array $args
+     */
+    public static function CONCATENATE(...$args): string
+    {
+        $returnValue = '';
+        $aArgs = Functions::flattenArray($args);
+        foreach ($aArgs as $arg) {
+            $value = Helpers::extractString($arg);
+            if (ErrorValue::isError($value, true)) {
+                $returnValue = $value;
+                break;
+            }
+            $returnValue .= Helpers::extractString($arg);
+            if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
+                $returnValue = ExcelError::CALC();
+                break;
+            }
+        }
+        return $returnValue;
+    }
+    /**
+     * TEXTJOIN.
+     *
+     * @param mixed $delimiter The delimter to use between the joined arguments
+     *                         Or can be an array of values
+     * @param mixed $ignoreEmpty true/false Flag indicating whether empty arguments should be skipped
+     *                         Or can be an array of values
+     * @param mixed $args The values to join
+     *
+     * @return array|string The joined string
+     *         If an array of values is passed for the $delimiter or $ignoreEmpty arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function TEXTJOIN(mixed $delimiter = '', mixed $ignoreEmpty = true, mixed ...$args): array|string
+    {
+        if (is_array($delimiter) || is_array($ignoreEmpty)) {
+            return self::evaluateArrayArgumentsSubset(
+                [self::class, __FUNCTION__],
+                2,
+                $delimiter,
+                $ignoreEmpty,
+                ...$args
+            );
+        }
+        $delimiter ??= '';
+        $ignoreEmpty ??= true;
+        $aArgs = Functions::flattenArray($args);
+        $returnValue = self::evaluateTextJoinArray($ignoreEmpty, $aArgs);
+        $returnValue ??= implode($delimiter, $aArgs);
+        if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
+            $returnValue = ExcelError::CALC();
+        }
+        return $returnValue;
+    }
+    private static function evaluateTextJoinArray(bool $ignoreEmpty, array &$aArgs): ?string
+    {
+        foreach ($aArgs as $key => &$arg) {
+            $value = Helpers::extractString($arg);
+            if (ErrorValue::isError($value, true)) {
+                return $value;
+            }
+            if ($ignoreEmpty === true && ((is_string($arg) && trim($arg) === '') || $arg === null)) {
+                unset($aArgs[$key]);
+            } elseif (is_bool($arg)) {
+                $arg = Helpers::convertBooleanValue($arg);
+            }
+        }
+        return null;
+    }
+    /**
+     * REPT.
+     *
+     * Returns the result of builtin function round after validating args.
+     *
+     * @param mixed $stringValue The value to repeat
+     *                         Or can be an array of values
+     * @param mixed $repeatCount The number of times the string value should be repeated
+     *                         Or can be an array of values
+     *
+     * @return array|string The repeated string
+     *         If an array of values is passed for the $stringValue or $repeatCount arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function builtinREPT(mixed $stringValue, mixed $repeatCount): array|string
+    {
+        if (is_array($stringValue) || is_array($repeatCount)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $stringValue, $repeatCount);
+        }
+        $stringValue = Helpers::extractString($stringValue);
+        if (!is_numeric($repeatCount) || $repeatCount < 0) {
+            $returnValue = ExcelError::VALUE();
+        } elseif (ErrorValue::isError($stringValue, true)) {
+            $returnValue = $stringValue;
+        } else {
+            $returnValue = str_repeat($stringValue, (int) $repeatCount);
+            if (StringHelper::countCharacters($returnValue) > DataType::MAX_STRING_LENGTH) {
+                $returnValue = ExcelError::VALUE(); // note VALUE not CALC
+            }
+        }
+        return $returnValue;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Extract.php
@@ -0,0 +1,244 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+class Extract
+{
+    use ArrayEnabled;
+    /**
+     * LEFT.
+     *
+     * @param mixed $value String value from which to extract characters
+     *                         Or can be an array of values
+     * @param mixed $chars The number of characters to extract (as an integer)
+     *                         Or can be an array of values
+     *
+     * @return array|string The joined string
+     *         If an array of values is passed for the $value or $chars arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function left(mixed $value, mixed $chars = 1): array|string
+    {
+        if (is_array($value) || is_array($chars)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $chars);
+        }
+        try {
+            $value = Helpers::extractString($value, true);
+            $chars = Helpers::extractInt($chars, 0, 1);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return mb_substr($value, 0, $chars, 'UTF-8');
+    }
+    /**
+     * MID.
+     *
+     * @param mixed $value String value from which to extract characters
+     *                         Or can be an array of values
+     * @param mixed $start Integer offset of the first character that we want to extract
+     *                         Or can be an array of values
+     * @param mixed $chars The number of characters to extract (as an integer)
+     *                         Or can be an array of values
+     *
+     * @return array|string The joined string
+     *         If an array of values is passed for the $value, $start or $chars arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function mid(mixed $value, mixed $start, mixed $chars): array|string
+    {
+        if (is_array($value) || is_array($start) || is_array($chars)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $start, $chars);
+        }
+        try {
+            $value = Helpers::extractString($value, true);
+            $start = Helpers::extractInt($start, 1);
+            $chars = Helpers::extractInt($chars, 0);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return mb_substr($value, --$start, $chars, 'UTF-8');
+    }
+    /**
+     * RIGHT.
+     *
+     * @param mixed $value String value from which to extract characters
+     *                         Or can be an array of values
+     * @param mixed $chars The number of characters to extract (as an integer)
+     *                         Or can be an array of values
+     *
+     * @return array|string The joined string
+     *         If an array of values is passed for the $value or $chars arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function right(mixed $value, mixed $chars = 1): array|string
+    {
+        if (is_array($value) || is_array($chars)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $chars);
+        }
+        try {
+            $value = Helpers::extractString($value, true);
+            $chars = Helpers::extractInt($chars, 0, 1);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return mb_substr($value, mb_strlen($value, 'UTF-8') - $chars, $chars, 'UTF-8');
+    }
+    /**
+     * TEXTBEFORE.
+     *
+     * @param mixed $text the text that you're searching
+     *                    Or can be an array of values
+     * @param null|array|string $delimiter the text that marks the point before which you want to extract
+     *                                 Multiple delimiters can be passed as an array of string values
+     * @param mixed $instance The instance of the delimiter after which you want to extract the text.
+     *                            By default, this is the first instance (1).
+     *                            A negative value means start searching from the end of the text string.
+     *                        Or can be an array of values
+     * @param mixed $matchMode Determines whether the match is case-sensitive or not.
+     *                           0 - Case-sensitive
+     *                           1 - Case-insensitive
+     *                        Or can be an array of values
+     * @param mixed $matchEnd Treats the end of text as a delimiter.
+     *                          0 - Don't match the delimiter against the end of the text.
+     *                          1 - Match the delimiter against the end of the text.
+     *                        Or can be an array of values
+     * @param mixed $ifNotFound value to return if no match is found
+     *                             The default is a #N/A Error
+     *                          Or can be an array of values
+     *
+     * @return array|string the string extracted from text before the delimiter; or the $ifNotFound value
+     *         If an array of values is passed for any of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function before(mixed $text, $delimiter, mixed $instance = 1, mixed $matchMode = 0, mixed $matchEnd = 0, mixed $ifNotFound = '#N/A'): array|string
+    {
+        if (is_array($text) || is_array($instance) || is_array($matchMode) || is_array($matchEnd) || is_array($ifNotFound)) {
+            return self::evaluateArrayArgumentsIgnore([self::class, __FUNCTION__], 1, $text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
+        }
+        try {
+            $text = Helpers::extractString($text ?? '', true);
+            Helpers::extractString(Functions::flattenSingleValue($delimiter ?? ''), true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $instance = (int) $instance;
+        $matchMode = (int) $matchMode;
+        $matchEnd = (int) $matchEnd;
+        $split = self::validateTextBeforeAfter($text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
+        if (is_string($split)) {
+            return $split;
+        }
+        if (Helpers::extractString(Functions::flattenSingleValue($delimiter ?? '')) === '') {
+            return ($instance > 0) ? '' : $text;
+        }
+        $flags = self::matchFlags($matchMode);
+        $delimiter = self::buildDelimiter($delimiter);
+        $adjust = preg_match('/^' . $delimiter . "\$/{$flags}", $split[0]);
+        $oddReverseAdjustment = count($split) % 2;
+        $split = ($instance < 0)
+            ? array_slice($split, 0, max(count($split) - (abs($instance) * 2 - 1) - $adjust - $oddReverseAdjustment, 0))
+            : array_slice($split, 0, $instance * 2 - 1 - $adjust);
+        return implode('', $split);
+    }
+    /**
+     * TEXTAFTER.
+     *
+     * @param mixed $text the text that you're searching
+     * @param null|array|string $delimiter the text that marks the point before which you want to extract
+     *                                 Multiple delimiters can be passed as an array of string values
+     * @param mixed $instance The instance of the delimiter after which you want to extract the text.
+     *                          By default, this is the first instance (1).
+     *                          A negative value means start searching from the end of the text string.
+     *                        Or can be an array of values
+     * @param mixed $matchMode Determines whether the match is case-sensitive or not.
+     *                            0 - Case-sensitive
+     *                            1 - Case-insensitive
+     *                         Or can be an array of values
+     * @param mixed $matchEnd Treats the end of text as a delimiter.
+     *                          0 - Don't match the delimiter against the end of the text.
+     *                          1 - Match the delimiter against the end of the text.
+     *                        Or can be an array of values
+     * @param mixed $ifNotFound value to return if no match is found
+     *                             The default is a #N/A Error
+     *                          Or can be an array of values
+     *
+     * @return array|string the string extracted from text before the delimiter; or the $ifNotFound value
+     *         If an array of values is passed for any of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function after(mixed $text, $delimiter, mixed $instance = 1, mixed $matchMode = 0, mixed $matchEnd = 0, mixed $ifNotFound = '#N/A'): array|string
+    {
+        if (is_array($text) || is_array($instance) || is_array($matchMode) || is_array($matchEnd) || is_array($ifNotFound)) {
+            return self::evaluateArrayArgumentsIgnore([self::class, __FUNCTION__], 1, $text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
+        }
+        try {
+            $text = Helpers::extractString($text ?? '', true);
+            Helpers::extractString(Functions::flattenSingleValue($delimiter ?? ''), true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $instance = (int) $instance;
+        $matchMode = (int) $matchMode;
+        $matchEnd = (int) $matchEnd;
+        $split = self::validateTextBeforeAfter($text, $delimiter, $instance, $matchMode, $matchEnd, $ifNotFound);
+        if (is_string($split)) {
+            return $split;
+        }
+        if (Helpers::extractString(Functions::flattenSingleValue($delimiter ?? '')) === '') {
+            return ($instance < 0) ? '' : $text;
+        }
+        $flags = self::matchFlags($matchMode);
+        $delimiter = self::buildDelimiter($delimiter);
+        $adjust = preg_match('/^' . $delimiter . "\$/{$flags}", $split[0]);
+        $oddReverseAdjustment = count($split) % 2;
+        $split = ($instance < 0)
+            ? array_slice($split, count($split) - ((int) abs($instance + 1) * 2) - $adjust - $oddReverseAdjustment)
+            : array_slice($split, $instance * 2 - $adjust);
+        return implode('', $split);
+    }
+    private static function validateTextBeforeAfter(string $text, null|array|string $delimiter, int $instance, int $matchMode, int $matchEnd, mixed $ifNotFound): array|string
+    {
+        $flags = self::matchFlags($matchMode);
+        $delimiter = self::buildDelimiter($delimiter);
+        if (preg_match('/' . $delimiter . "/{$flags}", $text) === 0 && $matchEnd === 0) {
+            return $ifNotFound;
+        }
+        $split = preg_split('/' . $delimiter . "/{$flags}", $text, 0, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);
+        if ($split === false) {
+            return ExcelError::NA();
+        }
+        if ($instance === 0 || abs($instance) > StringHelper::countCharacters($text)) {
+            return ExcelError::VALUE();
+        }
+        if ($matchEnd === 0 && (abs($instance) > floor(count($split) / 2))) {
+            return ExcelError::NA();
+        } elseif ($matchEnd !== 0 && (abs($instance) - 1 > ceil(count($split) / 2))) {
+            return ExcelError::NA();
+        }
+        return $split;
+    }
+    /**
+     * @param null|array|string $delimiter the text that marks the point before which you want to extract
+     *                                 Multiple delimiters can be passed as an array of string values
+     */
+    private static function buildDelimiter($delimiter): string
+    {
+        if (is_array($delimiter)) {
+            $delimiter = Functions::flattenArray($delimiter);
+            $quotedDelimiters = array_map(
+                fn ($delimiter): string => preg_quote($delimiter ?? '', '/'),
+                $delimiter
+            );
+            $delimiters = implode('|', $quotedDelimiters);
+            return '(' . $delimiters . ')';
+        }
+        return '(' . preg_quote($delimiter ?? '', '/') . ')';
+    }
+    private static function matchFlags(int $matchMode): string
+    {
+        return ($matchMode === 0) ? 'mu' : 'miu';
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Format.php
@@ -0,0 +1,282 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use DateTimeInterface;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Calculation\MathTrig;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+class Format
+{
+    use ArrayEnabled;
+    /**
+     * DOLLAR.
+     *
+     * This function converts a number to text using currency format, with the decimals rounded to the specified place.
+     * The format used is $#,##0.00_);($#,##0.00)..
+     *
+     * @param mixed $value The value to format
+     *                         Or can be an array of values
+     * @param mixed $decimals The number of digits to display to the right of the decimal point (as an integer).
+     *                            If decimals is negative, number is rounded to the left of the decimal point.
+     *                            If you omit decimals, it is assumed to be 2
+     *                         Or can be an array of values
+     *
+     * @return array|string If an array of values is passed for either of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function DOLLAR(mixed $value = 0, mixed $decimals = 2)
+    {
+        if (is_array($value) || is_array($decimals)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimals);
+        }
+        try {
+            $value = Helpers::extractFloat($value);
+            $decimals = Helpers::extractInt($decimals, -100, 0, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $mask = '$#,##0';
+        if ($decimals > 0) {
+            $mask .= '.' . str_repeat('0', $decimals);
+        } else {
+            $round = 10 ** abs($decimals);
+            if ($value < 0) {
+                $round = 0 - $round;
+            }
+            /** @var float|int|string */
+            $value = MathTrig\Round::multiple($value, $round);
+        }
+        $mask = "{$mask};-{$mask}";
+        return NumberFormat::toFormattedString($value, $mask);
+    }
+    /**
+     * FIXED.
+     *
+     * @param mixed $value The value to format
+     *                         Or can be an array of values
+     * @param mixed $decimals Integer value for the number of decimal places that should be formatted
+     *                         Or can be an array of values
+     * @param mixed $noCommas Boolean value indicating whether the value should have thousands separators or not
+     *                         Or can be an array of values
+     *
+     * @return array|string If an array of values is passed for either of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function FIXEDFORMAT(mixed $value, mixed $decimals = 2, mixed $noCommas = false): array|string
+    {
+        if (is_array($value) || is_array($decimals) || is_array($noCommas)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimals, $noCommas);
+        }
+        try {
+            $value = Helpers::extractFloat($value);
+            $decimals = Helpers::extractInt($decimals, -100, 0, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $valueResult = round($value, $decimals);
+        if ($decimals < 0) {
+            $decimals = 0;
+        }
+        if ($noCommas === false) {
+            $valueResult = number_format(
+                $valueResult,
+                $decimals,
+                StringHelper::getDecimalSeparator(),
+                StringHelper::getThousandsSeparator()
+            );
+        }
+        return (string) $valueResult;
+    }
+    /**
+     * TEXT.
+     *
+     * @param mixed $value The value to format
+     *                         Or can be an array of values
+     * @param mixed $format A string with the Format mask that should be used
+     *                         Or can be an array of values
+     *
+     * @return array|string If an array of values is passed for either of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function TEXTFORMAT(mixed $value, mixed $format): array|string
+    {
+        if (is_array($value) || is_array($format)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $format);
+        }
+        try {
+            $value = Helpers::extractString($value, true);
+            $format = Helpers::extractString($format, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        $format = (string) NumberFormat::convertSystemFormats($format);
+        if (!is_numeric($value) && Date::isDateTimeFormatCode($format)) {
+            $value1 = DateTimeExcel\DateValue::fromString($value);
+            $value2 = DateTimeExcel\TimeValue::fromString($value);
+            /** @var float|int|string */
+            $value = (is_numeric($value1) && is_numeric($value2)) ? ($value1 + $value2) : (is_numeric($value1) ? $value2 : $value1);
+        }
+        return (string) NumberFormat::toFormattedString($value, $format);
+    }
+    /**
+     * @param mixed $value Value to check
+     */
+    private static function convertValue(mixed $value, bool $spacesMeanZero = false): mixed
+    {
+        $value = $value ?? 0;
+        if (is_bool($value)) {
+            if (Functions::getCompatibilityMode() === Functions::COMPATIBILITY_OPENOFFICE) {
+                $value = (int) $value;
+            } else {
+                throw new CalcExp(ExcelError::VALUE());
+            }
+        }
+        if (is_string($value)) {
+            $value = trim($value);
+            if (ErrorValue::isError($value, true)) {
+                throw new CalcExp($value);
+            }
+            if ($spacesMeanZero && $value === '') {
+                $value = 0;
+            }
+        }
+        return $value;
+    }
+    /**
+     * VALUE.
+     *
+     * @param mixed $value Value to check
+     *                         Or can be an array of values
+     *
+     * @return array|DateTimeInterface|float|int|string A string if arguments are invalid
+     *         If an array of values is passed for the argument, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function VALUE(mixed $value = '')
+    {
+        if (is_array($value)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
+        }
+        try {
+            $value = self::convertValue($value);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        if (!is_numeric($value)) {
+            $numberValue = str_replace(
+                StringHelper::getThousandsSeparator(),
+                '',
+                trim($value, " \t\n\r\0\x0B" . StringHelper::getCurrencyCode())
+            );
+            if ($numberValue === '') {
+                return ExcelError::VALUE();
+            }
+            if (is_numeric($numberValue)) {
+                return (float) $numberValue;
+            }
+            $dateSetting = Functions::getReturnDateType();
+            Functions::setReturnDateType(Functions::RETURNDATE_EXCEL);
+            if (str_contains($value, ':')) {
+                $timeValue = Functions::scalar(DateTimeExcel\TimeValue::fromString($value));
+                if ($timeValue !== ExcelError::VALUE()) {
+                    Functions::setReturnDateType($dateSetting);
+                    return $timeValue;
+                }
+            }
+            $dateValue = Functions::scalar(DateTimeExcel\DateValue::fromString($value));
+            if ($dateValue !== ExcelError::VALUE()) {
+                Functions::setReturnDateType($dateSetting);
+                return $dateValue;
+            }
+            Functions::setReturnDateType($dateSetting);
+            return ExcelError::VALUE();
+        }
+        return (float) $value;
+    }
+    /**
+     * VALUETOTEXT.
+     *
+     * @param mixed $value The value to format
+     *                         Or can be an array of values
+     *
+     * @return array|string If an array of values is passed for either of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function valueToText(mixed $value, mixed $format = false): array|string
+    {
+        if (is_array($value) || is_array($format)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $format);
+        }
+        $format = (bool) $format;
+        if (is_object($value) && $value instanceof RichText) {
+            $value = $value->getPlainText();
+        }
+        if (is_string($value)) {
+            $value = ($format === true) ? Calculation::wrapResult($value) : $value;
+            $value = str_replace("\n", '', $value);
+        } elseif (is_bool($value)) {
+            $value = Calculation::getLocaleBoolean($value ? 'TRUE' : 'FALSE');
+        }
+        return (string) $value;
+    }
+    private static function getDecimalSeparator(mixed $decimalSeparator): string
+    {
+        return empty($decimalSeparator) ? StringHelper::getDecimalSeparator() : (string) $decimalSeparator;
+    }
+    private static function getGroupSeparator(mixed $groupSeparator): string
+    {
+        return empty($groupSeparator) ? StringHelper::getThousandsSeparator() : (string) $groupSeparator;
+    }
+    /**
+     * NUMBERVALUE.
+     *
+     * @param mixed $value The value to format
+     *                         Or can be an array of values
+     * @param mixed $decimalSeparator A string with the decimal separator to use, defaults to locale defined value
+     *                         Or can be an array of values
+     * @param mixed $groupSeparator A string with the group/thousands separator to use, defaults to locale defined value
+     *                         Or can be an array of values
+     */
+    public static function NUMBERVALUE(mixed $value = '', mixed $decimalSeparator = null, mixed $groupSeparator = null): array|string|float
+    {
+        if (is_array($value) || is_array($decimalSeparator) || is_array($groupSeparator)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value, $decimalSeparator, $groupSeparator);
+        }
+        try {
+            $value = self::convertValue($value, true);
+            $decimalSeparator = self::getDecimalSeparator($decimalSeparator);
+            $groupSeparator = self::getGroupSeparator($groupSeparator);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        if (!is_numeric($value)) {
+            $decimalPositions = preg_match_all('/' . preg_quote($decimalSeparator, '/') . '/', $value, $matches, PREG_OFFSET_CAPTURE);
+            if ($decimalPositions > 1) {
+                return ExcelError::VALUE();
+            }
+            $decimalOffset = array_pop($matches[0])[1] ?? null;
+            if ($decimalOffset === null || strpos($value, $groupSeparator, $decimalOffset) !== false) {
+                return ExcelError::VALUE();
+            }
+            $value = str_replace([$groupSeparator, $decimalSeparator], ['', '.'], $value);
+            $percentageString = rtrim($value, '%');
+            if (!is_numeric($percentageString)) {
+                return ExcelError::VALUE();
+            }
+            $percentageAdjustment = strlen($value) - strlen($percentageString);
+            if ($percentageAdjustment) {
+                $value = (float) $percentageString;
+                $value /= 10 ** ($percentageAdjustment * 2);
+            }
+        }
+        return is_array($value) ? ExcelError::VALUE() : (float) $value;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Helpers.php
@@ -0,0 +1,77 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+class Helpers
+{
+    public static function convertBooleanValue(bool $value): string
+    {
+        if (Functions::getCompatibilityMode() == Functions::COMPATIBILITY_OPENOFFICE) {
+            return $value ? '1' : '0';
+        }
+        return ($value) ? Calculation::getTRUE() : Calculation::getFALSE();
+    }
+    /**
+     * @param mixed $value String value from which to extract characters
+     */
+    public static function extractString(mixed $value, bool $throwIfError = false): string
+    {
+        if (is_bool($value)) {
+            return self::convertBooleanValue($value);
+        }
+        if ($throwIfError && is_string($value) && ErrorValue::isError($value, true)) {
+            throw new CalcExp($value);
+        }
+        return (string) $value;
+    }
+    public static function extractInt(mixed $value, int $minValue, int $gnumericNull = 0, bool $ooBoolOk = false): int
+    {
+        if ($value === null) {
+            $value = (Functions::getCompatibilityMode() === Functions::COMPATIBILITY_GNUMERIC) ? $gnumericNull : 0;
+        }
+        if (is_bool($value) && ($ooBoolOk || Functions::getCompatibilityMode() !== Functions::COMPATIBILITY_OPENOFFICE)) {
+            $value = (int) $value;
+        }
+        if (!is_numeric($value)) {
+            throw new CalcExp(ExcelError::VALUE());
+        }
+        $value = (int) $value;
+        if ($value < $minValue) {
+            throw new CalcExp(ExcelError::VALUE());
+        }
+        return (int) $value;
+    }
+    public static function extractFloat(mixed $value): float
+    {
+        if ($value === null) {
+            $value = 0.0;
+        }
+        if (is_bool($value)) {
+            $value = (float) $value;
+        }
+        if (!is_numeric($value)) {
+            if (is_string($value) && ErrorValue::isError($value, true)) {
+                throw new CalcExp($value);
+            }
+            throw new CalcExp(ExcelError::VALUE());
+        }
+        return (float) $value;
+    }
+    public static function validateInt(mixed $value, bool $throwIfError = false): int
+    {
+        if ($value === null) {
+            $value = 0;
+        } elseif (is_bool($value)) {
+            $value = (int) $value;
+        } elseif ($throwIfError && is_string($value) && !is_numeric($value)) {
+            if (!ErrorValue::isError($value, true)) {
+                $value = ExcelError::VALUE();
+            }
+            throw new CalcExp($value);
+        }
+        return (int) $value;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Search.php
@@ -0,0 +1,84 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+class Search
+{
+    use ArrayEnabled;
+    /**
+     * FIND (case sensitive search).
+     *
+     * @param mixed $needle The string to look for
+     *                         Or can be an array of values
+     * @param mixed $haystack The string in which to look
+     *                         Or can be an array of values
+     * @param mixed $offset Integer offset within $haystack to start searching from
+     *                         Or can be an array of values
+     *
+     * @return array|int|string The offset where the first occurrence of needle was found in the haystack
+     *         If an array of values is passed for the $value or $chars arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function sensitive(mixed $needle, mixed $haystack, mixed $offset = 1): array|string|int
+    {
+        if (is_array($needle) || is_array($haystack) || is_array($offset)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $needle, $haystack, $offset);
+        }
+        try {
+            $needle = Helpers::extractString($needle, true);
+            $haystack = Helpers::extractString($haystack, true);
+            $offset = Helpers::extractInt($offset, 1, 0, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        if (StringHelper::countCharacters($haystack) >= $offset) {
+            if (StringHelper::countCharacters($needle) === 0) {
+                return $offset;
+            }
+            $pos = mb_strpos($haystack, $needle, --$offset, 'UTF-8');
+            if ($pos !== false) {
+                return ++$pos;
+            }
+        }
+        return ExcelError::VALUE();
+    }
+    /**
+     * SEARCH (case insensitive search).
+     *
+     * @param mixed $needle The string to look for
+     *                         Or can be an array of values
+     * @param mixed $haystack The string in which to look
+     *                         Or can be an array of values
+     * @param mixed $offset Integer offset within $haystack to start searching from
+     *                         Or can be an array of values
+     *
+     * @return array|int|string The offset where the first occurrence of needle was found in the haystack
+     *         If an array of values is passed for the $value or $chars arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function insensitive(mixed $needle, mixed $haystack, mixed $offset = 1): array|string|int
+    {
+        if (is_array($needle) || is_array($haystack) || is_array($offset)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $needle, $haystack, $offset);
+        }
+        try {
+            $needle = Helpers::extractString($needle, true);
+            $haystack = Helpers::extractString($haystack, true);
+            $offset = Helpers::extractInt($offset, 1, 0, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        if (StringHelper::countCharacters($haystack) >= $offset) {
+            if (StringHelper::countCharacters($needle) === 0) {
+                return $offset;
+            }
+            $pos = mb_stripos($haystack, $needle, --$offset, 'UTF-8');
+            if ($pos !== false) {
+                return ++$pos;
+            }
+        }
+        return ExcelError::VALUE();
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Calculation/TextData/Text.php
@@ -0,0 +1,213 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Calculation\TextData;
+use PhpOffice\PhpSpreadsheet\Calculation\ArrayEnabled;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalcExp;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
+class Text
+{
+    use ArrayEnabled;
+    /**
+     * LEN.
+     *
+     * @param mixed $value String Value
+     *                         Or can be an array of values
+     *
+     * @return array|int|string If an array of values is passed for the argument, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function length(mixed $value = ''): array|int|string
+    {
+        if (is_array($value)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $value);
+        }
+        try {
+            $value = Helpers::extractString($value, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return mb_strlen($value, 'UTF-8');
+    }
+    /**
+     * Compares two text strings and returns TRUE if they are exactly the same, FALSE otherwise.
+     * EXACT is case-sensitive but ignores formatting differences.
+     * Use EXACT to test text being entered into a document.
+     *
+     * @param mixed $value1 String Value
+     *                         Or can be an array of values
+     * @param mixed $value2 String Value
+     *                         Or can be an array of values
+     *
+     * @return array|bool|string If an array of values is passed for either of the arguments, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function exact(mixed $value1, mixed $value2): array|bool|string
+    {
+        if (is_array($value1) || is_array($value2)) {
+            return self::evaluateArrayArguments([self::class, __FUNCTION__], $value1, $value2);
+        }
+        try {
+            $value1 = Helpers::extractString($value1, true);
+            $value2 = Helpers::extractString($value2, true);
+        } catch (CalcExp $e) {
+            return $e->getMessage();
+        }
+        return $value2 === $value1;
+    }
+    /**
+     * T.
+     *
+     * @param mixed $testValue Value to check
+     *                         Or can be an array of values
+     *
+     * @return array|string If an array of values is passed for the argument, then the returned result
+     *            will also be an array with matching dimensions
+     */
+    public static function test(mixed $testValue = ''): array|string
+    {
+        if (is_array($testValue)) {
+            return self::evaluateSingleArgumentArray([self::class, __FUNCTION__], $testValue);
+        }
+        if (is_string($testValue)) {
+            return $testValue;
+        }
+        return '';
+    }
+    /**
+     * TEXTSPLIT.
+     *
+     * @param mixed $text the text that you're searching
+     * @param null|array|string $columnDelimiter The text that marks the point where to spill the text across columns.
+     *                          Multiple delimiters can be passed as an array of string values
+     * @param null|array|string $rowDelimiter The text that marks the point where to spill the text down rows.
+     *                          Multiple delimiters can be passed as an array of string values
+     * @param bool $ignoreEmpty Specify FALSE to create an empty cell when two delimiters are consecutive.
+     *                              true = create empty cells
+     *                              false = skip empty cells
+     *                              Defaults to TRUE, which creates an empty cell
+     * @param bool $matchMode Determines whether the match is case-sensitive or not.
+     *                              true = case-sensitive
+     *                              false = case-insensitive
+     *                         By default, a case-sensitive match is done.
+     * @param mixed $padding The value with which to pad the result.
+     *                              The default is #N/A.
+     *
+     * @return array|string the array built from the text, split by the row and column delimiters, or an error string
+     */
+    public static function split(mixed $text, $columnDelimiter = null, $rowDelimiter = null, bool $ignoreEmpty = false, bool $matchMode = true, mixed $padding = '#N/A'): array|string
+    {
+        $text = Functions::flattenSingleValue($text);
+        if (ErrorValue::isError($text, true)) {
+            return $text;
+        }
+        $flags = self::matchFlags($matchMode);
+        if ($rowDelimiter !== null) {
+            $delimiter = self::buildDelimiter($rowDelimiter);
+            $rows = ($delimiter === '()')
+                ? [$text]
+                : preg_split("/{$delimiter}/{$flags}", $text);
+        } else {
+            $rows = [$text];
+        }
+        /** @var array $rows */
+        if ($ignoreEmpty === true) {
+            $rows = array_values(array_filter(
+                $rows,
+                fn ($row): bool => $row !== ''
+            ));
+        }
+        if ($columnDelimiter !== null) {
+            $delimiter = self::buildDelimiter($columnDelimiter);
+            array_walk(
+                $rows,
+                function (&$row) use ($delimiter, $flags, $ignoreEmpty): void {
+                    $row = ($delimiter === '()')
+                        ? [$row]
+                        : preg_split("/{$delimiter}/{$flags}", $row);
+                    /** @var array $row */
+                    if ($ignoreEmpty === true) {
+                        $row = array_values(array_filter(
+                            $row,
+                            fn ($value): bool => $value !== ''
+                        ));
+                    }
+                }
+            );
+            if ($ignoreEmpty === true) {
+                $rows = array_values(array_filter(
+                    $rows,
+                    fn ($row): bool => $row !== [] && $row !== ['']
+                ));
+            }
+        }
+        return self::applyPadding($rows, $padding);
+    }
+    private static function applyPadding(array $rows, mixed $padding): array
+    {
+        $columnCount = array_reduce(
+            $rows,
+            fn (int $counter, array $row): int => max($counter, count($row)),
+            0
+        );
+        return array_map(
+            function (array $row) use ($columnCount, $padding): array {
+                return (count($row) < $columnCount)
+                    ? array_merge($row, array_fill(0, $columnCount - count($row), $padding))
+                    : $row;
+            },
+            $rows
+        );
+    }
+    /**
+     * @param null|array|string $delimiter the text that marks the point before which you want to split
+     *                                 Multiple delimiters can be passed as an array of string values
+     */
+    private static function buildDelimiter($delimiter): string
+    {
+        $valueSet = Functions::flattenArray($delimiter);
+        if (is_array($delimiter) && count($valueSet) > 1) {
+            $quotedDelimiters = array_map(
+                fn ($delimiter): string => preg_quote($delimiter ?? '', '/'),
+                $valueSet
+            );
+            $delimiters = implode('|', $quotedDelimiters);
+            return '(' . $delimiters . ')';
+        }
+        return '(' . preg_quote(Functions::flattenSingleValue($delimiter), '/') . ')';
+    }
+    private static function matchFlags(bool $matchMode): string
+    {
+        return ($matchMode === true) ? 'miu' : 'mu';
+    }
+    public static function fromArray(array $array, int $format = 0): string
+    {
+        $result = [];
+        foreach ($array as $row) {
+            $cells = [];
+            foreach ($row as $cellValue) {
+                $value = ($format === 1) ? self::formatValueMode1($cellValue) : self::formatValueMode0($cellValue);
+                $cells[] = $value;
+            }
+            $result[] = implode(($format === 1) ? ',' : ', ', $cells);
+        }
+        $result = implode(($format === 1) ? ';' : ', ', $result);
+        return ($format === 1) ? '{' . $result . '}' : $result;
+    }
+    private static function formatValueMode0(mixed $cellValue): string
+    {
+        if (is_bool($cellValue)) {
+            return Calculation::getLocaleBoolean($cellValue ? 'TRUE' : 'FALSE');
+        }
+        return (string) $cellValue;
+    }
+    private static function formatValueMode1(mixed $cellValue): string
+    {
+        if (is_string($cellValue) && ErrorValue::isError($cellValue) === false) {
+            return Calculation::FORMULA_STRING_QUOTE . $cellValue . Calculation::FORMULA_STRING_QUOTE;
+        } elseif (is_bool($cellValue)) {
+            return Calculation::getLocaleBoolean($cellValue ? 'TRUE' : 'FALSE');
+        }
+        return (string) $cellValue;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/AdvancedValueBinder.php
@@ -0,0 +1,145 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Engine\FormattedNumber;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+class AdvancedValueBinder extends DefaultValueBinder implements IValueBinder
+{
+    /**
+     * Bind value to a cell.
+     *
+     * @param Cell $cell Cell to bind value to
+     * @param mixed $value Value to bind in cell
+     */
+    public function bindValue(Cell $cell, mixed $value = null): bool
+    {
+        if ($value === null) {
+            return parent::bindValue($cell, $value);
+        } elseif (is_string($value)) {
+            $value = StringHelper::sanitizeUTF8($value);
+        }
+        $dataType = parent::dataTypeForValue($value);
+        if ($dataType === DataType::TYPE_STRING && is_string($value)) {
+            if (StringHelper::strToUpper($value) === Calculation::getTRUE()) {
+                $cell->setValueExplicit(true, DataType::TYPE_BOOL);
+                return true;
+            } elseif (StringHelper::strToUpper($value) === Calculation::getFALSE()) {
+                $cell->setValueExplicit(false, DataType::TYPE_BOOL);
+                return true;
+            }
+            if (preg_match('~^([+-]?)\s*(\d+)\s*/\s*(\d+)$~', $value, $matches)) {
+                return $this->setProperFraction($matches, $cell);
+            } elseif (preg_match('~^([+-]?)(\d+)\s+(\d+)\s*/\s*(\d+)$~', $value, $matches)) {
+                return $this->setImproperFraction($matches, $cell);
+            }
+            $decimalSeparatorNoPreg = StringHelper::getDecimalSeparator();
+            $decimalSeparator = preg_quote($decimalSeparatorNoPreg, '/');
+            $thousandsSeparator = preg_quote(StringHelper::getThousandsSeparator(), '/');
+            if (preg_match('/^\-?\d*' . $decimalSeparator . '?\d*\s?\%$/', (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value))) {
+                return $this->setPercentage((string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value), $cell);
+            }
+            if (preg_match(FormattedNumber::currencyMatcherRegexp(), (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value), $matches, PREG_UNMATCHED_AS_NULL)) {
+                $sign = ($matches['PrefixedSign'] ?? $matches['PrefixedSign2'] ?? $matches['PostfixedSign']) ?? null;
+                $currencyCode = $matches['PrefixedCurrency'] ?? $matches['PostfixedCurrency'];
+                /** @var string */
+                $temp = str_replace([$decimalSeparatorNoPreg, $currencyCode, ' ', '-'], ['.', '', '', ''], (string) preg_replace('/(\d)' . $thousandsSeparator . '(\d)/u', '$1$2', $value));
+                $value = (float) ($sign . trim($temp));
+                return $this->setCurrency($value, $cell, $currencyCode ?? '');
+            }
+            if (preg_match('/^(\d|[0-1]\d|2[0-3]):[0-5]\d$/', $value)) {
+                return $this->setTimeHoursMinutes($value, $cell);
+            }
+            if (preg_match('/^(\d|[0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$/', $value)) {
+                return $this->setTimeHoursMinutesSeconds($value, $cell);
+            }
+            if (($d = Date::stringToExcel($value)) !== false) {
+                $cell->setValueExplicit($d, DataType::TYPE_NUMERIC);
+                if (str_contains($value, ':')) {
+                    $formatCode = 'yyyy-mm-dd h:mm';
+                } else {
+                    $formatCode = 'yyyy-mm-dd';
+                }
+                $cell->getWorksheet()->getStyle($cell->getCoordinate())
+                    ->getNumberFormat()->setFormatCode($formatCode);
+                return true;
+            }
+            if (str_contains($value, "\n")) {
+                $cell->setValueExplicit($value, DataType::TYPE_STRING);
+                $cell->getWorksheet()->getStyle($cell->getCoordinate())
+                    ->getAlignment()->setWrapText(true);
+                return true;
+            }
+        }
+        return parent::bindValue($cell, $value);
+    }
+    protected function setImproperFraction(array $matches, Cell $cell): bool
+    {
+        $value = $matches[2] + ($matches[3] / $matches[4]);
+        if ($matches[1] === '-') {
+            $value = 0 - $value;
+        }
+        $cell->setValueExplicit((float) $value, DataType::TYPE_NUMERIC);
+        $dividend = str_repeat('?', strlen($matches[3]));
+        $divisor = str_repeat('?', strlen($matches[4]));
+        $fractionMask = "# {$dividend}/{$divisor}";
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode($fractionMask);
+        return true;
+    }
+    protected function setProperFraction(array $matches, Cell $cell): bool
+    {
+        $value = $matches[2] / $matches[3];
+        if ($matches[1] === '-') {
+            $value = 0 - $value;
+        }
+        $cell->setValueExplicit((float) $value, DataType::TYPE_NUMERIC);
+        $dividend = str_repeat('?', strlen($matches[2]));
+        $divisor = str_repeat('?', strlen($matches[3]));
+        $fractionMask = "{$dividend}/{$divisor}";
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode($fractionMask);
+        return true;
+    }
+    protected function setPercentage(string $value, Cell $cell): bool
+    {
+        $value = ((float) str_replace('%', '', $value)) / 100;
+        $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_PERCENTAGE_00);
+        return true;
+    }
+    protected function setCurrency(float $value, Cell $cell, string $currencyCode): bool
+    {
+        $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode(
+                str_replace('$', '[$' . $currencyCode . ']', NumberFormat::FORMAT_CURRENCY_USD)
+            );
+        return true;
+    }
+    protected function setTimeHoursMinutes(string $value, Cell $cell): bool
+    {
+        [$hours, $minutes] = explode(':', $value);
+        $hours = (int) $hours;
+        $minutes = (int) $minutes;
+        $days = ($hours / 24) + ($minutes / 1440);
+        $cell->setValueExplicit($days, DataType::TYPE_NUMERIC);
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_DATE_TIME3);
+        return true;
+    }
+    protected function setTimeHoursMinutesSeconds(string $value, Cell $cell): bool
+    {
+        [$hours, $minutes, $seconds] = explode(':', $value);
+        $hours = (int) $hours;
+        $minutes = (int) $minutes;
+        $seconds = (int) $seconds;
+        $days = ($hours / 24) + ($minutes / 1440) + ($seconds / 86400);
+        $cell->setValueExplicit($days, DataType::TYPE_NUMERIC);
+        $cell->getWorksheet()->getStyle($cell->getCoordinate())
+            ->getNumberFormat()->setFormatCode(NumberFormat::FORMAT_DATE_TIME4);
+        return true;
+    }
+}

--- a/src/PhpSpreadsheet/Cell/Cell.php
+++ b/src/PhpSpreadsheet/Cell/Cell.php
@@ -36,20 +36,22 @@
      *
      * @var mixed
      */
     private $calculatedValue;
     /**
      * Type of the cell data.
      */
     private string $dataType;
     /**
      * The collection of cells that this cell belongs to (i.e. The Cell Collection for the parent Worksheet).
+     *
+     * @var ?Cells
      */
     private ?Cells $parent;
     /**
      * Index to the cellXf reference for the styling of this cell.
      */
     private int $xfIndex = 0;
     /**
      * Attributes of the formula.
      */
     private mixed $formulaAttributes = null;
@@ -256,35 +258,21 @@
             case DataType::TYPE_ERROR:
                 $this->value = DataType::checkErrorCode($value);
                 break;
             default:
                 throw new SpreadsheetException('Invalid datatype: ' . $dataType);
         }
         $this->dataType = $dataType;
         $this->updateInCollection();
         $cellCoordinate = $this->getCoordinate();
         self::updateIfCellIsTableHeader($this->getParent()?->getParent(), $this, $oldValue, $value);
-        $worksheet = $this->getWorksheet();
-        $spreadsheet = $worksheet->getParent();
-        if (isset($spreadsheet)) {
-            $originalSelected = $worksheet->getSelectedCells();
-            $activeSheetIndex = $spreadsheet->getActiveSheetIndex();
-            $style = $this->getStyle();
-            $oldQuotePrefix = $style->getQuotePrefix();
-            if ($oldQuotePrefix !== $quotePrefix) {
-                $style->setQuotePrefix($quotePrefix);
-            }
-            $worksheet->setSelectedCells($originalSelected);
-            if ($activeSheetIndex >= 0) {
-                $spreadsheet->setActiveSheetIndex($activeSheetIndex);
-            }
-        }
+        $this->getWorksheet()->applyStylesFromArray($cellCoordinate, ['quotePrefix' => $quotePrefix]);
         return $this->getParent()?->get($cellCoordinate) ?? $this;
     }
     public const CALCULATE_DATE_TIME_ASIS = 0;
     public const CALCULATE_DATE_TIME_FLOAT = 1;
     public const CALCULATE_TIME_FLOAT = 2;
     private static int $calculateDateTimeType = self::CALCULATE_DATE_TIME_ASIS;
     public static function getCalculateDateTimeType(): int
     {
         return self::$calculateDateTimeType;
     }

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/Coordinate.php
@@ -0,0 +1,592 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+/**
+ * Helper class to manipulate cell coordinates.
+ *
+ * Columns indexes and rows are always based on 1, **not** on 0. This match the behavior
+ * that Excel users are used to, and also match the Excel functions `COLUMN()` and `ROW()`.
+ */
+abstract class Coordinate
+{
+    public const A1_COORDINATE_REGEX = '/^(?<col>\$?[A-Z]{1,3})(?<row>\$?\d{1,7})$/i';
+    public const FULL_REFERENCE_REGEX = '/^(?:(?<worksheet>[^!]*)!)?(?<localReference>(?<firstCoordinate>[$]?[A-Z]{1,3}[$]?\d{1,7})(?:\:(?<secondCoordinate>[$]?[A-Z]{1,3}[$]?\d{1,7}))?)$/i';
+    /**
+     * Default range variable constant.
+     *
+     * @var string
+     */
+    const DEFAULT_RANGE = 'A1:A1';
+    /**
+     * Convert string coordinate to [0 => int column index, 1 => int row index].
+     *
+     * @param string $cellAddress eg: 'A1'
+     *
+     * @return array{0: string, 1: string} Array containing column and row (indexes 0 and 1)
+     */
+    public static function coordinateFromString(string $cellAddress): array
+    {
+        if (preg_match(self::A1_COORDINATE_REGEX, $cellAddress, $matches)) {
+            return [$matches['col'], $matches['row']];
+        } elseif (self::coordinateIsRange($cellAddress)) {
+            throw new Exception('Cell coordinate string can not be a range of cells');
+        } elseif ($cellAddress == '') {
+            throw new Exception('Cell coordinate can not be zero-length string');
+        }
+        throw new Exception('Invalid cell coordinate ' . $cellAddress);
+    }
+    /**
+     * Convert string coordinate to [0 => int column index, 1 => int row index, 2 => string column string].
+     *
+     * @param string $coordinates eg: 'A1', '$B$12'
+     *
+     * @return array{0: int, 1: int, 2: string} Array containing column and row index, and column string
+     */
+    public static function indexesFromString(string $coordinates): array
+    {
+        [$column, $row] = self::coordinateFromString($coordinates);
+        $column = ltrim($column, '$');
+        return [
+            self::columnIndexFromString($column),
+            (int) ltrim($row, '$'),
+            $column,
+        ];
+    }
+    /**
+     * Checks if a Cell Address represents a range of cells.
+     *
+     * @param string $cellAddress eg: 'A1' or 'A1:A2' or 'A1:A2,C1:C2'
+     *
+     * @return bool Whether the coordinate represents a range of cells
+     */
+    public static function coordinateIsRange(string $cellAddress): bool
+    {
+        return str_contains($cellAddress, ':') || str_contains($cellAddress, ',');
+    }
+    /**
+     * Make string row, column or cell coordinate absolute.
+     *
+     * @param int|string $cellAddress e.g. 'A' or '1' or 'A1'
+     *                    Note that this value can be a row or column reference as well as a cell reference
+     *
+     * @return string Absolute coordinate        e.g. '$A' or '$1' or '$A$1'
+     */
+    public static function absoluteReference(int|string $cellAddress): string
+    {
+        $cellAddress = (string) $cellAddress;
+        if (self::coordinateIsRange($cellAddress)) {
+            throw new Exception('Cell coordinate string can not be a range of cells');
+        }
+        [$worksheet, $cellAddress] = Worksheet::extractSheetTitle($cellAddress, true);
+        if ($worksheet > '') {
+            $worksheet .= '!';
+        }
+        $cellAddress = "$cellAddress";
+        if (ctype_digit($cellAddress)) {
+            return $worksheet . '$' . $cellAddress;
+        } elseif (ctype_alpha($cellAddress)) {
+            return $worksheet . '$' . strtoupper($cellAddress);
+        }
+        return $worksheet . self::absoluteCoordinate($cellAddress);
+    }
+    /**
+     * Make string coordinate absolute.
+     *
+     * @param string $cellAddress e.g. 'A1'
+     *
+     * @return string Absolute coordinate        e.g. '$A$1'
+     */
+    public static function absoluteCoordinate(string $cellAddress): string
+    {
+        if (self::coordinateIsRange($cellAddress)) {
+            throw new Exception('Cell coordinate string can not be a range of cells');
+        }
+        [$worksheet, $cellAddress] = Worksheet::extractSheetTitle($cellAddress, true);
+        if ($worksheet > '') {
+            $worksheet .= '!';
+        }
+        [$column, $row] = self::coordinateFromString($cellAddress ?? 'A1');
+        $column = ltrim($column, '$');
+        $row = ltrim($row, '$');
+        return $worksheet . '$' . $column . '$' . $row;
+    }
+    /**
+     * Split range into coordinate strings.
+     *
+     * @param string $range e.g. 'B4:D9' or 'B4:D9,H2:O11' or 'B4'
+     *
+     * @return array Array containing one or more arrays containing one or two coordinate strings
+     *                                e.g. ['B4','D9'] or [['B4','D9'], ['H2','O11']]
+     *                                        or ['B4']
+     */
+    public static function splitRange(string $range): array
+    {
+        if (empty($range)) {
+            $range = self::DEFAULT_RANGE;
+        }
+        $exploded = explode(',', $range);
+        $outArray = [];
+        foreach ($exploded as $value) {
+            $outArray[] = explode(':', $value);
+        }
+        return $outArray;
+    }
+    /**
+     * Build range from coordinate strings.
+     *
+     * @param array $range Array containing one or more arrays containing one or two coordinate strings
+     *
+     * @return string String representation of $pRange
+     */
+    public static function buildRange(array $range): string
+    {
+        if (empty($range) || !is_array($range[0])) {
+            throw new Exception('Range does not contain any information');
+        }
+        $counter = count($range);
+        for ($i = 0; $i < $counter; ++$i) {
+            $range[$i] = implode(':', $range[$i]);
+        }
+        return implode(',', $range);
+    }
+    /**
+     * Calculate range boundaries.
+     *
+     * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
+     *
+     * @return array Range coordinates [Start Cell, End Cell]
+     *                    where Start Cell and End Cell are arrays (Column Number, Row Number)
+     */
+    public static function rangeBoundaries(string $range): array
+    {
+        if (empty($range)) {
+            $range = self::DEFAULT_RANGE;
+        }
+        $range = strtoupper($range);
+        if (!str_contains($range, ':')) {
+            $rangeA = $rangeB = $range;
+        } else {
+            [$rangeA, $rangeB] = explode(':', $range);
+        }
+        if (is_numeric($rangeA) && is_numeric($rangeB)) {
+            $rangeA = 'A' . $rangeA;
+            $rangeB = AddressRange::MAX_COLUMN . $rangeB;
+        }
+        if (ctype_alpha($rangeA) && ctype_alpha($rangeB)) {
+            $rangeA = $rangeA . '1';
+            $rangeB = $rangeB . AddressRange::MAX_ROW;
+        }
+        $rangeStart = self::coordinateFromString($rangeA);
+        $rangeEnd = self::coordinateFromString($rangeB);
+        $rangeStart[0] = self::columnIndexFromString($rangeStart[0]);
+        $rangeEnd[0] = self::columnIndexFromString($rangeEnd[0]);
+        return [$rangeStart, $rangeEnd];
+    }
+    /**
+     * Calculate range dimension.
+     *
+     * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
+     *
+     * @return array Range dimension (width, height)
+     */
+    public static function rangeDimension(string $range): array
+    {
+        [$rangeStart, $rangeEnd] = self::rangeBoundaries($range);
+        return [($rangeEnd[0] - $rangeStart[0] + 1), ($rangeEnd[1] - $rangeStart[1] + 1)];
+    }
+    /**
+     * Calculate range boundaries.
+     *
+     * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
+     *
+     * @return array Range coordinates [Start Cell, End Cell]
+     *                    where Start Cell and End Cell are arrays [Column ID, Row Number]
+     */
+    public static function getRangeBoundaries(string $range): array
+    {
+        [$rangeA, $rangeB] = self::rangeBoundaries($range);
+        return [
+            [self::stringFromColumnIndex($rangeA[0]), $rangeA[1]],
+            [self::stringFromColumnIndex($rangeB[0]), $rangeB[1]],
+        ];
+    }
+    /**
+     * Check if cell or range reference is valid and return an array with type of reference (cell or range), worksheet (if it was given)
+     * and the coordinate or the first coordinate and second coordinate if it is a range.
+     *
+     * @param string $reference Coordinate or Range (e.g. A1:A1, B2, B:C, 2:3)
+     *
+     * @return array reference data
+     */
+    private static function validateReferenceAndGetData($reference): array
+    {
+        $data = [];
+        preg_match(self::FULL_REFERENCE_REGEX, $reference, $matches);
+        if (count($matches) === 0) {
+            return ['type' => 'invalid'];
+        }
+        if (isset($matches['secondCoordinate'])) {
+            $data['type'] = 'range';
+            $data['firstCoordinate'] = str_replace('$', '', $matches['firstCoordinate']);
+            $data['secondCoordinate'] = str_replace('$', '', $matches['secondCoordinate']);
+        } else {
+            $data['type'] = 'coordinate';
+            $data['coordinate'] = str_replace('$', '', $matches['firstCoordinate']);
+        }
+        $worksheet = $matches['worksheet'];
+        if ($worksheet !== '') {
+            if (substr($worksheet, 0, 1) === "'" && substr($worksheet, -1, 1) === "'") {
+                $worksheet = substr($worksheet, 1, -1);
+            }
+            $data['worksheet'] = strtolower($worksheet);
+        }
+        $data['localReference'] = str_replace('$', '', $matches['localReference']);
+        return $data;
+    }
+    /**
+     * Check if coordinate is inside a range.
+     *
+     * @param string $range Cell range, Single Cell, Row/Column Range (e.g. A1:A1, B2, B:C, 2:3)
+     * @param string $coordinate Cell coordinate (e.g. A1)
+     *
+     * @return bool true if coordinate is inside range
+     */
+    public static function coordinateIsInsideRange(string $range, string $coordinate): bool
+    {
+        $rangeData = self::validateReferenceAndGetData($range);
+        if ($rangeData['type'] === 'invalid') {
+            throw new Exception('First argument needs to be a range');
+        }
+        $coordinateData = self::validateReferenceAndGetData($coordinate);
+        if ($coordinateData['type'] === 'invalid') {
+            throw new Exception('Second argument needs to be a single coordinate');
+        }
+        if (isset($coordinateData['worksheet']) && !isset($rangeData['worksheet'])) {
+            return false;
+        }
+        if (!isset($coordinateData['worksheet']) && isset($rangeData['worksheet'])) {
+            return false;
+        }
+        if (isset($coordinateData['worksheet'], $rangeData['worksheet'])) {
+            if ($coordinateData['worksheet'] !== $rangeData['worksheet']) {
+                return false;
+            }
+        }
+        $boundaries = self::rangeBoundaries($rangeData['localReference']);
+        $coordinates = self::indexesFromString($coordinateData['localReference']);
+        $columnIsInside = $boundaries[0][0] <= $coordinates[0] && $coordinates[0] <= $boundaries[1][0];
+        if (!$columnIsInside) {
+            return false;
+        }
+        $rowIsInside = $boundaries[0][1] <= $coordinates[1] && $coordinates[1] <= $boundaries[1][1];
+        if (!$rowIsInside) {
+            return false;
+        }
+        return true;
+    }
+    /**
+     * Column index from string.
+     *
+     * @param ?string $columnAddress eg 'A'
+     *
+     * @return int Column index (A = 1)
+     */
+    public static function columnIndexFromString(?string $columnAddress): int
+    {
+        static $indexCache = [];
+        $columnAddress = $columnAddress ?? '';
+        if (isset($indexCache[$columnAddress])) {
+            return $indexCache[$columnAddress];
+        }
+        static $columnLookup = [
+            'A' => 1, 'B' => 2, 'C' => 3, 'D' => 4, 'E' => 5, 'F' => 6, 'G' => 7, 'H' => 8, 'I' => 9, 'J' => 10,
+            'K' => 11, 'L' => 12, 'M' => 13, 'N' => 14, 'O' => 15, 'P' => 16, 'Q' => 17, 'R' => 18, 'S' => 19,
+            'T' => 20, 'U' => 21, 'V' => 22, 'W' => 23, 'X' => 24, 'Y' => 25, 'Z' => 26,
+            'a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5, 'f' => 6, 'g' => 7, 'h' => 8, 'i' => 9, 'j' => 10,
+            'k' => 11, 'l' => 12, 'm' => 13, 'n' => 14, 'o' => 15, 'p' => 16, 'q' => 17, 'r' => 18, 's' => 19,
+            't' => 20, 'u' => 21, 'v' => 22, 'w' => 23, 'x' => 24, 'y' => 25, 'z' => 26,
+        ];
+        if (isset($columnAddress[0])) {
+            if (!isset($columnAddress[1])) {
+                $indexCache[$columnAddress] = $columnLookup[$columnAddress];
+                return $indexCache[$columnAddress];
+            } elseif (!isset($columnAddress[2])) {
+                $indexCache[$columnAddress] = $columnLookup[$columnAddress[0]] * 26
+                    + $columnLookup[$columnAddress[1]];
+                return $indexCache[$columnAddress];
+            } elseif (!isset($columnAddress[3])) {
+                $indexCache[$columnAddress] = $columnLookup[$columnAddress[0]] * 676
+                    + $columnLookup[$columnAddress[1]] * 26
+                    + $columnLookup[$columnAddress[2]];
+                return $indexCache[$columnAddress];
+            }
+        }
+        throw new Exception(
+            'Column string index can not be ' . ((isset($columnAddress[0])) ? 'longer than 3 characters' : 'empty')
+        );
+    }
+    /**
+     * String from column index.
+     *
+     * @param int|numeric-string $columnIndex Column index (A = 1)
+     */
+    public static function stringFromColumnIndex(int|string $columnIndex): string
+    {
+        static $indexCache = [];
+        static $lookupCache = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ';
+        if (!isset($indexCache[$columnIndex])) {
+            $indexValue = $columnIndex;
+            $base26 = '';
+            do {
+                $characterValue = ($indexValue % 26) ?: 26;
+                $indexValue = ($indexValue - $characterValue) / 26;
+                $base26 = $lookupCache[$characterValue] . $base26;
+            } while ($indexValue > 0);
+            $indexCache[$columnIndex] = $base26;
+        }
+        return $indexCache[$columnIndex];
+    }
+    /**
+     * Extract all cell references in range, which may be comprised of multiple cell ranges.
+     *
+     * @param string $cellRange Range: e.g. 'A1' or 'A1:C10' or 'A1:E10,A20:E25' or 'A1:E5 C3:G7' or 'A1:C1,A3:C3 B1:C3'
+     *
+     * @return array Array containing single cell references
+     */
+    public static function extractAllCellReferencesInRange(string $cellRange): array
+    {
+        if (substr_count($cellRange, '!') > 1) {
+            throw new Exception('3-D Range References are not supported');
+        }
+        [$worksheet, $cellRange] = Worksheet::extractSheetTitle($cellRange, true);
+        $quoted = '';
+        if ($worksheet) {
+            $quoted = Worksheet::nameRequiresQuotes($worksheet) ? "'" : '';
+            if (str_starts_with($worksheet, "'") && str_ends_with($worksheet, "'")) {
+                $worksheet = substr($worksheet, 1, -1);
+            }
+            $worksheet = str_replace("'", "''", $worksheet);
+        }
+        [$ranges, $operators] = self::getCellBlocksFromRangeString($cellRange ?? 'A1');
+        $cells = [];
+        foreach ($ranges as $range) {
+            $cells[] = self::getReferencesForCellBlock($range);
+        }
+        $cells = self::processRangeSetOperators($operators, $cells);
+        if (empty($cells)) {
+            return [];
+        }
+        $cellList = array_merge(...$cells);
+        return array_map(
+            fn ($cellAddress) => ($worksheet !== '') ? "{$quoted}{$worksheet}{$quoted}!{$cellAddress}" : $cellAddress,
+            self::sortCellReferenceArray($cellList)
+        );
+    }
+    private static function processRangeSetOperators(array $operators, array $cells): array
+    {
+        $operatorCount = count($operators);
+        for ($offset = 0; $offset < $operatorCount; ++$offset) {
+            $operator = $operators[$offset];
+            if ($operator !== ' ') {
+                continue;
+            }
+            $cells[$offset] = array_intersect($cells[$offset], $cells[$offset + 1]);
+            unset($operators[$offset], $cells[$offset + 1]);
+            $operators = array_values($operators);
+            $cells = array_values($cells);
+            --$offset;
+            --$operatorCount;
+        }
+        return $cells;
+    }
+    private static function sortCellReferenceArray(array $cellList): array
+    {
+        $sortKeys = [];
+        foreach ($cellList as $coordinate) {
+            $column = '';
+            $row = 0;
+            sscanf($coordinate, '%[A-Z]%d', $column, $row);
+            $key = (--$row * 16384) + self::columnIndexFromString((string) $column);
+            $sortKeys[$key] = $coordinate;
+        }
+        ksort($sortKeys);
+        return array_values($sortKeys);
+    }
+    /**
+     * Get all cell references applying union and intersection.
+     *
+     * @param string $cellBlock A cell range e.g. A1:B5,D1:E5 B2:C4
+     *
+     * @return string A string without intersection operator.
+     *   If there was no intersection to begin with, return original argument.
+     *   Otherwise, return cells and/or cell ranges in that range separated by comma.
+     */
+    public static function resolveUnionAndIntersection(string $cellBlock, string $implodeCharacter = ','): string
+    {
+        $cellBlock = preg_replace('/  +/', ' ', trim($cellBlock)) ?? $cellBlock;
+        $cellBlock = preg_replace('/ ,/', ',', $cellBlock) ?? $cellBlock;
+        $cellBlock = preg_replace('/, /', ',', $cellBlock) ?? $cellBlock;
+        $array1 = [];
+        $blocks = explode(',', $cellBlock);
+        foreach ($blocks as $block) {
+            $block0 = explode(' ', $block);
+            if (count($block0) === 1) {
+                $array1 = array_merge($array1, $block0);
+            } else {
+                $blockIdx = -1;
+                $array2 = [];
+                foreach ($block0 as $block00) {
+                    ++$blockIdx;
+                    if ($blockIdx === 0) {
+                        $array2 = self::getReferencesForCellBlock($block00);
+                    } else {
+                        $array2 = array_intersect($array2, self::getReferencesForCellBlock($block00));
+                    }
+                }
+                $array1 = array_merge($array1, $array2);
+            }
+        }
+        return implode($implodeCharacter, $array1);
+    }
+    /**
+     * Get all cell references for an individual cell block.
+     *
+     * @param string $cellBlock A cell range e.g. A4:B5
+     *
+     * @return array All individual cells in that range
+     */
+    private static function getReferencesForCellBlock(string $cellBlock): array
+    {
+        $returnValue = [];
+        if (!self::coordinateIsRange($cellBlock)) {
+            return (array) $cellBlock;
+        }
+        $ranges = self::splitRange($cellBlock);
+        foreach ($ranges as $range) {
+            if (!isset($range[1])) {
+                $returnValue[] = $range[0];
+                continue;
+            }
+            [$rangeStart, $rangeEnd] = $range;
+            [$startColumn, $startRow] = self::coordinateFromString($rangeStart);
+            [$endColumn, $endRow] = self::coordinateFromString($rangeEnd);
+            $startColumnIndex = self::columnIndexFromString($startColumn);
+            $endColumnIndex = self::columnIndexFromString($endColumn);
+            ++$endColumnIndex;
+            $currentColumnIndex = $startColumnIndex;
+            $currentRow = $startRow;
+            self::validateRange($cellBlock, $startColumnIndex, $endColumnIndex, (int) $currentRow, (int) $endRow);
+            while ($currentColumnIndex < $endColumnIndex) {
+                while ($currentRow <= $endRow) {
+                    $returnValue[] = self::stringFromColumnIndex($currentColumnIndex) . $currentRow;
+                    ++$currentRow;
+                }
+                ++$currentColumnIndex;
+                $currentRow = $startRow;
+            }
+        }
+        return $returnValue;
+    }
+    /**
+     * Convert an associative array of single cell coordinates to values to an associative array
+     * of cell ranges to values.  Only adjacent cell coordinates with the same
+     * value will be merged.  If the value is an object, it must implement the method getHashCode().
+     *
+     * For example, this function converts:
+     *
+     *    [ 'A1' => 'x', 'A2' => 'x', 'A3' => 'x', 'A4' => 'y' ]
+     *
+     * to:
+     *
+     *    [ 'A1:A3' => 'x', 'A4' => 'y' ]
+     *
+     * @param array $coordinateCollection associative array mapping coordinates to values
+     *
+     * @return array associative array mapping coordinate ranges to valuea
+     */
+    public static function mergeRangesInCollection(array $coordinateCollection): array
+    {
+        $hashedValues = [];
+        $mergedCoordCollection = [];
+        foreach ($coordinateCollection as $coord => $value) {
+            if (self::coordinateIsRange($coord)) {
+                $mergedCoordCollection[$coord] = $value;
+                continue;
+            }
+            [$column, $row] = self::coordinateFromString($coord);
+            $row = (int) (ltrim($row, '$'));
+            $hashCode = $column . '-' . ((is_object($value) && method_exists($value, 'getHashCode')) ? $value->getHashCode() : $value);
+            if (!isset($hashedValues[$hashCode])) {
+                $hashedValues[$hashCode] = (object) [
+                    'value' => $value,
+                    'col' => $column,
+                    'rows' => [$row],
+                ];
+            } else {
+                $hashedValues[$hashCode]->rows[] = $row;
+            }
+        }
+        ksort($hashedValues);
+        foreach ($hashedValues as $hashedValue) {
+            sort($hashedValue->rows);
+            $rowStart = null;
+            $rowEnd = null;
+            $ranges = [];
+            foreach ($hashedValue->rows as $row) {
+                if ($rowStart === null) {
+                    $rowStart = $row;
+                    $rowEnd = $row;
+                } elseif ($rowEnd === $row - 1) {
+                    $rowEnd = $row;
+                } else {
+                    if ($rowStart == $rowEnd) {
+                        $ranges[] = $hashedValue->col . $rowStart;
+                    } else {
+                        $ranges[] = $hashedValue->col . $rowStart . ':' . $hashedValue->col . $rowEnd;
+                    }
+                    $rowStart = $row;
+                    $rowEnd = $row;
+                }
+            }
+            if ($rowStart !== null) {
+                if ($rowStart == $rowEnd) {
+                    $ranges[] = $hashedValue->col . $rowStart;
+                } else {
+                    $ranges[] = $hashedValue->col . $rowStart . ':' . $hashedValue->col . $rowEnd;
+                }
+            }
+            foreach ($ranges as $range) {
+                $mergedCoordCollection[$range] = $hashedValue->value;
+            }
+        }
+        return $mergedCoordCollection;
+    }
+    /**
+     * Get the individual cell blocks from a range string, removing any $ characters.
+     *      then splitting by operators and returning an array with ranges and operators.
+     *
+     * @return array[]
+     */
+    private static function getCellBlocksFromRangeString(string $rangeString): array
+    {
+        $rangeString = str_replace('$', '', strtoupper($rangeString));
+        $tokens = preg_split('/([ ,])/', $rangeString, -1, PREG_SPLIT_DELIM_CAPTURE) ?: [];
+        $split = array_chunk($tokens, 2);
+        $ranges = array_column($split, 0);
+        $operators = array_column($split, 1);
+        return [$ranges, $operators];
+    }
+    /**
+     * Check that the given range is valid, i.e. that the start column and row are not greater than the end column and
+     * row.
+     *
+     * @param string $cellBlock The original range, for displaying a meaningful error message
+     */
+    private static function validateRange(string $cellBlock, int $startColumnIndex, int $endColumnIndex, int $currentRow, int $endRow): void
+    {
+        if ($startColumnIndex >= $endColumnIndex || $currentRow > $endRow) {
+            throw new Exception('Invalid range: "' . $cellBlock . '"');
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/DataType.php
@@ -0,0 +1,73 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use Stringable;
+class DataType
+{
+    const TYPE_STRING2 = 'str';
+    const TYPE_STRING = 's';
+    const TYPE_FORMULA = 'f';
+    const TYPE_NUMERIC = 'n';
+    const TYPE_BOOL = 'b';
+    const TYPE_NULL = 'null';
+    const TYPE_INLINE = 'inlineStr';
+    const TYPE_ERROR = 'e';
+    const TYPE_ISO_DATE = 'd';
+    /**
+     * List of error codes.
+     *
+     * @var array<string, int>
+     */
+    private static array $errorCodes = [
+        '#NULL!' => 0,
+        '#DIV/0!' => 1,
+        '#VALUE!' => 2,
+        '#REF!' => 3,
+        '#NAME?' => 4,
+        '#NUM!' => 5,
+        '#N/A' => 6,
+        '#CALC!' => 7,
+    ];
+    public const MAX_STRING_LENGTH = 32767;
+    /**
+     * Get list of error codes.
+     *
+     * @return array<string, int>
+     */
+    public static function getErrorCodes(): array
+    {
+        return self::$errorCodes;
+    }
+    /**
+     * Check a string that it satisfies Excel requirements.
+     *
+     * @param null|RichText|string $textValue Value to sanitize to an Excel string
+     *
+     * @return RichText|string Sanitized value
+     */
+    public static function checkString(null|RichText|string $textValue): RichText|string
+    {
+        if ($textValue instanceof RichText) {
+            return $textValue;
+        }
+        $textValue = StringHelper::substring((string) $textValue, 0, self::MAX_STRING_LENGTH);
+        $textValue = str_replace(["\r\n", "\r"], "\n", $textValue);
+        return $textValue;
+    }
+    /**
+     * Check a value that it is a valid error code.
+     *
+     * @param mixed $value Value to sanitize to an Excel error code
+     *
+     * @return string Sanitized value
+     */
+    public static function checkErrorCode(mixed $value): string
+    {
+        $value = (is_scalar($value) || $value instanceof Stringable) ? ((string) $value) : '#NULL!';
+        if (!isset(self::$errorCodes[$value])) {
+            $value = '#NULL!';
+        }
+        return $value;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/DataValidator.php
@@ -0,0 +1,101 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ExcelError;
+use PhpOffice\PhpSpreadsheet\Exception;
+/**
+ * Validate a cell value according to its validation rules.
+ */
+class DataValidator
+{
+    /**
+     * Does this cell contain valid value?
+     *
+     * @param Cell $cell Cell to check the value
+     */
+    public function isValid(Cell $cell): bool
+    {
+        if (!$cell->hasDataValidation() || $cell->getDataValidation()->getType() === DataValidation::TYPE_NONE) {
+            return true;
+        }
+        $cellValue = $cell->getValue();
+        $dataValidation = $cell->getDataValidation();
+        if (!$dataValidation->getAllowBlank() && ($cellValue === null || $cellValue === '')) {
+            return false;
+        }
+        $returnValue = false;
+        $type = $dataValidation->getType();
+        if ($type === DataValidation::TYPE_LIST) {
+            $returnValue = $this->isValueInList($cell);
+        } elseif ($type === DataValidation::TYPE_WHOLE) {
+            if (!is_numeric($cellValue) || fmod((float) $cellValue, 1) != 0) {
+                $returnValue = false;
+            } else {
+                $returnValue = $this->numericOperator($dataValidation, (int) $cellValue);
+            }
+        } elseif ($type === DataValidation::TYPE_DECIMAL || $type === DataValidation::TYPE_DATE || $type === DataValidation::TYPE_TIME) {
+            if (!is_numeric($cellValue)) {
+                $returnValue = false;
+            } else {
+                $returnValue = $this->numericOperator($dataValidation, (float) $cellValue);
+            }
+        } elseif ($type === DataValidation::TYPE_TEXTLENGTH) {
+            $returnValue = $this->numericOperator($dataValidation, mb_strlen($cell->getValueString()));
+        }
+        return $returnValue;
+    }
+    private function numericOperator(DataValidation $dataValidation, int|float $cellValue): bool
+    {
+        $operator = $dataValidation->getOperator();
+        $formula1 = $dataValidation->getFormula1();
+        $formula2 = $dataValidation->getFormula2();
+        $returnValue = false;
+        if ($operator === DataValidation::OPERATOR_BETWEEN) {
+            $returnValue = $cellValue >= $formula1 && $cellValue <= $formula2;
+        } elseif ($operator === DataValidation::OPERATOR_NOTBETWEEN) {
+            $returnValue = $cellValue < $formula1 || $cellValue > $formula2;
+        } elseif ($operator === DataValidation::OPERATOR_EQUAL) {
+            $returnValue = $cellValue == $formula1;
+        } elseif ($operator === DataValidation::OPERATOR_NOTEQUAL) {
+            $returnValue = $cellValue != $formula1;
+        } elseif ($operator === DataValidation::OPERATOR_LESSTHAN) {
+            $returnValue = $cellValue < $formula1;
+        } elseif ($operator === DataValidation::OPERATOR_LESSTHANOREQUAL) {
+            $returnValue = $cellValue <= $formula1;
+        } elseif ($operator === DataValidation::OPERATOR_GREATERTHAN) {
+            $returnValue = $cellValue > $formula1;
+        } elseif ($operator === DataValidation::OPERATOR_GREATERTHANOREQUAL) {
+            $returnValue = $cellValue >= $formula1;
+        }
+        return $returnValue;
+    }
+    /**
+     * Does this cell contain valid value, based on list?
+     *
+     * @param Cell $cell Cell to check the value
+     */
+    private function isValueInList(Cell $cell): bool
+    {
+        $cellValueString = $cell->getValueString();
+        $dataValidation = $cell->getDataValidation();
+        $formula1 = $dataValidation->getFormula1();
+        if (!empty($formula1)) {
+            if ($formula1[0] === '"') {
+                return in_array(strtolower($cellValueString), explode(',', strtolower(trim($formula1, '"'))), true);
+            } elseif (strpos($formula1, ':') > 0) {
+                $matchFormula = '=MATCH(' . $cell->getCoordinate() . ', ' . $formula1 . ', 0)';
+                $calculation = Calculation::getInstance($cell->getWorksheet()->getParent());
+                try {
+                    $result = $calculation->calculateFormula($matchFormula, $cell->getCoordinate(), $cell);
+                    while (is_array($result)) {
+                        $result = array_pop($result);
+                    }
+                    return $result !== ExcelError::NA();
+                } catch (Exception) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/DefaultValueBinder.php
@@ -0,0 +1,95 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use DateTimeInterface;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalculationException;
+use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use Stringable;
+class DefaultValueBinder implements IValueBinder
+{
+    /**
+     * Bind value to a cell.
+     *
+     * @param Cell $cell Cell to bind value to
+     * @param mixed $value Value to bind in cell
+     */
+    public function bindValue(Cell $cell, mixed $value): bool
+    {
+        if (is_string($value)) {
+            $value = StringHelper::sanitizeUTF8($value);
+        } elseif ($value === null || is_scalar($value) || $value instanceof RichText) {
+        } elseif ($value instanceof DateTimeInterface) {
+            $value = $value->format('Y-m-d H:i:s');
+        } elseif ($value instanceof Stringable) {
+            $value = (string) $value;
+        } else {
+            throw new SpreadsheetException('Unable to bind unstringable ' . gettype($value));
+        }
+        $cell->setValueExplicit($value, static::dataTypeForValue($value));
+        return true;
+    }
+    /**
+     * DataType for value.
+     */
+    public static function dataTypeForValue(mixed $value): string
+    {
+        if ($value === null) {
+            return DataType::TYPE_NULL;
+        }
+        if (is_float($value) || is_int($value)) {
+            return DataType::TYPE_NUMERIC;
+        }
+        if (is_bool($value)) {
+            return DataType::TYPE_BOOL;
+        }
+        if ($value === '') {
+            return DataType::TYPE_STRING;
+        }
+        if ($value instanceof RichText) {
+            return DataType::TYPE_INLINE;
+        }
+        if ($value instanceof Stringable) {
+            $value = (string) $value;
+        }
+        if (!is_string($value)) {
+            $gettype = is_object($value) ? get_class($value) : gettype($value);
+            throw new SpreadsheetException("unusable type $gettype");
+        }
+        if (strlen($value) > 1 && $value[0] === '=') {
+            $calculation = new Calculation();
+            $calculation->disableBranchPruning();
+            try {
+                if (empty($calculation->parseFormula($value))) {
+                    return DataType::TYPE_STRING;
+                }
+            } catch (CalculationException $e) {
+                $message = $e->getMessage();
+                if (
+                    $message === 'Formula Error: An unexpected error occurred'
+                    || str_contains($message, 'has no operands')
+                ) {
+                    return DataType::TYPE_STRING;
+                }
+            }
+            return DataType::TYPE_FORMULA;
+        }
+        if (preg_match('/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/', $value)) {
+            $tValue = ltrim($value, '+-');
+            if (strlen($tValue) > 1 && $tValue[0] === '0' && $tValue[1] !== '.') {
+                return DataType::TYPE_STRING;
+            } elseif ((!str_contains($value, '.')) && ($value > PHP_INT_MAX)) {
+                return DataType::TYPE_STRING;
+            } elseif (!is_numeric($value)) {
+                return DataType::TYPE_STRING;
+            }
+            return DataType::TYPE_NUMERIC;
+        }
+        $errorCodes = DataType::getErrorCodes();
+        if (isset($errorCodes[$value])) {
+            return DataType::TYPE_ERROR;
+        }
+        return DataType::TYPE_STRING;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Cell/StringValueBinder.php
@@ -0,0 +1,90 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Cell;
+use DateTimeInterface;
+use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use Stringable;
+class StringValueBinder extends DefaultValueBinder implements IValueBinder
+{
+    protected bool $convertNull = true;
+    protected bool $convertBoolean = true;
+    protected bool $convertNumeric = true;
+    protected bool $convertFormula = true;
+    public function setNullConversion(bool $suppressConversion = false): self
+    {
+        $this->convertNull = $suppressConversion;
+        return $this;
+    }
+    public function setBooleanConversion(bool $suppressConversion = false): self
+    {
+        $this->convertBoolean = $suppressConversion;
+        return $this;
+    }
+    public function getBooleanConversion(): bool
+    {
+        return $this->convertBoolean;
+    }
+    public function setNumericConversion(bool $suppressConversion = false): self
+    {
+        $this->convertNumeric = $suppressConversion;
+        return $this;
+    }
+    public function setFormulaConversion(bool $suppressConversion = false): self
+    {
+        $this->convertFormula = $suppressConversion;
+        return $this;
+    }
+    public function setConversionForAllValueTypes(bool $suppressConversion = false): self
+    {
+        $this->convertNull = $suppressConversion;
+        $this->convertBoolean = $suppressConversion;
+        $this->convertNumeric = $suppressConversion;
+        $this->convertFormula = $suppressConversion;
+        return $this;
+    }
+    /**
+     * Bind value to a cell.
+     *
+     * @param Cell $cell Cell to bind value to
+     * @param mixed $value Value to bind in cell
+     */
+    public function bindValue(Cell $cell, mixed $value): bool
+    {
+        if (is_object($value)) {
+            return $this->bindObjectValue($cell, $value);
+        }
+        if ($value !== null && !is_scalar($value)) {
+            throw new SpreadsheetException('Unable to bind unstringable ' . gettype($value));
+        }
+        if (is_string($value)) {
+            $value = StringHelper::sanitizeUTF8($value);
+        }
+        if ($value === null && $this->convertNull === false) {
+            $cell->setValueExplicit($value, DataType::TYPE_NULL);
+        } elseif (is_bool($value) && $this->convertBoolean === false) {
+            $cell->setValueExplicit($value, DataType::TYPE_BOOL);
+        } elseif ((is_int($value) || is_float($value)) && $this->convertNumeric === false) {
+            $cell->setValueExplicit($value, DataType::TYPE_NUMERIC);
+        } elseif (is_string($value) && strlen($value) > 1 && $value[0] === '=' && $this->convertFormula === false && parent::dataTypeForValue($value) === DataType::TYPE_FORMULA) {
+            $cell->setValueExplicit($value, DataType::TYPE_FORMULA);
+        } else {
+            $cell->setValueExplicit((string) $value, DataType::TYPE_STRING);
+        }
+        return true;
+    }
+    protected function bindObjectValue(Cell $cell, object $value): bool
+    {
+        if ($value instanceof DateTimeInterface) {
+            $value = $value->format('Y-m-d H:i:s');
+            $cell->setValueExplicit($value, DataType::TYPE_STRING);
+        } elseif ($value instanceof RichText) {
+            $cell->setValueExplicit($value, DataType::TYPE_INLINE);
+        } elseif ($value instanceof Stringable) {
+            $cell->setValueExplicit((string) $value, DataType::TYPE_STRING);
+        } else {
+            throw new SpreadsheetException('Unable to bind unstringable object of type ' . get_class($value));
+        }
+        return true;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Chart/Axis.php
@@ -0,0 +1,295 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Chart;
+/**
+ * Created by PhpStorm.
+ * User: Wiktor Trzonkowski
+ * Date: 6/17/14
+ * Time: 12:11 PM.
+ */
+class Axis extends Properties
+{
+    const AXIS_TYPE_CATEGORY = 'catAx';
+    const AXIS_TYPE_DATE = 'dateAx';
+    const AXIS_TYPE_VALUE = 'valAx';
+    const TIME_UNIT_DAYS = 'days';
+    const TIME_UNIT_MONTHS = 'months';
+    const TIME_UNIT_YEARS = 'years';
+    public function __construct()
+    {
+        parent::__construct();
+        $this->fillColor = new ChartColor();
+    }
+    /**
+     * Chart Major Gridlines as.
+     */
+    private ?GridLines $majorGridlines = null;
+    /**
+     * Chart Minor Gridlines as.
+     */
+    private ?GridLines $minorGridlines = null;
+    /**
+     * Axis Number.
+     *
+     * @var array{format: string, source_linked: int, numeric: ?bool}
+     */
+    private array $axisNumber = [
+        'format' => self::FORMAT_CODE_GENERAL,
+        'source_linked' => 1,
+        'numeric' => null,
+    ];
+    private string $axisType = '';
+    private ?AxisText $axisText = null;
+    private ?Title $dispUnitsTitle = null;
+    /**
+     * Axis Options.
+     *
+     * @var array<string, null|string>
+     */
+    private array $axisOptions = [
+        'minimum' => null,
+        'maximum' => null,
+        'major_unit' => null,
+        'minor_unit' => null,
+        'orientation' => self::ORIENTATION_NORMAL,
+        'minor_tick_mark' => self::TICK_MARK_NONE,
+        'major_tick_mark' => self::TICK_MARK_NONE,
+        'axis_labels' => self::AXIS_LABELS_NEXT_TO,
+        'horizontal_crosses' => self::HORIZONTAL_CROSSES_AUTOZERO,
+        'horizontal_crosses_value' => null,
+        'textRotation' => null,
+        'hidden' => null,
+        'majorTimeUnit' => self::TIME_UNIT_YEARS,
+        'minorTimeUnit' => self::TIME_UNIT_MONTHS,
+        'baseTimeUnit' => self::TIME_UNIT_DAYS,
+        'logBase' => null,
+        'dispUnitsBuiltIn' => null,
+    ];
+    public const DISP_UNITS_HUNDREDS = 'hundreds';
+    public const DISP_UNITS_THOUSANDS = 'thousands';
+    public const DISP_UNITS_TEN_THOUSANDS = 'tenThousands';
+    public const DISP_UNITS_HUNDRED_THOUSANDS = 'hundredThousands';
+    public const DISP_UNITS_MILLIONS = 'millions';
+    public const DISP_UNITS_TEN_MILLIONS = 'tenMillions';
+    public const DISP_UNITS_HUNDRED_MILLIONS = 'hundredMillions';
+    public const DISP_UNITS_BILLIONS = 'billions';
+    public const DISP_UNITS_TRILLIONS = 'trillions';
+    public const TRILLION_INDEX = (PHP_INT_SIZE > 4) ? 1000000000000 : '1000000000000';
+    public const DISP_UNITS_BUILTIN_INT = [
+        100 => self::DISP_UNITS_HUNDREDS,
+        1000 => self::DISP_UNITS_THOUSANDS,
+        10000 => self::DISP_UNITS_TEN_THOUSANDS,
+        100000 => self::DISP_UNITS_HUNDRED_THOUSANDS,
+        1000000 => self::DISP_UNITS_MILLIONS,
+        10000000 => self::DISP_UNITS_TEN_MILLIONS,
+        100000000 => self::DISP_UNITS_HUNDRED_MILLIONS,
+        1000000000 => self::DISP_UNITS_BILLIONS,
+        self::TRILLION_INDEX => self::DISP_UNITS_TRILLIONS, // overflow for 32-bit
+    ];
+    /**
+     * Fill Properties.
+     */
+    private ChartColor $fillColor;
+    private const NUMERIC_FORMAT = [
+        Properties::FORMAT_CODE_NUMBER,
+        Properties::FORMAT_CODE_DATE,
+        Properties::FORMAT_CODE_DATE_ISO8601,
+    ];
+    private bool $noFill = false;
+    /**
+     * Get Series Data Type.
+     */
+    public function setAxisNumberProperties(string $format_code, ?bool $numeric = null, int $sourceLinked = 0): void
+    {
+        $format = $format_code;
+        $this->axisNumber['format'] = $format;
+        $this->axisNumber['source_linked'] = $sourceLinked;
+        if (is_bool($numeric)) {
+            $this->axisNumber['numeric'] = $numeric;
+        } elseif (in_array($format, self::NUMERIC_FORMAT, true)) {
+            $this->axisNumber['numeric'] = true;
+        }
+    }
+    /**
+     * Get Axis Number Format Data Type.
+     */
+    public function getAxisNumberFormat(): string
+    {
+        return $this->axisNumber['format'];
+    }
+    /**
+     * Get Axis Number Source Linked.
+     */
+    public function getAxisNumberSourceLinked(): string
+    {
+        return (string) $this->axisNumber['source_linked'];
+    }
+    public function getAxisIsNumericFormat(): bool
+    {
+        return $this->axisType === self::AXIS_TYPE_DATE || (bool) $this->axisNumber['numeric'];
+    }
+    public function setAxisOption(string $key, null|float|int|string $value): void
+    {
+        if ($value !== null && $value !== '') {
+            $this->axisOptions[$key] = (string) $value;
+        }
+    }
+    /**
+     * Set Axis Options Properties.
+     */
+    public function setAxisOptionsProperties(
+        string $axisLabels,
+        ?string $horizontalCrossesValue = null,
+        ?string $horizontalCrosses = null,
+        ?string $axisOrientation = null,
+        ?string $majorTmt = null,
+        ?string $minorTmt = null,
+        null|float|int|string $minimum = null,
+        null|float|int|string $maximum = null,
+        null|float|int|string $majorUnit = null,
+        null|float|int|string $minorUnit = null,
+        null|float|int|string $textRotation = null,
+        ?string $hidden = null,
+        ?string $baseTimeUnit = null,
+        ?string $majorTimeUnit = null,
+        ?string $minorTimeUnit = null,
+        null|float|int|string $logBase = null,
+        ?string $dispUnitsBuiltIn = null
+    ): void {
+        $this->axisOptions['axis_labels'] = $axisLabels;
+        $this->setAxisOption('horizontal_crosses_value', $horizontalCrossesValue);
+        $this->setAxisOption('horizontal_crosses', $horizontalCrosses);
+        $this->setAxisOption('orientation', $axisOrientation);
+        $this->setAxisOption('major_tick_mark', $majorTmt);
+        $this->setAxisOption('minor_tick_mark', $minorTmt);
+        $this->setAxisOption('minimum', $minimum);
+        $this->setAxisOption('maximum', $maximum);
+        $this->setAxisOption('major_unit', $majorUnit);
+        $this->setAxisOption('minor_unit', $minorUnit);
+        $this->setAxisOption('textRotation', $textRotation);
+        $this->setAxisOption('hidden', $hidden);
+        $this->setAxisOption('baseTimeUnit', $baseTimeUnit);
+        $this->setAxisOption('majorTimeUnit', $majorTimeUnit);
+        $this->setAxisOption('minorTimeUnit', $minorTimeUnit);
+        $this->setAxisOption('logBase', $logBase);
+        $this->setAxisOption('dispUnitsBuiltIn', $dispUnitsBuiltIn);
+    }
+    /**
+     * Get Axis Options Property.
+     */
+    public function getAxisOptionsProperty(string $property): ?string
+    {
+        if ($property === 'textRotation') {
+            if ($this->axisText !== null) {
+                if ($this->axisText->getRotation() !== null) {
+                    return (string) $this->axisText->getRotation();
+                }
+            }
+        }
+        return $this->axisOptions[$property];
+    }
+    /**
+     * Set Axis Orientation Property.
+     */
+    public function setAxisOrientation(string $orientation): void
+    {
+        $this->axisOptions['orientation'] = (string) $orientation;
+    }
+    public function getAxisType(): string
+    {
+        return $this->axisType;
+    }
+    public function setAxisType(string $type): self
+    {
+        if ($type === self::AXIS_TYPE_CATEGORY || $type === self::AXIS_TYPE_VALUE || $type === self::AXIS_TYPE_DATE) {
+            $this->axisType = $type;
+        } else {
+            $this->axisType = '';
+        }
+        return $this;
+    }
+    /**
+     * Set Fill Property.
+     */
+    public function setFillParameters(?string $color, ?int $alpha = null, ?string $AlphaType = ChartColor::EXCEL_COLOR_TYPE_RGB): void
+    {
+        $this->fillColor->setColorProperties($color, $alpha, $AlphaType);
+    }
+    /**
+     * Get Fill Property.
+     */
+    public function getFillProperty(string $property): string
+    {
+        return (string) $this->fillColor->getColorProperty($property);
+    }
+    public function getFillColorObject(): ChartColor
+    {
+        return $this->fillColor;
+    }
+    private string $crossBetween = ''; // 'between' or 'midCat' might be better
+    public function setCrossBetween(string $crossBetween): self
+    {
+        $this->crossBetween = $crossBetween;
+        return $this;
+    }
+    public function getCrossBetween(): string
+    {
+        return $this->crossBetween;
+    }
+    public function getMajorGridlines(): ?GridLines
+    {
+        return $this->majorGridlines;
+    }
+    public function getMinorGridlines(): ?GridLines
+    {
+        return $this->minorGridlines;
+    }
+    public function setMajorGridlines(?GridLines $gridlines): self
+    {
+        $this->majorGridlines = $gridlines;
+        return $this;
+    }
+    public function setMinorGridlines(?GridLines $gridlines): self
+    {
+        $this->minorGridlines = $gridlines;
+        return $this;
+    }
+    public function getAxisText(): ?AxisText
+    {
+        return $this->axisText;
+    }
+    public function setAxisText(?AxisText $axisText): self
+    {
+        $this->axisText = $axisText;
+        return $this;
+    }
+    public function setNoFill(bool $noFill): self
+    {
+        $this->noFill = $noFill;
+        return $this;
+    }
+    public function getNoFill(): bool
+    {
+        return $this->noFill;
+    }
+    public function setDispUnitsTitle(?Title $dispUnitsTitle): self
+    {
+        $this->dispUnitsTitle = $dispUnitsTitle;
+        return $this;
+    }
+    public function getDispUnitsTitle(): ?Title
+    {
+        return $this->dispUnitsTitle;
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        parent::__clone();
+        $this->majorGridlines = ($this->majorGridlines === null) ? null : clone $this->majorGridlines;
+        $this->majorGridlines = ($this->minorGridlines === null) ? null : clone $this->minorGridlines;
+        $this->axisText = ($this->axisText === null) ? null : clone $this->axisText;
+        $this->dispUnitsTitle = ($this->dispUnitsTitle === null) ? null : clone $this->dispUnitsTitle;
+        $this->fillColor = clone $this->fillColor;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Chart/DataSeriesValues.php
@@ -0,0 +1,491 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Chart;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+class DataSeriesValues extends Properties
+{
+    const DATASERIES_TYPE_STRING = 'String';
+    const DATASERIES_TYPE_NUMBER = 'Number';
+    private const DATA_TYPE_VALUES = [
+        self::DATASERIES_TYPE_STRING,
+        self::DATASERIES_TYPE_NUMBER,
+    ];
+    /**
+     * Series Data Type.
+     */
+    private string $dataType;
+    /**
+     * Series Data Source.
+     */
+    private ?string $dataSource;
+    /**
+     * Format Code.
+     */
+    private ?string $formatCode;
+    /**
+     * Series Point Marker.
+     */
+    private ?string $pointMarker;
+    private ChartColor $markerFillColor;
+    private ChartColor $markerBorderColor;
+    /**
+     * Series Point Size.
+     */
+    private int $pointSize = 3;
+    /**
+     * Point Count (The number of datapoints in the dataseries).
+     */
+    private int $pointCount;
+    /**
+     * Data Values.
+     */
+    private ?array $dataValues;
+    /**
+     * Fill color (can be array with colors if dataseries have custom colors).
+     *
+     * @var null|ChartColor|ChartColor[]
+     */
+    private $fillColor;
+    private bool $scatterLines = true;
+    private bool $bubble3D = false;
+    private ?Layout $labelLayout = null;
+    /** @var TrendLine[] */
+    private array $trendLines = [];
+    /**
+     * Create a new DataSeriesValues object.
+     *
+     * @param null|ChartColor|ChartColor[]|string|string[] $fillColor
+     */
+    public function __construct(
+        string $dataType = self::DATASERIES_TYPE_NUMBER,
+        ?string $dataSource = null,
+        ?string $formatCode = null,
+        int $pointCount = 0,
+        ?array $dataValues = [],
+        ?string $marker = null,
+        null|ChartColor|array|string $fillColor = null,
+        int|string $pointSize = 3
+    ) {
+        parent::__construct();
+        $this->markerFillColor = new ChartColor();
+        $this->markerBorderColor = new ChartColor();
+        $this->setDataType($dataType);
+        $this->dataSource = $dataSource;
+        $this->formatCode = $formatCode;
+        $this->pointCount = $pointCount;
+        $this->dataValues = $dataValues;
+        $this->pointMarker = $marker;
+        if ($fillColor !== null) {
+            $this->setFillColor($fillColor);
+        }
+        if (is_numeric($pointSize)) {
+            $this->pointSize = (int) $pointSize;
+        }
+    }
+    /**
+     * Get Series Data Type.
+     */
+    public function getDataType(): string
+    {
+        return $this->dataType;
+    }
+    /**
+     * Set Series Data Type.
+     *
+     * @param string $dataType Datatype of this data series
+     *                                Typical values are:
+     *                                    DataSeriesValues::DATASERIES_TYPE_STRING
+     *                                        Normally used for axis point values
+     *                                    DataSeriesValues::DATASERIES_TYPE_NUMBER
+     *                                        Normally used for chart data values
+     *
+     * @return $this
+     */
+    public function setDataType(string $dataType): static
+    {
+        if (!in_array($dataType, self::DATA_TYPE_VALUES)) {
+            throw new Exception('Invalid datatype for chart data series values');
+        }
+        $this->dataType = $dataType;
+        return $this;
+    }
+    /**
+     * Get Series Data Source (formula).
+     */
+    public function getDataSource(): ?string
+    {
+        return $this->dataSource;
+    }
+    /**
+     * Set Series Data Source (formula).
+     *
+     * @return $this
+     */
+    public function setDataSource(?string $dataSource): static
+    {
+        $this->dataSource = $dataSource;
+        return $this;
+    }
+    /**
+     * Get Point Marker.
+     */
+    public function getPointMarker(): ?string
+    {
+        return $this->pointMarker;
+    }
+    /**
+     * Set Point Marker.
+     *
+     * @return $this
+     */
+    public function setPointMarker(string $marker): static
+    {
+        $this->pointMarker = $marker;
+        return $this;
+    }
+    public function getMarkerFillColor(): ChartColor
+    {
+        return $this->markerFillColor;
+    }
+    public function getMarkerBorderColor(): ChartColor
+    {
+        return $this->markerBorderColor;
+    }
+    /**
+     * Get Point Size.
+     */
+    public function getPointSize(): int
+    {
+        return $this->pointSize;
+    }
+    /**
+     * Set Point Size.
+     *
+     * @return $this
+     */
+    public function setPointSize(int $size = 3): static
+    {
+        $this->pointSize = $size;
+        return $this;
+    }
+    /**
+     * Get Series Format Code.
+     */
+    public function getFormatCode(): ?string
+    {
+        return $this->formatCode;
+    }
+    /**
+     * Set Series Format Code.
+     *
+     * @return $this
+     */
+    public function setFormatCode(string $formatCode): static
+    {
+        $this->formatCode = $formatCode;
+        return $this;
+    }
+    /**
+     * Get Series Point Count.
+     */
+    public function getPointCount(): int
+    {
+        return $this->pointCount;
+    }
+    /**
+     * Get fill color object.
+     *
+     * @return null|ChartColor|ChartColor[]
+     */
+    public function getFillColorObject()
+    {
+        return $this->fillColor;
+    }
+    private function stringToChartColor(string $fillString): ChartColor
+    {
+        $value = $type = '';
+        if (str_starts_with($fillString, '*')) {
+            $type = 'schemeClr';
+            $value = substr($fillString, 1);
+        } elseif (str_starts_with($fillString, '/')) {
+            $type = 'prstClr';
+            $value = substr($fillString, 1);
+        } elseif ($fillString !== '') {
+            $type = 'srgbClr';
+            $value = $fillString;
+            $this->validateColor($value);
+        }
+        return new ChartColor($value, null, $type);
+    }
+    private function chartColorToString(ChartColor $chartColor): string
+    {
+        $type = (string) $chartColor->getColorProperty('type');
+        $value = (string) $chartColor->getColorProperty('value');
+        if ($type === '' || $value === '') {
+            return '';
+        }
+        if ($type === 'schemeClr') {
+            return "*$value";
+        }
+        if ($type === 'prstClr') {
+            return "/$value";
+        }
+        return $value;
+    }
+    /**
+     * Get fill color.
+     *
+     * @return string|string[] HEX color or array with HEX colors
+     */
+    public function getFillColor(): string|array
+    {
+        if ($this->fillColor === null) {
+            return '';
+        }
+        if (is_array($this->fillColor)) {
+            $array = [];
+            foreach ($this->fillColor as $chartColor) {
+                $array[] = $this->chartColorToString($chartColor);
+            }
+            return $array;
+        }
+        return $this->chartColorToString($this->fillColor);
+    }
+    /**
+     * Set fill color for series.
+     *
+     * @param ChartColor|ChartColor[]|string|string[] $color HEX color or array with HEX colors
+     *
+     * @return   $this
+     */
+    public function setFillColor($color): static
+    {
+        if (is_array($color)) {
+            $this->fillColor = [];
+            foreach ($color as $fillString) {
+                if ($fillString instanceof ChartColor) {
+                    $this->fillColor[] = $fillString;
+                } else {
+                    $this->fillColor[] = $this->stringToChartColor($fillString);
+                }
+            }
+        } elseif ($color instanceof ChartColor) {
+            $this->fillColor = $color;
+        } else {
+            $this->fillColor = $this->stringToChartColor($color);
+        }
+        return $this;
+    }
+    /**
+     * Method for validating hex color.
+     *
+     * @param string $color value for color
+     *
+     * @return bool true if validation was successful
+     */
+    private function validateColor(string $color): bool
+    {
+        if (!preg_match('/^[a-f0-9]{6}$/i', $color)) {
+            throw new Exception(sprintf('Invalid hex color for chart series (color: "%s")', $color));
+        }
+        return true;
+    }
+    /**
+     * Get line width for series.
+     */
+    public function getLineWidth(): null|float|int
+    {
+        return $this->lineStyleProperties['width'];
+    }
+    /**
+     * Set line width for the series.
+     *
+     * @return $this
+     */
+    public function setLineWidth(null|float|int $width): static
+    {
+        $this->lineStyleProperties['width'] = $width;
+        return $this;
+    }
+    /**
+     * Identify if the Data Series is a multi-level or a simple series.
+     */
+    public function isMultiLevelSeries(): ?bool
+    {
+        if (!empty($this->dataValues)) {
+            return is_array(array_values($this->dataValues)[0]);
+        }
+        return null;
+    }
+    /**
+     * Return the level count of a multi-level Data Series.
+     */
+    public function multiLevelCount(): int
+    {
+        $levelCount = 0;
+        foreach (($this->dataValues ?? []) as $dataValueSet) {
+            $levelCount = max($levelCount, count($dataValueSet));
+        }
+        return $levelCount;
+    }
+    /**
+     * Get Series Data Values.
+     */
+    public function getDataValues(): ?array
+    {
+        return $this->dataValues;
+    }
+    /**
+     * Get the first Series Data value.
+     */
+    public function getDataValue(): mixed
+    {
+        if ($this->dataValues === null) {
+            return null;
+        }
+        $count = count($this->dataValues);
+        if ($count == 0) {
+            return null;
+        } elseif ($count == 1) {
+            return $this->dataValues[0];
+        }
+        return $this->dataValues;
+    }
+    /**
+     * Set Series Data Values.
+     *
+     * @return $this
+     */
+    public function setDataValues(array $dataValues): static
+    {
+        $this->dataValues = Functions::flattenArray($dataValues);
+        $this->pointCount = count($dataValues);
+        return $this;
+    }
+    public function refresh(Worksheet $worksheet, bool $flatten = true): void
+    {
+        if ($this->dataSource !== null) {
+            $calcEngine = Calculation::getInstance($worksheet->getParent());
+            $newDataValues = Calculation::unwrapResult(
+                $calcEngine->_calculateFormulaValue(
+                    '=' . $this->dataSource,
+                    null,
+                    $worksheet->getCell('A1')
+                )
+            );
+            if ($flatten) {
+                $this->dataValues = Functions::flattenArray($newDataValues);
+                foreach ($this->dataValues as &$dataValue) {
+                    if (is_string($dataValue) && !empty($dataValue) && $dataValue[0] == '#') {
+                        $dataValue = 0.0;
+                    }
+                }
+                unset($dataValue);
+            } else {
+                [$worksheet, $cellRange] = Worksheet::extractSheetTitle($this->dataSource, true);
+                $dimensions = Coordinate::rangeDimension(str_replace('$', '', $cellRange ?? ''));
+                if (($dimensions[0] == 1) || ($dimensions[1] == 1)) {
+                    $this->dataValues = Functions::flattenArray($newDataValues);
+                } else {
+                    /** @var array<int, array> */
+                    $newDataValuesx = $newDataValues;
+                    $newArray = array_values(array_shift($newDataValuesx) ?? []);
+                    foreach ($newArray as $i => $newDataSet) {
+                        $newArray[$i] = [$newDataSet];
+                    }
+                    foreach ($newDataValuesx as $newDataSet) {
+                        $i = 0;
+                        foreach ($newDataSet as $newDataVal) {
+                            array_unshift($newArray[$i++], $newDataVal);
+                        }
+                    }
+                    $this->dataValues = $newArray;
+                }
+            }
+            $this->pointCount = count($this->dataValues);
+        }
+    }
+    public function getScatterLines(): bool
+    {
+        return $this->scatterLines;
+    }
+    public function setScatterLines(bool $scatterLines): self
+    {
+        $this->scatterLines = $scatterLines;
+        return $this;
+    }
+    public function getBubble3D(): bool
+    {
+        return $this->bubble3D;
+    }
+    public function setBubble3D(bool $bubble3D): self
+    {
+        $this->bubble3D = $bubble3D;
+        return $this;
+    }
+    /**
+     * Smooth Line. Must be specified for both DataSeries and DataSeriesValues.
+     */
+    private bool $smoothLine = false;
+    /**
+     * Get Smooth Line.
+     */
+    public function getSmoothLine(): bool
+    {
+        return $this->smoothLine;
+    }
+    /**
+     * Set Smooth Line.
+     *
+     * @return $this
+     */
+    public function setSmoothLine(bool $smoothLine): static
+    {
+        $this->smoothLine = $smoothLine;
+        return $this;
+    }
+    public function getLabelLayout(): ?Layout
+    {
+        return $this->labelLayout;
+    }
+    public function setLabelLayout(?Layout $labelLayout): self
+    {
+        $this->labelLayout = $labelLayout;
+        return $this;
+    }
+    public function setTrendLines(array $trendLines): self
+    {
+        $this->trendLines = $trendLines;
+        return $this;
+    }
+    public function getTrendLines(): array
+    {
+        return $this->trendLines;
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        parent::__clone();
+        $this->markerFillColor = clone $this->markerFillColor;
+        $this->markerBorderColor = clone $this->markerBorderColor;
+        if (is_array($this->fillColor)) {
+            $fillColor = $this->fillColor;
+            $this->fillColor = [];
+            foreach ($fillColor as $color) {
+                $this->fillColor[] = clone $color;
+            }
+        } elseif ($this->fillColor instanceof ChartColor) {
+            $this->fillColor = clone $this->fillColor;
+        }
+        $this->labelLayout = ($this->labelLayout === null) ? null : clone $this->labelLayout;
+        $trendLines = $this->trendLines;
+        $this->trendLines = [];
+        foreach ($trendLines as $trendLine) {
+            $this->trendLines[] = clone $trendLine;
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Chart/Properties.php
@@ -0,0 +1,808 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Chart;
+/**
+ * Created by PhpStorm.
+ * User: nhw2h8s
+ * Date: 7/2/14
+ * Time: 5:45 PM.
+ */
+abstract class Properties
+{
+    const AXIS_LABELS_LOW = 'low';
+    const AXIS_LABELS_HIGH = 'high';
+    const AXIS_LABELS_NEXT_TO = 'nextTo';
+    const AXIS_LABELS_NONE = 'none';
+    const TICK_MARK_NONE = 'none';
+    const TICK_MARK_INSIDE = 'in';
+    const TICK_MARK_OUTSIDE = 'out';
+    const TICK_MARK_CROSS = 'cross';
+    const HORIZONTAL_CROSSES_AUTOZERO = 'autoZero';
+    const HORIZONTAL_CROSSES_MAXIMUM = 'max';
+    const FORMAT_CODE_GENERAL = 'General';
+    const FORMAT_CODE_NUMBER = '#,##0.00';
+    const FORMAT_CODE_CURRENCY = '$#,##0.00';
+    const FORMAT_CODE_ACCOUNTING = '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)';
+    const FORMAT_CODE_DATE = 'm/d/yyyy';
+    const FORMAT_CODE_DATE_ISO8601 = 'yyyy-mm-dd';
+    const FORMAT_CODE_TIME = '[$-F400]h:mm:ss AM/PM';
+    const FORMAT_CODE_PERCENTAGE = '0.00%';
+    const FORMAT_CODE_FRACTION = '# ?/?';
+    const FORMAT_CODE_SCIENTIFIC = '0.00E+00';
+    const FORMAT_CODE_TEXT = '@';
+    const FORMAT_CODE_SPECIAL = '00000';
+    const ORIENTATION_NORMAL = 'minMax';
+    const ORIENTATION_REVERSED = 'maxMin';
+    const LINE_STYLE_COMPOUND_SIMPLE = 'sng';
+    const LINE_STYLE_COMPOUND_DOUBLE = 'dbl';
+    const LINE_STYLE_COMPOUND_THICKTHIN = 'thickThin';
+    const LINE_STYLE_COMPOUND_THINTHICK = 'thinThick';
+    const LINE_STYLE_COMPOUND_TRIPLE = 'tri';
+    const LINE_STYLE_DASH_SOLID = 'solid';
+    const LINE_STYLE_DASH_ROUND_DOT = 'sysDot';
+    const LINE_STYLE_DASH_SQUARE_DOT = 'sysDash';
+    const LINE_STYPE_DASH_DASH = 'dash';
+    const LINE_STYLE_DASH_DASH_DOT = 'dashDot';
+    const LINE_STYLE_DASH_LONG_DASH = 'lgDash';
+    const LINE_STYLE_DASH_LONG_DASH_DOT = 'lgDashDot';
+    const LINE_STYLE_DASH_LONG_DASH_DOT_DOT = 'lgDashDotDot';
+    const LINE_STYLE_CAP_SQUARE = 'sq';
+    const LINE_STYLE_CAP_ROUND = 'rnd';
+    const LINE_STYLE_CAP_FLAT = 'flat';
+    const LINE_STYLE_JOIN_ROUND = 'round';
+    const LINE_STYLE_JOIN_MITER = 'miter';
+    const LINE_STYLE_JOIN_BEVEL = 'bevel';
+    const LINE_STYLE_ARROW_TYPE_NOARROW = null;
+    const LINE_STYLE_ARROW_TYPE_ARROW = 'triangle';
+    const LINE_STYLE_ARROW_TYPE_OPEN = 'arrow';
+    const LINE_STYLE_ARROW_TYPE_STEALTH = 'stealth';
+    const LINE_STYLE_ARROW_TYPE_DIAMOND = 'diamond';
+    const LINE_STYLE_ARROW_TYPE_OVAL = 'oval';
+    const LINE_STYLE_ARROW_SIZE_1 = 1;
+    const LINE_STYLE_ARROW_SIZE_2 = 2;
+    const LINE_STYLE_ARROW_SIZE_3 = 3;
+    const LINE_STYLE_ARROW_SIZE_4 = 4;
+    const LINE_STYLE_ARROW_SIZE_5 = 5;
+    const LINE_STYLE_ARROW_SIZE_6 = 6;
+    const LINE_STYLE_ARROW_SIZE_7 = 7;
+    const LINE_STYLE_ARROW_SIZE_8 = 8;
+    const LINE_STYLE_ARROW_SIZE_9 = 9;
+    const SHADOW_PRESETS_NOSHADOW = null;
+    const SHADOW_PRESETS_OUTER_BOTTTOM_RIGHT = 1;
+    const SHADOW_PRESETS_OUTER_BOTTOM = 2;
+    const SHADOW_PRESETS_OUTER_BOTTOM_LEFT = 3;
+    const SHADOW_PRESETS_OUTER_RIGHT = 4;
+    const SHADOW_PRESETS_OUTER_CENTER = 5;
+    const SHADOW_PRESETS_OUTER_LEFT = 6;
+    const SHADOW_PRESETS_OUTER_TOP_RIGHT = 7;
+    const SHADOW_PRESETS_OUTER_TOP = 8;
+    const SHADOW_PRESETS_OUTER_TOP_LEFT = 9;
+    const SHADOW_PRESETS_INNER_BOTTTOM_RIGHT = 10;
+    const SHADOW_PRESETS_INNER_BOTTOM = 11;
+    const SHADOW_PRESETS_INNER_BOTTOM_LEFT = 12;
+    const SHADOW_PRESETS_INNER_RIGHT = 13;
+    const SHADOW_PRESETS_INNER_CENTER = 14;
+    const SHADOW_PRESETS_INNER_LEFT = 15;
+    const SHADOW_PRESETS_INNER_TOP_RIGHT = 16;
+    const SHADOW_PRESETS_INNER_TOP = 17;
+    const SHADOW_PRESETS_INNER_TOP_LEFT = 18;
+    const SHADOW_PRESETS_PERSPECTIVE_BELOW = 19;
+    const SHADOW_PRESETS_PERSPECTIVE_UPPER_RIGHT = 20;
+    const SHADOW_PRESETS_PERSPECTIVE_UPPER_LEFT = 21;
+    const SHADOW_PRESETS_PERSPECTIVE_LOWER_RIGHT = 22;
+    const SHADOW_PRESETS_PERSPECTIVE_LOWER_LEFT = 23;
+    const POINTS_WIDTH_MULTIPLIER = 12700;
+    const ANGLE_MULTIPLIER = 60000; // direction and size-kx size-ky
+    const PERCENTAGE_MULTIPLIER = 100000; // size sx and sy
+    protected bool $objectState = false; // used only for minor gridlines
+    /** @var ?float */
+    protected ?float $glowSize = null;
+    protected ChartColor $glowColor;
+    protected array $softEdges = [
+        'size' => null,
+    ];
+    protected array $shadowProperties = self::PRESETS_OPTIONS[0];
+    protected ChartColor $shadowColor;
+    public function __construct()
+    {
+        $this->lineColor = new ChartColor();
+        $this->glowColor = new ChartColor();
+        $this->shadowColor = new ChartColor();
+        $this->shadowColor->setType(ChartColor::EXCEL_COLOR_TYPE_STANDARD);
+        $this->shadowColor->setValue('black');
+        $this->shadowColor->setAlpha(40);
+    }
+    /**
+     * Get Object State.
+     */
+    public function getObjectState(): bool
+    {
+        return $this->objectState;
+    }
+    /**
+     * Change Object State to True.
+     *
+     * @return $this
+     */
+    public function activateObject()
+    {
+        $this->objectState = true;
+        return $this;
+    }
+    public static function pointsToXml(float $width): string
+    {
+        return (string) (int) ($width * self::POINTS_WIDTH_MULTIPLIER);
+    }
+    public static function xmlToPoints(string $width): float
+    {
+        return ((float) $width) / self::POINTS_WIDTH_MULTIPLIER;
+    }
+    public static function angleToXml(float $angle): string
+    {
+        return (string) (int) ($angle * self::ANGLE_MULTIPLIER);
+    }
+    public static function xmlToAngle(string $angle): float
+    {
+        return ((float) $angle) / self::ANGLE_MULTIPLIER;
+    }
+    public static function tenthOfPercentToXml(float $value): string
+    {
+        return (string) (int) ($value * self::PERCENTAGE_MULTIPLIER);
+    }
+    public static function xmlToTenthOfPercent(string $value): float
+    {
+        return ((float) $value) / self::PERCENTAGE_MULTIPLIER;
+    }
+    protected function setColorProperties(?string $color, null|float|int|string $alpha, ?string $colorType): array
+    {
+        return [
+            'type' => $colorType,
+            'value' => $color,
+            'alpha' => ($alpha === null) ? null : (int) $alpha,
+        ];
+    }
+    protected const PRESETS_OPTIONS = [
+        0 => [
+            'presets' => self::SHADOW_PRESETS_NOSHADOW,
+            'effect' => null,
+            'size' => [
+                'sx' => null,
+                'sy' => null,
+                'kx' => null,
+                'ky' => null,
+            ],
+            'blur' => null,
+            'direction' => null,
+            'distance' => null,
+            'algn' => null,
+            'rotWithShape' => null,
+        ],
+        1 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 2700000 / self::ANGLE_MULTIPLIER,
+            'algn' => 'tl',
+            'rotWithShape' => '0',
+        ],
+        2 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 5400000 / self::ANGLE_MULTIPLIER,
+            'algn' => 't',
+            'rotWithShape' => '0',
+        ],
+        3 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 8100000 / self::ANGLE_MULTIPLIER,
+            'algn' => 'tr',
+            'rotWithShape' => '0',
+        ],
+        4 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'algn' => 'l',
+            'rotWithShape' => '0',
+        ],
+        5 => [
+            'effect' => 'outerShdw',
+            'size' => [
+                'sx' => 102000 / self::PERCENTAGE_MULTIPLIER,
+                'sy' => 102000 / self::PERCENTAGE_MULTIPLIER,
+            ],
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'algn' => 'ctr',
+            'rotWithShape' => '0',
+        ],
+        6 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 10800000 / self::ANGLE_MULTIPLIER,
+            'algn' => 'r',
+            'rotWithShape' => '0',
+        ],
+        7 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 18900000 / self::ANGLE_MULTIPLIER,
+            'algn' => 'bl',
+            'rotWithShape' => '0',
+        ],
+        8 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 16200000 / self::ANGLE_MULTIPLIER,
+            'rotWithShape' => '0',
+        ],
+        9 => [
+            'effect' => 'outerShdw',
+            'blur' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 38100 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 13500000 / self::ANGLE_MULTIPLIER,
+            'algn' => 'br',
+            'rotWithShape' => '0',
+        ],
+        10 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 2700000 / self::ANGLE_MULTIPLIER,
+        ],
+        11 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 5400000 / self::ANGLE_MULTIPLIER,
+        ],
+        12 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 8100000 / self::ANGLE_MULTIPLIER,
+        ],
+        13 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+        ],
+        14 => [
+            'effect' => 'innerShdw',
+            'blur' => 114300 / self::POINTS_WIDTH_MULTIPLIER,
+        ],
+        15 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 10800000 / self::ANGLE_MULTIPLIER,
+        ],
+        16 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 18900000 / self::ANGLE_MULTIPLIER,
+        ],
+        17 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 16200000 / self::ANGLE_MULTIPLIER,
+        ],
+        18 => [
+            'effect' => 'innerShdw',
+            'blur' => 63500 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 50800 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 13500000 / self::ANGLE_MULTIPLIER,
+        ],
+        19 => [
+            'effect' => 'outerShdw',
+            'blur' => 152400 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 317500 / self::POINTS_WIDTH_MULTIPLIER,
+            'size' => [
+                'sx' => 90000 / self::PERCENTAGE_MULTIPLIER,
+                'sy' => -19000 / self::PERCENTAGE_MULTIPLIER,
+            ],
+            'direction' => 5400000 / self::ANGLE_MULTIPLIER,
+            'rotWithShape' => '0',
+        ],
+        20 => [
+            'effect' => 'outerShdw',
+            'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 18900000 / self::ANGLE_MULTIPLIER,
+            'size' => [
+                'sy' => 23000 / self::PERCENTAGE_MULTIPLIER,
+                'kx' => -1200000 / self::ANGLE_MULTIPLIER,
+            ],
+            'algn' => 'bl',
+            'rotWithShape' => '0',
+        ],
+        21 => [
+            'effect' => 'outerShdw',
+            'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 13500000 / self::ANGLE_MULTIPLIER,
+            'size' => [
+                'sy' => 23000 / self::PERCENTAGE_MULTIPLIER,
+                'kx' => 1200000 / self::ANGLE_MULTIPLIER,
+            ],
+            'algn' => 'br',
+            'rotWithShape' => '0',
+        ],
+        22 => [
+            'effect' => 'outerShdw',
+            'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 12700 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 2700000 / self::ANGLE_MULTIPLIER,
+            'size' => [
+                'sy' => -23000 / self::PERCENTAGE_MULTIPLIER,
+                'kx' => -800400 / self::ANGLE_MULTIPLIER,
+            ],
+            'algn' => 'bl',
+            'rotWithShape' => '0',
+        ],
+        23 => [
+            'effect' => 'outerShdw',
+            'blur' => 76200 / self::POINTS_WIDTH_MULTIPLIER,
+            'distance' => 12700 / self::POINTS_WIDTH_MULTIPLIER,
+            'direction' => 8100000 / self::ANGLE_MULTIPLIER,
+            'size' => [
+                'sy' => -23000 / self::PERCENTAGE_MULTIPLIER,
+                'kx' => 800400 / self::ANGLE_MULTIPLIER,
+            ],
+            'algn' => 'br',
+            'rotWithShape' => '0',
+        ],
+    ];
+    protected function getShadowPresetsMap(int $presetsOption): array
+    {
+        return self::PRESETS_OPTIONS[$presetsOption] ?? self::PRESETS_OPTIONS[0];
+    }
+    /**
+     * Get value of array element.
+     */
+    protected function getArrayElementsValue(array $properties, array|int|string $elements): mixed
+    {
+        $reference = &$properties;
+        if (!is_array($elements)) {
+            return $reference[$elements];
+        }
+        foreach ($elements as $keys) {
+            $reference = &$reference[$keys];
+        }
+        return $reference;
+    }
+    /**
+     * Set Glow Properties.
+     */
+    public function setGlowProperties(float $size, ?string $colorValue = null, ?int $colorAlpha = null, ?string $colorType = null): void
+    {
+        $this
+            ->activateObject()
+            ->setGlowSize($size);
+        $this->glowColor->setColorPropertiesArray(
+            [
+                'value' => $colorValue,
+                'type' => $colorType,
+                'alpha' => $colorAlpha,
+            ]
+        );
+    }
+    /**
+     * Get Glow Property.
+     */
+    public function getGlowProperty(array|string $property): null|array|float|int|string
+    {
+        $retVal = null;
+        if ($property === 'size') {
+            $retVal = $this->glowSize;
+        } elseif ($property === 'color') {
+            $retVal = [
+                'value' => $this->glowColor->getColorProperty('value'),
+                'type' => $this->glowColor->getColorProperty('type'),
+                'alpha' => $this->glowColor->getColorProperty('alpha'),
+            ];
+        } elseif (is_array($property) && count($property) >= 2 && $property[0] === 'color') {
+            $retVal = $this->glowColor->getColorProperty($property[1]);
+        }
+        return $retVal;
+    }
+    /**
+     * Get Glow Color Property.
+     */
+    public function getGlowColor(string $propertyName): null|int|string
+    {
+        return $this->glowColor->getColorProperty($propertyName);
+    }
+    public function getGlowColorObject(): ChartColor
+    {
+        return $this->glowColor;
+    }
+    /**
+     * Get Glow Size.
+     */
+    public function getGlowSize(): ?float
+    {
+        return $this->glowSize;
+    }
+    /**
+     * Set Glow Size.
+     *
+     * @return $this
+     */
+    protected function setGlowSize(?float $size)
+    {
+        $this->glowSize = $size;
+        return $this;
+    }
+    /**
+     * Set Soft Edges Size.
+     */
+    public function setSoftEdges(?float $size): void
+    {
+        if ($size !== null) {
+            $this->activateObject();
+            $this->softEdges['size'] = $size;
+        }
+    }
+    /**
+     * Get Soft Edges Size.
+     */
+    public function getSoftEdgesSize(): ?float
+    {
+        return $this->softEdges['size'];
+    }
+    public function setShadowProperty(string $propertyName, mixed $value): self
+    {
+        $this->activateObject();
+        if ($propertyName === 'color' && is_array($value)) {
+            $this->shadowColor->setColorPropertiesArray($value);
+        } else {
+            $this->shadowProperties[$propertyName] = $value;
+        }
+        return $this;
+    }
+    /**
+     * Set Shadow Properties.
+     */
+    public function setShadowProperties(int $presets, ?string $colorValue = null, ?string $colorType = null, null|float|int|string $colorAlpha = null, ?float $blur = null, ?int $angle = null, ?float $distance = null): void
+    {
+        $this->activateObject()->setShadowPresetsProperties((int) $presets);
+        if ($presets === 0) {
+            $this->shadowColor->setType(ChartColor::EXCEL_COLOR_TYPE_STANDARD);
+            $this->shadowColor->setValue('black');
+            $this->shadowColor->setAlpha(40);
+        }
+        if ($colorValue !== null) {
+            $this->shadowColor->setValue($colorValue);
+        }
+        if ($colorType !== null) {
+            $this->shadowColor->setType($colorType);
+        }
+        if (is_numeric($colorAlpha)) {
+            $this->shadowColor->setAlpha((int) $colorAlpha);
+        }
+        $this
+            ->setShadowBlur($blur)
+            ->setShadowAngle($angle)
+            ->setShadowDistance($distance);
+    }
+    /**
+     * Set Shadow Presets Properties.
+     *
+     * @return $this
+     */
+    protected function setShadowPresetsProperties(int $presets)
+    {
+        $this->shadowProperties['presets'] = $presets;
+        $this->setShadowPropertiesMapValues($this->getShadowPresetsMap($presets));
+        return $this;
+    }
+    protected const SHADOW_ARRAY_KEYS = ['size', 'color'];
+    /**
+     * Set Shadow Properties Values.
+     *
+     * @return $this
+     */
+    protected function setShadowPropertiesMapValues(array $propertiesMap, ?array &$reference = null)
+    {
+        $base_reference = $reference;
+        foreach ($propertiesMap as $property_key => $property_val) {
+            if (is_array($property_val)) {
+                if (in_array($property_key, self::SHADOW_ARRAY_KEYS, true)) {
+                    $reference = &$this->shadowProperties[$property_key];
+                    $this->setShadowPropertiesMapValues($property_val, $reference);
+                }
+            } else {
+                if ($base_reference === null) {
+                    $this->shadowProperties[$property_key] = $property_val;
+                } else {
+                    $reference[$property_key] = $property_val;
+                }
+            }
+        }
+        return $this;
+    }
+    /**
+     * Set Shadow Blur.
+     *
+     * @return $this
+     */
+    protected function setShadowBlur(?float $blur)
+    {
+        if ($blur !== null) {
+            $this->shadowProperties['blur'] = $blur;
+        }
+        return $this;
+    }
+    /**
+     * Set Shadow Angle.
+     *
+     * @return $this
+     */
+    protected function setShadowAngle(null|float|int|string $angle)
+    {
+        if (is_numeric($angle)) {
+            $this->shadowProperties['direction'] = $angle;
+        }
+        return $this;
+    }
+    /**
+     * Set Shadow Distance.
+     *
+     * @return $this
+     */
+    protected function setShadowDistance(?float $distance)
+    {
+        if ($distance !== null) {
+            $this->shadowProperties['distance'] = $distance;
+        }
+        return $this;
+    }
+    public function getShadowColorObject(): ChartColor
+    {
+        return $this->shadowColor;
+    }
+    /**
+     * Get Shadow Property.
+     *
+     * @param string|string[] $elements
+     */
+    public function getShadowProperty($elements): array|string|null
+    {
+        if ($elements === 'color') {
+            return [
+                'value' => $this->shadowColor->getValue(),
+                'type' => $this->shadowColor->getType(),
+                'alpha' => $this->shadowColor->getAlpha(),
+            ];
+        }
+        $retVal = $this->getArrayElementsValue($this->shadowProperties, $elements);
+        if (is_scalar($retVal)) {
+            $retVal = (string) $retVal;
+        } elseif ($retVal !== null && !is_array($retVal)) {
+            throw new Exception('Unexpected value for shadowProperty');
+        }
+        return $retVal;
+    }
+    public function getShadowArray(): array
+    {
+        $array = $this->shadowProperties;
+        if ($this->getShadowColorObject()->isUsable()) {
+            $array['color'] = $this->getShadowProperty('color');
+        }
+        return $array;
+    }
+    protected ChartColor $lineColor;
+    protected array $lineStyleProperties = [
+        'width' => null, //'9525',
+        'compound' => '', //self::LINE_STYLE_COMPOUND_SIMPLE,
+        'dash' => '', //self::LINE_STYLE_DASH_SOLID,
+        'cap' => '', //self::LINE_STYLE_CAP_FLAT,
+        'join' => '', //self::LINE_STYLE_JOIN_BEVEL,
+        'arrow' => [
+            'head' => [
+                'type' => '', //self::LINE_STYLE_ARROW_TYPE_NOARROW,
+                'size' => '', //self::LINE_STYLE_ARROW_SIZE_5,
+                'w' => '',
+                'len' => '',
+            ],
+            'end' => [
+                'type' => '', //self::LINE_STYLE_ARROW_TYPE_NOARROW,
+                'size' => '', //self::LINE_STYLE_ARROW_SIZE_8,
+                'w' => '',
+                'len' => '',
+            ],
+        ],
+    ];
+    public function copyLineStyles(self $otherProperties): void
+    {
+        $this->lineStyleProperties = $otherProperties->lineStyleProperties;
+        $this->lineColor = $otherProperties->lineColor;
+        $this->glowSize = $otherProperties->glowSize;
+        $this->glowColor = $otherProperties->glowColor;
+        $this->softEdges = $otherProperties->softEdges;
+        $this->shadowProperties = $otherProperties->shadowProperties;
+    }
+    public function getLineColor(): ChartColor
+    {
+        return $this->lineColor;
+    }
+    /**
+     * Set Line Color Properties.
+     */
+    public function setLineColorProperties(?string $value, ?int $alpha = null, ?string $colorType = null): void
+    {
+        $this->activateObject();
+        $this->lineColor->setColorPropertiesArray(
+            $this->setColorProperties(
+                $value,
+                $alpha,
+                $colorType
+            )
+        );
+    }
+    /**
+     * Get Line Color Property.
+     */
+    public function getLineColorProperty(string $propertyName): null|int|string
+    {
+        return $this->lineColor->getColorProperty($propertyName);
+    }
+    /**
+     * Set Line Style Properties.
+     */
+    public function setLineStyleProperties(
+        null|float|int|string $lineWidth = null,
+        ?string $compoundType = '',
+        ?string $dashType = '',
+        ?string $capType = '',
+        ?string $joinType = '',
+        ?string $headArrowType = '',
+        int $headArrowSize = 0,
+        ?string $endArrowType = '',
+        int $endArrowSize = 0,
+        ?string $headArrowWidth = '',
+        ?string $headArrowLength = '',
+        ?string $endArrowWidth = '',
+        ?string $endArrowLength = ''
+    ): void {
+        $this->activateObject();
+        if (is_numeric($lineWidth)) {
+            $this->lineStyleProperties['width'] = $lineWidth;
+        }
+        if ($compoundType !== '') {
+            $this->lineStyleProperties['compound'] = $compoundType;
+        }
+        if ($dashType !== '') {
+            $this->lineStyleProperties['dash'] = $dashType;
+        }
+        if ($capType !== '') {
+            $this->lineStyleProperties['cap'] = $capType;
+        }
+        if ($joinType !== '') {
+            $this->lineStyleProperties['join'] = $joinType;
+        }
+        if ($headArrowType !== '') {
+            $this->lineStyleProperties['arrow']['head']['type'] = $headArrowType;
+        }
+        if (isset(self::ARROW_SIZES[$headArrowSize])) {
+            $this->lineStyleProperties['arrow']['head']['size'] = $headArrowSize;
+            $this->lineStyleProperties['arrow']['head']['w'] = self::ARROW_SIZES[$headArrowSize]['w'];
+            $this->lineStyleProperties['arrow']['head']['len'] = self::ARROW_SIZES[$headArrowSize]['len'];
+        }
+        if ($endArrowType !== '') {
+            $this->lineStyleProperties['arrow']['end']['type'] = $endArrowType;
+        }
+        if (isset(self::ARROW_SIZES[$endArrowSize])) {
+            $this->lineStyleProperties['arrow']['end']['size'] = $endArrowSize;
+            $this->lineStyleProperties['arrow']['end']['w'] = self::ARROW_SIZES[$endArrowSize]['w'];
+            $this->lineStyleProperties['arrow']['end']['len'] = self::ARROW_SIZES[$endArrowSize]['len'];
+        }
+        if ($headArrowWidth !== '') {
+            $this->lineStyleProperties['arrow']['head']['w'] = $headArrowWidth;
+        }
+        if ($headArrowLength !== '') {
+            $this->lineStyleProperties['arrow']['head']['len'] = $headArrowLength;
+        }
+        if ($endArrowWidth !== '') {
+            $this->lineStyleProperties['arrow']['end']['w'] = $endArrowWidth;
+        }
+        if ($endArrowLength !== '') {
+            $this->lineStyleProperties['arrow']['end']['len'] = $endArrowLength;
+        }
+    }
+    public function getLineStyleArray(): array
+    {
+        return $this->lineStyleProperties;
+    }
+    public function setLineStyleArray(array $lineStyleProperties = []): self
+    {
+        $this->activateObject();
+        $this->lineStyleProperties['width'] = $lineStyleProperties['width'] ?? null;
+        $this->lineStyleProperties['compound'] = $lineStyleProperties['compound'] ?? '';
+        $this->lineStyleProperties['dash'] = $lineStyleProperties['dash'] ?? '';
+        $this->lineStyleProperties['cap'] = $lineStyleProperties['cap'] ?? '';
+        $this->lineStyleProperties['join'] = $lineStyleProperties['join'] ?? '';
+        $this->lineStyleProperties['arrow']['head']['type'] = $lineStyleProperties['arrow']['head']['type'] ?? '';
+        $this->lineStyleProperties['arrow']['head']['size'] = $lineStyleProperties['arrow']['head']['size'] ?? '';
+        $this->lineStyleProperties['arrow']['head']['w'] = $lineStyleProperties['arrow']['head']['w'] ?? '';
+        $this->lineStyleProperties['arrow']['head']['len'] = $lineStyleProperties['arrow']['head']['len'] ?? '';
+        $this->lineStyleProperties['arrow']['end']['type'] = $lineStyleProperties['arrow']['end']['type'] ?? '';
+        $this->lineStyleProperties['arrow']['end']['size'] = $lineStyleProperties['arrow']['end']['size'] ?? '';
+        $this->lineStyleProperties['arrow']['end']['w'] = $lineStyleProperties['arrow']['end']['w'] ?? '';
+        $this->lineStyleProperties['arrow']['end']['len'] = $lineStyleProperties['arrow']['end']['len'] ?? '';
+        return $this;
+    }
+    public function setLineStyleProperty(string $propertyName, mixed $value): self
+    {
+        $this->activateObject();
+        $this->lineStyleProperties[$propertyName] = $value;
+        return $this;
+    }
+    /**
+     * Get Line Style Property.
+     */
+    public function getLineStyleProperty(array|string $elements): ?string
+    {
+        $retVal = $this->getArrayElementsValue($this->lineStyleProperties, $elements);
+        if (is_scalar($retVal)) {
+            $retVal = (string) $retVal;
+        } elseif ($retVal !== null) {
+            throw new Exception('Unexpected value for lineStyleProperty');
+        }
+        return $retVal;
+    }
+    protected const ARROW_SIZES = [
+        1 => ['w' => 'sm', 'len' => 'sm'],
+        2 => ['w' => 'sm', 'len' => 'med'],
+        3 => ['w' => 'sm', 'len' => 'lg'],
+        4 => ['w' => 'med', 'len' => 'sm'],
+        5 => ['w' => 'med', 'len' => 'med'],
+        6 => ['w' => 'med', 'len' => 'lg'],
+        7 => ['w' => 'lg', 'len' => 'sm'],
+        8 => ['w' => 'lg', 'len' => 'med'],
+        9 => ['w' => 'lg', 'len' => 'lg'],
+    ];
+    /**
+     * Get Line Style Arrow Size.
+     */
+    protected function getLineStyleArrowSize(int $arraySelector, string $arrayKaySelector): string
+    {
+        return self::ARROW_SIZES[$arraySelector][$arrayKaySelector] ?? '';
+    }
+    /**
+     * Get Line Style Arrow Parameters.
+     */
+    public function getLineStyleArrowParameters(string $arrowSelector, string $propertySelector): string
+    {
+        return $this->getLineStyleArrowSize($this->lineStyleProperties['arrow'][$arrowSelector]['size'], $propertySelector);
+    }
+    /**
+     * Get Line Style Arrow Width.
+     */
+    public function getLineStyleArrowWidth(string $arrow): ?string
+    {
+        return $this->getLineStyleProperty(['arrow', $arrow, 'w']);
+    }
+    /**
+     * Get Line Style Arrow Excel Length.
+     */
+    public function getLineStyleArrowLength(string $arrow): ?string
+    {
+        return $this->getLineStyleProperty(['arrow', $arrow, 'len']);
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $this->lineColor = clone $this->lineColor;
+        $this->glowColor = clone $this->glowColor;
+        $this->shadowColor = clone $this->shadowColor;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Chart/Renderer/JpGraphRendererBase.php
@@ -0,0 +1,704 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Chart\Renderer;
+use AccBarPlot;
+use AccLinePlot;
+use BarPlot;
+use ContourPlot;
+use Graph;
+use GroupBarPlot;
+use LinePlot;
+use PhpOffice\PhpSpreadsheet\Chart\Chart;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PieGraph;
+use PiePlot;
+use PiePlot3D;
+use PiePlotC;
+use RadarGraph;
+use RadarPlot;
+use ScatterPlot;
+use Spline;
+use StockPlot;
+/**
+ * Base class for different Jpgraph implementations as charts renderer.
+ */
+abstract class JpGraphRendererBase implements IRenderer
+{
+    private const DEFAULT_WIDTH = 640.0;
+    private const DEFAULT_HEIGHT = 480.0;
+    private static $colourSet = [
+        'mediumpurple1', 'palegreen3', 'gold1', 'cadetblue1',
+        'darkmagenta', 'coral', 'dodgerblue3', 'eggplant',
+        'mediumblue', 'magenta', 'sandybrown', 'cyan',
+        'firebrick1', 'forestgreen', 'deeppink4', 'darkolivegreen',
+        'goldenrod2',
+    ];
+    private static array $markSet;
+    private Chart $chart;
+    private $graph;
+    private static $plotColour = 0;
+    private static $plotMark = 0;
+    /**
+     * Create a new jpgraph.
+     */
+    public function __construct(Chart $chart)
+    {
+        static::init();
+        $this->graph = null;
+        $this->chart = $chart;
+        self::$markSet = [
+            'diamond' => MARK_DIAMOND,
+            'square' => MARK_SQUARE,
+            'triangle' => MARK_UTRIANGLE,
+            'x' => MARK_X,
+            'star' => MARK_STAR,
+            'dot' => MARK_FILLEDCIRCLE,
+            'dash' => MARK_DTRIANGLE,
+            'circle' => MARK_CIRCLE,
+            'plus' => MARK_CROSS,
+        ];
+    }
+    private function getGraphWidth(): float
+    {
+        return $this->chart->getRenderedWidth() ?? self::DEFAULT_WIDTH;
+    }
+    private function getGraphHeight(): float
+    {
+        return $this->chart->getRenderedHeight() ?? self::DEFAULT_HEIGHT;
+    }
+    /**
+     * This method should be overriden in descendants to do real JpGraph library initialization.
+     */
+    abstract protected static function init(): void;
+    private function formatPointMarker($seriesPlot, $markerID)
+    {
+        $plotMarkKeys = array_keys(self::$markSet);
+        if ($markerID === null) {
+            self::$plotMark %= count(self::$markSet);
+            $seriesPlot->mark->SetType(self::$markSet[$plotMarkKeys[self::$plotMark++]]);
+        } elseif ($markerID !== 'none') {
+            if (isset(self::$markSet[$markerID])) {
+                $seriesPlot->mark->SetType(self::$markSet[$markerID]);
+            } else {
+                self::$plotMark %= count(self::$markSet);
+                $seriesPlot->mark->SetType(self::$markSet[$plotMarkKeys[self::$plotMark++]]);
+            }
+        } else {
+            $seriesPlot->mark->Hide();
+        }
+        $seriesPlot->mark->SetColor(self::$colourSet[self::$plotColour]);
+        $seriesPlot->mark->SetFillColor(self::$colourSet[self::$plotColour]);
+        $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
+        return $seriesPlot;
+    }
+    private function formatDataSetLabels(int $groupID, array $datasetLabels, $rotation = '')
+    {
+        $datasetLabelFormatCode = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getFormatCode() ?? '';
+        $datasetLabelFormatCode = stripslashes($datasetLabelFormatCode);
+        $testCurrentIndex = 0;
+        foreach ($datasetLabels as $i => $datasetLabel) {
+            if (is_array($datasetLabel)) {
+                if ($rotation == 'bar') {
+                    $datasetLabels[$i] = implode(' ', $datasetLabel);
+                } else {
+                    $datasetLabel = array_reverse($datasetLabel);
+                    $datasetLabels[$i] = implode("\n", $datasetLabel);
+                }
+            } else {
+                if ($datasetLabelFormatCode !== null) {
+                    $datasetLabels[$i] = NumberFormat::toFormattedString($datasetLabel, $datasetLabelFormatCode);
+                }
+            }
+            ++$testCurrentIndex;
+        }
+        return $datasetLabels;
+    }
+    private function percentageSumCalculation(int $groupID, $seriesCount)
+    {
+        $sumValues = [];
+        for ($i = 0; $i < $seriesCount; ++$i) {
+            if ($i == 0) {
+                $sumValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
+            } else {
+                $nextValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
+                foreach ($nextValues as $k => $value) {
+                    if (isset($sumValues[$k])) {
+                        $sumValues[$k] += $value;
+                    } else {
+                        $sumValues[$k] = $value;
+                    }
+                }
+            }
+        }
+        return $sumValues;
+    }
+    private function percentageAdjustValues(array $dataValues, array $sumValues)
+    {
+        foreach ($dataValues as $k => $dataValue) {
+            $dataValues[$k] = $dataValue / $sumValues[$k] * 100;
+        }
+        return $dataValues;
+    }
+    private function getCaption($captionElement)
+    {
+        $caption = ($captionElement !== null) ? $captionElement->getCaption() : null;
+        if ($caption !== null) {
+            if (is_array($caption)) {
+                $caption = implode('', $caption);
+            }
+        }
+        return $caption;
+    }
+    private function renderTitle(): void
+    {
+        $title = $this->getCaption($this->chart->getTitle());
+        if ($title !== null) {
+            $this->graph->title->Set($title);
+        }
+    }
+    private function renderLegend(): void
+    {
+        $legend = $this->chart->getLegend();
+        if ($legend !== null) {
+            $legendPosition = $legend->getPosition();
+            switch ($legendPosition) {
+                case 'r':
+                    $this->graph->legend->SetPos(0.01, 0.5, 'right', 'center'); //    right
+                    $this->graph->legend->SetColumns(1);
+                    break;
+                case 'l':
+                    $this->graph->legend->SetPos(0.01, 0.5, 'left', 'center'); //    left
+                    $this->graph->legend->SetColumns(1);
+                    break;
+                case 't':
+                    $this->graph->legend->SetPos(0.5, 0.01, 'center', 'top'); //    top
+                    break;
+                case 'b':
+                    $this->graph->legend->SetPos(0.5, 0.99, 'center', 'bottom'); //    bottom
+                    break;
+                default:
+                    $this->graph->legend->SetPos(0.01, 0.01, 'right', 'top'); //    top-right
+                    $this->graph->legend->SetColumns(1);
+                    break;
+            }
+        } else {
+            $this->graph->legend->Hide();
+        }
+    }
+    private function renderCartesianPlotArea(string $type = 'textlin'): void
+    {
+        $this->graph = new Graph($this->getGraphWidth(), $this->getGraphHeight());
+        $this->graph->SetScale($type);
+        $this->renderTitle();
+        $rotation = $this->chart->getPlotArea()->getPlotGroupByIndex(0)->getPlotDirection();
+        $reverse = $rotation == 'bar';
+        $xAxisLabel = $this->chart->getXAxisLabel();
+        if ($xAxisLabel !== null) {
+            $title = $this->getCaption($xAxisLabel);
+            if ($title !== null) {
+                $this->graph->xaxis->SetTitle($title, 'center');
+                $this->graph->xaxis->title->SetMargin(35);
+                if ($reverse) {
+                    $this->graph->xaxis->title->SetAngle(90);
+                    $this->graph->xaxis->title->SetMargin(90);
+                }
+            }
+        }
+        $yAxisLabel = $this->chart->getYAxisLabel();
+        if ($yAxisLabel !== null) {
+            $title = $this->getCaption($yAxisLabel);
+            if ($title !== null) {
+                $this->graph->yaxis->SetTitle($title, 'center');
+                if ($reverse) {
+                    $this->graph->yaxis->title->SetAngle(0);
+                    $this->graph->yaxis->title->SetMargin(-55);
+                }
+            }
+        }
+    }
+    private function renderPiePlotArea(): void
+    {
+        $this->graph = new PieGraph($this->getGraphWidth(), $this->getGraphHeight());
+        $this->renderTitle();
+    }
+    private function renderRadarPlotArea(): void
+    {
+        $this->graph = new RadarGraph($this->getGraphWidth(), $this->getGraphHeight());
+        $this->graph->SetScale('lin');
+        $this->renderTitle();
+    }
+    private function getDataLabel(int $groupId, int $index): mixed
+    {
+        $plotLabel = $this->chart->getPlotArea()->getPlotGroupByIndex($groupId)->getPlotLabelByIndex($index);
+        if (!$plotLabel) {
+            return '';
+        }
+        return $plotLabel->getDataValue();
+    }
+    private function renderPlotLine(int $groupID, bool $filled = false, bool $combination = false): void
+    {
+        $grouping = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotGrouping();
+        $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[0];
+        $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointCount();
+        if ($labelCount > 0) {
+            $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
+            $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
+            $this->graph->xaxis->SetTickLabels($datasetLabels);
+        }
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        $seriesPlots = [];
+        if ($grouping == 'percentStacked') {
+            $sumValues = $this->percentageSumCalculation($groupID, $seriesCount);
+        } else {
+            $sumValues = [];
+        }
+        for ($i = 0; $i < $seriesCount; ++$i) {
+            $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[$i];
+            $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getDataValues();
+            $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointMarker();
+            if ($grouping == 'percentStacked') {
+                $dataValues = $this->percentageAdjustValues($dataValues, $sumValues);
+            }
+            $testCurrentIndex = 0;
+            foreach ($dataValues as $k => $dataValue) {
+                while ($k != $testCurrentIndex) {
+                    $dataValues[$testCurrentIndex] = null;
+                    ++$testCurrentIndex;
+                }
+                ++$testCurrentIndex;
+            }
+            $seriesPlot = new LinePlot($dataValues);
+            if ($combination) {
+                $seriesPlot->SetBarCenter();
+            }
+            if ($filled) {
+                $seriesPlot->SetFilled(true);
+                $seriesPlot->SetColor('black');
+                $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour++]);
+            } else {
+                $this->formatPointMarker($seriesPlot, $marker);
+            }
+            $seriesPlot->SetLegend($this->getDataLabel($groupID, $index));
+            $seriesPlots[] = $seriesPlot;
+        }
+        if ($grouping == 'standard') {
+            $groupPlot = $seriesPlots;
+        } else {
+            $groupPlot = new AccLinePlot($seriesPlots);
+        }
+        $this->graph->Add($groupPlot);
+    }
+    private function renderPlotBar(int $groupID, ?string $dimensions = '2d'): void
+    {
+        $rotation = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotDirection();
+        if (($groupID == 0) && ($rotation == 'bar')) {
+            $this->graph->Set90AndMargin();
+        }
+        $grouping = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotGrouping();
+        $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[0];
+        $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getPointCount();
+        if ($labelCount > 0) {
+            $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
+            $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels, $rotation);
+            if ($rotation == 'bar') {
+                $datasetLabels = array_reverse($datasetLabels);
+                $this->graph->yaxis->SetPos('max');
+                $this->graph->yaxis->SetLabelAlign('center', 'top');
+                $this->graph->yaxis->SetLabelSide(SIDE_RIGHT);
+            }
+            $this->graph->xaxis->SetTickLabels($datasetLabels);
+        }
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        $seriesPlots = [];
+        if ($grouping == 'percentStacked') {
+            $sumValues = $this->percentageSumCalculation($groupID, $seriesCount);
+        } else {
+            $sumValues = [];
+        }
+        for ($j = 0; $j < $seriesCount; ++$j) {
+            $index = array_keys($this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder())[$j];
+            $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($index)->getDataValues();
+            if ($grouping == 'percentStacked') {
+                $dataValues = $this->percentageAdjustValues($dataValues, $sumValues);
+            }
+            $testCurrentIndex = 0;
+            foreach ($dataValues as $k => $dataValue) {
+                while ($k != $testCurrentIndex) {
+                    $dataValues[$testCurrentIndex] = null;
+                    ++$testCurrentIndex;
+                }
+                ++$testCurrentIndex;
+            }
+            if ($rotation == 'bar') {
+                $dataValues = array_reverse($dataValues);
+            }
+            $seriesPlot = new BarPlot($dataValues);
+            $seriesPlot->SetColor('black');
+            $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour++]);
+            if ($dimensions == '3d') {
+                $seriesPlot->SetShadow();
+            }
+            $seriesPlot->SetLegend($this->getDataLabel($groupID, $j));
+            $seriesPlots[] = $seriesPlot;
+        }
+        if (($rotation == 'bar') && ($grouping != 'percentStacked')) {
+            $seriesPlots = array_reverse($seriesPlots);
+        }
+        if ($grouping == 'clustered') {
+            $groupPlot = new GroupBarPlot($seriesPlots);
+        } elseif ($grouping == 'standard') {
+            $groupPlot = new GroupBarPlot($seriesPlots);
+        } else {
+            $groupPlot = new AccBarPlot($seriesPlots);
+            if ($dimensions == '3d') {
+                $groupPlot->SetShadow();
+            }
+        }
+        $this->graph->Add($groupPlot);
+    }
+    private function renderPlotScatter(int $groupID, bool $bubble): void
+    {
+        $scatterStyle = $bubbleSize = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        for ($i = 0; $i < $seriesCount; ++$i) {
+            $plotCategoryByIndex = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex($i);
+            if ($plotCategoryByIndex === false) {
+                $plotCategoryByIndex = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0);
+            }
+            $dataValuesY = $plotCategoryByIndex->getDataValues();
+            $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
+            $redoDataValuesY = true;
+            if ($bubble) {
+                if (!$bubbleSize) {
+                    $bubbleSize = '10';
+                }
+                $redoDataValuesY = false;
+                foreach ($dataValuesY as $dataValueY) {
+                    if (!is_int($dataValueY) && !is_float($dataValueY)) {
+                        $redoDataValuesY = true;
+                        break;
+                    }
+                }
+            }
+            if ($redoDataValuesY) {
+                foreach ($dataValuesY as $k => $dataValueY) {
+                    $dataValuesY[$k] = $k;
+                }
+            }
+            $seriesPlot = new ScatterPlot($dataValuesX, $dataValuesY);
+            if ($scatterStyle == 'lineMarker') {
+                $seriesPlot->SetLinkPoints();
+                $seriesPlot->link->SetColor(self::$colourSet[self::$plotColour]);
+            } elseif ($scatterStyle == 'smoothMarker') {
+                $spline = new Spline($dataValuesY, $dataValuesX);
+                [$splineDataY, $splineDataX] = $spline->Get(count($dataValuesX) * $this->getGraphWidth() / 20);
+                $lplot = new LinePlot($splineDataX, $splineDataY);
+                $lplot->SetColor(self::$colourSet[self::$plotColour]);
+                $this->graph->Add($lplot);
+            }
+            if ($bubble) {
+                $this->formatPointMarker($seriesPlot, 'dot');
+                $seriesPlot->mark->SetColor('black');
+                $seriesPlot->mark->SetSize($bubbleSize);
+            } else {
+                $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getPointMarker();
+                $this->formatPointMarker($seriesPlot, $marker);
+            }
+            $seriesPlot->SetLegend($this->getDataLabel($groupID, $i));
+            $this->graph->Add($seriesPlot);
+        }
+    }
+    private function renderPlotRadar(int $groupID): void
+    {
+        $radarStyle = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        for ($i = 0; $i < $seriesCount; ++$i) {
+            $dataValuesY = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex($i)->getDataValues();
+            $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
+            $marker = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getPointMarker();
+            $dataValues = [];
+            foreach ($dataValuesY as $k => $dataValueY) {
+                $dataValues[$k] = is_array($dataValueY) ? implode(' ', array_reverse($dataValueY)) : $dataValueY;
+            }
+            $tmp = array_shift($dataValues);
+            $dataValues[] = $tmp;
+            $tmp = array_shift($dataValuesX);
+            $dataValuesX[] = $tmp;
+            $this->graph->SetTitles(array_reverse($dataValues));
+            $seriesPlot = new RadarPlot(array_reverse($dataValuesX));
+            $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
+            if ($radarStyle == 'filled') {
+                $seriesPlot->SetFillColor(self::$colourSet[self::$plotColour]);
+            }
+            $this->formatPointMarker($seriesPlot, $marker);
+            $seriesPlot->SetLegend($this->getDataLabel($groupID, $i));
+            $this->graph->Add($seriesPlot);
+        }
+    }
+    private function renderPlotContour(int $groupID): void
+    {
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        $dataValues = [];
+        for ($i = 0; $i < $seriesCount; ++$i) {
+            $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($i)->getDataValues();
+            $dataValues[$i] = $dataValuesX;
+        }
+        $seriesPlot = new ContourPlot($dataValues);
+        $this->graph->Add($seriesPlot);
+    }
+    private function renderPlotStock(int $groupID): void
+    {
+        $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+        $plotOrder = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotOrder();
+        $dataValues = [];
+        foreach ($plotOrder as $i => $v) {
+            $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($v);
+            if ($dataValuesX === false) {
+                continue;
+            }
+            $dataValuesX = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($v)->getDataValues();
+            foreach ($dataValuesX as $j => $dataValueX) {
+                $dataValues[$plotOrder[$i]][$j] = $dataValueX;
+            }
+        }
+        if (empty($dataValues)) {
+            return;
+        }
+        $dataValuesPlot = [];
+        $jMax = count($dataValues[0]);
+        for ($j = 0; $j < $jMax; ++$j) {
+            for ($i = 0; $i < $seriesCount; ++$i) {
+                $dataValuesPlot[] = $dataValues[$i][$j] ?? null;
+            }
+        }
+        $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex(0)->getPointCount();
+        if ($labelCount > 0) {
+            $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
+            $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
+            $this->graph->xaxis->SetTickLabels($datasetLabels);
+        }
+        $seriesPlot = new StockPlot($dataValuesPlot);
+        $seriesPlot->SetWidth(20);
+        $this->graph->Add($seriesPlot);
+    }
+    private function renderAreaChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea();
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotLine($i, true, false);
+        }
+    }
+    private function renderLineChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea();
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotLine($i, false, false);
+        }
+    }
+    private function renderBarChart($groupCount, ?string $dimensions = '2d'): void
+    {
+        $this->renderCartesianPlotArea();
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotBar($i, $dimensions);
+        }
+    }
+    private function renderScatterChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea('linlin');
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotScatter($i, false);
+        }
+    }
+    private function renderBubbleChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea('linlin');
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotScatter($i, true);
+        }
+    }
+    private function renderPieChart($groupCount, ?string $dimensions = '2d', bool $doughnut = false, bool $multiplePlots = false): void
+    {
+        $this->renderPiePlotArea();
+        $iLimit = ($multiplePlots) ? $groupCount : 1;
+        for ($groupID = 0; $groupID < $iLimit; ++$groupID) {
+            $exploded = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotStyle();
+            $datasetLabels = [];
+            if ($groupID == 0) {
+                $labelCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex(0)->getPointCount();
+                if ($labelCount > 0) {
+                    $datasetLabels = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotCategoryByIndex(0)->getDataValues();
+                    $datasetLabels = $this->formatDataSetLabels($groupID, $datasetLabels);
+                }
+            }
+            $seriesCount = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotSeriesCount();
+            $jLimit = ($multiplePlots) ? $seriesCount : 1;
+            for ($j = 0; $j < $jLimit; ++$j) {
+                $dataValues = $this->chart->getPlotArea()->getPlotGroupByIndex($groupID)->getPlotValuesByIndex($j)->getDataValues();
+                $testCurrentIndex = 0;
+                foreach ($dataValues as $k => $dataValue) {
+                    while ($k != $testCurrentIndex) {
+                        $dataValues[$testCurrentIndex] = null;
+                        ++$testCurrentIndex;
+                    }
+                    ++$testCurrentIndex;
+                }
+                if ($dimensions == '3d') {
+                    $seriesPlot = new PiePlot3D($dataValues);
+                } else {
+                    if ($doughnut) {
+                        $seriesPlot = new PiePlotC($dataValues);
+                    } else {
+                        $seriesPlot = new PiePlot($dataValues);
+                    }
+                }
+                if ($multiplePlots) {
+                    $seriesPlot->SetSize(($jLimit - $j) / ($jLimit * 4));
+                }
+                if ($doughnut && method_exists($seriesPlot, 'SetMidColor')) {
+                    $seriesPlot->SetMidColor('white');
+                }
+                $seriesPlot->SetColor(self::$colourSet[self::$plotColour++]);
+                if (count($datasetLabels) > 0) {
+                    $seriesPlot->SetLabels(array_fill(0, count($datasetLabels), ''));
+                }
+                if ($dimensions != '3d') {
+                    $seriesPlot->SetGuideLines(false);
+                }
+                if ($j == 0) {
+                    if ($exploded) {
+                        $seriesPlot->ExplodeAll();
+                    }
+                    $seriesPlot->SetLegends($datasetLabels);
+                }
+                $this->graph->Add($seriesPlot);
+            }
+        }
+    }
+    private function renderRadarChart($groupCount): void
+    {
+        $this->renderRadarPlotArea();
+        for ($groupID = 0; $groupID < $groupCount; ++$groupID) {
+            $this->renderPlotRadar($groupID);
+        }
+    }
+    private function renderStockChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea('intint');
+        for ($groupID = 0; $groupID < $groupCount; ++$groupID) {
+            $this->renderPlotStock($groupID);
+        }
+    }
+    private function renderContourChart($groupCount): void
+    {
+        $this->renderCartesianPlotArea('intint');
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $this->renderPlotContour($i);
+        }
+    }
+    private function renderCombinationChart($groupCount, $outputDestination): bool
+    {
+        $this->renderCartesianPlotArea();
+        for ($i = 0; $i < $groupCount; ++$i) {
+            $dimensions = null;
+            $chartType = $this->chart->getPlotArea()->getPlotGroupByIndex($i)->getPlotType();
+            switch ($chartType) {
+                case 'area3DChart':
+                case 'areaChart':
+                    $this->renderPlotLine($i, true, true);
+                    break;
+                case 'bar3DChart':
+                    $dimensions = '3d';
+                case 'barChart':
+                    $this->renderPlotBar($i, $dimensions);
+                    break;
+                case 'line3DChart':
+                case 'lineChart':
+                    $this->renderPlotLine($i, false, true);
+                    break;
+                case 'scatterChart':
+                    $this->renderPlotScatter($i, false);
+                    break;
+                case 'bubbleChart':
+                    $this->renderPlotScatter($i, true);
+                    break;
+                default:
+                    $this->graph = null;
+                    return false;
+            }
+        }
+        $this->renderLegend();
+        $this->graph->Stroke($outputDestination);
+        return true;
+    }
+    public function render(?string $outputDestination): bool
+    {
+        self::$plotColour = 0;
+        $groupCount = $this->chart->getPlotArea()->getPlotGroupCount();
+        $dimensions = null;
+        if ($groupCount == 1) {
+            $chartType = $this->chart->getPlotArea()->getPlotGroupByIndex(0)->getPlotType();
+        } else {
+            $chartTypes = [];
+            for ($i = 0; $i < $groupCount; ++$i) {
+                $chartTypes[] = $this->chart->getPlotArea()->getPlotGroupByIndex($i)->getPlotType();
+            }
+            $chartTypes = array_unique($chartTypes);
+            if (count($chartTypes) == 1) {
+                $chartType = array_pop($chartTypes);
+            } elseif (count($chartTypes) == 0) {
+                echo 'Chart is not yet implemented<br />';
+                return false;
+            } else {
+                return $this->renderCombinationChart($groupCount, $outputDestination);
+            }
+        }
+        switch ($chartType) {
+            case 'area3DChart':
+                $dimensions = '3d';
+            case 'areaChart':
+                $this->renderAreaChart($groupCount);
+                break;
+            case 'bar3DChart':
+                $dimensions = '3d';
+            case 'barChart':
+                $this->renderBarChart($groupCount, $dimensions);
+                break;
+            case 'line3DChart':
+                $dimensions = '3d';
+            case 'lineChart':
+                $this->renderLineChart($groupCount);
+                break;
+            case 'pie3DChart':
+                $dimensions = '3d';
+            case 'pieChart':
+                $this->renderPieChart($groupCount, $dimensions, false, false);
+                break;
+            case 'doughnut3DChart':
+                $dimensions = '3d';
+            case 'doughnutChart':
+                $this->renderPieChart($groupCount, $dimensions, true, true);
+                break;
+            case 'scatterChart':
+                $this->renderScatterChart($groupCount);
+                break;
+            case 'bubbleChart':
+                $this->renderBubbleChart($groupCount);
+                break;
+            case 'radarChart':
+                $this->renderRadarChart($groupCount);
+                break;
+            case 'surface3DChart':
+            case 'surfaceChart':
+                $this->renderContourChart($groupCount);
+                break;
+            case 'stockChart':
+                $this->renderStockChart($groupCount);
+                break;
+            default:
+                echo $chartType . ' is not yet implemented<br />';
+                return false;
+        }
+        $this->renderLegend();
+        $this->graph->Stroke($outputDestination);
+        return true;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Collection/Cells.php
@@ -0,0 +1,397 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Collection;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Settings;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use Psr\SimpleCache\CacheInterface;
+class Cells
+{
+    protected const MAX_COLUMN_ID = 16384;
+    private CacheInterface $cache;
+    /**
+     * Parent worksheet.
+     */
+    private ?Worksheet $parent;
+    /**
+     * The currently active Cell.
+     */
+    private ?Cell $currentCell = null;
+    /**
+     * Coordinate of the currently active Cell.
+     */
+    private ?string $currentCoordinate = null;
+    /**
+     * Flag indicating whether the currently active Cell requires saving.
+     */
+    private bool $currentCellIsDirty = false;
+    /**
+     * An index of existing cells. int pointer to the coordinate (0-base-indexed row * 16,384 + 1-base indexed column)
+     *    indexed by their coordinate.
+     *
+     * @var int[]
+     */
+    private array $index = [];
+    /**
+     * Prefix used to uniquely identify cache data for this worksheet.
+     */
+    private string $cachePrefix;
+    /**
+     * Initialise this new cell collection.
+     *
+     * @param Worksheet $parent The worksheet for this cell collection
+     */
+    public function __construct(Worksheet $parent, CacheInterface $cache)
+    {
+        $this->parent = $parent;
+        $this->cache = $cache;
+        $this->cachePrefix = $this->getUniqueID();
+    }
+    /**
+     * Return the parent worksheet for this cell collection.
+     */
+    public function getParent(): ?Worksheet
+    {
+        return $this->parent;
+    }
+    /**
+     * Whether the collection holds a cell for the given coordinate.
+     *
+     * @param string $cellCoordinate Coordinate of the cell to check
+     */
+    public function has(string $cellCoordinate): bool
+    {
+        return ($cellCoordinate === $this->currentCoordinate) || isset($this->index[$cellCoordinate]);
+    }
+    /**
+     * Add or update a cell in the collection.
+     *
+     * @param Cell $cell Cell to update
+     */
+    public function update(Cell $cell): Cell
+    {
+        return $this->add($cell->getCoordinate(), $cell);
+    }
+    /**
+     * Delete a cell in cache identified by coordinate.
+     *
+     * @param string $cellCoordinate Coordinate of the cell to delete
+     */
+    public function delete(string $cellCoordinate): void
+    {
+        if ($cellCoordinate === $this->currentCoordinate && $this->currentCell !== null) {
+            $this->currentCell->detach();
+            $this->currentCoordinate = null;
+            $this->currentCell = null;
+            $this->currentCellIsDirty = false;
+        }
+        unset($this->index[$cellCoordinate]);
+        $this->cache->delete($this->cachePrefix . $cellCoordinate);
+    }
+    /**
+     * Get a list of all cell coordinates currently held in the collection.
+     *
+     * @return string[]
+     */
+    public function getCoordinates(): array
+    {
+        return array_keys($this->index);
+    }
+    /**
+     * Get a sorted list of all cell coordinates currently held in the collection by row and column.
+     *
+     * @return string[]
+     */
+    public function getSortedCoordinates(): array
+    {
+        asort($this->index);
+        return array_keys($this->index);
+    }
+    /**
+     * Get a sorted list of all cell coordinates currently held in the collection by index (16384*row+column).
+     *
+     * @return int[]
+     */
+    public function getSortedCoordinatesInt(): array
+    {
+        asort($this->index);
+        return array_values($this->index);
+    }
+    /**
+     * Return the cell coordinate of the currently active cell object.
+     */
+    public function getCurrentCoordinate(): ?string
+    {
+        return $this->currentCoordinate;
+    }
+    /**
+     * Return the column coordinate of the currently active cell object.
+     */
+    public function getCurrentColumn(): string
+    {
+        $column = 0;
+        $row = '';
+        sscanf($this->currentCoordinate ?? '', '%[A-Z]%d', $column, $row);
+        return (string) $column;
+    }
+    /**
+     * Return the row coordinate of the currently active cell object.
+     */
+    public function getCurrentRow(): int
+    {
+        $column = 0;
+        $row = '';
+        sscanf($this->currentCoordinate ?? '', '%[A-Z]%d', $column, $row);
+        return (int) $row;
+    }
+    /**
+     * Get highest worksheet column and highest row that have cell records.
+     *
+     * @return array Highest column name and highest row number
+     */
+    public function getHighestRowAndColumn(): array
+    {
+        $maxRow = $maxColumn = 1;
+        foreach ($this->index as $coordinate) {
+            $row = (int) floor(($coordinate - 1) / self::MAX_COLUMN_ID) + 1;
+            $maxRow = ($maxRow > $row) ? $maxRow : $row;
+            $column = ($coordinate % self::MAX_COLUMN_ID) ?: self::MAX_COLUMN_ID;
+            $maxColumn = ($maxColumn > $column) ? $maxColumn : $column;
+        }
+        return [
+            'row' => $maxRow,
+            'column' => Coordinate::stringFromColumnIndex($maxColumn),
+        ];
+    }
+    /**
+     * Get highest worksheet column.
+     *
+     * @param null|int|string $row Return the highest column for the specified row,
+     *                    or the highest column of any row if no row number is passed
+     *
+     * @return string Highest column name
+     */
+    public function getHighestColumn($row = null): string
+    {
+        if ($row === null) {
+            return $this->getHighestRowAndColumn()['column'];
+        }
+        $row = (int) $row;
+        if ($row <= 0) {
+            throw new PhpSpreadsheetException('Row number must be a positive integer');
+        }
+        $maxColumn = 1;
+        $toRow = $row * self::MAX_COLUMN_ID;
+        $fromRow = --$row * self::MAX_COLUMN_ID;
+        foreach ($this->index as $coordinate) {
+            if ($coordinate < $fromRow || $coordinate >= $toRow) {
+                continue;
+            }
+            $column = ($coordinate % self::MAX_COLUMN_ID) ?: self::MAX_COLUMN_ID;
+            $maxColumn = $maxColumn > $column ? $maxColumn : $column;
+        }
+        return Coordinate::stringFromColumnIndex($maxColumn);
+    }
+    /**
+     * Get highest worksheet row.
+     *
+     * @param null|string $column Return the highest row for the specified column,
+     *                       or the highest row of any column if no column letter is passed
+     *
+     * @return int Highest row number
+     */
+    public function getHighestRow(?string $column = null): int
+    {
+        if ($column === null) {
+            return $this->getHighestRowAndColumn()['row'];
+        }
+        $maxRow = 1;
+        $columnIndex = Coordinate::columnIndexFromString($column);
+        foreach ($this->index as $coordinate) {
+            if ($coordinate % self::MAX_COLUMN_ID !== $columnIndex) {
+                continue;
+            }
+            $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
+            $maxRow = ($maxRow > $row) ? $maxRow : $row;
+        }
+        return $maxRow;
+    }
+    /**
+     * Generate a unique ID for cache referencing.
+     *
+     * @return string Unique Reference
+     */
+    private function getUniqueID(): string
+    {
+        $cacheType = Settings::getCache();
+        return ($cacheType instanceof Memory\SimpleCache1 || $cacheType instanceof Memory\SimpleCache3)
+            ? random_bytes(7) . ':'
+            : uniqid('phpspreadsheet.', true) . '.';
+    }
+    /**
+     * Clone the cell collection.
+     */
+    public function cloneCellCollection(Worksheet $worksheet): static
+    {
+        $this->storeCurrentCell();
+        $newCollection = clone $this;
+        $newCollection->parent = $worksheet;
+        $newCollection->cachePrefix = $newCollection->getUniqueID();
+        foreach ($this->index as $key => $value) {
+            $newCollection->index[$key] = $value;
+            $stored = $newCollection->cache->set(
+                $newCollection->cachePrefix . $key,
+                clone $this->getCache($key)
+            );
+            if ($stored === false) {
+                $this->destructIfNeeded($newCollection, 'Failed to copy cells in cache');
+            }
+        }
+        return $newCollection;
+    }
+    /**
+     * Remove a row, deleting all cells in that row.
+     *
+     * @param int|string $row Row number to remove
+     */
+    public function removeRow($row): void
+    {
+        $this->storeCurrentCell();
+        $row = (int) $row;
+        if ($row <= 0) {
+            throw new PhpSpreadsheetException('Row number must be a positive integer');
+        }
+        $toRow = $row * self::MAX_COLUMN_ID;
+        $fromRow = --$row * self::MAX_COLUMN_ID;
+        foreach ($this->index as $coordinate) {
+            if ($coordinate >= $fromRow && $coordinate < $toRow) {
+                $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
+                $column = Coordinate::stringFromColumnIndex($coordinate % self::MAX_COLUMN_ID);
+                $this->delete("{$column}{$row}");
+            }
+        }
+    }
+    /**
+     * Remove a column, deleting all cells in that column.
+     *
+     * @param string $column Column ID to remove
+     */
+    public function removeColumn(string $column): void
+    {
+        $this->storeCurrentCell();
+        $columnIndex = Coordinate::columnIndexFromString($column);
+        foreach ($this->index as $coordinate) {
+            if ($coordinate % self::MAX_COLUMN_ID === $columnIndex) {
+                $row = (int) floor($coordinate / self::MAX_COLUMN_ID) + 1;
+                $column = Coordinate::stringFromColumnIndex($coordinate % self::MAX_COLUMN_ID);
+                $this->delete("{$column}{$row}");
+            }
+        }
+    }
+    /**
+     * Store cell data in cache for the current cell object if it's "dirty",
+     * and the 'nullify' the current cell object.
+     */
+    private function storeCurrentCell(): void
+    {
+        if ($this->currentCellIsDirty && isset($this->currentCoordinate, $this->currentCell)) {
+            $this->currentCell->detach();
+            $stored = $this->cache->set($this->cachePrefix . $this->currentCoordinate, $this->currentCell);
+            if ($stored === false) {
+                $this->destructIfNeeded($this, "Failed to store cell {$this->currentCoordinate} in cache");
+            }
+            $this->currentCellIsDirty = false;
+        }
+        $this->currentCoordinate = null;
+        $this->currentCell = null;
+    }
+    private function destructIfNeeded(self $cells, string $message): void
+    {
+        $cells->__destruct();
+        throw new PhpSpreadsheetException($message);
+    }
+    /**
+     * Add or update a cell identified by its coordinate into the collection.
+     *
+     * @param string $cellCoordinate Coordinate of the cell to update
+     * @param Cell $cell Cell to update
+     */
+    public function add(string $cellCoordinate, Cell $cell): Cell
+    {
+        if ($cellCoordinate !== $this->currentCoordinate) {
+            $this->storeCurrentCell();
+        }
+        $column = 0;
+        $row = '';
+        sscanf($cellCoordinate, '%[A-Z]%d', $column, $row);
+        $this->index[$cellCoordinate] = (--$row * self::MAX_COLUMN_ID) + Coordinate::columnIndexFromString((string) $column);
+        $this->currentCoordinate = $cellCoordinate;
+        $this->currentCell = $cell;
+        $this->currentCellIsDirty = true;
+        return $cell;
+    }
+    /**
+     * Get cell at a specific coordinate.
+     *
+     * @param string $cellCoordinate Coordinate of the cell
+     *
+     * @return null|Cell Cell that was found, or null if not found
+     */
+    public function get(string $cellCoordinate): ?Cell
+    {
+        if ($cellCoordinate === $this->currentCoordinate) {
+            return $this->currentCell;
+        }
+        $this->storeCurrentCell();
+        if ($this->has($cellCoordinate) === false) {
+            return null;
+        }
+        $cell = $this->getcache($cellCoordinate);
+        $this->currentCoordinate = $cellCoordinate;
+        $this->currentCell = $cell;
+        $this->currentCell->attach($this);
+        return $this->currentCell;
+    }
+    /**
+     * Clear the cell collection and disconnect from our parent.
+     */
+    public function unsetWorksheetCells(): void
+    {
+        if ($this->currentCell !== null) {
+            $this->currentCell->detach();
+            $this->currentCell = null;
+            $this->currentCoordinate = null;
+        }
+        $this->__destruct();
+        $this->index = [];
+        $this->parent = null;
+    }
+    /**
+     * Destroy this cell collection.
+     */
+    public function __destruct()
+    {
+        $this->cache->deleteMultiple($this->getAllCacheKeys());
+        $this->parent = null;
+    }
+    /**
+     * Returns all known cache keys.
+     *
+     * @return iterable<string>
+     */
+    private function getAllCacheKeys(): iterable
+    {
+        foreach ($this->index as $coordinate => $value) {
+            yield $this->cachePrefix . $coordinate;
+        }
+    }
+    private function getCache(string $cellCoordinate): Cell
+    {
+        $cell = $this->cache->get($this->cachePrefix . $cellCoordinate);
+        if (!($cell instanceof Cell)) {
+            throw new PhpSpreadsheetException("Cell entry {$cellCoordinate} no longer exists in cache. This probably means that the cache was cleared by someone else.");
+        }
+        return $cell;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Comment.php
@@ -0,0 +1,300 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Helper\Size;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\Drawing as SharedDrawing;
+use PhpOffice\PhpSpreadsheet\Style\Alignment;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Worksheet\Drawing;
+use Stringable;
+class Comment implements IComparable, Stringable
+{
+    /**
+     * Author.
+     */
+    private string $author;
+    /**
+     * Rich text comment.
+     */
+    private RichText $text;
+    /**
+     * Comment width (CSS style, i.e. XXpx or YYpt).
+     */
+    private string $width = '96pt';
+    /**
+     * Left margin (CSS style, i.e. XXpx or YYpt).
+     */
+    private string $marginLeft = '59.25pt';
+    /**
+     * Top margin (CSS style, i.e. XXpx or YYpt).
+     */
+    private string $marginTop = '1.5pt';
+    /**
+     * Visible.
+     */
+    private bool $visible = false;
+    /**
+     * Comment height (CSS style, i.e. XXpx or YYpt).
+     */
+    private string $height = '55.5pt';
+    /**
+     * Comment fill color.
+     */
+    private Color $fillColor;
+    /**
+     * Alignment.
+     */
+    private string $alignment;
+    /**
+     * Background image in comment.
+     */
+    private Drawing $backgroundImage;
+    public const TEXTBOX_DIRECTION_RTL = 'rtl';
+    public const TEXTBOX_DIRECTION_LTR = 'ltr';
+    public const TEXTBOX_DIRECTION_AUTO = 'auto';
+    public const TEXTBOX_DIRECTION_CONTEXT = 'auto';
+    private string $textboxDirection = '';
+    /**
+     * Create a new Comment.
+     */
+    public function __construct()
+    {
+        $this->author = 'Author';
+        $this->text = new RichText();
+        $this->fillColor = new Color('FFFFFFE1');
+        $this->alignment = Alignment::HORIZONTAL_GENERAL;
+        $this->backgroundImage = new Drawing();
+    }
+    /**
+     * Get Author.
+     */
+    public function getAuthor(): string
+    {
+        return $this->author;
+    }
+    /**
+     * Set Author.
+     */
+    public function setAuthor(string $author): self
+    {
+        $this->author = $author;
+        return $this;
+    }
+    /**
+     * Get Rich text comment.
+     */
+    public function getText(): RichText
+    {
+        return $this->text;
+    }
+    /**
+     * Set Rich text comment.
+     */
+    public function setText(RichText $text): self
+    {
+        $this->text = $text;
+        return $this;
+    }
+    /**
+     * Get comment width (CSS style, i.e. XXpx or YYpt).
+     */
+    public function getWidth(): string
+    {
+        return $this->width;
+    }
+    /**
+     * Set comment width (CSS style, i.e. XXpx or YYpt). Default unit is pt.
+     */
+    public function setWidth(string $width): self
+    {
+        $width = new Size($width);
+        if ($width->valid()) {
+            $this->width = (string) $width;
+        }
+        return $this;
+    }
+    /**
+     * Get comment height (CSS style, i.e. XXpx or YYpt).
+     */
+    public function getHeight(): string
+    {
+        return $this->height;
+    }
+    /**
+     * Set comment height (CSS style, i.e. XXpx or YYpt). Default unit is pt.
+     */
+    public function setHeight(string $height): self
+    {
+        $height = new Size($height);
+        if ($height->valid()) {
+            $this->height = (string) $height;
+        }
+        return $this;
+    }
+    /**
+     * Get left margin (CSS style, i.e. XXpx or YYpt).
+     */
+    public function getMarginLeft(): string
+    {
+        return $this->marginLeft;
+    }
+    /**
+     * Set left margin (CSS style, i.e. XXpx or YYpt). Default unit is pt.
+     */
+    public function setMarginLeft(string $margin): self
+    {
+        $margin = new Size($margin);
+        if ($margin->valid()) {
+            $this->marginLeft = (string) $margin;
+        }
+        return $this;
+    }
+    /**
+     * Get top margin (CSS style, i.e. XXpx or YYpt).
+     */
+    public function getMarginTop(): string
+    {
+        return $this->marginTop;
+    }
+    /**
+     * Set top margin (CSS style, i.e. XXpx or YYpt). Default unit is pt.
+     */
+    public function setMarginTop(string $margin): self
+    {
+        $margin = new Size($margin);
+        if ($margin->valid()) {
+            $this->marginTop = (string) $margin;
+        }
+        return $this;
+    }
+    /**
+     * Is the comment visible by default?
+     */
+    public function getVisible(): bool
+    {
+        return $this->visible;
+    }
+    /**
+     * Set comment default visibility.
+     */
+    public function setVisible(bool $visibility): self
+    {
+        $this->visible = $visibility;
+        return $this;
+    }
+    /**
+     * Set fill color.
+     */
+    public function setFillColor(Color $color): self
+    {
+        $this->fillColor = $color;
+        return $this;
+    }
+    /**
+     * Get fill color.
+     */
+    public function getFillColor(): Color
+    {
+        return $this->fillColor;
+    }
+    public function setAlignment(string $alignment): self
+    {
+        $this->alignment = $alignment;
+        return $this;
+    }
+    public function getAlignment(): string
+    {
+        return $this->alignment;
+    }
+    public function setTextboxDirection(string $textboxDirection): self
+    {
+        $this->textboxDirection = $textboxDirection;
+        return $this;
+    }
+    public function getTextboxDirection(): string
+    {
+        return $this->textboxDirection;
+    }
+    /**
+     * Get hash code.
+     */
+    public function getHashCode(): string
+    {
+        return md5(
+            $this->author
+            . $this->text->getHashCode()
+            . $this->width
+            . $this->height
+            . $this->marginLeft
+            . $this->marginTop
+            . ($this->visible ? 1 : 0)
+            . $this->fillColor->getHashCode()
+            . $this->alignment
+            . $this->textboxDirection
+            . ($this->hasBackgroundImage() ? $this->backgroundImage->getHashCode() : '')
+            . __CLASS__
+        );
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $vars = get_object_vars($this);
+        foreach ($vars as $key => $value) {
+            if (is_object($value)) {
+                $this->$key = clone $value;
+            } else {
+                $this->$key = $value;
+            }
+        }
+    }
+    /**
+     * Convert to string.
+     */
+    public function __toString(): string
+    {
+        return $this->text->getPlainText();
+    }
+    /**
+     * Check is background image exists.
+     */
+    public function hasBackgroundImage(): bool
+    {
+        $path = $this->backgroundImage->getPath();
+        if (empty($path)) {
+            return false;
+        }
+        return getimagesize($path) !== false;
+    }
+    /**
+     * Returns background image.
+     */
+    public function getBackgroundImage(): Drawing
+    {
+        return $this->backgroundImage;
+    }
+    /**
+     * Sets background image.
+     */
+    public function setBackgroundImage(Drawing $objDrawing): self
+    {
+        if (!array_key_exists($objDrawing->getType(), Drawing::IMAGE_TYPES_CONVERTION_MAP)) {
+            throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
+        }
+        $this->backgroundImage = $objDrawing;
+        return $this;
+    }
+    /**
+     * Sets size of comment as size of background image.
+     */
+    public function setSizeAsBackgroundImage(): self
+    {
+        if ($this->hasBackgroundImage()) {
+            $this->setWidth(SharedDrawing::pixelsToPoints($this->backgroundImage->getWidth()) . 'pt');
+            $this->setHeight(SharedDrawing::pixelsToPoints($this->backgroundImage->getHeight()) . 'pt');
+        }
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Helper/Html.php
@@ -0,0 +1,798 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Helper;
+use DOMAttr;
+use DOMDocument;
+use DOMElement;
+use DOMNode;
+use DOMText;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\Font;
+class Html
+{
+    private const COLOUR_MAP = [
+        'aliceblue' => 'f0f8ff',
+        'antiquewhite' => 'faebd7',
+        'antiquewhite1' => 'ffefdb',
+        'antiquewhite2' => 'eedfcc',
+        'antiquewhite3' => 'cdc0b0',
+        'antiquewhite4' => '8b8378',
+        'aqua' => '00ffff',
+        'aquamarine1' => '7fffd4',
+        'aquamarine2' => '76eec6',
+        'aquamarine4' => '458b74',
+        'azure1' => 'f0ffff',
+        'azure2' => 'e0eeee',
+        'azure3' => 'c1cdcd',
+        'azure4' => '838b8b',
+        'beige' => 'f5f5dc',
+        'bisque1' => 'ffe4c4',
+        'bisque2' => 'eed5b7',
+        'bisque3' => 'cdb79e',
+        'bisque4' => '8b7d6b',
+        'black' => '000000',
+        'blanchedalmond' => 'ffebcd',
+        'blue' => '0000ff',
+        'blue1' => '0000ff',
+        'blue2' => '0000ee',
+        'blue4' => '00008b',
+        'blueviolet' => '8a2be2',
+        'brown' => 'a52a2a',
+        'brown1' => 'ff4040',
+        'brown2' => 'ee3b3b',
+        'brown3' => 'cd3333',
+        'brown4' => '8b2323',
+        'burlywood' => 'deb887',
+        'burlywood1' => 'ffd39b',
+        'burlywood2' => 'eec591',
+        'burlywood3' => 'cdaa7d',
+        'burlywood4' => '8b7355',
+        'cadetblue' => '5f9ea0',
+        'cadetblue1' => '98f5ff',
+        'cadetblue2' => '8ee5ee',
+        'cadetblue3' => '7ac5cd',
+        'cadetblue4' => '53868b',
+        'chartreuse1' => '7fff00',
+        'chartreuse2' => '76ee00',
+        'chartreuse3' => '66cd00',
+        'chartreuse4' => '458b00',
+        'chocolate' => 'd2691e',
+        'chocolate1' => 'ff7f24',
+        'chocolate2' => 'ee7621',
+        'chocolate3' => 'cd661d',
+        'coral' => 'ff7f50',
+        'coral1' => 'ff7256',
+        'coral2' => 'ee6a50',
+        'coral3' => 'cd5b45',
+        'coral4' => '8b3e2f',
+        'cornflowerblue' => '6495ed',
+        'cornsilk1' => 'fff8dc',
+        'cornsilk2' => 'eee8cd',
+        'cornsilk3' => 'cdc8b1',
+        'cornsilk4' => '8b8878',
+        'cyan1' => '00ffff',
+        'cyan2' => '00eeee',
+        'cyan3' => '00cdcd',
+        'cyan4' => '008b8b',
+        'darkgoldenrod' => 'b8860b',
+        'darkgoldenrod1' => 'ffb90f',
+        'darkgoldenrod2' => 'eead0e',
+        'darkgoldenrod3' => 'cd950c',
+        'darkgoldenrod4' => '8b6508',
+        'darkgreen' => '006400',
+        'darkkhaki' => 'bdb76b',
+        'darkolivegreen' => '556b2f',
+        'darkolivegreen1' => 'caff70',
+        'darkolivegreen2' => 'bcee68',
+        'darkolivegreen3' => 'a2cd5a',
+        'darkolivegreen4' => '6e8b3d',
+        'darkorange' => 'ff8c00',
+        'darkorange1' => 'ff7f00',
+        'darkorange2' => 'ee7600',
+        'darkorange3' => 'cd6600',
+        'darkorange4' => '8b4500',
+        'darkorchid' => '9932cc',
+        'darkorchid1' => 'bf3eff',
+        'darkorchid2' => 'b23aee',
+        'darkorchid3' => '9a32cd',
+        'darkorchid4' => '68228b',
+        'darksalmon' => 'e9967a',
+        'darkseagreen' => '8fbc8f',
+        'darkseagreen1' => 'c1ffc1',
+        'darkseagreen2' => 'b4eeb4',
+        'darkseagreen3' => '9bcd9b',
+        'darkseagreen4' => '698b69',
+        'darkslateblue' => '483d8b',
+        'darkslategray' => '2f4f4f',
+        'darkslategray1' => '97ffff',
+        'darkslategray2' => '8deeee',
+        'darkslategray3' => '79cdcd',
+        'darkslategray4' => '528b8b',
+        'darkturquoise' => '00ced1',
+        'darkviolet' => '9400d3',
+        'deeppink1' => 'ff1493',
+        'deeppink2' => 'ee1289',
+        'deeppink3' => 'cd1076',
+        'deeppink4' => '8b0a50',
+        'deepskyblue1' => '00bfff',
+        'deepskyblue2' => '00b2ee',
+        'deepskyblue3' => '009acd',
+        'deepskyblue4' => '00688b',
+        'dimgray' => '696969',
+        'dodgerblue1' => '1e90ff',
+        'dodgerblue2' => '1c86ee',
+        'dodgerblue3' => '1874cd',
+        'dodgerblue4' => '104e8b',
+        'firebrick' => 'b22222',
+        'firebrick1' => 'ff3030',
+        'firebrick2' => 'ee2c2c',
+        'firebrick3' => 'cd2626',
+        'firebrick4' => '8b1a1a',
+        'floralwhite' => 'fffaf0',
+        'forestgreen' => '228b22',
+        'fuchsia' => 'ff00ff',
+        'gainsboro' => 'dcdcdc',
+        'ghostwhite' => 'f8f8ff',
+        'gold1' => 'ffd700',
+        'gold2' => 'eec900',
+        'gold3' => 'cdad00',
+        'gold4' => '8b7500',
+        'goldenrod' => 'daa520',
+        'goldenrod1' => 'ffc125',
+        'goldenrod2' => 'eeb422',
+        'goldenrod3' => 'cd9b1d',
+        'goldenrod4' => '8b6914',
+        'gray' => 'bebebe',
+        'gray1' => '030303',
+        'gray10' => '1a1a1a',
+        'gray11' => '1c1c1c',
+        'gray12' => '1f1f1f',
+        'gray13' => '212121',
+        'gray14' => '242424',
+        'gray15' => '262626',
+        'gray16' => '292929',
+        'gray17' => '2b2b2b',
+        'gray18' => '2e2e2e',
+        'gray19' => '303030',
+        'gray2' => '050505',
+        'gray20' => '333333',
+        'gray21' => '363636',
+        'gray22' => '383838',
+        'gray23' => '3b3b3b',
+        'gray24' => '3d3d3d',
+        'gray25' => '404040',
+        'gray26' => '424242',
+        'gray27' => '454545',
+        'gray28' => '474747',
+        'gray29' => '4a4a4a',
+        'gray3' => '080808',
+        'gray30' => '4d4d4d',
+        'gray31' => '4f4f4f',
+        'gray32' => '525252',
+        'gray33' => '545454',
+        'gray34' => '575757',
+        'gray35' => '595959',
+        'gray36' => '5c5c5c',
+        'gray37' => '5e5e5e',
+        'gray38' => '616161',
+        'gray39' => '636363',
+        'gray4' => '0a0a0a',
+        'gray40' => '666666',
+        'gray41' => '696969',
+        'gray42' => '6b6b6b',
+        'gray43' => '6e6e6e',
+        'gray44' => '707070',
+        'gray45' => '737373',
+        'gray46' => '757575',
+        'gray47' => '787878',
+        'gray48' => '7a7a7a',
+        'gray49' => '7d7d7d',
+        'gray5' => '0d0d0d',
+        'gray50' => '7f7f7f',
+        'gray51' => '828282',
+        'gray52' => '858585',
+        'gray53' => '878787',
+        'gray54' => '8a8a8a',
+        'gray55' => '8c8c8c',
+        'gray56' => '8f8f8f',
+        'gray57' => '919191',
+        'gray58' => '949494',
+        'gray59' => '969696',
+        'gray6' => '0f0f0f',
+        'gray60' => '999999',
+        'gray61' => '9c9c9c',
+        'gray62' => '9e9e9e',
+        'gray63' => 'a1a1a1',
+        'gray64' => 'a3a3a3',
+        'gray65' => 'a6a6a6',
+        'gray66' => 'a8a8a8',
+        'gray67' => 'ababab',
+        'gray68' => 'adadad',
+        'gray69' => 'b0b0b0',
+        'gray7' => '121212',
+        'gray70' => 'b3b3b3',
+        'gray71' => 'b5b5b5',
+        'gray72' => 'b8b8b8',
+        'gray73' => 'bababa',
+        'gray74' => 'bdbdbd',
+        'gray75' => 'bfbfbf',
+        'gray76' => 'c2c2c2',
+        'gray77' => 'c4c4c4',
+        'gray78' => 'c7c7c7',
+        'gray79' => 'c9c9c9',
+        'gray8' => '141414',
+        'gray80' => 'cccccc',
+        'gray81' => 'cfcfcf',
+        'gray82' => 'd1d1d1',
+        'gray83' => 'd4d4d4',
+        'gray84' => 'd6d6d6',
+        'gray85' => 'd9d9d9',
+        'gray86' => 'dbdbdb',
+        'gray87' => 'dedede',
+        'gray88' => 'e0e0e0',
+        'gray89' => 'e3e3e3',
+        'gray9' => '171717',
+        'gray90' => 'e5e5e5',
+        'gray91' => 'e8e8e8',
+        'gray92' => 'ebebeb',
+        'gray93' => 'ededed',
+        'gray94' => 'f0f0f0',
+        'gray95' => 'f2f2f2',
+        'gray97' => 'f7f7f7',
+        'gray98' => 'fafafa',
+        'gray99' => 'fcfcfc',
+        'green' => '00ff00',
+        'green1' => '00ff00',
+        'green2' => '00ee00',
+        'green3' => '00cd00',
+        'green4' => '008b00',
+        'greenyellow' => 'adff2f',
+        'honeydew1' => 'f0fff0',
+        'honeydew2' => 'e0eee0',
+        'honeydew3' => 'c1cdc1',
+        'honeydew4' => '838b83',
+        'hotpink' => 'ff69b4',
+        'hotpink1' => 'ff6eb4',
+        'hotpink2' => 'ee6aa7',
+        'hotpink3' => 'cd6090',
+        'hotpink4' => '8b3a62',
+        'indianred' => 'cd5c5c',
+        'indianred1' => 'ff6a6a',
+        'indianred2' => 'ee6363',
+        'indianred3' => 'cd5555',
+        'indianred4' => '8b3a3a',
+        'ivory1' => 'fffff0',
+        'ivory2' => 'eeeee0',
+        'ivory3' => 'cdcdc1',
+        'ivory4' => '8b8b83',
+        'khaki' => 'f0e68c',
+        'khaki1' => 'fff68f',
+        'khaki2' => 'eee685',
+        'khaki3' => 'cdc673',
+        'khaki4' => '8b864e',
+        'lavender' => 'e6e6fa',
+        'lavenderblush1' => 'fff0f5',
+        'lavenderblush2' => 'eee0e5',
+        'lavenderblush3' => 'cdc1c5',
+        'lavenderblush4' => '8b8386',
+        'lawngreen' => '7cfc00',
+        'lemonchiffon1' => 'fffacd',
+        'lemonchiffon2' => 'eee9bf',
+        'lemonchiffon3' => 'cdc9a5',
+        'lemonchiffon4' => '8b8970',
+        'light' => 'eedd82',
+        'lightblue' => 'add8e6',
+        'lightblue1' => 'bfefff',
+        'lightblue2' => 'b2dfee',
+        'lightblue3' => '9ac0cd',
+        'lightblue4' => '68838b',
+        'lightcoral' => 'f08080',
+        'lightcyan1' => 'e0ffff',
+        'lightcyan2' => 'd1eeee',
+        'lightcyan3' => 'b4cdcd',
+        'lightcyan4' => '7a8b8b',
+        'lightgoldenrod1' => 'ffec8b',
+        'lightgoldenrod2' => 'eedc82',
+        'lightgoldenrod3' => 'cdbe70',
+        'lightgoldenrod4' => '8b814c',
+        'lightgoldenrodyellow' => 'fafad2',
+        'lightgray' => 'd3d3d3',
+        'lightpink' => 'ffb6c1',
+        'lightpink1' => 'ffaeb9',
+        'lightpink2' => 'eea2ad',
+        'lightpink3' => 'cd8c95',
+        'lightpink4' => '8b5f65',
+        'lightsalmon1' => 'ffa07a',
+        'lightsalmon2' => 'ee9572',
+        'lightsalmon3' => 'cd8162',
+        'lightsalmon4' => '8b5742',
+        'lightseagreen' => '20b2aa',
+        'lightskyblue' => '87cefa',
+        'lightskyblue1' => 'b0e2ff',
+        'lightskyblue2' => 'a4d3ee',
+        'lightskyblue3' => '8db6cd',
+        'lightskyblue4' => '607b8b',
+        'lightslateblue' => '8470ff',
+        'lightslategray' => '778899',
+        'lightsteelblue' => 'b0c4de',
+        'lightsteelblue1' => 'cae1ff',
+        'lightsteelblue2' => 'bcd2ee',
+        'lightsteelblue3' => 'a2b5cd',
+        'lightsteelblue4' => '6e7b8b',
+        'lightyellow1' => 'ffffe0',
+        'lightyellow2' => 'eeeed1',
+        'lightyellow3' => 'cdcdb4',
+        'lightyellow4' => '8b8b7a',
+        'lime' => '00ff00',
+        'limegreen' => '32cd32',
+        'linen' => 'faf0e6',
+        'magenta' => 'ff00ff',
+        'magenta2' => 'ee00ee',
+        'magenta3' => 'cd00cd',
+        'magenta4' => '8b008b',
+        'maroon' => 'b03060',
+        'maroon1' => 'ff34b3',
+        'maroon2' => 'ee30a7',
+        'maroon3' => 'cd2990',
+        'maroon4' => '8b1c62',
+        'medium' => '66cdaa',
+        'mediumaquamarine' => '66cdaa',
+        'mediumblue' => '0000cd',
+        'mediumorchid' => 'ba55d3',
+        'mediumorchid1' => 'e066ff',
+        'mediumorchid2' => 'd15fee',
+        'mediumorchid3' => 'b452cd',
+        'mediumorchid4' => '7a378b',
+        'mediumpurple' => '9370db',
+        'mediumpurple1' => 'ab82ff',
+        'mediumpurple2' => '9f79ee',
+        'mediumpurple3' => '8968cd',
+        'mediumpurple4' => '5d478b',
+        'mediumseagreen' => '3cb371',
+        'mediumslateblue' => '7b68ee',
+        'mediumspringgreen' => '00fa9a',
+        'mediumturquoise' => '48d1cc',
+        'mediumvioletred' => 'c71585',
+        'midnightblue' => '191970',
+        'mintcream' => 'f5fffa',
+        'mistyrose1' => 'ffe4e1',
+        'mistyrose2' => 'eed5d2',
+        'mistyrose3' => 'cdb7b5',
+        'mistyrose4' => '8b7d7b',
+        'moccasin' => 'ffe4b5',
+        'navajowhite1' => 'ffdead',
+        'navajowhite2' => 'eecfa1',
+        'navajowhite3' => 'cdb38b',
+        'navajowhite4' => '8b795e',
+        'navy' => '000080',
+        'navyblue' => '000080',
+        'oldlace' => 'fdf5e6',
+        'olive' => '808000',
+        'olivedrab' => '6b8e23',
+        'olivedrab1' => 'c0ff3e',
+        'olivedrab2' => 'b3ee3a',
+        'olivedrab4' => '698b22',
+        'orange' => 'ffa500',
+        'orange1' => 'ffa500',
+        'orange2' => 'ee9a00',
+        'orange3' => 'cd8500',
+        'orange4' => '8b5a00',
+        'orangered1' => 'ff4500',
+        'orangered2' => 'ee4000',
+        'orangered3' => 'cd3700',
+        'orangered4' => '8b2500',
+        'orchid' => 'da70d6',
+        'orchid1' => 'ff83fa',
+        'orchid2' => 'ee7ae9',
+        'orchid3' => 'cd69c9',
+        'orchid4' => '8b4789',
+        'pale' => 'db7093',
+        'palegoldenrod' => 'eee8aa',
+        'palegreen' => '98fb98',
+        'palegreen1' => '9aff9a',
+        'palegreen2' => '90ee90',
+        'palegreen3' => '7ccd7c',
+        'palegreen4' => '548b54',
+        'paleturquoise' => 'afeeee',
+        'paleturquoise1' => 'bbffff',
+        'paleturquoise2' => 'aeeeee',
+        'paleturquoise3' => '96cdcd',
+        'paleturquoise4' => '668b8b',
+        'palevioletred' => 'db7093',
+        'palevioletred1' => 'ff82ab',
+        'palevioletred2' => 'ee799f',
+        'palevioletred3' => 'cd6889',
+        'palevioletred4' => '8b475d',
+        'papayawhip' => 'ffefd5',
+        'peachpuff1' => 'ffdab9',
+        'peachpuff2' => 'eecbad',
+        'peachpuff3' => 'cdaf95',
+        'peachpuff4' => '8b7765',
+        'pink' => 'ffc0cb',
+        'pink1' => 'ffb5c5',
+        'pink2' => 'eea9b8',
+        'pink3' => 'cd919e',
+        'pink4' => '8b636c',
+        'plum' => 'dda0dd',
+        'plum1' => 'ffbbff',
+        'plum2' => 'eeaeee',
+        'plum3' => 'cd96cd',
+        'plum4' => '8b668b',
+        'powderblue' => 'b0e0e6',
+        'purple' => 'a020f0',
+        'rebeccapurple' => '663399',
+        'purple1' => '9b30ff',
+        'purple2' => '912cee',
+        'purple3' => '7d26cd',
+        'purple4' => '551a8b',
+        'red' => 'ff0000',
+        'red1' => 'ff0000',
+        'red2' => 'ee0000',
+        'red3' => 'cd0000',
+        'red4' => '8b0000',
+        'rosybrown' => 'bc8f8f',
+        'rosybrown1' => 'ffc1c1',
+        'rosybrown2' => 'eeb4b4',
+        'rosybrown3' => 'cd9b9b',
+        'rosybrown4' => '8b6969',
+        'royalblue' => '4169e1',
+        'royalblue1' => '4876ff',
+        'royalblue2' => '436eee',
+        'royalblue3' => '3a5fcd',
+        'royalblue4' => '27408b',
+        'saddlebrown' => '8b4513',
+        'salmon' => 'fa8072',
+        'salmon1' => 'ff8c69',
+        'salmon2' => 'ee8262',
+        'salmon3' => 'cd7054',
+        'salmon4' => '8b4c39',
+        'sandybrown' => 'f4a460',
+        'seagreen1' => '54ff9f',
+        'seagreen2' => '4eee94',
+        'seagreen3' => '43cd80',
+        'seagreen4' => '2e8b57',
+        'seashell1' => 'fff5ee',
+        'seashell2' => 'eee5de',
+        'seashell3' => 'cdc5bf',
+        'seashell4' => '8b8682',
+        'sienna' => 'a0522d',
+        'sienna1' => 'ff8247',
+        'sienna2' => 'ee7942',
+        'sienna3' => 'cd6839',
+        'sienna4' => '8b4726',
+        'silver' => 'c0c0c0',
+        'skyblue' => '87ceeb',
+        'skyblue1' => '87ceff',
+        'skyblue2' => '7ec0ee',
+        'skyblue3' => '6ca6cd',
+        'skyblue4' => '4a708b',
+        'slateblue' => '6a5acd',
+        'slateblue1' => '836fff',
+        'slateblue2' => '7a67ee',
+        'slateblue3' => '6959cd',
+        'slateblue4' => '473c8b',
+        'slategray' => '708090',
+        'slategray1' => 'c6e2ff',
+        'slategray2' => 'b9d3ee',
+        'slategray3' => '9fb6cd',
+        'slategray4' => '6c7b8b',
+        'snow1' => 'fffafa',
+        'snow2' => 'eee9e9',
+        'snow3' => 'cdc9c9',
+        'snow4' => '8b8989',
+        'springgreen1' => '00ff7f',
+        'springgreen2' => '00ee76',
+        'springgreen3' => '00cd66',
+        'springgreen4' => '008b45',
+        'steelblue' => '4682b4',
+        'steelblue1' => '63b8ff',
+        'steelblue2' => '5cacee',
+        'steelblue3' => '4f94cd',
+        'steelblue4' => '36648b',
+        'tan' => 'd2b48c',
+        'tan1' => 'ffa54f',
+        'tan2' => 'ee9a49',
+        'tan3' => 'cd853f',
+        'tan4' => '8b5a2b',
+        'teal' => '008080',
+        'thistle' => 'd8bfd8',
+        'thistle1' => 'ffe1ff',
+        'thistle2' => 'eed2ee',
+        'thistle3' => 'cdb5cd',
+        'thistle4' => '8b7b8b',
+        'tomato1' => 'ff6347',
+        'tomato2' => 'ee5c42',
+        'tomato3' => 'cd4f39',
+        'tomato4' => '8b3626',
+        'turquoise' => '40e0d0',
+        'turquoise1' => '00f5ff',
+        'turquoise2' => '00e5ee',
+        'turquoise3' => '00c5cd',
+        'turquoise4' => '00868b',
+        'violet' => 'ee82ee',
+        'violetred' => 'd02090',
+        'violetred1' => 'ff3e96',
+        'violetred2' => 'ee3a8c',
+        'violetred3' => 'cd3278',
+        'violetred4' => '8b2252',
+        'wheat' => 'f5deb3',
+        'wheat1' => 'ffe7ba',
+        'wheat2' => 'eed8ae',
+        'wheat3' => 'cdba96',
+        'wheat4' => '8b7e66',
+        'white' => 'ffffff',
+        'whitesmoke' => 'f5f5f5',
+        'yellow' => 'ffff00',
+        'yellow1' => 'ffff00',
+        'yellow2' => 'eeee00',
+        'yellow3' => 'cdcd00',
+        'yellow4' => '8b8b00',
+        'yellowgreen' => '9acd32',
+    ];
+    /** @var ?string */
+    private ?string $face = null;
+    /** @var ?string */
+    private ?string $size = null;
+    /** @var ?string */
+    private ?string $color = null;
+    private bool $bold = false;
+    private bool $italic = false;
+    private bool $underline = false;
+    private bool $superscript = false;
+    private bool $subscript = false;
+    private bool $strikethrough = false;
+    /** @var callable[] */
+    private array $startTagCallbacks = [
+        'font' => [self::class, 'startFontTag'],
+        'b' => [self::class, 'startBoldTag'],
+        'strong' => [self::class, 'startBoldTag'],
+        'i' => [self::class, 'startItalicTag'],
+        'em' => [self::class, 'startItalicTag'],
+        'u' => [self::class, 'startUnderlineTag'],
+        'ins' => [self::class, 'startUnderlineTag'],
+        'del' => [self::class, 'startStrikethruTag'],
+        'sup' => [self::class, 'startSuperscriptTag'],
+        'sub' => [self::class, 'startSubscriptTag'],
+    ];
+    /** @var callable[] */
+    private array $endTagCallbacks = [
+        'font' => [self::class, 'endFontTag'],
+        'b' => [self::class, 'endBoldTag'],
+        'strong' => [self::class, 'endBoldTag'],
+        'i' => [self::class, 'endItalicTag'],
+        'em' => [self::class, 'endItalicTag'],
+        'u' => [self::class, 'endUnderlineTag'],
+        'ins' => [self::class, 'endUnderlineTag'],
+        'del' => [self::class, 'endStrikethruTag'],
+        'sup' => [self::class, 'endSuperscriptTag'],
+        'sub' => [self::class, 'endSubscriptTag'],
+        'br' => [self::class, 'breakTag'],
+        'p' => [self::class, 'breakTag'],
+        'h1' => [self::class, 'breakTag'],
+        'h2' => [self::class, 'breakTag'],
+        'h3' => [self::class, 'breakTag'],
+        'h4' => [self::class, 'breakTag'],
+        'h5' => [self::class, 'breakTag'],
+        'h6' => [self::class, 'breakTag'],
+    ];
+    private array $stack = [];
+    public string $stringData = '';
+    private RichText $richTextObject;
+    private bool $preserveWhiteSpace = false;
+    private function initialise(): void
+    {
+        $this->face = $this->size = $this->color = null;
+        $this->bold = $this->italic = $this->underline = $this->superscript = $this->subscript = $this->strikethrough = false;
+        $this->stack = [];
+        $this->stringData = '';
+    }
+    /**
+     * Parse HTML formatting and return the resulting RichText.
+     */
+    public function toRichTextObject(string $html, bool $preserveWhiteSpace = false): RichText
+    {
+        $this->initialise();
+        $dom = new DOMDocument();
+        $prefix = '<?xml encoding="UTF-8">';
+        @$dom->loadHTML($prefix . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
+        $dom->preserveWhiteSpace = false;
+        $this->richTextObject = new RichText();
+        $this->preserveWhiteSpace = $preserveWhiteSpace;
+        $this->parseElements($dom);
+        $this->preserveWhiteSpace = false;
+        $this->cleanWhitespace();
+        return $this->richTextObject;
+    }
+    private function cleanWhitespace(): void
+    {
+        foreach ($this->richTextObject->getRichTextElements() as $key => $element) {
+            $text = $element->getText();
+            if ($key == 0) {
+                $text = ltrim($text);
+            }
+            $text = (string) preg_replace('/\n */mu', "\n", $text);
+            $element->setText($text);
+        }
+    }
+    private function buildTextRun(): void
+    {
+        $text = $this->stringData;
+        if (trim($text) === '') {
+            return;
+        }
+        $richtextRun = $this->richTextObject->createTextRun($this->stringData);
+        $font = $richtextRun->getFont();
+        if ($font !== null) {
+            if ($this->face) {
+                $font->setName($this->face);
+            }
+            if ($this->size) {
+                $font->setSize($this->size);
+            }
+            if ($this->color) {
+                $font->setColor(new Color('ff' . $this->color));
+            }
+            if ($this->bold) {
+                $font->setBold(true);
+            }
+            if ($this->italic) {
+                $font->setItalic(true);
+            }
+            if ($this->underline) {
+                $font->setUnderline(Font::UNDERLINE_SINGLE);
+            }
+            if ($this->superscript) {
+                $font->setSuperscript(true);
+            }
+            if ($this->subscript) {
+                $font->setSubscript(true);
+            }
+            if ($this->strikethrough) {
+                $font->setStrikethrough(true);
+            }
+        }
+        $this->stringData = '';
+    }
+    private function rgbToColour(string $rgbValue): string
+    {
+        preg_match_all('/\d+/', $rgbValue, $values);
+        foreach ($values[0] as &$value) {
+            $value = str_pad(dechex((int) $value), 2, '0', STR_PAD_LEFT);
+        }
+        return implode('', $values[0]);
+    }
+    public static function colourNameLookup(string $colorName): string
+    {
+        return self::COLOUR_MAP[$colorName] ?? '';
+    }
+    protected function startFontTag(DOMElement $tag): void
+    {
+        $attrs = $tag->attributes;
+        if ($attrs !== null) {
+            /** @var DOMAttr $attribute */
+            foreach ($attrs as $attribute) {
+                $attributeName = strtolower($attribute->name);
+                $attributeName = preg_replace('/^html:/', '', $attributeName) ?? $attributeName; // in case from Xml spreadsheet
+                $attributeValue = $attribute->value;
+                if ($attributeName == 'color') {
+                    if (preg_match('/rgb\s*\(/', $attributeValue)) {
+                        $this->$attributeName = $this->rgbToColour($attributeValue);
+                    } elseif (str_starts_with(trim($attributeValue), '#')) {
+                        $this->$attributeName = ltrim($attributeValue, '#');
+                    } else {
+                        $this->$attributeName = static::colourNameLookup($attributeValue);
+                    }
+                } else {
+                    $this->$attributeName = $attributeValue;
+                }
+            }
+        }
+    }
+    protected function endFontTag(): void
+    {
+        $this->face = $this->size = $this->color = null;
+    }
+    protected function startBoldTag(): void
+    {
+        $this->bold = true;
+    }
+    protected function endBoldTag(): void
+    {
+        $this->bold = false;
+    }
+    protected function startItalicTag(): void
+    {
+        $this->italic = true;
+    }
+    protected function endItalicTag(): void
+    {
+        $this->italic = false;
+    }
+    protected function startUnderlineTag(): void
+    {
+        $this->underline = true;
+    }
+    protected function endUnderlineTag(): void
+    {
+        $this->underline = false;
+    }
+    protected function startSubscriptTag(): void
+    {
+        $this->subscript = true;
+    }
+    protected function endSubscriptTag(): void
+    {
+        $this->subscript = false;
+    }
+    protected function startSuperscriptTag(): void
+    {
+        $this->superscript = true;
+    }
+    protected function endSuperscriptTag(): void
+    {
+        $this->superscript = false;
+    }
+    protected function startStrikethruTag(): void
+    {
+        $this->strikethrough = true;
+    }
+    protected function endStrikethruTag(): void
+    {
+        $this->strikethrough = false;
+    }
+    public function breakTag(): void
+    {
+        $this->stringData .= "\n";
+    }
+    private function parseTextNode(DOMText $textNode): void
+    {
+        if ($this->preserveWhiteSpace) {
+            $domText = $textNode->nodeValue ?? '';
+        } else {
+            $domText = (string) preg_replace(
+                '/\s+/u',
+                ' ',
+                str_replace(["\r", "\n"], ' ', $textNode->nodeValue ?? '')
+            );
+        }
+        $this->stringData .= $domText;
+        $this->buildTextRun();
+    }
+    public function addStartTagCallback(string $tag, callable $callback): void
+    {
+        $this->startTagCallbacks[$tag] = $callback;
+    }
+    public function addEndTagCallback(string $tag, callable $callback): void
+    {
+        $this->endTagCallbacks[$tag] = $callback;
+    }
+    /** @param callable[] $callbacks */
+    private function handleCallback(DOMElement $element, string $callbackTag, array $callbacks): void
+    {
+        if (isset($callbacks[$callbackTag])) {
+            $elementHandler = $callbacks[$callbackTag];
+            if (is_callable($elementHandler)) {
+                call_user_func($elementHandler, $element, $this);
+            }
+        }
+    }
+    private function parseElementNode(DOMElement $element): void
+    {
+        $callbackTag = strtolower($element->nodeName);
+        $this->stack[] = $callbackTag;
+        $this->handleCallback($element, $callbackTag, $this->startTagCallbacks);
+        $this->parseElements($element);
+        array_pop($this->stack);
+        $this->handleCallback($element, $callbackTag, $this->endTagCallbacks);
+    }
+    private function parseElements(DOMNode $element): void
+    {
+        foreach ($element->childNodes as $child) {
+            if ($child instanceof DOMText) {
+                $this->parseTextNode($child);
+            } elseif ($child instanceof DOMElement) {
+                $this->parseElementNode($child);
+            }
+        }
+    }
+}

--- a/src/PhpSpreadsheet/Helper/Sample.php
+++ b/src/PhpSpreadsheet/Helper/Sample.php
@@ -1,20 +1,19 @@
 <?php
 namespace PhpOffice\PhpSpreadsheet\Helper;
 use PhpOffice\PhpSpreadsheet\Chart\Chart;
 use PhpOffice\PhpSpreadsheet\Chart\Renderer\MtJpGraphRenderer;
 use PhpOffice\PhpSpreadsheet\IOFactory;
 use PhpOffice\PhpSpreadsheet\Settings;
 use PhpOffice\PhpSpreadsheet\Spreadsheet;
 use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
 use PhpOffice\PhpSpreadsheet\Writer\IWriter;
-use PhpOffice\PhpSpreadsheet\Writer\Pdf\Dompdf;
 use RecursiveDirectoryIterator;
 use RecursiveIteratorIterator;
 use RecursiveRegexIterator;
 use ReflectionClass;
 use RegexIterator;
 use RuntimeException;
 use Throwable;
 /**
  * Helper class to be used in sample code.
  */
@@ -100,25 +99,21 @@
             $spreadsheet->setActiveSheetIndex(0);
         }
         foreach ($writers as $writerType) {
             $path = $this->getFilename($filename, mb_strtolower($writerType));
             $writer = IOFactory::createWriter($spreadsheet, $writerType);
             $writer->setIncludeCharts($withCharts);
             if ($writerCallback !== null) {
                 $writerCallback($writer);
             }
             $callStartTime = microtime(true);
-            if (PHP_VERSION_ID >= 80400 && $writer instanceof Dompdf) {
-                @$writer->save($path);
-            } else {
-                $writer->save($path);
-            }
+            $writer->save($path);
             $this->logWrite($writer, $path, $callStartTime);
             if ($this->isCli() === false) {
                 echo '<a href="/download.php?type=' . pathinfo($path, PATHINFO_EXTENSION) . '&name=' . basename($path) . '">Download ' . basename($path) . '</a><br />';
             }
         }
         $this->logEndingNotes();
     }
     protected function isDirOrMkdir(string $folder): bool
     {
         return \is_dir($folder) || \mkdir($folder);

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/BaseReader.php
@@ -0,0 +1,199 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Reader\Exception as ReaderException;
+use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
+use PhpOffice\PhpSpreadsheet\Shared\File;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+abstract class BaseReader implements IReader
+{
+    /**
+     * Read data only?
+     * Identifies whether the Reader should only read data values for cells, and ignore any formatting information;
+     *        or whether it should read both data and formatting.
+     */
+    protected bool $readDataOnly = false;
+    /**
+     * Read empty cells?
+     * Identifies whether the Reader should read data values for cells all cells, or should ignore cells containing
+     *         null value or empty string.
+     */
+    protected bool $readEmptyCells = true;
+    /**
+     * Read charts that are defined in the workbook?
+     * Identifies whether the Reader should read the definitions for any charts that exist in the workbook;.
+     */
+    protected bool $includeCharts = false;
+    /**
+     * Restrict which sheets should be loaded?
+     * This property holds an array of worksheet names to be loaded. If null, then all worksheets will be loaded.
+     * This property is ignored for Csv, Html, and Slk.
+     *
+     * @var null|string[]
+     */
+    protected ?array $loadSheetsOnly = null;
+    /**
+     * Ignore rows with no cells?
+     * Identifies whether the Reader should ignore rows with no cells.
+     *        Currently implemented only for Xlsx.
+     */
+    protected bool $ignoreRowsWithNoCells = false;
+    /**
+     * IReadFilter instance.
+     */
+    protected IReadFilter $readFilter;
+    /** @var resource */
+    protected $fileHandle;
+    protected ?XmlScanner $securityScanner = null;
+    public function __construct()
+    {
+        $this->readFilter = new DefaultReadFilter();
+    }
+    public function getReadDataOnly(): bool
+    {
+        return $this->readDataOnly;
+    }
+    public function setReadDataOnly(bool $readCellValuesOnly): self
+    {
+        $this->readDataOnly = $readCellValuesOnly;
+        return $this;
+    }
+    public function getReadEmptyCells(): bool
+    {
+        return $this->readEmptyCells;
+    }
+    public function setReadEmptyCells(bool $readEmptyCells): self
+    {
+        $this->readEmptyCells = $readEmptyCells;
+        return $this;
+    }
+    public function getIgnoreRowsWithNoCells(): bool
+    {
+        return $this->ignoreRowsWithNoCells;
+    }
+    public function setIgnoreRowsWithNoCells(bool $ignoreRowsWithNoCells): self
+    {
+        $this->ignoreRowsWithNoCells = $ignoreRowsWithNoCells;
+        return $this;
+    }
+    public function getIncludeCharts(): bool
+    {
+        return $this->includeCharts;
+    }
+    public function setIncludeCharts(bool $includeCharts): self
+    {
+        $this->includeCharts = $includeCharts;
+        return $this;
+    }
+    public function getLoadSheetsOnly(): ?array
+    {
+        return $this->loadSheetsOnly;
+    }
+    public function setLoadSheetsOnly(string|array|null $sheetList): self
+    {
+        if ($sheetList === null) {
+            return $this->setLoadAllSheets();
+        }
+        $this->loadSheetsOnly = is_array($sheetList) ? $sheetList : [$sheetList];
+        return $this;
+    }
+    public function setLoadAllSheets(): self
+    {
+        $this->loadSheetsOnly = null;
+        return $this;
+    }
+    public function getReadFilter(): IReadFilter
+    {
+        return $this->readFilter;
+    }
+    public function setReadFilter(IReadFilter $readFilter): self
+    {
+        $this->readFilter = $readFilter;
+        return $this;
+    }
+    public function getSecurityScanner(): ?XmlScanner
+    {
+        return $this->securityScanner;
+    }
+    public function getSecurityScannerOrThrow(): XmlScanner
+    {
+        if ($this->securityScanner === null) {
+            throw new ReaderException('Security scanner is unexpectedly null');
+        }
+        return $this->securityScanner;
+    }
+    protected function processFlags(int $flags): void
+    {
+        if (((bool) ($flags & self::LOAD_WITH_CHARTS)) === true) {
+            $this->setIncludeCharts(true);
+        }
+        if (((bool) ($flags & self::READ_DATA_ONLY)) === true) {
+            $this->setReadDataOnly(true);
+        }
+        if (((bool) ($flags & self::SKIP_EMPTY_CELLS) || (bool) ($flags & self::IGNORE_EMPTY_CELLS)) === true) {
+            $this->setReadEmptyCells(false);
+        }
+        if (((bool) ($flags & self::IGNORE_ROWS_WITH_NO_CELLS)) === true) {
+            $this->setIgnoreRowsWithNoCells(true);
+        }
+    }
+    protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
+    {
+        throw new PhpSpreadsheetException('Reader classes must implement their own loadSpreadsheetFromFile() method');
+    }
+    /**
+     * Loads Spreadsheet from file.
+     *
+     * @param int $flags the optional second parameter flags may be used to identify specific elements
+     *                       that should be loaded, but which won't be loaded by default, using these values:
+     *                            IReader::LOAD_WITH_CHARTS - Include any charts that are defined in the loaded file
+     */
+    public function load(string $filename, int $flags = 0): Spreadsheet
+    {
+        $this->processFlags($flags);
+        try {
+            return $this->loadSpreadsheetFromFile($filename);
+        } catch (ReaderException $e) {
+            throw $e;
+        }
+    }
+    /**
+     * Open file for reading.
+     */
+    protected function openFile(string $filename): void
+    {
+        $fileHandle = false;
+        if ($filename) {
+            File::assertFile($filename);
+            $fileHandle = fopen($filename, 'rb');
+        }
+        if ($fileHandle === false) {
+            throw new ReaderException('Could not open file ' . $filename . ' for reading.');
+        }
+        $this->fileHandle = $fileHandle;
+    }
+    /**
+     * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
+     */
+    public function listWorksheetInfo(string $filename): array
+    {
+        throw new PhpSpreadsheetException('Reader classes must implement their own listWorksheetInfo() method');
+    }
+    /**
+     * Returns names of the worksheets from a file,
+     * possibly without parsing the whole file to a Spreadsheet object.
+     * Readers will often have a more efficient method with which
+     * they can override this method.
+     */
+    public function listWorksheetNames(string $filename): array
+    {
+        $returnArray = [];
+        $info = $this->listWorksheetInfo($filename);
+        foreach ($info as $infoArray) {
+            if (isset($infoArray['worksheetName'])) {
+                $returnArray[] = $infoArray['worksheetName'];
+            }
+        }
+        return $returnArray;
+    }
+}

--- a/src/PhpSpreadsheet/Reader/Csv.php
+++ b/src/PhpSpreadsheet/Reader/Csv.php
@@ -45,32 +45,22 @@
     /**
      * Sheet index to read.
      */
     private int $sheetIndex = 0;
     /**
      * Load rows contiguously.
      */
     private bool $contiguous = false;
     /**
      * The character that can escape the enclosure.
-     * This will probably become unsupported in Php 9.
-     * Not yet ready to mark deprecated in order to give users
-     * a migration path.
-     */
-    private ?string $escapeCharacter = null;
-    /**
-     * The character that will be supplied to fgetcsv
-     * when escapeCharacter is null.
-     * It is anticipated that it will conditionally be set
-     * to null-string for Php9 and above.
-     */
-    private static string $defaultEscapeCharacter = '\\';
+     */
+    private string $escapeCharacter = '\\';
     /**
      * Callback for setting defaults in construction.
      *
      * @var ?callable
      */
     private static $constructorCallback;
     /**
      * Attempt autodetect line endings (deprecated after PHP8.1)?
      */
     private bool $testAutodetect = true;
@@ -151,21 +141,21 @@
         $this->skipBOM();
     }
     /**
      * Infer the separator if it isn't explicitly set in the file or specified by the user.
      */
     protected function inferSeparator(): void
     {
         if ($this->delimiter !== null) {
             return;
         }
-        $inferenceEngine = new Delimiter($this->fileHandle, $this->escapeCharacter ?? self::$defaultEscapeCharacter, $this->enclosure);
+        $inferenceEngine = new Delimiter($this->fileHandle, $this->escapeCharacter, $this->enclosure);
         if ($inferenceEngine->linesCounted() === 0) {
             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
             $this->skipBOM();
             return;
         }
         $this->delimiter = $inferenceEngine->infer();
         if ($this->delimiter === null) {
             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
         }
         $this->skipBOM();
@@ -180,25 +170,25 @@
         $this->skipBOM();
         $this->checkSeparator();
         $this->inferSeparator();
         $worksheetInfo = [];
         $worksheetInfo[0]['worksheetName'] = 'Worksheet';
         $worksheetInfo[0]['lastColumnLetter'] = 'A';
         $worksheetInfo[0]['lastColumnIndex'] = 0;
         $worksheetInfo[0]['totalRows'] = 0;
         $worksheetInfo[0]['totalColumns'] = 0;
         $delimiter = $this->delimiter ?? '';
-        $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
+        $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
         while (is_array($rowData)) {
             ++$worksheetInfo[0]['totalRows'];
             $worksheetInfo[0]['lastColumnIndex'] = max($worksheetInfo[0]['lastColumnIndex'], count($rowData) - 1);
-            $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
+            $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
         }
         $worksheetInfo[0]['lastColumnLetter'] = Coordinate::stringFromColumnIndex($worksheetInfo[0]['lastColumnIndex'] + 1);
         $worksheetInfo[0]['totalColumns'] = $worksheetInfo[0]['lastColumnIndex'] + 1;
         fclose($fileHandle);
         return $worksheetInfo;
     }
     /**
      * Loads Spreadsheet from file.
      */
     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
@@ -295,21 +285,21 @@
         while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
             $spreadsheet->createSheet();
         }
         $sheet = $spreadsheet->setActiveSheetIndex($this->sheetIndex);
         if ($this->sheetNameIsFileName) {
             $sheet->setTitle(substr(basename($filename, '.csv'), 0, Worksheet::SHEET_TITLE_MAXIMUM_LENGTH));
         }
         $currentRow = 1;
         $outRow = 0;
         $delimiter = $this->delimiter ?? '';
-        $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
+        $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
         $valueBinder = Cell::getValueBinder();
         $preserveBooleanString = method_exists($valueBinder, 'getBooleanConversion') && $valueBinder->getBooleanConversion();
         $this->getTrue = Calculation::getTRUE();
         $this->getFalse = Calculation::getFALSE();
         $this->thousandsSeparator = StringHelper::getThousandsSeparator();
         $this->decimalSeparator = StringHelper::getDecimalSeparator();
         while (is_array($rowData)) {
             $noOutputYet = true;
             $columnLetter = 'A';
             foreach ($rowData as $rowDatum) {
@@ -330,21 +320,21 @@
                     }
                     if ($numberFormatMask !== '') {
                         $sheet->getStyle($columnLetter . $outRow)
                             ->getNumberFormat()
                             ->setFormatCode($numberFormatMask);
                     }
                     $sheet->getCell($columnLetter . $outRow)->setValue($rowDatum);
                 }
                 ++$columnLetter;
             }
-            $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
+            $rowData = fgetcsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
             ++$currentRow;
         }
         fclose($fileHandle);
         $this->setAutoDetect($iniset);
         return $spreadsheet;
     }
     /**
      * Convert string true/false to boolean, and null to null-string.
      */
     private function convertBoolean(mixed &$rowDatum): void
@@ -418,33 +408,28 @@
     }
     public function setContiguous(bool $contiguous): self
     {
         $this->contiguous = $contiguous;
         return $this;
     }
     public function getContiguous(): bool
     {
         return $this->contiguous;
     }
-    /**
-     * Php9 intends to drop support for this parameter in fgetcsv.
-     * Not yet ready to mark deprecated in order to give users
-     * a migration path.
-     */
     public function setEscapeCharacter(string $escapeCharacter): self
     {
         $this->escapeCharacter = $escapeCharacter;
         return $this;
     }
     public function getEscapeCharacter(): string
     {
-        return $this->escapeCharacter ?? self::$defaultEscapeCharacter;
+        return $this->escapeCharacter;
     }
     /**
      * Can the current IReader read the file?
      */
     public function canRead(string $filename): bool
     {
         try {
             $this->openFile($filename);
         } catch (ReaderException) {
             return false;
@@ -522,33 +507,11 @@
     }
     public function getPreserveNullString(): bool
     {
         return $this->preserveNullString;
     }
     public function setSheetNameIsFileName(bool $sheetNameIsFileName): self
     {
         $this->sheetNameIsFileName = $sheetNameIsFileName;
         return $this;
     }
-    /**
-     * Php8.4 deprecates use of anything other than null string
-     * as escape Character.
-     *
-     * @param resource $stream
-     * @param null|int<0, max> $length
-     *
-     * @return array<int,?string>|false
-     */
-    private static function getCsv(
-        $stream,
-        ?int $length = null,
-        string $separator = ',',
-        string $enclosure = '"',
-        ?string $escape = null
-    ): array|false {
-        $escape = $escape ?? self::$defaultEscapeCharacter;
-        if (PHP_VERSION_ID >= 80400 && $escape !== '') {
-            return @fgetcsv($stream, $length, $separator, $enclosure, $escape);
-        }
-        return fgetcsv($stream, $length, $separator, $enclosure, $escape);
-    }
 }

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Html.php
@@ -0,0 +1,945 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use DOMAttr;
+use DOMDocument;
+use DOMElement;
+use DOMNode;
+use DOMText;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Comment;
+use PhpOffice\PhpSpreadsheet\Document\Properties;
+use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Helper\Dimension as CssDimension;
+use PhpOffice\PhpSpreadsheet\Helper\Html as HelperHtml;
+use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Border;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Font;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+use PhpOffice\PhpSpreadsheet\Worksheet\Drawing;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use Throwable;
+class Html extends BaseReader
+{
+    /**
+     * Sample size to read to determine if it's HTML or not.
+     */
+    const TEST_SAMPLE_SIZE = 2048;
+    private const STARTS_WITH_BOM = '/^(?:\xfe\xff|\xff\xfe|\xEF\xBB\xBF)/';
+    private const DECLARES_CHARSET = '/ charset=/i';
+    /**
+     * Input encoding.
+     */
+    protected string $inputEncoding = 'ANSI';
+    /**
+     * Sheet index to read.
+     */
+    protected int $sheetIndex = 0;
+    /**
+     * Formats.
+     */
+    protected array $formats = [
+        'h1' => [
+            'font' => [
+                'bold' => true,
+                'size' => 24,
+            ],
+        ], //    Bold, 24pt
+        'h2' => [
+            'font' => [
+                'bold' => true,
+                'size' => 18,
+            ],
+        ], //    Bold, 18pt
+        'h3' => [
+            'font' => [
+                'bold' => true,
+                'size' => 13.5,
+            ],
+        ], //    Bold, 13.5pt
+        'h4' => [
+            'font' => [
+                'bold' => true,
+                'size' => 12,
+            ],
+        ], //    Bold, 12pt
+        'h5' => [
+            'font' => [
+                'bold' => true,
+                'size' => 10,
+            ],
+        ], //    Bold, 10pt
+        'h6' => [
+            'font' => [
+                'bold' => true,
+                'size' => 7.5,
+            ],
+        ], //    Bold, 7.5pt
+        'a' => [
+            'font' => [
+                'underline' => true,
+                'color' => [
+                    'argb' => Color::COLOR_BLUE,
+                ],
+            ],
+        ], //    Blue underlined
+        'hr' => [
+            'borders' => [
+                'bottom' => [
+                    'borderStyle' => Border::BORDER_THIN,
+                    'color' => [
+                        Color::COLOR_BLACK,
+                    ],
+                ],
+            ],
+        ], //    Bottom border
+        'strong' => [
+            'font' => [
+                'bold' => true,
+            ],
+        ], //    Bold
+        'b' => [
+            'font' => [
+                'bold' => true,
+            ],
+        ], //    Bold
+        'i' => [
+            'font' => [
+                'italic' => true,
+            ],
+        ], //    Italic
+        'em' => [
+            'font' => [
+                'italic' => true,
+            ],
+        ], //    Italic
+    ];
+    protected array $rowspan = [];
+    /**
+     * Create a new HTML Reader instance.
+     */
+    public function __construct()
+    {
+        parent::__construct();
+        $this->securityScanner = XmlScanner::getInstance($this);
+    }
+    /**
+     * Validate that the current file is an HTML file.
+     */
+    public function canRead(string $filename): bool
+    {
+        try {
+            $this->openFile($filename);
+        } catch (Exception) {
+            return false;
+        }
+        $beginning = preg_replace(self::STARTS_WITH_BOM, '', $this->readBeginning()) ?? '';
+        $startWithTag = self::startsWithTag($beginning);
+        $containsTags = self::containsTags($beginning);
+        $endsWithTag = self::endsWithTag($this->readEnding());
+        fclose($this->fileHandle);
+        return $startWithTag && $containsTags && $endsWithTag;
+    }
+    private function readBeginning(): string
+    {
+        fseek($this->fileHandle, 0);
+        return (string) fread($this->fileHandle, self::TEST_SAMPLE_SIZE);
+    }
+    private function readEnding(): string
+    {
+        $meta = stream_get_meta_data($this->fileHandle);
+        $filename = $meta['uri']; //@phpstan-ignore-line
+        $size = (int) filesize($filename);
+        if ($size === 0) {
+            return '';
+        }
+        $blockSize = self::TEST_SAMPLE_SIZE;
+        if ($size < $blockSize) {
+            $blockSize = $size;
+        }
+        fseek($this->fileHandle, $size - $blockSize);
+        return (string) fread($this->fileHandle, $blockSize);
+    }
+    private static function startsWithTag(string $data): bool
+    {
+        return str_starts_with(trim($data), '<');
+    }
+    private static function endsWithTag(string $data): bool
+    {
+        return str_ends_with(trim($data), '>');
+    }
+    private static function containsTags(string $data): bool
+    {
+        return strlen($data) !== strlen(strip_tags($data));
+    }
+    /**
+     * Loads Spreadsheet from file.
+     */
+    public function loadSpreadsheetFromFile(string $filename): Spreadsheet
+    {
+        $spreadsheet = new Spreadsheet();
+        return $this->loadIntoExisting($filename, $spreadsheet);
+    }
+    protected array $dataArray = [];
+    protected int $tableLevel = 0;
+    protected array $nestedColumn = ['A'];
+    protected function setTableStartColumn(string $column): string
+    {
+        if ($this->tableLevel == 0) {
+            $column = 'A';
+        }
+        ++$this->tableLevel;
+        $this->nestedColumn[$this->tableLevel] = $column;
+        return $this->nestedColumn[$this->tableLevel];
+    }
+    protected function getTableStartColumn(): string
+    {
+        return $this->nestedColumn[$this->tableLevel];
+    }
+    protected function releaseTableStartColumn(): string
+    {
+        --$this->tableLevel;
+        return array_pop($this->nestedColumn);
+    }
+    /**
+     * Flush cell.
+     */
+    protected function flushCell(Worksheet $sheet, string $column, int|string $row, mixed &$cellContent, array $attributeArray): void
+    {
+        if (is_string($cellContent)) {
+            if (trim($cellContent) > '') {
+                if (isset($attributeArray['data-type'])) {
+                    $datatype = $attributeArray['data-type'];
+                    if (in_array($datatype, [DataType::TYPE_STRING, DataType::TYPE_STRING2, DataType::TYPE_INLINE])) {
+                        if (str_starts_with($cellContent, '=')) {
+                            $sheet->getCell($column . $row)
+                                ->getStyle()
+                                ->setQuotePrefix(true);
+                        }
+                    }
+                    try {
+                        $sheet->setCellValueExplicit($column . $row, $cellContent, $attributeArray['data-type']);
+                    } catch (SpreadsheetException) {
+                        $sheet->setCellValue($column . $row, $cellContent);
+                    }
+                } else {
+                    $sheet->setCellValue($column . $row, $cellContent);
+                }
+                $this->dataArray[$row][$column] = $cellContent;
+            }
+        } else {
+            $this->dataArray[$row][$column] = 'RICH TEXT: ' . $cellContent;
+        }
+        $cellContent = (string) '';
+    }
+    private function processDomElementBody(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child): void
+    {
+        $attributeArray = [];
+        /** @var DOMAttr $attribute */
+        foreach ($child->attributes as $attribute) {
+            $attributeArray[$attribute->name] = $attribute->value;
+        }
+        if ($child->nodeName === 'body') {
+            $row = 1;
+            $column = 'A';
+            $cellContent = '';
+            $this->tableLevel = 0;
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+        } else {
+            $this->processDomElementTitle($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementTitle(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'title') {
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            try {
+                $sheet->setTitle($cellContent, true, true);
+            } catch (SpreadsheetException) {
+            }
+            $cellContent = '';
+        } else {
+            $this->processDomElementSpanEtc($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private const SPAN_ETC = ['span', 'div', 'font', 'i', 'em', 'strong', 'b'];
+    private function processDomElementSpanEtc(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if (in_array((string) $child->nodeName, self::SPAN_ETC, true)) {
+            if (isset($attributeArray['class']) && $attributeArray['class'] === 'comment') {
+                $sheet->getComment($column . $row)
+                    ->getText()
+                    ->createTextRun($child->textContent);
+                if (isset($attributeArray['dir']) && $attributeArray['dir'] === 'rtl') {
+                    $sheet->getComment($column . $row)->setTextboxDirection(Comment::TEXTBOX_DIRECTION_RTL);
+                }
+                if (isset($attributeArray['style'])) {
+                    $alignStyle = $attributeArray['style'];
+                    if (preg_match('/\\btext-align:\\s*(left|right|center|justify)\\b/', $alignStyle, $matches) === 1) {
+                        $sheet->getComment($column . $row)->setAlignment($matches[1]);
+                    }
+                }
+            } else {
+                $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            }
+            if (isset($this->formats[$child->nodeName])) {
+                $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
+            }
+        } else {
+            $this->processDomElementHr($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementHr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'hr') {
+            $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+            ++$row;
+            if (isset($this->formats[$child->nodeName])) {
+                $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
+            }
+            ++$row;
+        }
+        $this->processDomElementBr($sheet, $row, $column, $cellContent, $child, $attributeArray);
+    }
+    private function processDomElementBr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'br' || $child->nodeName === 'hr') {
+            if ($this->tableLevel > 0) {
+                $cellContent .= "\n";
+                $sheet->getStyle($column . $row)->getAlignment()->setWrapText(true);
+            } else {
+                $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+                ++$row;
+            }
+        } else {
+            $this->processDomElementA($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementA(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'a') {
+            foreach ($attributeArray as $attributeName => $attributeValue) {
+                switch ($attributeName) {
+                    case 'href':
+                        $sheet->getCell($column . $row)->getHyperlink()->setUrl($attributeValue);
+                        if (isset($this->formats[$child->nodeName])) {
+                            $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
+                        }
+                        break;
+                    case 'class':
+                        if ($attributeValue === 'comment-indicator') {
+                            break; // Ignore - it's just a red square.
+                        }
+                }
+            }
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+        } else {
+            $this->processDomElementH1Etc($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private const H1_ETC = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'p'];
+    private function processDomElementH1Etc(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if (in_array((string) $child->nodeName, self::H1_ETC, true)) {
+            if ($this->tableLevel > 0) {
+                $cellContent .= $cellContent ? "\n" : '';
+                $sheet->getStyle($column . $row)->getAlignment()->setWrapText(true);
+                $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            } else {
+                if ($cellContent > '') {
+                    $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+                    ++$row;
+                }
+                $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+                $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+                if (isset($this->formats[$child->nodeName])) {
+                    $sheet->getStyle($column . $row)->applyFromArray($this->formats[$child->nodeName]);
+                }
+                ++$row;
+                $column = 'A';
+            }
+        } else {
+            $this->processDomElementLi($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementLi(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'li') {
+            if ($this->tableLevel > 0) {
+                $cellContent .= $cellContent ? "\n" : '';
+                $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            } else {
+                if ($cellContent > '') {
+                    $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+                }
+                ++$row;
+                $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+                $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+                $column = 'A';
+            }
+        } else {
+            $this->processDomElementImg($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementImg(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'img') {
+            $this->insertImage($sheet, $column, $row, $attributeArray);
+        } else {
+            $this->processDomElementTable($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private string $currentColumn = 'A';
+    private function processDomElementTable(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'table') {
+            $this->currentColumn = 'A';
+            $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+            $column = $this->setTableStartColumn($column);
+            if ($this->tableLevel > 1 && $row > 1) {
+                --$row;
+            }
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            $column = $this->releaseTableStartColumn();
+            if ($this->tableLevel > 1) {
+                ++$column;
+            } else {
+                ++$row;
+            }
+        } else {
+            $this->processDomElementTr($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementTr(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName === 'col') {
+            $this->applyInlineStyle($sheet, -1, $this->currentColumn, $attributeArray);
+            ++$this->currentColumn;
+        } elseif ($child->nodeName === 'tr') {
+            $column = $this->getTableStartColumn();
+            $cellContent = '';
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+            if (isset($attributeArray['height'])) {
+                $sheet->getRowDimension($row)->setRowHeight($attributeArray['height']);
+            }
+            ++$row;
+        } else {
+            $this->processDomElementThTdOther($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementThTdOther(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        if ($child->nodeName !== 'td' && $child->nodeName !== 'th') {
+            $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+        } else {
+            $this->processDomElementThTd($sheet, $row, $column, $cellContent, $child, $attributeArray);
+        }
+    }
+    private function processDomElementBgcolor(Worksheet $sheet, int $row, string $column, array $attributeArray): void
+    {
+        if (isset($attributeArray['bgcolor'])) {
+            $sheet->getStyle("$column$row")->applyFromArray(
+                [
+                    'fill' => [
+                        'fillType' => Fill::FILL_SOLID,
+                        'color' => ['rgb' => $this->getStyleColor($attributeArray['bgcolor'])],
+                    ],
+                ]
+            );
+        }
+    }
+    private function processDomElementWidth(Worksheet $sheet, string $column, array $attributeArray): void
+    {
+        if (isset($attributeArray['width'])) {
+            $sheet->getColumnDimension($column)->setWidth((new CssDimension($attributeArray['width']))->width());
+        }
+    }
+    private function processDomElementHeight(Worksheet $sheet, int $row, array $attributeArray): void
+    {
+        if (isset($attributeArray['height'])) {
+            $sheet->getRowDimension($row)->setRowHeight((new CssDimension($attributeArray['height']))->height());
+        }
+    }
+    private function processDomElementAlign(Worksheet $sheet, int $row, string $column, array $attributeArray): void
+    {
+        if (isset($attributeArray['align'])) {
+            $sheet->getStyle($column . $row)->getAlignment()->setHorizontal($attributeArray['align']);
+        }
+    }
+    private function processDomElementVAlign(Worksheet $sheet, int $row, string $column, array $attributeArray): void
+    {
+        if (isset($attributeArray['valign'])) {
+            $sheet->getStyle($column . $row)->getAlignment()->setVertical($attributeArray['valign']);
+        }
+    }
+    private function processDomElementDataFormat(Worksheet $sheet, int $row, string $column, array $attributeArray): void
+    {
+        if (isset($attributeArray['data-format'])) {
+            $sheet->getStyle($column . $row)->getNumberFormat()->setFormatCode($attributeArray['data-format']);
+        }
+    }
+    private function processDomElementThTd(Worksheet $sheet, int &$row, string &$column, string &$cellContent, DOMElement $child, array &$attributeArray): void
+    {
+        while (isset($this->rowspan[$column . $row])) {
+            ++$column;
+        }
+        $this->processDomElement($child, $sheet, $row, $column, $cellContent);
+        $this->applyInlineStyle($sheet, $row, $column, $attributeArray);
+        $this->flushCell($sheet, $column, $row, $cellContent, $attributeArray);
+        $this->processDomElementBgcolor($sheet, $row, $column, $attributeArray);
+        $this->processDomElementWidth($sheet, $column, $attributeArray);
+        $this->processDomElementHeight($sheet, $row, $attributeArray);
+        $this->processDomElementAlign($sheet, $row, $column, $attributeArray);
+        $this->processDomElementVAlign($sheet, $row, $column, $attributeArray);
+        $this->processDomElementDataFormat($sheet, $row, $column, $attributeArray);
+        if (isset($attributeArray['rowspan'], $attributeArray['colspan'])) {
+            $columnTo = $column;
+            for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
+                ++$columnTo;
+            }
+            $range = $column . $row . ':' . $columnTo . ($row + (int) $attributeArray['rowspan'] - 1);
+            foreach (Coordinate::extractAllCellReferencesInRange($range) as $value) {
+                $this->rowspan[$value] = true;
+            }
+            $sheet->mergeCells($range);
+            $column = $columnTo;
+        } elseif (isset($attributeArray['rowspan'])) {
+            $range = $column . $row . ':' . $column . ($row + (int) $attributeArray['rowspan'] - 1);
+            foreach (Coordinate::extractAllCellReferencesInRange($range) as $value) {
+                $this->rowspan[$value] = true;
+            }
+            $sheet->mergeCells($range);
+        } elseif (isset($attributeArray['colspan'])) {
+            $columnTo = $column;
+            for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
+                ++$columnTo;
+            }
+            $sheet->mergeCells($column . $row . ':' . $columnTo . $row);
+            $column = $columnTo;
+        }
+        ++$column;
+    }
+    protected function processDomElement(DOMNode $element, Worksheet $sheet, int &$row, string &$column, string &$cellContent): void
+    {
+        foreach ($element->childNodes as $child) {
+            if ($child instanceof DOMText) {
+                $domText = (string) preg_replace('/\s+/u', ' ', trim($child->nodeValue ?? ''));
+                if (is_string($cellContent)) {
+                    $cellContent .= $domText;
+                }
+            } elseif ($child instanceof DOMElement) {
+                $this->processDomElementBody($sheet, $row, $column, $cellContent, $child);
+            }
+        }
+    }
+    /**
+     * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
+     */
+    public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
+    {
+        if (!$this->canRead($filename)) {
+            throw new Exception($filename . ' is an Invalid HTML file.');
+        }
+        $dom = new DOMDocument();
+        try {
+            $convert = $this->getSecurityScannerOrThrow()->scanFile($filename);
+            $convert = self::replaceNonAsciiIfNeeded($convert);
+            $loaded = ($convert === null) ? false : $dom->loadHTML($convert);
+        } catch (Throwable $e) {
+            $loaded = false;
+        }
+        if ($loaded === false) {
+            throw new Exception('Failed to load ' . $filename . ' as a DOM Document', 0, $e ?? null);
+        }
+        self::loadProperties($dom, $spreadsheet);
+        return $this->loadDocument($dom, $spreadsheet);
+    }
+    private static function loadProperties(DOMDocument $dom, Spreadsheet $spreadsheet): void
+    {
+        $properties = $spreadsheet->getProperties();
+        foreach ($dom->getElementsByTagName('meta') as $meta) {
+            $metaContent = (string) $meta->getAttribute('content');
+            if ($metaContent !== '') {
+                $metaName = (string) $meta->getAttribute('name');
+                switch ($metaName) {
+                    case 'author':
+                        $properties->setCreator($metaContent);
+                        break;
+                    case 'category':
+                        $properties->setCategory($metaContent);
+                        break;
+                    case 'company':
+                        $properties->setCompany($metaContent);
+                        break;
+                    case 'created':
+                        $properties->setCreated($metaContent);
+                        break;
+                    case 'description':
+                        $properties->setDescription($metaContent);
+                        break;
+                    case 'keywords':
+                        $properties->setKeywords($metaContent);
+                        break;
+                    case 'lastModifiedBy':
+                        $properties->setLastModifiedBy($metaContent);
+                        break;
+                    case 'manager':
+                        $properties->setManager($metaContent);
+                        break;
+                    case 'modified':
+                        $properties->setModified($metaContent);
+                        break;
+                    case 'subject':
+                        $properties->setSubject($metaContent);
+                        break;
+                    case 'title':
+                        $properties->setTitle($metaContent);
+                        break;
+                    case 'viewport':
+                        $properties->setViewport($metaContent);
+                        break;
+                    default:
+                        if (preg_match('/^custom[.](bool|date|float|int|string)[.](.+)$/', $metaName, $matches) === 1) {
+                            match ($matches[1]) {
+                                'bool' => $properties->setCustomProperty($matches[2], (bool) $metaContent, Properties::PROPERTY_TYPE_BOOLEAN),
+                                'float' => $properties->setCustomProperty($matches[2], (float) $metaContent, Properties::PROPERTY_TYPE_FLOAT),
+                                'int' => $properties->setCustomProperty($matches[2], (int) $metaContent, Properties::PROPERTY_TYPE_INTEGER),
+                                'date' => $properties->setCustomProperty($matches[2], $metaContent, Properties::PROPERTY_TYPE_DATE),
+                                default => $properties->setCustomProperty($matches[2], $metaContent, Properties::PROPERTY_TYPE_STRING),
+                            };
+                        }
+                }
+            }
+        }
+        if (!empty($dom->baseURI)) {
+            $properties->setHyperlinkBase($dom->baseURI);
+        }
+    }
+    private static function replaceNonAscii(array $matches): string
+    {
+        return '&#' . mb_ord($matches[0], 'UTF-8') . ';';
+    }
+    private static function replaceNonAsciiIfNeeded(string $convert): ?string
+    {
+        if (preg_match(self::STARTS_WITH_BOM, $convert) !== 1 && preg_match(self::DECLARES_CHARSET, $convert) !== 1) {
+            $lowend = "\u{80}";
+            $highend = "\u{10ffff}";
+            $regexp = "/[$lowend-$highend]/u";
+            /** @var callable $callback */
+            $callback = [self::class, 'replaceNonAscii'];
+            $convert = preg_replace_callback($regexp, $callback, $convert);
+        }
+        return $convert;
+    }
+    /**
+     * Spreadsheet from content.
+     */
+    public function loadFromString(string $content, ?Spreadsheet $spreadsheet = null): Spreadsheet
+    {
+        $dom = new DOMDocument();
+        try {
+            $convert = $this->getSecurityScannerOrThrow()->scan($content);
+            $convert = self::replaceNonAsciiIfNeeded($convert);
+            $loaded = ($convert === null) ? false : $dom->loadHTML($convert);
+        } catch (Throwable $e) {
+            $loaded = false;
+        }
+        if ($loaded === false) {
+            throw new Exception('Failed to load content as a DOM Document', 0, $e ?? null);
+        }
+        $spreadsheet = $spreadsheet ?? new Spreadsheet();
+        self::loadProperties($dom, $spreadsheet);
+        return $this->loadDocument($dom, $spreadsheet);
+    }
+    /**
+     * Loads PhpSpreadsheet from DOMDocument into PhpSpreadsheet instance.
+     */
+    private function loadDocument(DOMDocument $document, Spreadsheet $spreadsheet): Spreadsheet
+    {
+        while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
+            $spreadsheet->createSheet();
+        }
+        $spreadsheet->setActiveSheetIndex($this->sheetIndex);
+        $document->preserveWhiteSpace = false;
+        $row = 0;
+        $column = 'A';
+        $content = '';
+        $this->rowspan = [];
+        $this->processDomElement($document, $spreadsheet->getActiveSheet(), $row, $column, $content);
+        return $spreadsheet;
+    }
+    /**
+     * Get sheet index.
+     */
+    public function getSheetIndex(): int
+    {
+        return $this->sheetIndex;
+    }
+    /**
+     * Set sheet index.
+     *
+     * @param int $sheetIndex Sheet index
+     *
+     * @return $this
+     */
+    public function setSheetIndex(int $sheetIndex): static
+    {
+        $this->sheetIndex = $sheetIndex;
+        return $this;
+    }
+    /**
+     * Apply inline css inline style.
+     *
+     * NOTES :
+     * Currently only intended for td & th element,
+     * and only takes 'background-color' and 'color'; property with HEX color
+     *
+     * TODO :
+     * - Implement to other propertie, such as border
+     */
+    private function applyInlineStyle(Worksheet &$sheet, int $row, string $column, array $attributeArray): void
+    {
+        if (!isset($attributeArray['style'])) {
+            return;
+        }
+        if ($row <= 0 || $column === '') {
+            $cellStyle = new Style();
+        } elseif (isset($attributeArray['rowspan'], $attributeArray['colspan'])) {
+            $columnTo = $column;
+            for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
+                ++$columnTo;
+            }
+            $range = $column . $row . ':' . $columnTo . ($row + (int) $attributeArray['rowspan'] - 1);
+            $cellStyle = $sheet->getStyle($range);
+        } elseif (isset($attributeArray['rowspan'])) {
+            $range = $column . $row . ':' . $column . ($row + (int) $attributeArray['rowspan'] - 1);
+            $cellStyle = $sheet->getStyle($range);
+        } elseif (isset($attributeArray['colspan'])) {
+            $columnTo = $column;
+            for ($i = 0; $i < (int) $attributeArray['colspan'] - 1; ++$i) {
+                ++$columnTo;
+            }
+            $range = $column . $row . ':' . $columnTo . $row;
+            $cellStyle = $sheet->getStyle($range);
+        } else {
+            $cellStyle = $sheet->getStyle($column . $row);
+        }
+        $styles = explode(';', $attributeArray['style']);
+        foreach ($styles as $st) {
+            $value = explode(':', $st);
+            $styleName = isset($value[0]) ? trim($value[0]) : null;
+            $styleValue = isset($value[1]) ? trim($value[1]) : null;
+            $styleValueString = (string) $styleValue;
+            if (!$styleName) {
+                continue;
+            }
+            switch ($styleName) {
+                case 'background':
+                case 'background-color':
+                    $styleColor = $this->getStyleColor($styleValueString);
+                    if (!$styleColor) {
+                        continue 2;
+                    }
+                    $cellStyle->applyFromArray(['fill' => ['fillType' => Fill::FILL_SOLID, 'color' => ['rgb' => $styleColor]]]);
+                    break;
+                case 'color':
+                    $styleColor = $this->getStyleColor($styleValueString);
+                    if (!$styleColor) {
+                        continue 2;
+                    }
+                    $cellStyle->applyFromArray(['font' => ['color' => ['rgb' => $styleColor]]]);
+                    break;
+                case 'border':
+                    $this->setBorderStyle($cellStyle, $styleValueString, 'allBorders');
+                    break;
+                case 'border-top':
+                    $this->setBorderStyle($cellStyle, $styleValueString, 'top');
+                    break;
+                case 'border-bottom':
+                    $this->setBorderStyle($cellStyle, $styleValueString, 'bottom');
+                    break;
+                case 'border-left':
+                    $this->setBorderStyle($cellStyle, $styleValueString, 'left');
+                    break;
+                case 'border-right':
+                    $this->setBorderStyle($cellStyle, $styleValueString, 'right');
+                    break;
+                case 'font-size':
+                    $cellStyle->getFont()->setSize(
+                        (float) $styleValue
+                    );
+                    break;
+                case 'font-weight':
+                    if ($styleValue === 'bold' || $styleValue >= 500) {
+                        $cellStyle->getFont()->setBold(true);
+                    }
+                    break;
+                case 'font-style':
+                    if ($styleValue === 'italic') {
+                        $cellStyle->getFont()->setItalic(true);
+                    }
+                    break;
+                case 'font-family':
+                    $cellStyle->getFont()->setName(str_replace('\'', '', $styleValueString));
+                    break;
+                case 'text-decoration':
+                    switch ($styleValue) {
+                        case 'underline':
+                            $cellStyle->getFont()->setUnderline(Font::UNDERLINE_SINGLE);
+                            break;
+                        case 'line-through':
+                            $cellStyle->getFont()->setStrikethrough(true);
+                            break;
+                    }
+                    break;
+                case 'text-align':
+                    $cellStyle->getAlignment()->setHorizontal($styleValueString);
+                    break;
+                case 'vertical-align':
+                    $cellStyle->getAlignment()->setVertical($styleValueString);
+                    break;
+                case 'width':
+                    if ($column !== '') {
+                        $sheet->getColumnDimension($column)->setWidth(
+                            (new CssDimension($styleValue ?? ''))->width()
+                        );
+                    }
+                    break;
+                case 'height':
+                    if ($row > 0) {
+                        $sheet->getRowDimension($row)->setRowHeight(
+                            (new CssDimension($styleValue ?? ''))->height()
+                        );
+                    }
+                    break;
+                case 'word-wrap':
+                    $cellStyle->getAlignment()->setWrapText(
+                        $styleValue === 'break-word'
+                    );
+                    break;
+                case 'text-indent':
+                    $cellStyle->getAlignment()->setIndent(
+                        (int) str_replace(['px'], '', $styleValueString)
+                    );
+                    break;
+            }
+        }
+    }
+    /**
+     * Check if has #, so we can get clean hex.
+     */
+    public function getStyleColor(?string $value): string
+    {
+        $value = (string) $value;
+        if (str_starts_with($value, '#')) {
+            return substr($value, 1);
+        }
+        return HelperHtml::colourNameLookup($value);
+    }
+    private function insertImage(Worksheet $sheet, string $column, int $row, array $attributes): void
+    {
+        if (!isset($attributes['src'])) {
+            return;
+        }
+        $src = urldecode($attributes['src']);
+        $width = isset($attributes['width']) ? (float) $attributes['width'] : null;
+        $height = isset($attributes['height']) ? (float) $attributes['height'] : null;
+        $name = $attributes['alt'] ?? null;
+        $drawing = new Drawing();
+        $drawing->setPath($src);
+        $drawing->setWorksheet($sheet);
+        $drawing->setCoordinates($column . $row);
+        $drawing->setOffsetX(0);
+        $drawing->setOffsetY(10);
+        $drawing->setResizeProportional(true);
+        if ($name) {
+            $drawing->setName($name);
+        }
+        if ($width) {
+            $drawing->setWidth((int) $width);
+        }
+        if ($height) {
+            $drawing->setHeight((int) $height);
+        }
+        $sheet->getColumnDimension($column)->setWidth(
+            $drawing->getWidth() / 6
+        );
+        $sheet->getRowDimension($row)->setRowHeight(
+            $drawing->getHeight() * 0.9
+        );
+    }
+    private const BORDER_MAPPINGS = [
+        'dash-dot' => Border::BORDER_DASHDOT,
+        'dash-dot-dot' => Border::BORDER_DASHDOTDOT,
+        'dashed' => Border::BORDER_DASHED,
+        'dotted' => Border::BORDER_DOTTED,
+        'double' => Border::BORDER_DOUBLE,
+        'hair' => Border::BORDER_HAIR,
+        'medium' => Border::BORDER_MEDIUM,
+        'medium-dashed' => Border::BORDER_MEDIUMDASHED,
+        'medium-dash-dot' => Border::BORDER_MEDIUMDASHDOT,
+        'medium-dash-dot-dot' => Border::BORDER_MEDIUMDASHDOTDOT,
+        'none' => Border::BORDER_NONE,
+        'slant-dash-dot' => Border::BORDER_SLANTDASHDOT,
+        'solid' => Border::BORDER_THIN,
+        'thick' => Border::BORDER_THICK,
+    ];
+    public static function getBorderMappings(): array
+    {
+        return self::BORDER_MAPPINGS;
+    }
+    /**
+     * Map html border style to PhpSpreadsheet border style.
+     */
+    public function getBorderStyle(string $style): ?string
+    {
+        return self::BORDER_MAPPINGS[$style] ?? null;
+    }
+    private function setBorderStyle(Style $cellStyle, string $styleValue, string $type): void
+    {
+        if (trim($styleValue) === Border::BORDER_NONE) {
+            $borderStyle = Border::BORDER_NONE;
+            $color = null;
+        } else {
+            $borderArray = explode(' ', $styleValue);
+            $borderCount = count($borderArray);
+            if ($borderCount >= 3) {
+                $borderStyle = $borderArray[1];
+                $color = $borderArray[2];
+            } else {
+                $borderStyle = $borderArray[0];
+                $color = $borderArray[1] ?? null;
+            }
+        }
+        $cellStyle->applyFromArray([
+            'borders' => [
+                $type => [
+                    'borderStyle' => $this->getBorderStyle($borderStyle),
+                    'color' => ['rgb' => $this->getStyleColor($color)],
+                ],
+            ],
+        ]);
+    }
+    /**
+     * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
+     */
+    public function listWorksheetInfo(string $filename): array
+    {
+        $info = [];
+        $spreadsheet = new Spreadsheet();
+        $this->loadIntoExisting($filename, $spreadsheet);
+        foreach ($spreadsheet->getAllSheets() as $sheet) {
+            $newEntry = ['worksheetName' => $sheet->getTitle()];
+            $newEntry['lastColumnLetter'] = $sheet->getHighestDataColumn();
+            $newEntry['lastColumnIndex'] = Coordinate::columnIndexFromString($sheet->getHighestDataColumn()) - 1;
+            $newEntry['totalRows'] = $sheet->getHighestDataRow();
+            $newEntry['totalColumns'] = $newEntry['lastColumnIndex'] + 1;
+            $info[] = $newEntry;
+        }
+        $spreadsheet->disconnectWorksheets();
+        return $info;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/IReader.php
@@ -0,0 +1,106 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+interface IReader
+{
+    public const LOAD_WITH_CHARTS = 1;
+    public const READ_DATA_ONLY = 2;
+    public const SKIP_EMPTY_CELLS = 4;
+    public const IGNORE_EMPTY_CELLS = 4;
+    public const IGNORE_ROWS_WITH_NO_CELLS = 8;
+    public function __construct();
+    /**
+     * Can the current IReader read the file?
+     */
+    public function canRead(string $filename): bool;
+    /**
+     * Read data only?
+     *        If this is true, then the Reader will only read data values for cells, it will not read any formatting
+     *           or structural information (like merges).
+     *        If false (the default) it will read data and formatting.
+     */
+    public function getReadDataOnly(): bool;
+    /**
+     * Set read data only
+     *        Set to true, to advise the Reader only to read data values for cells, and to ignore any formatting
+     *            or structural information (like merges).
+     *        Set to false (the default) to advise the Reader to read both data and formatting for cells.
+     *
+     * @return $this
+     */
+    public function setReadDataOnly(bool $readDataOnly): self;
+    /**
+     * Read empty cells?
+     *        If this is true (the default), then the Reader will read data values for all cells, irrespective of value.
+     *        If false it will not read data for cells containing a null value or an empty string.
+     */
+    public function getReadEmptyCells(): bool;
+    /**
+     * Set read empty cells
+     *        Set to true (the default) to advise the Reader read data values for all cells, irrespective of value.
+     *        Set to false to advise the Reader to ignore cells containing a null value or an empty string.
+     *
+     * @return $this
+     */
+    public function setReadEmptyCells(bool $readEmptyCells): self;
+    /**
+     * Read charts in workbook?
+     *      If this is true, then the Reader will include any charts that exist in the workbook.
+     *         Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
+     *      If false (the default) it will ignore any charts defined in the workbook file.
+     */
+    public function getIncludeCharts(): bool;
+    /**
+     * Set read charts in workbook
+     *     Set to true, to advise the Reader to include any charts that exist in the workbook.
+     *         Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
+     *     Set to false (the default) to discard charts.
+     *
+     * @return $this
+     */
+    public function setIncludeCharts(bool $includeCharts): self;
+    /**
+     * Get which sheets to load
+     * Returns either an array of worksheet names (the list of worksheets that should be loaded), or a null
+     *        indicating that all worksheets in the workbook should be loaded.
+     */
+    public function getLoadSheetsOnly(): ?array;
+    /**
+     * Set which sheets to load.
+     *
+     * @param null|array|string $value This should be either an array of worksheet names to be loaded,
+     *          or a string containing a single worksheet name. If NULL, then it tells the Reader to
+     *          read all worksheets in the workbook
+     *
+     * @return $this
+     */
+    public function setLoadSheetsOnly(string|array|null $value): self;
+    /**
+     * Set all sheets to load
+     *        Tells the Reader to load all worksheets from the workbook.
+     *
+     * @return $this
+     */
+    public function setLoadAllSheets(): self;
+    /**
+     * Read filter.
+     */
+    public function getReadFilter(): IReadFilter;
+    /**
+     * Set read filter.
+     *
+     * @return $this
+     */
+    public function setReadFilter(IReadFilter $readFilter): self;
+    /**
+     * Loads PhpSpreadsheet from file.
+     *
+     * @param string $filename The name of the file to load
+     * @param int $flags Flags that can change the behaviour of the Writer:
+     *            self::LOAD_WITH_CHARTS    Load any charts that are defined (if the Reader supports Charts)
+     *            self::READ_DATA_ONLY      Read only data, not style or structure information, from the file
+     *            self::SKIP_EMPTY_CELLS    Don't read empty cells (cells that contain a null value,
+     *                                      empty string, or a string containing only whitespace characters)
+     */
+    public function load(string $filename, int $flags = 0): Spreadsheet;
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Ods.php
@@ -0,0 +1,649 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use DOMAttr;
+use DOMDocument;
+use DOMElement;
+use DOMNode;
+use DOMText;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Helper\Dimension as HelperDimension;
+use PhpOffice\PhpSpreadsheet\Reader\Ods\AutoFilter;
+use PhpOffice\PhpSpreadsheet\Reader\Ods\DefinedNames;
+use PhpOffice\PhpSpreadsheet\Reader\Ods\FormulaTranslator;
+use PhpOffice\PhpSpreadsheet\Reader\Ods\PageSettings;
+use PhpOffice\PhpSpreadsheet\Reader\Ods\Properties as DocumentProperties;
+use PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Settings;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\File;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use Throwable;
+use XMLReader;
+use ZipArchive;
+class Ods extends BaseReader
+{
+    const INITIAL_FILE = 'content.xml';
+    /**
+     * Create a new Ods Reader instance.
+     */
+    public function __construct()
+    {
+        parent::__construct();
+        $this->securityScanner = XmlScanner::getInstance($this);
+    }
+    /**
+     * Can the current IReader read the file?
+     */
+    public function canRead(string $filename): bool
+    {
+        $mimeType = 'UNKNOWN';
+        if (File::testFileNoThrow($filename, '')) {
+            $zip = new ZipArchive();
+            if ($zip->open($filename) === true) {
+                $stat = $zip->statName('mimetype');
+                if (!empty($stat) && ($stat['size'] <= 255)) {
+                    $mimeType = $zip->getFromName($stat['name']);
+                } elseif ($zip->statName('META-INF/manifest.xml')) {
+                    $xml = simplexml_load_string(
+                        $this->getSecurityScannerOrThrow()->scan($zip->getFromName('META-INF/manifest.xml')),
+                        'SimpleXMLElement',
+                        Settings::getLibXmlLoaderOptions()
+                    );
+                    if ($xml !== false) {
+                        $namespacesContent = $xml->getNamespaces(true);
+                        if (isset($namespacesContent['manifest'])) {
+                            $manifest = $xml->children($namespacesContent['manifest']);
+                            foreach ($manifest as $manifestDataSet) {
+                                $manifestAttributes = $manifestDataSet->attributes($namespacesContent['manifest']);
+                                if ($manifestAttributes && $manifestAttributes->{'full-path'} == '/') {
+                                    $mimeType = (string) $manifestAttributes->{'media-type'};
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+                $zip->close();
+            }
+        }
+        return $mimeType === 'application/vnd.oasis.opendocument.spreadsheet';
+    }
+    /**
+     * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
+     *
+     * @return string[]
+     */
+    public function listWorksheetNames(string $filename): array
+    {
+        File::assertFile($filename, self::INITIAL_FILE);
+        $worksheetNames = [];
+        $xml = new XMLReader();
+        $xml->xml(
+            $this->getSecurityScannerOrThrow()->scanFile('zip://' . realpath($filename) . '#' . self::INITIAL_FILE),
+            null,
+            Settings::getLibXmlLoaderOptions()
+        );
+        $xml->setParserProperty(2, true);
+        $xml->read();
+        while ($xml->read()) {
+            while (self::getXmlName($xml) !== 'office:body') {
+                if ($xml->isEmptyElement) {
+                    $xml->read();
+                } else {
+                    $xml->next();
+                }
+            }
+            while ($xml->read()) {
+                $xmlName = self::getXmlName($xml);
+                if ($xmlName == 'table:table' && $xml->nodeType == XMLReader::ELEMENT) {
+                    do {
+                        $worksheetName = $xml->getAttribute('table:name');
+                        if (!empty($worksheetName)) {
+                            $worksheetNames[] = $worksheetName;
+                        }
+                        $xml->next();
+                    } while (self::getXmlName($xml) == 'table:table' && $xml->nodeType == XMLReader::ELEMENT);
+                }
+            }
+        }
+        return $worksheetNames;
+    }
+    /**
+     * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
+     */
+    public function listWorksheetInfo(string $filename): array
+    {
+        File::assertFile($filename, self::INITIAL_FILE);
+        $worksheetInfo = [];
+        $xml = new XMLReader();
+        $xml->xml(
+            $this->getSecurityScannerOrThrow()->scanFile('zip://' . realpath($filename) . '#' . self::INITIAL_FILE),
+            null,
+            Settings::getLibXmlLoaderOptions()
+        );
+        $xml->setParserProperty(2, true);
+        $xml->read();
+        while ($xml->read()) {
+            while (self::getXmlName($xml) !== 'office:body') {
+                if ($xml->isEmptyElement) {
+                    $xml->read();
+                } else {
+                    $xml->next();
+                }
+            }
+            while ($xml->read()) {
+                if (self::getXmlName($xml) == 'table:table' && $xml->nodeType == XMLReader::ELEMENT) {
+                    $worksheetNames[] = $xml->getAttribute('table:name');
+                    $tmpInfo = [
+                        'worksheetName' => $xml->getAttribute('table:name'),
+                        'lastColumnLetter' => 'A',
+                        'lastColumnIndex' => 0,
+                        'totalRows' => 0,
+                        'totalColumns' => 0,
+                    ];
+                    $currCells = 0;
+                    do {
+                        $xml->read();
+                        if (self::getXmlName($xml) == 'table:table-row' && $xml->nodeType == XMLReader::ELEMENT) {
+                            $rowspan = $xml->getAttribute('table:number-rows-repeated');
+                            $rowspan = empty($rowspan) ? 1 : $rowspan;
+                            $tmpInfo['totalRows'] += $rowspan;
+                            $tmpInfo['totalColumns'] = max($tmpInfo['totalColumns'], $currCells);
+                            $currCells = 0;
+                            $xml->read();
+                            do {
+                                $doread = true;
+                                if (self::getXmlName($xml) == 'table:table-cell' && $xml->nodeType == XMLReader::ELEMENT) {
+                                    if (!$xml->isEmptyElement) {
+                                        ++$currCells;
+                                        $xml->next();
+                                        $doread = false;
+                                    }
+                                } elseif (self::getXmlName($xml) == 'table:covered-table-cell' && $xml->nodeType == XMLReader::ELEMENT) {
+                                    $mergeSize = $xml->getAttribute('table:number-columns-repeated');
+                                    $currCells += (int) $mergeSize;
+                                }
+                                if ($doread) {
+                                    $xml->read();
+                                }
+                            } while (self::getXmlName($xml) != 'table:table-row');
+                        }
+                    } while (self::getXmlName($xml) != 'table:table');
+                    $tmpInfo['totalColumns'] = max($tmpInfo['totalColumns'], $currCells);
+                    $tmpInfo['lastColumnIndex'] = $tmpInfo['totalColumns'] - 1;
+                    $tmpInfo['lastColumnLetter'] = Coordinate::stringFromColumnIndex($tmpInfo['lastColumnIndex'] + 1);
+                    $worksheetInfo[] = $tmpInfo;
+                }
+            }
+        }
+        return $worksheetInfo;
+    }
+    /**
+     * Counteract Phpstan caching.
+     *
+     * @phpstan-impure
+     */
+    private static function getXmlName(XMLReader $xml): string
+    {
+        return $xml->name;
+    }
+    /**
+     * Loads PhpSpreadsheet from file.
+     */
+    protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
+    {
+        $spreadsheet = new Spreadsheet();
+        $spreadsheet->removeSheetByIndex(0);
+        return $this->loadIntoExisting($filename, $spreadsheet);
+    }
+    /**
+     * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
+     */
+    public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
+    {
+        File::assertFile($filename, self::INITIAL_FILE);
+        $zip = new ZipArchive();
+        $zip->open($filename);
+        $xml = @simplexml_load_string(
+            $this->getSecurityScannerOrThrow()->scan($zip->getFromName('meta.xml')),
+            'SimpleXMLElement',
+            Settings::getLibXmlLoaderOptions()
+        );
+        if ($xml === false) {
+            throw new Exception('Unable to read data from {$pFilename}');
+        }
+        $namespacesMeta = $xml->getNamespaces(true);
+        (new DocumentProperties($spreadsheet))->load($xml, $namespacesMeta);
+        $dom = new DOMDocument('1.01', 'UTF-8');
+        $dom->loadXML(
+            $this->getSecurityScannerOrThrow()->scan($zip->getFromName('styles.xml')),
+            Settings::getLibXmlLoaderOptions()
+        );
+        $pageSettings = new PageSettings($dom);
+        $dom = new DOMDocument('1.01', 'UTF-8');
+        $dom->loadXML(
+            $this->getSecurityScannerOrThrow()->scan($zip->getFromName(self::INITIAL_FILE)),
+            Settings::getLibXmlLoaderOptions()
+        );
+        $officeNs = (string) $dom->lookupNamespaceUri('office');
+        $tableNs = (string) $dom->lookupNamespaceUri('table');
+        $textNs = (string) $dom->lookupNamespaceUri('text');
+        $xlinkNs = (string) $dom->lookupNamespaceUri('xlink');
+        $styleNs = (string) $dom->lookupNamespaceUri('style');
+        $pageSettings->readStyleCrossReferences($dom);
+        $autoFilterReader = new AutoFilter($spreadsheet, $tableNs);
+        $definedNameReader = new DefinedNames($spreadsheet, $tableNs);
+        $columnWidths = [];
+        $automaticStyle0 = $dom->getElementsByTagNameNS($officeNs, 'automatic-styles')->item(0);
+        $automaticStyles = ($automaticStyle0 === null) ? [] : $automaticStyle0->getElementsByTagNameNS($styleNs, 'style');
+        foreach ($automaticStyles as $automaticStyle) {
+            $styleName = $automaticStyle->getAttributeNS($styleNs, 'name');
+            $styleFamily = $automaticStyle->getAttributeNS($styleNs, 'family');
+            if ($styleFamily === 'table-column') {
+                $tcprops = $automaticStyle->getElementsByTagNameNS($styleNs, 'table-column-properties');
+                if ($tcprops !== null) {
+                    $tcprop = $tcprops->item(0);
+                    if ($tcprop !== null) {
+                        $columnWidth = $tcprop->getAttributeNs($styleNs, 'column-width');
+                        $columnWidths[$styleName] = $columnWidth;
+                    }
+                }
+            }
+        }
+        $item0 = $dom->getElementsByTagNameNS($officeNs, 'body')->item(0);
+        $spreadsheets = ($item0 === null) ? [] : $item0->getElementsByTagNameNS($officeNs, 'spreadsheet');
+        foreach ($spreadsheets as $workbookData) {
+            /** @var DOMElement $workbookData */
+            $tables = $workbookData->getElementsByTagNameNS($tableNs, 'table');
+            $worksheetID = 0;
+            foreach ($tables as $worksheetDataSet) {
+                /** @var DOMElement $worksheetDataSet */
+                $worksheetName = $worksheetDataSet->getAttributeNS($tableNs, 'name');
+                if (
+                    $this->loadSheetsOnly !== null
+                    && $worksheetName
+                    && !in_array($worksheetName, $this->loadSheetsOnly)
+                ) {
+                    continue;
+                }
+                $worksheetStyleName = $worksheetDataSet->getAttributeNS($tableNs, 'style-name');
+                $spreadsheet->createSheet();
+                $spreadsheet->setActiveSheetIndex($worksheetID);
+                if ($worksheetName || is_numeric($worksheetName)) {
+                    $spreadsheet->getActiveSheet()->setTitle((string) $worksheetName, false, false);
+                }
+                $rowID = 1;
+                $tableColumnIndex = 1;
+                foreach ($worksheetDataSet->childNodes as $childNode) {
+                    /** @var DOMElement $childNode */
+                    if ($childNode->namespaceURI != $tableNs) {
+                        continue;
+                    }
+                    $key = $childNode->nodeName;
+                    if (str_contains($key, ':')) {
+                        $keyChunks = explode(':', $key);
+                        $key = array_pop($keyChunks);
+                    }
+                    switch ($key) {
+                        case 'table-header-rows':
+                            break;
+                        case 'table-column':
+                            if ($childNode->hasAttributeNS($tableNs, 'number-columns-repeated')) {
+                                $rowRepeats = (int) $childNode->getAttributeNS($tableNs, 'number-columns-repeated');
+                            } else {
+                                $rowRepeats = 1;
+                            }
+                            $tableStyleName = $childNode->getAttributeNS($tableNs, 'style-name');
+                            if (isset($columnWidths[$tableStyleName])) {
+                                $columnWidth = new HelperDimension($columnWidths[$tableStyleName]);
+                                $tableColumnString = Coordinate::stringFromColumnIndex($tableColumnIndex);
+                                for ($rowRepeats2 = $rowRepeats; $rowRepeats2 > 0; --$rowRepeats2) {
+                                    $spreadsheet->getActiveSheet()
+                                        ->getColumnDimension($tableColumnString)
+                                        ->setWidth($columnWidth->toUnit('cm'), 'cm');
+                                    ++$tableColumnString;
+                                }
+                            }
+                            $tableColumnIndex += $rowRepeats;
+                            break;
+                        case 'table-row':
+                            if ($childNode->hasAttributeNS($tableNs, 'number-rows-repeated')) {
+                                $rowRepeats = (int) $childNode->getAttributeNS($tableNs, 'number-rows-repeated');
+                            } else {
+                                $rowRepeats = 1;
+                            }
+                            $columnID = 'A';
+                            /** @var DOMElement|DOMText $cellData */
+                            foreach ($childNode->childNodes as $cellData) {
+                                if ($cellData instanceof DOMText) {
+                                    continue; // should just be whitespace
+                                }
+                                if ($this->getReadFilter() !== null) {
+                                    if (!$this->getReadFilter()->readCell($columnID, $rowID, $worksheetName)) {
+                                        if ($cellData->hasAttributeNS($tableNs, 'number-columns-repeated')) {
+                                            $colRepeats = (int) $cellData->getAttributeNS($tableNs, 'number-columns-repeated');
+                                        } else {
+                                            $colRepeats = 1;
+                                        }
+                                        for ($i = 0; $i < $colRepeats; ++$i) {
+                                            ++$columnID;
+                                        }
+                                        continue;
+                                    }
+                                }
+                                $formatting = $hyperlink = null;
+                                $hasCalculatedValue = false;
+                                $cellDataFormula = '';
+                                if ($cellData->hasAttributeNS($tableNs, 'formula')) {
+                                    $cellDataFormula = $cellData->getAttributeNS($tableNs, 'formula');
+                                    $hasCalculatedValue = true;
+                                }
+                                $annotation = $cellData->getElementsByTagNameNS($officeNs, 'annotation');
+                                if ($annotation->length > 0 && $annotation->item(0) !== null) {
+                                    $textNode = $annotation->item(0)->getElementsByTagNameNS($textNs, 'p');
+                                    $textNodeLength = $textNode->length;
+                                    $newLineOwed = false;
+                                    for ($textNodeIndex = 0; $textNodeIndex < $textNodeLength; ++$textNodeIndex) {
+                                        $textNodeItem = $textNode->item($textNodeIndex);
+                                        if ($textNodeItem !== null) {
+                                            $text = $this->scanElementForText($textNodeItem);
+                                            if ($newLineOwed) {
+                                                $spreadsheet->getActiveSheet()
+                                                    ->getComment($columnID . $rowID)
+                                                    ->getText()
+                                                    ->createText("\n");
+                                            }
+                                            $newLineOwed = true;
+                                            $spreadsheet->getActiveSheet()
+                                                ->getComment($columnID . $rowID)
+                                                ->getText()
+                                                ->createText($this->parseRichText($text));
+                                        }
+                                    }
+                                }
+                                /** @var DOMElement[] $paragraphs */
+                                $paragraphs = [];
+                                foreach ($cellData->childNodes as $item) {
+                                    /** @var DOMElement $item */
+                                    if ($item->nodeName == 'text:p') {
+                                        $paragraphs[] = $item;
+                                    }
+                                }
+                                if (count($paragraphs) > 0) {
+                                    $dataArray = [];
+                                    foreach ($paragraphs as $pData) {
+                                        $dataArray[] = $this->scanElementForText($pData);
+                                    }
+                                    $allCellDataText = implode("\n", $dataArray);
+                                    $type = $cellData->getAttributeNS($officeNs, 'value-type');
+                                    switch ($type) {
+                                        case 'string':
+                                            $type = DataType::TYPE_STRING;
+                                            $dataValue = $allCellDataText;
+                                            foreach ($paragraphs as $paragraph) {
+                                                $link = $paragraph->getElementsByTagNameNS($textNs, 'a');
+                                                if ($link->length > 0 && $link->item(0) !== null) {
+                                                    $hyperlink = $link->item(0)->getAttributeNS($xlinkNs, 'href');
+                                                }
+                                            }
+                                            break;
+                                        case 'boolean':
+                                            $type = DataType::TYPE_BOOL;
+                                            $dataValue = ($cellData->getAttributeNS($officeNs, 'boolean-value') === 'true') ? true : false;
+                                            break;
+                                        case 'percentage':
+                                            $type = DataType::TYPE_NUMERIC;
+                                            $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
+                                            $formatting = NumberFormat::FORMAT_PERCENTAGE_00;
+                                            break;
+                                        case 'currency':
+                                            $type = DataType::TYPE_NUMERIC;
+                                            $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
+                                            if (floor($dataValue) == $dataValue) {
+                                                $dataValue = (int) $dataValue;
+                                            }
+                                            $formatting = NumberFormat::FORMAT_CURRENCY_USD_INTEGER;
+                                            break;
+                                        case 'float':
+                                            $type = DataType::TYPE_NUMERIC;
+                                            $dataValue = (float) $cellData->getAttributeNS($officeNs, 'value');
+                                            if (floor($dataValue) == $dataValue) {
+                                                if ($dataValue == (int) $dataValue) {
+                                                    $dataValue = (int) $dataValue;
+                                                }
+                                            }
+                                            break;
+                                        case 'date':
+                                            $type = DataType::TYPE_NUMERIC;
+                                            $value = $cellData->getAttributeNS($officeNs, 'date-value');
+                                            $dataValue = Date::convertIsoDate($value);
+                                            if ($dataValue != floor($dataValue)) {
+                                                $formatting = NumberFormat::FORMAT_DATE_XLSX15
+                                                    . ' '
+                                                    . NumberFormat::FORMAT_DATE_TIME4;
+                                            } else {
+                                                $formatting = NumberFormat::FORMAT_DATE_XLSX15;
+                                            }
+                                            break;
+                                        case 'time':
+                                            $type = DataType::TYPE_NUMERIC;
+                                            $timeValue = $cellData->getAttributeNS($officeNs, 'time-value');
+                                            $dataValue = Date::PHPToExcel(
+                                                strtotime(
+                                                    '01-01-1970 ' . implode(':', sscanf($timeValue, 'PT%dH%dM%dS') ?? [])
+                                                )
+                                            );
+                                            $formatting = NumberFormat::FORMAT_DATE_TIME4;
+                                            break;
+                                        default:
+                                            $dataValue = null;
+                                    }
+                                } else {
+                                    $type = DataType::TYPE_NULL;
+                                    $dataValue = null;
+                                }
+                                if ($hasCalculatedValue) {
+                                    $type = DataType::TYPE_FORMULA;
+                                    $cellDataFormula = substr($cellDataFormula, strpos($cellDataFormula, ':=') + 1);
+                                    $cellDataFormula = FormulaTranslator::convertToExcelFormulaValue($cellDataFormula);
+                                }
+                                if ($cellData->hasAttributeNS($tableNs, 'number-columns-repeated')) {
+                                    $colRepeats = (int) $cellData->getAttributeNS($tableNs, 'number-columns-repeated');
+                                } else {
+                                    $colRepeats = 1;
+                                }
+                                if ($type !== null) {
+                                    for ($i = 0; $i < $colRepeats; ++$i) {
+                                        if ($i > 0) {
+                                            ++$columnID;
+                                        }
+                                        if ($type !== DataType::TYPE_NULL) {
+                                            for ($rowAdjust = 0; $rowAdjust < $rowRepeats; ++$rowAdjust) {
+                                                $rID = $rowID + $rowAdjust;
+                                                $cell = $spreadsheet->getActiveSheet()
+                                                    ->getCell($columnID . $rID);
+                                                if ($hasCalculatedValue) {
+                                                    $cell->setValueExplicit($cellDataFormula, $type);
+                                                } else {
+                                                    $cell->setValueExplicit($dataValue, $type);
+                                                }
+                                                if ($hasCalculatedValue) {
+                                                    $cell->setCalculatedValue($dataValue, $type === DataType::TYPE_NUMERIC);
+                                                }
+                                                if ($formatting !== null) {
+                                                    $spreadsheet->getActiveSheet()
+                                                        ->getStyle($columnID . $rID)
+                                                        ->getNumberFormat()
+                                                        ->setFormatCode($formatting);
+                                                } else {
+                                                    $spreadsheet->getActiveSheet()
+                                                        ->getStyle($columnID . $rID)
+                                                        ->getNumberFormat()
+                                                        ->setFormatCode(NumberFormat::FORMAT_GENERAL);
+                                                }
+                                                if ($hyperlink !== null) {
+                                                    if ($hyperlink[0] === '#') {
+                                                        $hyperlink = 'sheet://' . substr($hyperlink, 1);
+                                                    }
+                                                    $cell->getHyperlink()
+                                                        ->setUrl($hyperlink);
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                                $this->processMergedCells($cellData, $tableNs, $type, $columnID, $rowID, $spreadsheet);
+                                ++$columnID;
+                            }
+                            $rowID += $rowRepeats;
+                            break;
+                    }
+                }
+                $pageSettings->setVisibilityForWorksheet($spreadsheet->getActiveSheet(), $worksheetStyleName);
+                $pageSettings->setPrintSettingsForWorksheet($spreadsheet->getActiveSheet(), $worksheetStyleName);
+                ++$worksheetID;
+            }
+            $autoFilterReader->read($workbookData);
+            $definedNameReader->read($workbookData);
+        }
+        $spreadsheet->setActiveSheetIndex(0);
+        if ($zip->locateName('settings.xml') !== false) {
+            $this->processSettings($zip, $spreadsheet);
+        }
+        return $spreadsheet;
+    }
+    private function processSettings(ZipArchive $zip, Spreadsheet $spreadsheet): void
+    {
+        $dom = new DOMDocument('1.01', 'UTF-8');
+        $dom->loadXML(
+            $this->getSecurityScannerOrThrow()->scan($zip->getFromName('settings.xml')),
+            Settings::getLibXmlLoaderOptions()
+        );
+        $configNs = (string) $dom->lookupNamespaceUri('config');
+        $officeNs = (string) $dom->lookupNamespaceUri('office');
+        $settings = $dom->getElementsByTagNameNS($officeNs, 'settings')
+            ->item(0);
+        if ($settings !== null) {
+            $this->lookForActiveSheet($settings, $spreadsheet, $configNs);
+            $this->lookForSelectedCells($settings, $spreadsheet, $configNs);
+        }
+    }
+    private function lookForActiveSheet(DOMElement $settings, Spreadsheet $spreadsheet, string $configNs): void
+    {
+        /** @var DOMElement $t */
+        foreach ($settings->getElementsByTagNameNS($configNs, 'config-item') as $t) {
+            if ($t->getAttributeNs($configNs, 'name') === 'ActiveTable') {
+                try {
+                    $spreadsheet->setActiveSheetIndexByName($t->nodeValue ?? '');
+                } catch (Throwable) {
+                }
+                break;
+            }
+        }
+    }
+    private function lookForSelectedCells(DOMElement $settings, Spreadsheet $spreadsheet, string $configNs): void
+    {
+        /** @var DOMElement $t */
+        foreach ($settings->getElementsByTagNameNS($configNs, 'config-item-map-named') as $t) {
+            if ($t->getAttributeNs($configNs, 'name') === 'Tables') {
+                foreach ($t->getElementsByTagNameNS($configNs, 'config-item-map-entry') as $ws) {
+                    $setRow = $setCol = '';
+                    $wsname = $ws->getAttributeNs($configNs, 'name');
+                    foreach ($ws->getElementsByTagNameNS($configNs, 'config-item') as $configItem) {
+                        $attrName = $configItem->getAttributeNs($configNs, 'name');
+                        if ($attrName === 'CursorPositionX') {
+                            $setCol = $configItem->nodeValue;
+                        }
+                        if ($attrName === 'CursorPositionY') {
+                            $setRow = $configItem->nodeValue;
+                        }
+                    }
+                    $this->setSelected($spreadsheet, $wsname, "$setCol", "$setRow");
+                }
+                break;
+            }
+        }
+    }
+    private function setSelected(Spreadsheet $spreadsheet, string $wsname, string $setCol, string $setRow): void
+    {
+        if (is_numeric($setCol) && is_numeric($setRow)) {
+            $sheet = $spreadsheet->getSheetByName($wsname);
+            if ($sheet !== null) {
+                $sheet->setSelectedCells([(int) $setCol + 1, (int) $setRow + 1]);
+            }
+        }
+    }
+    /**
+     * Recursively scan element.
+     */
+    protected function scanElementForText(DOMNode $element): string
+    {
+        $str = '';
+        foreach ($element->childNodes as $child) {
+            /** @var DOMNode $child */
+            if ($child->nodeType == XML_TEXT_NODE) {
+                $str .= $child->nodeValue;
+            } elseif ($child->nodeType == XML_ELEMENT_NODE && $child->nodeName == 'text:line-break') {
+                $str .= "\n";
+            } elseif ($child->nodeType == XML_ELEMENT_NODE && $child->nodeName == 'text:s') {
+                $attributes = $child->attributes;
+                /** @var ?DOMAttr $cAttr */
+                $cAttr = ($attributes === null) ? null : $attributes->getNamedItem('c');
+                $multiplier = self::getMultiplier($cAttr);
+                $str .= str_repeat(' ', $multiplier);
+            }
+            if ($child->hasChildNodes()) {
+                $str .= $this->scanElementForText($child);
+            }
+        }
+        return $str;
+    }
+    private static function getMultiplier(?DOMAttr $cAttr): int
+    {
+        if ($cAttr) {
+            $multiplier = (int) $cAttr->nodeValue;
+        } else {
+            $multiplier = 1;
+        }
+        return $multiplier;
+    }
+    private function parseRichText(string $is): RichText
+    {
+        $value = new RichText();
+        $value->createText($is);
+        return $value;
+    }
+    private function processMergedCells(
+        DOMElement $cellData,
+        string $tableNs,
+        string $type,
+        string $columnID,
+        int $rowID,
+        Spreadsheet $spreadsheet
+    ): void {
+        if (
+            $cellData->hasAttributeNS($tableNs, 'number-columns-spanned')
+            || $cellData->hasAttributeNS($tableNs, 'number-rows-spanned')
+        ) {
+            if (($type !== DataType::TYPE_NULL) || ($this->readDataOnly === false)) {
+                $columnTo = $columnID;
+                if ($cellData->hasAttributeNS($tableNs, 'number-columns-spanned')) {
+                    $columnIndex = Coordinate::columnIndexFromString($columnID);
+                    $columnIndex += (int) $cellData->getAttributeNS($tableNs, 'number-columns-spanned');
+                    $columnIndex -= 2;
+                    $columnTo = Coordinate::stringFromColumnIndex($columnIndex + 1);
+                }
+                $rowTo = $rowID;
+                if ($cellData->hasAttributeNS($tableNs, 'number-rows-spanned')) {
+                    $rowTo = $rowTo + (int) $cellData->getAttributeNS($tableNs, 'number-rows-spanned') - 1;
+                }
+                $cellRange = $columnID . $rowID . ':' . $columnTo . $rowTo;
+                $spreadsheet->getActiveSheet()->mergeCells($cellRange, Worksheet::MERGE_CELL_CONTENT_HIDE);
+            }
+        }
+    }
+}

--- a/src/PhpSpreadsheet/Reader/Security/XmlScanner.php
+++ b//dev/null
@@ -1,76 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Reader\Security;
-use PhpOffice\PhpSpreadsheet\Reader;
-class XmlScanner
-{
-    private string $pattern;
-    /** @var ?callable */
-    private $callback;
-    public function __construct(string $pattern = '<!DOCTYPE')
-    {
-        $this->pattern = $pattern;
-    }
-    public static function getInstance(Reader\IReader $reader): self
-    {
-        $pattern = ($reader instanceof Reader\Html) ? '<!ENTITY' : '<!DOCTYPE';
-        return new self($pattern);
-    }
-    public function setAdditionalCallback(callable $callback): void
-    {
-        $this->callback = $callback;
-    }
-    private static function forceString(mixed $arg): string
-    {
-        return is_string($arg) ? $arg : '';
-    }
-    private function toUtf8(string $xml): string
-    {
-        $charset = $this->findCharSet($xml);
-        if ($charset !== 'UTF-8') {
-            $xml = self::forceString(mb_convert_encoding($xml, 'UTF-8', $charset));
-            $charset = $this->findCharSet($xml);
-            if ($charset !== 'UTF-8') {
-                throw new Reader\Exception('Suspicious Double-encoded XML, spreadsheet file load() aborted to prevent XXE/XEE attacks');
-            }
-        }
-        return $xml;
-    }
-    private function findCharSet(string $xml): string
-    {
-        $patterns = [
-            '/encoding\\s*=\\s*"([^"]*]?)"/',
-            "/encoding\\s*=\\s*'([^']*?)'/",
-        ];
-        foreach ($patterns as $pattern) {
-            if (preg_match($pattern, $xml, $matches)) {
-                return strtoupper($matches[1]);
-            }
-        }
-        return 'UTF-8';
-    }
-    /**
-     * Scan the XML for use of <!ENTITY to prevent XXE/XEE attacks.
-     *
-     * @param false|string $xml
-     */
-    public function scan($xml): string
-    {
-        $xml = "$xml";
-        $xml = $this->toUtf8($xml);
-        $pattern = '/\\0?' . implode('\\0?', str_split($this->pattern)) . '\\0?/';
-        if (preg_match($pattern, $xml)) {
-            throw new Reader\Exception('Detected use of ENTITY in XML, spreadsheet file load() aborted to prevent XXE/XEE attacks');
-        }
-        if ($this->callback !== null) {
-            $xml = call_user_func($this->callback, $xml);
-        }
-        return $xml;
-    }
-    /**
-     * Scan theXML for use of <!ENTITY to prevent XXE/XEE attacks.
-     */
-    public function scanFile(string $filestream): string
-    {
-        return $this->scan(file_get_contents($filestream));
-    }
-}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Slk.php
@@ -0,0 +1,445 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Reader\Exception as ReaderException;
+use PhpOffice\PhpSpreadsheet\ReferenceHelper;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Border;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+class Slk extends BaseReader
+{
+    /**
+     * Sheet index to read.
+     */
+    private int $sheetIndex = 0;
+    /**
+     * Formats.
+     */
+    private array $formats = [];
+    /**
+     * Format Count.
+     */
+    private int $format = 0;
+    /**
+     * Fonts.
+     */
+    private array $fonts = [];
+    /**
+     * Font Count.
+     */
+    private int $fontcount = 0;
+    /**
+     * Create a new SYLK Reader instance.
+     */
+    public function __construct()
+    {
+        parent::__construct();
+    }
+    /**
+     * Validate that the current file is a SYLK file.
+     */
+    public function canRead(string $filename): bool
+    {
+        try {
+            $this->openFile($filename);
+        } catch (ReaderException) {
+            return false;
+        }
+        $data = (string) fread($this->fileHandle, 2048);
+        $delimiterCount = substr_count($data, ';');
+        $hasDelimiter = $delimiterCount > 0;
+        $lines = explode("\n", $data);
+        $hasId = str_starts_with($lines[0], 'ID;P');
+        fclose($this->fileHandle);
+        return $hasDelimiter && $hasId;
+    }
+    private function canReadOrBust(string $filename): void
+    {
+        if (!$this->canRead($filename)) {
+            throw new ReaderException($filename . ' is an Invalid SYLK file.');
+        }
+        $this->openFile($filename);
+    }
+    /**
+     * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
+     */
+    public function listWorksheetInfo(string $filename): array
+    {
+        $this->canReadOrBust($filename);
+        $fileHandle = $this->fileHandle;
+        rewind($fileHandle);
+        $worksheetInfo = [];
+        $worksheetInfo[0]['worksheetName'] = basename($filename, '.slk');
+        $rowIndex = 0;
+        $columnIndex = 0;
+        while (($rowData = fgets($fileHandle)) !== false) {
+            $columnIndex = 0;
+            $rowData = StringHelper::SYLKtoUTF8($rowData);
+            $rowData = explode("\t", str_replace('¤', ';', str_replace(';', "\t", str_replace(';;', '¤', rtrim($rowData)))));
+            $dataType = array_shift($rowData);
+            if ($dataType == 'B') {
+                foreach ($rowData as $rowDatum) {
+                    switch ($rowDatum[0]) {
+                        case 'X':
+                            $columnIndex = (int) substr($rowDatum, 1) - 1;
+                            break;
+                        case 'Y':
+                            $rowIndex = (int) substr($rowDatum, 1);
+                            break;
+                    }
+                }
+                break;
+            }
+        }
+        $worksheetInfo[0]['lastColumnIndex'] = $columnIndex;
+        $worksheetInfo[0]['totalRows'] = $rowIndex;
+        $worksheetInfo[0]['lastColumnLetter'] = Coordinate::stringFromColumnIndex($worksheetInfo[0]['lastColumnIndex'] + 1);
+        $worksheetInfo[0]['totalColumns'] = $worksheetInfo[0]['lastColumnIndex'] + 1;
+        fclose($fileHandle);
+        return $worksheetInfo;
+    }
+    /**
+     * Loads PhpSpreadsheet from file.
+     */
+    protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
+    {
+        $spreadsheet = new Spreadsheet();
+        return $this->loadIntoExisting($filename, $spreadsheet);
+    }
+    private const COLOR_ARRAY = [
+        'FF00FFFF', // 0 - cyan
+        'FF000000', // 1 - black
+        'FFFFFFFF', // 2 - white
+        'FFFF0000', // 3 - red
+        'FF00FF00', // 4 - green
+        'FF0000FF', // 5 - blue
+        'FFFFFF00', // 6 - yellow
+        'FFFF00FF', // 7 - magenta
+    ];
+    private const FONT_STYLE_MAPPINGS = [
+        'B' => 'bold',
+        'I' => 'italic',
+        'U' => 'underline',
+    ];
+    private function processFormula(string $rowDatum, bool &$hasCalculatedValue, string &$cellDataFormula, string $row, string $column): void
+    {
+        $cellDataFormula = '=' . substr($rowDatum, 1);
+        $temp = explode('"', $cellDataFormula);
+        $key = false;
+        foreach ($temp as &$value) {
+            $key = $key === false;
+            if ($key) {
+                preg_match_all('/(R(\[?-?\d*\]?))(C(\[?-?\d*\]?))/', $value, $cellReferences, PREG_SET_ORDER + PREG_OFFSET_CAPTURE);
+                $cellReferences = array_reverse($cellReferences);
+                foreach ($cellReferences as $cellReference) {
+                    $rowReference = $cellReference[2][0];
+                    if ($rowReference == '') {
+                        $rowReference = $row;
+                    }
+                    if ($rowReference[0] == '[') {
+                        $rowReference = (int) $row + (int) trim($rowReference, '[]');
+                    }
+                    $columnReference = $cellReference[4][0];
+                    if ($columnReference == '') {
+                        $columnReference = $column;
+                    }
+                    if ($columnReference[0] == '[') {
+                        $columnReference = (int) $column + (int) trim($columnReference, '[]');
+                    }
+                    $A1CellReference = Coordinate::stringFromColumnIndex((int) $columnReference) . $rowReference;
+                    $value = substr_replace($value, $A1CellReference, $cellReference[0][1], strlen($cellReference[0][0]));
+                }
+            }
+        }
+        unset($value);
+        $cellDataFormula = implode('"', $temp);
+        $hasCalculatedValue = true;
+    }
+    private function processCRecord(array $rowData, Spreadsheet &$spreadsheet, string &$row, string &$column): void
+    {
+        $hasCalculatedValue = false;
+        $tryNumeric = false;
+        $cellDataFormula = $cellData = '';
+        $sharedColumn = $sharedRow = -1;
+        $sharedFormula = false;
+        foreach ($rowData as $rowDatum) {
+            switch ($rowDatum[0]) {
+                case 'X':
+                    $column = substr($rowDatum, 1);
+                    break;
+                case 'Y':
+                    $row = substr($rowDatum, 1);
+                    break;
+                case 'K':
+                    $cellData = substr($rowDatum, 1);
+                    $tryNumeric = is_numeric($cellData);
+                    break;
+                case 'E':
+                    $this->processFormula($rowDatum, $hasCalculatedValue, $cellDataFormula, $row, $column);
+                    break;
+                case 'A':
+                    $comment = substr($rowDatum, 1);
+                    $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
+                    $spreadsheet->getActiveSheet()
+                        ->getComment("$columnLetter$row")
+                        ->getText()
+                        ->createText($comment);
+                    break;
+                case 'C':
+                    $sharedColumn = (int) substr($rowDatum, 1);
+                    break;
+                case 'R':
+                    $sharedRow = (int) substr($rowDatum, 1);
+                    break;
+                case 'S':
+                    $sharedFormula = true;
+                    break;
+            }
+        }
+        if ($sharedFormula === true && $sharedRow >= 0 && $sharedColumn >= 0) {
+            $thisCoordinate = Coordinate::stringFromColumnIndex((int) $column) . $row;
+            $sharedCoordinate = Coordinate::stringFromColumnIndex($sharedColumn) . $sharedRow;
+            /** @var string */
+            $formula = $spreadsheet->getActiveSheet()->getCell($sharedCoordinate)->getValue();
+            $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setValue($formula);
+            $referenceHelper = ReferenceHelper::getInstance();
+            $newFormula = $referenceHelper->updateFormulaReferences($formula, 'A1', (int) $column - $sharedColumn, (int) $row - $sharedRow, '', true, false);
+            $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setValue($newFormula);
+            $cellData = Calculation::unwrapResult($cellData);
+            $spreadsheet->getActiveSheet()->getCell($thisCoordinate)->setCalculatedValue($cellData, $tryNumeric);
+            return;
+        }
+        $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
+        /** @var string */
+        $cellData = Calculation::unwrapResult($cellData);
+        $this->processCFinal($spreadsheet, $hasCalculatedValue, $cellDataFormula, $cellData, "$columnLetter$row", $tryNumeric);
+    }
+    private function processCFinal(Spreadsheet &$spreadsheet, bool $hasCalculatedValue, string $cellDataFormula, string $cellData, string $coordinate, bool $tryNumeric): void
+    {
+        $spreadsheet->getActiveSheet()->getCell($coordinate)->setValue(($hasCalculatedValue) ? $cellDataFormula : $cellData);
+        if ($hasCalculatedValue) {
+            $cellData = Calculation::unwrapResult($cellData);
+            $spreadsheet->getActiveSheet()->getCell($coordinate)->setCalculatedValue($cellData, $tryNumeric);
+        }
+    }
+    private function processFRecord(array $rowData, Spreadsheet &$spreadsheet, string &$row, string &$column): void
+    {
+        $formatStyle = $columnWidth = '';
+        $startCol = $endCol = '';
+        $fontStyle = '';
+        $styleData = [];
+        foreach ($rowData as $rowDatum) {
+            switch ($rowDatum[0]) {
+                case 'C':
+                case 'X':
+                    $column = substr($rowDatum, 1);
+                    break;
+                case 'R':
+                case 'Y':
+                    $row = substr($rowDatum, 1);
+                    break;
+                case 'P':
+                    $formatStyle = $rowDatum;
+                    break;
+                case 'W':
+                    [$startCol, $endCol, $columnWidth] = explode(' ', substr($rowDatum, 1));
+                    break;
+                case 'S':
+                    $this->styleSettings($rowDatum, $styleData, $fontStyle);
+                    break;
+            }
+        }
+        $this->addFormats($spreadsheet, $formatStyle, $row, $column);
+        $this->addFonts($spreadsheet, $fontStyle, $row, $column);
+        $this->addStyle($spreadsheet, $styleData, $row, $column);
+        $this->addWidth($spreadsheet, $columnWidth, $startCol, $endCol);
+    }
+    private const STYLE_SETTINGS_FONT = ['D' => 'bold', 'I' => 'italic'];
+    private const STYLE_SETTINGS_BORDER = [
+        'B' => 'bottom',
+        'L' => 'left',
+        'R' => 'right',
+        'T' => 'top',
+    ];
+    private function styleSettings(string $rowDatum, array &$styleData, string &$fontStyle): void
+    {
+        $styleSettings = substr($rowDatum, 1);
+        $iMax = strlen($styleSettings);
+        for ($i = 0; $i < $iMax; ++$i) {
+            $char = $styleSettings[$i];
+            if (array_key_exists($char, self::STYLE_SETTINGS_FONT)) {
+                $styleData['font'][self::STYLE_SETTINGS_FONT[$char]] = true;
+            } elseif (array_key_exists($char, self::STYLE_SETTINGS_BORDER)) {
+                $styleData['borders'][self::STYLE_SETTINGS_BORDER[$char]]['borderStyle'] = Border::BORDER_THIN;
+            } elseif ($char == 'S') {
+                $styleData['fill']['fillType'] = Fill::FILL_PATTERN_GRAY125;
+            } elseif ($char == 'M') {
+                if (preg_match('/M([1-9]\\d*)/', $styleSettings, $matches)) {
+                    $fontStyle = $matches[1];
+                }
+            }
+        }
+    }
+    private function addFormats(Spreadsheet &$spreadsheet, string $formatStyle, string $row, string $column): void
+    {
+        if ($formatStyle && $column > '' && $row > '') {
+            $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
+            if (isset($this->formats[$formatStyle])) {
+                $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($this->formats[$formatStyle]);
+            }
+        }
+    }
+    private function addFonts(Spreadsheet &$spreadsheet, string $fontStyle, string $row, string $column): void
+    {
+        if ($fontStyle && $column > '' && $row > '') {
+            $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
+            if (isset($this->fonts[$fontStyle])) {
+                $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($this->fonts[$fontStyle]);
+            }
+        }
+    }
+    private function addStyle(Spreadsheet &$spreadsheet, array $styleData, string $row, string $column): void
+    {
+        if ((!empty($styleData)) && $column > '' && $row > '') {
+            $columnLetter = Coordinate::stringFromColumnIndex((int) $column);
+            $spreadsheet->getActiveSheet()->getStyle($columnLetter . $row)->applyFromArray($styleData);
+        }
+    }
+    private function addWidth(Spreadsheet $spreadsheet, string $columnWidth, string $startCol, string $endCol): void
+    {
+        if ($columnWidth > '') {
+            if ($startCol == $endCol) {
+                $startCol = Coordinate::stringFromColumnIndex((int) $startCol);
+                $spreadsheet->getActiveSheet()->getColumnDimension($startCol)->setWidth((float) $columnWidth);
+            } else {
+                $startCol = Coordinate::stringFromColumnIndex((int) $startCol);
+                $endCol = Coordinate::stringFromColumnIndex((int) $endCol);
+                $spreadsheet->getActiveSheet()->getColumnDimension($startCol)->setWidth((float) $columnWidth);
+                do {
+                    $spreadsheet->getActiveSheet()->getColumnDimension((string) ++$startCol)->setWidth((float) $columnWidth);
+                } while ($startCol !== $endCol);
+            }
+        }
+    }
+    private function processPRecord(array $rowData, Spreadsheet &$spreadsheet): void
+    {
+        $formatArray = [];
+        $fromFormats = ['\-', '\ '];
+        $toFormats = ['-', ' '];
+        foreach ($rowData as $rowDatum) {
+            switch ($rowDatum[0]) {
+                case 'P':
+                    $formatArray['numberFormat']['formatCode'] = str_replace($fromFormats, $toFormats, substr($rowDatum, 1));
+                    break;
+                case 'E':
+                case 'F':
+                    $formatArray['font']['name'] = substr($rowDatum, 1);
+                    break;
+                case 'M':
+                    $formatArray['font']['size'] = ((float) substr($rowDatum, 1)) / 20;
+                    break;
+                case 'L':
+                    $this->processPColors($rowDatum, $formatArray);
+                    break;
+                case 'S':
+                    $this->processPFontStyles($rowDatum, $formatArray);
+                    break;
+            }
+        }
+        $this->processPFinal($spreadsheet, $formatArray);
+    }
+    private function processPColors(string $rowDatum, array &$formatArray): void
+    {
+        if (preg_match('/L([1-9]\\d*)/', $rowDatum, $matches)) {
+            $fontColor = $matches[1] % 8;
+            $formatArray['font']['color']['argb'] = self::COLOR_ARRAY[$fontColor];
+        }
+    }
+    private function processPFontStyles(string $rowDatum, array &$formatArray): void
+    {
+        $styleSettings = substr($rowDatum, 1);
+        $iMax = strlen($styleSettings);
+        for ($i = 0; $i < $iMax; ++$i) {
+            if (array_key_exists($styleSettings[$i], self::FONT_STYLE_MAPPINGS)) {
+                $formatArray['font'][self::FONT_STYLE_MAPPINGS[$styleSettings[$i]]] = true;
+            }
+        }
+    }
+    private function processPFinal(Spreadsheet &$spreadsheet, array $formatArray): void
+    {
+        if (array_key_exists('numberFormat', $formatArray)) {
+            $this->formats['P' . $this->format] = $formatArray;
+            ++$this->format;
+        } elseif (array_key_exists('font', $formatArray)) {
+            ++$this->fontcount;
+            $this->fonts[$this->fontcount] = $formatArray;
+            if ($this->fontcount === 1) {
+                $spreadsheet->getDefaultStyle()->applyFromArray($formatArray);
+            }
+        }
+    }
+    /**
+     * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
+     */
+    public function loadIntoExisting(string $filename, Spreadsheet $spreadsheet): Spreadsheet
+    {
+        $this->canReadOrBust($filename);
+        $fileHandle = $this->fileHandle;
+        rewind($fileHandle);
+        while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
+            $spreadsheet->createSheet();
+        }
+        $spreadsheet->setActiveSheetIndex($this->sheetIndex);
+        $spreadsheet->getActiveSheet()->setTitle(substr(basename($filename, '.slk'), 0, Worksheet::SHEET_TITLE_MAXIMUM_LENGTH));
+        $column = $row = '';
+        while (($rowDataTxt = fgets($fileHandle)) !== false) {
+            $rowDataTxt = StringHelper::SYLKtoUTF8($rowDataTxt);
+            $rowData = explode("\t", str_replace('¤', ';', str_replace(';', "\t", str_replace(';;', '¤', rtrim($rowDataTxt)))));
+            $dataType = array_shift($rowData);
+            if ($dataType == 'P') {
+                $this->processPRecord($rowData, $spreadsheet);
+            } elseif ($dataType == 'C') {
+                $this->processCRecord($rowData, $spreadsheet, $row, $column);
+            } elseif ($dataType == 'F') {
+                $this->processFRecord($rowData, $spreadsheet, $row, $column);
+            } else {
+                $this->columnRowFromRowData($rowData, $column, $row);
+            }
+        }
+        fclose($fileHandle);
+        return $spreadsheet;
+    }
+    private function columnRowFromRowData(array $rowData, string &$column, string &$row): void
+    {
+        foreach ($rowData as $rowDatum) {
+            $char0 = $rowDatum[0];
+            if ($char0 === 'X' || $char0 == 'C') {
+                $column = substr($rowDatum, 1);
+            } elseif ($char0 === 'Y' || $char0 == 'R') {
+                $row = substr($rowDatum, 1);
+            }
+        }
+    }
+    /**
+     * Get sheet index.
+     */
+    public function getSheetIndex(): int
+    {
+        return $this->sheetIndex;
+    }
+    /**
+     * Set sheet index.
+     *
+     * @param int $sheetIndex Sheet index
+     *
+     * @return $this
+     */
+    public function setSheetIndex(int $sheetIndex): static
+    {
+        $this->sheetIndex = $sheetIndex;
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Xls.php
@@ -0,0 +1,5315 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Cell\DataValidation;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\NamedRange;
+use PhpOffice\PhpSpreadsheet\Reader\Xls\ConditionalFormatting;
+use PhpOffice\PhpSpreadsheet\Reader\Xls\Style\CellFont;
+use PhpOffice\PhpSpreadsheet\Reader\Xls\Style\FillPattern;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Shared\CodePage;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\Escher;
+use PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer\SpContainer;
+use PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE;
+use PhpOffice\PhpSpreadsheet\Shared\File;
+use PhpOffice\PhpSpreadsheet\Shared\OLE;
+use PhpOffice\PhpSpreadsheet\Shared\OLERead;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Shared\Xls as SharedXls;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Alignment;
+use PhpOffice\PhpSpreadsheet\Style\Border;
+use PhpOffice\PhpSpreadsheet\Style\Borders;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Font;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Style\Protection;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
+use PhpOffice\PhpSpreadsheet\Worksheet\PageSetup;
+use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+class Xls extends BaseReader
+{
+    private const HIGH_ORDER_BIT = 0x80 << 24;
+    private const FC000000 = 0xFC << 24;
+    private const FE000000 = 0xFE << 24;
+    const XLS_BIFF8 = 0x0600;
+    const XLS_BIFF7 = 0x0500;
+    const XLS_WORKBOOKGLOBALS = 0x0005;
+    const XLS_WORKSHEET = 0x0010;
+    const XLS_TYPE_FORMULA = 0x0006;
+    const XLS_TYPE_EOF = 0x000A;
+    const XLS_TYPE_PROTECT = 0x0012;
+    const XLS_TYPE_OBJECTPROTECT = 0x0063;
+    const XLS_TYPE_SCENPROTECT = 0x00DD;
+    const XLS_TYPE_PASSWORD = 0x0013;
+    const XLS_TYPE_HEADER = 0x0014;
+    const XLS_TYPE_FOOTER = 0x0015;
+    const XLS_TYPE_EXTERNSHEET = 0x0017;
+    const XLS_TYPE_DEFINEDNAME = 0x0018;
+    const XLS_TYPE_VERTICALPAGEBREAKS = 0x001A;
+    const XLS_TYPE_HORIZONTALPAGEBREAKS = 0x001B;
+    const XLS_TYPE_NOTE = 0x001C;
+    const XLS_TYPE_SELECTION = 0x001D;
+    const XLS_TYPE_DATEMODE = 0x0022;
+    const XLS_TYPE_EXTERNNAME = 0x0023;
+    const XLS_TYPE_LEFTMARGIN = 0x0026;
+    const XLS_TYPE_RIGHTMARGIN = 0x0027;
+    const XLS_TYPE_TOPMARGIN = 0x0028;
+    const XLS_TYPE_BOTTOMMARGIN = 0x0029;
+    const XLS_TYPE_PRINTGRIDLINES = 0x002B;
+    const XLS_TYPE_FILEPASS = 0x002F;
+    const XLS_TYPE_FONT = 0x0031;
+    const XLS_TYPE_CONTINUE = 0x003C;
+    const XLS_TYPE_PANE = 0x0041;
+    const XLS_TYPE_CODEPAGE = 0x0042;
+    const XLS_TYPE_DEFCOLWIDTH = 0x0055;
+    const XLS_TYPE_OBJ = 0x005D;
+    const XLS_TYPE_COLINFO = 0x007D;
+    const XLS_TYPE_IMDATA = 0x007F;
+    const XLS_TYPE_SHEETPR = 0x0081;
+    const XLS_TYPE_HCENTER = 0x0083;
+    const XLS_TYPE_VCENTER = 0x0084;
+    const XLS_TYPE_SHEET = 0x0085;
+    const XLS_TYPE_PALETTE = 0x0092;
+    const XLS_TYPE_SCL = 0x00A0;
+    const XLS_TYPE_PAGESETUP = 0x00A1;
+    const XLS_TYPE_MULRK = 0x00BD;
+    const XLS_TYPE_MULBLANK = 0x00BE;
+    const XLS_TYPE_DBCELL = 0x00D7;
+    const XLS_TYPE_XF = 0x00E0;
+    const XLS_TYPE_MERGEDCELLS = 0x00E5;
+    const XLS_TYPE_MSODRAWINGGROUP = 0x00EB;
+    const XLS_TYPE_MSODRAWING = 0x00EC;
+    const XLS_TYPE_SST = 0x00FC;
+    const XLS_TYPE_LABELSST = 0x00FD;
+    const XLS_TYPE_EXTSST = 0x00FF;
+    const XLS_TYPE_EXTERNALBOOK = 0x01AE;
+    const XLS_TYPE_DATAVALIDATIONS = 0x01B2;
+    const XLS_TYPE_TXO = 0x01B6;
+    const XLS_TYPE_HYPERLINK = 0x01B8;
+    const XLS_TYPE_DATAVALIDATION = 0x01BE;
+    const XLS_TYPE_DIMENSION = 0x0200;
+    const XLS_TYPE_BLANK = 0x0201;
+    const XLS_TYPE_NUMBER = 0x0203;
+    const XLS_TYPE_LABEL = 0x0204;
+    const XLS_TYPE_BOOLERR = 0x0205;
+    const XLS_TYPE_STRING = 0x0207;
+    const XLS_TYPE_ROW = 0x0208;
+    const XLS_TYPE_INDEX = 0x020B;
+    const XLS_TYPE_ARRAY = 0x0221;
+    const XLS_TYPE_DEFAULTROWHEIGHT = 0x0225;
+    const XLS_TYPE_WINDOW2 = 0x023E;
+    const XLS_TYPE_RK = 0x027E;
+    const XLS_TYPE_STYLE = 0x0293;
+    const XLS_TYPE_FORMAT = 0x041E;
+    const XLS_TYPE_SHAREDFMLA = 0x04BC;
+    const XLS_TYPE_BOF = 0x0809;
+    const XLS_TYPE_SHEETPROTECTION = 0x0867;
+    const XLS_TYPE_RANGEPROTECTION = 0x0868;
+    const XLS_TYPE_SHEETLAYOUT = 0x0862;
+    const XLS_TYPE_XFEXT = 0x087D;
+    const XLS_TYPE_PAGELAYOUTVIEW = 0x088B;
+    const XLS_TYPE_CFHEADER = 0x01B0;
+    const XLS_TYPE_CFRULE = 0x01B1;
+    const XLS_TYPE_UNKNOWN = 0xFFFF;
+    const MS_BIFF_CRYPTO_NONE = 0;
+    const MS_BIFF_CRYPTO_XOR = 1;
+    const MS_BIFF_CRYPTO_RC4 = 2;
+    const REKEY_BLOCK = 0x400;
+    const BORDER_STYLE_MAP = [
+        Border::BORDER_NONE, // => 0x00,
+        Border::BORDER_THIN,  // => 0x01,
+        Border::BORDER_MEDIUM, // => 0x02,
+        Border::BORDER_DASHED, // => 0x03,
+        Border::BORDER_DOTTED,  // => 0x04,
+        Border::BORDER_THICK, // => 0x05,
+        Border::BORDER_DOUBLE, // => 0x06,
+        Border::BORDER_HAIR, // => 0x07,
+        Border::BORDER_MEDIUMDASHED, // => 0x08,
+        Border::BORDER_DASHDOT, // => 0x09,
+        Border::BORDER_MEDIUMDASHDOT, // => 0x0A,
+        Border::BORDER_DASHDOTDOT, // => 0x0B,
+        Border::BORDER_MEDIUMDASHDOTDOT, // => 0x0C,
+        Border::BORDER_SLANTDASHDOT, // => 0x0D,
+        Border::BORDER_OMIT, // => 0x0E,
+        Border::BORDER_OMIT, // => 0x0F,
+    ];
+    /**
+     * Summary Information stream data.
+     */
+    private ?string $summaryInformation = null;
+    /**
+     * Extended Summary Information stream data.
+     */
+    private ?string $documentSummaryInformation = null;
+    /**
+     * Workbook stream data. (Includes workbook globals substream as well as sheet substreams).
+     */
+    private string $data;
+    /**
+     * Size in bytes of $this->data.
+     */
+    private int $dataSize;
+    /**
+     * Current position in stream.
+     */
+    private int $pos;
+    /**
+     * Workbook to be returned by the reader.
+     */
+    private Spreadsheet $spreadsheet;
+    /**
+     * Worksheet that is currently being built by the reader.
+     */
+    private Worksheet $phpSheet;
+    /**
+     * BIFF version.
+     */
+    private int $version = 0;
+    /**
+     * Codepage set in the Excel file being read. Only important for BIFF5 (Excel 5.0 - Excel 95)
+     * For BIFF8 (Excel 97 - Excel 2003) this will always have the value 'UTF-16LE'.
+     */
+    private string $codepage = '';
+    /**
+     * Shared formats.
+     */
+    private array $formats;
+    /**
+     * Shared fonts.
+     *
+     * @var Font[]
+     */
+    private array $objFonts;
+    /**
+     * Color palette.
+     */
+    private array $palette;
+    /**
+     * Worksheets.
+     */
+    private array $sheets;
+    /**
+     * External books.
+     */
+    private array $externalBooks;
+    /**
+     * REF structures. Only applies to BIFF8.
+     */
+    private array $ref;
+    /**
+     * External names.
+     */
+    private array $externalNames;
+    /**
+     * Defined names.
+     */
+    private array $definedname;
+    /**
+     * Shared strings. Only applies to BIFF8.
+     */
+    private array $sst;
+    /**
+     * Panes are frozen? (in sheet currently being read). See WINDOW2 record.
+     */
+    private bool $frozen;
+    /**
+     * Fit printout to number of pages? (in sheet currently being read). See SHEETPR record.
+     */
+    private bool $isFitToPages;
+    /**
+     * Objects. One OBJ record contributes with one entry.
+     */
+    private array $objs;
+    /**
+     * Text Objects. One TXO record corresponds with one entry.
+     */
+    private array $textObjects;
+    /**
+     * Cell Annotations (BIFF8).
+     */
+    private array $cellNotes;
+    /**
+     * The combined MSODRAWINGGROUP data.
+     */
+    private string $drawingGroupData;
+    /**
+     * The combined MSODRAWING data (per sheet).
+     */
+    private string $drawingData;
+    /**
+     * Keep track of XF index.
+     */
+    private int $xfIndex;
+    /**
+     * Mapping of XF index (that is a cell XF) to final index in cellXf collection.
+     */
+    private array $mapCellXfIndex;
+    /**
+     * Mapping of XF index (that is a style XF) to final index in cellStyleXf collection.
+     */
+    private array $mapCellStyleXfIndex;
+    /**
+     * The shared formulas in a sheet. One SHAREDFMLA record contributes with one value.
+     */
+    private array $sharedFormulas;
+    /**
+     * The shared formula parts in a sheet. One FORMULA record contributes with one value if it
+     * refers to a shared formula.
+     */
+    private array $sharedFormulaParts;
+    /**
+     * The type of encryption in use.
+     */
+    private int $encryption = 0;
+    /**
+     * The position in the stream after which contents are encrypted.
+     */
+    private int $encryptionStartPos = 0;
+    /**
+     * The current RC4 decryption object.
+     *
+     * @var ?Xls\RC4
+     */
+    private ?Xls\RC4 $rc4Key = null;
+    /**
+     * The position in the stream that the RC4 decryption object was left at.
+     */
+    private int $rc4Pos = 0;
+    /**
+     * The current MD5 context state.
+     * It is never set in the program, so code which uses it is suspect.
+     */
+    private string $md5Ctxt; // @phpstan-ignore-line
+    private int $textObjRef;
+    private string $baseCell;
+    private bool $activeSheetSet = false;
+    /**
+     * Create a new Xls Reader instance.
+     */
+    public function __construct()
+    {
+        parent::__construct();
+    }
+    /**
+     * Can the current IReader read the file?
+     */
+    public function canRead(string $filename): bool
+    {
+        if (File::testFileNoThrow($filename) === false) {
+            return false;
+        }
+        try {
+            $ole = new OLERead();
+            $ole->read($filename);
+            if ($ole->wrkbook === null) {
+                throw new Exception('The filename ' . $filename . ' is not recognised as a Spreadsheet file');
+            }
+            return true;
+        } catch (PhpSpreadsheetException) {
+            return false;
+        }
+    }
+    public function setCodepage(string $codepage): void
+    {
+        if (CodePage::validate($codepage) === false) {
+            throw new PhpSpreadsheetException('Unknown codepage: ' . $codepage);
+        }
+        $this->codepage = $codepage;
+    }
+    public function getCodepage(): string
+    {
+        return $this->codepage;
+    }
+    /**
+     * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
+     */
+    public function listWorksheetNames(string $filename): array
+    {
+        File::assertFile($filename);
+        $worksheetNames = [];
+        $this->loadOLE($filename);
+        $this->dataSize = strlen($this->data);
+        $this->pos = 0;
+        $this->sheets = [];
+        while ($this->pos < $this->dataSize) {
+            $code = self::getUInt2d($this->data, $this->pos);
+            match ($code) {
+                self::XLS_TYPE_BOF => $this->readBof(),
+                self::XLS_TYPE_SHEET => $this->readSheet(),
+                self::XLS_TYPE_EOF => $this->readDefault(),
+                self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
+                default => $this->readDefault(),
+            };
+            if ($code === self::XLS_TYPE_EOF) {
+                break;
+            }
+        }
+        foreach ($this->sheets as $sheet) {
+            if ($sheet['sheetType'] != 0x00) {
+                continue;
+            }
+            $worksheetNames[] = $sheet['name'];
+        }
+        return $worksheetNames;
+    }
+    /**
+     * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
+     */
+    public function listWorksheetInfo(string $filename): array
+    {
+        File::assertFile($filename);
+        $worksheetInfo = [];
+        $this->loadOLE($filename);
+        $this->dataSize = strlen($this->data);
+        $this->pos = 0;
+        $this->sheets = [];
+        while ($this->pos < $this->dataSize) {
+            $code = self::getUInt2d($this->data, $this->pos);
+            match ($code) {
+                self::XLS_TYPE_BOF => $this->readBof(),
+                self::XLS_TYPE_SHEET => $this->readSheet(),
+                self::XLS_TYPE_EOF => $this->readDefault(),
+                self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
+                default => $this->readDefault(),
+            };
+            if ($code === self::XLS_TYPE_EOF) {
+                break;
+            }
+        }
+        foreach ($this->sheets as $sheet) {
+            if ($sheet['sheetType'] != 0x00) {
+                continue;
+            }
+            $tmpInfo = [];
+            $tmpInfo['worksheetName'] = $sheet['name'];
+            $tmpInfo['lastColumnLetter'] = 'A';
+            $tmpInfo['lastColumnIndex'] = 0;
+            $tmpInfo['totalRows'] = 0;
+            $tmpInfo['totalColumns'] = 0;
+            $this->pos = $sheet['offset'];
+            while ($this->pos <= $this->dataSize - 4) {
+                $code = self::getUInt2d($this->data, $this->pos);
+                switch ($code) {
+                    case self::XLS_TYPE_RK:
+                    case self::XLS_TYPE_LABELSST:
+                    case self::XLS_TYPE_NUMBER:
+                    case self::XLS_TYPE_FORMULA:
+                    case self::XLS_TYPE_BOOLERR:
+                    case self::XLS_TYPE_LABEL:
+                        $length = self::getUInt2d($this->data, $this->pos + 2);
+                        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+                        $this->pos += 4 + $length;
+                        $rowIndex = self::getUInt2d($recordData, 0) + 1;
+                        $columnIndex = self::getUInt2d($recordData, 2);
+                        $tmpInfo['totalRows'] = max($tmpInfo['totalRows'], $rowIndex);
+                        $tmpInfo['lastColumnIndex'] = max($tmpInfo['lastColumnIndex'], $columnIndex);
+                        break;
+                    case self::XLS_TYPE_BOF:
+                        $this->readBof();
+                        break;
+                    case self::XLS_TYPE_EOF:
+                        $this->readDefault();
+                        break 2;
+                    default:
+                        $this->readDefault();
+                        break;
+                }
+            }
+            $tmpInfo['lastColumnLetter'] = Coordinate::stringFromColumnIndex($tmpInfo['lastColumnIndex'] + 1);
+            $tmpInfo['totalColumns'] = $tmpInfo['lastColumnIndex'] + 1;
+            $worksheetInfo[] = $tmpInfo;
+        }
+        return $worksheetInfo;
+    }
+    /**
+     * Loads PhpSpreadsheet from file.
+     */
+    protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
+    {
+        $this->loadOLE($filename);
+        $this->spreadsheet = new Spreadsheet();
+        $this->spreadsheet->removeSheetByIndex(0); // remove 1st sheet
+        if (!$this->readDataOnly) {
+            $this->spreadsheet->removeCellStyleXfByIndex(0); // remove the default style
+            $this->spreadsheet->removeCellXfByIndex(0); // remove the default style
+        }
+        $this->readSummaryInformation();
+        $this->readDocumentSummaryInformation();
+        $this->dataSize = strlen($this->data);
+        $this->pos = 0;
+        $this->codepage = $this->codepage ?: CodePage::DEFAULT_CODE_PAGE;
+        $this->formats = [];
+        $this->objFonts = [];
+        $this->palette = [];
+        $this->sheets = [];
+        $this->externalBooks = [];
+        $this->ref = [];
+        $this->definedname = [];
+        $this->sst = [];
+        $this->drawingGroupData = '';
+        $this->xfIndex = 0;
+        $this->mapCellXfIndex = [];
+        $this->mapCellStyleXfIndex = [];
+        while ($this->pos < $this->dataSize) {
+            $code = self::getUInt2d($this->data, $this->pos);
+            match ($code) {
+                self::XLS_TYPE_BOF => $this->readBof(),
+                self::XLS_TYPE_FILEPASS => $this->readFilepass(),
+                self::XLS_TYPE_CODEPAGE => $this->readCodepage(),
+                self::XLS_TYPE_DATEMODE => $this->readDateMode(),
+                self::XLS_TYPE_FONT => $this->readFont(),
+                self::XLS_TYPE_FORMAT => $this->readFormat(),
+                self::XLS_TYPE_XF => $this->readXf(),
+                self::XLS_TYPE_XFEXT => $this->readXfExt(),
+                self::XLS_TYPE_STYLE => $this->readStyle(),
+                self::XLS_TYPE_PALETTE => $this->readPalette(),
+                self::XLS_TYPE_SHEET => $this->readSheet(),
+                self::XLS_TYPE_EXTERNALBOOK => $this->readExternalBook(),
+                self::XLS_TYPE_EXTERNNAME => $this->readExternName(),
+                self::XLS_TYPE_EXTERNSHEET => $this->readExternSheet(),
+                self::XLS_TYPE_DEFINEDNAME => $this->readDefinedName(),
+                self::XLS_TYPE_MSODRAWINGGROUP => $this->readMsoDrawingGroup(),
+                self::XLS_TYPE_SST => $this->readSst(),
+                self::XLS_TYPE_EOF => $this->readDefault(),
+                default => $this->readDefault(),
+            };
+            if ($code === self::XLS_TYPE_EOF) {
+                break;
+            }
+        }
+        if (!$this->readDataOnly) {
+            foreach ($this->objFonts as $objFont) {
+                if (isset($objFont->colorIndex)) {
+                    $color = Xls\Color::map($objFont->colorIndex, $this->palette, $this->version);
+                    $objFont->getColor()->setRGB($color['rgb']);
+                }
+            }
+            foreach ($this->spreadsheet->getCellXfCollection() as $objStyle) {
+                $fill = $objStyle->getFill();
+                if (isset($fill->startcolorIndex)) {
+                    $startColor = Xls\Color::map($fill->startcolorIndex, $this->palette, $this->version);
+                    $fill->getStartColor()->setRGB($startColor['rgb']);
+                }
+                if (isset($fill->endcolorIndex)) {
+                    $endColor = Xls\Color::map($fill->endcolorIndex, $this->palette, $this->version);
+                    $fill->getEndColor()->setRGB($endColor['rgb']);
+                }
+                $top = $objStyle->getBorders()->getTop();
+                $right = $objStyle->getBorders()->getRight();
+                $bottom = $objStyle->getBorders()->getBottom();
+                $left = $objStyle->getBorders()->getLeft();
+                $diagonal = $objStyle->getBorders()->getDiagonal();
+                if (isset($top->colorIndex)) {
+                    $borderTopColor = Xls\Color::map($top->colorIndex, $this->palette, $this->version);
+                    $top->getColor()->setRGB($borderTopColor['rgb']);
+                }
+                if (isset($right->colorIndex)) {
+                    $borderRightColor = Xls\Color::map($right->colorIndex, $this->palette, $this->version);
+                    $right->getColor()->setRGB($borderRightColor['rgb']);
+                }
+                if (isset($bottom->colorIndex)) {
+                    $borderBottomColor = Xls\Color::map($bottom->colorIndex, $this->palette, $this->version);
+                    $bottom->getColor()->setRGB($borderBottomColor['rgb']);
+                }
+                if (isset($left->colorIndex)) {
+                    $borderLeftColor = Xls\Color::map($left->colorIndex, $this->palette, $this->version);
+                    $left->getColor()->setRGB($borderLeftColor['rgb']);
+                }
+                if (isset($diagonal->colorIndex)) {
+                    $borderDiagonalColor = Xls\Color::map($diagonal->colorIndex, $this->palette, $this->version);
+                    $diagonal->getColor()->setRGB($borderDiagonalColor['rgb']);
+                }
+            }
+        }
+        $escherWorkbook = null;
+        if (!$this->readDataOnly && $this->drawingGroupData) {
+            $escher = new Escher();
+            $reader = new Xls\Escher($escher);
+            $escherWorkbook = $reader->load($this->drawingGroupData);
+        }
+        $this->activeSheetSet = false;
+        foreach ($this->sheets as $sheet) {
+            $selectedCells = '';
+            if ($sheet['sheetType'] != 0x00) {
+                continue;
+            }
+            if (isset($this->loadSheetsOnly) && !in_array($sheet['name'], $this->loadSheetsOnly)) {
+                continue;
+            }
+            $this->phpSheet = $this->spreadsheet->createSheet();
+            $this->phpSheet->setTitle($sheet['name'], false, false);
+            $this->phpSheet->setSheetState($sheet['sheetState']);
+            $this->pos = $sheet['offset'];
+            $this->isFitToPages = false;
+            $this->drawingData = '';
+            $this->objs = [];
+            $this->sharedFormulaParts = [];
+            $this->sharedFormulas = [];
+            $this->textObjects = [];
+            $this->cellNotes = [];
+            $this->textObjRef = -1;
+            while ($this->pos <= $this->dataSize - 4) {
+                $code = self::getUInt2d($this->data, $this->pos);
+                switch ($code) {
+                    case self::XLS_TYPE_BOF:
+                        $this->readBof();
+                        break;
+                    case self::XLS_TYPE_PRINTGRIDLINES:
+                        $this->readPrintGridlines();
+                        break;
+                    case self::XLS_TYPE_DEFAULTROWHEIGHT:
+                        $this->readDefaultRowHeight();
+                        break;
+                    case self::XLS_TYPE_SHEETPR:
+                        $this->readSheetPr();
+                        break;
+                    case self::XLS_TYPE_HORIZONTALPAGEBREAKS:
+                        $this->readHorizontalPageBreaks();
+                        break;
+                    case self::XLS_TYPE_VERTICALPAGEBREAKS:
+                        $this->readVerticalPageBreaks();
+                        break;
+                    case self::XLS_TYPE_HEADER:
+                        $this->readHeader();
+                        break;
+                    case self::XLS_TYPE_FOOTER:
+                        $this->readFooter();
+                        break;
+                    case self::XLS_TYPE_HCENTER:
+                        $this->readHcenter();
+                        break;
+                    case self::XLS_TYPE_VCENTER:
+                        $this->readVcenter();
+                        break;
+                    case self::XLS_TYPE_LEFTMARGIN:
+                        $this->readLeftMargin();
+                        break;
+                    case self::XLS_TYPE_RIGHTMARGIN:
+                        $this->readRightMargin();
+                        break;
+                    case self::XLS_TYPE_TOPMARGIN:
+                        $this->readTopMargin();
+                        break;
+                    case self::XLS_TYPE_BOTTOMMARGIN:
+                        $this->readBottomMargin();
+                        break;
+                    case self::XLS_TYPE_PAGESETUP:
+                        $this->readPageSetup();
+                        break;
+                    case self::XLS_TYPE_PROTECT:
+                        $this->readProtect();
+                        break;
+                    case self::XLS_TYPE_SCENPROTECT:
+                        $this->readScenProtect();
+                        break;
+                    case self::XLS_TYPE_OBJECTPROTECT:
+                        $this->readObjectProtect();
+                        break;
+                    case self::XLS_TYPE_PASSWORD:
+                        $this->readPassword();
+                        break;
+                    case self::XLS_TYPE_DEFCOLWIDTH:
+                        $this->readDefColWidth();
+                        break;
+                    case self::XLS_TYPE_COLINFO:
+                        $this->readColInfo();
+                        break;
+                    case self::XLS_TYPE_DIMENSION:
+                        $this->readDefault();
+                        break;
+                    case self::XLS_TYPE_ROW:
+                        $this->readRow();
+                        break;
+                    case self::XLS_TYPE_DBCELL:
+                        $this->readDefault();
+                        break;
+                    case self::XLS_TYPE_RK:
+                        $this->readRk();
+                        break;
+                    case self::XLS_TYPE_LABELSST:
+                        $this->readLabelSst();
+                        break;
+                    case self::XLS_TYPE_MULRK:
+                        $this->readMulRk();
+                        break;
+                    case self::XLS_TYPE_NUMBER:
+                        $this->readNumber();
+                        break;
+                    case self::XLS_TYPE_FORMULA:
+                        $this->readFormula();
+                        break;
+                    case self::XLS_TYPE_SHAREDFMLA:
+                        $this->readSharedFmla();
+                        break;
+                    case self::XLS_TYPE_BOOLERR:
+                        $this->readBoolErr();
+                        break;
+                    case self::XLS_TYPE_MULBLANK:
+                        $this->readMulBlank();
+                        break;
+                    case self::XLS_TYPE_LABEL:
+                        $this->readLabel();
+                        break;
+                    case self::XLS_TYPE_BLANK:
+                        $this->readBlank();
+                        break;
+                    case self::XLS_TYPE_MSODRAWING:
+                        $this->readMsoDrawing();
+                        break;
+                    case self::XLS_TYPE_OBJ:
+                        $this->readObj();
+                        break;
+                    case self::XLS_TYPE_WINDOW2:
+                        $this->readWindow2();
+                        break;
+                    case self::XLS_TYPE_PAGELAYOUTVIEW:
+                        $this->readPageLayoutView();
+                        break;
+                    case self::XLS_TYPE_SCL:
+                        $this->readScl();
+                        break;
+                    case self::XLS_TYPE_PANE:
+                        $this->readPane();
+                        break;
+                    case self::XLS_TYPE_SELECTION:
+                        $selectedCells = $this->readSelection();
+                        break;
+                    case self::XLS_TYPE_MERGEDCELLS:
+                        $this->readMergedCells();
+                        break;
+                    case self::XLS_TYPE_HYPERLINK:
+                        $this->readHyperLink();
+                        break;
+                    case self::XLS_TYPE_DATAVALIDATIONS:
+                        $this->readDataValidations();
+                        break;
+                    case self::XLS_TYPE_DATAVALIDATION:
+                        $this->readDataValidation();
+                        break;
+                    case self::XLS_TYPE_CFHEADER:
+                        $cellRangeAddresses = $this->readCFHeader();
+                        break;
+                    case self::XLS_TYPE_CFRULE:
+                        $this->readCFRule($cellRangeAddresses ?? []);
+                        break;
+                    case self::XLS_TYPE_SHEETLAYOUT:
+                        $this->readSheetLayout();
+                        break;
+                    case self::XLS_TYPE_SHEETPROTECTION:
+                        $this->readSheetProtection();
+                        break;
+                    case self::XLS_TYPE_RANGEPROTECTION:
+                        $this->readRangeProtection();
+                        break;
+                    case self::XLS_TYPE_NOTE:
+                        $this->readNote();
+                        break;
+                    case self::XLS_TYPE_TXO:
+                        $this->readTextObject();
+                        break;
+                    case self::XLS_TYPE_CONTINUE:
+                        $this->readContinue();
+                        break;
+                    case self::XLS_TYPE_EOF:
+                        $this->readDefault();
+                        break 2;
+                    default:
+                        $this->readDefault();
+                        break;
+                }
+            }
+            if (!$this->readDataOnly && $this->drawingData) {
+                $escherWorksheet = new Escher();
+                $reader = new Xls\Escher($escherWorksheet);
+                $escherWorksheet = $reader->load($this->drawingData);
+                /** @var SpContainer[] $allSpContainers */
+                $allSpContainers = method_exists($escherWorksheet, 'getDgContainer') ? $escherWorksheet->getDgContainer()->getSpgrContainer()->getAllSpContainers() : [];
+            }
+            foreach ($this->objs as $n => $obj) {
+                if (isset($allSpContainers[$n + 1])) {
+                    $spContainer = $allSpContainers[$n + 1];
+                    if ($spContainer->getNestingLevel() > 1) {
+                        continue;
+                    }
+                    /** @var int $startRow */
+                    [$startColumn, $startRow] = Coordinate::coordinateFromString($spContainer->getStartCoordinates());
+                    /** @var int $endRow */
+                    [$endColumn, $endRow] = Coordinate::coordinateFromString($spContainer->getEndCoordinates());
+                    $startOffsetX = $spContainer->getStartOffsetX();
+                    $startOffsetY = $spContainer->getStartOffsetY();
+                    $endOffsetX = $spContainer->getEndOffsetX();
+                    $endOffsetY = $spContainer->getEndOffsetY();
+                    $width = SharedXls::getDistanceX($this->phpSheet, $startColumn, $startOffsetX, $endColumn, $endOffsetX);
+                    $height = SharedXls::getDistanceY($this->phpSheet, $startRow, $startOffsetY, $endRow, $endOffsetY);
+                    $offsetX = (int) ($startOffsetX * SharedXls::sizeCol($this->phpSheet, $startColumn) / 1024);
+                    $offsetY = (int) ($startOffsetY * SharedXls::sizeRow($this->phpSheet, $startRow) / 256);
+                    switch ($obj['otObjType']) {
+                        case 0x19:
+                            if (isset($this->cellNotes[$obj['idObjID']])) {
+                                if (isset($this->textObjects[$obj['idObjID']])) {
+                                    $textObject = $this->textObjects[$obj['idObjID']];
+                                    $this->cellNotes[$obj['idObjID']]['objTextData'] = $textObject;
+                                }
+                            }
+                            break;
+                        case 0x08:
+                            $BSEindex = $spContainer->getOPT(0x0104);
+                            if (!$BSEindex) {
+                                continue 2;
+                            }
+                            if ($escherWorkbook) {
+                                $BSECollection = method_exists($escherWorkbook, 'getDggContainer') ? $escherWorkbook->getDggContainer()->getBstoreContainer()->getBSECollection() : [];
+                                $BSE = $BSECollection[$BSEindex - 1];
+                                $blipType = $BSE->getBlipType();
+                                if ($blip = $BSE->getBlip()) {
+                                    $ih = imagecreatefromstring($blip->getData());
+                                    if ($ih !== false) {
+                                        $drawing = new MemoryDrawing();
+                                        $drawing->setImageResource($ih);
+                                        $drawing->setResizeProportional(false);
+                                        $drawing->setWidth($width);
+                                        $drawing->setHeight($height);
+                                        $drawing->setOffsetX($offsetX);
+                                        $drawing->setOffsetY($offsetY);
+                                        switch ($blipType) {
+                                            case BSE::BLIPTYPE_JPEG:
+                                                $drawing->setRenderingFunction(MemoryDrawing::RENDERING_JPEG);
+                                                $drawing->setMimeType(MemoryDrawing::MIMETYPE_JPEG);
+                                                break;
+                                            case BSE::BLIPTYPE_PNG:
+                                                imagealphablending($ih, false);
+                                                imagesavealpha($ih, true);
+                                                $drawing->setRenderingFunction(MemoryDrawing::RENDERING_PNG);
+                                                $drawing->setMimeType(MemoryDrawing::MIMETYPE_PNG);
+                                                break;
+                                        }
+                                        $drawing->setWorksheet($this->phpSheet);
+                                        $drawing->setCoordinates($spContainer->getStartCoordinates());
+                                    }
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+            if ($this->version == self::XLS_BIFF8) {
+                foreach ($this->sharedFormulaParts as $cell => $baseCell) {
+                    /** @var int $row */
+                    [$column, $row] = Coordinate::coordinateFromString($cell);
+                    if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($column, $row, $this->phpSheet->getTitle())) {
+                        $formula = $this->getFormulaFromStructure($this->sharedFormulas[$baseCell], $cell);
+                        $this->phpSheet->getCell($cell)->setValueExplicit('=' . $formula, DataType::TYPE_FORMULA);
+                    }
+                }
+            }
+            if (!empty($this->cellNotes)) {
+                foreach ($this->cellNotes as $note => $noteDetails) {
+                    if (!isset($noteDetails['objTextData'])) {
+                        if (isset($this->textObjects[$note])) {
+                            $textObject = $this->textObjects[$note];
+                            $noteDetails['objTextData'] = $textObject;
+                        } else {
+                            $noteDetails['objTextData']['text'] = '';
+                        }
+                    }
+                    $cellAddress = str_replace('$', '', $noteDetails['cellRef']);
+                    $this->phpSheet->getComment($cellAddress)->setAuthor($noteDetails['author'])->setText($this->parseRichText($noteDetails['objTextData']['text']));
+                }
+            }
+            if ($selectedCells !== '') {
+                $this->phpSheet->setSelectedCells($selectedCells);
+            }
+        }
+        if ($this->activeSheetSet === false) {
+            $this->spreadsheet->setActiveSheetIndex(0);
+        }
+        foreach ($this->definedname as $definedName) {
+            if ($definedName['isBuiltInName']) {
+                switch ($definedName['name']) {
+                    case pack('C', 0x06):
+                        $ranges = explode(',', $definedName['formula']); // FIXME: what if sheetname contains comma?
+                        $extractedRanges = [];
+                        $sheetName = '';
+                        /** @var non-empty-string $range */
+                        foreach ($ranges as $range) {
+                            $explodes = Worksheet::extractSheetTitle($range, true);
+                            $sheetName = trim($explodes[0], "'");
+                            if (!str_contains($explodes[1], ':')) {
+                                $explodes[1] = $explodes[1] . ':' . $explodes[1];
+                            }
+                            $extractedRanges[] = str_replace('$', '', $explodes[1]); // C7:J66
+                        }
+                        if ($docSheet = $this->spreadsheet->getSheetByName($sheetName)) {
+                            $docSheet->getPageSetup()->setPrintArea(implode(',', $extractedRanges)); // C7:J66,A1:IV2
+                        }
+                        break;
+                    case pack('C', 0x07):
+                        $ranges = explode(',', $definedName['formula']); // FIXME: what if sheetname contains comma?
+                        foreach ($ranges as $range) {
+                            if (str_contains($range, '!')) {
+                                $explodes = Worksheet::extractSheetTitle($range, true);
+                                if ($docSheet = $this->spreadsheet->getSheetByName($explodes[0])) {
+                                    $extractedRange = $explodes[1];
+                                    $extractedRange = str_replace('$', '', $extractedRange);
+                                    $coordinateStrings = explode(':', $extractedRange);
+                                    if (count($coordinateStrings) == 2) {
+                                        [$firstColumn, $firstRow] = Coordinate::coordinateFromString($coordinateStrings[0]);
+                                        [$lastColumn, $lastRow] = Coordinate::coordinateFromString($coordinateStrings[1]);
+                                        if ($firstColumn == 'A' && $lastColumn == 'IV') {
+                                            $docSheet->getPageSetup()->setRowsToRepeatAtTop([$firstRow, $lastRow]);
+                                        } elseif ($firstRow == 1 && $lastRow == 65536) {
+                                            $docSheet->getPageSetup()->setColumnsToRepeatAtLeft([$firstColumn, $lastColumn]);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                }
+            } else {
+                /** @var non-empty-string $formula */
+                $formula = $definedName['formula'];
+                if (str_contains($formula, '!')) {
+                    $explodes = Worksheet::extractSheetTitle($formula, true);
+                    if (
+                        ($docSheet = $this->spreadsheet->getSheetByName($explodes[0]))
+                        || ($docSheet = $this->spreadsheet->getSheetByName(trim($explodes[0], "'")))
+                    ) {
+                        $extractedRange = $explodes[1];
+                        $localOnly = ($definedName['scope'] === 0) ? false : true;
+                        $scope = ($definedName['scope'] === 0) ? null : $this->spreadsheet->getSheetByName($this->sheets[$definedName['scope'] - 1]['name']);
+                        $this->spreadsheet->addNamedRange(new NamedRange((string) $definedName['name'], $docSheet, $extractedRange, $localOnly, $scope));
+                    }
+                }
+            }
+        }
+        $this->data = '';
+        return $this->spreadsheet;
+    }
+    /**
+     * Read record data from stream, decrypting as required.
+     *
+     * @param string $data Data stream to read from
+     * @param int $pos Position to start reading from
+     * @param int $len Record data length
+     *
+     * @return string Record data
+     */
+    private function readRecordData(string $data, int $pos, int $len): string
+    {
+        $data = substr($data, $pos, $len);
+        if ($this->encryption == self::MS_BIFF_CRYPTO_NONE || $pos < $this->encryptionStartPos) {
+            return $data;
+        }
+        $recordData = '';
+        if ($this->encryption == self::MS_BIFF_CRYPTO_RC4) {
+            $oldBlock = floor($this->rc4Pos / self::REKEY_BLOCK);
+            $block = (int) floor($pos / self::REKEY_BLOCK);
+            $endBlock = (int) floor(($pos + $len) / self::REKEY_BLOCK);
+            if ($block != $oldBlock || $pos < $this->rc4Pos || !$this->rc4Key) {
+                $this->rc4Key = $this->makeKey($block, $this->md5Ctxt);
+                $step = $pos % self::REKEY_BLOCK;
+            } else {
+                $step = $pos - $this->rc4Pos;
+            }
+            $this->rc4Key->RC4(str_repeat("\0", $step));
+            while ($block != $endBlock) {
+                $step = self::REKEY_BLOCK - ($pos % self::REKEY_BLOCK);
+                $recordData .= $this->rc4Key->RC4(substr($data, 0, $step));
+                $data = substr($data, $step);
+                $pos += $step;
+                $len -= $step;
+                ++$block;
+                $this->rc4Key = $this->makeKey($block, $this->md5Ctxt);
+            }
+            $recordData .= $this->rc4Key->RC4(substr($data, 0, $len));
+            $this->rc4Pos = $pos + $len;
+        } elseif ($this->encryption == self::MS_BIFF_CRYPTO_XOR) {
+            throw new Exception('XOr encryption not supported');
+        }
+        return $recordData;
+    }
+    /**
+     * Use OLE reader to extract the relevant data streams from the OLE file.
+     */
+    private function loadOLE(string $filename): void
+    {
+        $ole = new OLERead();
+        $ole->read($filename);
+        $this->data = $ole->getStream($ole->wrkbook); // @phpstan-ignore-line
+        $this->summaryInformation = $ole->getStream($ole->summaryInformation);
+        $this->documentSummaryInformation = $ole->getStream($ole->documentSummaryInformation);
+    }
+    /**
+     * Read summary information.
+     */
+    private function readSummaryInformation(): void
+    {
+        if (!isset($this->summaryInformation)) {
+            return;
+        }
+        $secOffset = self::getInt4d($this->summaryInformation, 44);
+        $countProperties = self::getInt4d($this->summaryInformation, $secOffset + 4);
+        $codePage = 'CP1252';
+        for ($i = 0; $i < $countProperties; ++$i) {
+            $id = self::getInt4d($this->summaryInformation, ($secOffset + 8) + (8 * $i));
+            $offset = self::getInt4d($this->summaryInformation, ($secOffset + 12) + (8 * $i));
+            $type = self::getInt4d($this->summaryInformation, $secOffset + $offset);
+            $value = null;
+            switch ($type) {
+                case 0x02: // 2 byte signed integer
+                    $value = self::getUInt2d($this->summaryInformation, $secOffset + 4 + $offset);
+                    break;
+                case 0x03: // 4 byte signed integer
+                    $value = self::getInt4d($this->summaryInformation, $secOffset + 4 + $offset);
+                    break;
+                case 0x13: // 4 byte unsigned integer
+                    break;
+                case 0x1E: // null-terminated string prepended by dword string length
+                    $byteLength = self::getInt4d($this->summaryInformation, $secOffset + 4 + $offset);
+                    $value = substr($this->summaryInformation, $secOffset + 8 + $offset, $byteLength);
+                    $value = StringHelper::convertEncoding($value, 'UTF-8', $codePage);
+                    $value = rtrim($value);
+                    break;
+                case 0x40: // Filetime (64-bit value representing the number of 100-nanosecond intervals since January 1, 1601)
+                    $value = OLE::OLE2LocalDate(substr($this->summaryInformation, $secOffset + 4 + $offset, 8));
+                    break;
+                case 0x47: // Clipboard format
+                    break;
+            }
+            switch ($id) {
+                case 0x01:    //    Code Page
+                    $codePage = CodePage::numberToName((int) $value);
+                    break;
+                case 0x02:    //    Title
+                    $this->spreadsheet->getProperties()->setTitle("$value");
+                    break;
+                case 0x03:    //    Subject
+                    $this->spreadsheet->getProperties()->setSubject("$value");
+                    break;
+                case 0x04:    //    Author (Creator)
+                    $this->spreadsheet->getProperties()->setCreator("$value");
+                    break;
+                case 0x05:    //    Keywords
+                    $this->spreadsheet->getProperties()->setKeywords("$value");
+                    break;
+                case 0x06:    //    Comments (Description)
+                    $this->spreadsheet->getProperties()->setDescription("$value");
+                    break;
+                case 0x07:    //    Template
+                    break;
+                case 0x08:    //    Last Saved By (LastModifiedBy)
+                    $this->spreadsheet->getProperties()->setLastModifiedBy("$value");
+                    break;
+                case 0x09:    //    Revision
+                    break;
+                case 0x0A:    //    Total Editing Time
+                    break;
+                case 0x0B:    //    Last Printed
+                    break;
+                case 0x0C:    //    Created Date/Time
+                    $this->spreadsheet->getProperties()->setCreated($value);
+                    break;
+                case 0x0D:    //    Modified Date/Time
+                    $this->spreadsheet->getProperties()->setModified($value);
+                    break;
+                case 0x0E:    //    Number of Pages
+                    break;
+                case 0x0F:    //    Number of Words
+                    break;
+                case 0x10:    //    Number of Characters
+                    break;
+                case 0x11:    //    Thumbnail
+                    break;
+                case 0x12:    //    Name of creating application
+                    break;
+                case 0x13:    //    Security
+                    break;
+            }
+        }
+    }
+    /**
+     * Read additional document summary information.
+     */
+    private function readDocumentSummaryInformation(): void
+    {
+        if (!isset($this->documentSummaryInformation)) {
+            return;
+        }
+        $secOffset = self::getInt4d($this->documentSummaryInformation, 44);
+        $countProperties = self::getInt4d($this->documentSummaryInformation, $secOffset + 4);
+        $codePage = 'CP1252';
+        for ($i = 0; $i < $countProperties; ++$i) {
+            $id = self::getInt4d($this->documentSummaryInformation, ($secOffset + 8) + (8 * $i));
+            $offset = self::getInt4d($this->documentSummaryInformation, ($secOffset + 12) + (8 * $i));
+            $type = self::getInt4d($this->documentSummaryInformation, $secOffset + $offset);
+            $value = null;
+            switch ($type) {
+                case 0x02:    //    2 byte signed integer
+                    $value = self::getUInt2d($this->documentSummaryInformation, $secOffset + 4 + $offset);
+                    break;
+                case 0x03:    //    4 byte signed integer
+                    $value = self::getInt4d($this->documentSummaryInformation, $secOffset + 4 + $offset);
+                    break;
+                case 0x0B:  // Boolean
+                    $value = self::getUInt2d($this->documentSummaryInformation, $secOffset + 4 + $offset);
+                    $value = ($value == 0 ? false : true);
+                    break;
+                case 0x13:    //    4 byte unsigned integer
+                    break;
+                case 0x1E:    //    null-terminated string prepended by dword string length
+                    $byteLength = self::getInt4d($this->documentSummaryInformation, $secOffset + 4 + $offset);
+                    $value = substr($this->documentSummaryInformation, $secOffset + 8 + $offset, $byteLength);
+                    $value = StringHelper::convertEncoding($value, 'UTF-8', $codePage);
+                    $value = rtrim($value);
+                    break;
+                case 0x40:    //    Filetime (64-bit value representing the number of 100-nanosecond intervals since January 1, 1601)
+                    $value = OLE::OLE2LocalDate(substr($this->documentSummaryInformation, $secOffset + 4 + $offset, 8));
+                    break;
+                case 0x47:    //    Clipboard format
+                    break;
+            }
+            switch ($id) {
+                case 0x01:    //    Code Page
+                    $codePage = CodePage::numberToName((int) $value);
+                    break;
+                case 0x02:    //    Category
+                    $this->spreadsheet->getProperties()->setCategory("$value");
+                    break;
+                case 0x03:    //    Presentation Target
+                    break;
+                case 0x04:    //    Bytes
+                    break;
+                case 0x05:    //    Lines
+                    break;
+                case 0x06:    //    Paragraphs
+                    break;
+                case 0x07:    //    Slides
+                    break;
+                case 0x08:    //    Notes
+                    break;
+                case 0x09:    //    Hidden Slides
+                    break;
+                case 0x0A:    //    MM Clips
+                    break;
+                case 0x0B:    //    Scale Crop
+                    break;
+                case 0x0C:    //    Heading Pairs
+                    break;
+                case 0x0D:    //    Titles of Parts
+                    break;
+                case 0x0E:    //    Manager
+                    $this->spreadsheet->getProperties()->setManager("$value");
+                    break;
+                case 0x0F:    //    Company
+                    $this->spreadsheet->getProperties()->setCompany("$value");
+                    break;
+                case 0x10:    //    Links up-to-date
+                    break;
+            }
+        }
+    }
+    /**
+     * Reads a general type of BIFF record. Does nothing except for moving stream pointer forward to next record.
+     */
+    private function readDefault(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $this->pos += 4 + $length;
+    }
+    /**
+     *    The NOTE record specifies a comment associated with a particular cell. In Excel 95 (BIFF7) and earlier versions,
+     *        this record stores a note (cell note). This feature was significantly enhanced in Excel 97.
+     */
+    private function readNote(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $cellAddress = $this->readBIFF8CellAddress(substr($recordData, 0, 4));
+        if ($this->version == self::XLS_BIFF8) {
+            $noteObjID = self::getUInt2d($recordData, 6);
+            $noteAuthor = self::readUnicodeStringLong(substr($recordData, 8));
+            $noteAuthor = $noteAuthor['value'];
+            $this->cellNotes[$noteObjID] = [
+                'cellRef' => $cellAddress,
+                'objectID' => $noteObjID,
+                'author' => $noteAuthor,
+            ];
+        } else {
+            $extension = false;
+            if ($cellAddress == '$B$65536') {
+                $extension = true;
+                $arrayKeys = array_keys($this->phpSheet->getComments());
+                $cellAddress = array_pop($arrayKeys);
+            }
+            $cellAddress = str_replace('$', '', (string) $cellAddress);
+            $noteText = trim(substr($recordData, 6));
+            if ($extension) {
+                $comment = $this->phpSheet->getComment($cellAddress);
+                $commentText = $comment->getText()->getPlainText();
+                $comment->setText($this->parseRichText($commentText . $noteText));
+            } else {
+                $this->phpSheet->getComment($cellAddress)->setText($this->parseRichText($noteText));
+            }
+        }
+    }
+    /**
+     * The TEXT Object record contains the text associated with a cell annotation.
+     */
+    private function readTextObject(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $grbitOpts = self::getUInt2d($recordData, 0);
+        $rot = self::getUInt2d($recordData, 2);
+        $cbRuns = self::getUInt2d($recordData, 12);
+        $text = $this->getSplicedRecordData();
+        $textByte = $text['spliceOffsets'][1] - $text['spliceOffsets'][0] - 1;
+        $textStr = substr($text['recordData'], $text['spliceOffsets'][0] + 1, $textByte);
+        $is16Bit = ord($text['recordData'][0]);
+        if (($is16Bit & 0x01) === 0) {
+            $textStr = StringHelper::ConvertEncoding($textStr, 'UTF-8', 'ISO-8859-1');
+        } else {
+            $textStr = $this->decodeCodepage($textStr);
+        }
+        $this->textObjects[$this->textObjRef] = [
+            'text' => $textStr,
+            'format' => substr($text['recordData'], $text['spliceOffsets'][1], $cbRuns),
+            'alignment' => $grbitOpts,
+            'rotation' => $rot,
+        ];
+    }
+    /**
+     * Read BOF.
+     */
+    private function readBof(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = substr($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $substreamType = self::getUInt2d($recordData, 2);
+        switch ($substreamType) {
+            case self::XLS_WORKBOOKGLOBALS:
+                $version = self::getUInt2d($recordData, 0);
+                if (($version != self::XLS_BIFF8) && ($version != self::XLS_BIFF7)) {
+                    throw new Exception('Cannot read this Excel file. Version is too old.');
+                }
+                $this->version = $version;
+                break;
+            case self::XLS_WORKSHEET:
+                break;
+            default:
+                do {
+                    $code = self::getUInt2d($this->data, $this->pos);
+                    $this->readDefault();
+                } while ($code != self::XLS_TYPE_EOF && $this->pos < $this->dataSize);
+                break;
+        }
+    }
+    /**
+     * FILEPASS.
+     *
+     * This record is part of the File Protection Block. It
+     * contains information about the read/write password of the
+     * file. All record contents following this record will be
+     * encrypted.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     *
+     * The decryption functions and objects used from here on in
+     * are based on the source of Spreadsheet-ParseExcel:
+     * https://metacpan.org/release/Spreadsheet-ParseExcel
+     */
+    private function readFilepass(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        if ($length != 54) {
+            throw new Exception('Unexpected file pass record length');
+        }
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->verifyPassword('VelvetSweatshop', substr($recordData, 6, 16), substr($recordData, 22, 16), substr($recordData, 38, 16), $this->md5Ctxt)) {
+            throw new Exception('Decryption password incorrect');
+        }
+        $this->encryption = self::MS_BIFF_CRYPTO_RC4;
+        $this->encryptionStartPos = $this->pos + self::getUInt2d($this->data, $this->pos + 2);
+    }
+    /**
+     * Make an RC4 decryptor for the given block.
+     *
+     * @param int $block Block for which to create decrypto
+     * @param string $valContext MD5 context state
+     */
+    private function makeKey(int $block, string $valContext): Xls\RC4
+    {
+        $pwarray = str_repeat("\0", 64);
+        for ($i = 0; $i < 5; ++$i) {
+            $pwarray[$i] = $valContext[$i];
+        }
+        $pwarray[5] = chr($block & 0xFF);
+        $pwarray[6] = chr(($block >> 8) & 0xFF);
+        $pwarray[7] = chr(($block >> 16) & 0xFF);
+        $pwarray[8] = chr(($block >> 24) & 0xFF);
+        $pwarray[9] = "\x80";
+        $pwarray[56] = "\x48";
+        $md5 = new Xls\MD5();
+        $md5->add($pwarray);
+        $s = $md5->getContext();
+        return new Xls\RC4($s);
+    }
+    /**
+     * Verify RC4 file password.
+     *
+     * @param string $password Password to check
+     * @param string $docid Document id
+     * @param string $salt_data Salt data
+     * @param string $hashedsalt_data Hashed salt data
+     * @param string $valContext Set to the MD5 context of the value
+     *
+     * @return bool Success
+     */
+    private function verifyPassword(string $password, string $docid, string $salt_data, string $hashedsalt_data, string &$valContext): bool
+    {
+        $pwarray = str_repeat("\0", 64);
+        $iMax = strlen($password);
+        for ($i = 0; $i < $iMax; ++$i) {
+            $o = ord(substr($password, $i, 1));
+            $pwarray[2 * $i] = chr($o & 0xFF);
+            $pwarray[2 * $i + 1] = chr(($o >> 8) & 0xFF);
+        }
+        $pwarray[2 * $i] = chr(0x80);
+        $pwarray[56] = chr(($i << 4) & 0xFF);
+        $md5 = new Xls\MD5();
+        $md5->add($pwarray);
+        $mdContext1 = $md5->getContext();
+        $offset = 0;
+        $keyoffset = 0;
+        $tocopy = 5;
+        $md5->reset();
+        while ($offset != 16) {
+            if ((64 - $offset) < 5) {
+                $tocopy = 64 - $offset;
+            }
+            for ($i = 0; $i <= $tocopy; ++$i) {
+                $pwarray[$offset + $i] = $mdContext1[$keyoffset + $i];
+            }
+            $offset += $tocopy;
+            if ($offset == 64) {
+                $md5->add($pwarray);
+                $keyoffset = $tocopy;
+                $tocopy = 5 - $tocopy;
+                $offset = 0;
+                continue;
+            }
+            $keyoffset = 0;
+            $tocopy = 5;
+            for ($i = 0; $i < 16; ++$i) {
+                $pwarray[$offset + $i] = $docid[$i];
+            }
+            $offset += 16;
+        }
+        $pwarray[16] = "\x80";
+        for ($i = 0; $i < 47; ++$i) {
+            $pwarray[17 + $i] = "\0";
+        }
+        $pwarray[56] = "\x80";
+        $pwarray[57] = "\x0a";
+        $md5->add($pwarray);
+        $valContext = $md5->getContext();
+        $key = $this->makeKey(0, $valContext);
+        $salt = $key->RC4($salt_data);
+        $hashedsalt = $key->RC4($hashedsalt_data);
+        $salt .= "\x80" . str_repeat("\0", 47);
+        $salt[56] = "\x80";
+        $md5->reset();
+        $md5->add($salt);
+        $mdContext2 = $md5->getContext();
+        return $mdContext2 == $hashedsalt;
+    }
+    /**
+     * CODEPAGE.
+     *
+     * This record stores the text encoding used to write byte
+     * strings, stored as MS Windows code page identifier.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readCodepage(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $codepage = self::getUInt2d($recordData, 0);
+        $this->codepage = CodePage::numberToName($codepage);
+    }
+    /**
+     * DATEMODE.
+     *
+     * This record specifies the base date for displaying date
+     * values. All dates are stored as count of days past this
+     * base date. In BIFF2-BIFF4 this record is part of the
+     * Calculation Settings Block. In BIFF5-BIFF8 it is
+     * stored in the Workbook Globals Substream.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readDateMode(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        Date::setExcelCalendar(Date::CALENDAR_WINDOWS_1900);
+        $this->spreadsheet->setExcelCalendar(Date::CALENDAR_WINDOWS_1900);
+        if (ord($recordData[0]) == 1) {
+            Date::setExcelCalendar(Date::CALENDAR_MAC_1904);
+            $this->spreadsheet->setExcelCalendar(Date::CALENDAR_MAC_1904);
+        }
+    }
+    /**
+     * Read a FONT record.
+     */
+    private function readFont(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $objFont = new Font();
+            $size = self::getUInt2d($recordData, 0);
+            $objFont->setSize($size / 20);
+            $isItalic = (0x0002 & self::getUInt2d($recordData, 2)) >> 1;
+            if ($isItalic) {
+                $objFont->setItalic(true);
+            }
+            $isStrike = (0x0008 & self::getUInt2d($recordData, 2)) >> 3;
+            if ($isStrike) {
+                $objFont->setStrikethrough(true);
+            }
+            $colorIndex = self::getUInt2d($recordData, 4);
+            $objFont->colorIndex = $colorIndex;
+            $weight = self::getUInt2d($recordData, 6); // regular=400 bold=700
+            if ($weight >= 550) {
+                $objFont->setBold(true);
+            }
+            $escapement = self::getUInt2d($recordData, 8);
+            CellFont::escapement($objFont, $escapement);
+            $underlineType = ord($recordData[10]);
+            CellFont::underline($objFont, $underlineType);
+            if ($this->version == self::XLS_BIFF8) {
+                $string = self::readUnicodeStringShort(substr($recordData, 14));
+            } else {
+                $string = $this->readByteStringShort(substr($recordData, 14));
+            }
+            $objFont->setName($string['value']);
+            $this->objFonts[] = $objFont;
+        }
+    }
+    /**
+     * FORMAT.
+     *
+     * This record contains information about a number format.
+     * All FORMAT records occur together in a sequential list.
+     *
+     * In BIFF2-BIFF4 other records referencing a FORMAT record
+     * contain a zero-based index into this list. From BIFF5 on
+     * the FORMAT record contains the index itself that will be
+     * used by other records.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readFormat(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $indexCode = self::getUInt2d($recordData, 0);
+            if ($this->version == self::XLS_BIFF8) {
+                $string = self::readUnicodeStringLong(substr($recordData, 2));
+            } else {
+                $string = $this->readByteStringShort(substr($recordData, 2));
+            }
+            $formatString = $string['value'];
+            if ($formatString === 'GENERAL') {
+                $formatString = NumberFormat::FORMAT_GENERAL;
+            }
+            $this->formats[$indexCode] = $formatString;
+        }
+    }
+    /**
+     * XF - Extended Format.
+     *
+     * This record contains formatting information for cells, rows, columns or styles.
+     * According to https://support.microsoft.com/en-us/help/147732 there are always at least 15 cell style XF
+     * and 1 cell XF.
+     * Inspection of Excel files generated by MS Office Excel shows that XF records 0-14 are cell style XF
+     * and XF record 15 is a cell XF
+     * We only read the first cell style XF and skip the remaining cell style XF records
+     * We read all cell XF records.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readXf(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $objStyle = new Style();
+        if (!$this->readDataOnly) {
+            if (self::getUInt2d($recordData, 0) < 4) {
+                $fontIndex = self::getUInt2d($recordData, 0);
+            } else {
+                $fontIndex = self::getUInt2d($recordData, 0) - 1;
+            }
+            if (isset($this->objFonts[$fontIndex])) {
+                $objStyle->setFont($this->objFonts[$fontIndex]);
+            }
+            $numberFormatIndex = self::getUInt2d($recordData, 2);
+            if (isset($this->formats[$numberFormatIndex])) {
+                $numberFormat = ['formatCode' => $this->formats[$numberFormatIndex]];
+            } elseif (($code = NumberFormat::builtInFormatCode($numberFormatIndex)) !== '') {
+                $numberFormat = ['formatCode' => $code];
+            } else {
+                $numberFormat = ['formatCode' => NumberFormat::FORMAT_GENERAL];
+            }
+            $objStyle->getNumberFormat()->setFormatCode($numberFormat['formatCode']);
+            $xfTypeProt = self::getUInt2d($recordData, 4);
+            $isLocked = (0x01 & $xfTypeProt) >> 0;
+            $objStyle->getProtection()->setLocked($isLocked ? Protection::PROTECTION_INHERIT : Protection::PROTECTION_UNPROTECTED);
+            $isHidden = (0x02 & $xfTypeProt) >> 1;
+            $objStyle->getProtection()->setHidden($isHidden ? Protection::PROTECTION_PROTECTED : Protection::PROTECTION_UNPROTECTED);
+            $isCellStyleXf = (0x04 & $xfTypeProt) >> 2;
+            $horAlign = (0x07 & ord($recordData[6])) >> 0;
+            Xls\Style\CellAlignment::horizontal($objStyle->getAlignment(), $horAlign);
+            $wrapText = (0x08 & ord($recordData[6])) >> 3;
+            Xls\Style\CellAlignment::wrap($objStyle->getAlignment(), $wrapText);
+            $vertAlign = (0x70 & ord($recordData[6])) >> 4;
+            Xls\Style\CellAlignment::vertical($objStyle->getAlignment(), $vertAlign);
+            if ($this->version == self::XLS_BIFF8) {
+                $angle = ord($recordData[7]);
+                $rotation = 0;
+                if ($angle <= 90) {
+                    $rotation = $angle;
+                } elseif ($angle <= 180) {
+                    $rotation = 90 - $angle;
+                } elseif ($angle == Alignment::TEXTROTATION_STACK_EXCEL) {
+                    $rotation = Alignment::TEXTROTATION_STACK_PHPSPREADSHEET;
+                }
+                $objStyle->getAlignment()->setTextRotation($rotation);
+                $indent = (0x0F & ord($recordData[8])) >> 0;
+                $objStyle->getAlignment()->setIndent($indent);
+                $shrinkToFit = (0x10 & ord($recordData[8])) >> 4;
+                switch ($shrinkToFit) {
+                    case 0:
+                        $objStyle->getAlignment()->setShrinkToFit(false);
+                        break;
+                    case 1:
+                        $objStyle->getAlignment()->setShrinkToFit(true);
+                        break;
+                }
+                if ($bordersLeftStyle = Xls\Style\Border::lookup((0x0000000F & self::getInt4d($recordData, 10)) >> 0)) {
+                    $objStyle->getBorders()->getLeft()->setBorderStyle($bordersLeftStyle);
+                }
+                if ($bordersRightStyle = Xls\Style\Border::lookup((0x000000F0 & self::getInt4d($recordData, 10)) >> 4)) {
+                    $objStyle->getBorders()->getRight()->setBorderStyle($bordersRightStyle);
+                }
+                if ($bordersTopStyle = Xls\Style\Border::lookup((0x00000F00 & self::getInt4d($recordData, 10)) >> 8)) {
+                    $objStyle->getBorders()->getTop()->setBorderStyle($bordersTopStyle);
+                }
+                if ($bordersBottomStyle = Xls\Style\Border::lookup((0x0000F000 & self::getInt4d($recordData, 10)) >> 12)) {
+                    $objStyle->getBorders()->getBottom()->setBorderStyle($bordersBottomStyle);
+                }
+                $objStyle->getBorders()->getLeft()->colorIndex = (0x007F0000 & self::getInt4d($recordData, 10)) >> 16;
+                $objStyle->getBorders()->getRight()->colorIndex = (0x3F800000 & self::getInt4d($recordData, 10)) >> 23;
+                $diagonalDown = (0x40000000 & self::getInt4d($recordData, 10)) >> 30 ? true : false;
+                $diagonalUp = (self::HIGH_ORDER_BIT & self::getInt4d($recordData, 10)) >> 31 ? true : false;
+                if ($diagonalUp === false) {
+                    if ($diagonalDown === false) {
+                        $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_NONE);
+                    } else {
+                        $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_DOWN);
+                    }
+                } elseif ($diagonalDown === false) {
+                    $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_UP);
+                } else {
+                    $objStyle->getBorders()->setDiagonalDirection(Borders::DIAGONAL_BOTH);
+                }
+                $objStyle->getBorders()->getTop()->colorIndex = (0x0000007F & self::getInt4d($recordData, 14)) >> 0;
+                $objStyle->getBorders()->getBottom()->colorIndex = (0x00003F80 & self::getInt4d($recordData, 14)) >> 7;
+                $objStyle->getBorders()->getDiagonal()->colorIndex = (0x001FC000 & self::getInt4d($recordData, 14)) >> 14;
+                if ($bordersDiagonalStyle = Xls\Style\Border::lookup((0x01E00000 & self::getInt4d($recordData, 14)) >> 21)) {
+                    $objStyle->getBorders()->getDiagonal()->setBorderStyle($bordersDiagonalStyle);
+                }
+                if ($fillType = FillPattern::lookup((self::FC000000 & self::getInt4d($recordData, 14)) >> 26)) {
+                    $objStyle->getFill()->setFillType($fillType);
+                }
+                $objStyle->getFill()->startcolorIndex = (0x007F & self::getUInt2d($recordData, 18)) >> 0;
+                $objStyle->getFill()->endcolorIndex = (0x3F80 & self::getUInt2d($recordData, 18)) >> 7;
+            } else {
+                $orientationAndFlags = ord($recordData[7]);
+                $xfOrientation = (0x03 & $orientationAndFlags) >> 0;
+                switch ($xfOrientation) {
+                    case 0:
+                        $objStyle->getAlignment()->setTextRotation(0);
+                        break;
+                    case 1:
+                        $objStyle->getAlignment()->setTextRotation(Alignment::TEXTROTATION_STACK_PHPSPREADSHEET);
+                        break;
+                    case 2:
+                        $objStyle->getAlignment()->setTextRotation(90);
+                        break;
+                    case 3:
+                        $objStyle->getAlignment()->setTextRotation(-90);
+                        break;
+                }
+                $borderAndBackground = self::getInt4d($recordData, 8);
+                $objStyle->getFill()->startcolorIndex = (0x0000007F & $borderAndBackground) >> 0;
+                $objStyle->getFill()->endcolorIndex = (0x00003F80 & $borderAndBackground) >> 7;
+                $objStyle->getFill()->setFillType(FillPattern::lookup((0x003F0000 & $borderAndBackground) >> 16));
+                $objStyle->getBorders()->getBottom()->setBorderStyle(Xls\Style\Border::lookup((0x01C00000 & $borderAndBackground) >> 22));
+                $objStyle->getBorders()->getBottom()->colorIndex = (self::FE000000 & $borderAndBackground) >> 25;
+                $borderLines = self::getInt4d($recordData, 12);
+                $objStyle->getBorders()->getTop()->setBorderStyle(Xls\Style\Border::lookup((0x00000007 & $borderLines) >> 0));
+                $objStyle->getBorders()->getLeft()->setBorderStyle(Xls\Style\Border::lookup((0x00000038 & $borderLines) >> 3));
+                $objStyle->getBorders()->getRight()->setBorderStyle(Xls\Style\Border::lookup((0x000001C0 & $borderLines) >> 6));
+                $objStyle->getBorders()->getTop()->colorIndex = (0x0000FE00 & $borderLines) >> 9;
+                $objStyle->getBorders()->getLeft()->colorIndex = (0x007F0000 & $borderLines) >> 16;
+                $objStyle->getBorders()->getRight()->colorIndex = (0x3F800000 & $borderLines) >> 23;
+            }
+            if ($isCellStyleXf) {
+                if ($this->xfIndex == 0) {
+                    $this->spreadsheet->addCellStyleXf($objStyle);
+                    $this->mapCellStyleXfIndex[$this->xfIndex] = 0;
+                }
+            } else {
+                $this->spreadsheet->addCellXf($objStyle);
+                $this->mapCellXfIndex[$this->xfIndex] = count($this->spreadsheet->getCellXfCollection()) - 1;
+            }
+            ++$this->xfIndex;
+        }
+    }
+    private function readXfExt(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $ixfe = self::getUInt2d($recordData, 14);
+            $offset = 20;
+            while ($offset < $length) {
+                $extType = self::getUInt2d($recordData, $offset);
+                $cb = self::getUInt2d($recordData, $offset + 2);
+                $extData = substr($recordData, $offset + 4, $cb);
+                switch ($extType) {
+                    case 4:        // fill start color
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $fill = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFill();
+                                $fill->getStartColor()->setRGB($rgb);
+                                $fill->startcolorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 5:        // fill end color
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $fill = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFill();
+                                $fill->getEndColor()->setRGB($rgb);
+                                $fill->endcolorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 7:        // border color top
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $top = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getTop();
+                                $top->getColor()->setRGB($rgb);
+                                $top->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 8:        // border color bottom
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $bottom = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getBottom();
+                                $bottom->getColor()->setRGB($rgb);
+                                $bottom->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 9:        // border color left
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $left = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getLeft();
+                                $left->getColor()->setRGB($rgb);
+                                $left->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 10:        // border color right
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $right = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getRight();
+                                $right->getColor()->setRGB($rgb);
+                                $right->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 11:        // border color diagonal
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $diagonal = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getBorders()->getDiagonal();
+                                $diagonal->getColor()->setRGB($rgb);
+                                $diagonal->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                    case 13:    // font color
+                        $xclfType = self::getUInt2d($extData, 0); // color type
+                        $xclrValue = substr($extData, 4, 4); // color value (value based on color type)
+                        if ($xclfType == 2) {
+                            $rgb = sprintf('%02X%02X%02X', ord($xclrValue[0]), ord($xclrValue[1]), ord($xclrValue[2]));
+                            if (isset($this->mapCellXfIndex[$ixfe])) {
+                                $font = $this->spreadsheet->getCellXfByIndex($this->mapCellXfIndex[$ixfe])->getFont();
+                                $font->getColor()->setRGB($rgb);
+                                $font->colorIndex = null; // normal color index does not apply, discard
+                            }
+                        }
+                        break;
+                }
+                $offset += $cb;
+            }
+        }
+    }
+    /**
+     * Read STYLE record.
+     */
+    private function readStyle(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $ixfe = self::getUInt2d($recordData, 0);
+            $isBuiltIn = (bool) ((0x8000 & $ixfe) >> 15);
+            if ($isBuiltIn) {
+                $builtInId = ord($recordData[2]);
+                switch ($builtInId) {
+                    case 0x00:
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+    }
+    /**
+     * Read PALETTE record.
+     */
+    private function readPalette(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $nm = self::getUInt2d($recordData, 0);
+            for ($i = 0; $i < $nm; ++$i) {
+                $rgb = substr($recordData, 2 + 4 * $i, 4);
+                $this->palette[] = self::readRGB($rgb);
+            }
+        }
+    }
+    /**
+     * SHEET.
+     *
+     * This record is  located in the  Workbook Globals
+     * Substream  and represents a sheet inside the workbook.
+     * One SHEET record is written for each sheet. It stores the
+     * sheet name and a stream offset to the BOF record of the
+     * respective Sheet Substream within the Workbook Stream.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readSheet(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $rec_offset = self::getInt4d($this->data, $this->pos + 4);
+        $this->pos += 4 + $length;
+        $sheetState = match (ord($recordData[4])) {
+            0x00 => Worksheet::SHEETSTATE_VISIBLE,
+            0x01 => Worksheet::SHEETSTATE_HIDDEN,
+            0x02 => Worksheet::SHEETSTATE_VERYHIDDEN,
+            default => Worksheet::SHEETSTATE_VISIBLE,
+        };
+        $sheetType = ord($recordData[5]);
+        $rec_name = null;
+        if ($this->version == self::XLS_BIFF8) {
+            $string = self::readUnicodeStringShort(substr($recordData, 6));
+            $rec_name = $string['value'];
+        } elseif ($this->version == self::XLS_BIFF7) {
+            $string = $this->readByteStringShort(substr($recordData, 6));
+            $rec_name = $string['value'];
+        }
+        $this->sheets[] = [
+            'name' => $rec_name,
+            'offset' => $rec_offset,
+            'sheetState' => $sheetState,
+            'sheetType' => $sheetType,
+        ];
+    }
+    /**
+     * Read EXTERNALBOOK record.
+     */
+    private function readExternalBook(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $offset = 0;
+        if (strlen($recordData) > 4) {
+            $nm = self::getUInt2d($recordData, 0);
+            $offset += 2;
+            $encodedUrlString = self::readUnicodeStringLong(substr($recordData, 2));
+            $offset += $encodedUrlString['size'];
+            $externalSheetNames = [];
+            for ($i = 0; $i < $nm; ++$i) {
+                $externalSheetNameString = self::readUnicodeStringLong(substr($recordData, $offset));
+                $externalSheetNames[] = $externalSheetNameString['value'];
+                $offset += $externalSheetNameString['size'];
+            }
+            $this->externalBooks[] = [
+                'type' => 'external',
+                'encodedUrl' => $encodedUrlString['value'],
+                'externalSheetNames' => $externalSheetNames,
+            ];
+        } elseif (substr($recordData, 2, 2) == pack('CC', 0x01, 0x04)) {
+            $this->externalBooks[] = [
+                'type' => 'internal',
+            ];
+        } elseif (substr($recordData, 0, 4) == pack('vCC', 0x0001, 0x01, 0x3A)) {
+            $this->externalBooks[] = [
+                'type' => 'addInFunction',
+            ];
+        } elseif (substr($recordData, 0, 2) == pack('v', 0x0000)) {
+            $this->externalBooks[] = [
+                'type' => 'DDEorOLE',
+            ];
+        }
+    }
+    /**
+     * Read EXTERNNAME record.
+     */
+    private function readExternName(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8) {
+            $nameString = self::readUnicodeStringShort(substr($recordData, 6));
+            $offset = 6 + $nameString['size'];
+            $formula = $this->getFormulaFromStructure(substr($recordData, $offset));
+            $this->externalNames[] = [
+                'name' => $nameString['value'],
+                'formula' => $formula,
+            ];
+        }
+    }
+    /**
+     * Read EXTERNSHEET record.
+     */
+    private function readExternSheet(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8) {
+            $nm = self::getUInt2d($recordData, 0);
+            for ($i = 0; $i < $nm; ++$i) {
+                $this->ref[] = [
+                    'externalBookIndex' => self::getUInt2d($recordData, 2 + 6 * $i),
+                    'firstSheetIndex' => self::getUInt2d($recordData, 4 + 6 * $i),
+                    'lastSheetIndex' => self::getUInt2d($recordData, 6 + 6 * $i),
+                ];
+            }
+        }
+    }
+    /**
+     * DEFINEDNAME.
+     *
+     * This record is part of a Link Table. It contains the name
+     * and the token array of an internal defined name. Token
+     * arrays of defined names contain tokens with aberrant
+     * token classes.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readDefinedName(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8) {
+            $opts = self::getUInt2d($recordData, 0);
+            $isBuiltInName = (0x0020 & $opts) >> 5;
+            $nlen = ord($recordData[3]);
+            $flen = self::getUInt2d($recordData, 4);
+            $scope = self::getUInt2d($recordData, 8);
+            $string = self::readUnicodeString(substr($recordData, 14), $nlen);
+            $offset = 14 + $string['size'];
+            $formulaStructure = pack('v', $flen) . substr($recordData, $offset);
+            try {
+                $formula = $this->getFormulaFromStructure($formulaStructure);
+            } catch (PhpSpreadsheetException) {
+                $formula = '';
+                $isBuiltInName = 0;
+            }
+            $this->definedname[] = [
+                'isBuiltInName' => $isBuiltInName,
+                'name' => $string['value'],
+                'formula' => $formula,
+                'scope' => $scope,
+            ];
+        }
+    }
+    /**
+     * Read MSODRAWINGGROUP record.
+     */
+    private function readMsoDrawingGroup(): void
+    {
+        $splicedRecordData = $this->getSplicedRecordData();
+        $recordData = $splicedRecordData['recordData'];
+        $this->drawingGroupData .= $recordData;
+    }
+    /**
+     * SST - Shared String Table.
+     *
+     * This record contains a list of all strings used anywhere
+     * in the workbook. Each string occurs only once. The
+     * workbook uses indexes into the list to reference the
+     * strings.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readSst(): void
+    {
+        $pos = 0;
+        $limitposSST = 0;
+        $splicedRecordData = $this->getSplicedRecordData();
+        $recordData = $splicedRecordData['recordData'];
+        $spliceOffsets = $splicedRecordData['spliceOffsets'];
+        $pos += 4;
+        $nm = self::getInt4d($recordData, 4);
+        $pos += 4;
+        foreach ($spliceOffsets as $spliceOffset) {
+            if ($pos <= $spliceOffset) {
+                $limitposSST = $spliceOffset;
+            }
+        }
+        for ($i = 0; $i < $nm && $pos < $limitposSST; ++$i) {
+            $numChars = self::getUInt2d($recordData, $pos);
+            $pos += 2;
+            $optionFlags = ord($recordData[$pos]);
+            ++$pos;
+            $isCompressed = (($optionFlags & 0x01) == 0);
+            $hasAsian = (($optionFlags & 0x04) != 0);
+            $hasRichText = (($optionFlags & 0x08) != 0);
+            $formattingRuns = 0;
+            if ($hasRichText) {
+                $formattingRuns = self::getUInt2d($recordData, $pos);
+                $pos += 2;
+            }
+            $extendedRunLength = 0;
+            if ($hasAsian) {
+                $extendedRunLength = self::getInt4d($recordData, $pos);
+                $pos += 4;
+            }
+            $len = ($isCompressed) ? $numChars : $numChars * 2;
+            $limitpos = null;
+            foreach ($spliceOffsets as $spliceOffset) {
+                if ($pos <= $spliceOffset) {
+                    $limitpos = $spliceOffset;
+                    break;
+                }
+            }
+            if ($pos + $len <= $limitpos) {
+                $retstr = substr($recordData, $pos, $len);
+                $pos += $len;
+            } else {
+                $retstr = substr($recordData, $pos, $limitpos - $pos);
+                $bytesRead = $limitpos - $pos;
+                $charsLeft = $numChars - (($isCompressed) ? $bytesRead : ($bytesRead / 2));
+                $pos = $limitpos;
+                while ($charsLeft > 0) {
+                    foreach ($spliceOffsets as $spliceOffset) {
+                        if ($pos < $spliceOffset) {
+                            $limitpos = $spliceOffset;
+                            break;
+                        }
+                    }
+                    $option = ord($recordData[$pos]);
+                    ++$pos;
+                    if ($isCompressed && ($option == 0)) {
+                        $len = min($charsLeft, $limitpos - $pos);
+                        $retstr .= substr($recordData, $pos, $len);
+                        $charsLeft -= $len;
+                        $isCompressed = true;
+                    } elseif (!$isCompressed && ($option != 0)) {
+                        $len = min($charsLeft * 2, $limitpos - $pos);
+                        $retstr .= substr($recordData, $pos, $len);
+                        $charsLeft -= $len / 2;
+                        $isCompressed = false;
+                    } elseif (!$isCompressed && ($option == 0)) {
+                        $len = min($charsLeft, $limitpos - $pos);
+                        for ($j = 0; $j < $len; ++$j) {
+                            $retstr .= $recordData[$pos + $j]
+                                . chr(0);
+                        }
+                        $charsLeft -= $len;
+                        $isCompressed = false;
+                    } else {
+                        $newstr = '';
+                        $jMax = strlen($retstr);
+                        for ($j = 0; $j < $jMax; ++$j) {
+                            $newstr .= $retstr[$j] . chr(0);
+                        }
+                        $retstr = $newstr;
+                        $len = min($charsLeft * 2, $limitpos - $pos);
+                        $retstr .= substr($recordData, $pos, $len);
+                        $charsLeft -= $len / 2;
+                        $isCompressed = false;
+                    }
+                    $pos += $len;
+                }
+            }
+            $retstr = self::encodeUTF16($retstr, $isCompressed);
+            $fmtRuns = [];
+            if ($hasRichText) {
+                for ($j = 0; $j < $formattingRuns; ++$j) {
+                    $charPos = self::getUInt2d($recordData, $pos + $j * 4);
+                    $fontIndex = self::getUInt2d($recordData, $pos + 2 + $j * 4);
+                    $fmtRuns[] = [
+                        'charPos' => $charPos,
+                        'fontIndex' => $fontIndex,
+                    ];
+                }
+                $pos += 4 * $formattingRuns;
+            }
+            if ($hasAsian) {
+                $pos += $extendedRunLength;
+            }
+            $this->sst[] = [
+                'value' => $retstr,
+                'fmtRuns' => $fmtRuns,
+            ];
+        }
+    }
+    /**
+     * Read PRINTGRIDLINES record.
+     */
+    private function readPrintGridlines(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
+            $printGridlines = (bool) self::getUInt2d($recordData, 0);
+            $this->phpSheet->setPrintGridlines($printGridlines);
+        }
+    }
+    /**
+     * Read DEFAULTROWHEIGHT record.
+     */
+    private function readDefaultRowHeight(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $height = self::getUInt2d($recordData, 2);
+        $this->phpSheet->getDefaultRowDimension()->setRowHeight($height / 20);
+    }
+    /**
+     * Read SHEETPR record.
+     */
+    private function readSheetPr(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $isSummaryBelow = (0x0040 & self::getUInt2d($recordData, 0)) >> 6;
+        $this->phpSheet->setShowSummaryBelow((bool) $isSummaryBelow);
+        $isSummaryRight = (0x0080 & self::getUInt2d($recordData, 0)) >> 7;
+        $this->phpSheet->setShowSummaryRight((bool) $isSummaryRight);
+        $this->isFitToPages = (bool) ((0x0100 & self::getUInt2d($recordData, 0)) >> 8);
+    }
+    /**
+     * Read HORIZONTALPAGEBREAKS record.
+     */
+    private function readHorizontalPageBreaks(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
+            $nm = self::getUInt2d($recordData, 0);
+            for ($i = 0; $i < $nm; ++$i) {
+                $r = self::getUInt2d($recordData, 2 + 6 * $i);
+                $cf = self::getUInt2d($recordData, 2 + 6 * $i + 2);
+                $this->phpSheet->setBreak([$cf + 1, $r], Worksheet::BREAK_ROW);
+            }
+        }
+    }
+    /**
+     * Read VERTICALPAGEBREAKS record.
+     */
+    private function readVerticalPageBreaks(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
+            $nm = self::getUInt2d($recordData, 0);
+            for ($i = 0; $i < $nm; ++$i) {
+                $c = self::getUInt2d($recordData, 2 + 6 * $i);
+                $rf = self::getUInt2d($recordData, 2 + 6 * $i + 2);
+                $this->phpSheet->setBreak([$c + 1, ($rf > 0) ? $rf : 1], Worksheet::BREAK_COLUMN);
+            }
+        }
+    }
+    /**
+     * Read HEADER record.
+     */
+    private function readHeader(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            if ($recordData) {
+                if ($this->version == self::XLS_BIFF8) {
+                    $string = self::readUnicodeStringLong($recordData);
+                } else {
+                    $string = $this->readByteStringShort($recordData);
+                }
+                $this->phpSheet->getHeaderFooter()->setOddHeader($string['value']);
+                $this->phpSheet->getHeaderFooter()->setEvenHeader($string['value']);
+            }
+        }
+    }
+    /**
+     * Read FOOTER record.
+     */
+    private function readFooter(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            if ($recordData) {
+                if ($this->version == self::XLS_BIFF8) {
+                    $string = self::readUnicodeStringLong($recordData);
+                } else {
+                    $string = $this->readByteStringShort($recordData);
+                }
+                $this->phpSheet->getHeaderFooter()->setOddFooter($string['value']);
+                $this->phpSheet->getHeaderFooter()->setEvenFooter($string['value']);
+            }
+        }
+    }
+    /**
+     * Read HCENTER record.
+     */
+    private function readHcenter(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $isHorizontalCentered = (bool) self::getUInt2d($recordData, 0);
+            $this->phpSheet->getPageSetup()->setHorizontalCentered($isHorizontalCentered);
+        }
+    }
+    /**
+     * Read VCENTER record.
+     */
+    private function readVcenter(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $isVerticalCentered = (bool) self::getUInt2d($recordData, 0);
+            $this->phpSheet->getPageSetup()->setVerticalCentered($isVerticalCentered);
+        }
+    }
+    /**
+     * Read LEFTMARGIN record.
+     */
+    private function readLeftMargin(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $this->phpSheet->getPageMargins()->setLeft(self::extractNumber($recordData));
+        }
+    }
+    /**
+     * Read RIGHTMARGIN record.
+     */
+    private function readRightMargin(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $this->phpSheet->getPageMargins()->setRight(self::extractNumber($recordData));
+        }
+    }
+    /**
+     * Read TOPMARGIN record.
+     */
+    private function readTopMargin(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $this->phpSheet->getPageMargins()->setTop(self::extractNumber($recordData));
+        }
+    }
+    /**
+     * Read BOTTOMMARGIN record.
+     */
+    private function readBottomMargin(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $this->phpSheet->getPageMargins()->setBottom(self::extractNumber($recordData));
+        }
+    }
+    /**
+     * Read PAGESETUP record.
+     */
+    private function readPageSetup(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $paperSize = self::getUInt2d($recordData, 0);
+            $scale = self::getUInt2d($recordData, 2);
+            $fitToWidth = self::getUInt2d($recordData, 6);
+            $fitToHeight = self::getUInt2d($recordData, 8);
+            $isOverThenDown = (0x0001 & self::getUInt2d($recordData, 10));
+            $isPortrait = (0x0002 & self::getUInt2d($recordData, 10)) >> 1;
+            $isNotInit = (0x0004 & self::getUInt2d($recordData, 10)) >> 2;
+            if (!$isNotInit) {
+                $this->phpSheet->getPageSetup()->setPaperSize($paperSize);
+                $this->phpSheet->getPageSetup()->setPageOrder(((bool) $isOverThenDown) ? PageSetup::PAGEORDER_OVER_THEN_DOWN : PageSetup::PAGEORDER_DOWN_THEN_OVER);
+                $this->phpSheet->getPageSetup()->setOrientation(((bool) $isPortrait) ? PageSetup::ORIENTATION_PORTRAIT : PageSetup::ORIENTATION_LANDSCAPE);
+                $this->phpSheet->getPageSetup()->setScale($scale, false);
+                $this->phpSheet->getPageSetup()->setFitToPage((bool) $this->isFitToPages);
+                $this->phpSheet->getPageSetup()->setFitToWidth($fitToWidth, false);
+                $this->phpSheet->getPageSetup()->setFitToHeight($fitToHeight, false);
+            }
+            $marginHeader = self::extractNumber(substr($recordData, 16, 8));
+            $this->phpSheet->getPageMargins()->setHeader($marginHeader);
+            $marginFooter = self::extractNumber(substr($recordData, 24, 8));
+            $this->phpSheet->getPageMargins()->setFooter($marginFooter);
+        }
+    }
+    /**
+     * PROTECT - Sheet protection (BIFF2 through BIFF8)
+     *   if this record is omitted, then it also means no sheet protection.
+     */
+    private function readProtect(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
+        $this->phpSheet->getProtection()->setSheet((bool) $bool);
+    }
+    /**
+     * SCENPROTECT.
+     */
+    private function readScenProtect(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
+        $this->phpSheet->getProtection()->setScenarios((bool) $bool);
+    }
+    /**
+     * OBJECTPROTECT.
+     */
+    private function readObjectProtect(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $bool = (0x01 & self::getUInt2d($recordData, 0)) >> 0;
+        $this->phpSheet->getProtection()->setObjects((bool) $bool);
+    }
+    /**
+     * PASSWORD - Sheet protection (hashed) password (BIFF2 through BIFF8).
+     */
+    private function readPassword(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $password = strtoupper(dechex(self::getUInt2d($recordData, 0))); // the hashed password
+            $this->phpSheet->getProtection()->setPassword($password, true);
+        }
+    }
+    /**
+     * Read DEFCOLWIDTH record.
+     */
+    private function readDefColWidth(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $width = self::getUInt2d($recordData, 0);
+        if ($width != 8) {
+            $this->phpSheet->getDefaultColumnDimension()->setWidth($width);
+        }
+    }
+    /**
+     * Read COLINFO record.
+     */
+    private function readColInfo(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $firstColumnIndex = self::getUInt2d($recordData, 0);
+            $lastColumnIndex = self::getUInt2d($recordData, 2);
+            $width = self::getUInt2d($recordData, 4);
+            $xfIndex = self::getUInt2d($recordData, 6);
+            $isHidden = (0x0001 & self::getUInt2d($recordData, 8)) >> 0;
+            $level = (0x0700 & self::getUInt2d($recordData, 8)) >> 8;
+            $isCollapsed = (bool) ((0x1000 & self::getUInt2d($recordData, 8)) >> 12);
+            for ($i = $firstColumnIndex + 1; $i <= $lastColumnIndex + 1; ++$i) {
+                if ($lastColumnIndex == 255 || $lastColumnIndex == 256) {
+                    $this->phpSheet->getDefaultColumnDimension()->setWidth($width / 256);
+                    break;
+                }
+                $this->phpSheet->getColumnDimensionByColumn($i)->setWidth($width / 256);
+                $this->phpSheet->getColumnDimensionByColumn($i)->setVisible(!$isHidden);
+                $this->phpSheet->getColumnDimensionByColumn($i)->setOutlineLevel($level);
+                $this->phpSheet->getColumnDimensionByColumn($i)->setCollapsed($isCollapsed);
+                if (isset($this->mapCellXfIndex[$xfIndex])) {
+                    $this->phpSheet->getColumnDimensionByColumn($i)->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+                }
+            }
+        }
+    }
+    /**
+     * ROW.
+     *
+     * This record contains the properties of a single row in a
+     * sheet. Rows and cells in a sheet are divided into blocks
+     * of 32 rows.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readRow(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $r = self::getUInt2d($recordData, 0);
+            $height = (0x7FFF & self::getUInt2d($recordData, 6)) >> 0;
+            $useDefaultHeight = (0x8000 & self::getUInt2d($recordData, 6)) >> 15;
+            if (!$useDefaultHeight) {
+                $this->phpSheet->getRowDimension($r + 1)->setRowHeight($height / 20);
+            }
+            $level = (0x00000007 & self::getInt4d($recordData, 12)) >> 0;
+            $this->phpSheet->getRowDimension($r + 1)->setOutlineLevel($level);
+            $isCollapsed = (bool) ((0x00000010 & self::getInt4d($recordData, 12)) >> 4);
+            $this->phpSheet->getRowDimension($r + 1)->setCollapsed($isCollapsed);
+            $isHidden = (0x00000020 & self::getInt4d($recordData, 12)) >> 5;
+            $this->phpSheet->getRowDimension($r + 1)->setVisible(!$isHidden);
+            $hasExplicitFormat = (0x00000080 & self::getInt4d($recordData, 12)) >> 7;
+            $xfIndex = (0x0FFF0000 & self::getInt4d($recordData, 12)) >> 16;
+            if ($hasExplicitFormat && isset($this->mapCellXfIndex[$xfIndex])) {
+                $this->phpSheet->getRowDimension($r + 1)->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+        }
+    }
+    /**
+     * Read RK record
+     * This record represents a cell that contains an RK value
+     * (encoded integer or floating-point value). If a
+     * floating-point value cannot be encoded to an RK value,
+     * a NUMBER record will be written. This record replaces the
+     * record INTEGER written in BIFF2.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readRk(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            $rknum = self::getInt4d($recordData, 6);
+            $numValue = self::getIEEE754($rknum);
+            $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+            if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+            $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
+        }
+    }
+    /**
+     * Read LABELSST record
+     * This record represents a cell that contains a string. It
+     * replaces the LABEL record and RSTRING record used in
+     * BIFF2-BIFF5.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readLabelSst(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        $cell = null;
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            $index = self::getInt4d($recordData, 6);
+            if (($fmtRuns = $this->sst[$index]['fmtRuns']) && !$this->readDataOnly) {
+                $richText = new RichText();
+                $charPos = 0;
+                $sstCount = count($this->sst[$index]['fmtRuns']);
+                for ($i = 0; $i <= $sstCount; ++$i) {
+                    if (isset($fmtRuns[$i])) {
+                        $text = StringHelper::substring($this->sst[$index]['value'], $charPos, $fmtRuns[$i]['charPos'] - $charPos);
+                        $charPos = $fmtRuns[$i]['charPos'];
+                    } else {
+                        $text = StringHelper::substring($this->sst[$index]['value'], $charPos, StringHelper::countCharacters($this->sst[$index]['value']));
+                    }
+                    if (StringHelper::countCharacters($text) > 0) {
+                        if ($i == 0) { // first text run, no style
+                            $richText->createText($text);
+                        } else {
+                            $textRun = $richText->createTextRun($text);
+                            if (isset($fmtRuns[$i - 1])) {
+                                if ($fmtRuns[$i - 1]['fontIndex'] < 4) {
+                                    $fontIndex = $fmtRuns[$i - 1]['fontIndex'];
+                                } else {
+                                    $fontIndex = $fmtRuns[$i - 1]['fontIndex'] - 1;
+                                }
+                                if (array_key_exists($fontIndex, $this->objFonts) === false) {
+                                    $fontIndex = count($this->objFonts) - 1;
+                                }
+                                $textRun->setFont(clone $this->objFonts[$fontIndex]);
+                            }
+                        }
+                    }
+                }
+                if ($this->readEmptyCells || trim($richText->getPlainText()) !== '') {
+                    $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+                    $cell->setValueExplicit($richText, DataType::TYPE_STRING);
+                }
+            } else {
+                if ($this->readEmptyCells || trim($this->sst[$index]['value']) !== '') {
+                    $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+                    $cell->setValueExplicit($this->sst[$index]['value'], DataType::TYPE_STRING);
+                }
+            }
+            if (!$this->readDataOnly && $cell !== null && isset($this->mapCellXfIndex[$xfIndex])) {
+                $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+        }
+    }
+    /**
+     * Read MULRK record
+     * This record represents a cell range containing RK value
+     * cells. All cells are located in the same row.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readMulRk(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $colFirst = self::getUInt2d($recordData, 2);
+        $colLast = self::getUInt2d($recordData, $length - 2);
+        $columns = $colLast - $colFirst + 1;
+        $offset = 4;
+        for ($i = 1; $i <= $columns; ++$i) {
+            $columnString = Coordinate::stringFromColumnIndex($colFirst + $i);
+            if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+                $xfIndex = self::getUInt2d($recordData, $offset);
+                $numValue = self::getIEEE754(self::getInt4d($recordData, $offset + 2));
+                $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+                if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                    $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+                }
+                $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
+            }
+            $offset += 6;
+        }
+    }
+    /**
+     * Read NUMBER record
+     * This record represents a cell that contains a
+     * floating-point value.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readNumber(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            $numValue = self::extractNumber(substr($recordData, 6, 8));
+            $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+            if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+            $cell->setValueExplicit($numValue, DataType::TYPE_NUMERIC);
+        }
+    }
+    /**
+     * Read FORMULA record + perhaps a following STRING record if formula result is a string
+     * This record contains the token array and the result of a
+     * formula cell.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readFormula(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        $formulaStructure = substr($recordData, 20);
+        $options = self::getUInt2d($recordData, 14);
+        $isPartOfSharedFormula = (bool) (0x0008 & $options);
+        $isPartOfSharedFormula = $isPartOfSharedFormula && ord($formulaStructure[2]) == 0x01;
+        if ($isPartOfSharedFormula) {
+            $baseRow = self::getUInt2d($formulaStructure, 3);
+            $baseCol = self::getUInt2d($formulaStructure, 5);
+            $this->baseCell = Coordinate::stringFromColumnIndex($baseCol + 1) . ($baseRow + 1);
+        }
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            if ($isPartOfSharedFormula) {
+                $this->sharedFormulaParts[$columnString . ($row + 1)] = $this->baseCell;
+            }
+            $xfIndex = self::getUInt2d($recordData, 4);
+            if ((ord($recordData[6]) == 0) && (ord($recordData[12]) == 255) && (ord($recordData[13]) == 255)) {
+                $dataType = DataType::TYPE_STRING;
+                $code = self::getUInt2d($this->data, $this->pos);
+                if ($code == self::XLS_TYPE_SHAREDFMLA) {
+                    $this->readSharedFmla();
+                }
+                $value = $this->readString();
+            } elseif (
+                (ord($recordData[6]) == 1)
+                && (ord($recordData[12]) == 255)
+                && (ord($recordData[13]) == 255)
+            ) {
+                $dataType = DataType::TYPE_BOOL;
+                $value = (bool) ord($recordData[8]);
+            } elseif (
+                (ord($recordData[6]) == 2)
+                && (ord($recordData[12]) == 255)
+                && (ord($recordData[13]) == 255)
+            ) {
+                $dataType = DataType::TYPE_ERROR;
+                $value = Xls\ErrorCode::lookup(ord($recordData[8]));
+            } elseif (
+                (ord($recordData[6]) == 3)
+                && (ord($recordData[12]) == 255)
+                && (ord($recordData[13]) == 255)
+            ) {
+                $dataType = DataType::TYPE_NULL;
+                $value = '';
+            } else {
+                $dataType = DataType::TYPE_NUMERIC;
+                $value = self::extractNumber(substr($recordData, 6, 8));
+            }
+            $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+            if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+            if (!$isPartOfSharedFormula) {
+                try {
+                    if ($this->version != self::XLS_BIFF8) {
+                        throw new Exception('Not BIFF8. Can only read BIFF8 formulas');
+                    }
+                    $formula = $this->getFormulaFromStructure($formulaStructure); // get formula in human language
+                    $cell->setValueExplicit('=' . $formula, DataType::TYPE_FORMULA);
+                } catch (PhpSpreadsheetException) {
+                    $cell->setValueExplicit($value, $dataType);
+                }
+            } else {
+                if ($this->version == self::XLS_BIFF8) {
+                } else {
+                    $cell->setValueExplicit($value, $dataType);
+                }
+            }
+            $cell->setCalculatedValue($value, $dataType === DataType::TYPE_NUMERIC);
+        }
+    }
+    /**
+     * Read a SHAREDFMLA record. This function just stores the binary shared formula in the reader,
+     * which usually contains relative references.
+     * These will be used to construct the formula in each shared formula part after the sheet is read.
+     */
+    private function readSharedFmla(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $formula = substr($recordData, 8);
+        $this->sharedFormulas[$this->baseCell] = $formula;
+    }
+    /**
+     * Read a STRING record from current stream position and advance the stream pointer to next record
+     * This record is used for storing result from FORMULA record when it is a string, and
+     * it occurs directly after the FORMULA record.
+     *
+     * @return string The string contents as UTF-8
+     */
+    private function readString(): string
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8) {
+            $string = self::readUnicodeStringLong($recordData);
+            $value = $string['value'];
+        } else {
+            $string = $this->readByteStringLong($recordData);
+            $value = $string['value'];
+        }
+        return $value;
+    }
+    /**
+     * Read BOOLERR record
+     * This record represents a Boolean value or error value
+     * cell.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readBoolErr(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            $boolErr = ord($recordData[6]);
+            $isError = ord($recordData[7]);
+            $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+            switch ($isError) {
+                case 0: // boolean
+                    $value = (bool) $boolErr;
+                    $cell->setValueExplicit($value, DataType::TYPE_BOOL);
+                    break;
+                case 1: // error type
+                    $value = Xls\ErrorCode::lookup($boolErr);
+                    $cell->setValueExplicit($value, DataType::TYPE_ERROR);
+                    break;
+            }
+            if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+        }
+    }
+    /**
+     * Read MULBLANK record
+     * This record represents a cell range of empty cells. All
+     * cells are located in the same row.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readMulBlank(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $fc = self::getUInt2d($recordData, 2);
+        if (!$this->readDataOnly && $this->readEmptyCells) {
+            for ($i = 0; $i < $length / 2 - 3; ++$i) {
+                $columnString = Coordinate::stringFromColumnIndex($fc + $i + 1);
+                if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+                    $xfIndex = self::getUInt2d($recordData, 4 + 2 * $i);
+                    if (isset($this->mapCellXfIndex[$xfIndex])) {
+                        $this->phpSheet->getCell($columnString . ($row + 1))->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+                    }
+                }
+            }
+        }
+    }
+    /**
+     * Read LABEL record
+     * This record represents a cell that contains a string. In
+     * BIFF8 it is usually replaced by the LABELSST record.
+     * Excel still uses this record, if it copies unformatted
+     * text cells to the clipboard.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readLabel(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $column = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($column + 1);
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            if ($this->version == self::XLS_BIFF8) {
+                $string = self::readUnicodeStringLong(substr($recordData, 6));
+                $value = $string['value'];
+            } else {
+                $string = $this->readByteStringLong(substr($recordData, 6));
+                $value = $string['value'];
+            }
+            if ($this->readEmptyCells || trim($value) !== '') {
+                $cell = $this->phpSheet->getCell($columnString . ($row + 1));
+                $cell->setValueExplicit($value, DataType::TYPE_STRING);
+                if (!$this->readDataOnly && isset($this->mapCellXfIndex[$xfIndex])) {
+                    $cell->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+                }
+            }
+        }
+    }
+    /**
+     * Read BLANK record.
+     */
+    private function readBlank(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $row = self::getUInt2d($recordData, 0);
+        $col = self::getUInt2d($recordData, 2);
+        $columnString = Coordinate::stringFromColumnIndex($col + 1);
+        if (($this->getReadFilter() !== null) && $this->getReadFilter()->readCell($columnString, $row + 1, $this->phpSheet->getTitle())) {
+            $xfIndex = self::getUInt2d($recordData, 4);
+            if (!$this->readDataOnly && $this->readEmptyCells && isset($this->mapCellXfIndex[$xfIndex])) {
+                $this->phpSheet->getCell($columnString . ($row + 1))->setXfIndex($this->mapCellXfIndex[$xfIndex]);
+            }
+        }
+    }
+    /**
+     * Read MSODRAWING record.
+     */
+    private function readMsoDrawing(): void
+    {
+        $splicedRecordData = $this->getSplicedRecordData();
+        $recordData = $splicedRecordData['recordData'];
+        $this->drawingData .= $recordData;
+    }
+    /**
+     * Read OBJ record.
+     */
+    private function readObj(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly || $this->version != self::XLS_BIFF8) {
+            return;
+        }
+        $ftCmoType = self::getUInt2d($recordData, 0);
+        $cbCmoSize = self::getUInt2d($recordData, 2);
+        $otObjType = self::getUInt2d($recordData, 4);
+        $idObjID = self::getUInt2d($recordData, 6);
+        $grbitOpts = self::getUInt2d($recordData, 6);
+        $this->objs[] = [
+            'ftCmoType' => $ftCmoType,
+            'cbCmoSize' => $cbCmoSize,
+            'otObjType' => $otObjType,
+            'idObjID' => $idObjID,
+            'grbitOpts' => $grbitOpts,
+        ];
+        $this->textObjRef = $idObjID;
+    }
+    /**
+     * Read WINDOW2 record.
+     */
+    private function readWindow2(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $options = self::getUInt2d($recordData, 0);
+        $zoomscaleInPageBreakPreview = 0;
+        $zoomscaleInNormalView = 0;
+        if ($this->version === self::XLS_BIFF8) {
+            if (!isset($recordData[10])) {
+                $zoomscaleInPageBreakPreview = 0;
+            } else {
+                $zoomscaleInPageBreakPreview = self::getUInt2d($recordData, 10);
+            }
+            if ($zoomscaleInPageBreakPreview === 0) {
+                $zoomscaleInPageBreakPreview = 60;
+            }
+            if (!isset($recordData[12])) {
+                $zoomscaleInNormalView = 0;
+            } else {
+                $zoomscaleInNormalView = self::getUInt2d($recordData, 12);
+            }
+            if ($zoomscaleInNormalView === 0) {
+                $zoomscaleInNormalView = 100;
+            }
+        }
+        $showGridlines = (bool) ((0x0002 & $options) >> 1);
+        $this->phpSheet->setShowGridlines($showGridlines);
+        $showRowColHeaders = (bool) ((0x0004 & $options) >> 2);
+        $this->phpSheet->setShowRowColHeaders($showRowColHeaders);
+        $this->frozen = (bool) ((0x0008 & $options) >> 3);
+        $this->phpSheet->setRightToLeft((bool) ((0x0040 & $options) >> 6));
+        $isActive = (bool) ((0x0400 & $options) >> 10);
+        if ($isActive) {
+            $this->spreadsheet->setActiveSheetIndex($this->spreadsheet->getIndex($this->phpSheet));
+            $this->activeSheetSet = true;
+        }
+        $isPageBreakPreview = (bool) ((0x0800 & $options) >> 11);
+        if ($this->phpSheet->getSheetView()->getView() !== SheetView::SHEETVIEW_PAGE_LAYOUT) {
+            $view = $isPageBreakPreview ? SheetView::SHEETVIEW_PAGE_BREAK_PREVIEW : SheetView::SHEETVIEW_NORMAL;
+            $this->phpSheet->getSheetView()->setView($view);
+            if ($this->version === self::XLS_BIFF8) {
+                $zoomScale = $isPageBreakPreview ? $zoomscaleInPageBreakPreview : $zoomscaleInNormalView;
+                $this->phpSheet->getSheetView()->setZoomScale($zoomScale);
+                $this->phpSheet->getSheetView()->setZoomScaleNormal($zoomscaleInNormalView);
+            }
+        }
+    }
+    /**
+     * Read PLV Record(Created by Excel2007 or upper).
+     */
+    private function readPageLayoutView(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $wScalePLV = self::getUInt2d($recordData, 12);
+        $grbit = self::getUInt2d($recordData, 14);
+        $fPageLayoutView = $grbit & 0x01;
+        if ($fPageLayoutView === 1) {
+            $this->phpSheet->getSheetView()->setView(SheetView::SHEETVIEW_PAGE_LAYOUT);
+            $this->phpSheet->getSheetView()->setZoomScale($wScalePLV); //set by Excel2007 only if SHEETVIEW_PAGE_LAYOUT
+        }
+    }
+    /**
+     * Read SCL record.
+     */
+    private function readScl(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $numerator = self::getUInt2d($recordData, 0);
+        $denumerator = self::getUInt2d($recordData, 2);
+        $this->phpSheet->getSheetView()->setZoomScale($numerator * 100 / $denumerator);
+    }
+    /**
+     * Read PANE record.
+     */
+    private function readPane(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $px = self::getUInt2d($recordData, 0);
+            $py = self::getUInt2d($recordData, 2);
+            $rwTop = self::getUInt2d($recordData, 4);
+            $colLeft = self::getUInt2d($recordData, 6);
+            if ($this->frozen) {
+                $cell = Coordinate::stringFromColumnIndex($px + 1) . ($py + 1);
+                $topLeftCell = Coordinate::stringFromColumnIndex($colLeft + 1) . ($rwTop + 1);
+                $this->phpSheet->freezePane($cell, $topLeftCell);
+            }
+        }
+    }
+    /**
+     * Read SELECTION record. There is one such record for each pane in the sheet.
+     */
+    private function readSelection(): string
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $selectedCells = '';
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $data = substr($recordData, 7);
+            $cellRangeAddressList = $this->readBIFF5CellRangeAddressList($data); // note: also BIFF8 uses BIFF5 syntax
+            $selectedCells = $cellRangeAddressList['cellRangeAddresses'][0];
+            if (preg_match('/^([A-Z]+1\:[A-Z]+)16384$/', $selectedCells)) {
+                $selectedCells = (string) preg_replace('/^([A-Z]+1\:[A-Z]+)16384$/', '${1}1048576', $selectedCells);
+            }
+            if (preg_match('/^([A-Z]+1\:[A-Z]+)65536$/', $selectedCells)) {
+                $selectedCells = (string) preg_replace('/^([A-Z]+1\:[A-Z]+)65536$/', '${1}1048576', $selectedCells);
+            }
+            if (preg_match('/^(A\d+\:)IV(\d+)$/', $selectedCells)) {
+                $selectedCells = (string) preg_replace('/^(A\d+\:)IV(\d+)$/', '${1}XFD${2}', $selectedCells);
+            }
+            $this->phpSheet->setSelectedCells($selectedCells);
+        }
+        return $selectedCells;
+    }
+    private function includeCellRangeFiltered(string $cellRangeAddress): bool
+    {
+        $includeCellRange = true;
+        if ($this->getReadFilter() !== null) {
+            $includeCellRange = false;
+            $rangeBoundaries = Coordinate::getRangeBoundaries($cellRangeAddress);
+            ++$rangeBoundaries[1][0];
+            for ($row = $rangeBoundaries[0][1]; $row <= $rangeBoundaries[1][1]; ++$row) {
+                for ($column = $rangeBoundaries[0][0]; $column != $rangeBoundaries[1][0]; ++$column) {
+                    if ($this->getReadFilter()->readCell($column, $row, $this->phpSheet->getTitle())) {
+                        $includeCellRange = true;
+                        break 2;
+                    }
+                }
+            }
+        }
+        return $includeCellRange;
+    }
+    /**
+     * MERGEDCELLS.
+     *
+     * This record contains the addresses of merged cell ranges
+     * in the current sheet.
+     *
+     * --    "OpenOffice.org's Documentation of the Microsoft
+     *         Excel File Format"
+     */
+    private function readMergedCells(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->version == self::XLS_BIFF8 && !$this->readDataOnly) {
+            $cellRangeAddressList = $this->readBIFF8CellRangeAddressList($recordData);
+            foreach ($cellRangeAddressList['cellRangeAddresses'] as $cellRangeAddress) {
+                if (
+                    (str_contains($cellRangeAddress, ':'))
+                    && ($this->includeCellRangeFiltered($cellRangeAddress))
+                ) {
+                    $this->phpSheet->mergeCells($cellRangeAddress, Worksheet::MERGE_CELL_CONTENT_HIDE);
+                }
+            }
+        }
+    }
+    /**
+     * Read HYPERLINK record.
+     */
+    private function readHyperLink(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            try {
+                $cellRange = $this->readBIFF8CellRangeAddressFixed($recordData);
+            } catch (PhpSpreadsheetException) {
+                return;
+            }
+            $isFileLinkOrUrl = (0x00000001 & self::getUInt2d($recordData, 28)) >> 0;
+            $hasDesc = (0x00000014 & self::getUInt2d($recordData, 28)) >> 2;
+            $hasText = (0x00000008 & self::getUInt2d($recordData, 28)) >> 3;
+            $hasFrame = (0x00000080 & self::getUInt2d($recordData, 28)) >> 7;
+            $isUNC = (0x00000100 & self::getUInt2d($recordData, 28)) >> 8;
+            $offset = 32;
+            if ($hasDesc) {
+                $dl = self::getInt4d($recordData, 32);
+                $offset += 4 + 2 * $dl;
+            }
+            if ($hasFrame) {
+                $fl = self::getInt4d($recordData, $offset);
+                $offset += 4 + 2 * $fl;
+            }
+            $hyperlinkType = null;
+            if ($isUNC) {
+                $hyperlinkType = 'UNC';
+            } elseif (!$isFileLinkOrUrl) {
+                $hyperlinkType = 'workbook';
+            } elseif (ord($recordData[$offset]) == 0x03) {
+                $hyperlinkType = 'local';
+            } elseif (ord($recordData[$offset]) == 0xE0) {
+                $hyperlinkType = 'URL';
+            }
+            switch ($hyperlinkType) {
+                case 'URL':
+                    $offset += 16;
+                    $us = self::getInt4d($recordData, $offset);
+                    $offset += 4;
+                    $url = self::encodeUTF16(substr($recordData, $offset, $us - 2), false);
+                    $nullOffset = strpos($url, chr(0x00));
+                    if ($nullOffset) {
+                        $url = substr($url, 0, $nullOffset);
+                    }
+                    $url .= $hasText ? '#' : '';
+                    $offset += $us;
+                    break;
+                case 'local':
+                    $offset += 16;
+                    $upLevelCount = self::getUInt2d($recordData, $offset);
+                    $offset += 2;
+                    $sl = self::getInt4d($recordData, $offset);
+                    $offset += 4;
+                    $shortenedFilePath = substr($recordData, $offset, $sl);
+                    $shortenedFilePath = self::encodeUTF16($shortenedFilePath, true);
+                    $shortenedFilePath = substr($shortenedFilePath, 0, -1); // remove trailing zero
+                    $offset += $sl;
+                    $offset += 24;
+                    $sz = self::getInt4d($recordData, $offset);
+                    $offset += 4;
+                    $extendedFilePath = '';
+                    if ($sz > 0) {
+                        $xl = self::getInt4d($recordData, $offset);
+                        $offset += 4;
+                        $offset += 2;
+                        $extendedFilePath = substr($recordData, $offset, $xl);
+                        $extendedFilePath = self::encodeUTF16($extendedFilePath, false);
+                        $offset += $xl;
+                    }
+                    $url = str_repeat('..\\', $upLevelCount);
+                    $url .= ($sz > 0) ? $extendedFilePath : $shortenedFilePath; // use extended path if available
+                    $url .= $hasText ? '#' : '';
+                    break;
+                case 'UNC':
+                    return;
+                case 'workbook':
+                    $url = 'sheet://';
+                    break;
+                default:
+                    return;
+            }
+            if ($hasText) {
+                $tl = self::getInt4d($recordData, $offset);
+                $offset += 4;
+                $text = self::encodeUTF16(substr($recordData, $offset, 2 * ($tl - 1)), false);
+                $url .= $text;
+            }
+            foreach (Coordinate::extractAllCellReferencesInRange($cellRange) as $coordinate) {
+                $this->phpSheet->getCell($coordinate)->getHyperLink()->setUrl($url);
+            }
+        }
+    }
+    /**
+     * Read DATAVALIDATIONS record.
+     */
+    private function readDataValidations(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $this->pos += 4 + $length;
+    }
+    /**
+     * Read DATAVALIDATION record.
+     */
+    private function readDataValidation(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $options = self::getInt4d($recordData, 0);
+        $type = (0x0000000F & $options) >> 0;
+        $type = Xls\DataValidationHelper::type($type);
+        $errorStyle = (0x00000070 & $options) >> 4;
+        $errorStyle = Xls\DataValidationHelper::errorStyle($errorStyle);
+        $allowBlank = (0x00000100 & $options) >> 8;
+        $suppressDropDown = (0x00000200 & $options) >> 9;
+        $showInputMessage = (0x00040000 & $options) >> 18;
+        $showErrorMessage = (0x00080000 & $options) >> 19;
+        $operator = (0x00F00000 & $options) >> 20;
+        $operator = Xls\DataValidationHelper::operator($operator);
+        if ($type === null || $errorStyle === null || $operator === null) {
+            return;
+        }
+        $offset = 4;
+        $string = self::readUnicodeStringLong(substr($recordData, $offset));
+        $promptTitle = $string['value'] !== chr(0) ? $string['value'] : '';
+        $offset += $string['size'];
+        $string = self::readUnicodeStringLong(substr($recordData, $offset));
+        $errorTitle = $string['value'] !== chr(0) ? $string['value'] : '';
+        $offset += $string['size'];
+        $string = self::readUnicodeStringLong(substr($recordData, $offset));
+        $prompt = $string['value'] !== chr(0) ? $string['value'] : '';
+        $offset += $string['size'];
+        $string = self::readUnicodeStringLong(substr($recordData, $offset));
+        $error = $string['value'] !== chr(0) ? $string['value'] : '';
+        $offset += $string['size'];
+        $sz1 = self::getUInt2d($recordData, $offset);
+        $offset += 2;
+        $offset += 2;
+        $formula1 = substr($recordData, $offset, $sz1);
+        $formula1 = pack('v', $sz1) . $formula1; // prepend the length
+        try {
+            $formula1 = $this->getFormulaFromStructure($formula1);
+            if ($type == DataValidation::TYPE_LIST) {
+                $formula1 = str_replace(chr(0), ',', $formula1);
+            }
+        } catch (PhpSpreadsheetException $e) {
+            return;
+        }
+        $offset += $sz1;
+        $sz2 = self::getUInt2d($recordData, $offset);
+        $offset += 2;
+        $offset += 2;
+        $formula2 = substr($recordData, $offset, $sz2);
+        $formula2 = pack('v', $sz2) . $formula2; // prepend the length
+        try {
+            $formula2 = $this->getFormulaFromStructure($formula2);
+        } catch (PhpSpreadsheetException) {
+            return;
+        }
+        $offset += $sz2;
+        $cellRangeAddressList = $this->readBIFF8CellRangeAddressList(substr($recordData, $offset));
+        $cellRangeAddresses = $cellRangeAddressList['cellRangeAddresses'];
+        foreach ($cellRangeAddresses as $cellRange) {
+            $stRange = $this->phpSheet->shrinkRangeToFit($cellRange);
+            foreach (Coordinate::extractAllCellReferencesInRange($stRange) as $coordinate) {
+                $objValidation = $this->phpSheet->getCell($coordinate)->getDataValidation();
+                $objValidation->setType($type);
+                $objValidation->setErrorStyle($errorStyle);
+                $objValidation->setAllowBlank((bool) $allowBlank);
+                $objValidation->setShowInputMessage((bool) $showInputMessage);
+                $objValidation->setShowErrorMessage((bool) $showErrorMessage);
+                $objValidation->setShowDropDown(!$suppressDropDown);
+                $objValidation->setOperator($operator);
+                $objValidation->setErrorTitle($errorTitle);
+                $objValidation->setError($error);
+                $objValidation->setPromptTitle($promptTitle);
+                $objValidation->setPrompt($prompt);
+                $objValidation->setFormula1($formula1);
+                $objValidation->setFormula2($formula2);
+            }
+        }
+    }
+    /**
+     * Read SHEETLAYOUT record. Stores sheet tab color information.
+     */
+    private function readSheetLayout(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if (!$this->readDataOnly) {
+            $sz = self::getInt4d($recordData, 12);
+            switch ($sz) {
+                case 0x14:
+                    $colorIndex = self::getUInt2d($recordData, 16);
+                    $color = Xls\Color::map($colorIndex, $this->palette, $this->version);
+                    $this->phpSheet->getTabColor()->setRGB($color['rgb']);
+                    break;
+                case 0x28:
+                    return;
+            }
+        }
+    }
+    /**
+     * Read SHEETPROTECTION record (FEATHEADR).
+     */
+    private function readSheetProtection(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $isf = self::getUInt2d($recordData, 12);
+        if ($isf != 2) {
+            return;
+        }
+        $options = self::getUInt2d($recordData, 19);
+        $bool = (0x0001 & $options) >> 0;
+        $this->phpSheet->getProtection()->setObjects((bool) $bool);
+        $bool = (0x0002 & $options) >> 1;
+        $this->phpSheet->getProtection()->setScenarios((bool) $bool);
+        $bool = (0x0004 & $options) >> 2;
+        $this->phpSheet->getProtection()->setFormatCells(!$bool);
+        $bool = (0x0008 & $options) >> 3;
+        $this->phpSheet->getProtection()->setFormatColumns(!$bool);
+        $bool = (0x0010 & $options) >> 4;
+        $this->phpSheet->getProtection()->setFormatRows(!$bool);
+        $bool = (0x0020 & $options) >> 5;
+        $this->phpSheet->getProtection()->setInsertColumns(!$bool);
+        $bool = (0x0040 & $options) >> 6;
+        $this->phpSheet->getProtection()->setInsertRows(!$bool);
+        $bool = (0x0080 & $options) >> 7;
+        $this->phpSheet->getProtection()->setInsertHyperlinks(!$bool);
+        $bool = (0x0100 & $options) >> 8;
+        $this->phpSheet->getProtection()->setDeleteColumns(!$bool);
+        $bool = (0x0200 & $options) >> 9;
+        $this->phpSheet->getProtection()->setDeleteRows(!$bool);
+        $bool = (0x0400 & $options) >> 10;
+        $this->phpSheet->getProtection()->setSelectLockedCells((bool) $bool);
+        $bool = (0x0800 & $options) >> 11;
+        $this->phpSheet->getProtection()->setSort(!$bool);
+        $bool = (0x1000 & $options) >> 12;
+        $this->phpSheet->getProtection()->setAutoFilter(!$bool);
+        $bool = (0x2000 & $options) >> 13;
+        $this->phpSheet->getProtection()->setPivotTables(!$bool);
+        $bool = (0x4000 & $options) >> 14;
+        $this->phpSheet->getProtection()->setSelectUnlockedCells((bool) $bool);
+    }
+    /**
+     * Read RANGEPROTECTION record
+     * Reading of this record is based on Microsoft Office Excel 97-2000 Binary File Format Specification,
+     * where it is referred to as FEAT record.
+     */
+    private function readRangeProtection(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        $offset = 0;
+        if (!$this->readDataOnly) {
+            $offset += 12;
+            $isf = self::getUInt2d($recordData, 12);
+            if ($isf != 2) {
+                return;
+            }
+            $offset += 2;
+            $offset += 5;
+            $cref = self::getUInt2d($recordData, 19);
+            $offset += 2;
+            $offset += 6;
+            $cellRanges = [];
+            for ($i = 0; $i < $cref; ++$i) {
+                try {
+                    $cellRange = $this->readBIFF8CellRangeAddressFixed(substr($recordData, 27 + 8 * $i, 8));
+                } catch (PhpSpreadsheetException) {
+                    return;
+                }
+                $cellRanges[] = $cellRange;
+                $offset += 8;
+            }
+            $offset += 4;
+            $wPassword = self::getInt4d($recordData, $offset);
+            $offset += 4;
+            if ($cellRanges) {
+                $this->phpSheet->protectCells(implode(' ', $cellRanges), ($wPassword === 0) ? '' : strtoupper(dechex($wPassword)), true);
+            }
+        }
+    }
+    /**
+     * Read a free CONTINUE record. Free CONTINUE record may be a camouflaged MSODRAWING record
+     * When MSODRAWING data on a sheet exceeds 8224 bytes, CONTINUE records are used instead. Undocumented.
+     * In this case, we must treat the CONTINUE record as a MSODRAWING record.
+     */
+    private function readContinue(): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        if ($this->drawingData == '') {
+            $this->pos += 4 + $length;
+            return;
+        }
+        if ($length < 4) {
+            $this->pos += 4 + $length;
+            return;
+        }
+        $validSplitPoints = [0xF003, 0xF004, 0xF00D]; // add identifiers if we find more
+        $splitPoint = self::getUInt2d($recordData, 2);
+        if (in_array($splitPoint, $validSplitPoints)) {
+            $splicedRecordData = $this->getSplicedRecordData();
+            $this->drawingData .= $splicedRecordData['recordData'];
+            return;
+        }
+        $this->pos += 4 + $length;
+    }
+    /**
+     * Reads a record from current position in data stream and continues reading data as long as CONTINUE
+     * records are found. Splices the record data pieces and returns the combined string as if record data
+     * is in one piece.
+     * Moves to next current position in data stream to start of next record different from a CONtINUE record.
+     */
+    private function getSplicedRecordData(): array
+    {
+        $data = '';
+        $spliceOffsets = [];
+        $i = 0;
+        $spliceOffsets[0] = 0;
+        do {
+            ++$i;
+            $length = self::getUInt2d($this->data, $this->pos + 2);
+            $data .= $this->readRecordData($this->data, $this->pos + 4, $length);
+            $spliceOffsets[$i] = $spliceOffsets[$i - 1] + $length;
+            $this->pos += 4 + $length;
+            $nextIdentifier = self::getUInt2d($this->data, $this->pos);
+        } while ($nextIdentifier == self::XLS_TYPE_CONTINUE);
+        return [
+            'recordData' => $data,
+            'spliceOffsets' => $spliceOffsets,
+        ];
+    }
+    /**
+     * Convert formula structure into human readable Excel formula like 'A3+A5*5'.
+     *
+     * @param string $formulaStructure The complete binary data for the formula
+     * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
+     *
+     * @return string Human readable formula
+     */
+    private function getFormulaFromStructure(string $formulaStructure, string $baseCell = 'A1'): string
+    {
+        $sz = self::getUInt2d($formulaStructure, 0);
+        $formulaData = substr($formulaStructure, 2, $sz);
+        if (strlen($formulaStructure) > 2 + $sz) {
+            $additionalData = substr($formulaStructure, 2 + $sz);
+        } else {
+            $additionalData = '';
+        }
+        return $this->getFormulaFromData($formulaData, $additionalData, $baseCell);
+    }
+    /**
+     * Take formula data and additional data for formula and return human readable formula.
+     *
+     * @param string $formulaData The binary data for the formula itself
+     * @param string $additionalData Additional binary data going with the formula
+     * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
+     *
+     * @return string Human readable formula
+     */
+    private function getFormulaFromData(string $formulaData, string $additionalData = '', string $baseCell = 'A1'): string
+    {
+        $tokens = [];
+        while ($formulaData !== '' && $token = $this->getNextToken($formulaData, $baseCell)) {
+            $tokens[] = $token;
+            $formulaData = substr($formulaData, $token['size']);
+        }
+        $formulaString = $this->createFormulaFromTokens($tokens, $additionalData);
+        return $formulaString;
+    }
+    /**
+     * Take array of tokens together with additional data for formula and return human readable formula.
+     *
+     * @param string $additionalData Additional binary data going with the formula
+     *
+     * @return string Human readable formula
+     */
+    private function createFormulaFromTokens(array $tokens, string $additionalData): string
+    {
+        if (empty($tokens)) {
+            return '';
+        }
+        $formulaStrings = [];
+        foreach ($tokens as $token) {
+            $space0 = $space0 ?? ''; // spaces before next token, not tParen
+            $space1 = $space1 ?? ''; // carriage returns before next token, not tParen
+            $space2 = $space2 ?? ''; // spaces before opening parenthesis
+            $space3 = $space3 ?? ''; // carriage returns before opening parenthesis
+            $space4 = $space4 ?? ''; // spaces before closing parenthesis
+            $space5 = $space5 ?? ''; // carriage returns before closing parenthesis
+            switch ($token['name']) {
+                case 'tAdd': // addition
+                case 'tConcat': // addition
+                case 'tDiv': // division
+                case 'tEQ': // equality
+                case 'tGE': // greater than or equal
+                case 'tGT': // greater than
+                case 'tIsect': // intersection
+                case 'tLE': // less than or equal
+                case 'tList': // less than or equal
+                case 'tLT': // less than
+                case 'tMul': // multiplication
+                case 'tNE': // multiplication
+                case 'tPower': // power
+                case 'tRange': // range
+                case 'tSub': // subtraction
+                    $op2 = array_pop($formulaStrings);
+                    $op1 = array_pop($formulaStrings);
+                    $formulaStrings[] = "$op1$space1$space0{$token['data']}$op2";
+                    unset($space0, $space1);
+                    break;
+                case 'tUplus': // unary plus
+                case 'tUminus': // unary minus
+                    $op = array_pop($formulaStrings);
+                    $formulaStrings[] = "$space1$space0{$token['data']}$op";
+                    unset($space0, $space1);
+                    break;
+                case 'tPercent': // percent sign
+                    $op = array_pop($formulaStrings);
+                    $formulaStrings[] = "$op$space1$space0{$token['data']}";
+                    unset($space0, $space1);
+                    break;
+                case 'tAttrVolatile': // indicates volatile function
+                case 'tAttrIf':
+                case 'tAttrSkip':
+                case 'tAttrChoose':
+                    break;
+                case 'tAttrSpace': // space / carriage return
+                    switch ($token['data']['spacetype']) {
+                        case 'type0':
+                            $space0 = str_repeat(' ', $token['data']['spacecount']);
+                            break;
+                        case 'type1':
+                            $space1 = str_repeat("\n", $token['data']['spacecount']);
+                            break;
+                        case 'type2':
+                            $space2 = str_repeat(' ', $token['data']['spacecount']);
+                            break;
+                        case 'type3':
+                            $space3 = str_repeat("\n", $token['data']['spacecount']);
+                            break;
+                        case 'type4':
+                            $space4 = str_repeat(' ', $token['data']['spacecount']);
+                            break;
+                        case 'type5':
+                            $space5 = str_repeat("\n", $token['data']['spacecount']);
+                            break;
+                    }
+                    break;
+                case 'tAttrSum': // SUM function with one parameter
+                    $op = array_pop($formulaStrings);
+                    $formulaStrings[] = "{$space1}{$space0}SUM($op)";
+                    unset($space0, $space1);
+                    break;
+                case 'tFunc': // function with fixed number of arguments
+                case 'tFuncV': // function with variable number of arguments
+                    if ($token['data']['function'] != '') {
+                        $ops = []; // array of operators
+                        for ($i = 0; $i < $token['data']['args']; ++$i) {
+                            $ops[] = array_pop($formulaStrings);
+                        }
+                        $ops = array_reverse($ops);
+                        $formulaStrings[] = "$space1$space0{$token['data']['function']}(" . implode(',', $ops) . ')';
+                        unset($space0, $space1);
+                    } else {
+                        $ops = []; // array of operators
+                        for ($i = 0; $i < $token['data']['args'] - 1; ++$i) {
+                            $ops[] = array_pop($formulaStrings);
+                        }
+                        $ops = array_reverse($ops);
+                        $function = array_pop($formulaStrings);
+                        $formulaStrings[] = "$space1$space0$function(" . implode(',', $ops) . ')';
+                        unset($space0, $space1);
+                    }
+                    break;
+                case 'tParen': // parenthesis
+                    $expression = array_pop($formulaStrings);
+                    $formulaStrings[] = "$space3$space2($expression$space5$space4)";
+                    unset($space2, $space3, $space4, $space5);
+                    break;
+                case 'tArray': // array constant
+                    $constantArray = self::readBIFF8ConstantArray($additionalData);
+                    $formulaStrings[] = $space1 . $space0 . $constantArray['value'];
+                    $additionalData = substr($additionalData, $constantArray['size']); // bite of chunk of additional data
+                    unset($space0, $space1);
+                    break;
+                case 'tMemArea':
+                    $cellRangeAddressList = $this->readBIFF8CellRangeAddressList($additionalData);
+                    $additionalData = substr($additionalData, $cellRangeAddressList['size']);
+                    $formulaStrings[] = "$space1$space0{$token['data']}";
+                    unset($space0, $space1);
+                    break;
+                case 'tArea': // cell range address
+                case 'tBool': // boolean
+                case 'tErr': // error code
+                case 'tInt': // integer
+                case 'tMemErr':
+                case 'tMemFunc':
+                case 'tMissArg':
+                case 'tName':
+                case 'tNameX':
+                case 'tNum': // number
+                case 'tRef': // single cell reference
+                case 'tRef3d': // 3d cell reference
+                case 'tArea3d': // 3d cell range reference
+                case 'tRefN':
+                case 'tAreaN':
+                case 'tStr': // string
+                    $formulaStrings[] = "$space1$space0{$token['data']}";
+                    unset($space0, $space1);
+                    break;
+            }
+        }
+        $formulaString = $formulaStrings[0];
+        return $formulaString;
+    }
+    /**
+     * Fetch next token from binary formula data.
+     *
+     * @param string $formulaData Formula data
+     * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
+     */
+    private function getNextToken(string $formulaData, string $baseCell = 'A1'): array
+    {
+        $id = ord($formulaData[0]); // token id
+        $name = false; // initialize token name
+        switch ($id) {
+            case 0x03:
+                $name = 'tAdd';
+                $size = 1;
+                $data = '+';
+                break;
+            case 0x04:
+                $name = 'tSub';
+                $size = 1;
+                $data = '-';
+                break;
+            case 0x05:
+                $name = 'tMul';
+                $size = 1;
+                $data = '*';
+                break;
+            case 0x06:
+                $name = 'tDiv';
+                $size = 1;
+                $data = '/';
+                break;
+            case 0x07:
+                $name = 'tPower';
+                $size = 1;
+                $data = '^';
+                break;
+            case 0x08:
+                $name = 'tConcat';
+                $size = 1;
+                $data = '&';
+                break;
+            case 0x09:
+                $name = 'tLT';
+                $size = 1;
+                $data = '<';
+                break;
+            case 0x0A:
+                $name = 'tLE';
+                $size = 1;
+                $data = '<=';
+                break;
+            case 0x0B:
+                $name = 'tEQ';
+                $size = 1;
+                $data = '=';
+                break;
+            case 0x0C:
+                $name = 'tGE';
+                $size = 1;
+                $data = '>=';
+                break;
+            case 0x0D:
+                $name = 'tGT';
+                $size = 1;
+                $data = '>';
+                break;
+            case 0x0E:
+                $name = 'tNE';
+                $size = 1;
+                $data = '<>';
+                break;
+            case 0x0F:
+                $name = 'tIsect';
+                $size = 1;
+                $data = ' ';
+                break;
+            case 0x10:
+                $name = 'tList';
+                $size = 1;
+                $data = ',';
+                break;
+            case 0x11:
+                $name = 'tRange';
+                $size = 1;
+                $data = ':';
+                break;
+            case 0x12:
+                $name = 'tUplus';
+                $size = 1;
+                $data = '+';
+                break;
+            case 0x13:
+                $name = 'tUminus';
+                $size = 1;
+                $data = '-';
+                break;
+            case 0x14:
+                $name = 'tPercent';
+                $size = 1;
+                $data = '%';
+                break;
+            case 0x15:    //    parenthesis
+                $name = 'tParen';
+                $size = 1;
+                $data = null;
+                break;
+            case 0x16:    //    missing argument
+                $name = 'tMissArg';
+                $size = 1;
+                $data = '';
+                break;
+            case 0x17:    //    string
+                $name = 'tStr';
+                $string = self::readUnicodeStringShort(substr($formulaData, 1));
+                $size = 1 + $string['size'];
+                $data = self::UTF8toExcelDoubleQuoted($string['value']);
+                break;
+            case 0x19:    //    Special attribute
+                switch (ord($formulaData[1])) {
+                    case 0x01:
+                        $name = 'tAttrVolatile';
+                        $size = 4;
+                        $data = null;
+                        break;
+                    case 0x02:
+                        $name = 'tAttrIf';
+                        $size = 4;
+                        $data = null;
+                        break;
+                    case 0x04:
+                        $name = 'tAttrChoose';
+                        $nc = self::getUInt2d($formulaData, 2);
+                        $size = 2 * $nc + 6;
+                        $data = null;
+                        break;
+                    case 0x08:
+                        $name = 'tAttrSkip';
+                        $size = 4;
+                        $data = null;
+                        break;
+                    case 0x10:
+                        $name = 'tAttrSum';
+                        $size = 4;
+                        $data = null;
+                        break;
+                    case 0x40:
+                    case 0x41:
+                        $name = 'tAttrSpace';
+                        $size = 4;
+                        $spacetype = match (ord($formulaData[2])) {
+                            0x00 => 'type0',
+                            0x01 => 'type1',
+                            0x02 => 'type2',
+                            0x03 => 'type3',
+                            0x04 => 'type4',
+                            0x05 => 'type5',
+                            default => throw new Exception('Unrecognized space type in tAttrSpace token'),
+                        };
+                        $spacecount = ord($formulaData[3]);
+                        $data = ['spacetype' => $spacetype, 'spacecount' => $spacecount];
+                        break;
+                    default:
+                        throw new Exception('Unrecognized attribute flag in tAttr token');
+                }
+                break;
+            case 0x1C:    //    error code
+                $name = 'tErr';
+                $size = 2;
+                $data = Xls\ErrorCode::lookup(ord($formulaData[1]));
+                break;
+            case 0x1D:    //    boolean
+                $name = 'tBool';
+                $size = 2;
+                $data = ord($formulaData[1]) ? 'TRUE' : 'FALSE';
+                break;
+            case 0x1E:    //    integer
+                $name = 'tInt';
+                $size = 3;
+                $data = self::getUInt2d($formulaData, 1);
+                break;
+            case 0x1F:    //    number
+                $name = 'tNum';
+                $size = 9;
+                $data = self::extractNumber(substr($formulaData, 1));
+                $data = str_replace(',', '.', (string) $data); // in case non-English locale
+                break;
+            case 0x20:    //    array constant
+            case 0x40:
+            case 0x60:
+                $name = 'tArray';
+                $size = 8;
+                $data = null;
+                break;
+            case 0x21:    //    function with fixed number of arguments
+            case 0x41:
+            case 0x61:
+                $name = 'tFunc';
+                $size = 3;
+                switch (self::getUInt2d($formulaData, 1)) {
+                    case 2:
+                        $function = 'ISNA';
+                        $args = 1;
+                        break;
+                    case 3:
+                        $function = 'ISERROR';
+                        $args = 1;
+                        break;
+                    case 10:
+                        $function = 'NA';
+                        $args = 0;
+                        break;
+                    case 15:
+                        $function = 'SIN';
+                        $args = 1;
+                        break;
+                    case 16:
+                        $function = 'COS';
+                        $args = 1;
+                        break;
+                    case 17:
+                        $function = 'TAN';
+                        $args = 1;
+                        break;
+                    case 18:
+                        $function = 'ATAN';
+                        $args = 1;
+                        break;
+                    case 19:
+                        $function = 'PI';
+                        $args = 0;
+                        break;
+                    case 20:
+                        $function = 'SQRT';
+                        $args = 1;
+                        break;
+                    case 21:
+                        $function = 'EXP';
+                        $args = 1;
+                        break;
+                    case 22:
+                        $function = 'LN';
+                        $args = 1;
+                        break;
+                    case 23:
+                        $function = 'LOG10';
+                        $args = 1;
+                        break;
+                    case 24:
+                        $function = 'ABS';
+                        $args = 1;
+                        break;
+                    case 25:
+                        $function = 'INT';
+                        $args = 1;
+                        break;
+                    case 26:
+                        $function = 'SIGN';
+                        $args = 1;
+                        break;
+                    case 27:
+                        $function = 'ROUND';
+                        $args = 2;
+                        break;
+                    case 30:
+                        $function = 'REPT';
+                        $args = 2;
+                        break;
+                    case 31:
+                        $function = 'MID';
+                        $args = 3;
+                        break;
+                    case 32:
+                        $function = 'LEN';
+                        $args = 1;
+                        break;
+                    case 33:
+                        $function = 'VALUE';
+                        $args = 1;
+                        break;
+                    case 34:
+                        $function = 'TRUE';
+                        $args = 0;
+                        break;
+                    case 35:
+                        $function = 'FALSE';
+                        $args = 0;
+                        break;
+                    case 38:
+                        $function = 'NOT';
+                        $args = 1;
+                        break;
+                    case 39:
+                        $function = 'MOD';
+                        $args = 2;
+                        break;
+                    case 40:
+                        $function = 'DCOUNT';
+                        $args = 3;
+                        break;
+                    case 41:
+                        $function = 'DSUM';
+                        $args = 3;
+                        break;
+                    case 42:
+                        $function = 'DAVERAGE';
+                        $args = 3;
+                        break;
+                    case 43:
+                        $function = 'DMIN';
+                        $args = 3;
+                        break;
+                    case 44:
+                        $function = 'DMAX';
+                        $args = 3;
+                        break;
+                    case 45:
+                        $function = 'DSTDEV';
+                        $args = 3;
+                        break;
+                    case 48:
+                        $function = 'TEXT';
+                        $args = 2;
+                        break;
+                    case 61:
+                        $function = 'MIRR';
+                        $args = 3;
+                        break;
+                    case 63:
+                        $function = 'RAND';
+                        $args = 0;
+                        break;
+                    case 65:
+                        $function = 'DATE';
+                        $args = 3;
+                        break;
+                    case 66:
+                        $function = 'TIME';
+                        $args = 3;
+                        break;
+                    case 67:
+                        $function = 'DAY';
+                        $args = 1;
+                        break;
+                    case 68:
+                        $function = 'MONTH';
+                        $args = 1;
+                        break;
+                    case 69:
+                        $function = 'YEAR';
+                        $args = 1;
+                        break;
+                    case 71:
+                        $function = 'HOUR';
+                        $args = 1;
+                        break;
+                    case 72:
+                        $function = 'MINUTE';
+                        $args = 1;
+                        break;
+                    case 73:
+                        $function = 'SECOND';
+                        $args = 1;
+                        break;
+                    case 74:
+                        $function = 'NOW';
+                        $args = 0;
+                        break;
+                    case 75:
+                        $function = 'AREAS';
+                        $args = 1;
+                        break;
+                    case 76:
+                        $function = 'ROWS';
+                        $args = 1;
+                        break;
+                    case 77:
+                        $function = 'COLUMNS';
+                        $args = 1;
+                        break;
+                    case 83:
+                        $function = 'TRANSPOSE';
+                        $args = 1;
+                        break;
+                    case 86:
+                        $function = 'TYPE';
+                        $args = 1;
+                        break;
+                    case 97:
+                        $function = 'ATAN2';
+                        $args = 2;
+                        break;
+                    case 98:
+                        $function = 'ASIN';
+                        $args = 1;
+                        break;
+                    case 99:
+                        $function = 'ACOS';
+                        $args = 1;
+                        break;
+                    case 105:
+                        $function = 'ISREF';
+                        $args = 1;
+                        break;
+                    case 111:
+                        $function = 'CHAR';
+                        $args = 1;
+                        break;
+                    case 112:
+                        $function = 'LOWER';
+                        $args = 1;
+                        break;
+                    case 113:
+                        $function = 'UPPER';
+                        $args = 1;
+                        break;
+                    case 114:
+                        $function = 'PROPER';
+                        $args = 1;
+                        break;
+                    case 117:
+                        $function = 'EXACT';
+                        $args = 2;
+                        break;
+                    case 118:
+                        $function = 'TRIM';
+                        $args = 1;
+                        break;
+                    case 119:
+                        $function = 'REPLACE';
+                        $args = 4;
+                        break;
+                    case 121:
+                        $function = 'CODE';
+                        $args = 1;
+                        break;
+                    case 126:
+                        $function = 'ISERR';
+                        $args = 1;
+                        break;
+                    case 127:
+                        $function = 'ISTEXT';
+                        $args = 1;
+                        break;
+                    case 128:
+                        $function = 'ISNUMBER';
+                        $args = 1;
+                        break;
+                    case 129:
+                        $function = 'ISBLANK';
+                        $args = 1;
+                        break;
+                    case 130:
+                        $function = 'T';
+                        $args = 1;
+                        break;
+                    case 131:
+                        $function = 'N';
+                        $args = 1;
+                        break;
+                    case 140:
+                        $function = 'DATEVALUE';
+                        $args = 1;
+                        break;
+                    case 141:
+                        $function = 'TIMEVALUE';
+                        $args = 1;
+                        break;
+                    case 142:
+                        $function = 'SLN';
+                        $args = 3;
+                        break;
+                    case 143:
+                        $function = 'SYD';
+                        $args = 4;
+                        break;
+                    case 162:
+                        $function = 'CLEAN';
+                        $args = 1;
+                        break;
+                    case 163:
+                        $function = 'MDETERM';
+                        $args = 1;
+                        break;
+                    case 164:
+                        $function = 'MINVERSE';
+                        $args = 1;
+                        break;
+                    case 165:
+                        $function = 'MMULT';
+                        $args = 2;
+                        break;
+                    case 184:
+                        $function = 'FACT';
+                        $args = 1;
+                        break;
+                    case 189:
+                        $function = 'DPRODUCT';
+                        $args = 3;
+                        break;
+                    case 190:
+                        $function = 'ISNONTEXT';
+                        $args = 1;
+                        break;
+                    case 195:
+                        $function = 'DSTDEVP';
+                        $args = 3;
+                        break;
+                    case 196:
+                        $function = 'DVARP';
+                        $args = 3;
+                        break;
+                    case 198:
+                        $function = 'ISLOGICAL';
+                        $args = 1;
+                        break;
+                    case 199:
+                        $function = 'DCOUNTA';
+                        $args = 3;
+                        break;
+                    case 207:
+                        $function = 'REPLACEB';
+                        $args = 4;
+                        break;
+                    case 210:
+                        $function = 'MIDB';
+                        $args = 3;
+                        break;
+                    case 211:
+                        $function = 'LENB';
+                        $args = 1;
+                        break;
+                    case 212:
+                        $function = 'ROUNDUP';
+                        $args = 2;
+                        break;
+                    case 213:
+                        $function = 'ROUNDDOWN';
+                        $args = 2;
+                        break;
+                    case 214:
+                        $function = 'ASC';
+                        $args = 1;
+                        break;
+                    case 215:
+                        $function = 'DBCS';
+                        $args = 1;
+                        break;
+                    case 221:
+                        $function = 'TODAY';
+                        $args = 0;
+                        break;
+                    case 229:
+                        $function = 'SINH';
+                        $args = 1;
+                        break;
+                    case 230:
+                        $function = 'COSH';
+                        $args = 1;
+                        break;
+                    case 231:
+                        $function = 'TANH';
+                        $args = 1;
+                        break;
+                    case 232:
+                        $function = 'ASINH';
+                        $args = 1;
+                        break;
+                    case 233:
+                        $function = 'ACOSH';
+                        $args = 1;
+                        break;
+                    case 234:
+                        $function = 'ATANH';
+                        $args = 1;
+                        break;
+                    case 235:
+                        $function = 'DGET';
+                        $args = 3;
+                        break;
+                    case 244:
+                        $function = 'INFO';
+                        $args = 1;
+                        break;
+                    case 252:
+                        $function = 'FREQUENCY';
+                        $args = 2;
+                        break;
+                    case 261:
+                        $function = 'ERROR.TYPE';
+                        $args = 1;
+                        break;
+                    case 271:
+                        $function = 'GAMMALN';
+                        $args = 1;
+                        break;
+                    case 273:
+                        $function = 'BINOMDIST';
+                        $args = 4;
+                        break;
+                    case 274:
+                        $function = 'CHIDIST';
+                        $args = 2;
+                        break;
+                    case 275:
+                        $function = 'CHIINV';
+                        $args = 2;
+                        break;
+                    case 276:
+                        $function = 'COMBIN';
+                        $args = 2;
+                        break;
+                    case 277:
+                        $function = 'CONFIDENCE';
+                        $args = 3;
+                        break;
+                    case 278:
+                        $function = 'CRITBINOM';
+                        $args = 3;
+                        break;
+                    case 279:
+                        $function = 'EVEN';
+                        $args = 1;
+                        break;
+                    case 280:
+                        $function = 'EXPONDIST';
+                        $args = 3;
+                        break;
+                    case 281:
+                        $function = 'FDIST';
+                        $args = 3;
+                        break;
+                    case 282:
+                        $function = 'FINV';
+                        $args = 3;
+                        break;
+                    case 283:
+                        $function = 'FISHER';
+                        $args = 1;
+                        break;
+                    case 284:
+                        $function = 'FISHERINV';
+                        $args = 1;
+                        break;
+                    case 285:
+                        $function = 'FLOOR';
+                        $args = 2;
+                        break;
+                    case 286:
+                        $function = 'GAMMADIST';
+                        $args = 4;
+                        break;
+                    case 287:
+                        $function = 'GAMMAINV';
+                        $args = 3;
+                        break;
+                    case 288:
+                        $function = 'CEILING';
+                        $args = 2;
+                        break;
+                    case 289:
+                        $function = 'HYPGEOMDIST';
+                        $args = 4;
+                        break;
+                    case 290:
+                        $function = 'LOGNORMDIST';
+                        $args = 3;
+                        break;
+                    case 291:
+                        $function = 'LOGINV';
+                        $args = 3;
+                        break;
+                    case 292:
+                        $function = 'NEGBINOMDIST';
+                        $args = 3;
+                        break;
+                    case 293:
+                        $function = 'NORMDIST';
+                        $args = 4;
+                        break;
+                    case 294:
+                        $function = 'NORMSDIST';
+                        $args = 1;
+                        break;
+                    case 295:
+                        $function = 'NORMINV';
+                        $args = 3;
+                        break;
+                    case 296:
+                        $function = 'NORMSINV';
+                        $args = 1;
+                        break;
+                    case 297:
+                        $function = 'STANDARDIZE';
+                        $args = 3;
+                        break;
+                    case 298:
+                        $function = 'ODD';
+                        $args = 1;
+                        break;
+                    case 299:
+                        $function = 'PERMUT';
+                        $args = 2;
+                        break;
+                    case 300:
+                        $function = 'POISSON';
+                        $args = 3;
+                        break;
+                    case 301:
+                        $function = 'TDIST';
+                        $args = 3;
+                        break;
+                    case 302:
+                        $function = 'WEIBULL';
+                        $args = 4;
+                        break;
+                    case 303:
+                        $function = 'SUMXMY2';
+                        $args = 2;
+                        break;
+                    case 304:
+                        $function = 'SUMX2MY2';
+                        $args = 2;
+                        break;
+                    case 305:
+                        $function = 'SUMX2PY2';
+                        $args = 2;
+                        break;
+                    case 306:
+                        $function = 'CHITEST';
+                        $args = 2;
+                        break;
+                    case 307:
+                        $function = 'CORREL';
+                        $args = 2;
+                        break;
+                    case 308:
+                        $function = 'COVAR';
+                        $args = 2;
+                        break;
+                    case 309:
+                        $function = 'FORECAST';
+                        $args = 3;
+                        break;
+                    case 310:
+                        $function = 'FTEST';
+                        $args = 2;
+                        break;
+                    case 311:
+                        $function = 'INTERCEPT';
+                        $args = 2;
+                        break;
+                    case 312:
+                        $function = 'PEARSON';
+                        $args = 2;
+                        break;
+                    case 313:
+                        $function = 'RSQ';
+                        $args = 2;
+                        break;
+                    case 314:
+                        $function = 'STEYX';
+                        $args = 2;
+                        break;
+                    case 315:
+                        $function = 'SLOPE';
+                        $args = 2;
+                        break;
+                    case 316:
+                        $function = 'TTEST';
+                        $args = 4;
+                        break;
+                    case 325:
+                        $function = 'LARGE';
+                        $args = 2;
+                        break;
+                    case 326:
+                        $function = 'SMALL';
+                        $args = 2;
+                        break;
+                    case 327:
+                        $function = 'QUARTILE';
+                        $args = 2;
+                        break;
+                    case 328:
+                        $function = 'PERCENTILE';
+                        $args = 2;
+                        break;
+                    case 331:
+                        $function = 'TRIMMEAN';
+                        $args = 2;
+                        break;
+                    case 332:
+                        $function = 'TINV';
+                        $args = 2;
+                        break;
+                    case 337:
+                        $function = 'POWER';
+                        $args = 2;
+                        break;
+                    case 342:
+                        $function = 'RADIANS';
+                        $args = 1;
+                        break;
+                    case 343:
+                        $function = 'DEGREES';
+                        $args = 1;
+                        break;
+                    case 346:
+                        $function = 'COUNTIF';
+                        $args = 2;
+                        break;
+                    case 347:
+                        $function = 'COUNTBLANK';
+                        $args = 1;
+                        break;
+                    case 350:
+                        $function = 'ISPMT';
+                        $args = 4;
+                        break;
+                    case 351:
+                        $function = 'DATEDIF';
+                        $args = 3;
+                        break;
+                    case 352:
+                        $function = 'DATESTRING';
+                        $args = 1;
+                        break;
+                    case 353:
+                        $function = 'NUMBERSTRING';
+                        $args = 2;
+                        break;
+                    case 360:
+                        $function = 'PHONETIC';
+                        $args = 1;
+                        break;
+                    case 368:
+                        $function = 'BAHTTEXT';
+                        $args = 1;
+                        break;
+                    default:
+                        throw new Exception('Unrecognized function in formula');
+                }
+                $data = ['function' => $function, 'args' => $args];
+                break;
+            case 0x22:    //    function with variable number of arguments
+            case 0x42:
+            case 0x62:
+                $name = 'tFuncV';
+                $size = 4;
+                $args = ord($formulaData[1]);
+                $index = self::getUInt2d($formulaData, 2);
+                $function = match ($index) {
+                    0 => 'COUNT',
+                    1 => 'IF',
+                    4 => 'SUM',
+                    5 => 'AVERAGE',
+                    6 => 'MIN',
+                    7 => 'MAX',
+                    8 => 'ROW',
+                    9 => 'COLUMN',
+                    11 => 'NPV',
+                    12 => 'STDEV',
+                    13 => 'DOLLAR',
+                    14 => 'FIXED',
+                    28 => 'LOOKUP',
+                    29 => 'INDEX',
+                    36 => 'AND',
+                    37 => 'OR',
+                    46 => 'VAR',
+                    49 => 'LINEST',
+                    50 => 'TREND',
+                    51 => 'LOGEST',
+                    52 => 'GROWTH',
+                    56 => 'PV',
+                    57 => 'FV',
+                    58 => 'NPER',
+                    59 => 'PMT',
+                    60 => 'RATE',
+                    62 => 'IRR',
+                    64 => 'MATCH',
+                    70 => 'WEEKDAY',
+                    78 => 'OFFSET',
+                    82 => 'SEARCH',
+                    100 => 'CHOOSE',
+                    101 => 'HLOOKUP',
+                    102 => 'VLOOKUP',
+                    109 => 'LOG',
+                    115 => 'LEFT',
+                    116 => 'RIGHT',
+                    120 => 'SUBSTITUTE',
+                    124 => 'FIND',
+                    125 => 'CELL',
+                    144 => 'DDB',
+                    148 => 'INDIRECT',
+                    167 => 'IPMT',
+                    168 => 'PPMT',
+                    169 => 'COUNTA',
+                    183 => 'PRODUCT',
+                    193 => 'STDEVP',
+                    194 => 'VARP',
+                    197 => 'TRUNC',
+                    204 => 'USDOLLAR',
+                    205 => 'FINDB',
+                    206 => 'SEARCHB',
+                    208 => 'LEFTB',
+                    209 => 'RIGHTB',
+                    216 => 'RANK',
+                    219 => 'ADDRESS',
+                    220 => 'DAYS360',
+                    222 => 'VDB',
+                    227 => 'MEDIAN',
+                    228 => 'SUMPRODUCT',
+                    247 => 'DB',
+                    255 => '',
+                    269 => 'AVEDEV',
+                    270 => 'BETADIST',
+                    272 => 'BETAINV',
+                    317 => 'PROB',
+                    318 => 'DEVSQ',
+                    319 => 'GEOMEAN',
+                    320 => 'HARMEAN',
+                    321 => 'SUMSQ',
+                    322 => 'KURT',
+                    323 => 'SKEW',
+                    324 => 'ZTEST',
+                    329 => 'PERCENTRANK',
+                    330 => 'MODE',
+                    336 => 'CONCATENATE',
+                    344 => 'SUBTOTAL',
+                    345 => 'SUMIF',
+                    354 => 'ROMAN',
+                    358 => 'GETPIVOTDATA',
+                    359 => 'HYPERLINK',
+                    361 => 'AVERAGEA',
+                    362 => 'MAXA',
+                    363 => 'MINA',
+                    364 => 'STDEVPA',
+                    365 => 'VARPA',
+                    366 => 'STDEVA',
+                    367 => 'VARA',
+                    default => throw new Exception('Unrecognized function in formula'),
+                };
+                $data = ['function' => $function, 'args' => $args];
+                break;
+            case 0x23:    //    index to defined name
+            case 0x43:
+            case 0x63:
+                $name = 'tName';
+                $size = 5;
+                $definedNameIndex = self::getUInt2d($formulaData, 1) - 1;
+                $data = $this->definedname[$definedNameIndex]['name'] ?? '';
+                break;
+            case 0x24:    //    single cell reference e.g. A5
+            case 0x44:
+            case 0x64:
+                $name = 'tRef';
+                $size = 5;
+                $data = $this->readBIFF8CellAddress(substr($formulaData, 1, 4));
+                break;
+            case 0x25:    //    cell range reference to cells in the same sheet (2d)
+            case 0x45:
+            case 0x65:
+                $name = 'tArea';
+                $size = 9;
+                $data = $this->readBIFF8CellRangeAddress(substr($formulaData, 1, 8));
+                break;
+            case 0x26:    //    Constant reference sub-expression
+            case 0x46:
+            case 0x66:
+                $name = 'tMemArea';
+                $subSize = self::getUInt2d($formulaData, 5);
+                $size = 7 + $subSize;
+                $data = $this->getFormulaFromData(substr($formulaData, 7, $subSize));
+                break;
+            case 0x27:    //    Deleted constant reference sub-expression
+            case 0x47:
+            case 0x67:
+                $name = 'tMemErr';
+                $subSize = self::getUInt2d($formulaData, 5);
+                $size = 7 + $subSize;
+                $data = $this->getFormulaFromData(substr($formulaData, 7, $subSize));
+                break;
+            case 0x29:    //    Variable reference sub-expression
+            case 0x49:
+            case 0x69:
+                $name = 'tMemFunc';
+                $subSize = self::getUInt2d($formulaData, 1);
+                $size = 3 + $subSize;
+                $data = $this->getFormulaFromData(substr($formulaData, 3, $subSize));
+                break;
+            case 0x2C: // Relative 2d cell reference reference, used in shared formulas and some other places
+            case 0x4C:
+            case 0x6C:
+                $name = 'tRefN';
+                $size = 5;
+                $data = $this->readBIFF8CellAddressB(substr($formulaData, 1, 4), $baseCell);
+                break;
+            case 0x2D:    //    Relative 2d range reference
+            case 0x4D:
+            case 0x6D:
+                $name = 'tAreaN';
+                $size = 9;
+                $data = $this->readBIFF8CellRangeAddressB(substr($formulaData, 1, 8), $baseCell);
+                break;
+            case 0x39:    //    External name
+            case 0x59:
+            case 0x79:
+                $name = 'tNameX';
+                $size = 7;
+                $index = self::getUInt2d($formulaData, 3);
+                $data = $this->externalNames[$index - 1]['name'] ?? '';
+                break;
+            case 0x3A:    //    3d reference to cell
+            case 0x5A:
+            case 0x7A:
+                $name = 'tRef3d';
+                $size = 7;
+                try {
+                    $sheetRange = $this->readSheetRangeByRefIndex(self::getUInt2d($formulaData, 1));
+                    $cellAddress = $this->readBIFF8CellAddress(substr($formulaData, 3, 4));
+                    $data = "$sheetRange!$cellAddress";
+                } catch (PhpSpreadsheetException) {
+                    $data = '#REF!';
+                }
+                break;
+            case 0x3B:    //    3d reference to cell range
+            case 0x5B:
+            case 0x7B:
+                $name = 'tArea3d';
+                $size = 11;
+                try {
+                    $sheetRange = $this->readSheetRangeByRefIndex(self::getUInt2d($formulaData, 1));
+                    $cellRangeAddress = $this->readBIFF8CellRangeAddress(substr($formulaData, 3, 8));
+                    $data = "$sheetRange!$cellRangeAddress";
+                } catch (PhpSpreadsheetException) {
+                    $data = '#REF!';
+                }
+                break;
+            default:
+                throw new Exception('Unrecognized token ' . sprintf('%02X', $id) . ' in formula');
+        }
+        return [
+            'id' => $id,
+            'name' => $name,
+            'size' => $size,
+            'data' => $data,
+        ];
+    }
+    /**
+     * Reads a cell address in BIFF8 e.g. 'A2' or '$A$2'
+     * section 3.3.4.
+     */
+    private function readBIFF8CellAddress(string $cellAddressStructure): string
+    {
+        $row = self::getUInt2d($cellAddressStructure, 0) + 1;
+        $column = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($cellAddressStructure, 2)) + 1);
+        if (!(0x4000 & self::getUInt2d($cellAddressStructure, 2))) {
+            $column = '$' . $column;
+        }
+        if (!(0x8000 & self::getUInt2d($cellAddressStructure, 2))) {
+            $row = '$' . $row;
+        }
+        return $column . $row;
+    }
+    /**
+     * Reads a cell address in BIFF8 for shared formulas. Uses positive and negative values for row and column
+     * to indicate offsets from a base cell
+     * section 3.3.4.
+     *
+     * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
+     */
+    private function readBIFF8CellAddressB(string $cellAddressStructure, string $baseCell = 'A1'): string
+    {
+        [$baseCol, $baseRow] = Coordinate::coordinateFromString($baseCell);
+        $baseCol = Coordinate::columnIndexFromString($baseCol) - 1;
+        $baseRow = (int) $baseRow;
+        $rowIndex = self::getUInt2d($cellAddressStructure, 0);
+        $row = self::getUInt2d($cellAddressStructure, 0) + 1;
+        if (!(0x4000 & self::getUInt2d($cellAddressStructure, 2))) {
+            $colIndex = 0x00FF & self::getUInt2d($cellAddressStructure, 2);
+            $column = Coordinate::stringFromColumnIndex($colIndex + 1);
+            $column = '$' . $column;
+        } else {
+            $relativeColIndex = 0x00FF & self::getInt2d($cellAddressStructure, 2);
+            $colIndex = $baseCol + $relativeColIndex;
+            $colIndex = ($colIndex < 256) ? $colIndex : $colIndex - 256;
+            $colIndex = ($colIndex >= 0) ? $colIndex : $colIndex + 256;
+            $column = Coordinate::stringFromColumnIndex($colIndex + 1);
+        }
+        if (!(0x8000 & self::getUInt2d($cellAddressStructure, 2))) {
+            $row = '$' . $row;
+        } else {
+            $rowIndex = ($rowIndex <= 32767) ? $rowIndex : $rowIndex - 65536;
+            $row = $baseRow + $rowIndex;
+        }
+        return $column . $row;
+    }
+    /**
+     * Reads a cell range address in BIFF5 e.g. 'A2:B6' or 'A1'
+     * always fixed range
+     * section 2.5.14.
+     */
+    private function readBIFF5CellRangeAddressFixed(string $subData): string
+    {
+        $fr = self::getUInt2d($subData, 0) + 1;
+        $lr = self::getUInt2d($subData, 2) + 1;
+        $fc = ord($subData[4]);
+        $lc = ord($subData[5]);
+        if ($fr > $lr || $fc > $lc) {
+            throw new Exception('Not a cell range address');
+        }
+        $fc = Coordinate::stringFromColumnIndex($fc + 1);
+        $lc = Coordinate::stringFromColumnIndex($lc + 1);
+        if ($fr == $lr && $fc == $lc) {
+            return "$fc$fr";
+        }
+        return "$fc$fr:$lc$lr";
+    }
+    /**
+     * Reads a cell range address in BIFF8 e.g. 'A2:B6' or 'A1'
+     * always fixed range
+     * section 2.5.14.
+     */
+    private function readBIFF8CellRangeAddressFixed(string $subData): string
+    {
+        $fr = self::getUInt2d($subData, 0) + 1;
+        $lr = self::getUInt2d($subData, 2) + 1;
+        $fc = self::getUInt2d($subData, 4);
+        $lc = self::getUInt2d($subData, 6);
+        if ($fr > $lr || $fc > $lc) {
+            throw new Exception('Not a cell range address');
+        }
+        $fc = Coordinate::stringFromColumnIndex($fc + 1);
+        $lc = Coordinate::stringFromColumnIndex($lc + 1);
+        if ($fr == $lr && $fc == $lc) {
+            return "$fc$fr";
+        }
+        return "$fc$fr:$lc$lr";
+    }
+    /**
+     * Reads a cell range address in BIFF8 e.g. 'A2:B6' or '$A$2:$B$6'
+     * there are flags indicating whether column/row index is relative
+     * section 3.3.4.
+     */
+    private function readBIFF8CellRangeAddress(string $subData): string
+    {
+        $fr = self::getUInt2d($subData, 0) + 1;
+        $lr = self::getUInt2d($subData, 2) + 1;
+        $fc = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($subData, 4)) + 1);
+        if (!(0x4000 & self::getUInt2d($subData, 4))) {
+            $fc = '$' . $fc;
+        }
+        if (!(0x8000 & self::getUInt2d($subData, 4))) {
+            $fr = '$' . $fr;
+        }
+        $lc = Coordinate::stringFromColumnIndex((0x00FF & self::getUInt2d($subData, 6)) + 1);
+        if (!(0x4000 & self::getUInt2d($subData, 6))) {
+            $lc = '$' . $lc;
+        }
+        if (!(0x8000 & self::getUInt2d($subData, 6))) {
+            $lr = '$' . $lr;
+        }
+        return "$fc$fr:$lc$lr";
+    }
+    /**
+     * Reads a cell range address in BIFF8 for shared formulas. Uses positive and negative values for row and column
+     * to indicate offsets from a base cell
+     * section 3.3.4.
+     *
+     * @param string $baseCell Base cell
+     *
+     * @return string Cell range address
+     */
+    private function readBIFF8CellRangeAddressB(string $subData, string $baseCell = 'A1'): string
+    {
+        [$baseCol, $baseRow] = Coordinate::indexesFromString($baseCell);
+        $baseCol = $baseCol - 1;
+        $frIndex = self::getUInt2d($subData, 0); // adjust below
+        $lrIndex = self::getUInt2d($subData, 2); // adjust below
+        if (!(0x4000 & self::getUInt2d($subData, 4))) {
+            $fcIndex = 0x00FF & self::getUInt2d($subData, 4);
+            $fc = Coordinate::stringFromColumnIndex($fcIndex + 1);
+            $fc = '$' . $fc;
+        } else {
+            $relativeFcIndex = 0x00FF & self::getInt2d($subData, 4);
+            $fcIndex = $baseCol + $relativeFcIndex;
+            $fcIndex = ($fcIndex < 256) ? $fcIndex : $fcIndex - 256;
+            $fcIndex = ($fcIndex >= 0) ? $fcIndex : $fcIndex + 256;
+            $fc = Coordinate::stringFromColumnIndex($fcIndex + 1);
+        }
+        if (!(0x8000 & self::getUInt2d($subData, 4))) {
+            $fr = $frIndex + 1;
+            $fr = '$' . $fr;
+        } else {
+            $frIndex = ($frIndex <= 32767) ? $frIndex : $frIndex - 65536;
+            $fr = $baseRow + $frIndex;
+        }
+        if (!(0x4000 & self::getUInt2d($subData, 6))) {
+            $lcIndex = 0x00FF & self::getUInt2d($subData, 6);
+            $lc = Coordinate::stringFromColumnIndex($lcIndex + 1);
+            $lc = '$' . $lc;
+        } else {
+            $relativeLcIndex = 0x00FF & self::getInt2d($subData, 4);
+            $lcIndex = $baseCol + $relativeLcIndex;
+            $lcIndex = ($lcIndex < 256) ? $lcIndex : $lcIndex - 256;
+            $lcIndex = ($lcIndex >= 0) ? $lcIndex : $lcIndex + 256;
+            $lc = Coordinate::stringFromColumnIndex($lcIndex + 1);
+        }
+        if (!(0x8000 & self::getUInt2d($subData, 6))) {
+            $lr = $lrIndex + 1;
+            $lr = '$' . $lr;
+        } else {
+            $lrIndex = ($lrIndex <= 32767) ? $lrIndex : $lrIndex - 65536;
+            $lr = $baseRow + $lrIndex;
+        }
+        return "$fc$fr:$lc$lr";
+    }
+    /**
+     * Read BIFF8 cell range address list
+     * section 2.5.15.
+     */
+    private function readBIFF8CellRangeAddressList(string $subData): array
+    {
+        $cellRangeAddresses = [];
+        $nm = self::getUInt2d($subData, 0);
+        $offset = 2;
+        for ($i = 0; $i < $nm; ++$i) {
+            $cellRangeAddresses[] = $this->readBIFF8CellRangeAddressFixed(substr($subData, $offset, 8));
+            $offset += 8;
+        }
+        return [
+            'size' => 2 + 8 * $nm,
+            'cellRangeAddresses' => $cellRangeAddresses,
+        ];
+    }
+    /**
+     * Read BIFF5 cell range address list
+     * section 2.5.15.
+     */
+    private function readBIFF5CellRangeAddressList(string $subData): array
+    {
+        $cellRangeAddresses = [];
+        $nm = self::getUInt2d($subData, 0);
+        $offset = 2;
+        for ($i = 0; $i < $nm; ++$i) {
+            $cellRangeAddresses[] = $this->readBIFF5CellRangeAddressFixed(substr($subData, $offset, 6));
+            $offset += 6;
+        }
+        return [
+            'size' => 2 + 6 * $nm,
+            'cellRangeAddresses' => $cellRangeAddresses,
+        ];
+    }
+    /**
+     * Get a sheet range like Sheet1:Sheet3 from REF index
+     * Note: If there is only one sheet in the range, one gets e.g Sheet1
+     * It can also happen that the REF structure uses the -1 (FFFF) code to indicate deleted sheets,
+     * in which case an Exception is thrown.
+     */
+    private function readSheetRangeByRefIndex(int $index): string|false
+    {
+        if (isset($this->ref[$index])) {
+            $type = $this->externalBooks[$this->ref[$index]['externalBookIndex']]['type'];
+            switch ($type) {
+                case 'internal':
+                    if ($this->ref[$index]['firstSheetIndex'] == 0xFFFF || $this->ref[$index]['lastSheetIndex'] == 0xFFFF) {
+                        throw new Exception('Deleted sheet reference');
+                    }
+                    $firstSheetName = $this->sheets[$this->ref[$index]['firstSheetIndex']]['name'];
+                    $lastSheetName = $this->sheets[$this->ref[$index]['lastSheetIndex']]['name'];
+                    if ($firstSheetName == $lastSheetName) {
+                        $sheetRange = $firstSheetName;
+                    } else {
+                        $sheetRange = "$firstSheetName:$lastSheetName";
+                    }
+                    $sheetRange = str_replace("'", "''", $sheetRange);
+                    if (preg_match("/[ !\"@#£$%&{()}<>=+'|^,;-]/u", $sheetRange)) {
+                        $sheetRange = "'$sheetRange'";
+                    }
+                    return $sheetRange;
+                default:
+                    throw new Exception('Xls reader only supports internal sheets in formulas');
+            }
+        }
+        return false;
+    }
+    /**
+     * read BIFF8 constant value array from array data
+     * returns e.g. ['value' => '{1,2;3,4}', 'size' => 40]
+     * section 2.5.8.
+     */
+    private static function readBIFF8ConstantArray(string $arrayData): array
+    {
+        $nc = ord($arrayData[0]);
+        $nr = self::getUInt2d($arrayData, 1);
+        $size = 3; // initialize
+        $arrayData = substr($arrayData, 3);
+        $matrixChunks = [];
+        for ($r = 1; $r <= $nr + 1; ++$r) {
+            $items = [];
+            for ($c = 1; $c <= $nc + 1; ++$c) {
+                $constant = self::readBIFF8Constant($arrayData);
+                $items[] = $constant['value'];
+                $arrayData = substr($arrayData, $constant['size']);
+                $size += $constant['size'];
+            }
+            $matrixChunks[] = implode(',', $items); // looks like e.g. '1,"hello"'
+        }
+        $matrix = '{' . implode(';', $matrixChunks) . '}';
+        return [
+            'value' => $matrix,
+            'size' => $size,
+        ];
+    }
+    /**
+     * read BIFF8 constant value which may be 'Empty Value', 'Number', 'String Value', 'Boolean Value', 'Error Value'
+     * section 2.5.7
+     * returns e.g. ['value' => '5', 'size' => 9].
+     */
+    private static function readBIFF8Constant(string $valueData): array
+    {
+        $identifier = ord($valueData[0]);
+        switch ($identifier) {
+            case 0x00: // empty constant (what is this?)
+                $value = '';
+                $size = 9;
+                break;
+            case 0x01: // number
+                $value = self::extractNumber(substr($valueData, 1, 8));
+                $size = 9;
+                break;
+            case 0x02: // string value
+                $string = self::readUnicodeStringLong(substr($valueData, 1));
+                $value = '"' . $string['value'] . '"';
+                $size = 1 + $string['size'];
+                break;
+            case 0x04: // boolean
+                if (ord($valueData[1])) {
+                    $value = 'TRUE';
+                } else {
+                    $value = 'FALSE';
+                }
+                $size = 9;
+                break;
+            case 0x10: // error code
+                $value = Xls\ErrorCode::lookup(ord($valueData[1]));
+                $size = 9;
+                break;
+            default:
+                throw new PhpSpreadsheetException('Unsupported BIFF8 constant');
+        }
+        return [
+            'value' => $value,
+            'size' => $size,
+        ];
+    }
+    /**
+     * Extract RGB color
+     * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.4.
+     *
+     * @param string $rgb Encoded RGB value (4 bytes)
+     */
+    private static function readRGB(string $rgb): array
+    {
+        $r = ord($rgb[0]);
+        $g = ord($rgb[1]);
+        $b = ord($rgb[2]);
+        $rgb = sprintf('%02X%02X%02X', $r, $g, $b);
+        return ['rgb' => $rgb];
+    }
+    /**
+     * Read byte string (8-bit string length)
+     * OpenOffice documentation: 2.5.2.
+     */
+    private function readByteStringShort(string $subData): array
+    {
+        $ln = ord($subData[0]);
+        $value = $this->decodeCodepage(substr($subData, 1, $ln));
+        return [
+            'value' => $value,
+            'size' => 1 + $ln, // size in bytes of data structure
+        ];
+    }
+    /**
+     * Read byte string (16-bit string length)
+     * OpenOffice documentation: 2.5.2.
+     */
+    private function readByteStringLong(string $subData): array
+    {
+        $ln = self::getUInt2d($subData, 0);
+        $value = $this->decodeCodepage(substr($subData, 2));
+        return [
+            'value' => $value,
+            'size' => 2 + $ln, // size in bytes of data structure
+        ];
+    }
+    /**
+     * Extracts an Excel Unicode short string (8-bit string length)
+     * OpenOffice documentation: 2.5.3
+     * function will automatically find out where the Unicode string ends.
+     */
+    private static function readUnicodeStringShort(string $subData): array
+    {
+        $characterCount = ord($subData[0]);
+        $string = self::readUnicodeString(substr($subData, 1), $characterCount);
+        ++$string['size'];
+        return $string;
+    }
+    /**
+     * Extracts an Excel Unicode long string (16-bit string length)
+     * OpenOffice documentation: 2.5.3
+     * this function is under construction, needs to support rich text, and Asian phonetic settings.
+     */
+    private static function readUnicodeStringLong(string $subData): array
+    {
+        $characterCount = self::getUInt2d($subData, 0);
+        $string = self::readUnicodeString(substr($subData, 2), $characterCount);
+        $string['size'] += 2;
+        return $string;
+    }
+    /**
+     * Read Unicode string with no string length field, but with known character count
+     * this function is under construction, needs to support rich text, and Asian phonetic settings
+     * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.3.
+     */
+    private static function readUnicodeString(string $subData, int $characterCount): array
+    {
+        $isCompressed = !((0x01 & ord($subData[0])) >> 0);
+        $value = self::encodeUTF16(substr($subData, 1, $isCompressed ? $characterCount : 2 * $characterCount), $isCompressed);
+        return [
+            'value' => $value,
+            'size' => $isCompressed ? 1 + $characterCount : 1 + 2 * $characterCount, // the size in bytes including the option flags
+        ];
+    }
+    /**
+     * Convert UTF-8 string to string surounded by double quotes. Used for explicit string tokens in formulas.
+     * Example:  hello"world  -->  "hello""world".
+     *
+     * @param string $value UTF-8 encoded string
+     */
+    private static function UTF8toExcelDoubleQuoted(string $value): string
+    {
+        return '"' . str_replace('"', '""', $value) . '"';
+    }
+    /**
+     * Reads first 8 bytes of a string and return IEEE 754 float.
+     *
+     * @param string $data Binary string that is at least 8 bytes long
+     */
+    private static function extractNumber(string $data): int|float
+    {
+        $rknumhigh = self::getInt4d($data, 4);
+        $rknumlow = self::getInt4d($data, 0);
+        $sign = ($rknumhigh & self::HIGH_ORDER_BIT) >> 31;
+        $exp = (($rknumhigh & 0x7FF00000) >> 20) - 1023;
+        $mantissa = (0x100000 | ($rknumhigh & 0x000FFFFF));
+        $mantissalow1 = ($rknumlow & self::HIGH_ORDER_BIT) >> 31;
+        $mantissalow2 = ($rknumlow & 0x7FFFFFFF);
+        $value = $mantissa / 2 ** (20 - $exp);
+        if ($mantissalow1 != 0) {
+            $value += 1 / 2 ** (21 - $exp);
+        }
+        if ($mantissalow2 != 0) {
+            $value += $mantissalow2 / 2 ** (52 - $exp);
+        }
+        if ($sign) {
+            $value *= -1;
+        }
+        return $value;
+    }
+    private static function getIEEE754(int $rknum): float|int
+    {
+        if (($rknum & 0x02) != 0) {
+            $value = $rknum >> 2;
+        } else {
+            $sign = ($rknum & self::HIGH_ORDER_BIT) >> 31;
+            $exp = ($rknum & 0x7FF00000) >> 20;
+            $mantissa = (0x100000 | ($rknum & 0x000FFFFC));
+            $value = $mantissa / 2 ** (20 - ($exp - 1023));
+            if ($sign) {
+                $value = -1 * $value;
+            }
+        }
+        if (($rknum & 0x01) != 0) {
+            $value /= 100;
+        }
+        return $value;
+    }
+    /**
+     * Get UTF-8 string from (compressed or uncompressed) UTF-16 string.
+     */
+    private static function encodeUTF16(string $string, bool $compressed = false): string
+    {
+        if ($compressed) {
+            $string = self::uncompressByteString($string);
+        }
+        return StringHelper::convertEncoding($string, 'UTF-8', 'UTF-16LE');
+    }
+    /**
+     * Convert UTF-16 string in compressed notation to uncompressed form. Only used for BIFF8.
+     */
+    private static function uncompressByteString(string $string): string
+    {
+        $uncompressedString = '';
+        $strLen = strlen($string);
+        for ($i = 0; $i < $strLen; ++$i) {
+            $uncompressedString .= $string[$i] . "\0";
+        }
+        return $uncompressedString;
+    }
+    /**
+     * Convert string to UTF-8. Only used for BIFF5.
+     */
+    private function decodeCodepage(string $string): string
+    {
+        return StringHelper::convertEncoding($string, 'UTF-8', $this->codepage);
+    }
+    /**
+     * Read 16-bit unsigned integer.
+     */
+    public static function getUInt2d(string $data, int $pos): int
+    {
+        return ord($data[$pos]) | (ord($data[$pos + 1]) << 8);
+    }
+    /**
+     * Read 16-bit signed integer.
+     */
+    public static function getInt2d(string $data, int $pos): int
+    {
+        return unpack('s', $data[$pos] . $data[$pos + 1])[1]; // @phpstan-ignore-line
+    }
+    /**
+     * Read 32-bit signed integer.
+     */
+    public static function getInt4d(string $data, int $pos): int
+    {
+        $_or_24 = ord($data[$pos + 3]);
+        if ($_or_24 >= 128) {
+            $_ord_24 = -abs((256 - $_or_24) << 24);
+        } else {
+            $_ord_24 = ($_or_24 & 127) << 24;
+        }
+        return ord($data[$pos]) | (ord($data[$pos + 1]) << 8) | (ord($data[$pos + 2]) << 16) | $_ord_24;
+    }
+    private function parseRichText(string $is): RichText
+    {
+        $value = new RichText();
+        $value->createText($is);
+        return $value;
+    }
+    /**
+     * Phpstan 1.4.4 complains that this property is never read.
+     * So, we might be able to get rid of it altogether.
+     * For now, however, this function makes it readable,
+     * which satisfies Phpstan.
+     *
+     * @codeCoverageIgnore
+     */
+    public function getMapCellStyleXfIndex(): array
+    {
+        return $this->mapCellStyleXfIndex;
+    }
+    /**
+     * Parse conditional formatting blocks.
+     *
+     * @see https://www.openoffice.org/sc/excelfileformat.pdf Search for CFHEADER followed by CFRULE
+     */
+    private function readCFHeader(): array
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return [];
+        }
+        $cellRangeAddressList = ($this->version == self::XLS_BIFF8)
+            ? $this->readBIFF8CellRangeAddressList(substr($recordData, 12))
+            : $this->readBIFF5CellRangeAddressList(substr($recordData, 12));
+        $cellRangeAddresses = $cellRangeAddressList['cellRangeAddresses'];
+        return $cellRangeAddresses;
+    }
+    private function readCFRule(array $cellRangeAddresses): void
+    {
+        $length = self::getUInt2d($this->data, $this->pos + 2);
+        $recordData = $this->readRecordData($this->data, $this->pos + 4, $length);
+        $this->pos += 4 + $length;
+        if ($this->readDataOnly) {
+            return;
+        }
+        $cfRule = self::getUInt2d($recordData, 0);
+        $type = (0x00FF & $cfRule) >> 0;
+        $type = ConditionalFormatting::type($type);
+        $operator = (0xFF00 & $cfRule) >> 8;
+        $operator = ConditionalFormatting::operator($operator);
+        if ($type === null || $operator === null) {
+            return;
+        }
+        $size1 = self::getUInt2d($recordData, 2);
+        $size2 = self::getUInt2d($recordData, 4);
+        $options = self::getInt4d($recordData, 6);
+        $style = new Style(false, true); // non-supervisor, conditional
+        $noFormatSet = true;
+        $hasFontRecord = (bool) ((0x04000000 & $options) >> 26);
+        $hasAlignmentRecord = (bool) ((0x08000000 & $options) >> 27);
+        $hasBorderRecord = (bool) ((0x10000000 & $options) >> 28);
+        $hasFillRecord = (bool) ((0x20000000 & $options) >> 29);
+        $hasProtectionRecord = (bool) ((0x40000000 & $options) >> 30);
+        $hasBorderLeft = !(bool) (0x00000400 & $options);
+        $hasBorderRight = !(bool) (0x00000800 & $options);
+        $hasBorderTop = !(bool) (0x00001000 & $options);
+        $hasBorderBottom = !(bool) (0x00002000 & $options);
+        $offset = 12;
+        if ($hasFontRecord === true) {
+            $fontStyle = substr($recordData, $offset, 118);
+            $this->getCFFontStyle($fontStyle, $style);
+            $offset += 118;
+            $noFormatSet = false;
+        }
+        if ($hasAlignmentRecord === true) {
+            $offset += 8;
+        }
+        if ($hasBorderRecord === true) {
+            $borderStyle = substr($recordData, $offset, 8);
+            $this->getCFBorderStyle($borderStyle, $style, $hasBorderLeft, $hasBorderRight, $hasBorderTop, $hasBorderBottom);
+            $offset += 8;
+            $noFormatSet = false;
+        }
+        if ($hasFillRecord === true) {
+            $fillStyle = substr($recordData, $offset, 4);
+            $this->getCFFillStyle($fillStyle, $style);
+            $offset += 4;
+            $noFormatSet = false;
+        }
+        if ($hasProtectionRecord === true) {
+            $offset += 2;
+        }
+        $formula1 = $formula2 = null;
+        if ($size1 > 0) {
+            $formula1 = $this->readCFFormula($recordData, $offset, $size1);
+            if ($formula1 === null) {
+                return;
+            }
+            $offset += $size1;
+        }
+        if ($size2 > 0) {
+            $formula2 = $this->readCFFormula($recordData, $offset, $size2);
+            if ($formula2 === null) {
+                return;
+            }
+            $offset += $size2;
+        }
+        $this->setCFRules($cellRangeAddresses, $type, $operator, $formula1, $formula2, $style, $noFormatSet);
+    }
+    /*private function getCFStyleOptions(int $options, Style $style): void
+    {
+    }*/
+    private function getCFFontStyle(string $options, Style $style): void
+    {
+        $fontSize = self::getInt4d($options, 64);
+        if ($fontSize !== -1) {
+            $style->getFont()->setSize($fontSize / 20); // Convert twips to points
+        }
+        $options68 = self::getInt4d($options, 68);
+        $options88 = self::getInt4d($options, 88);
+        if (($options88 & 2) === 0) {
+            $bold = self::getUInt2d($options, 72); // 400 = normal, 700 = bold
+            if ($bold !== 0) {
+                $style->getFont()->setBold($bold >= 550);
+            }
+            if (($options68 & 2) !== 0) {
+                $style->getFont()->setItalic(true);
+            }
+        }
+        if (($options88 & 0x80) === 0) {
+            if (($options68 & 0x80) !== 0) {
+                $style->getFont()->setStrikethrough(true);
+            }
+        }
+        $color = self::getInt4d($options, 80);
+        if ($color !== -1) {
+            $style->getFont()->getColor()->setRGB(Xls\Color::map($color, $this->palette, $this->version)['rgb']);
+        }
+    }
+    /*private function getCFAlignmentStyle(string $options, Style $style): void
+    {
+    }*/
+    private function getCFBorderStyle(string $options, Style $style, bool $hasBorderLeft, bool $hasBorderRight, bool $hasBorderTop, bool $hasBorderBottom): void
+    {
+        $valueArray = unpack('V', $options);
+        $value = is_array($valueArray) ? $valueArray[1] : 0;
+        $left = $value & 15;
+        $right = ($value >> 4) & 15;
+        $top = ($value >> 8) & 15;
+        $bottom = ($value >> 12) & 15;
+        $leftc = ($value >> 16) & 0x7F;
+        $rightc = ($value >> 23) & 0x7F;
+        $valueArray = unpack('V', substr($options, 4));
+        $value = is_array($valueArray) ? $valueArray[1] : 0;
+        $topc = $value & 0x7F;
+        $bottomc = ($value & 0x3F80) >> 7;
+        if ($hasBorderLeft) {
+            $style->getBorders()->getLeft()
+                ->setBorderStyle(self::BORDER_STYLE_MAP[$left]);
+            $style->getBorders()->getLeft()->getColor()
+                ->setRGB(Xls\Color::map($leftc, $this->palette, $this->version)['rgb']);
+        }
+        if ($hasBorderRight) {
+            $style->getBorders()->getRight()
+                ->setBorderStyle(self::BORDER_STYLE_MAP[$right]);
+            $style->getBorders()->getRight()->getColor()
+                ->setRGB(Xls\Color::map($rightc, $this->palette, $this->version)['rgb']);
+        }
+        if ($hasBorderTop) {
+            $style->getBorders()->getTop()
+                ->setBorderStyle(self::BORDER_STYLE_MAP[$top]);
+            $style->getBorders()->getTop()->getColor()
+                ->setRGB(Xls\Color::map($topc, $this->palette, $this->version)['rgb']);
+        }
+        if ($hasBorderBottom) {
+            $style->getBorders()->getBottom()
+                ->setBorderStyle(self::BORDER_STYLE_MAP[$bottom]);
+            $style->getBorders()->getBottom()->getColor()
+                ->setRGB(Xls\Color::map($bottomc, $this->palette, $this->version)['rgb']);
+        }
+    }
+    private function getCFFillStyle(string $options, Style $style): void
+    {
+        $fillPattern = self::getUInt2d($options, 0);
+        $fillPattern = (0xFC00 & $fillPattern) >> 10;
+        $fillPattern = FillPattern::lookup($fillPattern);
+        $fillPattern = $fillPattern === Fill::FILL_NONE ? Fill::FILL_SOLID : $fillPattern;
+        if ($fillPattern !== Fill::FILL_NONE) {
+            $style->getFill()->setFillType($fillPattern);
+            $fillColors = self::getUInt2d($options, 2);
+            $color1 = (0x007F & $fillColors) >> 0;
+            $color2 = (0x3F80 & $fillColors) >> 7;
+            if ($fillPattern === Fill::FILL_SOLID) {
+                $style->getFill()->getStartColor()->setRGB(Xls\Color::map($color2, $this->palette, $this->version)['rgb']);
+            } else {
+                $style->getFill()->getStartColor()->setRGB(Xls\Color::map($color1, $this->palette, $this->version)['rgb']);
+                $style->getFill()->getEndColor()->setRGB(Xls\Color::map($color2, $this->palette, $this->version)['rgb']);
+            }
+        }
+    }
+    /*private function getCFProtectionStyle(string $options, Style $style): void
+    {
+    }*/
+    private function readCFFormula(string $recordData, int $offset, int $size): float|int|string|null
+    {
+        try {
+            $formula = substr($recordData, $offset, $size);
+            $formula = pack('v', $size) . $formula; // prepend the length
+            $formula = $this->getFormulaFromStructure($formula);
+            if (is_numeric($formula)) {
+                return (str_contains($formula, '.')) ? (float) $formula : (int) $formula;
+            }
+            return $formula;
+        } catch (PhpSpreadsheetException) {
+            return null;
+        }
+    }
+    private function setCFRules(array $cellRanges, string $type, string $operator, null|float|int|string $formula1, null|float|int|string $formula2, Style $style, bool $noFormatSet): void
+    {
+        foreach ($cellRanges as $cellRange) {
+            $conditional = new Conditional();
+            $conditional->setNoFormatSet($noFormatSet);
+            $conditional->setConditionType($type);
+            $conditional->setOperatorType($operator);
+            $conditional->setStopIfTrue(true);
+            if ($formula1 !== null) {
+                $conditional->addCondition($formula1);
+            }
+            if ($formula2 !== null) {
+                $conditional->addCondition($formula2);
+            }
+            $conditional->setStyle($style);
+            $conditionalStyles = $this->phpSheet->getStyle($cellRange)->getConditionalStyles();
+            $conditionalStyles[] = $conditional;
+            $this->phpSheet->getStyle($cellRange)->setConditionalStyles($conditionalStyles);
+        }
+    }
+    public function getVersion(): int
+    {
+        return $this->version;
+    }
+}

--- a/src/PhpSpreadsheet/Reader/Xlsx.php
+++ b/src/PhpSpreadsheet/Reader/Xlsx.php
@@ -727,28 +727,28 @@
                                                 if ($cellDataType !== DataType::TYPE_NULL) {
                                                     $cell->setValueExplicit($value, $cellDataType);
                                                 }
                                             } else {
                                                 $cell->setValue($value);
                                             }
                                             if ($calculatedValue !== null) {
                                                 $cell->setCalculatedValue($calculatedValue, $originalCellDataTypeNumeric);
                                             }
                                             if (!$this->readDataOnly) {
+                                                $holdSelected = $docSheet->getSelectedCells();
                                                 $cAttrS = (int) ($cAttr['s'] ?? 0);
                                                 $cAttrS = isset($styles[$cAttrS]) ? $cAttrS : 0;
                                                 $cell->setXfIndex($cAttrS);
                                                 if ($cellDataType === DataType::TYPE_FORMULA && $styles[$cAttrS]->quotePrefix === true) {
-                                                    $holdSelected = $docSheet->getSelectedCells();
                                                     $cell->getStyle()->setQuotePrefix(false);
-                                                    $docSheet->setSelectedCells($holdSelected);
-                                                }
+                                                }
+                                                $docSheet->setSelectedCells($holdSelected);
                                             }
                                         }
                                         ++$rowIndex;
                                     }
                                     ++$cIndex;
                                 }
                             }
                             $docSheet->setSelectedCells($holdSelectedCells);
                             if ($xmlSheetNS && $xmlSheetNS->ignoredErrors) {
                                 foreach ($xmlSheetNS->ignoredErrors->ignoredError as $ignoredErrorx) {
@@ -1034,21 +1034,21 @@
                                                 }
                                                 $imageData = $imageData[$idx];
                                                 $imageData = self::getAttributes($imageData, Namespaces::URN_MSOFFICE);
                                                 $style = self::toCSSArray((string) $shape['style']);
                                                 if (array_key_exists((string) $imageData['relid'], $drawings)) {
                                                     $shapeId = (string) $shape['id'];
                                                     $hfImages[$shapeId] = new HeaderFooterDrawing();
                                                     if (isset($imageData['title'])) {
                                                         $hfImages[$shapeId]->setName((string) $imageData['title']);
                                                     }
-                                                    $hfImages[$shapeId]->setPath('zip://' . File::realpath($filename) . '#' . $drawings[(string) $imageData['relid']], false, $zip);
+                                                    $hfImages[$shapeId]->setPath('zip://' . File::realpath($filename) . '#' . $drawings[(string) $imageData['relid']], false);
                                                     $hfImages[$shapeId]->setResizeProportional(false);
                                                     $hfImages[$shapeId]->setWidth($style['width']);
                                                     $hfImages[$shapeId]->setHeight($style['height']);
                                                     if (isset($style['margin-left'])) {
                                                         $hfImages[$shapeId]->setOffsetX($style['margin-left']);
                                                     }
                                                     $hfImages[$shapeId]->setOffsetY($style['margin-top']);
                                                     $hfImages[$shapeId]->setResizeProportional(true);
                                                 }
                                             }
@@ -1138,34 +1138,30 @@
                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'name'));
                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
                                                     $embedImageKey = (string) self::getArrayItem(
                                                         self::getAttributes($blip, $xmlNamespaceBase),
                                                         'embed'
                                                     );
                                                     if (isset($images[$embedImageKey])) {
                                                         $objDrawing->setPath(
                                                             'zip://' . File::realpath($filename) . '#'
                                                             . $images[$embedImageKey],
-                                                            false,
-                                                            $zip
+                                                            false
                                                         );
                                                     } else {
                                                         $linkImageKey = (string) self::getArrayItem(
                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
                                                             'link'
                                                         );
                                                         if (isset($images[$linkImageKey])) {
                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
-                                                            $objDrawing->setPath($url, false);
-                                                        }
-                                                        if ($objDrawing->getPath() === '') {
-                                                            continue;
+                                                            $objDrawing->setPath($url);
                                                         }
                                                     }
                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $oneCellAnchor->from->col) + 1) . ($oneCellAnchor->from->row + 1));
                                                     $objDrawing->setOffsetX((int) Drawing::EMUToPixels($oneCellAnchor->from->colOff));
                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($oneCellAnchor->from->rowOff));
                                                     $objDrawing->setResizeProportional(false);
                                                     $objDrawing->setWidth(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cx')));
                                                     $objDrawing->setHeight(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cy')));
                                                     if ($xfrm) {
                                                         $objDrawing->setRotation((int) Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($xfrm), 'rot')));
@@ -1225,34 +1221,30 @@
                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'name'));
                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
                                                     $embedImageKey = (string) self::getArrayItem(
                                                         self::getAttributes($blip, $xmlNamespaceBase),
                                                         'embed'
                                                     );
                                                     if (isset($images[$embedImageKey])) {
                                                         $objDrawing->setPath(
                                                             'zip://' . File::realpath($filename) . '#'
                                                             . $images[$embedImageKey],
-                                                            false,
-                                                            $zip
+                                                            false
                                                         );
                                                     } else {
                                                         $linkImageKey = (string) self::getArrayItem(
                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
                                                             'link'
                                                         );
                                                         if (isset($images[$linkImageKey])) {
                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
-                                                            $objDrawing->setPath($url, false);
-                                                        }
-                                                        if ($objDrawing->getPath() === '') {
-                                                            continue;
+                                                            $objDrawing->setPath($url);
                                                         }
                                                     }
                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->from->col) + 1) . ($twoCellAnchor->from->row + 1));
                                                     $objDrawing->setOffsetX(Drawing::EMUToPixels($twoCellAnchor->from->colOff));
                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($twoCellAnchor->from->rowOff));
                                                     $objDrawing->setCoordinates2(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->to->col) + 1) . ($twoCellAnchor->to->row + 1));
                                                     $objDrawing->setOffsetX2(Drawing::EMUToPixels($twoCellAnchor->to->colOff));
                                                     $objDrawing->setOffsetY2(Drawing::EMUToPixels($twoCellAnchor->to->rowOff));
                                                     $objDrawing->setResizeProportional(false);
                                                     if ($xfrm) {

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Xlsx/ColumnAndRowAttributes.php
@@ -0,0 +1,192 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader\Xlsx;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Reader\DefaultReadFilter;
+use PhpOffice\PhpSpreadsheet\Reader\IReadFilter;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use SimpleXMLElement;
+class ColumnAndRowAttributes extends BaseParserClass
+{
+    private Worksheet $worksheet;
+    private ?SimpleXMLElement $worksheetXml;
+    public function __construct(Worksheet $workSheet, ?SimpleXMLElement $worksheetXml = null)
+    {
+        $this->worksheet = $workSheet;
+        $this->worksheetXml = $worksheetXml;
+    }
+    /**
+     * Set Worksheet column attributes by attributes array passed.
+     *
+     * @param string $columnAddress A, B, ... DX, ...
+     * @param array $columnAttributes array of attributes (indexes are attribute name, values are value)
+     *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'width', ... ?
+     */
+    private function setColumnAttributes(string $columnAddress, array $columnAttributes): void
+    {
+        if (isset($columnAttributes['xfIndex'])) {
+            $this->worksheet->getColumnDimension($columnAddress)->setXfIndex($columnAttributes['xfIndex']);
+        }
+        if (isset($columnAttributes['visible'])) {
+            $this->worksheet->getColumnDimension($columnAddress)->setVisible($columnAttributes['visible']);
+        }
+        if (isset($columnAttributes['collapsed'])) {
+            $this->worksheet->getColumnDimension($columnAddress)->setCollapsed($columnAttributes['collapsed']);
+        }
+        if (isset($columnAttributes['outlineLevel'])) {
+            $this->worksheet->getColumnDimension($columnAddress)->setOutlineLevel($columnAttributes['outlineLevel']);
+        }
+        if (isset($columnAttributes['width'])) {
+            $this->worksheet->getColumnDimension($columnAddress)->setWidth($columnAttributes['width']);
+        }
+    }
+    /**
+     * Set Worksheet row attributes by attributes array passed.
+     *
+     * @param int $rowNumber 1, 2, 3, ... 99, ...
+     * @param array $rowAttributes array of attributes (indexes are attribute name, values are value)
+     *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'rowHeight', ... ?
+     */
+    private function setRowAttributes(int $rowNumber, array $rowAttributes): void
+    {
+        if (isset($rowAttributes['xfIndex'])) {
+            $this->worksheet->getRowDimension($rowNumber)->setXfIndex($rowAttributes['xfIndex']);
+        }
+        if (isset($rowAttributes['visible'])) {
+            $this->worksheet->getRowDimension($rowNumber)->setVisible($rowAttributes['visible']);
+        }
+        if (isset($rowAttributes['collapsed'])) {
+            $this->worksheet->getRowDimension($rowNumber)->setCollapsed($rowAttributes['collapsed']);
+        }
+        if (isset($rowAttributes['outlineLevel'])) {
+            $this->worksheet->getRowDimension($rowNumber)->setOutlineLevel($rowAttributes['outlineLevel']);
+        }
+        if (isset($rowAttributes['rowHeight'])) {
+            $this->worksheet->getRowDimension($rowNumber)->setRowHeight($rowAttributes['rowHeight']);
+        }
+    }
+    public function load(?IReadFilter $readFilter = null, bool $readDataOnly = false, bool $ignoreRowsWithNoCells = false): void
+    {
+        if ($this->worksheetXml === null) {
+            return;
+        }
+        $columnsAttributes = [];
+        $rowsAttributes = [];
+        if (isset($this->worksheetXml->cols)) {
+            $columnsAttributes = $this->readColumnAttributes($this->worksheetXml->cols, $readDataOnly);
+        }
+        if ($this->worksheetXml->sheetData && $this->worksheetXml->sheetData->row) {
+            $rowsAttributes = $this->readRowAttributes($this->worksheetXml->sheetData->row, $readDataOnly, $ignoreRowsWithNoCells);
+        }
+        if ($readFilter !== null && $readFilter::class === DefaultReadFilter::class) {
+            $readFilter = null;
+        }
+        $columnsAttributesAreSet = [];
+        foreach ($columnsAttributes as $columnCoordinate => $columnAttributes) {
+            if (
+                $readFilter === null
+                || !$this->isFilteredColumn($readFilter, $columnCoordinate, $rowsAttributes)
+            ) {
+                if (!isset($columnsAttributesAreSet[$columnCoordinate])) {
+                    $this->setColumnAttributes($columnCoordinate, $columnAttributes);
+                    $columnsAttributesAreSet[$columnCoordinate] = true;
+                }
+            }
+        }
+        $rowsAttributesAreSet = [];
+        foreach ($rowsAttributes as $rowCoordinate => $rowAttributes) {
+            if (
+                $readFilter === null
+                || !$this->isFilteredRow($readFilter, $rowCoordinate, $columnsAttributes)
+            ) {
+                if (!isset($rowsAttributesAreSet[$rowCoordinate])) {
+                    $this->setRowAttributes($rowCoordinate, $rowAttributes);
+                    $rowsAttributesAreSet[$rowCoordinate] = true;
+                }
+            }
+        }
+    }
+    private function isFilteredColumn(IReadFilter $readFilter, string $columnCoordinate, array $rowsAttributes): bool
+    {
+        foreach ($rowsAttributes as $rowCoordinate => $rowAttributes) {
+            if (!$readFilter->readCell($columnCoordinate, $rowCoordinate, $this->worksheet->getTitle())) {
+                return true;
+            }
+        }
+        return false;
+    }
+    private function readColumnAttributes(SimpleXMLElement $worksheetCols, bool $readDataOnly): array
+    {
+        $columnAttributes = [];
+        foreach ($worksheetCols->col as $columnx) {
+            $column = $columnx->attributes();
+            if ($column !== null) {
+                $startColumn = Coordinate::stringFromColumnIndex((int) $column['min']);
+                $endColumn = Coordinate::stringFromColumnIndex((int) $column['max']);
+                ++$endColumn;
+                for ($columnAddress = $startColumn; $columnAddress !== $endColumn; ++$columnAddress) {
+                    $columnAttributes[$columnAddress] = $this->readColumnRangeAttributes($column, $readDataOnly);
+                    if ((int) ($column['max']) == 16384) {
+                        break;
+                    }
+                }
+            }
+        }
+        return $columnAttributes;
+    }
+    private function readColumnRangeAttributes(?SimpleXMLElement $column, bool $readDataOnly): array
+    {
+        $columnAttributes = [];
+        if ($column !== null) {
+            if (isset($column['style']) && !$readDataOnly) {
+                $columnAttributes['xfIndex'] = (int) $column['style'];
+            }
+            if (isset($column['hidden']) && self::boolean($column['hidden'])) {
+                $columnAttributes['visible'] = false;
+            }
+            if (isset($column['collapsed']) && self::boolean($column['collapsed'])) {
+                $columnAttributes['collapsed'] = true;
+            }
+            if (isset($column['outlineLevel']) && ((int) $column['outlineLevel']) > 0) {
+                $columnAttributes['outlineLevel'] = (int) $column['outlineLevel'];
+            }
+            if (isset($column['width'])) {
+                $columnAttributes['width'] = (float) $column['width'];
+            }
+        }
+        return $columnAttributes;
+    }
+    private function isFilteredRow(IReadFilter $readFilter, int $rowCoordinate, array $columnsAttributes): bool
+    {
+        foreach ($columnsAttributes as $columnCoordinate => $columnAttributes) {
+            if (!$readFilter->readCell($columnCoordinate, $rowCoordinate, $this->worksheet->getTitle())) {
+                return true;
+            }
+        }
+        return false;
+    }
+    private function readRowAttributes(SimpleXMLElement $worksheetRow, bool $readDataOnly, bool $ignoreRowsWithNoCells): array
+    {
+        $rowAttributes = [];
+        foreach ($worksheetRow as $rowx) {
+            $row = $rowx->attributes();
+            if ($row !== null && (!$ignoreRowsWithNoCells || isset($rowx->c))) {
+                if (isset($row['ht']) && !$readDataOnly) {
+                    $rowAttributes[(int) $row['r']]['rowHeight'] = (float) $row['ht'];
+                }
+                if (isset($row['hidden']) && self::boolean($row['hidden'])) {
+                    $rowAttributes[(int) $row['r']]['visible'] = false;
+                }
+                if (isset($row['collapsed']) && self::boolean($row['collapsed'])) {
+                    $rowAttributes[(int) $row['r']]['collapsed'] = true;
+                }
+                if (isset($row['outlineLevel']) && (int) $row['outlineLevel'] > 0) {
+                    $rowAttributes[(int) $row['r']]['outlineLevel'] = (int) $row['outlineLevel'];
+                }
+                if (isset($row['s']) && !$readDataOnly) {
+                    $rowAttributes[(int) $row['r']]['xfIndex'] = (int) $row['s'];
+                }
+            }
+        }
+        return $rowAttributes;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Reader/Xlsx/ConditionalStyles.php
@@ -0,0 +1,277 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Reader\Xlsx;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Styles as StyleReader;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalColorScale;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalDataBar;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormattingRuleExtension;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormatValueObject;
+use PhpOffice\PhpSpreadsheet\Style\Style as Style;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use SimpleXMLElement;
+use stdClass;
+class ConditionalStyles
+{
+    private Worksheet $worksheet;
+    private SimpleXMLElement $worksheetXml;
+    private array $ns;
+    private array $dxfs;
+    private StyleReader $styleReader;
+    public function __construct(Worksheet $workSheet, SimpleXMLElement $worksheetXml, array $dxfs, StyleReader $styleReader)
+    {
+        $this->worksheet = $workSheet;
+        $this->worksheetXml = $worksheetXml;
+        $this->dxfs = $dxfs;
+        $this->styleReader = $styleReader;
+    }
+    public function load(): void
+    {
+        $selectedCells = $this->worksheet->getSelectedCells();
+        $this->setConditionalStyles(
+            $this->worksheet,
+            $this->readConditionalStyles($this->worksheetXml),
+            $this->worksheetXml->extLst
+        );
+        $this->worksheet->setSelectedCells($selectedCells);
+    }
+    public function loadFromExt(): void
+    {
+        $selectedCells = $this->worksheet->getSelectedCells();
+        $this->ns = $this->worksheetXml->getNamespaces(true);
+        $this->setConditionalsFromExt(
+            $this->readConditionalsFromExt($this->worksheetXml->extLst)
+        );
+        $this->worksheet->setSelectedCells($selectedCells);
+    }
+    private function setConditionalsFromExt(array $conditionals): void
+    {
+        foreach ($conditionals as $conditionalRange => $cfRules) {
+            ksort($cfRules);
+            $this->worksheet->getStyle($conditionalRange)
+                ->setConditionalStyles(array_values($cfRules));
+        }
+    }
+    private function readConditionalsFromExt(SimpleXMLElement $extLst): array
+    {
+        $conditionals = [];
+        if (!isset($extLst->ext)) {
+            return $conditionals;
+        }
+        foreach ($extLst->ext as $extlstcond) {
+            $extAttrs = $extlstcond->attributes() ?? [];
+            $extUri = (string) ($extAttrs['uri'] ?? '');
+            if ($extUri !== '{78C0D931-6437-407d-A8EE-F0AAD7539E65}') {
+                continue;
+            }
+            $conditionalFormattingRuleXml = $extlstcond->children($this->ns['x14']);
+            if (!$conditionalFormattingRuleXml->conditionalFormattings) {
+                return [];
+            }
+            foreach ($conditionalFormattingRuleXml->children($this->ns['x14']) as $extFormattingXml) {
+                $extFormattingRangeXml = $extFormattingXml->children($this->ns['xm']);
+                if (!$extFormattingRangeXml->sqref) {
+                    continue;
+                }
+                $sqref = (string) $extFormattingRangeXml->sqref;
+                $extCfRuleXml = $extFormattingXml->cfRule;
+                $attributes = $extCfRuleXml->attributes();
+                if (!$attributes) {
+                    continue;
+                }
+                $conditionType = (string) $attributes->type;
+                if (
+                    !Conditional::isValidConditionType($conditionType)
+                    || $conditionType === Conditional::CONDITION_DATABAR
+                ) {
+                    continue;
+                }
+                $priority = (int) $attributes->priority;
+                $conditional = $this->readConditionalRuleFromExt($extCfRuleXml, $attributes);
+                $cfStyle = $this->readStyleFromExt($extCfRuleXml);
+                $conditional->setStyle($cfStyle);
+                $conditionals[$sqref][$priority] = $conditional;
+            }
+        }
+        return $conditionals;
+    }
+    private function readConditionalRuleFromExt(SimpleXMLElement $cfRuleXml, SimpleXMLElement $attributes): Conditional
+    {
+        $conditionType = (string) $attributes->type;
+        $operatorType = (string) $attributes->operator;
+        $operands = [];
+        foreach ($cfRuleXml->children($this->ns['xm']) as $cfRuleOperandsXml) {
+            $operands[] = (string) $cfRuleOperandsXml;
+        }
+        $conditional = new Conditional();
+        $conditional->setConditionType($conditionType);
+        $conditional->setOperatorType($operatorType);
+        if (
+            $conditionType === Conditional::CONDITION_CONTAINSTEXT
+            || $conditionType === Conditional::CONDITION_NOTCONTAINSTEXT
+            || $conditionType === Conditional::CONDITION_BEGINSWITH
+            || $conditionType === Conditional::CONDITION_ENDSWITH
+            || $conditionType === Conditional::CONDITION_TIMEPERIOD
+        ) {
+            $conditional->setText(array_pop($operands) ?? '');
+        }
+        $conditional->setConditions($operands);
+        return $conditional;
+    }
+    private function readStyleFromExt(SimpleXMLElement $extCfRuleXml): Style
+    {
+        $cfStyle = new Style(false, true);
+        if ($extCfRuleXml->dxf) {
+            $styleXML = $extCfRuleXml->dxf->children();
+            if ($styleXML->borders) {
+                $this->styleReader->readBorderStyle($cfStyle->getBorders(), $styleXML->borders);
+            }
+            if ($styleXML->fill) {
+                $this->styleReader->readFillStyle($cfStyle->getFill(), $styleXML->fill);
+            }
+        }
+        return $cfStyle;
+    }
+    private function readConditionalStyles(SimpleXMLElement $xmlSheet): array
+    {
+        $conditionals = [];
+        foreach ($xmlSheet->conditionalFormatting as $conditional) {
+            foreach ($conditional->cfRule as $cfRule) {
+                if (Conditional::isValidConditionType((string) $cfRule['type']) && (!isset($cfRule['dxfId']) || isset($this->dxfs[(int) ($cfRule['dxfId'])]))) {
+                    $conditionals[(string) $conditional['sqref']][(int) ($cfRule['priority'])] = $cfRule;
+                } elseif ((string) $cfRule['type'] == Conditional::CONDITION_DATABAR) {
+                    $conditionals[(string) $conditional['sqref']][(int) ($cfRule['priority'])] = $cfRule;
+                }
+            }
+        }
+        return $conditionals;
+    }
+    private function setConditionalStyles(Worksheet $worksheet, array $conditionals, SimpleXMLElement $xmlExtLst): void
+    {
+        foreach ($conditionals as $cellRangeReference => $cfRules) {
+            ksort($cfRules);
+            $conditionalStyles = $this->readStyleRules($cfRules, $xmlExtLst);
+            $cellRangeReference = str_replace(['$', ' ', ',', '^'], ['', '^', ' ', ','], strtoupper($cellRangeReference));
+            $worksheet->getStyle($cellRangeReference)->setConditionalStyles($conditionalStyles);
+        }
+    }
+    private function readStyleRules(array $cfRules, SimpleXMLElement $extLst): array
+    {
+        $conditionalFormattingRuleExtensions = ConditionalFormattingRuleExtension::parseExtLstXml($extLst);
+        $conditionalStyles = [];
+        /** @var SimpleXMLElement $cfRule */
+        foreach ($cfRules as $cfRule) {
+            $objConditional = new Conditional();
+            $objConditional->setConditionType((string) $cfRule['type']);
+            $objConditional->setOperatorType((string) $cfRule['operator']);
+            $objConditional->setNoFormatSet(!isset($cfRule['dxfId']));
+            if ((string) $cfRule['text'] != '') {
+                $objConditional->setText((string) $cfRule['text']);
+            } elseif ((string) $cfRule['timePeriod'] != '') {
+                $objConditional->setText((string) $cfRule['timePeriod']);
+            }
+            if (isset($cfRule['stopIfTrue']) && (int) $cfRule['stopIfTrue'] === 1) {
+                $objConditional->setStopIfTrue(true);
+            }
+            if (count($cfRule->formula) >= 1) {
+                foreach ($cfRule->formula as $formulax) {
+                    $formula = (string) $formulax;
+                    if ($formula === 'TRUE') {
+                        $objConditional->addCondition(true);
+                    } elseif ($formula === 'FALSE') {
+                        $objConditional->addCondition(false);
+                    } else {
+                        $objConditional->addCondition($formula);
+                    }
+                }
+            } else {
+                $objConditional->addCondition('');
+            }
+            if (isset($cfRule->dataBar)) {
+                $objConditional->setDataBar(
+                    $this->readDataBarOfConditionalRule($cfRule, $conditionalFormattingRuleExtensions)
+                );
+            } elseif (isset($cfRule->colorScale)) {
+                $objConditional->setColorScale(
+                    $this->readColorScale($cfRule)
+                );
+            } elseif (isset($cfRule['dxfId'])) {
+                $objConditional->setStyle(clone $this->dxfs[(int) ($cfRule['dxfId'])]);
+            }
+            $conditionalStyles[] = $objConditional;
+        }
+        return $conditionalStyles;
+    }
+    private function readDataBarOfConditionalRule(SimpleXMLElement $cfRule, array $conditionalFormattingRuleExtensions): ConditionalDataBar
+    {
+        $dataBar = new ConditionalDataBar();
+        if (isset($cfRule->dataBar['showValue'])) {
+            $dataBar->setShowValue((bool) $cfRule->dataBar['showValue']);
+        }
+        $cfvoXml = $cfRule->dataBar->cfvo;
+        $cfvoIndex = 0;
+        foreach ((count($cfvoXml) > 1 ? $cfvoXml : [$cfvoXml]) as $cfvo) { //* @phpstan-ignore-line
+            if ($cfvoIndex === 0) {
+                $dataBar->setMinimumConditionalFormatValueObject(new ConditionalFormatValueObject((string) $cfvo['type'], (string) $cfvo['val']));
+            }
+            if ($cfvoIndex === 1) {
+                $dataBar->setMaximumConditionalFormatValueObject(new ConditionalFormatValueObject((string) $cfvo['type'], (string) $cfvo['val']));
+            }
+            ++$cfvoIndex;
+        }
+        if (isset($cfRule->dataBar->color)) {
+            $dataBar->setColor($this->styleReader->readColor($cfRule->dataBar->color));
+        }
+        $this->readDataBarExtLstOfConditionalRule($dataBar, $cfRule, $conditionalFormattingRuleExtensions);
+        return $dataBar;
+    }
+    private function readColorScale(SimpleXMLElement|stdClass $cfRule): ConditionalColorScale
+    {
+        $colorScale = new ConditionalColorScale();
+        $count = count($cfRule->colorScale->cfvo);
+        $idx = 0;
+        foreach ($cfRule->colorScale->cfvo as $cfvoXml) {
+            $attr = $cfvoXml->attributes() ?? [];
+            $type = (string) ($attr['type'] ?? '');
+            $val = $attr['val'] ?? null;
+            if ($idx === 0) {
+                $method = 'setMinimumConditionalFormatValueObject';
+            } elseif ($idx === 1 && $count === 3) {
+                $method = 'setMidpointConditionalFormatValueObject';
+            } else {
+                $method = 'setMaximumConditionalFormatValueObject';
+            }
+            if ($type !== 'formula') {
+                $colorScale->$method(new ConditionalFormatValueObject($type, $val));
+            } else {
+                $colorScale->$method(new ConditionalFormatValueObject($type, null, $val));
+            }
+            ++$idx;
+        }
+        $idx = 0;
+        foreach ($cfRule->colorScale->color as $color) {
+            $rgb = $this->styleReader->readColor($color);
+            if ($idx === 0) {
+                $colorScale->setMinimumColor(new Color($rgb));
+            } elseif ($idx === 1 && $count === 3) {
+                $colorScale->setMidpointColor(new Color($rgb));
+            } else {
+                $colorScale->setMaximumColor(new Color($rgb));
+            }
+            ++$idx;
+        }
+        return $colorScale;
+    }
+    private function readDataBarExtLstOfConditionalRule(ConditionalDataBar $dataBar, SimpleXMLElement $cfRule, array $conditionalFormattingRuleExtensions): void
+    {
+        if (isset($cfRule->extLst)) {
+            $ns = $cfRule->extLst->getNamespaces(true);
+            foreach ((count($cfRule->extLst) > 0 ? $cfRule->extLst->ext : [$cfRule->extLst->ext]) as $ext) { //* @phpstan-ignore-line
+                $extId = (string) $ext->children($ns['x14'])->id;
+                if (isset($conditionalFormattingRuleExtensions[$extId]) && (string) $ext['uri'] === '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}') {
+                    $dataBar->setConditionalFormattingRuleExt($conditionalFormattingRuleExtensions[$extId]);
+                }
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/ReferenceHelper.php
@@ -0,0 +1,1025 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
+use PhpOffice\PhpSpreadsheet\Worksheet\Table;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+class ReferenceHelper
+{
+    /**    Constants                */
+    /**    Regular Expressions      */
+    private const SHEETNAME_PART = '((\w*|\'[^!]*\')!)';
+    private const SHEETNAME_PART_WITH_SLASHES = '/' . self::SHEETNAME_PART . '/';
+    const REFHELPER_REGEXP_CELLREF = self::SHEETNAME_PART . '?(?<![:a-z1-9_\.\$])(\$?[a-z]{1,3}\$?\d+)(?=[^:!\d\'])';
+    const REFHELPER_REGEXP_CELLRANGE = self::SHEETNAME_PART . '?(\$?[a-z]{1,3}\$?\d+):(\$?[a-z]{1,3}\$?\d+)';
+    const REFHELPER_REGEXP_ROWRANGE = self::SHEETNAME_PART . '?(\$?\d+):(\$?\d+)';
+    const REFHELPER_REGEXP_COLRANGE = self::SHEETNAME_PART . '?(\$?[a-z]{1,3}):(\$?[a-z]{1,3})';
+    /**
+     * Instance of this class.
+     *
+     * @var ?ReferenceHelper
+     */
+    private static ?ReferenceHelper $instance = null;
+    private ?CellReferenceHelper $cellReferenceHelper = null;
+    /**
+     * Get an instance of this class.
+     */
+    public static function getInstance(): self
+    {
+        if (self::$instance === null) {
+            self::$instance = new self();
+        }
+        return self::$instance;
+    }
+    /**
+     * Create a new ReferenceHelper.
+     */
+    protected function __construct()
+    {
+    }
+    /**
+     * Compare two column addresses
+     * Intended for use as a Callback function for sorting column addresses by column.
+     *
+     * @param string $a First column to test (e.g. 'AA')
+     * @param string $b Second column to test (e.g. 'Z')
+     */
+    public static function columnSort(string $a, string $b): int
+    {
+        return strcasecmp(strlen($a) . $a, strlen($b) . $b);
+    }
+    /**
+     * Compare two column addresses
+     * Intended for use as a Callback function for reverse sorting column addresses by column.
+     *
+     * @param string $a First column to test (e.g. 'AA')
+     * @param string $b Second column to test (e.g. 'Z')
+     */
+    public static function columnReverseSort(string $a, string $b): int
+    {
+        return -strcasecmp(strlen($a) . $a, strlen($b) . $b);
+    }
+    /**
+     * Compare two cell addresses
+     * Intended for use as a Callback function for sorting cell addresses by column and row.
+     *
+     * @param string $a First cell to test (e.g. 'AA1')
+     * @param string $b Second cell to test (e.g. 'Z1')
+     */
+    public static function cellSort(string $a, string $b): int
+    {
+        sscanf($a, '%[A-Z]%d', $ac, $ar);
+        /** @var int $ar */
+        /** @var string $ac */
+        sscanf($b, '%[A-Z]%d', $bc, $br);
+        /** @var int $br */
+        /** @var string $bc */
+        if ($ar === $br) {
+            return strcasecmp(strlen($ac) . $ac, strlen($bc) . $bc);
+        }
+        return ($ar < $br) ? -1 : 1;
+    }
+    /**
+     * Compare two cell addresses
+     * Intended for use as a Callback function for sorting cell addresses by column and row.
+     *
+     * @param string $a First cell to test (e.g. 'AA1')
+     * @param string $b Second cell to test (e.g. 'Z1')
+     */
+    public static function cellReverseSort(string $a, string $b): int
+    {
+        sscanf($a, '%[A-Z]%d', $ac, $ar);
+        /** @var int $ar */
+        /** @var string $ac */
+        sscanf($b, '%[A-Z]%d', $bc, $br);
+        /** @var int $br */
+        /** @var string $bc */
+        if ($ar === $br) {
+            return -strcasecmp(strlen($ac) . $ac, strlen($bc) . $bc);
+        }
+        return ($ar < $br) ? 1 : -1;
+    }
+    /**
+     * Update page breaks when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustPageBreaks(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
+    {
+        $aBreaks = $worksheet->getBreaks();
+        ($numberOfColumns > 0 || $numberOfRows > 0)
+            ? uksort($aBreaks, [self::class, 'cellReverseSort'])
+            : uksort($aBreaks, [self::class, 'cellSort']);
+        foreach ($aBreaks as $cellAddress => $value) {
+            /** @var CellReferenceHelper */
+            $cellReferenceHelper = $this->cellReferenceHelper;
+            if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === true) {
+                $worksheet->setBreak($cellAddress, Worksheet::BREAK_NONE);
+            } else {
+                $newReference = $this->updateCellReference($cellAddress);
+                if ($cellAddress !== $newReference) {
+                    $worksheet->setBreak($newReference, $value)
+                        ->setBreak($cellAddress, Worksheet::BREAK_NONE);
+                }
+            }
+        }
+    }
+    /**
+     * Update cell comments when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     */
+    protected function adjustComments(Worksheet $worksheet): void
+    {
+        $aComments = $worksheet->getComments();
+        $aNewComments = []; // the new array of all comments
+        foreach ($aComments as $cellAddress => &$value) {
+            /** @var CellReferenceHelper */
+            $cellReferenceHelper = $this->cellReferenceHelper;
+            if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === false) {
+                $newReference = $this->updateCellReference($cellAddress);
+                $aNewComments[$newReference] = $value;
+            }
+        }
+        $worksheet->setComments($aNewComments);
+    }
+    /**
+     * Update hyperlinks when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustHyperlinks(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
+    {
+        $aHyperlinkCollection = $worksheet->getHyperlinkCollection();
+        ($numberOfColumns > 0 || $numberOfRows > 0)
+            ? uksort($aHyperlinkCollection, [self::class, 'cellReverseSort'])
+            : uksort($aHyperlinkCollection, [self::class, 'cellSort']);
+        foreach ($aHyperlinkCollection as $cellAddress => $value) {
+            $newReference = $this->updateCellReference($cellAddress);
+            /** @var CellReferenceHelper */
+            $cellReferenceHelper = $this->cellReferenceHelper;
+            if ($cellReferenceHelper->cellAddressInDeleteRange($cellAddress) === true) {
+                $worksheet->setHyperlink($cellAddress, null);
+            } elseif ($cellAddress !== $newReference) {
+                $worksheet->setHyperlink($newReference, $value);
+                $worksheet->setHyperlink($cellAddress, null);
+            }
+        }
+    }
+    /**
+     * Update conditional formatting styles when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustConditionalFormatting(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
+    {
+        $aStyles = $worksheet->getConditionalStylesCollection();
+        ($numberOfColumns > 0 || $numberOfRows > 0)
+            ? uksort($aStyles, [self::class, 'cellReverseSort'])
+            : uksort($aStyles, [self::class, 'cellSort']);
+        foreach ($aStyles as $cellAddress => $cfRules) {
+            $worksheet->removeConditionalStyles($cellAddress);
+            $newReference = $this->updateCellReference($cellAddress);
+            foreach ($cfRules as &$cfRule) {
+                /** @var Conditional $cfRule */
+                $conditions = $cfRule->getConditions();
+                foreach ($conditions as &$condition) {
+                    if (is_string($condition)) {
+                        /** @var CellReferenceHelper */
+                        $cellReferenceHelper = $this->cellReferenceHelper;
+                        $condition = $this->updateFormulaReferences(
+                            $condition,
+                            $cellReferenceHelper->beforeCellAddress(),
+                            $numberOfColumns,
+                            $numberOfRows,
+                            $worksheet->getTitle(),
+                            true
+                        );
+                    }
+                }
+                $cfRule->setConditions($conditions);
+            }
+            $worksheet->setConditionalStyles($newReference, $cfRules);
+        }
+    }
+    /**
+     * Update data validations when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustDataValidations(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
+    {
+        $aDataValidationCollection = $worksheet->getDataValidationCollection();
+        ($numberOfColumns > 0 || $numberOfRows > 0)
+            ? uksort($aDataValidationCollection, [self::class, 'cellReverseSort'])
+            : uksort($aDataValidationCollection, [self::class, 'cellSort']);
+        foreach ($aDataValidationCollection as $cellAddress => $dataValidation) {
+            $newReference = $this->updateCellReference($cellAddress);
+            if ($cellAddress !== $newReference) {
+                $dataValidation->setSqref($newReference);
+                $worksheet->setDataValidation($newReference, $dataValidation);
+                $worksheet->setDataValidation($cellAddress, null);
+            }
+        }
+    }
+    /**
+     * Update merged cells when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     */
+    protected function adjustMergeCells(Worksheet $worksheet): void
+    {
+        $aMergeCells = $worksheet->getMergeCells();
+        $aNewMergeCells = []; // the new array of all merge cells
+        foreach ($aMergeCells as $cellAddress => &$value) {
+            $newReference = $this->updateCellReference($cellAddress);
+            $aNewMergeCells[$newReference] = $newReference;
+        }
+        $worksheet->setMergeCells($aNewMergeCells); // replace the merge cells array
+    }
+    /**
+     * Update protected cells when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustProtectedCells(Worksheet $worksheet, int $numberOfColumns, int $numberOfRows): void
+    {
+        $aProtectedCells = $worksheet->getProtectedCells();
+        ($numberOfColumns > 0 || $numberOfRows > 0)
+            ? uksort($aProtectedCells, [self::class, 'cellReverseSort'])
+            : uksort($aProtectedCells, [self::class, 'cellSort']);
+        foreach ($aProtectedCells as $cellAddress => $value) {
+            $newReference = $this->updateCellReference($cellAddress);
+            if ($cellAddress !== $newReference) {
+                $worksheet->protectCells($newReference, $value, true);
+                $worksheet->unprotectCells($cellAddress);
+            }
+        }
+    }
+    /**
+     * Update column dimensions when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     */
+    protected function adjustColumnDimensions(Worksheet $worksheet): void
+    {
+        $aColumnDimensions = array_reverse($worksheet->getColumnDimensions(), true);
+        if (!empty($aColumnDimensions)) {
+            foreach ($aColumnDimensions as $objColumnDimension) {
+                $newReference = $this->updateCellReference($objColumnDimension->getColumnIndex() . '1');
+                [$newReference] = Coordinate::coordinateFromString($newReference);
+                if ($objColumnDimension->getColumnIndex() !== $newReference) {
+                    $objColumnDimension->setColumnIndex($newReference);
+                }
+            }
+            $worksheet->refreshColumnDimensions();
+        }
+    }
+    /**
+     * Update row dimensions when inserting/deleting rows/columns.
+     *
+     * @param Worksheet $worksheet The worksheet that we're editing
+     * @param int $beforeRow Number of the row we're inserting/deleting before
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     */
+    protected function adjustRowDimensions(Worksheet $worksheet, int $beforeRow, int $numberOfRows): void
+    {
+        $aRowDimensions = array_reverse($worksheet->getRowDimensions(), true);
+        if (!empty($aRowDimensions)) {
+            foreach ($aRowDimensions as $objRowDimension) {
+                $newReference = $this->updateCellReference('A' . $objRowDimension->getRowIndex());
+                [, $newReference] = Coordinate::coordinateFromString($newReference);
+                $newRoweference = (int) $newReference;
+                if ($objRowDimension->getRowIndex() !== $newRoweference) {
+                    $objRowDimension->setRowIndex($newRoweference);
+                }
+            }
+            $worksheet->refreshRowDimensions();
+            $copyDimension = $worksheet->getRowDimension($beforeRow - 1);
+            for ($i = $beforeRow; $i <= $beforeRow - 1 + $numberOfRows; ++$i) {
+                $newDimension = $worksheet->getRowDimension($i);
+                $newDimension->setRowHeight($copyDimension->getRowHeight());
+                $newDimension->setVisible($copyDimension->getVisible());
+                $newDimension->setOutlineLevel($copyDimension->getOutlineLevel());
+                $newDimension->setCollapsed($copyDimension->getCollapsed());
+            }
+        }
+    }
+    /**
+     * Insert a new column or row, updating all possible related data.
+     *
+     * @param string $beforeCellAddress Insert before this cell address (e.g. 'A1')
+     * @param int $numberOfColumns Number of columns to insert/delete (negative values indicate deletion)
+     * @param int $numberOfRows Number of rows to insert/delete (negative values indicate deletion)
+     * @param Worksheet $worksheet The worksheet that we're editing
+     */
+    public function insertNewBefore(
+        string $beforeCellAddress,
+        int $numberOfColumns,
+        int $numberOfRows,
+        Worksheet $worksheet
+    ): void {
+        $remove = ($numberOfColumns < 0 || $numberOfRows < 0);
+        if (
+            $this->cellReferenceHelper === null
+            || $this->cellReferenceHelper->refreshRequired($beforeCellAddress, $numberOfColumns, $numberOfRows)
+        ) {
+            $this->cellReferenceHelper = new CellReferenceHelper($beforeCellAddress, $numberOfColumns, $numberOfRows);
+        }
+        [$beforeColumn, $beforeRow, $beforeColumnString] = Coordinate::indexesFromString($beforeCellAddress);
+        $highestColumn = $worksheet->getHighestColumn();
+        $highestDataColumn = $worksheet->getHighestDataColumn();
+        $highestRow = $worksheet->getHighestRow();
+        $highestDataRow = $worksheet->getHighestDataRow();
+        if ($numberOfColumns < 0 && $beforeColumn - 2 + $numberOfColumns > 0) {
+            $this->clearColumnStrips($highestRow, $beforeColumn, $numberOfColumns, $worksheet);
+        }
+        if ($numberOfRows < 0 && $beforeRow - 1 + $numberOfRows > 0) {
+            $this->clearRowStrips($highestColumn, $beforeColumn, $beforeRow, $numberOfRows, $worksheet);
+        }
+        $startRow = $startCol = 1;
+        $startColString = 'A';
+        if ($numberOfRows === 0) {
+            $startCol = $beforeColumn;
+            $startColString = $beforeColumnString;
+        } elseif ($numberOfColumns === 0) {
+            $startRow = $beforeRow;
+        }
+        $highColumn = Coordinate::columnIndexFromString($highestDataColumn);
+        for ($row = $startRow; $row <= $highestDataRow; ++$row) {
+            for ($col = $startCol, $colString = $startColString; $col <= $highColumn; ++$col, ++$colString) {
+                $worksheet->getCell("$colString$row"); // create cell if it doesn't exist
+            }
+        }
+        $allCoordinates = $worksheet->getCoordinates();
+        if ($remove) {
+            $allCoordinates = array_reverse($allCoordinates);
+        }
+        while ($coordinate = array_pop($allCoordinates)) {
+            $cell = $worksheet->getCell($coordinate);
+            $cellIndex = Coordinate::columnIndexFromString($cell->getColumn());
+            if ($cellIndex - 1 + $numberOfColumns < 0) {
+                continue;
+            }
+            $newCoordinate = Coordinate::stringFromColumnIndex($cellIndex + $numberOfColumns) . ($cell->getRow() + $numberOfRows);
+            if (($cellIndex >= $beforeColumn) && ($cell->getRow() >= $beforeRow)) {
+                $worksheet->getCell($newCoordinate)->setXfIndex($cell->getXfIndex());
+                if ($cell->getDataType() === DataType::TYPE_FORMULA) {
+                    $worksheet->getCell($newCoordinate)
+                        ->setValue($this->updateFormulaReferences($cell->getValueString(), $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true));
+                } else {
+                    $worksheet->getCell($newCoordinate)->setValueExplicit($cell->getValue(), $cell->getDataType());
+                }
+                $worksheet->getCellCollection()->delete($coordinate);
+            } else {
+                /*    We don't need to update styles for rows/columns before our insertion position,
+                        but we do still need to adjust any formulae in those cells                    */
+                if ($cell->getDataType() === DataType::TYPE_FORMULA) {
+                    $cell->setValue($this->updateFormulaReferences($cell->getValueString(), $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true));
+                }
+            }
+        }
+        $highestColumn = $worksheet->getHighestColumn();
+        $highestRow = $worksheet->getHighestRow();
+        if ($numberOfColumns > 0 && $beforeColumn - 2 > 0) {
+            $this->duplicateStylesByColumn($worksheet, $beforeColumn, $beforeRow, $highestRow, $numberOfColumns);
+        }
+        if ($numberOfRows > 0 && $beforeRow - 1 > 0) {
+            $this->duplicateStylesByRow($worksheet, $beforeColumn, $beforeRow, $highestColumn, $numberOfRows);
+        }
+        $this->adjustColumnDimensions($worksheet);
+        $this->adjustRowDimensions($worksheet, $beforeRow, $numberOfRows);
+        $this->adjustPageBreaks($worksheet, $numberOfColumns, $numberOfRows);
+        $this->adjustComments($worksheet);
+        $this->adjustHyperlinks($worksheet, $numberOfColumns, $numberOfRows);
+        $this->adjustConditionalFormatting($worksheet, $numberOfColumns, $numberOfRows);
+        $this->adjustDataValidations($worksheet, $numberOfColumns, $numberOfRows);
+        $this->adjustMergeCells($worksheet);
+        $this->adjustProtectedCells($worksheet, $numberOfColumns, $numberOfRows);
+        $this->adjustAutoFilter($worksheet, $beforeCellAddress, $numberOfColumns);
+        $this->adjustTable($worksheet, $beforeCellAddress, $numberOfColumns);
+        if ($worksheet->getFreezePane()) {
+            $splitCell = $worksheet->getFreezePane();
+            $topLeftCell = $worksheet->getTopLeftCell() ?? '';
+            $splitCell = $this->updateCellReference($splitCell);
+            $topLeftCell = $this->updateCellReference($topLeftCell);
+            $worksheet->freezePane($splitCell, $topLeftCell);
+        }
+        if ($worksheet->getPageSetup()->isPrintAreaSet()) {
+            $worksheet->getPageSetup()->setPrintArea(
+                $this->updateCellReference($worksheet->getPageSetup()->getPrintArea())
+            );
+        }
+        $aDrawings = $worksheet->getDrawingCollection();
+        foreach ($aDrawings as $objDrawing) {
+            $newReference = $this->updateCellReference($objDrawing->getCoordinates());
+            if ($objDrawing->getCoordinates() != $newReference) {
+                $objDrawing->setCoordinates($newReference);
+            }
+            if ($objDrawing->getCoordinates2() !== '') {
+                $newReference = $this->updateCellReference($objDrawing->getCoordinates2());
+                if ($objDrawing->getCoordinates2() != $newReference) {
+                    $objDrawing->setCoordinates2($newReference);
+                }
+            }
+        }
+        if (count($worksheet->getParentOrThrow()->getDefinedNames()) > 0) {
+            $this->updateDefinedNames($worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
+        }
+        $worksheet->garbageCollect();
+    }
+    private static function matchSheetName(?string $match, string $worksheetName): bool
+    {
+        return $match === null || $match === '' || $match === "'\u{fffc}'" || $match === "'\u{fffb}'" || strcasecmp(trim($match, "'"), $worksheetName) === 0;
+    }
+    private static function sheetnameBeforeCells(string $match, string $worksheetName, string $cells): string
+    {
+        $toString = ($match > '') ? "$match!" : '';
+        return str_replace(["\u{fffc}", "'\u{fffb}'"], $worksheetName, $toString) . $cells;
+    }
+    /**
+     * Update references within formulas.
+     *
+     * @param string $formula Formula to update
+     * @param string $beforeCellAddress Insert before this one
+     * @param int $numberOfColumns Number of columns to insert
+     * @param int $numberOfRows Number of rows to insert
+     * @param string $worksheetName Worksheet name/title
+     *
+     * @return string Updated formula
+     */
+    public function updateFormulaReferences(
+        string $formula = '',
+        string $beforeCellAddress = 'A1',
+        int $numberOfColumns = 0,
+        int $numberOfRows = 0,
+        string $worksheetName = '',
+        bool $includeAbsoluteReferences = false,
+        bool $onlyAbsoluteReferences = false
+    ): string {
+        $callback = fn (array $matches): string => (strcasecmp(trim($matches[2], "'"), $worksheetName) === 0) ? (($matches[2][0] === "'") ? "'\u{fffc}'!" : "'\u{fffb}'!") : "'\u{fffd}'!";
+        if (
+            $this->cellReferenceHelper === null
+            || $this->cellReferenceHelper->refreshRequired($beforeCellAddress, $numberOfColumns, $numberOfRows)
+        ) {
+            $this->cellReferenceHelper = new CellReferenceHelper($beforeCellAddress, $numberOfColumns, $numberOfRows);
+        }
+        $formulaBlocks = explode('"', $formula);
+        $i = false;
+        foreach ($formulaBlocks as &$formulaBlock) {
+            $i = $i === false;
+            if ($i) {
+                $adjustCount = 0;
+                $newCellTokens = $cellTokens = [];
+                $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
+                $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_ROWRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
+                if ($matchCount > 0) {
+                    foreach ($matches as $match) {
+                        $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
+                        $modified3 = substr($this->updateCellReference('$A' . $match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences), 2);
+                        $modified4 = substr($this->updateCellReference('$A' . $match[4], $includeAbsoluteReferences, $onlyAbsoluteReferences), 2);
+                        if ($match[3] . ':' . $match[4] !== $modified3 . ':' . $modified4) {
+                            if (self::matchSheetName($match[2], $worksheetName)) {
+                                $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
+                                $column = 100000;
+                                $row = 10000000 + (int) trim($match[3], '$');
+                                $cellIndex = "{$column}{$row}";
+                                $newCellTokens[$cellIndex] = preg_quote($toString, '/');
+                                $cellTokens[$cellIndex] = '/(?<!\d\$\!)' . preg_quote($fromString, '/') . '(?!\d)/i';
+                                ++$adjustCount;
+                            }
+                        }
+                    }
+                }
+                $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
+                $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_COLRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
+                if ($matchCount > 0) {
+                    foreach ($matches as $match) {
+                        $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
+                        $modified3 = substr($this->updateCellReference($match[3] . '$1', $includeAbsoluteReferences, $onlyAbsoluteReferences), 0, -2);
+                        $modified4 = substr($this->updateCellReference($match[4] . '$1', $includeAbsoluteReferences, $onlyAbsoluteReferences), 0, -2);
+                        if ($match[3] . ':' . $match[4] !== $modified3 . ':' . $modified4) {
+                            if (self::matchSheetName($match[2], $worksheetName)) {
+                                $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
+                                $column = Coordinate::columnIndexFromString(trim($match[3], '$')) + 100000;
+                                $row = 10000000;
+                                $cellIndex = "{$column}{$row}";
+                                $newCellTokens[$cellIndex] = preg_quote($toString, '/');
+                                $cellTokens[$cellIndex] = '/(?<![A-Z\$\!])' . preg_quote($fromString, '/') . '(?![A-Z])/i';
+                                ++$adjustCount;
+                            }
+                        }
+                    }
+                }
+                $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, "$formulaBlock") ?? "$formulaBlock") . ' ';
+                $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_CELLRANGE . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
+                if ($matchCount > 0) {
+                    foreach ($matches as $match) {
+                        $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}:{$match[4]}");
+                        $modified3 = $this->updateCellReference($match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences);
+                        $modified4 = $this->updateCellReference($match[4], $includeAbsoluteReferences, $onlyAbsoluteReferences);
+                        if ($match[3] . $match[4] !== $modified3 . $modified4) {
+                            if (self::matchSheetName($match[2], $worksheetName)) {
+                                $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3:$modified4");
+                                [$column, $row] = Coordinate::coordinateFromString($match[3]);
+                                $column = Coordinate::columnIndexFromString(trim($column, '$')) + 100000;
+                                $row = (int) trim($row, '$') + 10000000;
+                                $cellIndex = "{$column}{$row}";
+                                $newCellTokens[$cellIndex] = preg_quote($toString, '/');
+                                $cellTokens[$cellIndex] = '/(?<![A-Z]\$\!)' . preg_quote($fromString, '/') . '(?!\d)/i';
+                                ++$adjustCount;
+                            }
+                        }
+                    }
+                }
+                $formulaBlockx = ' ' . (preg_replace_callback(self::SHEETNAME_PART_WITH_SLASHES, $callback, $formulaBlock) ?? $formulaBlock) . ' ';
+                $matchCount = preg_match_all('/' . self::REFHELPER_REGEXP_CELLREF . '/mui', $formulaBlockx, $matches, PREG_SET_ORDER);
+                if ($matchCount > 0) {
+                    foreach ($matches as $match) {
+                        $fromString = self::sheetnameBeforeCells($match[2], $worksheetName, "{$match[3]}");
+                        $modified3 = $this->updateCellReference($match[3], $includeAbsoluteReferences, $onlyAbsoluteReferences);
+                        if ($match[3] !== $modified3) {
+                            if (self::matchSheetName($match[2], $worksheetName)) {
+                                $toString = self::sheetnameBeforeCells($match[2], $worksheetName, "$modified3");
+                                [$column, $row] = Coordinate::coordinateFromString($match[3]);
+                                $columnAdditionalIndex = $column[0] === '$' ? 1 : 0;
+                                $rowAdditionalIndex = $row[0] === '$' ? 1 : 0;
+                                $column = Coordinate::columnIndexFromString(trim($column, '$')) + 100000;
+                                $row = (int) trim($row, '$') + 10000000;
+                                $cellIndex = $row . $rowAdditionalIndex . $column . $columnAdditionalIndex;
+                                $newCellTokens[$cellIndex] = preg_quote($toString, '/');
+                                $cellTokens[$cellIndex] = '/(?<![A-Z\$\!])' . preg_quote($fromString, '/') . '(?!\d)/i';
+                                ++$adjustCount;
+                            }
+                        }
+                    }
+                }
+                if ($adjustCount > 0) {
+                    if ($numberOfColumns > 0 || $numberOfRows > 0) {
+                        krsort($cellTokens);
+                        krsort($newCellTokens);
+                    } else {
+                        ksort($cellTokens);
+                        ksort($newCellTokens);
+                    }   //  Update cell references in the formula
+                    $formulaBlock = str_replace('\\', '', (string) preg_replace($cellTokens, $newCellTokens, $formulaBlock));
+                }
+            }
+        }
+        unset($formulaBlock);
+        return implode('"', $formulaBlocks);
+    }
+    /**
+     * Update all cell references within a formula, irrespective of worksheet.
+     */
+    public function updateFormulaReferencesAnyWorksheet(string $formula = '', int $numberOfColumns = 0, int $numberOfRows = 0): string
+    {
+        $formula = $this->updateCellReferencesAllWorksheets($formula, $numberOfColumns, $numberOfRows);
+        if ($numberOfColumns !== 0) {
+            $formula = $this->updateColumnRangesAllWorksheets($formula, $numberOfColumns);
+        }
+        if ($numberOfRows !== 0) {
+            $formula = $this->updateRowRangesAllWorksheets($formula, $numberOfRows);
+        }
+        return $formula;
+    }
+    private function updateCellReferencesAllWorksheets(string $formula, int $numberOfColumns, int $numberOfRows): string
+    {
+        $splitCount = preg_match_all(
+            '/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/mui',
+            $formula,
+            $splitRanges,
+            PREG_OFFSET_CAPTURE
+        );
+        $columnLengths = array_map('strlen', array_column($splitRanges[6], 0));
+        $rowLengths = array_map('strlen', array_column($splitRanges[7], 0));
+        $columnOffsets = array_column($splitRanges[6], 1);
+        $rowOffsets = array_column($splitRanges[7], 1);
+        $columns = $splitRanges[6];
+        $rows = $splitRanges[7];
+        while ($splitCount > 0) {
+            --$splitCount;
+            $columnLength = $columnLengths[$splitCount];
+            $rowLength = $rowLengths[$splitCount];
+            $columnOffset = $columnOffsets[$splitCount];
+            $rowOffset = $rowOffsets[$splitCount];
+            $column = $columns[$splitCount][0];
+            $row = $rows[$splitCount][0];
+            if (!empty($column) && $column[0] !== '$') {
+                $column = ((Coordinate::columnIndexFromString($column) + $numberOfColumns) % AddressRange::MAX_COLUMN_INT) ?: AddressRange::MAX_COLUMN_INT;
+                $column = Coordinate::stringFromColumnIndex($column);
+                $rowOffset -= ($columnLength - strlen($column));
+                $formula = substr($formula, 0, $columnOffset) . $column . substr($formula, $columnOffset + $columnLength);
+            }
+            if (!empty($row) && $row[0] !== '$') {
+                $row = (((int) $row + $numberOfRows) % AddressRange::MAX_ROW) ?: AddressRange::MAX_ROW;
+                $formula = substr($formula, 0, $rowOffset) . $row . substr($formula, $rowOffset + $rowLength);
+            }
+        }
+        return $formula;
+    }
+    private function updateColumnRangesAllWorksheets(string $formula, int $numberOfColumns): string
+    {
+        $splitCount = preg_match_all(
+            '/' . Calculation::CALCULATION_REGEXP_COLUMNRANGE_RELATIVE . '/mui',
+            $formula,
+            $splitRanges,
+            PREG_OFFSET_CAPTURE
+        );
+        $fromColumnLengths = array_map('strlen', array_column($splitRanges[1], 0));
+        $fromColumnOffsets = array_column($splitRanges[1], 1);
+        $toColumnLengths = array_map('strlen', array_column($splitRanges[2], 0));
+        $toColumnOffsets = array_column($splitRanges[2], 1);
+        $fromColumns = $splitRanges[1];
+        $toColumns = $splitRanges[2];
+        while ($splitCount > 0) {
+            --$splitCount;
+            $fromColumnLength = $fromColumnLengths[$splitCount];
+            $toColumnLength = $toColumnLengths[$splitCount];
+            $fromColumnOffset = $fromColumnOffsets[$splitCount];
+            $toColumnOffset = $toColumnOffsets[$splitCount];
+            $fromColumn = $fromColumns[$splitCount][0];
+            $toColumn = $toColumns[$splitCount][0];
+            if (!empty($fromColumn) && $fromColumn[0] !== '$') {
+                $fromColumn = Coordinate::stringFromColumnIndex(Coordinate::columnIndexFromString($fromColumn) + $numberOfColumns);
+                $formula = substr($formula, 0, $fromColumnOffset) . $fromColumn . substr($formula, $fromColumnOffset + $fromColumnLength);
+            }
+            if (!empty($toColumn) && $toColumn[0] !== '$') {
+                $toColumn = Coordinate::stringFromColumnIndex(Coordinate::columnIndexFromString($toColumn) + $numberOfColumns);
+                $formula = substr($formula, 0, $toColumnOffset) . $toColumn . substr($formula, $toColumnOffset + $toColumnLength);
+            }
+        }
+        return $formula;
+    }
+    private function updateRowRangesAllWorksheets(string $formula, int $numberOfRows): string
+    {
+        $splitCount = preg_match_all(
+            '/' . Calculation::CALCULATION_REGEXP_ROWRANGE_RELATIVE . '/mui',
+            $formula,
+            $splitRanges,
+            PREG_OFFSET_CAPTURE
+        );
+        $fromRowLengths = array_map('strlen', array_column($splitRanges[1], 0));
+        $fromRowOffsets = array_column($splitRanges[1], 1);
+        $toRowLengths = array_map('strlen', array_column($splitRanges[2], 0));
+        $toRowOffsets = array_column($splitRanges[2], 1);
+        $fromRows = $splitRanges[1];
+        $toRows = $splitRanges[2];
+        while ($splitCount > 0) {
+            --$splitCount;
+            $fromRowLength = $fromRowLengths[$splitCount];
+            $toRowLength = $toRowLengths[$splitCount];
+            $fromRowOffset = $fromRowOffsets[$splitCount];
+            $toRowOffset = $toRowOffsets[$splitCount];
+            $fromRow = $fromRows[$splitCount][0];
+            $toRow = $toRows[$splitCount][0];
+            if (!empty($fromRow) && $fromRow[0] !== '$') {
+                $fromRow = (int) $fromRow + $numberOfRows;
+                $formula = substr($formula, 0, $fromRowOffset) . $fromRow . substr($formula, $fromRowOffset + $fromRowLength);
+            }
+            if (!empty($toRow) && $toRow[0] !== '$') {
+                $toRow = (int) $toRow + $numberOfRows;
+                $formula = substr($formula, 0, $toRowOffset) . $toRow . substr($formula, $toRowOffset + $toRowLength);
+            }
+        }
+        return $formula;
+    }
+    /**
+     * Update cell reference.
+     *
+     * @param string $cellReference Cell address or range of addresses
+     *
+     * @return string Updated cell range
+     */
+    private function updateCellReference(string $cellReference = 'A1', bool $includeAbsoluteReferences = false, bool $onlyAbsoluteReferences = false): string
+    {
+        if (str_contains($cellReference, '!')) {
+            return $cellReference;
+        }
+        if (!Coordinate::coordinateIsRange($cellReference)) {
+            /** @var CellReferenceHelper */
+            $cellReferenceHelper = $this->cellReferenceHelper;
+            return $cellReferenceHelper->updateCellReference($cellReference, $includeAbsoluteReferences, $onlyAbsoluteReferences);
+        }
+        return $this->updateCellRange($cellReference, $includeAbsoluteReferences, $onlyAbsoluteReferences);
+    }
+    /**
+     * Update named formulae (i.e. containing worksheet references / named ranges).
+     *
+     * @param Spreadsheet $spreadsheet Object to update
+     * @param string $oldName Old name (name to replace)
+     * @param string $newName New name
+     */
+    public function updateNamedFormulae(Spreadsheet $spreadsheet, string $oldName = '', string $newName = ''): void
+    {
+        if ($oldName == '') {
+            return;
+        }
+        foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
+            foreach ($sheet->getCoordinates(false) as $coordinate) {
+                $cell = $sheet->getCell($coordinate);
+                if ($cell->getDataType() === DataType::TYPE_FORMULA) {
+                    $formula = $cell->getValueString();
+                    if (str_contains($formula, $oldName)) {
+                        $formula = str_replace("'" . $oldName . "'!", "'" . $newName . "'!", $formula);
+                        $formula = str_replace($oldName . '!', $newName . '!', $formula);
+                        $cell->setValueExplicit($formula, DataType::TYPE_FORMULA);
+                    }
+                }
+            }
+        }
+    }
+    private function updateDefinedNames(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
+    {
+        foreach ($worksheet->getParentOrThrow()->getDefinedNames() as $definedName) {
+            if ($definedName->isFormula() === false) {
+                $this->updateNamedRange($definedName, $worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
+            } else {
+                $this->updateNamedFormula($definedName, $worksheet, $beforeCellAddress, $numberOfColumns, $numberOfRows);
+            }
+        }
+    }
+    private function updateNamedRange(DefinedName $definedName, Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
+    {
+        $cellAddress = $definedName->getValue();
+        $asFormula = ($cellAddress[0] === '=');
+        if ($definedName->getWorksheet() !== null && $definedName->getWorksheet()->getHashCode() === $worksheet->getHashCode()) {
+            /**
+             * If we delete the entire range that is referenced by a Named Range, MS Excel sets the value to #REF!
+             * PhpSpreadsheet still only does a basic adjustment, so the Named Range will still reference Cells.
+             * Note that this applies only when deleting columns/rows; subsequent insertion won't fix the #REF!
+             * TODO Can we work out a method to identify Named Ranges that cease to be valid, so that we can replace
+             *      them with a #REF!
+             */
+            if ($asFormula === true) {
+                $formula = $this->updateFormulaReferences($cellAddress, $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true, true);
+                $definedName->setValue($formula);
+            } else {
+                $definedName->setValue($this->updateCellReference(ltrim($cellAddress, '='), true));
+            }
+        }
+    }
+    private function updateNamedFormula(DefinedName $definedName, Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns, int $numberOfRows): void
+    {
+        if ($definedName->getWorksheet() !== null && $definedName->getWorksheet()->getHashCode() === $worksheet->getHashCode()) {
+            /**
+             * If we delete the entire range that is referenced by a Named Formula, MS Excel sets the value to #REF!
+             * PhpSpreadsheet still only does a basic adjustment, so the Named Formula will still reference Cells.
+             * Note that this applies only when deleting columns/rows; subsequent insertion won't fix the #REF!
+             * TODO Can we work out a method to identify Named Ranges that cease to be valid, so that we can replace
+             *      them with a #REF!
+             */
+            $formula = $definedName->getValue();
+            $formula = $this->updateFormulaReferences($formula, $beforeCellAddress, $numberOfColumns, $numberOfRows, $worksheet->getTitle(), true);
+            $definedName->setValue($formula);
+        }
+    }
+    /**
+     * Update cell range.
+     *
+     * @param string $cellRange Cell range    (e.g. 'B2:D4', 'B:C' or '2:3')
+     *
+     * @return string Updated cell range
+     */
+    private function updateCellRange(string $cellRange = 'A1:A1', bool $includeAbsoluteReferences = false, bool $onlyAbsoluteReferences = false): string
+    {
+        if (!Coordinate::coordinateIsRange($cellRange)) {
+            throw new Exception('Only cell ranges may be passed to this method.');
+        }
+        $range = Coordinate::splitRange($cellRange);
+        $ic = count($range);
+        for ($i = 0; $i < $ic; ++$i) {
+            $jc = count($range[$i]);
+            for ($j = 0; $j < $jc; ++$j) {
+                /** @var CellReferenceHelper */
+                $cellReferenceHelper = $this->cellReferenceHelper;
+                if (ctype_alpha($range[$i][$j])) {
+                    $range[$i][$j] = Coordinate::coordinateFromString(
+                        $cellReferenceHelper->updateCellReference($range[$i][$j] . '1', $includeAbsoluteReferences, $onlyAbsoluteReferences)
+                    )[0];
+                } elseif (ctype_digit($range[$i][$j])) {
+                    $range[$i][$j] = Coordinate::coordinateFromString(
+                        $cellReferenceHelper->updateCellReference('A' . $range[$i][$j], $includeAbsoluteReferences, $onlyAbsoluteReferences)
+                    )[1];
+                } else {
+                    $range[$i][$j] = $cellReferenceHelper->updateCellReference($range[$i][$j], $includeAbsoluteReferences, $onlyAbsoluteReferences);
+                }
+            }
+        }
+        return Coordinate::buildRange($range);
+    }
+    private function clearColumnStrips(int $highestRow, int $beforeColumn, int $numberOfColumns, Worksheet $worksheet): void
+    {
+        $startColumnId = Coordinate::stringFromColumnIndex($beforeColumn + $numberOfColumns);
+        $endColumnId = Coordinate::stringFromColumnIndex($beforeColumn);
+        for ($row = 1; $row <= $highestRow - 1; ++$row) {
+            for ($column = $startColumnId; $column !== $endColumnId; ++$column) {
+                $coordinate = $column . $row;
+                $this->clearStripCell($worksheet, $coordinate);
+            }
+        }
+    }
+    private function clearRowStrips(string $highestColumn, int $beforeColumn, int $beforeRow, int $numberOfRows, Worksheet $worksheet): void
+    {
+        $startColumnId = Coordinate::stringFromColumnIndex($beforeColumn);
+        ++$highestColumn;
+        for ($column = $startColumnId; $column !== $highestColumn; ++$column) {
+            for ($row = $beforeRow + $numberOfRows; $row <= $beforeRow - 1; ++$row) {
+                $coordinate = $column . $row;
+                $this->clearStripCell($worksheet, $coordinate);
+            }
+        }
+    }
+    private function clearStripCell(Worksheet $worksheet, string $coordinate): void
+    {
+        $worksheet->removeConditionalStyles($coordinate);
+        $worksheet->setHyperlink($coordinate);
+        $worksheet->setDataValidation($coordinate);
+        $worksheet->removeComment($coordinate);
+        if ($worksheet->cellExists($coordinate)) {
+            $worksheet->getCell($coordinate)->setValueExplicit(null, DataType::TYPE_NULL);
+            $worksheet->getCell($coordinate)->setXfIndex(0);
+        }
+    }
+    private function adjustAutoFilter(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns): void
+    {
+        $autoFilter = $worksheet->getAutoFilter();
+        $autoFilterRange = $autoFilter->getRange();
+        if (!empty($autoFilterRange)) {
+            if ($numberOfColumns !== 0) {
+                $autoFilterColumns = $autoFilter->getColumns();
+                if (count($autoFilterColumns) > 0) {
+                    $column = '';
+                    $row = 0;
+                    sscanf($beforeCellAddress, '%[A-Z]%d', $column, $row);
+                    $columnIndex = Coordinate::columnIndexFromString((string) $column);
+                    [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($autoFilterRange);
+                    if ($columnIndex <= $rangeEnd[0]) {
+                        if ($numberOfColumns < 0) {
+                            $this->adjustAutoFilterDeleteRules($columnIndex, $numberOfColumns, $autoFilterColumns, $autoFilter);
+                        }
+                        $startCol = ($columnIndex > $rangeStart[0]) ? $columnIndex : $rangeStart[0];
+                        if ($numberOfColumns > 0) {
+                            $this->adjustAutoFilterInsert($startCol, $numberOfColumns, $rangeEnd[0], $autoFilter);
+                        } else {
+                            $this->adjustAutoFilterDelete($startCol, $numberOfColumns, $rangeEnd[0], $autoFilter);
+                        }
+                    }
+                }
+            }
+            $worksheet->setAutoFilter(
+                $this->updateCellReference($autoFilterRange)
+            );
+        }
+    }
+    private function adjustAutoFilterDeleteRules(int $columnIndex, int $numberOfColumns, array $autoFilterColumns, AutoFilter $autoFilter): void
+    {
+        $deleteColumn = $columnIndex + $numberOfColumns - 1;
+        $deleteCount = abs($numberOfColumns);
+        for ($i = 1; $i <= $deleteCount; ++$i) {
+            $columnName = Coordinate::stringFromColumnIndex($deleteColumn + 1);
+            if (isset($autoFilterColumns[$columnName])) {
+                $autoFilter->clearColumn($columnName);
+            }
+            ++$deleteColumn;
+        }
+    }
+    private function adjustAutoFilterInsert(int $startCol, int $numberOfColumns, int $rangeEnd, AutoFilter $autoFilter): void
+    {
+        $startColRef = $startCol;
+        $endColRef = $rangeEnd;
+        $toColRef = $rangeEnd + $numberOfColumns;
+        do {
+            $autoFilter->shiftColumn(Coordinate::stringFromColumnIndex($endColRef), Coordinate::stringFromColumnIndex($toColRef));
+            --$endColRef;
+            --$toColRef;
+        } while ($startColRef <= $endColRef);
+    }
+    private function adjustAutoFilterDelete(int $startCol, int $numberOfColumns, int $rangeEnd, AutoFilter $autoFilter): void
+    {
+        $startColID = Coordinate::stringFromColumnIndex($startCol);
+        $toColID = Coordinate::stringFromColumnIndex($startCol + $numberOfColumns);
+        $endColID = Coordinate::stringFromColumnIndex($rangeEnd + 1);
+        do {
+            $autoFilter->shiftColumn($startColID, $toColID);
+            ++$startColID;
+            ++$toColID;
+        } while ($startColID !== $endColID);
+    }
+    private function adjustTable(Worksheet $worksheet, string $beforeCellAddress, int $numberOfColumns): void
+    {
+        $tableCollection = $worksheet->getTableCollection();
+        foreach ($tableCollection as $table) {
+            $tableRange = $table->getRange();
+            if (!empty($tableRange)) {
+                if ($numberOfColumns !== 0) {
+                    $tableColumns = $table->getColumns();
+                    if (count($tableColumns) > 0) {
+                        $column = '';
+                        $row = 0;
+                        sscanf($beforeCellAddress, '%[A-Z]%d', $column, $row);
+                        $columnIndex = Coordinate::columnIndexFromString((string) $column);
+                        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($tableRange);
+                        if ($columnIndex <= $rangeEnd[0]) {
+                            if ($numberOfColumns < 0) {
+                                $this->adjustTableDeleteRules($columnIndex, $numberOfColumns, $tableColumns, $table);
+                            }
+                            $startCol = ($columnIndex > $rangeStart[0]) ? $columnIndex : $rangeStart[0];
+                            if ($numberOfColumns > 0) {
+                                $this->adjustTableInsert($startCol, $numberOfColumns, $rangeEnd[0], $table);
+                            } else {
+                                $this->adjustTableDelete($startCol, $numberOfColumns, $rangeEnd[0], $table);
+                            }
+                        }
+                    }
+                }
+                $table->setRange($this->updateCellReference($tableRange));
+            }
+        }
+    }
+    private function adjustTableDeleteRules(int $columnIndex, int $numberOfColumns, array $tableColumns, Table $table): void
+    {
+        $deleteColumn = $columnIndex + $numberOfColumns - 1;
+        $deleteCount = abs($numberOfColumns);
+        for ($i = 1; $i <= $deleteCount; ++$i) {
+            $columnName = Coordinate::stringFromColumnIndex($deleteColumn + 1);
+            if (isset($tableColumns[$columnName])) {
+                $table->clearColumn($columnName);
+            }
+            ++$deleteColumn;
+        }
+    }
+    private function adjustTableInsert(int $startCol, int $numberOfColumns, int $rangeEnd, Table $table): void
+    {
+        $startColRef = $startCol;
+        $endColRef = $rangeEnd;
+        $toColRef = $rangeEnd + $numberOfColumns;
+        do {
+            $table->shiftColumn(Coordinate::stringFromColumnIndex($endColRef), Coordinate::stringFromColumnIndex($toColRef));
+            --$endColRef;
+            --$toColRef;
+        } while ($startColRef <= $endColRef);
+    }
+    private function adjustTableDelete(int $startCol, int $numberOfColumns, int $rangeEnd, Table $table): void
+    {
+        $startColID = Coordinate::stringFromColumnIndex($startCol);
+        $toColID = Coordinate::stringFromColumnIndex($startCol + $numberOfColumns);
+        $endColID = Coordinate::stringFromColumnIndex($rangeEnd + 1);
+        do {
+            $table->shiftColumn($startColID, $toColID);
+            ++$startColID;
+            ++$toColID;
+        } while ($startColID !== $endColID);
+    }
+    private function duplicateStylesByColumn(Worksheet $worksheet, int $beforeColumn, int $beforeRow, int $highestRow, int $numberOfColumns): void
+    {
+        $beforeColumnName = Coordinate::stringFromColumnIndex($beforeColumn - 1);
+        for ($i = $beforeRow; $i <= $highestRow - 1; ++$i) {
+            $coordinate = $beforeColumnName . $i;
+            if ($worksheet->cellExists($coordinate)) {
+                $xfIndex = $worksheet->getCell($coordinate)->getXfIndex();
+                for ($j = $beforeColumn; $j <= $beforeColumn - 1 + $numberOfColumns; ++$j) {
+                    if (!empty($xfIndex) || $worksheet->cellExists([$j, $i])) {
+                        $worksheet->getCell([$j, $i])->setXfIndex($xfIndex);
+                    }
+                }
+            }
+        }
+    }
+    private function duplicateStylesByRow(Worksheet $worksheet, int $beforeColumn, int $beforeRow, string $highestColumn, int $numberOfRows): void
+    {
+        $highestColumnIndex = Coordinate::columnIndexFromString($highestColumn);
+        for ($i = $beforeColumn; $i <= $highestColumnIndex; ++$i) {
+            $coordinate = Coordinate::stringFromColumnIndex($i) . ($beforeRow - 1);
+            if ($worksheet->cellExists($coordinate)) {
+                $xfIndex = $worksheet->getCell($coordinate)->getXfIndex();
+                for ($j = $beforeRow; $j <= $beforeRow - 1 + $numberOfRows; ++$j) {
+                    if (!empty($xfIndex) || $worksheet->cellExists([$j, $i])) {
+                        $worksheet->getCell(Coordinate::stringFromColumnIndex($i) . $j)->setXfIndex($xfIndex);
+                    }
+                }
+            }
+        }
+    }
+    /**
+     * __clone implementation. Cloning should not be allowed in a Singleton!
+     */
+    final public function __clone()
+    {
+        throw new Exception('Cloning a Singleton is not allowed!');
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/RichText/RichText.php
@@ -0,0 +1,136 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\RichText;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\IComparable;
+use Stringable;
+class RichText implements IComparable, Stringable
+{
+    /**
+     * Rich text elements.
+     *
+     * @var ITextElement[]
+     */
+    private array $richTextElements;
+    /**
+     * Create a new RichText instance.
+     */
+    public function __construct(?Cell $cell = null)
+    {
+        $this->richTextElements = [];
+        if ($cell !== null) {
+            if ($cell->getValueString() !== '') {
+                $objRun = new Run($cell->getValueString());
+                $objRun->setFont(clone $cell->getWorksheet()->getStyle($cell->getCoordinate())->getFont());
+                $this->addText($objRun);
+            }
+            $cell->setValueExplicit($this, DataType::TYPE_STRING);
+        }
+    }
+    /**
+     * Add text.
+     *
+     * @param ITextElement $text Rich text element
+     *
+     * @return $this
+     */
+    public function addText(ITextElement $text): static
+    {
+        $this->richTextElements[] = $text;
+        return $this;
+    }
+    /**
+     * Create text.
+     *
+     * @param string $text Text
+     */
+    public function createText(string $text): TextElement
+    {
+        $objText = new TextElement($text);
+        $this->addText($objText);
+        return $objText;
+    }
+    /**
+     * Create text run.
+     *
+     * @param string $text Text
+     */
+    public function createTextRun(string $text): Run
+    {
+        $objText = new Run($text);
+        $this->addText($objText);
+        return $objText;
+    }
+    /**
+     * Get plain text.
+     */
+    public function getPlainText(): string
+    {
+        $returnValue = '';
+        foreach ($this->richTextElements as $text) {
+            $returnValue .= $text->getText();
+        }
+        return $returnValue;
+    }
+    /**
+     * Convert to string.
+     */
+    public function __toString(): string
+    {
+        return $this->getPlainText();
+    }
+    /**
+     * Get Rich Text elements.
+     *
+     * @return ITextElement[]
+     */
+    public function getRichTextElements(): array
+    {
+        return $this->richTextElements;
+    }
+    /**
+     * Set Rich Text elements.
+     *
+     * @param ITextElement[] $textElements Array of elements
+     *
+     * @return $this
+     */
+    public function setRichTextElements(array $textElements): static
+    {
+        $this->richTextElements = $textElements;
+        return $this;
+    }
+    /**
+     * Get hash code.
+     *
+     * @return string Hash code
+     */
+    public function getHashCode(): string
+    {
+        $hashElements = '';
+        foreach ($this->richTextElements as $element) {
+            $hashElements .= $element->getHashCode();
+        }
+        return md5(
+            $hashElements
+            . __CLASS__
+        );
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $vars = get_object_vars($this);
+        foreach ($vars as $key => $value) {
+            $newValue = is_object($value) ? (clone $value) : $value;
+            if (is_array($value)) {
+                $newValue = [];
+                foreach ($value as $key2 => $value2) {
+                    $newValue[$key2] = is_object($value2) ? (clone $value2) : $value2;
+                }
+            }
+            $this->$key = $newValue;
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Shared/Date.php
@@ -0,0 +1,460 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Shared;
+use DateTime;
+use DateTimeInterface;
+use DateTimeZone;
+use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+class Date
+{
+    /** constants */
+    const CALENDAR_WINDOWS_1900 = 1900; //    Base date of 1st Jan 1900 = 1.0
+    const CALENDAR_MAC_1904 = 1904; //    Base date of 2nd Jan 1904 = 1.0
+    /**
+     * Names of the months of the year, indexed by shortname
+     * Planned usage for locale settings.
+     *
+     * @var string[]
+     */
+    public static array $monthNames = [
+        'Jan' => 'January',
+        'Feb' => 'February',
+        'Mar' => 'March',
+        'Apr' => 'April',
+        'May' => 'May',
+        'Jun' => 'June',
+        'Jul' => 'July',
+        'Aug' => 'August',
+        'Sep' => 'September',
+        'Oct' => 'October',
+        'Nov' => 'November',
+        'Dec' => 'December',
+    ];
+    /**
+     * @var string[]
+     */
+    public static array $numberSuffixes = [
+        'st',
+        'nd',
+        'rd',
+        'th',
+    ];
+    /**
+     * Base calendar year to use for calculations
+     * Value is either CALENDAR_WINDOWS_1900 (1900) or CALENDAR_MAC_1904 (1904).
+     */
+    protected static int $excelCalendar = self::CALENDAR_WINDOWS_1900;
+    /**
+     * Default timezone to use for DateTime objects.
+     */
+    protected static ?DateTimeZone $defaultTimeZone = null;
+    /**
+     * Set the Excel calendar (Windows 1900 or Mac 1904).
+     *
+     * @param ?int $baseYear Excel base date (1900 or 1904)
+     *
+     * @return bool Success or failure
+     */
+    public static function setExcelCalendar(?int $baseYear): bool
+    {
+        if (
+            ($baseYear === self::CALENDAR_WINDOWS_1900)
+            || ($baseYear === self::CALENDAR_MAC_1904)
+        ) {
+            self::$excelCalendar = $baseYear;
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Return the Excel calendar (Windows 1900 or Mac 1904).
+     *
+     * @return int Excel base date (1900 or 1904)
+     */
+    public static function getExcelCalendar(): int
+    {
+        return self::$excelCalendar;
+    }
+    /**
+     * Set the Default timezone to use for dates.
+     *
+     * @param null|DateTimeZone|string $timeZone The timezone to set for all Excel datetimestamp to PHP DateTime Object conversions
+     *
+     * @return bool Success or failure
+     */
+    public static function setDefaultTimezone($timeZone): bool
+    {
+        try {
+            $timeZone = self::validateTimeZone($timeZone);
+            self::$defaultTimeZone = $timeZone;
+            $retval = true;
+        } catch (PhpSpreadsheetException) {
+            $retval = false;
+        }
+        return $retval;
+    }
+    /**
+     * Return the Default timezone, or UTC if default not set.
+     */
+    public static function getDefaultTimezone(): DateTimeZone
+    {
+        return self::$defaultTimeZone ?? new DateTimeZone('UTC');
+    }
+    /**
+     * Return the Default timezone, or local timezone if default is not set.
+     */
+    public static function getDefaultOrLocalTimezone(): DateTimeZone
+    {
+        return self::$defaultTimeZone ?? new DateTimeZone(date_default_timezone_get());
+    }
+    /**
+     * Return the Default timezone even if null.
+     */
+    public static function getDefaultTimezoneOrNull(): ?DateTimeZone
+    {
+        return self::$defaultTimeZone;
+    }
+    /**
+     * Validate a timezone.
+     *
+     * @param null|DateTimeZone|string $timeZone The timezone to validate, either as a timezone string or object
+     *
+     * @return ?DateTimeZone The timezone as a timezone object
+     */
+    private static function validateTimeZone($timeZone): ?DateTimeZone
+    {
+        if ($timeZone instanceof DateTimeZone || $timeZone === null) {
+            return $timeZone;
+        }
+        if (in_array($timeZone, DateTimeZone::listIdentifiers(DateTimeZone::ALL_WITH_BC))) {
+            return new DateTimeZone($timeZone);
+        }
+        throw new PhpSpreadsheetException('Invalid timezone');
+    }
+    /**
+     * @param mixed $value Converts a date/time in ISO-8601 standard format date string to an Excel
+     *                         serialized timestamp.
+     *                     See https://en.wikipedia.org/wiki/ISO_8601 for details of the ISO-8601 standard format.
+     */
+    public static function convertIsoDate(mixed $value): float|int
+    {
+        if (!is_string($value)) {
+            throw new Exception('Non-string value supplied for Iso Date conversion');
+        }
+        $date = new DateTime($value);
+        $dateErrors = DateTime::getLastErrors();
+        if (is_array($dateErrors) && ($dateErrors['warning_count'] > 0 || $dateErrors['error_count'] > 0)) {
+            throw new Exception("Invalid string $value supplied for datatype Date");
+        }
+        $newValue = self::PHPToExcel($date);
+        if ($newValue === false) {
+            throw new Exception("Invalid string $value supplied for datatype Date");
+        }
+        if (preg_match('/^\\s*\\d?\\d:\\d\\d(:\\d\\d([.]\\d+)?)?\\s*(am|pm)?\\s*$/i', $value) == 1) {
+            $newValue = fmod($newValue, 1.0);
+        }
+        return $newValue;
+    }
+    /**
+     * Convert a MS serialized datetime value from Excel to a PHP Date/Time object.
+     *
+     * @param float|int $excelTimestamp MS Excel serialized date/time value
+     * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
+     *                                           if you don't want to treat it as a UTC value
+     *                                           Use the default (UTC) unless you absolutely need a conversion
+     *
+     * @return DateTime PHP date/time object
+     */
+    public static function excelToDateTimeObject(float|int $excelTimestamp, null|DateTimeZone|string $timeZone = null): DateTime
+    {
+        $timeZone = ($timeZone === null) ? self::getDefaultTimezone() : self::validateTimeZone($timeZone);
+        if (Functions::getCompatibilityMode() == Functions::COMPATIBILITY_EXCEL) {
+            if ($excelTimestamp < 1 && self::$excelCalendar === self::CALENDAR_WINDOWS_1900) {
+                $baseDate = new DateTime('1970-01-01', $timeZone);
+            } else {
+                if (self::$excelCalendar == self::CALENDAR_WINDOWS_1900) {
+                    $baseDate = ($excelTimestamp < 60) ? new DateTime('1899-12-31', $timeZone) : new DateTime('1899-12-30', $timeZone);
+                } else {
+                    $baseDate = new DateTime('1904-01-01', $timeZone);
+                }
+            }
+        } else {
+            $baseDate = new DateTime('1899-12-30', $timeZone);
+        }
+        $days = floor($excelTimestamp);
+        $partDay = $excelTimestamp - $days;
+        $hms = 86400 * $partDay;
+        $microseconds = (int) round(fmod($hms, 1) * 1000000);
+        $hms = (int) floor($hms);
+        $hours = intdiv($hms, 3600);
+        $hms -= $hours * 3600;
+        $minutes = intdiv($hms, 60);
+        $seconds = $hms % 60;
+        if ($days >= 0) {
+            $days = '+' . $days;
+        }
+        $interval = $days . ' days';
+        return $baseDate->modify($interval)
+            ->setTime($hours, $minutes, $seconds, $microseconds);
+    }
+    /**
+     * Convert a MS serialized datetime value from Excel to a unix timestamp.
+     * The use of Unix timestamps, and therefore this function, is discouraged.
+     * They are not Y2038-safe on a 32-bit system, and have no timezone info.
+     *
+     * @param float|int $excelTimestamp MS Excel serialized date/time value
+     * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
+     *                                               if you don't want to treat it as a UTC value
+     *                                               Use the default (UTC) unless you absolutely need a conversion
+     *
+     * @return int Unix timetamp for this date/time
+     */
+    public static function excelToTimestamp($excelTimestamp, $timeZone = null): int
+    {
+        $dto = self::excelToDateTimeObject($excelTimestamp, $timeZone);
+        self::roundMicroseconds($dto);
+        return (int) $dto->format('U');
+    }
+    /**
+     * Convert a date from PHP to an MS Excel serialized date/time value.
+     *
+     * @param mixed $dateValue PHP DateTime object or a string - Unix timestamp is also permitted, but discouraged;
+     *    not Y2038-safe on a 32-bit system, and no timezone info
+     *
+     * @return false|float Excel date/time value
+     *                                  or boolean FALSE on failure
+     */
+    public static function PHPToExcel(mixed $dateValue)
+    {
+        if ((is_object($dateValue)) && ($dateValue instanceof DateTimeInterface)) {
+            return self::dateTimeToExcel($dateValue);
+        } elseif (is_numeric($dateValue)) {
+            return self::timestampToExcel($dateValue);
+        } elseif (is_string($dateValue)) {
+            return self::stringToExcel($dateValue);
+        }
+        return false;
+    }
+    /**
+     * Convert a PHP DateTime object to an MS Excel serialized date/time value.
+     *
+     * @param DateTimeInterface $dateValue PHP DateTime object
+     *
+     * @return float MS Excel serialized date/time value
+     */
+    public static function dateTimeToExcel(DateTimeInterface $dateValue): float
+    {
+        $seconds = (float) sprintf('%d.%06d', $dateValue->format('s'), $dateValue->format('u'));
+        return self::formattedPHPToExcel(
+            (int) $dateValue->format('Y'),
+            (int) $dateValue->format('m'),
+            (int) $dateValue->format('d'),
+            (int) $dateValue->format('H'),
+            (int) $dateValue->format('i'),
+            $seconds
+        );
+    }
+    /**
+     * Convert a Unix timestamp to an MS Excel serialized date/time value.
+     * The use of Unix timestamps, and therefore this function, is discouraged.
+     * They are not Y2038-safe on a 32-bit system, and have no timezone info.
+     *
+     * @param float|int|string $unixTimestamp Unix Timestamp
+     *
+     * @return false|float MS Excel serialized date/time value
+     */
+    public static function timestampToExcel($unixTimestamp): bool|float
+    {
+        if (!is_numeric($unixTimestamp)) {
+            return false;
+        }
+        return self::dateTimeToExcel(new DateTime('@' . $unixTimestamp));
+    }
+    /**
+     * formattedPHPToExcel.
+     *
+     * @return float Excel date/time value
+     */
+    public static function formattedPHPToExcel(int $year, int $month, int $day, int $hours = 0, int $minutes = 0, float|int $seconds = 0): float
+    {
+        if (self::$excelCalendar == self::CALENDAR_WINDOWS_1900) {
+            $excel1900isLeapYear = true;
+            if (($year == 1900) && ($month <= 2)) {
+                $excel1900isLeapYear = false;
+            }
+            $myexcelBaseDate = 2415020;
+        } else {
+            $myexcelBaseDate = 2416481;
+            $excel1900isLeapYear = false;
+        }
+        if ($month > 2) {
+            $month -= 3;
+        } else {
+            $month += 9;
+            --$year;
+        }
+        $century = (int) substr((string) $year, 0, 2);
+        $decade = (int) substr((string) $year, 2, 2);
+        $excelDate = floor((146097 * $century) / 4) + floor((1461 * $decade) / 4) + floor((153 * $month + 2) / 5) + $day + 1721119 - $myexcelBaseDate + $excel1900isLeapYear;
+        $excelTime = (($hours * 3600) + ($minutes * 60) + $seconds) / 86400;
+        return (float) $excelDate + $excelTime;
+    }
+    /**
+     * Is a given cell a date/time?
+     */
+    public static function isDateTime(Cell $cell, mixed $value = null, bool $dateWithoutTimeOkay = true): bool
+    {
+        $result = false;
+        $worksheet = $cell->getWorksheetOrNull();
+        $spreadsheet = ($worksheet === null) ? null : $worksheet->getParent();
+        if ($worksheet !== null && $spreadsheet !== null) {
+            $index = $spreadsheet->getActiveSheetIndex();
+            $selected = $worksheet->getSelectedCells();
+            try {
+                $result = is_numeric($value ?? $cell->getCalculatedValue())
+                    && self::isDateTimeFormat(
+                        $worksheet->getStyle(
+                            $cell->getCoordinate()
+                        )->getNumberFormat(),
+                        $dateWithoutTimeOkay
+                    );
+            } catch (Exception) {
+            }
+            $worksheet->setSelectedCells($selected);
+            $spreadsheet->setActiveSheetIndex($index);
+        }
+        return $result;
+    }
+    /**
+     * Is a given NumberFormat code a date/time format code?
+     */
+    public static function isDateTimeFormat(NumberFormat $excelFormatCode, bool $dateWithoutTimeOkay = true): bool
+    {
+        return self::isDateTimeFormatCode((string) $excelFormatCode->getFormatCode(), $dateWithoutTimeOkay);
+    }
+    private const POSSIBLE_DATETIME_FORMAT_CHARACTERS = 'eymdHs';
+    private const POSSIBLE_TIME_FORMAT_CHARACTERS = 'Hs'; // note - no 'm' due to ambiguity
+    /**
+     * Is a given number format code a date/time?
+     */
+    public static function isDateTimeFormatCode(string $excelFormatCode, bool $dateWithoutTimeOkay = true): bool
+    {
+        if (strtolower($excelFormatCode) === strtolower(NumberFormat::FORMAT_GENERAL)) {
+            return false;
+        }
+        if (preg_match('/[0#]E[+-]0/i', $excelFormatCode)) {
+            return false;
+        }
+        $excelFormatCode = (string) NumberFormat::convertSystemFormats($excelFormatCode);
+        if (in_array($excelFormatCode, NumberFormat::DATE_TIME_OR_DATETIME_ARRAY, true)) {
+            return $dateWithoutTimeOkay || in_array($excelFormatCode, NumberFormat::TIME_OR_DATETIME_ARRAY);
+        }
+        if ((str_starts_with($excelFormatCode, '_')) || (str_starts_with($excelFormatCode, '0 '))) {
+            return false;
+        }
+        if (str_contains($excelFormatCode, '-00000')) {
+            return false;
+        }
+        $possibleFormatCharacters = $dateWithoutTimeOkay ? self::POSSIBLE_DATETIME_FORMAT_CHARACTERS : self::POSSIBLE_TIME_FORMAT_CHARACTERS;
+        if (preg_match('/(^|\])[^\[]*[' . $possibleFormatCharacters . ']/i', $excelFormatCode)) {
+            if (str_contains($excelFormatCode, '"')) {
+                $segMatcher = false;
+                foreach (explode('"', $excelFormatCode) as $subVal) {
+                    $segMatcher = $segMatcher === false;
+                    if (
+                        $segMatcher
+                        && (preg_match('/(^|\])[^\[]*[' . $possibleFormatCharacters . ']/i', $subVal))
+                    ) {
+                        return true;
+                    }
+                }
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Convert a date/time string to Excel time.
+     *
+     * @param string $dateValue Examples: '2009-12-31', '2009-12-31 15:59', '2009-12-31 15:59:10'
+     *
+     * @return false|float Excel date/time serial value
+     */
+    public static function stringToExcel(string $dateValue): bool|float
+    {
+        if (strlen($dateValue) < 2) {
+            return false;
+        }
+        if (!preg_match('/^(\d{1,4}[ \.\/\-][A-Z]{3,9}([ \.\/\-]\d{1,4})?|[A-Z]{3,9}[ \.\/\-]\d{1,4}([ \.\/\-]\d{1,4})?|\d{1,4}[ \.\/\-]\d{1,4}([ \.\/\-]\d{1,4})?)( \d{1,2}:\d{1,2}(:\d{1,2})?)?$/iu', $dateValue)) {
+            return false;
+        }
+        $dateValueNew = DateTimeExcel\DateValue::fromString($dateValue);
+        if (!is_float($dateValueNew)) {
+            return false;
+        }
+        if (str_contains($dateValue, ':')) {
+            $timeValue = DateTimeExcel\TimeValue::fromString($dateValue);
+            if (!is_float($timeValue)) {
+                return false;
+            }
+            $dateValueNew += $timeValue;
+        }
+        return $dateValueNew;
+    }
+    /**
+     * Converts a month name (either a long or a short name) to a month number.
+     *
+     * @param string $monthName Month name or abbreviation
+     *
+     * @return int|string Month number (1 - 12), or the original string argument if it isn't a valid month name
+     */
+    public static function monthStringToNumber(string $monthName)
+    {
+        $monthIndex = 1;
+        foreach (self::$monthNames as $shortMonthName => $longMonthName) {
+            if (($monthName === $longMonthName) || ($monthName === $shortMonthName)) {
+                return $monthIndex;
+            }
+            ++$monthIndex;
+        }
+        return $monthName;
+    }
+    /**
+     * Strips an ordinal from a numeric value.
+     *
+     * @param string $day Day number with an ordinal
+     *
+     * @return int|string The integer value with any ordinal stripped, or the original string argument if it isn't a valid numeric
+     */
+    public static function dayStringToNumber(string $day)
+    {
+        $strippedDayValue = (str_replace(self::$numberSuffixes, '', $day));
+        if (is_numeric($strippedDayValue)) {
+            return (int) $strippedDayValue;
+        }
+        return $day;
+    }
+    public static function dateTimeFromTimestamp(string $date, ?DateTimeZone $timeZone = null): DateTime
+    {
+        $dtobj = DateTime::createFromFormat('U', $date) ?: new DateTime();
+        $dtobj->setTimeZone($timeZone ?? self::getDefaultOrLocalTimezone());
+        return $dtobj;
+    }
+    public static function formattedDateTimeFromTimestamp(string $date, string $format, ?DateTimeZone $timeZone = null): string
+    {
+        $dtobj = self::dateTimeFromTimestamp($date, $timeZone);
+        return $dtobj->format($format);
+    }
+    public static function roundMicroseconds(DateTime $dti): void
+    {
+        $microseconds = (int) $dti->format('u');
+        if ($microseconds >= 500000) {
+            $dti->modify('+1 second');
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Shared/Escher/DgContainer/SpgrContainer.php
@@ -0,0 +1,61 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer;
+class SpgrContainer
+{
+    /**
+     * Parent Shape Group Container.
+     */
+    private ?self $parent = null;
+    /**
+     * Shape Container collection.
+     */
+    private array $children = [];
+    /**
+     * Set parent Shape Group Container.
+     */
+    public function setParent(?self $parent): void
+    {
+        $this->parent = $parent;
+    }
+    /**
+     * Get the parent Shape Group Container if any.
+     */
+    public function getParent(): ?self
+    {
+        return $this->parent;
+    }
+    /**
+     * Add a child. This will be either spgrContainer or spContainer.
+     *
+     * @param SpgrContainer|SpgrContainer\SpContainer $child child to be added
+     */
+    public function addChild(mixed $child): void
+    {
+        $this->children[] = $child;
+        $child->setParent($this);
+    }
+    /**
+     * Get collection of Shape Containers.
+     */
+    public function getChildren(): array
+    {
+        return $this->children;
+    }
+    /**
+     * Recursively get all spContainers within this spgrContainer.
+     *
+     * @return SpgrContainer\SpContainer[]
+     */
+    public function getAllSpContainers(): array
+    {
+        $allSpContainers = [];
+        foreach ($this->children as $child) {
+            if ($child instanceof self) {
+                $allSpContainers = array_merge($allSpContainers, $child->getAllSpContainers());
+            } else {
+                $allSpContainers[] = $child;
+            }
+        }
+        return $allSpContainers;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Shared/Trend/PolynomialBestFit.php
@@ -0,0 +1,169 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Shared\Trend;
+use Matrix\Matrix;
+class PolynomialBestFit extends BestFit
+{
+    /**
+     * Algorithm type to use for best-fit
+     * (Name of this Trend class).
+     */
+    protected string $bestFitType = 'polynomial';
+    /**
+     * Polynomial order.
+     */
+    protected int $order = 0;
+    /**
+     * Return the order of this polynomial.
+     */
+    public function getOrder(): int
+    {
+        return $this->order;
+    }
+    /**
+     * Return the Y-Value for a specified value of X.
+     *
+     * @param float $xValue X-Value
+     *
+     * @return float Y-Value
+     */
+    public function getValueOfYForX(float $xValue): float
+    {
+        $retVal = $this->getIntersect();
+        $slope = $this->getSlope();
+        foreach ($slope as $key => $value) {
+            if ($value != 0.0) {
+                $retVal += $value * $xValue ** ($key + 1);
+            }
+        }
+        return $retVal;
+    }
+    /**
+     * Return the X-Value for a specified value of Y.
+     *
+     * @param float $yValue Y-Value
+     *
+     * @return float X-Value
+     */
+    public function getValueOfXForY(float $yValue): float
+    {
+        return ($yValue - $this->getIntersect()) / $this->getSlope();
+    }
+    /**
+     * Return the Equation of the best-fit line.
+     *
+     * @param int $dp Number of places of decimal precision to display
+     */
+    public function getEquation(int $dp = 0): string
+    {
+        $slope = $this->getSlope($dp);
+        $intersect = $this->getIntersect($dp);
+        $equation = 'Y = ' . $intersect;
+        foreach ($slope as $key => $value) {
+            if ($value != 0.0) {
+                $equation .= ' + ' . $value . ' * X';
+                if ($key > 0) {
+                    $equation .= '^' . ($key + 1);
+                }
+            }
+        }
+        return $equation;
+    }
+    /**
+     * Return the Slope of the line.
+     *
+     * @param int $dp Number of places of decimal precision to display
+     */
+    public function getSlope(int $dp = 0): float
+    {
+        if ($dp != 0) {
+            $coefficients = [];
+            foreach ($this->slope as $coefficient) {
+                $coefficients[] = round($coefficient, $dp);
+            }
+            return $coefficients;
+        }
+        return $this->slope;
+    }
+    public function getCoefficients(int $dp = 0): array
+    {
+        return array_merge([$this->getIntersect($dp)], $this->getSlope($dp));
+    }
+    /**
+     * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
+     *
+     * @param int $order Order of Polynomial for this regression
+     * @param float[] $yValues The set of Y-values for this regression
+     * @param float[] $xValues The set of X-values for this regression
+     */
+    private function polynomialRegression(int $order, array $yValues, array $xValues): void
+    {
+        $x_sum = array_sum($xValues);
+        $y_sum = array_sum($yValues);
+        $xx_sum = $xy_sum = $yy_sum = 0;
+        for ($i = 0; $i < $this->valueCount; ++$i) {
+            $xy_sum += $xValues[$i] * $yValues[$i];
+            $xx_sum += $xValues[$i] * $xValues[$i];
+            $yy_sum += $yValues[$i] * $yValues[$i];
+        }
+        /*
+         *    This routine uses logic from the PHP port of polyfit version 0.1
+         *    written by Michael Bommarito and Paul Meagher
+         *
+         *    The function fits a polynomial function of order $order through
+         *    a series of x-y data points using least squares.
+         *
+         */
+        $A = [];
+        $B = [];
+        for ($i = 0; $i < $this->valueCount; ++$i) {
+            for ($j = 0; $j <= $order; ++$j) {
+                $A[$i][$j] = $xValues[$i] ** $j;
+            }
+        }
+        for ($i = 0; $i < $this->valueCount; ++$i) {
+            $B[$i] = [$yValues[$i]];
+        }
+        $matrixA = new Matrix($A);
+        $matrixB = new Matrix($B);
+        $C = $matrixA->solve($matrixB);
+        $coefficients = [];
+        for ($i = 0; $i < $C->rows; ++$i) {
+            $r = $C->getValue($i + 1, 1); // row and column are origin-1
+            if (!is_numeric($r) || abs($r) <= 10 ** (-9)) {
+                $r = 0;
+            } else {
+                $r += 0;
+            }
+            $coefficients[] = $r;
+        }
+        $this->intersect = (float) array_shift($coefficients);
+        $this->slope = $coefficients;
+        $this->calculateGoodnessOfFit($x_sum, $y_sum, $xx_sum, $yy_sum, $xy_sum, 0, 0, 0);
+        foreach ($this->xValues as $xKey => $xValue) {
+            $this->yBestFitValues[$xKey] = $this->getValueOfYForX($xValue);
+        }
+    }
+    /**
+     * Define the regression and calculate the goodness of fit for a set of X and Y data values.
+     *
+     * @param int $order Order of Polynomial for this regression
+     * @param float[] $yValues The set of Y-values for this regression
+     * @param float[] $xValues The set of X-values for this regression
+     */
+    public function __construct(int $order, array $yValues, array $xValues = [])
+    {
+        parent::__construct($yValues, $xValues);
+        if (!$this->error) {
+            if ($order < $this->valueCount) {
+                $this->bestFitType .= '_' . $order;
+                $this->order = $order;
+                $this->polynomialRegression($order, $yValues, $xValues);
+                if (($this->getGoodnessOfFit() < 0.0) || ($this->getGoodnessOfFit() > 1.0)) {
+                    $this->error = true;
+                }
+            } else {
+                $this->error = true;
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Spreadsheet.php
@@ -0,0 +1,1339 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet;
+use JsonSerializable;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Document\Properties;
+use PhpOffice\PhpSpreadsheet\Document\Security;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx as XlsxReader;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\File;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+use PhpOffice\PhpSpreadsheet\Worksheet\Iterator;
+use PhpOffice\PhpSpreadsheet\Worksheet\Table;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use PhpOffice\PhpSpreadsheet\Writer\Xlsx as XlsxWriter;
+class Spreadsheet implements JsonSerializable
+{
+    const VISIBILITY_VISIBLE = 'visible';
+    const VISIBILITY_HIDDEN = 'hidden';
+    const VISIBILITY_VERY_HIDDEN = 'veryHidden';
+    private const DEFINED_NAME_IS_RANGE = false;
+    private const DEFINED_NAME_IS_FORMULA = true;
+    private const WORKBOOK_VIEW_VISIBILITY_VALUES = [
+        self::VISIBILITY_VISIBLE,
+        self::VISIBILITY_HIDDEN,
+        self::VISIBILITY_VERY_HIDDEN,
+    ];
+    protected int $excelCalendar = Date::CALENDAR_WINDOWS_1900;
+    /**
+     * Unique ID.
+     */
+    private string $uniqueID;
+    /**
+     * Document properties.
+     */
+    private Properties $properties;
+    /**
+     * Document security.
+     */
+    private Security $security;
+    /**
+     * Collection of Worksheet objects.
+     *
+     * @var Worksheet[]
+     */
+    private array $workSheetCollection;
+    /**
+     * Calculation Engine.
+     */
+    private ?Calculation $calculationEngine;
+    /**
+     * Active sheet index.
+     */
+    private int $activeSheetIndex;
+    /**
+     * Named ranges.
+     *
+     * @var DefinedName[]
+     */
+    private array $definedNames;
+    /**
+     * CellXf supervisor.
+     */
+    private Style $cellXfSupervisor;
+    /**
+     * CellXf collection.
+     *
+     * @var Style[]
+     */
+    private array $cellXfCollection = [];
+    /**
+     * CellStyleXf collection.
+     *
+     * @var Style[]
+     */
+    private array $cellStyleXfCollection = [];
+    /**
+     * hasMacros : this workbook have macros ?
+     */
+    private bool $hasMacros = false;
+    /**
+     * macrosCode : all macros code as binary data (the vbaProject.bin file, this include form, code,  etc.), null if no macro.
+     */
+    private ?string $macrosCode = null;
+    /**
+     * macrosCertificate : if macros are signed, contains binary data vbaProjectSignature.bin file, null if not signed.
+     */
+    private ?string $macrosCertificate = null;
+    /**
+     * ribbonXMLData : null if workbook is'nt Excel 2007 or not contain a customized UI.
+     *
+     * @var null|array{target: string, data: string}
+     */
+    private ?array $ribbonXMLData = null;
+    /**
+     * ribbonBinObjects : null if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements
+     * ignored if $ribbonXMLData is null.
+     */
+    private ?array $ribbonBinObjects = null;
+    /**
+     * List of unparsed loaded data for export to same format with better compatibility.
+     * It has to be minimized when the library start to support currently unparsed data.
+     */
+    private array $unparsedLoadedData = [];
+    /**
+     * Controls visibility of the horizonal scroll bar in the application.
+     */
+    private bool $showHorizontalScroll = true;
+    /**
+     * Controls visibility of the horizonal scroll bar in the application.
+     */
+    private bool $showVerticalScroll = true;
+    /**
+     * Controls visibility of the sheet tabs in the application.
+     */
+    private bool $showSheetTabs = true;
+    /**
+     * Specifies a boolean value that indicates whether the workbook window
+     * is minimized.
+     */
+    private bool $minimized = false;
+    /**
+     * Specifies a boolean value that indicates whether to group dates
+     * when presenting the user with filtering optiomd in the user
+     * interface.
+     */
+    private bool $autoFilterDateGrouping = true;
+    /**
+     * Specifies the index to the first sheet in the book view.
+     */
+    private int $firstSheetIndex = 0;
+    /**
+     * Specifies the visible status of the workbook.
+     */
+    private string $visibility = self::VISIBILITY_VISIBLE;
+    /**
+     * Specifies the ratio between the workbook tabs bar and the horizontal
+     * scroll bar.  TabRatio is assumed to be out of 1000 of the horizontal
+     * window width.
+     */
+    private int $tabRatio = 600;
+    private Theme $theme;
+    public function getTheme(): Theme
+    {
+        return $this->theme;
+    }
+    /**
+     * The workbook has macros ?
+     */
+    public function hasMacros(): bool
+    {
+        return $this->hasMacros;
+    }
+    /**
+     * Define if a workbook has macros.
+     *
+     * @param bool $hasMacros true|false
+     */
+    public function setHasMacros(bool $hasMacros): void
+    {
+        $this->hasMacros = (bool) $hasMacros;
+    }
+    /**
+     * Set the macros code.
+     *
+     * @param string $macroCode string|null
+     */
+    public function setMacrosCode(string $macroCode): void
+    {
+        $this->macrosCode = $macroCode;
+        $this->setHasMacros($macroCode !== null);
+    }
+    /**
+     * Return the macros code.
+     */
+    public function getMacrosCode(): ?string
+    {
+        return $this->macrosCode;
+    }
+    /**
+     * Set the macros certificate.
+     */
+    public function setMacrosCertificate(?string $certificate): void
+    {
+        $this->macrosCertificate = $certificate;
+    }
+    /**
+     * Is the project signed ?
+     *
+     * @return bool true|false
+     */
+    public function hasMacrosCertificate(): bool
+    {
+        return $this->macrosCertificate !== null;
+    }
+    /**
+     * Return the macros certificate.
+     */
+    public function getMacrosCertificate(): ?string
+    {
+        return $this->macrosCertificate;
+    }
+    /**
+     * Remove all macros, certificate from spreadsheet.
+     */
+    public function discardMacros(): void
+    {
+        $this->hasMacros = false;
+        $this->macrosCode = null;
+        $this->macrosCertificate = null;
+    }
+    /**
+     * set ribbon XML data.
+     */
+    public function setRibbonXMLData(mixed $target, mixed $xmlData): void
+    {
+        if (is_string($target) && is_string($xmlData)) {
+            $this->ribbonXMLData = ['target' => $target, 'data' => $xmlData];
+        } else {
+            $this->ribbonXMLData = null;
+        }
+    }
+    /**
+     * retrieve ribbon XML Data.
+     */
+    public function getRibbonXMLData(string $what = 'all'): null|array|string //we need some constants here...
+    {
+        $returnData = null;
+        $what = strtolower($what);
+        switch ($what) {
+            case 'all':
+                $returnData = $this->ribbonXMLData;
+                break;
+            case 'target':
+            case 'data':
+                if (is_array($this->ribbonXMLData)) {
+                    $returnData = $this->ribbonXMLData[$what];
+                }
+                break;
+        }
+        return $returnData;
+    }
+    /**
+     * store binaries ribbon objects (pictures).
+     */
+    public function setRibbonBinObjects(mixed $binObjectsNames, mixed $binObjectsData): void
+    {
+        if ($binObjectsNames !== null && $binObjectsData !== null) {
+            $this->ribbonBinObjects = ['names' => $binObjectsNames, 'data' => $binObjectsData];
+        } else {
+            $this->ribbonBinObjects = null;
+        }
+    }
+    /**
+     * List of unparsed loaded data for export to same format with better compatibility.
+     * It has to be minimized when the library start to support currently unparsed data.
+     *
+     * @internal
+     */
+    public function getUnparsedLoadedData(): array
+    {
+        return $this->unparsedLoadedData;
+    }
+    /**
+     * List of unparsed loaded data for export to same format with better compatibility.
+     * It has to be minimized when the library start to support currently unparsed data.
+     *
+     * @internal
+     */
+    public function setUnparsedLoadedData(array $unparsedLoadedData): void
+    {
+        $this->unparsedLoadedData = $unparsedLoadedData;
+    }
+    /**
+     * retrieve Binaries Ribbon Objects.
+     */
+    public function getRibbonBinObjects(string $what = 'all'): ?array
+    {
+        $ReturnData = null;
+        $what = strtolower($what);
+        switch ($what) {
+            case 'all':
+                return $this->ribbonBinObjects;
+            case 'names':
+            case 'data':
+                if (is_array($this->ribbonBinObjects) && isset($this->ribbonBinObjects[$what])) {
+                    $ReturnData = $this->ribbonBinObjects[$what];
+                }
+                break;
+            case 'types':
+                if (
+                    is_array($this->ribbonBinObjects)
+                    && isset($this->ribbonBinObjects['data']) && is_array($this->ribbonBinObjects['data'])
+                ) {
+                    $tmpTypes = array_keys($this->ribbonBinObjects['data']);
+                    $ReturnData = array_unique(array_map(fn (string $path): string => pathinfo($path, PATHINFO_EXTENSION), $tmpTypes));
+                } else {
+                    $ReturnData = []; // the caller want an array... not null if empty
+                }
+                break;
+        }
+        return $ReturnData;
+    }
+    /**
+     * This workbook have a custom UI ?
+     */
+    public function hasRibbon(): bool
+    {
+        return $this->ribbonXMLData !== null;
+    }
+    /**
+     * This workbook have additionnal object for the ribbon ?
+     */
+    public function hasRibbonBinObjects(): bool
+    {
+        return $this->ribbonBinObjects !== null;
+    }
+    /**
+     * Check if a sheet with a specified code name already exists.
+     *
+     * @param string $codeName Name of the worksheet to check
+     */
+    public function sheetCodeNameExists(string $codeName): bool
+    {
+        return $this->getSheetByCodeName($codeName) !== null;
+    }
+    /**
+     * Get sheet by code name. Warning : sheet don't have always a code name !
+     *
+     * @param string $codeName Sheet name
+     */
+    public function getSheetByCodeName(string $codeName): ?Worksheet
+    {
+        $worksheetCount = count($this->workSheetCollection);
+        for ($i = 0; $i < $worksheetCount; ++$i) {
+            if ($this->workSheetCollection[$i]->getCodeName() == $codeName) {
+                return $this->workSheetCollection[$i];
+            }
+        }
+        return null;
+    }
+    /**
+     * Create a new PhpSpreadsheet with one Worksheet.
+     */
+    public function __construct()
+    {
+        $this->uniqueID = uniqid('', true);
+        $this->calculationEngine = new Calculation($this);
+        $this->theme = new Theme();
+        $this->workSheetCollection = [];
+        $this->workSheetCollection[] = new Worksheet($this);
+        $this->activeSheetIndex = 0;
+        $this->properties = new Properties();
+        $this->security = new Security();
+        $this->definedNames = [];
+        $this->cellXfSupervisor = new Style(true);
+        $this->cellXfSupervisor->bindParent($this);
+        $this->addCellXf(new Style());
+        $this->addCellStyleXf(new Style());
+    }
+    /**
+     * Code to execute when this worksheet is unset().
+     */
+    public function __destruct()
+    {
+        $this->disconnectWorksheets();
+        $this->calculationEngine = null;
+        $this->cellXfCollection = [];
+        $this->cellStyleXfCollection = [];
+        $this->definedNames = [];
+    }
+    /**
+     * Disconnect all worksheets from this PhpSpreadsheet workbook object,
+     * typically so that the PhpSpreadsheet object can be unset.
+     */
+    public function disconnectWorksheets(): void
+    {
+        foreach ($this->workSheetCollection as $worksheet) {
+            $worksheet->disconnectCells();
+            unset($worksheet);
+        }
+        $this->workSheetCollection = [];
+    }
+    /**
+     * Return the calculation engine for this worksheet.
+     */
+    public function getCalculationEngine(): ?Calculation
+    {
+        return $this->calculationEngine;
+    }
+    /**
+     * Get properties.
+     */
+    public function getProperties(): Properties
+    {
+        return $this->properties;
+    }
+    /**
+     * Set properties.
+     */
+    public function setProperties(Properties $documentProperties): void
+    {
+        $this->properties = $documentProperties;
+    }
+    /**
+     * Get security.
+     */
+    public function getSecurity(): Security
+    {
+        return $this->security;
+    }
+    /**
+     * Set security.
+     */
+    public function setSecurity(Security $documentSecurity): void
+    {
+        $this->security = $documentSecurity;
+    }
+    /**
+     * Get active sheet.
+     */
+    public function getActiveSheet(): Worksheet
+    {
+        return $this->getSheet($this->activeSheetIndex);
+    }
+    /**
+     * Create sheet and add it to this workbook.
+     *
+     * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
+     */
+    public function createSheet(?int $sheetIndex = null): Worksheet
+    {
+        $newSheet = new Worksheet($this);
+        $this->addSheet($newSheet, $sheetIndex);
+        return $newSheet;
+    }
+    /**
+     * Check if a sheet with a specified name already exists.
+     *
+     * @param string $worksheetName Name of the worksheet to check
+     */
+    public function sheetNameExists(string $worksheetName): bool
+    {
+        return $this->getSheetByName($worksheetName) !== null;
+    }
+    /**
+     * Add sheet.
+     *
+     * @param Worksheet $worksheet The worksheet to add
+     * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
+     */
+    public function addSheet(Worksheet $worksheet, ?int $sheetIndex = null): Worksheet
+    {
+        if ($this->sheetNameExists($worksheet->getTitle())) {
+            throw new Exception(
+                "Workbook already contains a worksheet named '{$worksheet->getTitle()}'. Rename this worksheet first."
+            );
+        }
+        if ($sheetIndex === null) {
+            if ($this->activeSheetIndex < 0) {
+                $this->activeSheetIndex = 0;
+            }
+            $this->workSheetCollection[] = $worksheet;
+        } else {
+            array_splice(
+                $this->workSheetCollection,
+                $sheetIndex,
+                0,
+                [$worksheet]
+            );
+            if ($this->activeSheetIndex >= $sheetIndex) {
+                ++$this->activeSheetIndex;
+            }
+        }
+        if ($worksheet->getParent() === null) {
+            $worksheet->rebindParent($this);
+        }
+        return $worksheet;
+    }
+    /**
+     * Remove sheet by index.
+     *
+     * @param int $sheetIndex Index position of the worksheet to remove
+     */
+    public function removeSheetByIndex(int $sheetIndex): void
+    {
+        $numSheets = count($this->workSheetCollection);
+        if ($sheetIndex > $numSheets - 1) {
+            throw new Exception(
+                "You tried to remove a sheet by the out of bounds index: {$sheetIndex}. The actual number of sheets is {$numSheets}."
+            );
+        }
+        array_splice($this->workSheetCollection, $sheetIndex, 1);
+        if (
+            ($this->activeSheetIndex >= $sheetIndex)
+            && ($this->activeSheetIndex > 0 || $numSheets <= 1)
+        ) {
+            --$this->activeSheetIndex;
+        }
+    }
+    /**
+     * Get sheet by index.
+     *
+     * @param int $sheetIndex Sheet index
+     */
+    public function getSheet(int $sheetIndex): Worksheet
+    {
+        if (!isset($this->workSheetCollection[$sheetIndex])) {
+            $numSheets = $this->getSheetCount();
+            throw new Exception(
+                "Your requested sheet index: {$sheetIndex} is out of bounds. The actual number of sheets is {$numSheets}."
+            );
+        }
+        return $this->workSheetCollection[$sheetIndex];
+    }
+    /**
+     * Get all sheets.
+     *
+     * @return Worksheet[]
+     */
+    public function getAllSheets(): array
+    {
+        return $this->workSheetCollection;
+    }
+    /**
+     * Get sheet by name.
+     *
+     * @param string $worksheetName Sheet name
+     */
+    public function getSheetByName(string $worksheetName): ?Worksheet
+    {
+        $worksheetCount = count($this->workSheetCollection);
+        for ($i = 0; $i < $worksheetCount; ++$i) {
+            if (strcasecmp($this->workSheetCollection[$i]->getTitle(), trim($worksheetName, "'")) === 0) {
+                return $this->workSheetCollection[$i];
+            }
+        }
+        return null;
+    }
+    /**
+     * Get sheet by name, throwing exception if not found.
+     */
+    public function getSheetByNameOrThrow(string $worksheetName): Worksheet
+    {
+        $worksheet = $this->getSheetByName($worksheetName);
+        if ($worksheet === null) {
+            throw new Exception("Sheet $worksheetName does not exist.");
+        }
+        return $worksheet;
+    }
+    /**
+     * Get index for sheet.
+     *
+     * @return int index
+     */
+    public function getIndex(Worksheet $worksheet): int
+    {
+        foreach ($this->workSheetCollection as $key => $value) {
+            if ($value->getHashCode() === $worksheet->getHashCode()) {
+                return $key;
+            }
+        }
+        throw new Exception('Sheet does not exist.');
+    }
+    /**
+     * Set index for sheet by sheet name.
+     *
+     * @param string $worksheetName Sheet name to modify index for
+     * @param int $newIndexPosition New index for the sheet
+     *
+     * @return int New sheet index
+     */
+    public function setIndexByName(string $worksheetName, int $newIndexPosition): int
+    {
+        $oldIndex = $this->getIndex($this->getSheetByNameOrThrow($worksheetName));
+        $worksheet = array_splice(
+            $this->workSheetCollection,
+            $oldIndex,
+            1
+        );
+        array_splice(
+            $this->workSheetCollection,
+            $newIndexPosition,
+            0,
+            $worksheet
+        );
+        return $newIndexPosition;
+    }
+    /**
+     * Get sheet count.
+     */
+    public function getSheetCount(): int
+    {
+        return count($this->workSheetCollection);
+    }
+    /**
+     * Get active sheet index.
+     *
+     * @return int Active sheet index
+     */
+    public function getActiveSheetIndex(): int
+    {
+        return $this->activeSheetIndex;
+    }
+    /**
+     * Set active sheet index.
+     *
+     * @param int $worksheetIndex Active sheet index
+     */
+    public function setActiveSheetIndex(int $worksheetIndex): Worksheet
+    {
+        $numSheets = count($this->workSheetCollection);
+        if ($worksheetIndex > $numSheets - 1) {
+            throw new Exception(
+                "You tried to set a sheet active by the out of bounds index: {$worksheetIndex}. The actual number of sheets is {$numSheets}."
+            );
+        }
+        $this->activeSheetIndex = $worksheetIndex;
+        return $this->getActiveSheet();
+    }
+    /**
+     * Set active sheet index by name.
+     *
+     * @param string $worksheetName Sheet title
+     */
+    public function setActiveSheetIndexByName(string $worksheetName): Worksheet
+    {
+        if (($worksheet = $this->getSheetByName($worksheetName)) instanceof Worksheet) {
+            $this->setActiveSheetIndex($this->getIndex($worksheet));
+            return $worksheet;
+        }
+        throw new Exception('Workbook does not contain sheet:' . $worksheetName);
+    }
+    /**
+     * Get sheet names.
+     *
+     * @return string[]
+     */
+    public function getSheetNames(): array
+    {
+        $returnValue = [];
+        $worksheetCount = $this->getSheetCount();
+        for ($i = 0; $i < $worksheetCount; ++$i) {
+            $returnValue[] = $this->getSheet($i)->getTitle();
+        }
+        return $returnValue;
+    }
+    /**
+     * Add external sheet.
+     *
+     * @param Worksheet $worksheet External sheet to add
+     * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
+     */
+    public function addExternalSheet(Worksheet $worksheet, ?int $sheetIndex = null): Worksheet
+    {
+        if ($this->sheetNameExists($worksheet->getTitle())) {
+            throw new Exception("Workbook already contains a worksheet named '{$worksheet->getTitle()}'. Rename the external sheet first.");
+        }
+        $countCellXfs = count($this->cellXfCollection);
+        foreach ($worksheet->getParentOrThrow()->getCellXfCollection() as $cellXf) {
+            $this->addCellXf(clone $cellXf);
+        }
+        $worksheet->rebindParent($this);
+        foreach ($worksheet->getCoordinates(false) as $coordinate) {
+            $cell = $worksheet->getCell($coordinate);
+            $cell->setXfIndex($cell->getXfIndex() + $countCellXfs);
+        }
+        foreach ($worksheet->getColumnDimensions() as $columnDimension) {
+            $columnDimension->setXfIndex($columnDimension->getXfIndex() + $countCellXfs);
+        }
+        foreach ($worksheet->getRowDimensions() as $rowDimension) {
+            $xfIndex = $rowDimension->getXfIndex();
+            if ($xfIndex !== null) {
+                $rowDimension->setXfIndex($xfIndex + $countCellXfs);
+            }
+        }
+        return $this->addSheet($worksheet, $sheetIndex);
+    }
+    /**
+     * Get an array of all Named Ranges.
+     *
+     * @return DefinedName[]
+     */
+    public function getNamedRanges(): array
+    {
+        return array_filter(
+            $this->definedNames,
+            fn (DefinedName $definedName): bool => $definedName->isFormula() === self::DEFINED_NAME_IS_RANGE
+        );
+    }
+    /**
+     * Get an array of all Named Formulae.
+     *
+     * @return DefinedName[]
+     */
+    public function getNamedFormulae(): array
+    {
+        return array_filter(
+            $this->definedNames,
+            fn (DefinedName $definedName): bool => $definedName->isFormula() === self::DEFINED_NAME_IS_FORMULA
+        );
+    }
+    /**
+     * Get an array of all Defined Names (both named ranges and named formulae).
+     *
+     * @return DefinedName[]
+     */
+    public function getDefinedNames(): array
+    {
+        return $this->definedNames;
+    }
+    /**
+     * Add a named range.
+     * If a named range with this name already exists, then this will replace the existing value.
+     */
+    public function addNamedRange(NamedRange $namedRange): void
+    {
+        $this->addDefinedName($namedRange);
+    }
+    /**
+     * Add a named formula.
+     * If a named formula with this name already exists, then this will replace the existing value.
+     */
+    public function addNamedFormula(NamedFormula $namedFormula): void
+    {
+        $this->addDefinedName($namedFormula);
+    }
+    /**
+     * Add a defined name (either a named range or a named formula).
+     * If a defined named with this name already exists, then this will replace the existing value.
+     */
+    public function addDefinedName(DefinedName $definedName): void
+    {
+        $upperCaseName = StringHelper::strToUpper($definedName->getName());
+        if ($definedName->getScope() == null) {
+            $this->definedNames[$upperCaseName] = $definedName;
+        } else {
+            $this->definedNames[$definedName->getScope()->getTitle() . '!' . $upperCaseName] = $definedName;
+        }
+    }
+    /**
+     * Get named range.
+     *
+     * @param null|Worksheet $worksheet Scope. Use null for global scope
+     */
+    public function getNamedRange(string $namedRange, ?Worksheet $worksheet = null): ?NamedRange
+    {
+        $returnValue = null;
+        if ($namedRange !== '') {
+            $namedRange = StringHelper::strToUpper($namedRange);
+            $returnValue = $this->getGlobalDefinedNameByType($namedRange, self::DEFINED_NAME_IS_RANGE);
+            $returnValue = $this->getLocalDefinedNameByType($namedRange, self::DEFINED_NAME_IS_RANGE, $worksheet) ?: $returnValue;
+        }
+        return $returnValue instanceof NamedRange ? $returnValue : null;
+    }
+    /**
+     * Get named formula.
+     *
+     * @param null|Worksheet $worksheet Scope. Use null for global scope
+     */
+    public function getNamedFormula(string $namedFormula, ?Worksheet $worksheet = null): ?NamedFormula
+    {
+        $returnValue = null;
+        if ($namedFormula !== '') {
+            $namedFormula = StringHelper::strToUpper($namedFormula);
+            $returnValue = $this->getGlobalDefinedNameByType($namedFormula, self::DEFINED_NAME_IS_FORMULA);
+            $returnValue = $this->getLocalDefinedNameByType($namedFormula, self::DEFINED_NAME_IS_FORMULA, $worksheet) ?: $returnValue;
+        }
+        return $returnValue instanceof NamedFormula ? $returnValue : null;
+    }
+    private function getGlobalDefinedNameByType(string $name, bool $type): ?DefinedName
+    {
+        if (isset($this->definedNames[$name]) && $this->definedNames[$name]->isFormula() === $type) {
+            return $this->definedNames[$name];
+        }
+        return null;
+    }
+    private function getLocalDefinedNameByType(string $name, bool $type, ?Worksheet $worksheet = null): ?DefinedName
+    {
+        if (
+            ($worksheet !== null) && isset($this->definedNames[$worksheet->getTitle() . '!' . $name])
+            && $this->definedNames[$worksheet->getTitle() . '!' . $name]->isFormula() === $type
+        ) {
+            return $this->definedNames[$worksheet->getTitle() . '!' . $name];
+        }
+        return null;
+    }
+    /**
+     * Get named range.
+     *
+     * @param null|Worksheet $worksheet Scope. Use null for global scope
+     */
+    public function getDefinedName(string $definedName, ?Worksheet $worksheet = null): ?DefinedName
+    {
+        $returnValue = null;
+        if ($definedName !== '') {
+            $definedName = StringHelper::strToUpper($definedName);
+            if (isset($this->definedNames[$definedName])) {
+                $returnValue = $this->definedNames[$definedName];
+            }
+            if (($worksheet !== null) && isset($this->definedNames[$worksheet->getTitle() . '!' . $definedName])) {
+                $returnValue = $this->definedNames[$worksheet->getTitle() . '!' . $definedName];
+            }
+        }
+        return $returnValue;
+    }
+    /**
+     * Remove named range.
+     *
+     * @param null|Worksheet $worksheet scope: use null for global scope
+     *
+     * @return $this
+     */
+    public function removeNamedRange(string $namedRange, ?Worksheet $worksheet = null): self
+    {
+        if ($this->getNamedRange($namedRange, $worksheet) === null) {
+            return $this;
+        }
+        return $this->removeDefinedName($namedRange, $worksheet);
+    }
+    /**
+     * Remove named formula.
+     *
+     * @param null|Worksheet $worksheet scope: use null for global scope
+     *
+     * @return $this
+     */
+    public function removeNamedFormula(string $namedFormula, ?Worksheet $worksheet = null): self
+    {
+        if ($this->getNamedFormula($namedFormula, $worksheet) === null) {
+            return $this;
+        }
+        return $this->removeDefinedName($namedFormula, $worksheet);
+    }
+    /**
+     * Remove defined name.
+     *
+     * @param null|Worksheet $worksheet scope: use null for global scope
+     *
+     * @return $this
+     */
+    public function removeDefinedName(string $definedName, ?Worksheet $worksheet = null): self
+    {
+        $definedName = StringHelper::strToUpper($definedName);
+        if ($worksheet === null) {
+            if (isset($this->definedNames[$definedName])) {
+                unset($this->definedNames[$definedName]);
+            }
+        } else {
+            if (isset($this->definedNames[$worksheet->getTitle() . '!' . $definedName])) {
+                unset($this->definedNames[$worksheet->getTitle() . '!' . $definedName]);
+            } elseif (isset($this->definedNames[$definedName])) {
+                unset($this->definedNames[$definedName]);
+            }
+        }
+        return $this;
+    }
+    /**
+     * Get worksheet iterator.
+     */
+    public function getWorksheetIterator(): Iterator
+    {
+        return new Iterator($this);
+    }
+    /**
+     * Copy workbook (!= clone!).
+     */
+    public function copy(): self
+    {
+        $filename = File::temporaryFilename();
+        $writer = new XlsxWriter($this);
+        $writer->setIncludeCharts(true);
+        $writer->save($filename);
+        $reader = new XlsxReader();
+        $reader->setIncludeCharts(true);
+        $reloadedSpreadsheet = $reader->load($filename);
+        unlink($filename);
+        return $reloadedSpreadsheet;
+    }
+    public function __clone()
+    {
+        throw new Exception(
+            'Do not use clone on spreadsheet. Use spreadsheet->copy() instead.'
+        );
+    }
+    /**
+     * Get the workbook collection of cellXfs.
+     *
+     * @return Style[]
+     */
+    public function getCellXfCollection(): array
+    {
+        return $this->cellXfCollection;
+    }
+    /**
+     * Get cellXf by index.
+     */
+    public function getCellXfByIndex(int $cellStyleIndex): Style
+    {
+        return $this->cellXfCollection[$cellStyleIndex];
+    }
+    /**
+     * Get cellXf by hash code.
+     *
+     * @return false|Style
+     */
+    public function getCellXfByHashCode(string $hashcode): bool|Style
+    {
+        foreach ($this->cellXfCollection as $cellXf) {
+            if ($cellXf->getHashCode() === $hashcode) {
+                return $cellXf;
+            }
+        }
+        return false;
+    }
+    /**
+     * Check if style exists in style collection.
+     */
+    public function cellXfExists(Style $cellStyleIndex): bool
+    {
+        return in_array($cellStyleIndex, $this->cellXfCollection, true);
+    }
+    /**
+     * Get default style.
+     */
+    public function getDefaultStyle(): Style
+    {
+        if (isset($this->cellXfCollection[0])) {
+            return $this->cellXfCollection[0];
+        }
+        throw new Exception('No default style found for this workbook');
+    }
+    /**
+     * Add a cellXf to the workbook.
+     */
+    public function addCellXf(Style $style): void
+    {
+        $this->cellXfCollection[] = $style;
+        $style->setIndex(count($this->cellXfCollection) - 1);
+    }
+    /**
+     * Remove cellXf by index. It is ensured that all cells get their xf index updated.
+     *
+     * @param int $cellStyleIndex Index to cellXf
+     */
+    public function removeCellXfByIndex(int $cellStyleIndex): void
+    {
+        if ($cellStyleIndex > count($this->cellXfCollection) - 1) {
+            throw new Exception('CellXf index is out of bounds.');
+        }
+        array_splice($this->cellXfCollection, $cellStyleIndex, 1);
+        foreach ($this->workSheetCollection as $worksheet) {
+            foreach ($worksheet->getCoordinates(false) as $coordinate) {
+                $cell = $worksheet->getCell($coordinate);
+                $xfIndex = $cell->getXfIndex();
+                if ($xfIndex > $cellStyleIndex) {
+                    $cell->setXfIndex($xfIndex - 1);
+                } elseif ($xfIndex == $cellStyleIndex) {
+                    $cell->setXfIndex(0);
+                }
+            }
+        }
+    }
+    /**
+     * Get the cellXf supervisor.
+     */
+    public function getCellXfSupervisor(): Style
+    {
+        return $this->cellXfSupervisor;
+    }
+    /**
+     * Get the workbook collection of cellStyleXfs.
+     *
+     * @return Style[]
+     */
+    public function getCellStyleXfCollection(): array
+    {
+        return $this->cellStyleXfCollection;
+    }
+    /**
+     * Get cellStyleXf by index.
+     *
+     * @param int $cellStyleIndex Index to cellXf
+     */
+    public function getCellStyleXfByIndex(int $cellStyleIndex): Style
+    {
+        return $this->cellStyleXfCollection[$cellStyleIndex];
+    }
+    /**
+     * Get cellStyleXf by hash code.
+     *
+     * @return false|Style
+     */
+    public function getCellStyleXfByHashCode(string $hashcode): bool|Style
+    {
+        foreach ($this->cellStyleXfCollection as $cellStyleXf) {
+            if ($cellStyleXf->getHashCode() === $hashcode) {
+                return $cellStyleXf;
+            }
+        }
+        return false;
+    }
+    /**
+     * Add a cellStyleXf to the workbook.
+     */
+    public function addCellStyleXf(Style $style): void
+    {
+        $this->cellStyleXfCollection[] = $style;
+        $style->setIndex(count($this->cellStyleXfCollection) - 1);
+    }
+    /**
+     * Remove cellStyleXf by index.
+     *
+     * @param int $cellStyleIndex Index to cellXf
+     */
+    public function removeCellStyleXfByIndex(int $cellStyleIndex): void
+    {
+        if ($cellStyleIndex > count($this->cellStyleXfCollection) - 1) {
+            throw new Exception('CellStyleXf index is out of bounds.');
+        }
+        array_splice($this->cellStyleXfCollection, $cellStyleIndex, 1);
+    }
+    /**
+     * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells
+     * and columns in the workbook.
+     */
+    public function garbageCollect(): void
+    {
+        $countReferencesCellXf = [];
+        foreach ($this->cellXfCollection as $index => $cellXf) {
+            $countReferencesCellXf[$index] = 0;
+        }
+        foreach ($this->getWorksheetIterator() as $sheet) {
+            foreach ($sheet->getCoordinates(false) as $coordinate) {
+                $cell = $sheet->getCell($coordinate);
+                ++$countReferencesCellXf[$cell->getXfIndex()];
+            }
+            foreach ($sheet->getRowDimensions() as $rowDimension) {
+                if ($rowDimension->getXfIndex() !== null) {
+                    ++$countReferencesCellXf[$rowDimension->getXfIndex()];
+                }
+            }
+            foreach ($sheet->getColumnDimensions() as $columnDimension) {
+                ++$countReferencesCellXf[$columnDimension->getXfIndex()];
+            }
+        }
+        $countNeededCellXfs = 0;
+        $map = [];
+        foreach ($this->cellXfCollection as $index => $cellXf) {
+            if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf
+                ++$countNeededCellXfs;
+            } else {
+                unset($this->cellXfCollection[$index]);
+            }
+            $map[$index] = $countNeededCellXfs - 1;
+        }
+        $this->cellXfCollection = array_values($this->cellXfCollection);
+        foreach ($this->cellXfCollection as $i => $cellXf) {
+            $cellXf->setIndex($i);
+        }
+        if (empty($this->cellXfCollection)) {
+            $this->cellXfCollection[] = new Style();
+        }
+        foreach ($this->getWorksheetIterator() as $sheet) {
+            foreach ($sheet->getCoordinates(false) as $coordinate) {
+                $cell = $sheet->getCell($coordinate);
+                $cell->setXfIndex($map[$cell->getXfIndex()]);
+            }
+            foreach ($sheet->getRowDimensions() as $rowDimension) {
+                if ($rowDimension->getXfIndex() !== null) {
+                    $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);
+                }
+            }
+            foreach ($sheet->getColumnDimensions() as $columnDimension) {
+                $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);
+            }
+            $sheet->garbageCollect();
+        }
+    }
+    /**
+     * Return the unique ID value assigned to this spreadsheet workbook.
+     */
+    public function getID(): string
+    {
+        return $this->uniqueID;
+    }
+    /**
+     * Get the visibility of the horizonal scroll bar in the application.
+     *
+     * @return bool True if horizonal scroll bar is visible
+     */
+    public function getShowHorizontalScroll(): bool
+    {
+        return $this->showHorizontalScroll;
+    }
+    /**
+     * Set the visibility of the horizonal scroll bar in the application.
+     *
+     * @param bool $showHorizontalScroll True if horizonal scroll bar is visible
+     */
+    public function setShowHorizontalScroll(bool $showHorizontalScroll): void
+    {
+        $this->showHorizontalScroll = (bool) $showHorizontalScroll;
+    }
+    /**
+     * Get the visibility of the vertical scroll bar in the application.
+     *
+     * @return bool True if vertical scroll bar is visible
+     */
+    public function getShowVerticalScroll(): bool
+    {
+        return $this->showVerticalScroll;
+    }
+    /**
+     * Set the visibility of the vertical scroll bar in the application.
+     *
+     * @param bool $showVerticalScroll True if vertical scroll bar is visible
+     */
+    public function setShowVerticalScroll(bool $showVerticalScroll): void
+    {
+        $this->showVerticalScroll = (bool) $showVerticalScroll;
+    }
+    /**
+     * Get the visibility of the sheet tabs in the application.
+     *
+     * @return bool True if the sheet tabs are visible
+     */
+    public function getShowSheetTabs(): bool
+    {
+        return $this->showSheetTabs;
+    }
+    /**
+     * Set the visibility of the sheet tabs  in the application.
+     *
+     * @param bool $showSheetTabs True if sheet tabs are visible
+     */
+    public function setShowSheetTabs(bool $showSheetTabs): void
+    {
+        $this->showSheetTabs = (bool) $showSheetTabs;
+    }
+    /**
+     * Return whether the workbook window is minimized.
+     *
+     * @return bool true if workbook window is minimized
+     */
+    public function getMinimized(): bool
+    {
+        return $this->minimized;
+    }
+    /**
+     * Set whether the workbook window is minimized.
+     *
+     * @param bool $minimized true if workbook window is minimized
+     */
+    public function setMinimized(bool $minimized): void
+    {
+        $this->minimized = (bool) $minimized;
+    }
+    /**
+     * Return whether to group dates when presenting the user with
+     * filtering optiomd in the user interface.
+     *
+     * @return bool true if workbook window is minimized
+     */
+    public function getAutoFilterDateGrouping(): bool
+    {
+        return $this->autoFilterDateGrouping;
+    }
+    /**
+     * Set whether to group dates when presenting the user with
+     * filtering optiomd in the user interface.
+     *
+     * @param bool $autoFilterDateGrouping true if workbook window is minimized
+     */
+    public function setAutoFilterDateGrouping(bool $autoFilterDateGrouping): void
+    {
+        $this->autoFilterDateGrouping = (bool) $autoFilterDateGrouping;
+    }
+    /**
+     * Return the first sheet in the book view.
+     *
+     * @return int First sheet in book view
+     */
+    public function getFirstSheetIndex(): int
+    {
+        return $this->firstSheetIndex;
+    }
+    /**
+     * Set the first sheet in the book view.
+     *
+     * @param int $firstSheetIndex First sheet in book view
+     */
+    public function setFirstSheetIndex(int $firstSheetIndex): void
+    {
+        if ($firstSheetIndex >= 0) {
+            $this->firstSheetIndex = (int) $firstSheetIndex;
+        } else {
+            throw new Exception('First sheet index must be a positive integer.');
+        }
+    }
+    /**
+     * Return the visibility status of the workbook.
+     *
+     * This may be one of the following three values:
+     * - visibile
+     *
+     * @return string Visible status
+     */
+    public function getVisibility(): string
+    {
+        return $this->visibility;
+    }
+    /**
+     * Set the visibility status of the workbook.
+     *
+     * Valid values are:
+     *  - 'visible' (self::VISIBILITY_VISIBLE):
+     *       Workbook window is visible
+     *  - 'hidden' (self::VISIBILITY_HIDDEN):
+     *       Workbook window is hidden, but can be shown by the user
+     *       via the user interface
+     *  - 'veryHidden' (self::VISIBILITY_VERY_HIDDEN):
+     *       Workbook window is hidden and cannot be shown in the
+     *       user interface.
+     *
+     * @param null|string $visibility visibility status of the workbook
+     */
+    public function setVisibility(?string $visibility): void
+    {
+        if ($visibility === null) {
+            $visibility = self::VISIBILITY_VISIBLE;
+        }
+        if (in_array($visibility, self::WORKBOOK_VIEW_VISIBILITY_VALUES)) {
+            $this->visibility = $visibility;
+        } else {
+            throw new Exception('Invalid visibility value.');
+        }
+    }
+    /**
+     * Get the ratio between the workbook tabs bar and the horizontal scroll bar.
+     * TabRatio is assumed to be out of 1000 of the horizontal window width.
+     *
+     * @return int Ratio between the workbook tabs bar and the horizontal scroll bar
+     */
+    public function getTabRatio(): int
+    {
+        return $this->tabRatio;
+    }
+    /**
+     * Set the ratio between the workbook tabs bar and the horizontal scroll bar
+     * TabRatio is assumed to be out of 1000 of the horizontal window width.
+     *
+     * @param int $tabRatio Ratio between the tabs bar and the horizontal scroll bar
+     */
+    public function setTabRatio(int $tabRatio): void
+    {
+        if ($tabRatio >= 0 && $tabRatio <= 1000) {
+            $this->tabRatio = (int) $tabRatio;
+        } else {
+            throw new Exception('Tab ratio must be between 0 and 1000.');
+        }
+    }
+    public function reevaluateAutoFilters(bool $resetToMax): void
+    {
+        foreach ($this->workSheetCollection as $sheet) {
+            $filter = $sheet->getAutoFilter();
+            if (!empty($filter->getRange())) {
+                if ($resetToMax) {
+                    $filter->setRangeToMaxRow();
+                }
+                $filter->showHideRows();
+            }
+        }
+    }
+    /**
+     * @throws Exception
+     */
+    public function __serialize(): array
+    {
+        throw new Exception('Spreadsheet objects cannot be serialized');
+    }
+    /**
+     * @throws Exception
+     */
+    public function jsonSerialize(): mixed
+    {
+        throw new Exception('Spreadsheet objects cannot be json encoded');
+    }
+    public function resetThemeFonts(): void
+    {
+        $majorFontLatin = $this->theme->getMajorFontLatin();
+        $minorFontLatin = $this->theme->getMinorFontLatin();
+        foreach ($this->cellXfCollection as $cellStyleXf) {
+            $scheme = $cellStyleXf->getFont()->getScheme();
+            if ($scheme === 'major') {
+                $cellStyleXf->getFont()->setName($majorFontLatin)->setScheme($scheme);
+            } elseif ($scheme === 'minor') {
+                $cellStyleXf->getFont()->setName($minorFontLatin)->setScheme($scheme);
+            }
+        }
+        foreach ($this->cellStyleXfCollection as $cellStyleXf) {
+            $scheme = $cellStyleXf->getFont()->getScheme();
+            if ($scheme === 'major') {
+                $cellStyleXf->getFont()->setName($majorFontLatin)->setScheme($scheme);
+            } elseif ($scheme === 'minor') {
+                $cellStyleXf->getFont()->setName($minorFontLatin)->setScheme($scheme);
+            }
+        }
+    }
+    public function getTableByName(string $tableName): ?Table
+    {
+        $table = null;
+        foreach ($this->workSheetCollection as $sheet) {
+            $table = $sheet->getTableByName($tableName);
+            if ($table !== null) {
+                break;
+            }
+        }
+        return $table;
+    }
+    /**
+     * @return bool Success or failure
+     */
+    public function setExcelCalendar(int $baseYear): bool
+    {
+        if (($baseYear === Date::CALENDAR_WINDOWS_1900) || ($baseYear === Date::CALENDAR_MAC_1904)) {
+            $this->excelCalendar = $baseYear;
+            return true;
+        }
+        return false;
+    }
+    /**
+     * @return int Excel base date (1900 or 1904)
+     */
+    public function getExcelCalendar(): int
+    {
+        return $this->excelCalendar;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/ConditionalFormatting/CellMatcher.php
@@ -0,0 +1,206 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+class CellMatcher
+{
+    public const COMPARISON_OPERATORS = [
+        Conditional::OPERATOR_EQUAL => '=',
+        Conditional::OPERATOR_GREATERTHAN => '>',
+        Conditional::OPERATOR_GREATERTHANOREQUAL => '>=',
+        Conditional::OPERATOR_LESSTHAN => '<',
+        Conditional::OPERATOR_LESSTHANOREQUAL => '<=',
+        Conditional::OPERATOR_NOTEQUAL => '<>',
+    ];
+    public const COMPARISON_RANGE_OPERATORS = [
+        Conditional::OPERATOR_BETWEEN => 'IF(AND(A1>=%s,A1<=%s),TRUE,FALSE)',
+        Conditional::OPERATOR_NOTBETWEEN => 'IF(AND(A1>=%s,A1<=%s),FALSE,TRUE)',
+    ];
+    public const COMPARISON_DUPLICATES_OPERATORS = [
+        Conditional::CONDITION_DUPLICATES => "COUNTIF('%s'!%s,%s)>1",
+        Conditional::CONDITION_UNIQUE => "COUNTIF('%s'!%s,%s)=1",
+    ];
+    protected Cell $cell;
+    protected int $cellRow;
+    protected Worksheet $worksheet;
+    protected int $cellColumn;
+    protected string $conditionalRange;
+    protected string $referenceCell;
+    protected int $referenceRow;
+    protected int $referenceColumn;
+    protected Calculation $engine;
+    public function __construct(Cell $cell, string $conditionalRange)
+    {
+        $this->cell = $cell;
+        $this->worksheet = $cell->getWorksheet();
+        [$this->cellColumn, $this->cellRow] = Coordinate::indexesFromString($this->cell->getCoordinate());
+        $this->setReferenceCellForExpressions($conditionalRange);
+        $this->engine = Calculation::getInstance($this->worksheet->getParent());
+    }
+    protected function setReferenceCellForExpressions(string $conditionalRange): void
+    {
+        $conditionalRange = Coordinate::splitRange(str_replace('$', '', strtoupper($conditionalRange)));
+        [$this->referenceCell] = $conditionalRange[0];
+        [$this->referenceColumn, $this->referenceRow] = Coordinate::indexesFromString($this->referenceCell);
+        $rangeSets = [];
+        foreach ($conditionalRange as $rangeSet) {
+            $absoluteRangeSet = array_map(
+                [Coordinate::class, 'absoluteCoordinate'],
+                $rangeSet
+            );
+            $rangeSets[] = implode(':', $absoluteRangeSet);
+        }
+        $this->conditionalRange = implode(',', $rangeSets);
+    }
+    public function evaluateConditional(Conditional $conditional): bool
+    {
+        $cellColumn = Coordinate::stringFromColumnIndex($this->cellColumn);
+        $cellAddress = "{$cellColumn}{$this->cellRow}";
+        $this->cell = $this->worksheet->getCell($cellAddress);
+        return match ($conditional->getConditionType()) {
+            Conditional::CONDITION_CELLIS => $this->processOperatorComparison($conditional),
+            Conditional::CONDITION_DUPLICATES, Conditional::CONDITION_UNIQUE => $this->processDuplicatesComparison($conditional),
+            Conditional::CONDITION_CONTAINSTEXT,
+            Conditional::CONDITION_NOTCONTAINSTEXT,
+            Conditional::CONDITION_BEGINSWITH,
+            Conditional::CONDITION_ENDSWITH,
+            Conditional::CONDITION_CONTAINSBLANKS,
+            Conditional::CONDITION_NOTCONTAINSBLANKS,
+            Conditional::CONDITION_CONTAINSERRORS,
+            Conditional::CONDITION_NOTCONTAINSERRORS,
+            Conditional::CONDITION_TIMEPERIOD,
+            Conditional::CONDITION_EXPRESSION => $this->processExpression($conditional),
+            default => false,
+        };
+    }
+    protected function wrapValue(mixed $value): float|int|string
+    {
+        if (!is_numeric($value)) {
+            if (is_bool($value)) {
+                return $value ? 'TRUE' : 'FALSE';
+            } elseif ($value === null) {
+                return 'NULL';
+            }
+            return '"' . $value . '"';
+        }
+        return $value;
+    }
+    protected function wrapCellValue(): float|int|string
+    {
+        return $this->wrapValue($this->cell->getCalculatedValue());
+    }
+    protected function conditionCellAdjustment(array $matches): float|int|string
+    {
+        $column = $matches[6];
+        $row = $matches[7];
+        if (!str_contains($column, '$')) {
+            $column = Coordinate::columnIndexFromString($column);
+            $column += $this->cellColumn - $this->referenceColumn;
+            $column = Coordinate::stringFromColumnIndex($column);
+        }
+        if (!str_contains($row, '$')) {
+            $row += $this->cellRow - $this->referenceRow;
+        }
+        if (!empty($matches[4])) {
+            $worksheet = $this->worksheet->getParentOrThrow()->getSheetByName(trim($matches[4], "'"));
+            if ($worksheet === null) {
+                return $this->wrapValue(null);
+            }
+            return $this->wrapValue(
+                $worksheet
+                    ->getCell(str_replace('$', '', "{$column}{$row}"))
+                    ->getCalculatedValue()
+            );
+        }
+        return $this->wrapValue(
+            $this->worksheet
+                ->getCell(str_replace('$', '', "{$column}{$row}"))
+                ->getCalculatedValue()
+        );
+    }
+    protected function cellConditionCheck(string $condition): string
+    {
+        $splitCondition = explode(Calculation::FORMULA_STRING_QUOTE, $condition);
+        $i = false;
+        foreach ($splitCondition as &$value) {
+            $i = $i === false;
+            if ($i) {
+                $value = (string) preg_replace_callback(
+                    '/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i',
+                    [$this, 'conditionCellAdjustment'],
+                    $value
+                );
+            }
+        }
+        unset($value);
+        return implode(Calculation::FORMULA_STRING_QUOTE, $splitCondition);
+    }
+    protected function adjustConditionsForCellReferences(array $conditions): array
+    {
+        return array_map(
+            [$this, 'cellConditionCheck'],
+            $conditions
+        );
+    }
+    protected function processOperatorComparison(Conditional $conditional): bool
+    {
+        if (array_key_exists($conditional->getOperatorType(), self::COMPARISON_RANGE_OPERATORS)) {
+            return $this->processRangeOperator($conditional);
+        }
+        $operator = self::COMPARISON_OPERATORS[$conditional->getOperatorType()];
+        $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
+        $expression = sprintf('%s%s%s', (string) $this->wrapCellValue(), $operator, (string) array_pop($conditions));
+        return $this->evaluateExpression($expression);
+    }
+    protected function processRangeOperator(Conditional $conditional): bool
+    {
+        $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
+        sort($conditions);
+        $expression = sprintf(
+            (string) preg_replace(
+                '/\bA1\b/i',
+                (string) $this->wrapCellValue(),
+                self::COMPARISON_RANGE_OPERATORS[$conditional->getOperatorType()]
+            ),
+            ...$conditions
+        );
+        return $this->evaluateExpression($expression);
+    }
+    protected function processDuplicatesComparison(Conditional $conditional): bool
+    {
+        $worksheetName = $this->cell->getWorksheet()->getTitle();
+        $expression = sprintf(
+            self::COMPARISON_DUPLICATES_OPERATORS[$conditional->getConditionType()],
+            $worksheetName,
+            $this->conditionalRange,
+            $this->cellConditionCheck($this->cell->getCalculatedValueString())
+        );
+        return $this->evaluateExpression($expression);
+    }
+    protected function processExpression(Conditional $conditional): bool
+    {
+        $conditions = $this->adjustConditionsForCellReferences($conditional->getConditions());
+        $expression = array_pop($conditions);
+        $expression = (string) preg_replace(
+            '/\b' . $this->referenceCell . '\b/i',
+            (string) $this->wrapCellValue(),
+            $expression
+        );
+        return $this->evaluateExpression($expression);
+    }
+    protected function evaluateExpression(string $expression): bool
+    {
+        $expression = "={$expression}";
+        try {
+            $this->engine->flushInstance();
+            $result = (bool) $this->engine->calculateFormula($expression);
+        } catch (Exception) {
+            return false;
+        }
+        return $result;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/CellValue.php
@@ -0,0 +1,152 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\CellMatcher;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+/**
+ * @method CellValue equals($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue notEquals($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue greaterThan($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue greaterThanOrEqual($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue lessThan($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue lessThanOrEqual($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue between($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue notBetween($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method CellValue and($value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ */
+class CellValue extends WizardAbstract implements WizardInterface
+{
+    protected const MAGIC_OPERATIONS = [
+        'equals' => Conditional::OPERATOR_EQUAL,
+        'notEquals' => Conditional::OPERATOR_NOTEQUAL,
+        'greaterThan' => Conditional::OPERATOR_GREATERTHAN,
+        'greaterThanOrEqual' => Conditional::OPERATOR_GREATERTHANOREQUAL,
+        'lessThan' => Conditional::OPERATOR_LESSTHAN,
+        'lessThanOrEqual' => Conditional::OPERATOR_LESSTHANOREQUAL,
+        'between' => Conditional::OPERATOR_BETWEEN,
+        'notBetween' => Conditional::OPERATOR_NOTBETWEEN,
+    ];
+    protected const SINGLE_OPERATORS = CellMatcher::COMPARISON_OPERATORS;
+    protected const RANGE_OPERATORS = CellMatcher::COMPARISON_RANGE_OPERATORS;
+    protected string $operator = Conditional::OPERATOR_EQUAL;
+    protected array $operand = [0];
+    /**
+     * @var string[]
+     */
+    protected array $operandValueType = [];
+    public function __construct(string $cellRange)
+    {
+        parent::__construct($cellRange);
+    }
+    protected function operator(string $operator): void
+    {
+        if ((!isset(self::SINGLE_OPERATORS[$operator])) && (!isset(self::RANGE_OPERATORS[$operator]))) {
+            throw new Exception('Invalid Operator for Cell Value CF Rule Wizard');
+        }
+        $this->operator = $operator;
+    }
+    protected function operand(int $index, mixed $operand, string $operandValueType = Wizard::VALUE_TYPE_LITERAL): void
+    {
+        if (is_string($operand)) {
+            $operand = $this->validateOperand($operand, $operandValueType);
+        }
+        $this->operand[$index] = $operand;
+        $this->operandValueType[$index] = $operandValueType;
+    }
+    /** @param null|bool|float|int|string $value value to be wrapped */
+    protected function wrapValue(mixed $value, string $operandValueType): float|int|string
+    {
+        if (!is_numeric($value) && !is_bool($value) && null !== $value) {
+            if ($operandValueType === Wizard::VALUE_TYPE_LITERAL) {
+                return '"' . str_replace('"', '""', $value) . '"';
+            }
+            return $this->cellConditionCheck($value);
+        }
+        if (null === $value) {
+            $value = 'NULL';
+        } elseif (is_bool($value)) {
+            $value = $value ? 'TRUE' : 'FALSE';
+        }
+        return $value;
+    }
+    public function getConditional(): Conditional
+    {
+        if (!isset(self::RANGE_OPERATORS[$this->operator])) {
+            unset($this->operand[1], $this->operandValueType[1]);
+        }
+        $values = array_map([$this, 'wrapValue'], $this->operand, $this->operandValueType);
+        $conditional = new Conditional();
+        $conditional->setConditionType(Conditional::CONDITION_CELLIS);
+        $conditional->setOperatorType($this->operator);
+        $conditional->setConditions($values);
+        $conditional->setStyle($this->getStyle());
+        $conditional->setStopIfTrue($this->getStopIfTrue());
+        return $conditional;
+    }
+    protected static function unwrapString(string $condition): string
+    {
+        if ((str_starts_with($condition, '"')) && (str_starts_with(strrev($condition), '"'))) {
+            $condition = substr($condition, 1, -1);
+        }
+        return str_replace('""', '"', $condition);
+    }
+    public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
+    {
+        if ($conditional->getConditionType() !== Conditional::CONDITION_CELLIS) {
+            throw new Exception('Conditional is not a Cell Value CF Rule conditional');
+        }
+        $wizard = new self($cellRange);
+        $wizard->style = $conditional->getStyle();
+        $wizard->stopIfTrue = $conditional->getStopIfTrue();
+        $wizard->operator = $conditional->getOperatorType();
+        $conditions = $conditional->getConditions();
+        foreach ($conditions as $index => $condition) {
+            $operandValueType = Wizard::VALUE_TYPE_LITERAL;
+            if (is_string($condition)) {
+                if (Calculation::keyInExcelConstants($condition)) {
+                    $condition = Calculation::getExcelConstants($condition);
+                } elseif (preg_match('/^' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '$/i', $condition)) {
+                    $operandValueType = Wizard::VALUE_TYPE_CELL;
+                    $condition = self::reverseAdjustCellRef($condition, $cellRange);
+                } elseif (
+                    preg_match('/\(\)/', $condition)
+                    || preg_match('/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i', $condition)
+                ) {
+                    $operandValueType = Wizard::VALUE_TYPE_FORMULA;
+                    $condition = self::reverseAdjustCellRef($condition, $cellRange);
+                } else {
+                    $condition = self::unwrapString($condition);
+                }
+            }
+            $wizard->operand($index, $condition, $operandValueType);
+        }
+        return $wizard;
+    }
+    /**
+     * @param mixed[] $arguments
+     */
+    public function __call(string $methodName, array $arguments): self
+    {
+        if (!isset(self::MAGIC_OPERATIONS[$methodName]) && $methodName !== 'and') {
+            throw new Exception('Invalid Operator for Cell Value CF Rule Wizard');
+        }
+        if ($methodName === 'and') {
+            if (!isset(self::RANGE_OPERATORS[$this->operator])) {
+                throw new Exception('AND Value is only appropriate for range operators');
+            }
+            $this->operand(1, ...$arguments);
+            return $this;
+        }
+        $this->operator(self::MAGIC_OPERATIONS[$methodName]);
+        if (count($arguments) < 2) {
+            $this->operand(0, $arguments[0]);
+        } else {
+            /** @var string */
+            $arg1 = $arguments[1];
+            $this->operand(0, $arguments[0], $arg1);
+        }
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/Expression.php
@@ -0,0 +1,54 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+/**
+ * @method Expression formula(string $expression)
+ */
+class Expression extends WizardAbstract implements WizardInterface
+{
+    protected string $expression;
+    public function __construct(string $cellRange)
+    {
+        parent::__construct($cellRange);
+    }
+    public function expression(string $expression): self
+    {
+        $expression = $this->validateOperand($expression, Wizard::VALUE_TYPE_FORMULA);
+        $this->expression = $expression;
+        return $this;
+    }
+    public function getConditional(): Conditional
+    {
+        $expression = $this->adjustConditionsForCellReferences([$this->expression]);
+        $conditional = new Conditional();
+        $conditional->setConditionType(Conditional::CONDITION_EXPRESSION);
+        $conditional->setConditions($expression);
+        $conditional->setStyle($this->getStyle());
+        $conditional->setStopIfTrue($this->getStopIfTrue());
+        return $conditional;
+    }
+    public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
+    {
+        if ($conditional->getConditionType() !== Conditional::CONDITION_EXPRESSION) {
+            throw new Exception('Conditional is not an Expression CF Rule conditional');
+        }
+        $wizard = new self($cellRange);
+        $wizard->style = $conditional->getStyle();
+        $wizard->stopIfTrue = $conditional->getStopIfTrue();
+        $wizard->expression = self::reverseAdjustCellRef((string) ($conditional->getConditions()[0]), $cellRange);
+        return $wizard;
+    }
+    /**
+     * @param string[] $arguments
+     */
+    public function __call(string $methodName, array $arguments): self
+    {
+        if ($methodName !== 'formula') {
+            throw new Exception('Invalid Operation for Expression CF Rule Wizard');
+        }
+        $this->expression(...$arguments);
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/ConditionalFormatting/Wizard/TextValue.php
@@ -0,0 +1,136 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+/**
+ * @method TextValue contains(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method TextValue doesNotContain(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method TextValue doesntContain(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method TextValue beginsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method TextValue startsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ * @method TextValue endsWith(string $value, string $operandValueType = Wizard::VALUE_TYPE_LITERAL)
+ */
+class TextValue extends WizardAbstract implements WizardInterface
+{
+    protected const MAGIC_OPERATIONS = [
+        'contains' => Conditional::OPERATOR_CONTAINSTEXT,
+        'doesntContain' => Conditional::OPERATOR_NOTCONTAINS,
+        'doesNotContain' => Conditional::OPERATOR_NOTCONTAINS,
+        'beginsWith' => Conditional::OPERATOR_BEGINSWITH,
+        'startsWith' => Conditional::OPERATOR_BEGINSWITH,
+        'endsWith' => Conditional::OPERATOR_ENDSWITH,
+    ];
+    protected const OPERATORS = [
+        Conditional::OPERATOR_CONTAINSTEXT => Conditional::CONDITION_CONTAINSTEXT,
+        Conditional::OPERATOR_NOTCONTAINS => Conditional::CONDITION_NOTCONTAINSTEXT,
+        Conditional::OPERATOR_BEGINSWITH => Conditional::CONDITION_BEGINSWITH,
+        Conditional::OPERATOR_ENDSWITH => Conditional::CONDITION_ENDSWITH,
+    ];
+    protected const EXPRESSIONS = [
+        Conditional::OPERATOR_CONTAINSTEXT => 'NOT(ISERROR(SEARCH(%s,%s)))',
+        Conditional::OPERATOR_NOTCONTAINS => 'ISERROR(SEARCH(%s,%s))',
+        Conditional::OPERATOR_BEGINSWITH => 'LEFT(%s,LEN(%s))=%s',
+        Conditional::OPERATOR_ENDSWITH => 'RIGHT(%s,LEN(%s))=%s',
+    ];
+    protected string $operator;
+    protected string $operand;
+    protected string $operandValueType;
+    public function __construct(string $cellRange)
+    {
+        parent::__construct($cellRange);
+    }
+    protected function operator(string $operator): void
+    {
+        if (!isset(self::OPERATORS[$operator])) {
+            throw new Exception('Invalid Operator for Text Value CF Rule Wizard');
+        }
+        $this->operator = $operator;
+    }
+    protected function operand(string $operand, string $operandValueType = Wizard::VALUE_TYPE_LITERAL): void
+    {
+        $operand = $this->validateOperand($operand, $operandValueType);
+        $this->operand = $operand;
+        $this->operandValueType = $operandValueType;
+    }
+    protected function wrapValue(string $value): string
+    {
+        return '"' . $value . '"';
+    }
+    protected function setExpression(): void
+    {
+        $operand = $this->operandValueType === Wizard::VALUE_TYPE_LITERAL
+            ? $this->wrapValue(str_replace('"', '""', $this->operand))
+            : $this->cellConditionCheck($this->operand);
+        if (
+            $this->operator === Conditional::OPERATOR_CONTAINSTEXT
+            || $this->operator === Conditional::OPERATOR_NOTCONTAINS
+        ) {
+            $this->expression = sprintf(self::EXPRESSIONS[$this->operator], $operand, $this->referenceCell);
+        } else {
+            $this->expression = sprintf(self::EXPRESSIONS[$this->operator], $this->referenceCell, $operand, $operand);
+        }
+    }
+    public function getConditional(): Conditional
+    {
+        $this->setExpression();
+        $conditional = new Conditional();
+        $conditional->setConditionType(self::OPERATORS[$this->operator]);
+        $conditional->setOperatorType($this->operator);
+        $conditional->setText(
+            $this->operandValueType !== Wizard::VALUE_TYPE_LITERAL
+                ? $this->cellConditionCheck($this->operand)
+                : $this->operand
+        );
+        $conditional->setConditions([$this->expression]);
+        $conditional->setStyle($this->getStyle());
+        $conditional->setStopIfTrue($this->getStopIfTrue());
+        return $conditional;
+    }
+    public static function fromConditional(Conditional $conditional, string $cellRange = 'A1'): WizardInterface
+    {
+        if (!in_array($conditional->getConditionType(), self::OPERATORS, true)) {
+            throw new Exception('Conditional is not a Text Value CF Rule conditional');
+        }
+        $wizard = new self($cellRange);
+        $wizard->operator = (string) array_search($conditional->getConditionType(), self::OPERATORS, true);
+        $wizard->style = $conditional->getStyle();
+        $wizard->stopIfTrue = $conditional->getStopIfTrue();
+        $wizard->operandValueType = Wizard::VALUE_TYPE_LITERAL;
+        $condition = $conditional->getText();
+        if (preg_match('/^' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '$/i', $condition)) {
+            $wizard->operandValueType = Wizard::VALUE_TYPE_CELL;
+            $condition = self::reverseAdjustCellRef($condition, $cellRange);
+        } elseif (
+            preg_match('/\(\)/', $condition)
+            || preg_match('/' . Calculation::CALCULATION_REGEXP_CELLREF_RELATIVE . '/i', $condition)
+        ) {
+            $wizard->operandValueType = Wizard::VALUE_TYPE_FORMULA;
+        }
+        $wizard->operand = $condition;
+        return $wizard;
+    }
+    /**
+     * @param mixed[] $arguments
+     */
+    public function __call(string $methodName, array $arguments): self
+    {
+        if (!isset(self::MAGIC_OPERATIONS[$methodName])) {
+            throw new Exception('Invalid Operation for Text Value CF Rule Wizard');
+        }
+        $this->operator(self::MAGIC_OPERATIONS[$methodName]);
+        if (count($arguments) < 2) {
+            /** @var string */
+            $arg0 = $arguments[0];
+            $this->operand($arg0);
+        } else {
+            /** @var string */
+            $arg0 = $arguments[0];
+            /** @var string */
+            $arg1 = $arguments[1];
+            $this->operand($arg0, $arg1);
+        }
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/NumberFormat/DateFormatter.php
@@ -0,0 +1,159 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+class DateFormatter
+{
+    /**
+     * Search/replace values to convert Excel date/time format masks to PHP format masks.
+     */
+    private const DATE_FORMAT_REPLACEMENTS = [
+        '\\' => '',
+        'am/pm' => 'A',
+        'e' => 'Y',
+        'yyyy' => 'Y',
+        'yy' => 'y',
+        'mmmmm' => 'M',
+        'mmmm' => 'F',
+        'mmm' => 'M',
+        ':mm' => ':i',
+        'mm:' => 'i:',
+        'dddd' => 'l',
+        'ddd' => 'D',
+        'dd' => 'd',
+        'd' => 'j',
+        '.s' => '',
+    ];
+    /**
+     * Search/replace values to convert Excel date/time format masks hours to PHP format masks (24 hr clock).
+     */
+    private const DATE_FORMAT_REPLACEMENTS24 = [
+        'hh' => 'H',
+        'h' => 'G',
+        'mm' => 'm',
+        'm' => 'n',
+        'ss' => 's',
+    ];
+    /**
+     * Search/replace values to convert Excel date/time format masks hours to PHP format masks (12 hr clock).
+     */
+    private const DATE_FORMAT_REPLACEMENTS12 = [
+        'hh' => 'h',
+        'h' => 'g',
+        'mm' => 'm',
+        'm' => 'n',
+        'ss' => 's',
+    ];
+    private const HOURS_IN_DAY = 24;
+    private const MINUTES_IN_DAY = 60 * self::HOURS_IN_DAY;
+    private const SECONDS_IN_DAY = 60 * self::MINUTES_IN_DAY;
+    private const INTERVAL_PRECISION = 10;
+    private const INTERVAL_LEADING_ZERO = [
+        '[hh]',
+        '[mm]',
+        '[ss]',
+    ];
+    private const INTERVAL_ROUND_PRECISION = [
+        '[h]' => self::INTERVAL_PRECISION,
+        '[hh]' => self::INTERVAL_PRECISION,
+        '[m]' => self::INTERVAL_PRECISION,
+        '[mm]' => self::INTERVAL_PRECISION,
+        '[s]' => 0,
+        '[ss]' => 0,
+    ];
+    private const INTERVAL_MULTIPLIER = [
+        '[h]' => self::HOURS_IN_DAY,
+        '[hh]' => self::HOURS_IN_DAY,
+        '[m]' => self::MINUTES_IN_DAY,
+        '[mm]' => self::MINUTES_IN_DAY,
+        '[s]' => self::SECONDS_IN_DAY,
+        '[ss]' => self::SECONDS_IN_DAY,
+    ];
+    private static function tryInterval(bool &$seekingBracket, string &$block, mixed $value, string $format): void
+    {
+        if ($seekingBracket) {
+            if (str_contains($block, $format)) {
+                $hours = (string) (int) round(
+                    self::INTERVAL_MULTIPLIER[$format] * $value,
+                    self::INTERVAL_ROUND_PRECISION[$format]
+                );
+                if (strlen($hours) === 1 && in_array($format, self::INTERVAL_LEADING_ZERO, true)) {
+                    $hours = "0$hours";
+                }
+                $block = str_replace($format, $hours, $block);
+                $seekingBracket = false;
+            }
+        }
+    }
+    /** @param float|int $value value to be formatted */
+    public static function format(mixed $value, string $format): string
+    {
+        $format = (string) preg_replace('/^(\[DBNum\d\])*(\[\$[^\]]*\])/i', '', $format);
+        /** @var callable $callable */
+        $callable = [self::class, 'setLowercaseCallback'];
+        $format = (string) preg_replace_callback('/(?:^|")([^"]*)(?:$|")/', $callable, $format);
+        $blocks = explode('"', $format);
+        foreach ($blocks as $key => &$block) {
+            if ($key % 2 == 0) {
+                $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS);
+                if (!strpos($block, 'A')) {
+                    $seekingBracket = true;
+                    self::tryInterval($seekingBracket, $block, $value, '[h]');
+                    self::tryInterval($seekingBracket, $block, $value, '[hh]');
+                    self::tryInterval($seekingBracket, $block, $value, '[mm]');
+                    self::tryInterval($seekingBracket, $block, $value, '[m]');
+                    self::tryInterval($seekingBracket, $block, $value, '[s]');
+                    self::tryInterval($seekingBracket, $block, $value, '[ss]');
+                    $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS24);
+                } else {
+                    $block = strtr($block, self::DATE_FORMAT_REPLACEMENTS12);
+                }
+            }
+        }
+        $format = implode('"', $blocks);
+        /** @var callable $callback */
+        $callback = [self::class, 'escapeQuotesCallback'];
+        $format = (string) preg_replace_callback('/"(.*)"/U', $callback, $format);
+        $dateObj = Date::excelToDateTimeObject($value);
+        $format = (string) \preg_replace('/\\\\:m/', ':i', $format);
+        $microseconds = (int) $dateObj->format('u');
+        if (str_contains($format, ':s.000')) {
+            $milliseconds = (int) round($microseconds / 1000.0);
+            if ($milliseconds === 1000) {
+                $milliseconds = 0;
+                $dateObj->modify('+1 second');
+            }
+            $dateObj->modify("-$microseconds microseconds");
+            $format = str_replace(':s.000', ':s.' . sprintf('%03d', $milliseconds), $format);
+        } elseif (str_contains($format, ':s.00')) {
+            $centiseconds = (int) round($microseconds / 10000.0);
+            if ($centiseconds === 100) {
+                $centiseconds = 0;
+                $dateObj->modify('+1 second');
+            }
+            $dateObj->modify("-$microseconds microseconds");
+            $format = str_replace(':s.00', ':s.' . sprintf('%02d', $centiseconds), $format);
+        } elseif (str_contains($format, ':s.0')) {
+            $deciseconds = (int) round($microseconds / 100000.0);
+            if ($deciseconds === 10) {
+                $deciseconds = 0;
+                $dateObj->modify('+1 second');
+            }
+            $dateObj->modify("-$microseconds microseconds");
+            $format = str_replace(':s.0', ':s.' . sprintf('%1d', $deciseconds), $format);
+        } else { // no fractional second
+            if ($microseconds >= 500000) {
+                $dateObj->modify('+1 second');
+            }
+            $dateObj->modify("-$microseconds microseconds");
+        }
+        return $dateObj->format($format);
+    }
+    private static function setLowercaseCallback(array $matches): string
+    {
+        return mb_strtolower($matches[0]);
+    }
+    private static function escapeQuotesCallback(array $matches): string
+    {
+        return '\\' . implode('\\', str_split($matches[1]));
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/NumberFormat/NumberFormatter.php
@@ -0,0 +1,241 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+class NumberFormatter extends BaseFormatter
+{
+    private const NUMBER_REGEX = '/(0+)(\\.?)(0*)/';
+    private static function mergeComplexNumberFormatMasks(array $numbers, array $masks): array
+    {
+        $decimalCount = strlen($numbers[1]);
+        $postDecimalMasks = [];
+        do {
+            $tempMask = array_pop($masks);
+            if ($tempMask !== null) {
+                $postDecimalMasks[] = $tempMask;
+                $decimalCount -= strlen($tempMask);
+            }
+        } while ($tempMask !== null && $decimalCount > 0);
+        return [
+            implode('.', $masks),
+            implode('.', array_reverse($postDecimalMasks)),
+        ];
+    }
+    private static function processComplexNumberFormatMask(mixed $number, string $mask): string
+    {
+        /** @var string $result */
+        $result = $number;
+        $maskingBlockCount = preg_match_all('/0+/', $mask, $maskingBlocks, PREG_OFFSET_CAPTURE);
+        if ($maskingBlockCount > 1) {
+            $maskingBlocks = array_reverse($maskingBlocks[0]);
+            $offset = 0;
+            foreach ($maskingBlocks as $block) {
+                $size = strlen($block[0]);
+                $divisor = 10 ** $size;
+                $offset = $block[1];
+                /** @var float $numberFloat */
+                $numberFloat = $number;
+                $blockValue = sprintf("%0{$size}d", fmod($numberFloat, $divisor));
+                $number = floor($numberFloat / $divisor);
+                $mask = substr_replace($mask, $blockValue, $offset, $size);
+            }
+            /** @var string $numberString */
+            $numberString = $number;
+            if ($number > 0) {
+                $mask = substr_replace($mask, $numberString, $offset, 0);
+            }
+            $result = $mask;
+        }
+        return self::makeString($result);
+    }
+    private static function complexNumberFormatMask(mixed $number, string $mask, bool $splitOnPoint = true): string
+    {
+        /** @var float $numberFloat */
+        $numberFloat = $number;
+        if ($splitOnPoint) {
+            $masks = explode('.', $mask);
+            if (count($masks) <= 2) {
+                $decmask = $masks[1] ?? '';
+                $decpos = substr_count($decmask, '0');
+                $numberFloat = round($numberFloat, $decpos);
+            }
+        }
+        $sign = ($numberFloat < 0.0) ? '-' : '';
+        $number = self::f2s(abs($numberFloat));
+        if ($splitOnPoint && str_contains($mask, '.') && str_contains($number, '.')) {
+            $numbers = explode('.', $number);
+            $masks = explode('.', $mask);
+            if (count($masks) > 2) {
+                $masks = self::mergeComplexNumberFormatMasks($numbers, $masks);
+            }
+            $integerPart = self::complexNumberFormatMask($numbers[0], $masks[0], false);
+            $numlen = strlen($numbers[1]);
+            $msklen = strlen($masks[1]);
+            if ($numlen < $msklen) {
+                $numbers[1] .= str_repeat('0', $msklen - $numlen);
+            }
+            $decimalPart = strrev(self::complexNumberFormatMask(strrev($numbers[1]), strrev($masks[1]), false));
+            $decimalPart = substr($decimalPart, 0, $msklen);
+            return "{$sign}{$integerPart}.{$decimalPart}";
+        }
+        if (strlen($number) < strlen($mask)) {
+            $number = str_repeat('0', strlen($mask) - strlen($number)) . $number;
+        }
+        $result = self::processComplexNumberFormatMask($number, $mask);
+        return "{$sign}{$result}";
+    }
+    public static function f2s(float $f): string
+    {
+        return self::floatStringConvertScientific((string) $f);
+    }
+    public static function floatStringConvertScientific(string $s): string
+    {
+        if (preg_match('/^([+-])?([1-9])([.]([0-9]+))?[eE]([+-]?[0-9]+)$/', $s, $matches) === 1) {
+            $exponent = (int) $matches[5];
+            $sign = ($matches[1] === '-') ? '-' : '';
+            if ($exponent >= 0) {
+                $exponentPlus1 = $exponent + 1;
+                $out = $matches[2] . $matches[4];
+                $len = strlen($out);
+                if ($len < $exponentPlus1) {
+                    $out .= str_repeat('0', $exponentPlus1 - $len);
+                }
+                $out = substr($out, 0, $exponentPlus1) . ((strlen($out) === $exponentPlus1) ? '' : ('.' . substr($out, $exponentPlus1)));
+                $s = "$sign$out";
+            } else {
+                $s = $sign . '0.' . str_repeat('0', -$exponent - 1) . $matches[2] . $matches[4];
+            }
+        }
+        return $s;
+    }
+    private static function formatStraightNumericValue(mixed $value, string $format, array $matches, bool $useThousands): string
+    {
+        /** @var float $valueFloat */
+        $valueFloat = $value;
+        $left = $matches[1];
+        $dec = $matches[2];
+        $right = $matches[3];
+        $minWidth = strlen($left) + strlen($dec) + strlen($right);
+        if ($useThousands) {
+            $value = number_format(
+                $valueFloat,
+                strlen($right),
+                StringHelper::getDecimalSeparator(),
+                StringHelper::getThousandsSeparator()
+            );
+            return self::pregReplace(self::NUMBER_REGEX, $value, $format);
+        }
+        if (preg_match('/[0#]E[+-]0/i', $format)) {
+            $decimals = strlen($right);
+            $size = $decimals + 3;
+            return sprintf("%{$size}.{$decimals}E", $valueFloat);
+        } elseif (preg_match('/0([^\d\.]+)0/', $format) || substr_count($format, '.') > 1) {
+            if ($valueFloat == floor($valueFloat) && substr_count($format, '.') === 1) {
+                $value *= 10 ** strlen(explode('.', $format)[1]);
+            }
+            $result = self::complexNumberFormatMask($value, $format);
+            if (str_contains($result, 'E')) {
+                $result = self::f2s($valueFloat);
+            }
+            return $result;
+        }
+        $sprintf_pattern = "%0$minWidth." . strlen($right) . 'F';
+        /** @var float $valueFloat */
+        $valueFloat = $value;
+        $value = self::adjustSeparators(sprintf($sprintf_pattern, round($valueFloat, strlen($right))));
+        return self::pregReplace(self::NUMBER_REGEX, $value, $format);
+    }
+    /** @param float|int|numeric-string $value value to be formatted */
+    public static function format(mixed $value, string $format): string
+    {
+        $baseFormat = $format;
+        $useThousands = self::areThousandsRequired($format);
+        $scale = self::scaleThousandsMillions($format);
+        if (preg_match('/[#\?0]?.*[#\?0]\/(\?+|\d+|#)/', $format)) {
+            $format = (string) preg_replace('/[#0]+\//', '?/', $format);
+            $format = (string) preg_replace('/\/[#0]+/', '/?', $format);
+            $value = FractionFormatter::format($value, $format);
+        } else {
+            $value = $value / $scale;
+            $paddingPlaceholder = (str_contains($format, '?'));
+            $format = self::pregReplace('/[\\#\?](?=(?:[^"]*"[^"]*")*[^"]*\Z)/', '0', $format);
+            $format = self::pregReplace('/\[\$\-.*\]/', '', $format);
+            $n = '/\\[[^\\]]+\\]/';
+            $m = self::pregReplace($n, '', $format);
+            $format = self::makeString(str_replace(['"', '*'], '', $format));
+            if (preg_match(self::NUMBER_REGEX, $m, $matches)) {
+                $value = self::formatStraightNumericValue($value, $format, $matches, $useThousands);
+                if ($paddingPlaceholder === true) {
+                    $value = self::padValue($value, $baseFormat);
+                }
+            } elseif ($format !== NumberFormat::FORMAT_GENERAL) {
+                $value = self::makeString(str_replace('?', '', $format));
+            }
+        }
+        if (preg_match('/\[\$(.*)\]/u', $format, $m)) {
+            $currencyCode = $m[1];
+            [$currencyCode] = explode('-', $currencyCode);
+            if ($currencyCode == '') {
+                $currencyCode = StringHelper::getCurrencyCode();
+            }
+            $value = self::pregReplace('/\[\$([^\]]*)\]/u', $currencyCode, (string) $value);
+        }
+        if (
+            (str_contains((string) $value, '0.'))
+            && ((str_contains($baseFormat, '#.')) || (str_contains($baseFormat, '?.')))
+        ) {
+            $value = preg_replace('/(\b)0\.|([^\d])0\./', '${2}.', (string) $value);
+        }
+        return (string) $value;
+    }
+    private static function makeString(array|string $value): string
+    {
+        return is_array($value) ? '' : "$value";
+    }
+    private static function pregReplace(string $pattern, string $replacement, string $subject): string
+    {
+        return self::makeString(preg_replace($pattern, $replacement, $subject) ?? '');
+    }
+    public static function padValue(string $value, string $baseFormat): string
+    {
+        $preDecimal = $postDecimal = '';
+        $pregArray = preg_split('/\.(?=(?:[^"]*"[^"]*")*[^"]*\Z)/miu', $baseFormat . '.?');
+        if (is_array($pregArray)) {
+            $preDecimal = $pregArray[0] ?? '';
+            $postDecimal = $pregArray[1] ?? '';
+        }
+        $length = strlen($value);
+        if (str_contains($postDecimal, '?')) {
+            $value = str_pad(rtrim($value, '0. '), $length, ' ', STR_PAD_RIGHT);
+        }
+        if (str_contains($preDecimal, '?')) {
+            $value = str_pad(ltrim($value, '0, '), $length, ' ', STR_PAD_LEFT);
+        }
+        return $value;
+    }
+    /**
+     * Find out if we need thousands separator
+     * This is indicated by a comma enclosed by a digit placeholders: #, 0 or ?
+     */
+    public static function areThousandsRequired(string &$format): bool
+    {
+        $useThousands = (bool) preg_match('/([#\?0]),([#\?0])/', $format);
+        if ($useThousands) {
+            $format = self::pregReplace('/([#\?0]),([#\?0])/', '${1}${2}', $format);
+        }
+        return $useThousands;
+    }
+    /**
+     * Scale thousands, millions,...
+     * This is indicated by a number of commas after a digit placeholder: #, or 0.0,, or ?,.
+     */
+    public static function scaleThousandsMillions(string &$format): int
+    {
+        $scale = 1; // same as no scale
+        if (preg_match('/(#|0|\?)(,+)/', $format, $matches)) {
+            $scale = 1000 ** strlen($matches[2]);
+            $format = self::pregReplace('/([#\?0]),+/', '${1}', $format);
+        }
+        return $scale;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Style/NumberFormat/Wizard/DateTime.php
@@ -0,0 +1,37 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Style\NumberFormat\Wizard;
+class DateTime extends DateTimeWizard
+{
+    /**
+     * @var string[]
+     */
+    protected array $separators;
+    /**
+     * @var array<DateTimeWizard|string>
+     */
+    protected array $formatBlocks;
+    /**
+     * @param null|string|string[] $separators
+     *          If you want to use only a single format block, then pass a null as the separator argument
+     * @param DateTimeWizard|string ...$formatBlocks
+     */
+    public function __construct($separators, ...$formatBlocks)
+    {
+        $this->separators = $this->padSeparatorArray(
+            is_array($separators) ? $separators : [$separators],
+            count($formatBlocks) - 1
+        );
+        $this->formatBlocks = array_map([$this, 'mapFormatBlocks'], $formatBlocks);
+    }
+    private function mapFormatBlocks(DateTimeWizard|string $value): string
+    {
+        if ($value instanceof DateTimeWizard) {
+            return $value->__toString();
+        }
+        return $this->wrapLiteral($value);
+    }
+    public function format(): string
+    {
+        return implode('', array_map([$this, 'intersperse'], $this->formatBlocks, $this->separators));
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Worksheet/AutoFilter.php
@@ -0,0 +1,916 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Worksheet;
+use DateTime;
+use DateTimeZone;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Functions;
+use PhpOffice\PhpSpreadsheet\Calculation\Internal\WildcardMatch;
+use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
+use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
+use PhpOffice\PhpSpreadsheet\Cell\CellRange;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column\Rule;
+use Stringable;
+class AutoFilter implements Stringable
+{
+    /**
+     * Autofilter Worksheet.
+     */
+    private ?Worksheet $workSheet;
+    /**
+     * Autofilter Range.
+     */
+    private string $range;
+    /**
+     * Autofilter Column Ruleset.
+     *
+     * @var AutoFilter\Column[]
+     */
+    private array $columns = [];
+    private bool $evaluated = false;
+    public function getEvaluated(): bool
+    {
+        return $this->evaluated;
+    }
+    public function setEvaluated(bool $value): void
+    {
+        $this->evaluated = $value;
+    }
+    /**
+     * Create a new AutoFilter.
+     *
+     * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
+     *            A simple string containing a Cell range like 'A1:E10' is permitted
+     *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
+     *              or an AddressRange object.
+     */
+    public function __construct(AddressRange|string|array $range = '', ?Worksheet $worksheet = null)
+    {
+        if ($range !== '') {
+            [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
+        }
+        $this->range = $range ?? '';
+        $this->workSheet = $worksheet;
+    }
+    public function __destruct()
+    {
+        $this->workSheet = null;
+    }
+    /**
+     * Get AutoFilter Parent Worksheet.
+     */
+    public function getParent(): null|Worksheet
+    {
+        return $this->workSheet;
+    }
+    /**
+     * Set AutoFilter Parent Worksheet.
+     *
+     * @return $this
+     */
+    public function setParent(?Worksheet $worksheet = null): static
+    {
+        $this->evaluated = false;
+        $this->workSheet = $worksheet;
+        return $this;
+    }
+    /**
+     * Get AutoFilter Range.
+     */
+    public function getRange(): string
+    {
+        return $this->range;
+    }
+    /**
+     * Set AutoFilter Cell Range.
+     *
+     * @param AddressRange<CellRange>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
+     *            A simple string containing a Cell range like 'A1:E10' or a Cell address like 'A1' is permitted
+     *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
+     *              or an AddressRange object.
+     */
+    public function setRange(AddressRange|string|array $range = ''): self
+    {
+        $this->evaluated = false;
+        if ($range !== '') {
+            [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
+        }
+        if (empty($range)) {
+            $this->columns = [];
+            $this->range = '';
+            return $this;
+        }
+        if (ctype_digit($range) || ctype_alpha($range)) {
+            throw new Exception("{$range} is an invalid range for AutoFilter");
+        }
+        $this->range = $range;
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        foreach ($this->columns as $key => $value) {
+            $colIndex = Coordinate::columnIndexFromString($key);
+            if (($rangeStart[0] > $colIndex) || ($rangeEnd[0] < $colIndex)) {
+                unset($this->columns[$key]);
+            }
+        }
+        return $this;
+    }
+    public function setRangeToMaxRow(): self
+    {
+        $this->evaluated = false;
+        if ($this->workSheet !== null) {
+            $thisrange = $this->range;
+            $range = (string) preg_replace('/\\d+$/', (string) $this->workSheet->getHighestRow(), $thisrange);
+            if ($range !== $thisrange) {
+                $this->setRange($range);
+            }
+        }
+        return $this;
+    }
+    /**
+     * Get all AutoFilter Columns.
+     *
+     * @return AutoFilter\Column[]
+     */
+    public function getColumns(): array
+    {
+        return $this->columns;
+    }
+    /**
+     * Validate that the specified column is in the AutoFilter range.
+     *
+     * @param string $column Column name (e.g. A)
+     *
+     * @return int The column offset within the autofilter range
+     */
+    public function testColumnInRange(string $column): int
+    {
+        if (empty($this->range)) {
+            throw new Exception('No autofilter range is defined.');
+        }
+        $columnIndex = Coordinate::columnIndexFromString($column);
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        if (($rangeStart[0] > $columnIndex) || ($rangeEnd[0] < $columnIndex)) {
+            throw new Exception('Column is outside of current autofilter range.');
+        }
+        return $columnIndex - $rangeStart[0];
+    }
+    /**
+     * Get a specified AutoFilter Column Offset within the defined AutoFilter range.
+     *
+     * @param string $column Column name (e.g. A)
+     *
+     * @return int The offset of the specified column within the autofilter range
+     */
+    public function getColumnOffset(string $column): int
+    {
+        return $this->testColumnInRange($column);
+    }
+    /**
+     * Get a specified AutoFilter Column.
+     *
+     * @param string $column Column name (e.g. A)
+     */
+    public function getColumn(string $column): AutoFilter\Column
+    {
+        $this->testColumnInRange($column);
+        if (!isset($this->columns[$column])) {
+            $this->columns[$column] = new AutoFilter\Column($column, $this);
+        }
+        return $this->columns[$column];
+    }
+    /**
+     * Get a specified AutoFilter Column by it's offset.
+     *
+     * @param int $columnOffset Column offset within range (starting from 0)
+     */
+    public function getColumnByOffset(int $columnOffset): AutoFilter\Column
+    {
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        $pColumn = Coordinate::stringFromColumnIndex($rangeStart[0] + $columnOffset);
+        return $this->getColumn($pColumn);
+    }
+    /**
+     * Set AutoFilter.
+     *
+     * @param AutoFilter\Column|string $columnObjectOrString
+     *            A simple string containing a Column ID like 'A' is permitted
+     *
+     * @return $this
+     */
+    public function setColumn(AutoFilter\Column|string $columnObjectOrString): static
+    {
+        $this->evaluated = false;
+        if ((is_string($columnObjectOrString)) && (!empty($columnObjectOrString))) {
+            $column = $columnObjectOrString;
+        } elseif ($columnObjectOrString instanceof AutoFilter\Column) {
+            $column = $columnObjectOrString->getColumnIndex();
+        } else {
+            throw new Exception('Column is not within the autofilter range.');
+        }
+        $this->testColumnInRange($column);
+        if (is_string($columnObjectOrString)) {
+            $this->columns[$columnObjectOrString] = new AutoFilter\Column($columnObjectOrString, $this);
+        } else {
+            $columnObjectOrString->setParent($this);
+            $this->columns[$column] = $columnObjectOrString;
+        }
+        ksort($this->columns);
+        return $this;
+    }
+    /**
+     * Clear a specified AutoFilter Column.
+     *
+     * @param string $column Column name (e.g. A)
+     *
+     * @return $this
+     */
+    public function clearColumn(string $column): static
+    {
+        $this->evaluated = false;
+        $this->testColumnInRange($column);
+        if (isset($this->columns[$column])) {
+            unset($this->columns[$column]);
+        }
+        return $this;
+    }
+    /**
+     * Shift an AutoFilter Column Rule to a different column.
+     *
+     * Note: This method bypasses validation of the destination column to ensure it is within this AutoFilter range.
+     *        Nor does it verify whether any column rule already exists at $toColumn, but will simply override any existing value.
+     *        Use with caution.
+     *
+     * @param string $fromColumn Column name (e.g. A)
+     * @param string $toColumn Column name (e.g. B)
+     *
+     * @return $this
+     */
+    public function shiftColumn(string $fromColumn, string $toColumn): static
+    {
+        $this->evaluated = false;
+        $fromColumn = strtoupper($fromColumn);
+        $toColumn = strtoupper($toColumn);
+        if (($fromColumn !== null) && (isset($this->columns[$fromColumn])) && ($toColumn !== null)) {
+            $this->columns[$fromColumn]->setParent();
+            $this->columns[$fromColumn]->setColumnIndex($toColumn);
+            $this->columns[$toColumn] = $this->columns[$fromColumn];
+            $this->columns[$toColumn]->setParent($this);
+            unset($this->columns[$fromColumn]);
+            ksort($this->columns);
+        }
+        return $this;
+    }
+    /**
+     * Test if cell value is in the defined set of values.
+     *
+     * @param array{blanks: bool, filterValues: array<string,array<string,string>>} $dataSet
+     */
+    protected static function filterTestInSimpleDataSet(mixed $cellValue, array $dataSet): bool
+    {
+        $dataSetValues = $dataSet['filterValues'];
+        $blanks = $dataSet['blanks'];
+        if (($cellValue == '') || ($cellValue === null)) {
+            return $blanks;
+        }
+        return in_array($cellValue, $dataSetValues);
+    }
+    /**
+     * Test if cell value is in the defined set of Excel date values.
+     *
+     * @param array{blanks: bool, filterValues: array<string,array<string,string>>} $dataSet
+     */
+    protected static function filterTestInDateGroupSet(mixed $cellValue, array $dataSet): bool
+    {
+        $dateSet = $dataSet['filterValues'];
+        $blanks = $dataSet['blanks'];
+        if (($cellValue == '') || ($cellValue === null)) {
+            return $blanks;
+        }
+        $timeZone = new DateTimeZone('UTC');
+        if (is_numeric($cellValue)) {
+            $dateTime = Date::excelToDateTimeObject((float) $cellValue, $timeZone);
+            $cellValue = (float) $cellValue;
+            if ($cellValue < 1) {
+                $dtVal = $dateTime->format('His');
+                $dateSet = $dateSet['time'];
+            } elseif ($cellValue == floor($cellValue)) {
+                $dtVal = $dateTime->format('Ymd');
+                $dateSet = $dateSet['date'];
+            } else {
+                $dtVal = $dateTime->format('YmdHis');
+                $dateSet = $dateSet['dateTime'];
+            }
+            foreach ($dateSet as $dateValue) {
+                if (str_starts_with($dtVal, $dateValue)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    /**
+     * Test if cell value is within a set of values defined by a ruleset.
+     *
+     * @param mixed[] $ruleSet
+     */
+    protected static function filterTestInCustomDataSet(mixed $cellValue, array $ruleSet): bool
+    {
+        /** @var array[] $dataSet */
+        $dataSet = $ruleSet['filterRules'];
+        $join = $ruleSet['join'];
+        $customRuleForBlanks = $ruleSet['customRuleForBlanks'] ?? false;
+        if (!$customRuleForBlanks) {
+            if (($cellValue == '') || ($cellValue === null)) {
+                return false;
+            }
+        }
+        $returnVal = ($join == AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND);
+        foreach ($dataSet as $rule) {
+            /** @var string $ruleValue */
+            $ruleValue = $rule['value'];
+            /** @var string $ruleOperator */
+            $ruleOperator = $rule['operator'];
+            /** @var string $cellValueString */
+            $cellValueString = $cellValue ?? '';
+            $retVal = false;
+            if (is_numeric($ruleValue)) {
+                $numericTest = is_numeric($cellValue);
+                switch ($ruleOperator) {
+                    case Rule::AUTOFILTER_COLUMN_RULE_EQUAL:
+                        $retVal = $numericTest && ($cellValue == $ruleValue);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL:
+                        $retVal = !$numericTest || ($cellValue != $ruleValue);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN:
+                        $retVal = $numericTest && ($cellValue > $ruleValue);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL:
+                        $retVal = $numericTest && ($cellValue >= $ruleValue);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN:
+                        $retVal = $numericTest && ($cellValue < $ruleValue);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL:
+                        $retVal = $numericTest && ($cellValue <= $ruleValue);
+                        break;
+                }
+            } elseif ($ruleValue == '') {
+                $retVal = match ($ruleOperator) {
+                    Rule::AUTOFILTER_COLUMN_RULE_EQUAL => ($cellValue == '') || ($cellValue === null),
+                    Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL => ($cellValue != '') && ($cellValue !== null),
+                    default => true,
+                };
+            } else {
+                switch ($ruleOperator) {
+                    case Rule::AUTOFILTER_COLUMN_RULE_EQUAL:
+                        $retVal = (bool) preg_match('/^' . $ruleValue . '$/i', $cellValueString);
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_NOTEQUAL:
+                        $retVal = !((bool) preg_match('/^' . $ruleValue . '$/i', $cellValueString));
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN:
+                        $retVal = strcasecmp($cellValueString, $ruleValue) > 0;
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL:
+                        $retVal = strcasecmp($cellValueString, $ruleValue) >= 0;
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN:
+                        $retVal = strcasecmp($cellValueString, $ruleValue) < 0;
+                        break;
+                    case Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL:
+                        $retVal = strcasecmp($cellValueString, $ruleValue) <= 0;
+                        break;
+                }
+            }
+            switch ($join) {
+                case AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR:
+                    $returnVal = $returnVal || $retVal;
+                    if ($returnVal) {
+                        return $returnVal;
+                    }
+                    break;
+                case AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND:
+                    $returnVal = $returnVal && $retVal;
+                    break;
+            }
+        }
+        return $returnVal;
+    }
+    /**
+     * Test if cell date value is matches a set of values defined by a set of months.
+     *
+     * @param mixed[] $monthSet
+     */
+    protected static function filterTestInPeriodDateSet(mixed $cellValue, array $monthSet): bool
+    {
+        if (($cellValue == '') || ($cellValue === null)) {
+            return false;
+        }
+        if (is_numeric($cellValue)) {
+            $dateObject = Date::excelToDateTimeObject((float) $cellValue, new DateTimeZone('UTC'));
+            $dateValue = (int) $dateObject->format('m');
+            if (in_array($dateValue, $monthSet)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    private static function makeDateObject(int $year, int $month, int $day, int $hour = 0, int $minute = 0, int $second = 0): DateTime
+    {
+        $baseDate = new DateTime();
+        $baseDate->setDate($year, $month, $day);
+        $baseDate->setTime($hour, $minute, $second);
+        return $baseDate;
+    }
+    private const DATE_FUNCTIONS = [
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH => 'dynamicLastMonth',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER => 'dynamicLastQuarter',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK => 'dynamicLastWeek',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR => 'dynamicLastYear',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH => 'dynamicNextMonth',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER => 'dynamicNextQuarter',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK => 'dynamicNextWeek',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR => 'dynamicNextYear',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH => 'dynamicThisMonth',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER => 'dynamicThisQuarter',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK => 'dynamicThisWeek',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR => 'dynamicThisYear',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_TODAY => 'dynamicToday',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW => 'dynamicTomorrow',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE => 'dynamicYearToDate',
+        Rule::AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY => 'dynamicYesterday',
+    ];
+    private static function dynamicLastMonth(): array
+    {
+        $maxval = new DateTime();
+        $year = (int) $maxval->format('Y');
+        $month = (int) $maxval->format('m');
+        $maxval->setDate($year, $month, 1);
+        $maxval->setTime(0, 0, 0);
+        $val = clone $maxval;
+        $val->modify('-1 month');
+        return [$val, $maxval];
+    }
+    private static function firstDayOfQuarter(): DateTime
+    {
+        $val = new DateTime();
+        $year = (int) $val->format('Y');
+        $month = (int) $val->format('m');
+        $month = 3 * intdiv($month - 1, 3) + 1;
+        $val->setDate($year, $month, 1);
+        $val->setTime(0, 0, 0);
+        return $val;
+    }
+    private static function dynamicLastQuarter(): array
+    {
+        $maxval = self::firstDayOfQuarter();
+        $val = clone $maxval;
+        $val->modify('-3 months');
+        return [$val, $maxval];
+    }
+    private static function dynamicLastWeek(): array
+    {
+        $val = new DateTime();
+        $val->setTime(0, 0, 0);
+        $dayOfWeek = (int) $val->format('w'); // Sunday is 0
+        $subtract = $dayOfWeek + 7; // revert to prior Sunday
+        $val->modify("-$subtract days");
+        $maxval = clone $val;
+        $maxval->modify('+7 days');
+        return [$val, $maxval];
+    }
+    private static function dynamicLastYear(): array
+    {
+        $val = new DateTime();
+        $year = (int) $val->format('Y');
+        $val = self::makeDateObject($year - 1, 1, 1);
+        $maxval = self::makeDateObject($year, 1, 1);
+        return [$val, $maxval];
+    }
+    private static function dynamicNextMonth(): array
+    {
+        $val = new DateTime();
+        $year = (int) $val->format('Y');
+        $month = (int) $val->format('m');
+        $val->setDate($year, $month, 1);
+        $val->setTime(0, 0, 0);
+        $val->modify('+1 month');
+        $maxval = clone $val;
+        $maxval->modify('+1 month');
+        return [$val, $maxval];
+    }
+    private static function dynamicNextQuarter(): array
+    {
+        $val = self::firstDayOfQuarter();
+        $val->modify('+3 months');
+        $maxval = clone $val;
+        $maxval->modify('+3 months');
+        return [$val, $maxval];
+    }
+    private static function dynamicNextWeek(): array
+    {
+        $val = new DateTime();
+        $val->setTime(0, 0, 0);
+        $dayOfWeek = (int) $val->format('w'); // Sunday is 0
+        $add = 7 - $dayOfWeek; // move to next Sunday
+        $val->modify("+$add days");
+        $maxval = clone $val;
+        $maxval->modify('+7 days');
+        return [$val, $maxval];
+    }
+    private static function dynamicNextYear(): array
+    {
+        $val = new DateTime();
+        $year = (int) $val->format('Y');
+        $val = self::makeDateObject($year + 1, 1, 1);
+        $maxval = self::makeDateObject($year + 2, 1, 1);
+        return [$val, $maxval];
+    }
+    private static function dynamicThisMonth(): array
+    {
+        $baseDate = new DateTime();
+        $baseDate->setTime(0, 0, 0);
+        $year = (int) $baseDate->format('Y');
+        $month = (int) $baseDate->format('m');
+        $val = self::makeDateObject($year, $month, 1);
+        $maxval = clone $val;
+        $maxval->modify('+1 month');
+        return [$val, $maxval];
+    }
+    private static function dynamicThisQuarter(): array
+    {
+        $val = self::firstDayOfQuarter();
+        $maxval = clone $val;
+        $maxval->modify('+3 months');
+        return [$val, $maxval];
+    }
+    private static function dynamicThisWeek(): array
+    {
+        $val = new DateTime();
+        $val->setTime(0, 0, 0);
+        $dayOfWeek = (int) $val->format('w'); // Sunday is 0
+        $subtract = $dayOfWeek; // revert to Sunday
+        $val->modify("-$subtract days");
+        $maxval = clone $val;
+        $maxval->modify('+7 days');
+        return [$val, $maxval];
+    }
+    private static function dynamicThisYear(): array
+    {
+        $val = new DateTime();
+        $year = (int) $val->format('Y');
+        $val = self::makeDateObject($year, 1, 1);
+        $maxval = self::makeDateObject($year + 1, 1, 1);
+        return [$val, $maxval];
+    }
+    private static function dynamicToday(): array
+    {
+        $val = new DateTime();
+        $val->setTime(0, 0, 0);
+        $maxval = clone $val;
+        $maxval->modify('+1 day');
+        return [$val, $maxval];
+    }
+    private static function dynamicTomorrow(): array
+    {
+        $val = new DateTime();
+        $val->setTime(0, 0, 0);
+        $val->modify('+1 day');
+        $maxval = clone $val;
+        $maxval->modify('+1 day');
+        return [$val, $maxval];
+    }
+    private static function dynamicYearToDate(): array
+    {
+        $maxval = new DateTime();
+        $maxval->setTime(0, 0, 0);
+        $val = self::makeDateObject((int) $maxval->format('Y'), 1, 1);
+        $maxval->modify('+1 day');
+        return [$val, $maxval];
+    }
+    private static function dynamicYesterday(): array
+    {
+        $maxval = new DateTime();
+        $maxval->setTime(0, 0, 0);
+        $val = clone $maxval;
+        $val->modify('-1 day');
+        return [$val, $maxval];
+    }
+    /**
+     * Convert a dynamic rule daterange to a custom filter range expression for ease of calculation.
+     *
+     * @return mixed[]
+     */
+    private function dynamicFilterDateRange(string $dynamicRuleType, AutoFilter\Column &$filterColumn): array
+    {
+        $ruleValues = [];
+        $callBack = [__CLASS__, self::DATE_FUNCTIONS[$dynamicRuleType]]; // What if not found?
+        $val = $maxval = 0;
+        if (is_callable($callBack)) {
+            [$val, $maxval] = $callBack();
+        }
+        $val = Date::dateTimeToExcel($val);
+        $maxval = Date::dateTimeToExcel($maxval);
+        $filterColumn->setAttributes(['val' => $val, 'maxVal' => $maxval]);
+        $ruleValues[] = ['operator' => Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL, 'value' => $val];
+        $ruleValues[] = ['operator' => Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN, 'value' => $maxval];
+        return ['method' => 'filterTestInCustomDataSet', 'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_AND]];
+    }
+    /**
+     * Apply the AutoFilter rules to the AutoFilter Range.
+     */
+    private function calculateTopTenValue(string $columnID, int $startRow, int $endRow, ?string $ruleType, mixed $ruleValue): mixed
+    {
+        $range = $columnID . $startRow . ':' . $columnID . $endRow;
+        $retVal = null;
+        if ($this->workSheet !== null) {
+            $dataValues = Functions::flattenArray($this->workSheet->rangeToArray($range, null, true, false));
+            $dataValues = array_filter($dataValues);
+            if ($ruleType == Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP) {
+                rsort($dataValues);
+            } else {
+                sort($dataValues);
+            }
+            if (is_numeric($ruleValue)) {
+                $ruleValue = (int) $ruleValue;
+            }
+            if ($ruleValue === null || is_int($ruleValue)) {
+                $slice = array_slice($dataValues, 0, $ruleValue);
+                $retVal = array_pop($slice);
+            }
+        }
+        return $retVal;
+    }
+    /**
+     * Apply the AutoFilter rules to the AutoFilter Range.
+     *
+     * @return $this
+     */
+    public function showHideRows(): static
+    {
+        if ($this->workSheet === null) {
+            return $this;
+        }
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        $this->workSheet->getRowDimension($rangeStart[1])->setVisible(true);
+        $columnFilterTests = [];
+        foreach ($this->columns as $columnID => $filterColumn) {
+            $rules = $filterColumn->getRules();
+            switch ($filterColumn->getFilterType()) {
+                case AutoFilter\Column::AUTOFILTER_FILTERTYPE_FILTER:
+                    $ruleType = null;
+                    $ruleValues = [];
+                    foreach ($rules as $rule) {
+                        $ruleType = $rule->getRuleType();
+                        $ruleValues[] = $rule->getValue();
+                    }
+                    $blanks = false;
+                    $ruleDataSet = array_filter($ruleValues);
+                    if (count($ruleValues) != count($ruleDataSet)) {
+                        $blanks = true;
+                    }
+                    if ($ruleType == Rule::AUTOFILTER_RULETYPE_FILTER) {
+                        $columnFilterTests[$columnID] = [
+                            'method' => 'filterTestInSimpleDataSet',
+                            'arguments' => ['filterValues' => $ruleDataSet, 'blanks' => $blanks],
+                        ];
+                    } elseif ($ruleType !== null) {
+                        $arguments = [
+                            'date' => [],
+                            'time' => [],
+                            'dateTime' => [],
+                        ];
+                        foreach ($ruleDataSet as $ruleValue) {
+                            if (!is_array($ruleValue)) {
+                                continue;
+                            }
+                            $date = $time = '';
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR] !== '')
+                            ) {
+                                $date .= sprintf('%04d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_YEAR]);
+                            }
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH] != '')
+                            ) {
+                                $date .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MONTH]);
+                            }
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY] !== '')
+                            ) {
+                                $date .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_DAY]);
+                            }
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR] !== '')
+                            ) {
+                                $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_HOUR]);
+                            }
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE] !== '')
+                            ) {
+                                $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE]);
+                            }
+                            if (
+                                (isset($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND]))
+                                && ($ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND] !== '')
+                            ) {
+                                $time .= sprintf('%02d', $ruleValue[Rule::AUTOFILTER_RULETYPE_DATEGROUP_SECOND]);
+                            }
+                            $dateTime = $date . $time;
+                            $arguments['date'][] = $date;
+                            $arguments['time'][] = $time;
+                            $arguments['dateTime'][] = $dateTime;
+                        }
+                        $arguments['date'] = array_filter($arguments['date']);
+                        $arguments['time'] = array_filter($arguments['time']);
+                        $arguments['dateTime'] = array_filter($arguments['dateTime']);
+                        $columnFilterTests[$columnID] = [
+                            'method' => 'filterTestInDateGroupSet',
+                            'arguments' => ['filterValues' => $arguments, 'blanks' => $blanks],
+                        ];
+                    }
+                    break;
+                case AutoFilter\Column::AUTOFILTER_FILTERTYPE_CUSTOMFILTER:
+                    $customRuleForBlanks = true;
+                    $ruleValues = [];
+                    foreach ($rules as $rule) {
+                        $ruleValue = $rule->getValue();
+                        if (!is_array($ruleValue) && !is_numeric($ruleValue)) {
+                            $ruleValue = WildcardMatch::wildcard($ruleValue);
+                            if (trim($ruleValue) == '') {
+                                $customRuleForBlanks = true;
+                                $ruleValue = trim($ruleValue);
+                            }
+                        }
+                        $ruleValues[] = ['operator' => $rule->getOperator(), 'value' => $ruleValue];
+                    }
+                    $join = $filterColumn->getJoin();
+                    $columnFilterTests[$columnID] = [
+                        'method' => 'filterTestInCustomDataSet',
+                        'arguments' => ['filterRules' => $ruleValues, 'join' => $join, 'customRuleForBlanks' => $customRuleForBlanks],
+                    ];
+                    break;
+                case AutoFilter\Column::AUTOFILTER_FILTERTYPE_DYNAMICFILTER:
+                    $ruleValues = [];
+                    foreach ($rules as $rule) {
+                        $dynamicRuleType = $rule->getGrouping();
+                        if (
+                            ($dynamicRuleType == Rule::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE)
+                            || ($dynamicRuleType == Rule::AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE)
+                        ) {
+                            $averageFormula = '=AVERAGE(' . $columnID . ($rangeStart[1] + 1) . ':' . $columnID . $rangeEnd[1] . ')';
+                            $average = Calculation::getInstance($this->workSheet->getParent())->calculateFormula($averageFormula, null, $this->workSheet->getCell('A1'));
+                            while (is_array($average)) {
+                                $average = array_pop($average);
+                            }
+                            $operator = ($dynamicRuleType === Rule::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE)
+                                ? Rule::AUTOFILTER_COLUMN_RULE_GREATERTHAN
+                                : Rule::AUTOFILTER_COLUMN_RULE_LESSTHAN;
+                            $ruleValues[] = [
+                                'operator' => $operator,
+                                'value' => $average,
+                            ];
+                            $columnFilterTests[$columnID] = [
+                                'method' => 'filterTestInCustomDataSet',
+                                'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR],
+                            ];
+                        } else {
+                            if ($dynamicRuleType[0] == 'M' || $dynamicRuleType[0] == 'Q') {
+                                $periodType = '';
+                                $period = 0;
+                                sscanf($dynamicRuleType, '%[A-Z]%d', $periodType, $period);
+                                if ($periodType == 'M') {
+                                    $ruleValues = [$period];
+                                } else {
+                                    --$period;
+                                    $periodEnd = (1 + $period) * 3;
+                                    $periodStart = 1 + $period * 3;
+                                    $ruleValues = range($periodStart, $periodEnd);
+                                }
+                                $columnFilterTests[$columnID] = [
+                                    'method' => 'filterTestInPeriodDateSet',
+                                    'arguments' => $ruleValues,
+                                ];
+                                $filterColumn->setAttributes([]);
+                            } else {
+                                $columnFilterTests[$columnID] = $this->dynamicFilterDateRange($dynamicRuleType, $filterColumn);
+                                break;
+                            }
+                        }
+                    }
+                    break;
+                case AutoFilter\Column::AUTOFILTER_FILTERTYPE_TOPTENFILTER:
+                    $ruleValues = [];
+                    $dataRowCount = $rangeEnd[1] - $rangeStart[1];
+                    $toptenRuleType = null;
+                    $ruleValue = 0;
+                    $ruleOperator = null;
+                    foreach ($rules as $rule) {
+                        $toptenRuleType = $rule->getGrouping();
+                        $ruleValue = $rule->getValue();
+                        $ruleOperator = $rule->getOperator();
+                    }
+                    if (is_numeric($ruleValue) && $ruleOperator === Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT) {
+                        $ruleValue = (int) floor((float) $ruleValue * ($dataRowCount / 100));
+                    }
+                    if (!is_array($ruleValue) && $ruleValue < 1) {
+                        $ruleValue = 1;
+                    }
+                    if (!is_array($ruleValue) && $ruleValue > 500) {
+                        $ruleValue = 500;
+                    }
+                    /** @var float|int|string */
+                    $maxVal = $this->calculateTopTenValue($columnID, $rangeStart[1] + 1, (int) $rangeEnd[1], $toptenRuleType, $ruleValue);
+                    $operator = ($toptenRuleType == Rule::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP)
+                        ? Rule::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL
+                        : Rule::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL;
+                    $ruleValues[] = ['operator' => $operator, 'value' => $maxVal];
+                    $columnFilterTests[$columnID] = [
+                        'method' => 'filterTestInCustomDataSet',
+                        'arguments' => ['filterRules' => $ruleValues, 'join' => AutoFilter\Column::AUTOFILTER_COLUMN_JOIN_OR],
+                    ];
+                    $filterColumn->setAttributes(['maxVal' => $maxVal]);
+                    break;
+            }
+        }
+        $rangeEnd[1] = $this->autoExtendRange($rangeStart[1], $rangeEnd[1]);
+        for ($row = $rangeStart[1] + 1; $row <= $rangeEnd[1]; ++$row) {
+            $result = true;
+            foreach ($columnFilterTests as $columnID => $columnFilterTest) {
+                $cellValue = $this->workSheet->getCell($columnID . $row)->getCalculatedValue();
+                /** @var callable */
+                $temp = [self::class, $columnFilterTest['method']];
+                /** @var bool */
+                $result // $result && // phpstan says $result is always true here
+                    = call_user_func_array($temp, [$cellValue, $columnFilterTest['arguments']]);
+                if (!$result) {
+                    break;
+                }
+            }
+            if ($result === false || $this->workSheet->rowDimensionExists((int) $row)) {
+                $this->workSheet->getRowDimension((int) $row)->setVisible($result);
+            }
+        }
+        $this->evaluated = true;
+        return $this;
+    }
+    /**
+     * Magic Range Auto-sizing.
+     * For a single row rangeSet, we follow MS Excel rules, and search for the first empty row to determine our range.
+     */
+    public function autoExtendRange(int $startRow, int $endRow): int
+    {
+        if ($startRow === $endRow && $this->workSheet !== null) {
+            try {
+                $rowIterator = $this->workSheet->getRowIterator($startRow + 1);
+            } catch (Exception) {
+                return $startRow;
+            }
+            foreach ($rowIterator as $row) {
+                if ($row->isEmpty(CellIterator::TREAT_NULL_VALUE_AS_EMPTY_CELL | CellIterator::TREAT_EMPTY_STRING_AS_EMPTY_CELL) === true) {
+                    return $row->getRowIndex() - 1;
+                }
+            }
+        }
+        return $endRow;
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $vars = get_object_vars($this);
+        foreach ($vars as $key => $value) {
+            if (is_object($value)) {
+                if ($key === 'workSheet') {
+                    $this->{$key} = null;
+                } else {
+                    $this->{$key} = clone $value;
+                }
+            } elseif ((is_array($value)) && ($key == 'columns')) {
+                $this->{$key} = [];
+                foreach ($value as $k => $v) {
+                    $this->{$key}[$k] = clone $v;
+                    $this->{$key}[$k]->setParent($this);
+                }
+            } else {
+                $this->{$key} = $value;
+            }
+        }
+    }
+    /**
+     * toString method replicates previous behavior by returning the range if object is
+     * referenced as a property of its parent.
+     */
+    public function __toString(): string
+    {
+        return (string) $this->range;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Worksheet/AutoFilter/Column.php
@@ -0,0 +1,318 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter;
+class Column
+{
+    const AUTOFILTER_FILTERTYPE_FILTER = 'filters';
+    const AUTOFILTER_FILTERTYPE_CUSTOMFILTER = 'customFilters';
+    const AUTOFILTER_FILTERTYPE_DYNAMICFILTER = 'dynamicFilter';
+    const AUTOFILTER_FILTERTYPE_TOPTENFILTER = 'top10';
+    /**
+     * Types of autofilter rules.
+     *
+     * @var string[]
+     */
+    private static array $filterTypes = [
+        self::AUTOFILTER_FILTERTYPE_FILTER,
+        self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER,
+        self::AUTOFILTER_FILTERTYPE_DYNAMICFILTER,
+        self::AUTOFILTER_FILTERTYPE_TOPTENFILTER,
+    ];
+    const AUTOFILTER_COLUMN_JOIN_AND = 'and';
+    const AUTOFILTER_COLUMN_JOIN_OR = 'or';
+    /**
+     * Join options for autofilter rules.
+     *
+     * @var string[]
+     */
+    private static array $ruleJoins = [
+        self::AUTOFILTER_COLUMN_JOIN_AND,
+        self::AUTOFILTER_COLUMN_JOIN_OR,
+    ];
+    /**
+     * Autofilter.
+     */
+    private ?AutoFilter $parent;
+    /**
+     * Autofilter Column Index.
+     */
+    private string $columnIndex;
+    /**
+     * Autofilter Column Filter Type.
+     */
+    private string $filterType = self::AUTOFILTER_FILTERTYPE_FILTER;
+    /**
+     * Autofilter Multiple Rules And/Or.
+     */
+    private string $join = self::AUTOFILTER_COLUMN_JOIN_OR;
+    /**
+     * Autofilter Column Rules.
+     *
+     * @var Column\Rule[]
+     */
+    private array $ruleset = [];
+    /**
+     * Autofilter Column Dynamic Attributes.
+     *
+     * @var (float|int|string)[]
+     */
+    private array $attributes = [];
+    /**
+     * Create a new Column.
+     *
+     * @param string $column Column (e.g. A)
+     * @param ?AutoFilter $parent Autofilter for this column
+     */
+    public function __construct(string $column, ?AutoFilter $parent = null)
+    {
+        $this->columnIndex = $column;
+        $this->parent = $parent;
+    }
+    public function setEvaluatedFalse(): void
+    {
+        if ($this->parent !== null) {
+            $this->parent->setEvaluated(false);
+        }
+    }
+    /**
+     * Get AutoFilter column index as string eg: 'A'.
+     */
+    public function getColumnIndex(): string
+    {
+        return $this->columnIndex;
+    }
+    /**
+     * Set AutoFilter column index as string eg: 'A'.
+     *
+     * @param string $column Column (e.g. A)
+     *
+     * @return $this
+     */
+    public function setColumnIndex(string $column): static
+    {
+        $this->setEvaluatedFalse();
+        $column = strtoupper($column);
+        if ($this->parent !== null) {
+            $this->parent->testColumnInRange($column);
+        }
+        $this->columnIndex = $column;
+        return $this;
+    }
+    /**
+     * Get this Column's AutoFilter Parent.
+     */
+    public function getParent(): ?AutoFilter
+    {
+        return $this->parent;
+    }
+    /**
+     * Set this Column's AutoFilter Parent.
+     *
+     * @return $this
+     */
+    public function setParent(?AutoFilter $parent = null): static
+    {
+        $this->setEvaluatedFalse();
+        $this->parent = $parent;
+        return $this;
+    }
+    /**
+     * Get AutoFilter Type.
+     */
+    public function getFilterType(): string
+    {
+        return $this->filterType;
+    }
+    /**
+     * Set AutoFilter Type.
+     *
+     * @return $this
+     */
+    public function setFilterType(string $filterType): static
+    {
+        $this->setEvaluatedFalse();
+        if (!in_array($filterType, self::$filterTypes)) {
+            throw new PhpSpreadsheetException('Invalid filter type for column AutoFilter.');
+        }
+        if ($filterType === self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER && count($this->ruleset) > 2) {
+            throw new PhpSpreadsheetException('No more than 2 rules are allowed in a Custom Filter');
+        }
+        $this->filterType = $filterType;
+        return $this;
+    }
+    /**
+     * Get AutoFilter Multiple Rules And/Or Join.
+     */
+    public function getJoin(): string
+    {
+        return $this->join;
+    }
+    /**
+     * Set AutoFilter Multiple Rules And/Or.
+     *
+     * @param string $join And/Or
+     *
+     * @return $this
+     */
+    public function setJoin(string $join): static
+    {
+        $this->setEvaluatedFalse();
+        $join = strtolower($join);
+        if (!in_array($join, self::$ruleJoins)) {
+            throw new PhpSpreadsheetException('Invalid rule connection for column AutoFilter.');
+        }
+        $this->join = $join;
+        return $this;
+    }
+    /**
+     * Set AutoFilter Attributes.
+     *
+     * @param (float|int|string)[] $attributes
+     *
+     * @return $this
+     */
+    public function setAttributes(array $attributes): static
+    {
+        $this->setEvaluatedFalse();
+        $this->attributes = $attributes;
+        return $this;
+    }
+    /**
+     * Set An AutoFilter Attribute.
+     *
+     * @param string $name Attribute Name
+     * @param float|int|string $value Attribute Value
+     *
+     * @return $this
+     */
+    public function setAttribute(string $name, $value): static
+    {
+        $this->setEvaluatedFalse();
+        $this->attributes[$name] = $value;
+        return $this;
+    }
+    /**
+     * Get AutoFilter Column Attributes.
+     *
+     * @return (float|int|string)[]
+     */
+    public function getAttributes(): array
+    {
+        return $this->attributes;
+    }
+    /**
+     * Get specific AutoFilter Column Attribute.
+     *
+     * @param string $name Attribute Name
+     */
+    public function getAttribute(string $name): null|float|int|string
+    {
+        if (isset($this->attributes[$name])) {
+            return $this->attributes[$name];
+        }
+        return null;
+    }
+    public function ruleCount(): int
+    {
+        return count($this->ruleset);
+    }
+    /**
+     * Get all AutoFilter Column Rules.
+     *
+     * @return Column\Rule[]
+     */
+    public function getRules(): array
+    {
+        return $this->ruleset;
+    }
+    /**
+     * Get a specified AutoFilter Column Rule.
+     *
+     * @param int $index Rule index in the ruleset array
+     */
+    public function getRule(int $index): Column\Rule
+    {
+        if (!isset($this->ruleset[$index])) {
+            $this->ruleset[$index] = new Column\Rule($this);
+        }
+        return $this->ruleset[$index];
+    }
+    /**
+     * Create a new AutoFilter Column Rule in the ruleset.
+     */
+    public function createRule(): Column\Rule
+    {
+        $this->setEvaluatedFalse();
+        if ($this->filterType === self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER && count($this->ruleset) >= 2) {
+            throw new PhpSpreadsheetException('No more than 2 rules are allowed in a Custom Filter');
+        }
+        $this->ruleset[] = new Column\Rule($this);
+        return end($this->ruleset);
+    }
+    /**
+     * Add a new AutoFilter Column Rule to the ruleset.
+     *
+     * @return $this
+     */
+    public function addRule(Column\Rule $rule): static
+    {
+        $this->setEvaluatedFalse();
+        $rule->setParent($this);
+        $this->ruleset[] = $rule;
+        return $this;
+    }
+    /**
+     * Delete a specified AutoFilter Column Rule
+     * If the number of rules is reduced to 1, then we reset And/Or logic to Or.
+     *
+     * @param int $index Rule index in the ruleset array
+     *
+     * @return $this
+     */
+    public function deleteRule(int $index): static
+    {
+        $this->setEvaluatedFalse();
+        if (isset($this->ruleset[$index])) {
+            unset($this->ruleset[$index]);
+            if (count($this->ruleset) <= 1) {
+                $this->setJoin(self::AUTOFILTER_COLUMN_JOIN_OR);
+            }
+        }
+        return $this;
+    }
+    /**
+     * Delete all AutoFilter Column Rules.
+     *
+     * @return $this
+     */
+    public function clearRules(): static
+    {
+        $this->setEvaluatedFalse();
+        $this->ruleset = [];
+        $this->setJoin(self::AUTOFILTER_COLUMN_JOIN_OR);
+        return $this;
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $vars = get_object_vars($this);
+        /** @var AutoFilter\Column\Rule[] $value */
+        foreach ($vars as $key => $value) {
+            if ($key === 'parent') {
+                $this->parent = null;
+            } elseif ($key === 'ruleset') {
+                $this->ruleset = [];
+                foreach ($value as $k => $v) {
+                    $cloned = clone $v;
+                    $cloned->setParent($this); // attach the new cloned Rule to this new cloned Autofilter Cloned object
+                    $this->ruleset[$k] = $cloned;
+                }
+            } else {
+                $this->$key = $value;
+            }
+        }
+    }
+}

--- a/src/PhpSpreadsheet/Worksheet/BaseDrawing.php
+++ b//dev/null
@@ -1,438 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Worksheet;
-use PhpOffice\PhpSpreadsheet\Cell\Hyperlink;
-use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
-use PhpOffice\PhpSpreadsheet\IComparable;
-use PhpOffice\PhpSpreadsheet\Worksheet\Drawing\Shadow;
-use SimpleXMLElement;
-class BaseDrawing implements IComparable
-{
-    const EDIT_AS_ABSOLUTE = 'absolute';
-    const EDIT_AS_ONECELL = 'oneCell';
-    const EDIT_AS_TWOCELL = 'twoCell';
-    private const VALID_EDIT_AS = [
-        self::EDIT_AS_ABSOLUTE,
-        self::EDIT_AS_ONECELL,
-        self::EDIT_AS_TWOCELL,
-    ];
-    /**
-     * The editAs attribute, used only with two cell anchor.
-     */
-    protected string $editAs = '';
-    /**
-     * Image counter.
-     */
-    private static int $imageCounter = 0;
-    /**
-     * Image index.
-     */
-    private int $imageIndex;
-    /**
-     * Name.
-     */
-    protected string $name = '';
-    /**
-     * Description.
-     */
-    protected string $description = '';
-    /**
-     * Worksheet.
-     */
-    protected ?Worksheet $worksheet = null;
-    /**
-     * Coordinates.
-     */
-    protected string $coordinates = 'A1';
-    /**
-     * Offset X.
-     */
-    protected int $offsetX = 0;
-    /**
-     * Offset Y.
-     */
-    protected int $offsetY = 0;
-    /**
-     * Coordinates2.
-     */
-    protected string $coordinates2 = '';
-    /**
-     * Offset X2.
-     */
-    protected int $offsetX2 = 0;
-    /**
-     * Offset Y2.
-     */
-    protected int $offsetY2 = 0;
-    /**
-     * Width.
-     */
-    protected int $width = 0;
-    /**
-     * Height.
-     */
-    protected int $height = 0;
-    /**
-     * Pixel width of image. See $width for the size the Drawing will be in the sheet.
-     */
-    protected int $imageWidth = 0;
-    /**
-     * Pixel width of image. See $height for the size the Drawing will be in the sheet.
-     */
-    protected int $imageHeight = 0;
-    /**
-     * Proportional resize.
-     */
-    protected bool $resizeProportional = true;
-    /**
-     * Rotation.
-     */
-    protected int $rotation = 0;
-    protected bool $flipVertical = false;
-    protected bool $flipHorizontal = false;
-    /**
-     * Shadow.
-     */
-    protected Shadow $shadow;
-    /**
-     * Image hyperlink.
-     */
-    private ?Hyperlink $hyperlink = null;
-    /**
-     * Image type.
-     */
-    protected int $type = IMAGETYPE_UNKNOWN;
-    /** @var null|SimpleXMLElement|string[] */
-    protected $srcRect = [];
-    /**
-     * Create a new BaseDrawing.
-     */
-    public function __construct()
-    {
-        $this->setShadow();
-        ++self::$imageCounter;
-        $this->imageIndex = self::$imageCounter;
-    }
-    public function __destruct()
-    {
-        $this->worksheet = null;
-    }
-    public function getImageIndex(): int
-    {
-        return $this->imageIndex;
-    }
-    public function getName(): string
-    {
-        return $this->name;
-    }
-    public function setName(string $name): self
-    {
-        $this->name = $name;
-        return $this;
-    }
-    public function getDescription(): string
-    {
-        return $this->description;
-    }
-    public function setDescription(string $description): self
-    {
-        $this->description = $description;
-        return $this;
-    }
-    public function getWorksheet(): ?Worksheet
-    {
-        return $this->worksheet;
-    }
-    /**
-     * Set Worksheet.
-     *
-     * @param bool $overrideOld If a Worksheet has already been assigned, overwrite it and remove image from old Worksheet?
-     */
-    public function setWorksheet(?Worksheet $worksheet = null, bool $overrideOld = false): self
-    {
-        if ($this->worksheet === null) {
-            if ($worksheet !== null && !($this instanceof Drawing && $this->getPath() === '')) {
-                $this->worksheet = $worksheet;
-                $this->worksheet->getCell($this->coordinates);
-                $this->worksheet->getDrawingCollection()->append($this);
-            }
-        } else {
-            if ($overrideOld) {
-                $iterator = $this->worksheet->getDrawingCollection()->getIterator();
-                while ($iterator->valid()) {
-                    if ($iterator->current()->getHashCode() === $this->getHashCode()) {
-                        $this->worksheet->getDrawingCollection()->offsetUnset($iterator->key());
-                        $this->worksheet = null;
-                        break;
-                    }
-                }
-                $this->setWorksheet($worksheet);
-            } else {
-                throw new PhpSpreadsheetException('A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.');
-            }
-        }
-        return $this;
-    }
-    public function getCoordinates(): string
-    {
-        return $this->coordinates;
-    }
-    public function setCoordinates(string $coordinates): self
-    {
-        $this->coordinates = $coordinates;
-        return $this;
-    }
-    public function getOffsetX(): int
-    {
-        return $this->offsetX;
-    }
-    public function setOffsetX(int $offsetX): self
-    {
-        $this->offsetX = $offsetX;
-        return $this;
-    }
-    public function getOffsetY(): int
-    {
-        return $this->offsetY;
-    }
-    public function setOffsetY(int $offsetY): self
-    {
-        $this->offsetY = $offsetY;
-        return $this;
-    }
-    public function getCoordinates2(): string
-    {
-        return $this->coordinates2;
-    }
-    public function setCoordinates2(string $coordinates2): self
-    {
-        $this->coordinates2 = $coordinates2;
-        return $this;
-    }
-    public function getOffsetX2(): int
-    {
-        return $this->offsetX2;
-    }
-    public function setOffsetX2(int $offsetX2): self
-    {
-        $this->offsetX2 = $offsetX2;
-        return $this;
-    }
-    public function getOffsetY2(): int
-    {
-        return $this->offsetY2;
-    }
-    public function setOffsetY2(int $offsetY2): self
-    {
-        $this->offsetY2 = $offsetY2;
-        return $this;
-    }
-    public function getWidth(): int
-    {
-        return $this->width;
-    }
-    public function setWidth(int $width): self
-    {
-        if ($this->resizeProportional && $width != 0) {
-            $ratio = $this->height / ($this->width != 0 ? $this->width : 1);
-            $this->height = (int) round($ratio * $width);
-        }
-        $this->width = $width;
-        return $this;
-    }
-    public function getHeight(): int
-    {
-        return $this->height;
-    }
-    public function setHeight(int $height): self
-    {
-        if ($this->resizeProportional && $height != 0) {
-            $ratio = $this->width / ($this->height != 0 ? $this->height : 1);
-            $this->width = (int) round($ratio * $height);
-        }
-        $this->height = $height;
-        return $this;
-    }
-    /**
-     * Set width and height with proportional resize.
-     *
-     * Example:
-     * <code>
-     * $objDrawing->setResizeProportional(true);
-     * $objDrawing->setWidthAndHeight(160,120);
-     * </code>
-     *
-     * @author Vincent@luo MSN:kele_100@hotmail.com
-     */
-    public function setWidthAndHeight(int $width, int $height): self
-    {
-        $xratio = $width / ($this->width != 0 ? $this->width : 1);
-        $yratio = $height / ($this->height != 0 ? $this->height : 1);
-        if ($this->resizeProportional && !($width == 0 || $height == 0)) {
-            if (($xratio * $this->height) < $height) {
-                $this->height = (int) ceil($xratio * $this->height);
-                $this->width = $width;
-            } else {
-                $this->width = (int) ceil($yratio * $this->width);
-                $this->height = $height;
-            }
-        } else {
-            $this->width = $width;
-            $this->height = $height;
-        }
-        return $this;
-    }
-    public function getResizeProportional(): bool
-    {
-        return $this->resizeProportional;
-    }
-    public function setResizeProportional(bool $resizeProportional): self
-    {
-        $this->resizeProportional = $resizeProportional;
-        return $this;
-    }
-    public function getRotation(): int
-    {
-        return $this->rotation;
-    }
-    public function setRotation(int $rotation): self
-    {
-        $this->rotation = $rotation;
-        return $this;
-    }
-    public function getShadow(): Shadow
-    {
-        return $this->shadow;
-    }
-    public function setShadow(?Shadow $shadow = null): self
-    {
-        $this->shadow = $shadow ?? new Shadow();
-        return $this;
-    }
-    /**
-     * Get hash code.
-     *
-     * @return string Hash code
-     */
-    public function getHashCode(): string
-    {
-        return md5(
-            $this->name
-            . $this->description
-            . (($this->worksheet === null) ? '' : $this->worksheet->getHashCode())
-            . $this->coordinates
-            . $this->offsetX
-            . $this->offsetY
-            . $this->coordinates2
-            . $this->offsetX2
-            . $this->offsetY2
-            . $this->width
-            . $this->height
-            . $this->rotation
-            . $this->shadow->getHashCode()
-            . __CLASS__
-        );
-    }
-    /**
-     * Implement PHP __clone to create a deep clone, not just a shallow copy.
-     */
-    public function __clone()
-    {
-        $vars = get_object_vars($this);
-        foreach ($vars as $key => $value) {
-            if ($key == 'worksheet') {
-                $this->worksheet = null;
-            } elseif (is_object($value)) {
-                $this->$key = clone $value;
-            } else {
-                $this->$key = $value;
-            }
-        }
-    }
-    public function setHyperlink(?Hyperlink $hyperlink = null): void
-    {
-        $this->hyperlink = $hyperlink;
-    }
-    public function getHyperlink(): ?Hyperlink
-    {
-        return $this->hyperlink;
-    }
-    /**
-     * Set Fact Sizes and Type of Image.
-     */
-    protected function setSizesAndType(string $path): void
-    {
-        if ($this->imageWidth === 0 && $this->imageHeight === 0 && $this->type === IMAGETYPE_UNKNOWN) {
-            $imageData = getimagesize($path);
-            if (!empty($imageData)) {
-                $this->imageWidth = $imageData[0];
-                $this->imageHeight = $imageData[1];
-                $this->type = $imageData[2];
-            }
-        }
-        if ($this->width === 0 && $this->height === 0) {
-            $this->width = $this->imageWidth;
-            $this->height = $this->imageHeight;
-        }
-    }
-    /**
-     * Get Image Type.
-     */
-    public function getType(): int
-    {
-        return $this->type;
-    }
-    public function getImageWidth(): int
-    {
-        return $this->imageWidth;
-    }
-    public function getImageHeight(): int
-    {
-        return $this->imageHeight;
-    }
-    public function getEditAs(): string
-    {
-        return $this->editAs;
-    }
-    public function setEditAs(string $editAs): self
-    {
-        $this->editAs = $editAs;
-        return $this;
-    }
-    public function validEditAs(): bool
-    {
-        return in_array($this->editAs, self::VALID_EDIT_AS, true);
-    }
-    /**
-     * @return null|SimpleXMLElement|string[]
-     */
-    public function getSrcRect()
-    {
-        return $this->srcRect;
-    }
-    /**
-     * @param null|SimpleXMLElement|string[] $srcRect
-     */
-    public function setSrcRect($srcRect): self
-    {
-        $this->srcRect = $srcRect;
-        return $this;
-    }
-    public function setFlipHorizontal(bool $flipHorizontal): self
-    {
-        $this->flipHorizontal = $flipHorizontal;
-        return $this;
-    }
-    public function getFlipHorizontal(): bool
-    {
-        return $this->flipHorizontal;
-    }
-    public function setFlipVertical(bool $flipVertical): self
-    {
-        $this->flipVertical = $flipVertical;
-        return $this;
-    }
-    public function getFlipVertical(): bool
-    {
-        return $this->flipVertical;
-    }
-}

--- a/src/PhpSpreadsheet/Worksheet/Drawing.php
+++ b//dev/null
@@ -1,203 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Worksheet;
-use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
-use ZipArchive;
-class Drawing extends BaseDrawing
-{
-    const IMAGE_TYPES_CONVERTION_MAP = [
-        IMAGETYPE_GIF => IMAGETYPE_PNG,
-        IMAGETYPE_JPEG => IMAGETYPE_JPEG,
-        IMAGETYPE_PNG => IMAGETYPE_PNG,
-        IMAGETYPE_BMP => IMAGETYPE_PNG,
-    ];
-    /**
-     * Path.
-     */
-    private string $path;
-    /**
-     * Whether or not we are dealing with a URL.
-     */
-    private bool $isUrl;
-    /**
-     * Create a new Drawing.
-     */
-    public function __construct()
-    {
-        $this->path = '';
-        $this->isUrl = false;
-        parent::__construct();
-    }
-    /**
-     * Get Filename.
-     */
-    public function getFilename(): string
-    {
-        return basename($this->path);
-    }
-    /**
-     * Get indexed filename (using image index).
-     */
-    public function getIndexedFilename(): string
-    {
-        return md5($this->path) . '.' . $this->getExtension();
-    }
-    /**
-     * Get Extension.
-     */
-    public function getExtension(): string
-    {
-        $exploded = explode('.', basename($this->path));
-        return $exploded[count($exploded) - 1];
-    }
-    /**
-     * Get full filepath to store drawing in zip archive.
-     */
-    public function getMediaFilename(): string
-    {
-        if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
-            throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
-        }
-        return sprintf('image%d%s', $this->getImageIndex(), $this->getImageFileExtensionForSave());
-    }
-    /**
-     * Get Path.
-     */
-    public function getPath(): string
-    {
-        return $this->path;
-    }
-    /**
-     * Set Path.
-     *
-     * @param string $path File path
-     * @param bool $verifyFile Verify file
-     * @param ?ZipArchive $zip Zip archive instance
-     *
-     * @return $this
-     */
-    public function setPath(string $path, bool $verifyFile = true, ?ZipArchive $zip = null): static
-    {
-        $this->isUrl = false;
-        if (preg_match('~^data:image/[a-z]+;base64,~', $path) === 1) {
-            $this->path = $path;
-            return $this;
-        }
-        $this->path = '';
-        if (filter_var($path, FILTER_VALIDATE_URL)) {
-            if (!preg_match('/^(http|https|file|ftp|s3):/', $path)) {
-                throw new PhpSpreadsheetException('Invalid protocol for linked drawing');
-            }
-            $this->isUrl = true;
-            $ctx = null;
-            if (str_starts_with($path, 'https:')) {
-                $ctx = stream_context_create(['ssl' => ['crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT]]);
-            }
-            $imageContents = @file_get_contents($path, false, $ctx);
-            if ($imageContents !== false) {
-                $filePath = tempnam(sys_get_temp_dir(), 'Drawing');
-                if ($filePath) {
-                    $put = @file_put_contents($filePath, $imageContents);
-                    if ($put !== false) {
-                        if ($this->isImage($filePath)) {
-                            $this->path = $path;
-                            $this->setSizesAndType($filePath);
-                        }
-                        unlink($filePath);
-                    }
-                }
-            }
-        } elseif ($zip instanceof ZipArchive) {
-            $zipPath = explode('#', $path)[1];
-            $locate = @$zip->locateName($zipPath);
-            if ($locate !== false) {
-                if ($this->isImage($path)) {
-                    $this->path = $path;
-                    $this->setSizesAndType($path);
-                }
-            }
-        } else {
-            $exists = @file_exists($path);
-            if ($exists !== false && $this->isImage($path)) {
-                $this->path = $path;
-                $this->setSizesAndType($path);
-            }
-        }
-        if ($this->path === '' && $verifyFile) {
-            throw new PhpSpreadsheetException("File $path not found!");
-        }
-        return $this;
-    }
-    private function isImage(string $path): bool
-    {
-        $mime = (string) @mime_content_type($path);
-        $retVal = false;
-        if (str_starts_with($mime, 'image/')) {
-            $retVal = true;
-        } elseif ($mime === 'application/octet-stream') {
-            $extension = pathinfo($path, PATHINFO_EXTENSION);
-            $retVal = in_array($extension, ['bin', 'emf'], true);
-        }
-        return $retVal;
-    }
-    /**
-     * Get isURL.
-     */
-    public function getIsURL(): bool
-    {
-        return $this->isUrl;
-    }
-    /**
-     * Set isURL.
-     *
-     * @return $this
-     */
-    public function setIsURL(bool $isUrl): self
-    {
-        $this->isUrl = $isUrl;
-        return $this;
-    }
-    /**
-     * Get hash code.
-     *
-     * @return string Hash code
-     */
-    public function getHashCode(): string
-    {
-        return md5(
-            $this->path
-            . parent::getHashCode()
-            . __CLASS__
-        );
-    }
-    /**
-     * Get Image Type for Save.
-     */
-    public function getImageTypeForSave(): int
-    {
-        if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
-            throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
-        }
-        return self::IMAGE_TYPES_CONVERTION_MAP[$this->type];
-    }
-    /**
-     * Get Image file extention for Save.
-     */
-    public function getImageFileExtensionForSave(bool $includeDot = true): string
-    {
-        if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
-            throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
-        }
-        $result = image_type_to_extension(self::IMAGE_TYPES_CONVERTION_MAP[$this->type], $includeDot);
-        return "$result";
-    }
-    /**
-     * Get Image mime type.
-     */
-    public function getImageMimeType(): string
-    {
-        if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
-            throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
-        }
-        return image_type_to_mime_type(self::IMAGE_TYPES_CONVERTION_MAP[$this->type]);
-    }
-}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Worksheet/MemoryDrawing.php
@@ -0,0 +1,268 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Worksheet;
+use GdImage;
+use PhpOffice\PhpSpreadsheet\Exception;
+use PhpOffice\PhpSpreadsheet\Shared\File;
+class MemoryDrawing extends BaseDrawing
+{
+    const RENDERING_DEFAULT = 'imagepng';
+    const RENDERING_PNG = 'imagepng';
+    const RENDERING_GIF = 'imagegif';
+    const RENDERING_JPEG = 'imagejpeg';
+    const MIMETYPE_DEFAULT = 'image/png';
+    const MIMETYPE_PNG = 'image/png';
+    const MIMETYPE_GIF = 'image/gif';
+    const MIMETYPE_JPEG = 'image/jpeg';
+    const SUPPORTED_MIME_TYPES = [
+        self::MIMETYPE_GIF,
+        self::MIMETYPE_JPEG,
+        self::MIMETYPE_PNG,
+    ];
+    /**
+     * Image resource.
+     */
+    private null|GdImage $imageResource = null;
+    /**
+     * Rendering function.
+     */
+    private string $renderingFunction;
+    /**
+     * Mime type.
+     */
+    private string $mimeType;
+    /**
+     * Unique name.
+     */
+    private string $uniqueName;
+    /**
+     * Create a new MemoryDrawing.
+     */
+    public function __construct()
+    {
+        $this->renderingFunction = self::RENDERING_DEFAULT;
+        $this->mimeType = self::MIMETYPE_DEFAULT;
+        $this->uniqueName = md5(mt_rand(0, 9999) . time() . mt_rand(0, 9999));
+        parent::__construct();
+    }
+    public function __destruct()
+    {
+        if ($this->imageResource) {
+            @imagedestroy($this->imageResource);
+            $this->imageResource = null;
+        }
+        $this->worksheet = null;
+    }
+    public function __clone()
+    {
+        parent::__clone();
+        $this->cloneResource();
+    }
+    private function cloneResource(): void
+    {
+        if (!$this->imageResource) {
+            return;
+        }
+        $width = (int) imagesx($this->imageResource);
+        $height = (int) imagesy($this->imageResource);
+        if (imageistruecolor($this->imageResource)) {
+            $clone = imagecreatetruecolor($width, $height);
+            if (!$clone) {
+                throw new Exception('Could not clone image resource');
+            }
+            imagealphablending($clone, false);
+            imagesavealpha($clone, true);
+        } else {
+            $clone = imagecreate($width, $height);
+            if (!$clone) {
+                throw new Exception('Could not clone image resource');
+            }
+            $transparent = imagecolortransparent($this->imageResource);
+            if ($transparent >= 0) {
+                $rgb = imagecolorsforindex($this->imageResource, $transparent);
+                imagesavealpha($clone, true);
+                $color = imagecolorallocatealpha($clone, $rgb['red'], $rgb['green'], $rgb['blue'], $rgb['alpha']);
+                if ($color === false) {
+                    throw new Exception('Could not get image alpha color');
+                }
+                imagefill($clone, 0, 0, $color);
+            }
+        }
+        imagecopy($clone, $this->imageResource, 0, 0, 0, 0, $width, $height);
+        $this->imageResource = $clone;
+    }
+    /**
+     * @param resource $imageStream Stream data to be converted to a Memory Drawing
+     *
+     * @throws Exception
+     */
+    public static function fromStream($imageStream): self
+    {
+        $streamValue = stream_get_contents($imageStream);
+        if ($streamValue === false) {
+            throw new Exception('Unable to read data from stream');
+        }
+        return self::fromString($streamValue);
+    }
+    /**
+     * @param string $imageString String data to be converted to a Memory Drawing
+     *
+     * @throws Exception
+     */
+    public static function fromString(string $imageString): self
+    {
+        $gdImage = @imagecreatefromstring($imageString);
+        if ($gdImage === false) {
+            throw new Exception('Value cannot be converted to an image');
+        }
+        $mimeType = self::identifyMimeType($imageString);
+        if (imageistruecolor($gdImage) || imagecolortransparent($gdImage) >= 0) {
+            imagesavealpha($gdImage, true);
+        }
+        $renderingFunction = self::identifyRenderingFunction($mimeType);
+        $drawing = new self();
+        $drawing->setImageResource($gdImage);
+        $drawing->setRenderingFunction($renderingFunction);
+        $drawing->setMimeType($mimeType);
+        return $drawing;
+    }
+    private static function identifyRenderingFunction(string $mimeType): string
+    {
+        return match ($mimeType) {
+            self::MIMETYPE_PNG => self::RENDERING_PNG,
+            self::MIMETYPE_JPEG => self::RENDERING_JPEG,
+            self::MIMETYPE_GIF => self::RENDERING_GIF,
+            default => self::RENDERING_DEFAULT,
+        };
+    }
+    /**
+     * @throws Exception
+     */
+    private static function identifyMimeType(string $imageString): string
+    {
+        $temporaryFileName = File::temporaryFilename();
+        file_put_contents($temporaryFileName, $imageString);
+        $mimeType = self::identifyMimeTypeUsingExif($temporaryFileName);
+        if ($mimeType !== null) {
+            unlink($temporaryFileName);
+            return $mimeType;
+        }
+        $mimeType = self::identifyMimeTypeUsingGd($temporaryFileName);
+        if ($mimeType !== null) {
+            unlink($temporaryFileName);
+            return $mimeType;
+        }
+        unlink($temporaryFileName);
+        return self::MIMETYPE_DEFAULT;
+    }
+    private static function identifyMimeTypeUsingExif(string $temporaryFileName): ?string
+    {
+        if (function_exists('exif_imagetype')) {
+            $imageType = @exif_imagetype($temporaryFileName);
+            $mimeType = ($imageType) ? image_type_to_mime_type($imageType) : null;
+            return self::supportedMimeTypes($mimeType);
+        }
+        return null;
+    }
+    private static function identifyMimeTypeUsingGd(string $temporaryFileName): ?string
+    {
+        if (function_exists('getimagesize')) {
+            $imageSize = @getimagesize($temporaryFileName);
+            if (is_array($imageSize)) {
+                $mimeType = $imageSize['mime'];
+                return self::supportedMimeTypes($mimeType);
+            }
+        }
+        return null;
+    }
+    private static function supportedMimeTypes(?string $mimeType = null): ?string
+    {
+        if (in_array($mimeType, self::SUPPORTED_MIME_TYPES, true)) {
+            return $mimeType;
+        }
+        return null;
+    }
+    /**
+     * Get image resource.
+     */
+    public function getImageResource(): ?GdImage
+    {
+        return $this->imageResource;
+    }
+    /**
+     * Set image resource.
+     *
+     * @return $this
+     */
+    public function setImageResource(?GdImage $value): static
+    {
+        $this->imageResource = $value;
+        if ($this->imageResource !== null) {
+            $this->width = (int) imagesx($this->imageResource);
+            $this->height = (int) imagesy($this->imageResource);
+        }
+        return $this;
+    }
+    /**
+     * Get rendering function.
+     */
+    public function getRenderingFunction(): string
+    {
+        return $this->renderingFunction;
+    }
+    /**
+     * Set rendering function.
+     *
+     * @param string $value see self::RENDERING_*
+     *
+     * @return $this
+     */
+    public function setRenderingFunction(string $value): static
+    {
+        $this->renderingFunction = $value;
+        return $this;
+    }
+    /**
+     * Get mime type.
+     */
+    public function getMimeType(): string
+    {
+        return $this->mimeType;
+    }
+    /**
+     * Set mime type.
+     *
+     * @param string $value see self::MIMETYPE_*
+     *
+     * @return $this
+     */
+    public function setMimeType(string $value): static
+    {
+        $this->mimeType = $value;
+        return $this;
+    }
+    /**
+     * Get indexed filename (using image index).
+     */
+    public function getIndexedFilename(): string
+    {
+        $extension = strtolower($this->getMimeType());
+        $extension = explode('/', $extension);
+        $extension = $extension[1];
+        return $this->uniqueName . $this->getImageIndex() . '.' . $extension;
+    }
+    /**
+     * Get hash code.
+     *
+     * @return string Hash code
+     */
+    public function getHashCode(): string
+    {
+        return md5(
+            $this->renderingFunction
+            . $this->mimeType
+            . $this->uniqueName
+            . parent::getHashCode()
+            . __CLASS__
+        );
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Worksheet/Table.php
@@ -0,0 +1,488 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Worksheet;
+use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
+use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Worksheet\Table\TableStyle;
+use Stringable;
+class Table implements Stringable
+{
+    /**
+     * Table Name.
+     */
+    private string $name;
+    /**
+     * Show Header Row.
+     */
+    private bool $showHeaderRow = true;
+    /**
+     * Show Totals Row.
+     */
+    private bool $showTotalsRow = false;
+    /**
+     * Table Range.
+     */
+    private string $range = '';
+    /**
+     * Table Worksheet.
+     */
+    private ?Worksheet $workSheet = null;
+    /**
+     * Table allow filter.
+     */
+    private bool $allowFilter = true;
+    /**
+     * Table Column.
+     *
+     * @var Table\Column[]
+     */
+    private array $columns = [];
+    /**
+     * Table Style.
+     */
+    private TableStyle $style;
+    /**
+     * Table AutoFilter.
+     */
+    private AutoFilter $autoFilter;
+    /**
+     * Create a new Table.
+     *
+     * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
+     *            A simple string containing a Cell range like 'A1:E10' is permitted
+     *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
+     *              or an AddressRange object.
+     * @param string $name (e.g. Table1)
+     */
+    public function __construct(AddressRange|string|array $range = '', string $name = '')
+    {
+        $this->style = new TableStyle();
+        $this->autoFilter = new AutoFilter($range);
+        $this->setRange($range);
+        $this->setName($name);
+    }
+    /**
+     * Code to execute when this table is unset().
+     */
+    public function __destruct()
+    {
+        $this->workSheet = null;
+    }
+    /**
+     * Get Table name.
+     */
+    public function getName(): string
+    {
+        return $this->name;
+    }
+    /**
+     * Set Table name.
+     *
+     * @throws PhpSpreadsheetException
+     */
+    public function setName(string $name): self
+    {
+        $name = trim($name);
+        if (!empty($name)) {
+            if (strlen($name) === 1 && in_array($name, ['C', 'c', 'R', 'r'])) {
+                throw new PhpSpreadsheetException('The table name is invalid');
+            }
+            if (StringHelper::countCharacters($name) > 255) {
+                throw new PhpSpreadsheetException('The table name cannot be longer than 255 characters');
+            }
+            if (
+                preg_match(Coordinate::A1_COORDINATE_REGEX, $name)
+                || preg_match('/^R\[?\-?[0-9]*\]?C\[?\-?[0-9]*\]?$/i', $name)
+            ) {
+                throw new PhpSpreadsheetException('The table name can\'t be the same as a cell reference');
+            }
+            if (!preg_match('/^[\p{L}_\\\\]/iu', $name)) {
+                throw new PhpSpreadsheetException('The table name must begin a name with a letter, an underscore character (_), or a backslash (\)');
+            }
+            if (!preg_match('/^[\p{L}_\\\\][\p{L}\p{M}0-9\._]+$/iu', $name)) {
+                throw new PhpSpreadsheetException('The table name contains invalid characters');
+            }
+            $this->checkForDuplicateTableNames($name, $this->workSheet);
+            $this->updateStructuredReferences($name);
+        }
+        $this->name = $name;
+        return $this;
+    }
+    /**
+     * @throws PhpSpreadsheetException
+     */
+    private function checkForDuplicateTableNames(string $name, ?Worksheet $worksheet): void
+    {
+        $tableName = StringHelper::strToLower($name);
+        if ($worksheet !== null && StringHelper::strToLower($this->name) !== $name) {
+            $spreadsheet = $worksheet->getParentOrThrow();
+            foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
+                foreach ($sheet->getTableCollection() as $table) {
+                    if (StringHelper::strToLower($table->getName()) === $tableName && $table != $this) {
+                        throw new PhpSpreadsheetException("Spreadsheet already contains a table named '{$this->name}'");
+                    }
+                }
+            }
+        }
+    }
+    private function updateStructuredReferences(string $name): void
+    {
+        if (!$this->workSheet || !$this->name) {
+            return;
+        }
+        if (StringHelper::strToLower($this->name) !== StringHelper::strToLower($name)) {
+            $spreadsheet = $this->workSheet->getParentOrThrow();
+            foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
+                $this->updateStructuredReferencesInCells($sheet, $name);
+            }
+            $this->updateStructuredReferencesInNamedFormulae($spreadsheet, $name);
+        }
+    }
+    private function updateStructuredReferencesInCells(Worksheet $worksheet, string $newName): void
+    {
+        $pattern = '/' . preg_quote($this->name, '/') . '\[/mui';
+        foreach ($worksheet->getCoordinates(false) as $coordinate) {
+            $cell = $worksheet->getCell($coordinate);
+            if ($cell->getDataType() === DataType::TYPE_FORMULA) {
+                $formula = $cell->getValueString();
+                if (preg_match($pattern, $formula) === 1) {
+                    $formula = preg_replace($pattern, "{$newName}[", $formula);
+                    $cell->setValueExplicit($formula, DataType::TYPE_FORMULA);
+                }
+            }
+        }
+    }
+    private function updateStructuredReferencesInNamedFormulae(Spreadsheet $spreadsheet, string $newName): void
+    {
+        $pattern = '/' . preg_quote($this->name, '/') . '\[/mui';
+        foreach ($spreadsheet->getNamedFormulae() as $namedFormula) {
+            $formula = $namedFormula->getValue();
+            if (preg_match($pattern, $formula) === 1) {
+                $formula = preg_replace($pattern, "{$newName}[", $formula) ?? '';
+                $namedFormula->setValue($formula);
+            }
+        }
+    }
+    /**
+     * Get show Header Row.
+     */
+    public function getShowHeaderRow(): bool
+    {
+        return $this->showHeaderRow;
+    }
+    /**
+     * Set show Header Row.
+     */
+    public function setShowHeaderRow(bool $showHeaderRow): self
+    {
+        $this->showHeaderRow = $showHeaderRow;
+        return $this;
+    }
+    /**
+     * Get show Totals Row.
+     */
+    public function getShowTotalsRow(): bool
+    {
+        return $this->showTotalsRow;
+    }
+    /**
+     * Set show Totals Row.
+     */
+    public function setShowTotalsRow(bool $showTotalsRow): self
+    {
+        $this->showTotalsRow = $showTotalsRow;
+        return $this;
+    }
+    /**
+     * Get allow filter.
+     * If false, autofiltering is disabled for the table, if true it is enabled.
+     */
+    public function getAllowFilter(): bool
+    {
+        return $this->allowFilter;
+    }
+    /**
+     * Set show Autofiltering.
+     * Disabling autofiltering has the same effect as hiding the filter button on all the columns in the table.
+     */
+    public function setAllowFilter(bool $allowFilter): self
+    {
+        $this->allowFilter = $allowFilter;
+        return $this;
+    }
+    /**
+     * Get Table Range.
+     */
+    public function getRange(): string
+    {
+        return $this->range;
+    }
+    /**
+     * Set Table Cell Range.
+     *
+     * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $range
+     *            A simple string containing a Cell range like 'A1:E10' is permitted
+     *              or passing in an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 8]),
+     *              or an AddressRange object.
+     */
+    public function setRange(AddressRange|string|array $range = ''): self
+    {
+        if ($range !== '') {
+            [, $range] = Worksheet::extractSheetTitle(Validations::validateCellRange($range), true);
+        }
+        if (empty($range)) {
+            $this->columns = [];
+            $this->range = '';
+            return $this;
+        }
+        if (!str_contains($range, ':')) {
+            throw new PhpSpreadsheetException('Table must be set on a range of cells.');
+        }
+        [$width, $height] = Coordinate::rangeDimension($range);
+        if ($width < 1 || $height < 1) {
+            throw new PhpSpreadsheetException('The table range must be at least 1 column and row');
+        }
+        $this->range = $range;
+        $this->autoFilter->setRange($range);
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        foreach ($this->columns as $key => $value) {
+            $colIndex = Coordinate::columnIndexFromString($key);
+            if (($rangeStart[0] > $colIndex) || ($rangeEnd[0] < $colIndex)) {
+                unset($this->columns[$key]);
+            }
+        }
+        return $this;
+    }
+    /**
+     * Set Table Cell Range to max row.
+     */
+    public function setRangeToMaxRow(): self
+    {
+        if ($this->workSheet !== null) {
+            $thisrange = $this->range;
+            $range = (string) preg_replace('/\\d+$/', (string) $this->workSheet->getHighestRow(), $thisrange);
+            if ($range !== $thisrange) {
+                $this->setRange($range);
+            }
+        }
+        return $this;
+    }
+    /**
+     * Get Table's Worksheet.
+     */
+    public function getWorksheet(): ?Worksheet
+    {
+        return $this->workSheet;
+    }
+    /**
+     * Set Table's Worksheet.
+     */
+    public function setWorksheet(?Worksheet $worksheet = null): self
+    {
+        if ($this->name !== '' && $worksheet !== null) {
+            $spreadsheet = $worksheet->getParentOrThrow();
+            $tableName = StringHelper::strToUpper($this->name);
+            foreach ($spreadsheet->getWorksheetIterator() as $sheet) {
+                foreach ($sheet->getTableCollection() as $table) {
+                    if (StringHelper::strToUpper($table->getName()) === $tableName) {
+                        throw new PhpSpreadsheetException("Workbook already contains a table named '{$this->name}'");
+                    }
+                }
+            }
+        }
+        $this->workSheet = $worksheet;
+        $this->autoFilter->setParent($worksheet);
+        return $this;
+    }
+    /**
+     * Get all Table Columns.
+     *
+     * @return Table\Column[]
+     */
+    public function getColumns(): array
+    {
+        return $this->columns;
+    }
+    /**
+     * Validate that the specified column is in the Table range.
+     *
+     * @param string $column Column name (e.g. A)
+     *
+     * @return int The column offset within the table range
+     */
+    public function isColumnInRange(string $column): int
+    {
+        if (empty($this->range)) {
+            throw new PhpSpreadsheetException('No table range is defined.');
+        }
+        $columnIndex = Coordinate::columnIndexFromString($column);
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        if (($rangeStart[0] > $columnIndex) || ($rangeEnd[0] < $columnIndex)) {
+            throw new PhpSpreadsheetException('Column is outside of current table range.');
+        }
+        return $columnIndex - $rangeStart[0];
+    }
+    /**
+     * Get a specified Table Column Offset within the defined Table range.
+     *
+     * @param string $column Column name (e.g. A)
+     *
+     * @return int The offset of the specified column within the table range
+     */
+    public function getColumnOffset(string $column): int
+    {
+        return $this->isColumnInRange($column);
+    }
+    /**
+     * Get a specified Table Column.
+     *
+     * @param string $column Column name (e.g. A)
+     */
+    public function getColumn(string $column): Table\Column
+    {
+        $this->isColumnInRange($column);
+        if (!isset($this->columns[$column])) {
+            $this->columns[$column] = new Table\Column($column, $this);
+        }
+        return $this->columns[$column];
+    }
+    /**
+     * Get a specified Table Column by it's offset.
+     *
+     * @param int $columnOffset Column offset within range (starting from 0)
+     */
+    public function getColumnByOffset(int $columnOffset): Table\Column
+    {
+        [$rangeStart, $rangeEnd] = Coordinate::rangeBoundaries($this->range);
+        $pColumn = Coordinate::stringFromColumnIndex($rangeStart[0] + $columnOffset);
+        return $this->getColumn($pColumn);
+    }
+    /**
+     * Set Table.
+     *
+     * @param string|Table\Column $columnObjectOrString
+     *            A simple string containing a Column ID like 'A' is permitted
+     */
+    public function setColumn(string|Table\Column $columnObjectOrString): self
+    {
+        if ((is_string($columnObjectOrString)) && (!empty($columnObjectOrString))) {
+            $column = $columnObjectOrString;
+        } elseif (is_object($columnObjectOrString) && ($columnObjectOrString instanceof Table\Column)) {
+            $column = $columnObjectOrString->getColumnIndex();
+        } else {
+            throw new PhpSpreadsheetException('Column is not within the table range.');
+        }
+        $this->isColumnInRange($column);
+        if (is_string($columnObjectOrString)) {
+            $this->columns[$columnObjectOrString] = new Table\Column($columnObjectOrString, $this);
+        } else {
+            $columnObjectOrString->setTable($this);
+            $this->columns[$column] = $columnObjectOrString;
+        }
+        ksort($this->columns);
+        return $this;
+    }
+    /**
+     * Clear a specified Table Column.
+     *
+     * @param string $column Column name (e.g. A)
+     */
+    public function clearColumn(string $column): self
+    {
+        $this->isColumnInRange($column);
+        if (isset($this->columns[$column])) {
+            unset($this->columns[$column]);
+        }
+        return $this;
+    }
+    /**
+     * Shift an Table Column Rule to a different column.
+     *
+     * Note: This method bypasses validation of the destination column to ensure it is within this Table range.
+     *        Nor does it verify whether any column rule already exists at $toColumn, but will simply override any existing value.
+     *        Use with caution.
+     *
+     * @param string $fromColumn Column name (e.g. A)
+     * @param string $toColumn Column name (e.g. B)
+     */
+    public function shiftColumn(string $fromColumn, string $toColumn): self
+    {
+        $fromColumn = strtoupper($fromColumn);
+        $toColumn = strtoupper($toColumn);
+        if (($fromColumn !== null) && (isset($this->columns[$fromColumn])) && ($toColumn !== null)) {
+            $this->columns[$fromColumn]->setTable();
+            $this->columns[$fromColumn]->setColumnIndex($toColumn);
+            $this->columns[$toColumn] = $this->columns[$fromColumn];
+            $this->columns[$toColumn]->setTable($this);
+            unset($this->columns[$fromColumn]);
+            ksort($this->columns);
+        }
+        return $this;
+    }
+    /**
+     * Get table Style.
+     */
+    public function getStyle(): TableStyle
+    {
+        return $this->style;
+    }
+    /**
+     * Set table Style.
+     */
+    public function setStyle(TableStyle $style): self
+    {
+        $this->style = $style;
+        return $this;
+    }
+    /**
+     * Get AutoFilter.
+     */
+    public function getAutoFilter(): AutoFilter
+    {
+        return $this->autoFilter;
+    }
+    /**
+     * Set AutoFilter.
+     */
+    public function setAutoFilter(AutoFilter $autoFilter): self
+    {
+        $this->autoFilter = $autoFilter;
+        return $this;
+    }
+    /**
+     * Implement PHP __clone to create a deep clone, not just a shallow copy.
+     */
+    public function __clone()
+    {
+        $vars = get_object_vars($this);
+        foreach ($vars as $key => $value) {
+            if (is_object($value)) {
+                if ($key === 'workSheet') {
+                    $this->{$key} = null;
+                } else {
+                    $this->{$key} = clone $value;
+                }
+            } elseif ((is_array($value)) && ($key === 'columns')) {
+                $this->{$key} = [];
+                foreach ($value as $k => $v) {
+                    $this->{$key}[$k] = clone $v;
+                    $this->{$key}[$k]->setTable($this);
+                }
+            } else {
+                $this->{$key} = $value;
+            }
+        }
+    }
+    /**
+     * toString method replicates previous behavior by returning the range if object is
+     * referenced as a property of its worksheet.
+     */
+    public function __toString(): string
+    {
+        return (string) $this->range;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Worksheet/Validations.php
@@ -0,0 +1,91 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Worksheet;
+use PhpOffice\PhpSpreadsheet\Cell\AddressRange;
+use PhpOffice\PhpSpreadsheet\Cell\CellAddress;
+use PhpOffice\PhpSpreadsheet\Cell\CellRange;
+use PhpOffice\PhpSpreadsheet\Exception as SpreadsheetException;
+class Validations
+{
+    /**
+     * Validate a cell address.
+     *
+     * @param null|array{0: int, 1: int}|CellAddress|string $cellAddress Coordinate of the cell as a string, eg: 'C5';
+     *               or as an array of [$columnIndex, $row] (e.g. [3, 5]), or a CellAddress object.
+     */
+    public static function validateCellAddress(null|CellAddress|string|array $cellAddress): string
+    {
+        if (is_string($cellAddress)) {
+            [$worksheet, $address] = Worksheet::extractSheetTitle($cellAddress, true);
+            return empty($worksheet) ? strtoupper("$address") : $worksheet . '!' . strtoupper("$address");
+        }
+        if (is_array($cellAddress)) {
+            $cellAddress = CellAddress::fromColumnRowArray($cellAddress);
+        }
+        return (string) $cellAddress;
+    }
+    /**
+     * Validate a cell address or cell range.
+     *
+     * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|CellAddress|int|string $cellRange Coordinate of the cells as a string, eg: 'C5:F12';
+     *               or as an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 12]),
+     *               or as a CellAddress or AddressRange object.
+     */
+    public static function validateCellOrCellRange(AddressRange|CellAddress|int|string|array $cellRange): string
+    {
+        if (is_string($cellRange) || is_numeric($cellRange)) {
+            $cellRange = (string) preg_replace('/^([A-Z]+|\d+)$/', '${1}:${1}', (string) $cellRange);
+        } elseif (is_object($cellRange) && $cellRange instanceof CellAddress) {
+            $cellRange = new CellRange($cellRange, $cellRange);
+        }
+        return self::validateCellRange($cellRange);
+    }
+    private const SETMAXROW = '${1}1:${2}' . AddressRange::MAX_ROW;
+    private const SETMAXCOL = 'A${1}:' . AddressRange::MAX_COLUMN . '${2}';
+    /**
+     * Validate a cell range.
+     *
+     * @param AddressRange<CellAddress>|array{0: int, 1: int, 2: int, 3: int}|array{0: int, 1: int}|string $cellRange Coordinate of the cells as a string, eg: 'C5:F12';
+     *               or as an array of [$fromColumnIndex, $fromRow, $toColumnIndex, $toRow] (e.g. [3, 5, 6, 12]),
+     *               or as an AddressRange object.
+     */
+    public static function validateCellRange(AddressRange|string|array $cellRange): string
+    {
+        if (is_string($cellRange)) {
+            [$worksheet, $addressRange] = Worksheet::extractSheetTitle($cellRange, true);
+            $addressRange = (string) preg_replace(
+                ['/^([A-Z]+):([A-Z]+)$/i', '/^(\\d+):(\\d+)$/'],
+                [self::SETMAXROW, self::SETMAXCOL],
+                $addressRange ?? ''
+            );
+            return empty($worksheet) ? strtoupper($addressRange) : $worksheet . '!' . strtoupper($addressRange);
+        }
+        if (is_array($cellRange)) {
+            switch (count($cellRange)) {
+                case 4:
+                    $from = [$cellRange[0], $cellRange[1]];
+                    $to = [$cellRange[2], $cellRange[3]];
+                    break;
+                case 2:
+                    $from = [$cellRange[0], $cellRange[1]];
+                    $to = [$cellRange[0], $cellRange[1]];
+                    break;
+                default:
+                    throw new SpreadsheetException('CellRange array length must be 2 or 4');
+            }
+            $cellRange = new CellRange(CellAddress::fromColumnRowArray($from), CellAddress::fromColumnRowArray($to));
+        }
+        return (string) $cellRange;
+    }
+    public static function definedNameToCoordinate(string $coordinate, Worksheet $worksheet): string
+    {
+        $coordinate = strtoupper($coordinate);
+        $testCoordinate = (string) preg_replace('/^=/', '', $coordinate);
+        $defined = $worksheet->getParentOrThrow()->getDefinedName($testCoordinate, $worksheet);
+        if ($defined !== null) {
+            if ($defined->getWorksheet() === $worksheet && !$defined->isFormula()) {
+                $coordinate = (string) preg_replace('/^=/', '', $defined->getValue());
+            }
+        }
+        return $coordinate;
+    }
+}

--- a/src/PhpSpreadsheet/Worksheet/Worksheet.php
+++ b/src/PhpSpreadsheet/Worksheet/Worksheet.php
@@ -3090,17 +3090,15 @@
     }
     public function applyStylesFromArray(string $coordinate, array $styleArray): bool
     {
         $spreadsheet = $this->parent;
         if ($spreadsheet === null) {
             return false;
         }
         $activeSheetIndex = $spreadsheet->getActiveSheetIndex();
         $originalSelected = $this->selectedCells;
         $this->getStyle($coordinate)->applyFromArray($styleArray);
-        $this->setSelectedCells($originalSelected);
-        if ($activeSheetIndex >= 0) {
-            $spreadsheet->setActiveSheetIndex($activeSheetIndex);
-        }
+        $this->selectedCells = $originalSelected;
+        $spreadsheet->setActiveSheetIndex($activeSheetIndex);
         return true;
     }
 }

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Csv.php
@@ -0,0 +1,270 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use Stringable;
+class Csv extends BaseWriter
+{
+    /**
+     * PhpSpreadsheet object.
+     */
+    private Spreadsheet $spreadsheet;
+    /**
+     * Delimiter.
+     */
+    private string $delimiter = ',';
+    /**
+     * Enclosure.
+     */
+    private string $enclosure = '"';
+    /**
+     * Line ending.
+     */
+    private string $lineEnding = PHP_EOL;
+    /**
+     * Sheet index to write.
+     */
+    private int $sheetIndex = 0;
+    /**
+     * Whether to write a UTF8 BOM.
+     */
+    private bool $useBOM = false;
+    /**
+     * Whether to write a Separator line as the first line of the file
+     *     sep=x.
+     */
+    private bool $includeSeparatorLine = false;
+    /**
+     * Whether to write a fully Excel compatible CSV file.
+     */
+    private bool $excelCompatibility = false;
+    /**
+     * Output encoding.
+     */
+    private string $outputEncoding = '';
+    /**
+     * Whether number of columns should be allowed to vary
+     * between rows, or use a fixed range based on the max
+     * column overall.
+     */
+    private bool $variableColumns = false;
+    /**
+     * Create a new CSV.
+     */
+    public function __construct(Spreadsheet $spreadsheet)
+    {
+        $this->spreadsheet = $spreadsheet;
+    }
+    /**
+     * Save PhpSpreadsheet to file.
+     *
+     * @param resource|string $filename
+     */
+    public function save($filename, int $flags = 0): void
+    {
+        $this->processFlags($flags);
+        $sheet = $this->spreadsheet->getSheet($this->sheetIndex);
+        $saveDebugLog = Calculation::getInstance($this->spreadsheet)->getDebugLog()->getWriteDebugLog();
+        Calculation::getInstance($this->spreadsheet)->getDebugLog()->setWriteDebugLog(false);
+        $saveArrayReturnType = Calculation::getArrayReturnType();
+        Calculation::setArrayReturnType(Calculation::RETURN_ARRAY_AS_VALUE);
+        $this->openFileHandle($filename);
+        if ($this->excelCompatibility) {
+            $this->setUseBOM(true); //  Enforce UTF-8 BOM Header
+            $this->setIncludeSeparatorLine(true); //  Set separator line
+            $this->setEnclosure('"'); //  Set enclosure to "
+            $this->setDelimiter(';'); //  Set delimiter to a semi-colon
+            $this->setLineEnding("\r\n");
+        }
+        if ($this->useBOM) {
+            fwrite($this->fileHandle, "\xEF\xBB\xBF");
+        }
+        if ($this->includeSeparatorLine) {
+            fwrite($this->fileHandle, 'sep=' . $this->getDelimiter() . $this->lineEnding);
+        }
+        $maxCol = $sheet->getHighestDataColumn();
+        $maxRow = $sheet->getHighestDataRow();
+        $row = 0;
+        foreach ($sheet->rangeToArrayYieldRows("A1:$maxCol$maxRow", '', $this->preCalculateFormulas) as $cellsArray) {
+            ++$row;
+            if ($this->variableColumns) {
+                $column = $sheet->getHighestDataColumn($row);
+                if ($column === 'A' && !$sheet->cellExists("A$row")) {
+                    $cellsArray = [];
+                } else {
+                    array_splice($cellsArray, Coordinate::columnIndexFromString($column));
+                }
+            }
+            $this->writeLine($this->fileHandle, $cellsArray);
+        }
+        $this->maybeCloseFileHandle();
+        Calculation::setArrayReturnType($saveArrayReturnType);
+        Calculation::getInstance($this->spreadsheet)->getDebugLog()->setWriteDebugLog($saveDebugLog);
+    }
+    public function getDelimiter(): string
+    {
+        return $this->delimiter;
+    }
+    public function setDelimiter(string $delimiter): self
+    {
+        $this->delimiter = $delimiter;
+        return $this;
+    }
+    public function getEnclosure(): string
+    {
+        return $this->enclosure;
+    }
+    public function setEnclosure(string $enclosure = '"'): self
+    {
+        $this->enclosure = $enclosure;
+        return $this;
+    }
+    public function getLineEnding(): string
+    {
+        return $this->lineEnding;
+    }
+    public function setLineEnding(string $lineEnding): self
+    {
+        $this->lineEnding = $lineEnding;
+        return $this;
+    }
+    /**
+     * Get whether BOM should be used.
+     */
+    public function getUseBOM(): bool
+    {
+        return $this->useBOM;
+    }
+    /**
+     * Set whether BOM should be used, typically when non-ASCII characters are used.
+     */
+    public function setUseBOM(bool $useBOM): self
+    {
+        $this->useBOM = $useBOM;
+        return $this;
+    }
+    /**
+     * Get whether a separator line should be included.
+     */
+    public function getIncludeSeparatorLine(): bool
+    {
+        return $this->includeSeparatorLine;
+    }
+    /**
+     * Set whether a separator line should be included as the first line of the file.
+     */
+    public function setIncludeSeparatorLine(bool $includeSeparatorLine): self
+    {
+        $this->includeSeparatorLine = $includeSeparatorLine;
+        return $this;
+    }
+    /**
+     * Get whether the file should be saved with full Excel Compatibility.
+     */
+    public function getExcelCompatibility(): bool
+    {
+        return $this->excelCompatibility;
+    }
+    /**
+     * Set whether the file should be saved with full Excel Compatibility.
+     *
+     * @param bool $excelCompatibility Set the file to be written as a fully Excel compatible csv file
+     *                                Note that this overrides other settings such as useBOM, enclosure and delimiter
+     */
+    public function setExcelCompatibility(bool $excelCompatibility): self
+    {
+        $this->excelCompatibility = $excelCompatibility;
+        return $this;
+    }
+    public function getSheetIndex(): int
+    {
+        return $this->sheetIndex;
+    }
+    public function setSheetIndex(int $sheetIndex): self
+    {
+        $this->sheetIndex = $sheetIndex;
+        return $this;
+    }
+    public function getOutputEncoding(): string
+    {
+        return $this->outputEncoding;
+    }
+    public function setOutputEncoding(string $outputEnconding): self
+    {
+        $this->outputEncoding = $outputEnconding;
+        return $this;
+    }
+    private bool $enclosureRequired = true;
+    public function setEnclosureRequired(bool $value): self
+    {
+        $this->enclosureRequired = $value;
+        return $this;
+    }
+    public function getEnclosureRequired(): bool
+    {
+        return $this->enclosureRequired;
+    }
+    /**
+     * Convert boolean to TRUE/FALSE; otherwise return element cast to string.
+     *
+     * @param null|bool|float|int|string|Stringable $element element to be converted
+     */
+    private static function elementToString(mixed $element): string
+    {
+        if (is_bool($element)) {
+            return $element ? 'TRUE' : 'FALSE';
+        }
+        return (string) $element;
+    }
+    /**
+     * Write line to CSV file.
+     *
+     * @param resource $fileHandle PHP filehandle
+     * @param array $values Array containing values in a row
+     */
+    private function writeLine($fileHandle, array $values): void
+    {
+        $delimiter = '';
+        $line = '';
+        /** @var null|bool|float|int|string|Stringable $element */
+        foreach ($values as $element) {
+            $element = self::elementToString($element);
+            $line .= $delimiter;
+            $delimiter = $this->delimiter;
+            $enclosure = $this->enclosure;
+            if ($enclosure) {
+                if (!$this->enclosureRequired && strpbrk($element, "$delimiter$enclosure\n") === false) {
+                    $enclosure = '';
+                } else {
+                    $element = str_replace($enclosure, $enclosure . $enclosure, $element);
+                }
+            }
+            $line .= $enclosure . $element . $enclosure;
+        }
+        $line .= $this->lineEnding;
+        if ($this->outputEncoding != '') {
+            $line = mb_convert_encoding($line, $this->outputEncoding);
+        }
+        fwrite($fileHandle, $line);
+    }
+    /**
+     * Get whether number of columns should be allowed to vary
+     * between rows, or use a fixed range based on the max
+     * column overall.
+     */
+    public function getVariableColumns(): bool
+    {
+        return $this->variableColumns;
+    }
+    /**
+     * Set whether number of columns should be allowed to vary
+     * between rows, or use a fixed range based on the max
+     * column overall.
+     */
+    public function setVariableColumns(bool $pValue): self
+    {
+        $this->variableColumns = $pValue;
+        return $this;
+    }
+}

--- a/src/PhpSpreadsheet/Writer/Html.php
+++ b/src/PhpSpreadsheet/Writer/Html.php
@@ -453,23 +453,20 @@
                     if ($chartTL[1] > $rowMax) {
                         $rowMax = $chartTL[1];
                     }
                     if ($chartTL[0] > $colMax) {
                         $colMax = $chartTL[0];
                     }
                 }
             }
         }
         foreach ($worksheet->getDrawingCollection() as $drawing) {
-            if ($drawing instanceof Drawing && $drawing->getPath() === '') {
-                continue;
-            }
             $imageTL = Coordinate::indexesFromString($drawing->getCoordinates());
             $this->sheetDrawings[$drawing->getCoordinates()] = $drawing;
             if ($imageTL[1] > $rowMax) {
                 $rowMax = $imageTL[1];
             }
             if ($imageTL[0] > $colMax) {
                 $colMax = $imageTL[0];
             }
         }
     }
@@ -491,37 +488,34 @@
      *
      * @param string $coordinates Cell coordinates
      */
     private function writeImageInCell(string $coordinates): string
     {
         $html = '';
         $drawing = $this->sheetDrawings[$coordinates] ?? null;
         if ($drawing !== null) {
             $filedesc = $drawing->getDescription();
             $filedesc = $filedesc ? htmlspecialchars($filedesc, ENT_QUOTES) : 'Embedded image';
-            if ($drawing instanceof Drawing && $drawing->getPath() !== '') {
+            if ($drawing instanceof Drawing) {
                 $filename = $drawing->getPath();
                 $filename = (string) preg_replace('/^[.]/', '', $filename);
                 $filename = $this->getImagesRoot() . $filename;
                 $filename = (string) preg_replace('@^[.]([^/])@', '$1', $filename);
                 $filename = htmlspecialchars($filename, Settings::htmlEntityFlags());
                 $html .= PHP_EOL;
                 $imageData = self::winFileToUrl($filename, $this instanceof Pdf\Mpdf);
                 if ($this->embedImages || str_starts_with($imageData, 'zip://')) {
-                    $imageData = 'data:,';
                     $picture = @file_get_contents($filename);
                     if ($picture !== false) {
-                        $mimeContentType = (string) @mime_content_type($filename);
-                        if (str_starts_with($mimeContentType, 'image/')) {
-                            $base64 = base64_encode($picture);
-                            $imageData = 'data:' . $mimeContentType . ';base64,' . $base64;
-                        }
+                        $imageDetails = getimagesize($filename) ?: ['mime' => ''];
+                        $base64 = base64_encode($picture);
+                        $imageData = 'data:' . $imageDetails['mime'] . ';base64,' . $base64;
                     }
                 }
                 $html .= '<img style="position: absolute; z-index: 1; left: '
                     . $drawing->getOffsetX() . 'px; top: ' . $drawing->getOffsetY() . 'px; width: '
                     . $drawing->getWidth() . 'px; height: ' . $drawing->getHeight() . 'px;" src="'
                     . $imageData . '" alt="' . $filedesc . '" />';
             } elseif ($drawing instanceof MemoryDrawing) {
                 $imageResource = $drawing->getImageResource();
                 if ($imageResource) {
                     ob_start(); //  Let's start output buffering.
@@ -1161,28 +1155,21 @@
      */
     private function generateRow(Worksheet $worksheet, array $values, int $row, string $cellType): string
     {
         $sheetIndex = $worksheet->getParentOrThrow()->getIndex($worksheet);
         $html = $this->generateRowStart($worksheet, $sheetIndex, $row);
         $colNum = 0;
         foreach ($values as $cellAddress) {
             [$cell, $cssClass, $coordinate] = $this->generateRowCellCss($worksheet, $cellAddress, $row, $colNum);
             $cellData = $this->generateRowCellData($worksheet, $cell, $cssClass);
             if ($worksheet->hyperlinkExists($coordinate) && !$worksheet->getHyperlink($coordinate)->isInternal()) {
-                $url = $worksheet->getHyperlink($coordinate)->getUrl();
-                $urldecode = strtolower(html_entity_decode(trim($url), encoding: 'UTF-8'));
-                $parseScheme = preg_match('/^(\\w+):/', $urldecode, $matches);
-                if ($parseScheme === 1 && !in_array($matches[1], ['http', 'https', 'file', 'ftp', 's3'], true)) {
-                    $cellData = htmlspecialchars($url, Settings::htmlEntityFlags());
-                } else {
-                    $cellData = '<a href="' . htmlspecialchars($url, Settings::htmlEntityFlags()) . '" title="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getTooltip(), Settings::htmlEntityFlags()) . '">' . $cellData . '</a>';
-                }
+                $cellData = '<a href="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getUrl(), Settings::htmlEntityFlags()) . '" title="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getTooltip(), Settings::htmlEntityFlags()) . '">' . $cellData . '</a>';
             }
             $writeCell = !(isset($this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])
                 && $this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum]);
             $colSpan = 1;
             $rowSpan = 1;
             if (isset($this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])) {
                 $spans = $this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum];
                 $rowSpan = $spans['rowspan'];
                 $colSpan = $spans['colspan'];
                 $endCellCoord = Coordinate::stringFromColumnIndex($colNum + $colSpan) . ($row + $rowSpan);

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Ods/Cell/Comment.php
@@ -0,0 +1,39 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Ods\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+/**
+ * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
+ */
+class Comment
+{
+    public static function write(XMLWriter $objWriter, Cell $cell): void
+    {
+        $comments = $cell->getWorksheet()->getComments();
+        if (!isset($comments[$cell->getCoordinate()])) {
+            return;
+        }
+        $comment = $comments[$cell->getCoordinate()];
+        $objWriter->startElement('office:annotation');
+        $objWriter->writeAttribute('svg:width', $comment->getWidth());
+        $objWriter->writeAttribute('svg:height', $comment->getHeight());
+        $objWriter->writeAttribute('svg:x', $comment->getMarginLeft());
+        $objWriter->writeAttribute('svg:y', $comment->getMarginTop());
+        $objWriter->writeElement('dc:creator', $comment->getAuthor());
+        $objWriter->startElement('text:p');
+        $text = $comment->getText()->getPlainText();
+        $textElements = explode("\n", $text);
+        $newLineOwed = false;
+        foreach ($textElements as $textSegment) {
+            if ($newLineOwed) {
+                $objWriter->writeElement('text:line-break');
+            }
+            $newLineOwed = true;
+            if ($textSegment !== '') {
+                $objWriter->writeElement('text:span', $textSegment);
+            }
+        }
+        $objWriter->endElement(); // text:p
+        $objWriter->endElement();
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Ods/Content.php
@@ -0,0 +1,313 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Ods;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Calculation\Exception as CalculationException;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Worksheet\RowCellIterator;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
+use PhpOffice\PhpSpreadsheet\Writer\Ods;
+use PhpOffice\PhpSpreadsheet\Writer\Ods\Cell\Comment;
+use PhpOffice\PhpSpreadsheet\Writer\Ods\Cell\Style;
+/**
+ * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
+ */
+class Content extends WriterPart
+{
+    const NUMBER_COLS_REPEATED_MAX = 1024;
+    const NUMBER_ROWS_REPEATED_MAX = 1048576;
+    private Formula $formulaConvertor;
+    /**
+     * Set parent Ods writer.
+     */
+    public function __construct(Ods $writer)
+    {
+        parent::__construct($writer);
+        $this->formulaConvertor = new Formula($this->getParentWriter()->getSpreadsheet()->getDefinedNames());
+    }
+    /**
+     * Write content.xml to XML format.
+     *
+     * @return string XML Output
+     */
+    public function write(): string
+    {
+        $objWriter = null;
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8');
+        $objWriter->startElement('office:document-content');
+        $objWriter->writeAttribute('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
+        $objWriter->writeAttribute('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
+        $objWriter->writeAttribute('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
+        $objWriter->writeAttribute('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
+        $objWriter->writeAttribute('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
+        $objWriter->writeAttribute('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
+        $objWriter->writeAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
+        $objWriter->writeAttribute('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
+        $objWriter->writeAttribute('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
+        $objWriter->writeAttribute('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
+        $objWriter->writeAttribute('xmlns:presentation', 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0');
+        $objWriter->writeAttribute('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
+        $objWriter->writeAttribute('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
+        $objWriter->writeAttribute('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
+        $objWriter->writeAttribute('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
+        $objWriter->writeAttribute('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
+        $objWriter->writeAttribute('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
+        $objWriter->writeAttribute('xmlns:ooo', 'http://openoffice.org/2004/office');
+        $objWriter->writeAttribute('xmlns:ooow', 'http://openoffice.org/2004/writer');
+        $objWriter->writeAttribute('xmlns:oooc', 'http://openoffice.org/2004/calc');
+        $objWriter->writeAttribute('xmlns:dom', 'http://www.w3.org/2001/xml-events');
+        $objWriter->writeAttribute('xmlns:xforms', 'http://www.w3.org/2002/xforms');
+        $objWriter->writeAttribute('xmlns:xsd', 'http://www.w3.org/2001/XMLSchema');
+        $objWriter->writeAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
+        $objWriter->writeAttribute('xmlns:rpt', 'http://openoffice.org/2005/report');
+        $objWriter->writeAttribute('xmlns:of', 'urn:oasis:names:tc:opendocument:xmlns:of:1.2');
+        $objWriter->writeAttribute('xmlns:xhtml', 'http://www.w3.org/1999/xhtml');
+        $objWriter->writeAttribute('xmlns:grddl', 'http://www.w3.org/2003/g/data-view#');
+        $objWriter->writeAttribute('xmlns:tableooo', 'http://openoffice.org/2009/table');
+        $objWriter->writeAttribute('xmlns:field', 'urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0');
+        $objWriter->writeAttribute('xmlns:formx', 'urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0');
+        $objWriter->writeAttribute('xmlns:css3t', 'http://www.w3.org/TR/css3-text/');
+        $objWriter->writeAttribute('office:version', '1.2');
+        $objWriter->writeElement('office:scripts');
+        $objWriter->writeElement('office:font-face-decls');
+        $objWriter->startElement('office:automatic-styles');
+        $this->writeXfStyles($objWriter, $this->getParentWriter()->getSpreadsheet());
+        $objWriter->endElement();
+        $objWriter->startElement('office:body');
+        $objWriter->startElement('office:spreadsheet');
+        $objWriter->writeElement('table:calculation-settings');
+        $this->writeSheets($objWriter);
+        (new AutoFilters($objWriter, $this->getParentWriter()->getSpreadsheet()))->write();
+        (new NamedExpressions($objWriter, $this->getParentWriter()->getSpreadsheet(), $this->formulaConvertor))->write();
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    /**
+     * Write sheets.
+     */
+    private function writeSheets(XMLWriter $objWriter): void
+    {
+        $spreadsheet = $this->getParentWriter()->getSpreadsheet();
+        $sheetCount = $spreadsheet->getSheetCount();
+        for ($sheetIndex = 0; $sheetIndex < $sheetCount; ++$sheetIndex) {
+            $objWriter->startElement('table:table');
+            $objWriter->writeAttribute('table:name', $spreadsheet->getSheet($sheetIndex)->getTitle());
+            $objWriter->writeAttribute('table:style-name', Style::TABLE_STYLE_PREFIX . (string) ($sheetIndex + 1));
+            $objWriter->writeElement('office:forms');
+            $lastColumn = 0;
+            foreach ($spreadsheet->getSheet($sheetIndex)->getColumnDimensions() as $columnDimension) {
+                $thisColumn = $columnDimension->getColumnNumeric();
+                $emptyColumns = $thisColumn - $lastColumn - 1;
+                if ($emptyColumns > 0) {
+                    $objWriter->startElement('table:table-column');
+                    $objWriter->writeAttribute('table:number-columns-repeated', (string) $emptyColumns);
+                    $objWriter->endElement();
+                }
+                $lastColumn = $thisColumn;
+                $objWriter->startElement('table:table-column');
+                $objWriter->writeAttribute(
+                    'table:style-name',
+                    sprintf('%s_%d_%d', Style::COLUMN_STYLE_PREFIX, $sheetIndex, $columnDimension->getColumnNumeric())
+                );
+                $objWriter->writeAttribute('table:default-cell-style-name', 'ce0');
+                $objWriter->endElement();
+            }
+            $this->writeRows($objWriter, $spreadsheet->getSheet($sheetIndex), $sheetIndex);
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write rows of the specified sheet.
+     */
+    private function writeRows(XMLWriter $objWriter, Worksheet $sheet, int $sheetIndex): void
+    {
+        $numberRowsRepeated = self::NUMBER_ROWS_REPEATED_MAX;
+        $span_row = 0;
+        $rows = $sheet->getRowIterator();
+        foreach ($rows as $row) {
+            $cellIterator = $row->getCellIterator();
+            --$numberRowsRepeated;
+            if ($cellIterator->valid()) {
+                $objWriter->startElement('table:table-row');
+                if ($span_row) {
+                    if ($span_row > 1) {
+                        $objWriter->writeAttribute('table:number-rows-repeated', (string) $span_row);
+                    }
+                    $objWriter->startElement('table:table-cell');
+                    $objWriter->writeAttribute('table:number-columns-repeated', (string) self::NUMBER_COLS_REPEATED_MAX);
+                    $objWriter->endElement();
+                    $span_row = 0;
+                } else {
+                    if ($sheet->rowDimensionExists($row->getRowIndex()) && $sheet->getRowDimension($row->getRowIndex())->getRowHeight() > 0) {
+                        $objWriter->writeAttribute(
+                            'table:style-name',
+                            sprintf('%s_%d_%d', Style::ROW_STYLE_PREFIX, $sheetIndex, $row->getRowIndex())
+                        );
+                    }
+                    $this->writeCells($objWriter, $cellIterator);
+                }
+                $objWriter->endElement();
+            } else {
+                ++$span_row;
+            }
+        }
+    }
+    /**
+     * Write cells of the specified row.
+     */
+    private function writeCells(XMLWriter $objWriter, RowCellIterator $cells): void
+    {
+        $numberColsRepeated = self::NUMBER_COLS_REPEATED_MAX;
+        $prevColumn = -1;
+        foreach ($cells as $cell) {
+            /** @var Cell $cell */
+            $column = Coordinate::columnIndexFromString($cell->getColumn()) - 1;
+            $this->writeCellSpan($objWriter, $column, $prevColumn);
+            $objWriter->startElement('table:table-cell');
+            $this->writeCellMerge($objWriter, $cell);
+            $style = $cell->getXfIndex();
+            if ($style !== null) {
+                $objWriter->writeAttribute('table:style-name', Style::CELL_STYLE_PREFIX . $style);
+            }
+            switch ($cell->getDataType()) {
+                case DataType::TYPE_BOOL:
+                    $objWriter->writeAttribute('office:value-type', 'boolean');
+                    $objWriter->writeAttribute('office:boolean-value', $cell->getValue() ? 'true' : 'false');
+                    $objWriter->writeElement('text:p', Calculation::getInstance()->getLocaleBoolean($cell->getValue() ? 'TRUE' : 'FALSE'));
+                    break;
+                case DataType::TYPE_ERROR:
+                    $objWriter->writeAttribute('table:formula', 'of:=#NULL!');
+                    $objWriter->writeAttribute('office:value-type', 'string');
+                    $objWriter->writeAttribute('office:string-value', '');
+                    $objWriter->writeElement('text:p', '#NULL!');
+                    break;
+                case DataType::TYPE_FORMULA:
+                    $formulaValue = $cell->getValueString();
+                    if ($this->getParentWriter()->getPreCalculateFormulas()) {
+                        try {
+                            $formulaValue = $cell->getCalculatedValueString();
+                        } catch (CalculationException $e) {
+                        }
+                    }
+                    $objWriter->writeAttribute('table:formula', $this->formulaConvertor->convertFormula($cell->getValueString()));
+                    if (is_numeric($formulaValue)) {
+                        $objWriter->writeAttribute('office:value-type', 'float');
+                    } else {
+                        $objWriter->writeAttribute('office:value-type', 'string');
+                    }
+                    $objWriter->writeAttribute('office:value', $formulaValue);
+                    $objWriter->writeElement('text:p', $formulaValue);
+                    break;
+                case DataType::TYPE_NUMERIC:
+                    $objWriter->writeAttribute('office:value-type', 'float');
+                    $objWriter->writeAttribute('office:value', $cell->getValueString());
+                    $objWriter->writeElement('text:p', $cell->getValueString());
+                    break;
+                case DataType::TYPE_INLINE:
+                case DataType::TYPE_STRING:
+                    $objWriter->writeAttribute('office:value-type', 'string');
+                    $url = $cell->getHyperlink()->getUrl();
+                    if (empty($url)) {
+                        $objWriter->writeElement('text:p', $cell->getValueString());
+                    } else {
+                        $objWriter->startElement('text:p');
+                        $objWriter->startElement('text:a');
+                        $sheets = 'sheet://';
+                        $lensheets = strlen($sheets);
+                        if (substr($url, 0, $lensheets) === $sheets) {
+                            $url = '#' . substr($url, $lensheets);
+                        }
+                        $objWriter->writeAttribute('xlink:href', $url);
+                        $objWriter->writeAttribute('xlink:type', 'simple');
+                        $objWriter->text($cell->getValueString());
+                        $objWriter->endElement(); // text:a
+                        $objWriter->endElement(); // text:p
+                    }
+                    break;
+            }
+            Comment::write($objWriter, $cell);
+            $objWriter->endElement();
+            $prevColumn = $column;
+        }
+        $numberColsRepeated = $numberColsRepeated - $prevColumn - 1;
+        if ($numberColsRepeated > 0) {
+            if ($numberColsRepeated > 1) {
+                $objWriter->startElement('table:table-cell');
+                $objWriter->writeAttribute('table:number-columns-repeated', (string) $numberColsRepeated);
+                $objWriter->endElement();
+            } else {
+                $objWriter->writeElement('table:table-cell');
+            }
+        }
+    }
+    /**
+     * Write span.
+     */
+    private function writeCellSpan(XMLWriter $objWriter, int $curColumn, int $prevColumn): void
+    {
+        $diff = $curColumn - $prevColumn - 1;
+        if (1 === $diff) {
+            $objWriter->writeElement('table:table-cell');
+        } elseif ($diff > 1) {
+            $objWriter->startElement('table:table-cell');
+            $objWriter->writeAttribute('table:number-columns-repeated', (string) $diff);
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write XF cell styles.
+     */
+    private function writeXfStyles(XMLWriter $writer, Spreadsheet $spreadsheet): void
+    {
+        $styleWriter = new Style($writer);
+        $sheetCount = $spreadsheet->getSheetCount();
+        for ($i = 0; $i < $sheetCount; ++$i) {
+            $worksheet = $spreadsheet->getSheet($i);
+            $styleWriter->writeTableStyle($worksheet, $i + 1);
+            $worksheet->calculateColumnWidths();
+            foreach ($worksheet->getColumnDimensions() as $columnDimension) {
+                if ($columnDimension->getWidth() !== -1.0) {
+                    $styleWriter->writeColumnStyles($columnDimension, $i);
+                }
+            }
+        }
+        for ($i = 0; $i < $sheetCount; ++$i) {
+            $worksheet = $spreadsheet->getSheet($i);
+            foreach ($worksheet->getRowDimensions() as $rowDimension) {
+                if ($rowDimension->getRowHeight() > 0.0) {
+                    $styleWriter->writeRowStyles($rowDimension, $i);
+                }
+            }
+        }
+        foreach ($spreadsheet->getCellXfCollection() as $style) {
+            $styleWriter->write($style);
+        }
+    }
+    /**
+     * Write attributes for merged cell.
+     */
+    private function writeCellMerge(XMLWriter $objWriter, Cell $cell): void
+    {
+        if (!$cell->isMergeRangeValueCell()) {
+            return;
+        }
+        $mergeRange = Coordinate::splitRange((string) $cell->getMergeRange());
+        [$startCell, $endCell] = $mergeRange[0];
+        $start = Coordinate::coordinateFromString($startCell);
+        $end = Coordinate::coordinateFromString($endCell);
+        $columnSpan = Coordinate::columnIndexFromString($end[0]) - Coordinate::columnIndexFromString($start[0]) + 1;
+        $rowSpan = ((int) $end[1]) - ((int) $start[1]) + 1;
+        $objWriter->writeAttribute('table:number-columns-spanned', (string) $columnSpan);
+        $objWriter->writeAttribute('table:number-rows-spanned', (string) $rowSpan);
+    }
+}

--- a/src/PhpSpreadsheet/Writer/Xls.php
+++ b/src/PhpSpreadsheet/Writer/Xls.php
@@ -322,21 +322,21 @@
             $blip = new Blip();
             $blip->setData($blipData);
             $BSE = new BSE();
             $BSE->setBlipType($blipType);
             $BSE->setBlip($blip);
             $bstoreContainer->addBSE($BSE);
         }
     }
     private function processBaseDrawing(BstoreContainer &$bstoreContainer, BaseDrawing $drawing): void
     {
-        if ($drawing instanceof Drawing && $drawing->getPath() !== '') {
+        if ($drawing instanceof Drawing) {
             $this->processDrawing($bstoreContainer, $drawing);
         } elseif ($drawing instanceof MemoryDrawing) {
             $this->processMemoryDrawing($bstoreContainer, $drawing, $drawing->getRenderingFunction());
         }
     }
     private function checkForDrawings(): bool
     {
         $found = false;
         foreach ($this->spreadsheet->getAllSheets() as $sheet) {
             if (count($sheet->getDrawingCollection()) > 0) {

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xls/ConditionalHelper.php
@@ -0,0 +1,48 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\Wizard;
+class ConditionalHelper
+{
+    /**
+     * Formula parser.
+     */
+    protected Parser $parser;
+    protected mixed $condition;
+    protected string $cellRange;
+    protected ?string $tokens = null;
+    protected int $size;
+    public function __construct(Parser $parser)
+    {
+        $this->parser = $parser;
+    }
+    public function processCondition(mixed $condition, string $cellRange): void
+    {
+        $this->condition = $condition;
+        $this->cellRange = $cellRange;
+        if (is_int($condition) || is_float($condition)) {
+            $this->size = ($condition <= 65535 ? 3 : 0x0000);
+            $this->tokens = pack('Cv', 0x1E, $condition);
+        } else {
+            try {
+                /** @var float|int|string */
+                $conditionx = $condition;
+                $formula = Wizard\WizardAbstract::reverseAdjustCellRef((string) $conditionx, $cellRange);
+                $this->parser->parse($formula);
+                $this->tokens = $this->parser->toReversePolish();
+                $this->size = strlen($this->tokens ?? '');
+            } catch (PhpSpreadsheetException) {
+                $this->tokens = pack('Cv', 0x1E, 0);
+                $this->size = 3;
+            }
+        }
+    }
+    public function tokens(): ?string
+    {
+        return $this->tokens;
+    }
+    public function size(): int
+    {
+        return $this->size;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xls/Parser.php
@@ -0,0 +1,1271 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet as PhpspreadsheetWorksheet;
+use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
+class Parser
+{
+    /**    Constants                */
+    const REGEX_SHEET_TITLE_UNQUOTED = '[^\*\:\/\\\\\?\[\]\+\-\% \\\'\^\&\<\>\=\,\;\#\(\)\"\{\}]+';
+    const REGEX_SHEET_TITLE_QUOTED = '(([^\*\:\/\\\\\?\[\]\\\'])+|(\\\'\\\')+)+';
+    /**
+     * The index of the character we are currently looking at.
+     */
+    public int $currentCharacter;
+    /**
+     * The token we are working on.
+     */
+    public string $currentToken;
+    /**
+     * The formula to parse.
+     */
+    private string $formula;
+    /**
+     * The character ahead of the current char.
+     */
+    public string $lookAhead;
+    /**
+     * The parse tree to be generated.
+     */
+    public array|string $parseTree;
+    /**
+     * Array of external sheets.
+     */
+    private array $externalSheets;
+    /**
+     * Array of sheet references in the form of REF structures.
+     */
+    public array $references;
+    /**
+     * The Excel ptg indices.
+     */
+    private array $ptg = [
+        'ptgExp' => 0x01,
+        'ptgTbl' => 0x02,
+        'ptgAdd' => 0x03,
+        'ptgSub' => 0x04,
+        'ptgMul' => 0x05,
+        'ptgDiv' => 0x06,
+        'ptgPower' => 0x07,
+        'ptgConcat' => 0x08,
+        'ptgLT' => 0x09,
+        'ptgLE' => 0x0A,
+        'ptgEQ' => 0x0B,
+        'ptgGE' => 0x0C,
+        'ptgGT' => 0x0D,
+        'ptgNE' => 0x0E,
+        'ptgIsect' => 0x0F,
+        'ptgUnion' => 0x10,
+        'ptgRange' => 0x11,
+        'ptgUplus' => 0x12,
+        'ptgUminus' => 0x13,
+        'ptgPercent' => 0x14,
+        'ptgParen' => 0x15,
+        'ptgMissArg' => 0x16,
+        'ptgStr' => 0x17,
+        'ptgAttr' => 0x19,
+        'ptgSheet' => 0x1A,
+        'ptgEndSheet' => 0x1B,
+        'ptgErr' => 0x1C,
+        'ptgBool' => 0x1D,
+        'ptgInt' => 0x1E,
+        'ptgNum' => 0x1F,
+        'ptgArray' => 0x20,
+        'ptgFunc' => 0x21,
+        'ptgFuncVar' => 0x22,
+        'ptgName' => 0x23,
+        'ptgRef' => 0x24,
+        'ptgArea' => 0x25,
+        'ptgMemArea' => 0x26,
+        'ptgMemErr' => 0x27,
+        'ptgMemNoMem' => 0x28,
+        'ptgMemFunc' => 0x29,
+        'ptgRefErr' => 0x2A,
+        'ptgAreaErr' => 0x2B,
+        'ptgRefN' => 0x2C,
+        'ptgAreaN' => 0x2D,
+        'ptgMemAreaN' => 0x2E,
+        'ptgMemNoMemN' => 0x2F,
+        'ptgNameX' => 0x39,
+        'ptgRef3d' => 0x3A,
+        'ptgArea3d' => 0x3B,
+        'ptgRefErr3d' => 0x3C,
+        'ptgAreaErr3d' => 0x3D,
+        'ptgArrayV' => 0x40,
+        'ptgFuncV' => 0x41,
+        'ptgFuncVarV' => 0x42,
+        'ptgNameV' => 0x43,
+        'ptgRefV' => 0x44,
+        'ptgAreaV' => 0x45,
+        'ptgMemAreaV' => 0x46,
+        'ptgMemErrV' => 0x47,
+        'ptgMemNoMemV' => 0x48,
+        'ptgMemFuncV' => 0x49,
+        'ptgRefErrV' => 0x4A,
+        'ptgAreaErrV' => 0x4B,
+        'ptgRefNV' => 0x4C,
+        'ptgAreaNV' => 0x4D,
+        'ptgMemAreaNV' => 0x4E,
+        'ptgMemNoMemNV' => 0x4F,
+        'ptgFuncCEV' => 0x58,
+        'ptgNameXV' => 0x59,
+        'ptgRef3dV' => 0x5A,
+        'ptgArea3dV' => 0x5B,
+        'ptgRefErr3dV' => 0x5C,
+        'ptgAreaErr3dV' => 0x5D,
+        'ptgArrayA' => 0x60,
+        'ptgFuncA' => 0x61,
+        'ptgFuncVarA' => 0x62,
+        'ptgNameA' => 0x63,
+        'ptgRefA' => 0x64,
+        'ptgAreaA' => 0x65,
+        'ptgMemAreaA' => 0x66,
+        'ptgMemErrA' => 0x67,
+        'ptgMemNoMemA' => 0x68,
+        'ptgMemFuncA' => 0x69,
+        'ptgRefErrA' => 0x6A,
+        'ptgAreaErrA' => 0x6B,
+        'ptgRefNA' => 0x6C,
+        'ptgAreaNA' => 0x6D,
+        'ptgMemAreaNA' => 0x6E,
+        'ptgMemNoMemNA' => 0x6F,
+        'ptgFuncCEA' => 0x78,
+        'ptgNameXA' => 0x79,
+        'ptgRef3dA' => 0x7A,
+        'ptgArea3dA' => 0x7B,
+        'ptgRefErr3dA' => 0x7C,
+        'ptgAreaErr3dA' => 0x7D,
+    ];
+    /**
+     * Thanks to Michael Meeks and Gnumeric for the initial arg values.
+     *
+     * The following hash was generated by "function_locale.pl" in the distro.
+     * Refer to function_locale.pl for non-English function names.
+     *
+     * The array elements are as follow:
+     * ptg:   The Excel function ptg code.
+     * args:  The number of arguments that the function takes:
+     *           >=0 is a fixed number of arguments.
+     *           -1  is a variable  number of arguments.
+     * class: The reference, value or array class of the function args.
+     * vol:   The function is volatile.
+     */
+    private array $functions = [
+        'COUNT' => [0, -1, 0, 0],
+        'IF' => [1, -1, 1, 0],
+        'ISNA' => [2, 1, 1, 0],
+        'ISERROR' => [3, 1, 1, 0],
+        'SUM' => [4, -1, 0, 0],
+        'AVERAGE' => [5, -1, 0, 0],
+        'MIN' => [6, -1, 0, 0],
+        'MAX' => [7, -1, 0, 0],
+        'ROW' => [8, -1, 0, 0],
+        'COLUMN' => [9, -1, 0, 0],
+        'NA' => [10, 0, 0, 0],
+        'NPV' => [11, -1, 1, 0],
+        'STDEV' => [12, -1, 0, 0],
+        'DOLLAR' => [13, -1, 1, 0],
+        'FIXED' => [14, -1, 1, 0],
+        'SIN' => [15, 1, 1, 0],
+        'COS' => [16, 1, 1, 0],
+        'TAN' => [17, 1, 1, 0],
+        'ATAN' => [18, 1, 1, 0],
+        'PI' => [19, 0, 1, 0],
+        'SQRT' => [20, 1, 1, 0],
+        'EXP' => [21, 1, 1, 0],
+        'LN' => [22, 1, 1, 0],
+        'LOG10' => [23, 1, 1, 0],
+        'ABS' => [24, 1, 1, 0],
+        'INT' => [25, 1, 1, 0],
+        'SIGN' => [26, 1, 1, 0],
+        'ROUND' => [27, 2, 1, 0],
+        'LOOKUP' => [28, -1, 0, 0],
+        'INDEX' => [29, -1, 0, 1],
+        'REPT' => [30, 2, 1, 0],
+        'MID' => [31, 3, 1, 0],
+        'LEN' => [32, 1, 1, 0],
+        'VALUE' => [33, 1, 1, 0],
+        'TRUE' => [34, 0, 1, 0],
+        'FALSE' => [35, 0, 1, 0],
+        'AND' => [36, -1, 0, 0],
+        'OR' => [37, -1, 0, 0],
+        'NOT' => [38, 1, 1, 0],
+        'MOD' => [39, 2, 1, 0],
+        'DCOUNT' => [40, 3, 0, 0],
+        'DSUM' => [41, 3, 0, 0],
+        'DAVERAGE' => [42, 3, 0, 0],
+        'DMIN' => [43, 3, 0, 0],
+        'DMAX' => [44, 3, 0, 0],
+        'DSTDEV' => [45, 3, 0, 0],
+        'VAR' => [46, -1, 0, 0],
+        'DVAR' => [47, 3, 0, 0],
+        'TEXT' => [48, 2, 1, 0],
+        'LINEST' => [49, -1, 0, 0],
+        'TREND' => [50, -1, 0, 0],
+        'LOGEST' => [51, -1, 0, 0],
+        'GROWTH' => [52, -1, 0, 0],
+        'PV' => [56, -1, 1, 0],
+        'FV' => [57, -1, 1, 0],
+        'NPER' => [58, -1, 1, 0],
+        'PMT' => [59, -1, 1, 0],
+        'RATE' => [60, -1, 1, 0],
+        'MIRR' => [61, 3, 0, 0],
+        'IRR' => [62, -1, 0, 0],
+        'RAND' => [63, 0, 1, 1],
+        'MATCH' => [64, -1, 0, 0],
+        'DATE' => [65, 3, 1, 0],
+        'TIME' => [66, 3, 1, 0],
+        'DAY' => [67, 1, 1, 0],
+        'MONTH' => [68, 1, 1, 0],
+        'YEAR' => [69, 1, 1, 0],
+        'WEEKDAY' => [70, -1, 1, 0],
+        'HOUR' => [71, 1, 1, 0],
+        'MINUTE' => [72, 1, 1, 0],
+        'SECOND' => [73, 1, 1, 0],
+        'NOW' => [74, 0, 1, 1],
+        'AREAS' => [75, 1, 0, 1],
+        'ROWS' => [76, 1, 0, 1],
+        'COLUMNS' => [77, 1, 0, 1],
+        'OFFSET' => [78, -1, 0, 1],
+        'SEARCH' => [82, -1, 1, 0],
+        'TRANSPOSE' => [83, 1, 1, 0],
+        'TYPE' => [86, 1, 1, 0],
+        'ATAN2' => [97, 2, 1, 0],
+        'ASIN' => [98, 1, 1, 0],
+        'ACOS' => [99, 1, 1, 0],
+        'CHOOSE' => [100, -1, 1, 0],
+        'HLOOKUP' => [101, -1, 0, 0],
+        'VLOOKUP' => [102, -1, 0, 0],
+        'ISREF' => [105, 1, 0, 0],
+        'LOG' => [109, -1, 1, 0],
+        'CHAR' => [111, 1, 1, 0],
+        'LOWER' => [112, 1, 1, 0],
+        'UPPER' => [113, 1, 1, 0],
+        'PROPER' => [114, 1, 1, 0],
+        'LEFT' => [115, -1, 1, 0],
+        'RIGHT' => [116, -1, 1, 0],
+        'EXACT' => [117, 2, 1, 0],
+        'TRIM' => [118, 1, 1, 0],
+        'REPLACE' => [119, 4, 1, 0],
+        'SUBSTITUTE' => [120, -1, 1, 0],
+        'CODE' => [121, 1, 1, 0],
+        'FIND' => [124, -1, 1, 0],
+        'CELL' => [125, -1, 0, 1],
+        'ISERR' => [126, 1, 1, 0],
+        'ISTEXT' => [127, 1, 1, 0],
+        'ISNUMBER' => [128, 1, 1, 0],
+        'ISBLANK' => [129, 1, 1, 0],
+        'T' => [130, 1, 0, 0],
+        'N' => [131, 1, 0, 0],
+        'DATEVALUE' => [140, 1, 1, 0],
+        'TIMEVALUE' => [141, 1, 1, 0],
+        'SLN' => [142, 3, 1, 0],
+        'SYD' => [143, 4, 1, 0],
+        'DDB' => [144, -1, 1, 0],
+        'INDIRECT' => [148, -1, 1, 1],
+        'CALL' => [150, -1, 1, 0],
+        'CLEAN' => [162, 1, 1, 0],
+        'MDETERM' => [163, 1, 2, 0],
+        'MINVERSE' => [164, 1, 2, 0],
+        'MMULT' => [165, 2, 2, 0],
+        'IPMT' => [167, -1, 1, 0],
+        'PPMT' => [168, -1, 1, 0],
+        'COUNTA' => [169, -1, 0, 0],
+        'PRODUCT' => [183, -1, 0, 0],
+        'FACT' => [184, 1, 1, 0],
+        'DPRODUCT' => [189, 3, 0, 0],
+        'ISNONTEXT' => [190, 1, 1, 0],
+        'STDEVP' => [193, -1, 0, 0],
+        'VARP' => [194, -1, 0, 0],
+        'DSTDEVP' => [195, 3, 0, 0],
+        'DVARP' => [196, 3, 0, 0],
+        'TRUNC' => [197, -1, 1, 0],
+        'ISLOGICAL' => [198, 1, 1, 0],
+        'DCOUNTA' => [199, 3, 0, 0],
+        'USDOLLAR' => [204, -1, 1, 0],
+        'FINDB' => [205, -1, 1, 0],
+        'SEARCHB' => [206, -1, 1, 0],
+        'REPLACEB' => [207, 4, 1, 0],
+        'LEFTB' => [208, -1, 1, 0],
+        'RIGHTB' => [209, -1, 1, 0],
+        'MIDB' => [210, 3, 1, 0],
+        'LENB' => [211, 1, 1, 0],
+        'ROUNDUP' => [212, 2, 1, 0],
+        'ROUNDDOWN' => [213, 2, 1, 0],
+        'ASC' => [214, 1, 1, 0],
+        'DBCS' => [215, 1, 1, 0],
+        'RANK' => [216, -1, 0, 0],
+        'ADDRESS' => [219, -1, 1, 0],
+        'DAYS360' => [220, -1, 1, 0],
+        'TODAY' => [221, 0, 1, 1],
+        'VDB' => [222, -1, 1, 0],
+        'MEDIAN' => [227, -1, 0, 0],
+        'SUMPRODUCT' => [228, -1, 2, 0],
+        'SINH' => [229, 1, 1, 0],
+        'COSH' => [230, 1, 1, 0],
+        'TANH' => [231, 1, 1, 0],
+        'ASINH' => [232, 1, 1, 0],
+        'ACOSH' => [233, 1, 1, 0],
+        'ATANH' => [234, 1, 1, 0],
+        'DGET' => [235, 3, 0, 0],
+        'INFO' => [244, 1, 1, 1],
+        'DB' => [247, -1, 1, 0],
+        'FREQUENCY' => [252, 2, 0, 0],
+        'ERROR.TYPE' => [261, 1, 1, 0],
+        'REGISTER.ID' => [267, -1, 1, 0],
+        'AVEDEV' => [269, -1, 0, 0],
+        'BETADIST' => [270, -1, 1, 0],
+        'GAMMALN' => [271, 1, 1, 0],
+        'BETAINV' => [272, -1, 1, 0],
+        'BINOMDIST' => [273, 4, 1, 0],
+        'CHIDIST' => [274, 2, 1, 0],
+        'CHIINV' => [275, 2, 1, 0],
+        'COMBIN' => [276, 2, 1, 0],
+        'CONFIDENCE' => [277, 3, 1, 0],
+        'CRITBINOM' => [278, 3, 1, 0],
+        'EVEN' => [279, 1, 1, 0],
+        'EXPONDIST' => [280, 3, 1, 0],
+        'FDIST' => [281, 3, 1, 0],
+        'FINV' => [282, 3, 1, 0],
+        'FISHER' => [283, 1, 1, 0],
+        'FISHERINV' => [284, 1, 1, 0],
+        'FLOOR' => [285, 2, 1, 0],
+        'GAMMADIST' => [286, 4, 1, 0],
+        'GAMMAINV' => [287, 3, 1, 0],
+        'CEILING' => [288, 2, 1, 0],
+        'HYPGEOMDIST' => [289, 4, 1, 0],
+        'LOGNORMDIST' => [290, 3, 1, 0],
+        'LOGINV' => [291, 3, 1, 0],
+        'NEGBINOMDIST' => [292, 3, 1, 0],
+        'NORMDIST' => [293, 4, 1, 0],
+        'NORMSDIST' => [294, 1, 1, 0],
+        'NORMINV' => [295, 3, 1, 0],
+        'NORMSINV' => [296, 1, 1, 0],
+        'STANDARDIZE' => [297, 3, 1, 0],
+        'ODD' => [298, 1, 1, 0],
+        'PERMUT' => [299, 2, 1, 0],
+        'POISSON' => [300, 3, 1, 0],
+        'TDIST' => [301, 3, 1, 0],
+        'WEIBULL' => [302, 4, 1, 0],
+        'SUMXMY2' => [303, 2, 2, 0],
+        'SUMX2MY2' => [304, 2, 2, 0],
+        'SUMX2PY2' => [305, 2, 2, 0],
+        'CHITEST' => [306, 2, 2, 0],
+        'CORREL' => [307, 2, 2, 0],
+        'COVAR' => [308, 2, 2, 0],
+        'FORECAST' => [309, 3, 2, 0],
+        'FTEST' => [310, 2, 2, 0],
+        'INTERCEPT' => [311, 2, 2, 0],
+        'PEARSON' => [312, 2, 2, 0],
+        'RSQ' => [313, 2, 2, 0],
+        'STEYX' => [314, 2, 2, 0],
+        'SLOPE' => [315, 2, 2, 0],
+        'TTEST' => [316, 4, 2, 0],
+        'PROB' => [317, -1, 2, 0],
+        'DEVSQ' => [318, -1, 0, 0],
+        'GEOMEAN' => [319, -1, 0, 0],
+        'HARMEAN' => [320, -1, 0, 0],
+        'SUMSQ' => [321, -1, 0, 0],
+        'KURT' => [322, -1, 0, 0],
+        'SKEW' => [323, -1, 0, 0],
+        'ZTEST' => [324, -1, 0, 0],
+        'LARGE' => [325, 2, 0, 0],
+        'SMALL' => [326, 2, 0, 0],
+        'QUARTILE' => [327, 2, 0, 0],
+        'PERCENTILE' => [328, 2, 0, 0],
+        'PERCENTRANK' => [329, -1, 0, 0],
+        'MODE' => [330, -1, 2, 0],
+        'TRIMMEAN' => [331, 2, 0, 0],
+        'TINV' => [332, 2, 1, 0],
+        'CONCATENATE' => [336, -1, 1, 0],
+        'POWER' => [337, 2, 1, 0],
+        'RADIANS' => [342, 1, 1, 0],
+        'DEGREES' => [343, 1, 1, 0],
+        'SUBTOTAL' => [344, -1, 0, 0],
+        'SUMIF' => [345, -1, 0, 0],
+        'COUNTIF' => [346, 2, 0, 0],
+        'COUNTBLANK' => [347, 1, 0, 0],
+        'ISPMT' => [350, 4, 1, 0],
+        'DATEDIF' => [351, 3, 1, 0],
+        'DATESTRING' => [352, 1, 1, 0],
+        'NUMBERSTRING' => [353, 2, 1, 0],
+        'ROMAN' => [354, -1, 1, 0],
+        'GETPIVOTDATA' => [358, -1, 0, 0],
+        'HYPERLINK' => [359, -1, 1, 0],
+        'PHONETIC' => [360, 1, 0, 0],
+        'AVERAGEA' => [361, -1, 0, 0],
+        'MAXA' => [362, -1, 0, 0],
+        'MINA' => [363, -1, 0, 0],
+        'STDEVPA' => [364, -1, 0, 0],
+        'VARPA' => [365, -1, 0, 0],
+        'STDEVA' => [366, -1, 0, 0],
+        'VARA' => [367, -1, 0, 0],
+        'BAHTTEXT' => [368, 1, 0, 0],
+    ];
+    private Spreadsheet $spreadsheet;
+    /**
+     * The class constructor.
+     */
+    public function __construct(Spreadsheet $spreadsheet)
+    {
+        $this->spreadsheet = $spreadsheet;
+        $this->currentCharacter = 0;
+        $this->currentToken = ''; // The token we are working on.
+        $this->formula = ''; // The formula to parse.
+        $this->lookAhead = ''; // The character ahead of the current char.
+        $this->parseTree = ''; // The parse tree to be generated.
+        $this->externalSheets = [];
+        $this->references = [];
+    }
+    /**
+     * Convert a token to the proper ptg value.
+     *
+     * @param string $token the token to convert
+     *
+     * @return string the converted token on success
+     */
+    private function convert(string $token): string
+    {
+        if (preg_match('/"([^"]|""){0,255}"/', $token)) {
+            return $this->convertString($token);
+        }
+        if (is_numeric($token)) {
+            return $this->convertNumber($token);
+        }
+        if (preg_match('/^\$?([A-Ia-i]?[A-Za-z])\$?(\d+)$/', $token)) {
+            return $this->convertRef2d($token);
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?(\\d+)$/u', $token)) {
+            return $this->convertRef3d($token);
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?(\\d+)$/u", $token)) {
+            return $this->convertRef3d($token);
+        }
+        if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)\:(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)$/', $token)) {
+            return $this->convertRange2d($token);
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)\\:\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)$/u', $token)) {
+            return $this->convertRange3d($token);
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)\\:\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)$/u", $token)) {
+            return $this->convertRange3d($token);
+        }
+        if (isset($this->ptg[$token])) {
+            return pack('C', $this->ptg[$token]);
+        }
+        if (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $token) || $token == '#N/A') {
+            return $this->convertError($token);
+        }
+        if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/mui', $token) && $this->spreadsheet->getDefinedName($token) !== null) {
+            return $this->convertDefinedName($token);
+        }
+        /*if (preg_match("/[A-Z0-9\xc0-\xdc\.]+/", $token))
+        {
+            return($this->convertFunction($token, $this->_func_args));
+        }*/
+        if ($token == 'arg') {
+            return '';
+        }
+        if (preg_match('/^true$/i', $token)) {
+            return $this->convertBool(1);
+        }
+        if (preg_match('/^false$/i', $token)) {
+            return $this->convertBool(0);
+        }
+        throw new WriterException("Unknown token $token");
+    }
+    /**
+     * Convert a number token to ptgInt or ptgNum.
+     *
+     * @param float|int|string $num an integer or double for conversion to its ptg value
+     */
+    private function convertNumber(mixed $num): string
+    {
+        if ((preg_match('/^\\d+$/', (string) $num)) && ($num <= 65535)) {
+            return pack('Cv', $this->ptg['ptgInt'], $num);
+        }
+        if (BIFFwriter::getByteOrder()) { // if it's Big Endian
+            $num = strrev((string) $num);
+        }
+        return pack('Cd', $this->ptg['ptgNum'], $num);
+    }
+    private function convertBool(int $num): string
+    {
+        return pack('CC', $this->ptg['ptgBool'], $num);
+    }
+    /**
+     * Convert a string token to ptgStr.
+     *
+     * @param string $string a string for conversion to its ptg value
+     *
+     * @return string the converted token
+     */
+    private function convertString(string $string): string
+    {
+        $string = substr($string, 1, -1);
+        if (strlen($string) > 255) {
+            throw new WriterException('String is too long');
+        }
+        return pack('C', $this->ptg['ptgStr']) . StringHelper::UTF8toBIFF8UnicodeShort($string);
+    }
+    /**
+     * Convert a function to a ptgFunc or ptgFuncVarV depending on the number of
+     * args that it takes.
+     *
+     * @param string $token the name of the function for convertion to ptg value
+     * @param int $num_args the number of arguments the function receives
+     *
+     * @return string The packed ptg for the function
+     */
+    private function convertFunction(string $token, int $num_args): string
+    {
+        $args = $this->functions[$token][1];
+        if ($args >= 0) {
+            return pack('Cv', $this->ptg['ptgFuncV'], $this->functions[$token][0]);
+        }
+        return pack('CCv', $this->ptg['ptgFuncVarV'], $num_args, $this->functions[$token][0]);
+    }
+    /**
+     * Convert an Excel range such as A1:D4 to a ptgRefV.
+     *
+     * @param string $range An Excel range in the A1:A2
+     */
+    private function convertRange2d(string $range, int $class = 0): string
+    {
+        if (preg_match('/^(\$)?([A-Ia-i]?[A-Za-z])(\$)?(\d+)\:(\$)?([A-Ia-i]?[A-Za-z])(\$)?(\d+)$/', $range)) {
+            [$cell1, $cell2] = explode(':', $range);
+        } else {
+            throw new WriterException('Unknown range separator');
+        }
+        [$row1, $col1] = $this->cellToPackedRowcol($cell1);
+        [$row2, $col2] = $this->cellToPackedRowcol($cell2);
+        if ($class == 0) {
+            $ptgArea = pack('C', $this->ptg['ptgArea']);
+        } elseif ($class == 1) {
+            $ptgArea = pack('C', $this->ptg['ptgAreaV']);
+        } elseif ($class == 2) {
+            $ptgArea = pack('C', $this->ptg['ptgAreaA']);
+        } else {
+            throw new WriterException("Unknown class $class");
+        }
+        return $ptgArea . $row1 . $row2 . $col1 . $col2;
+    }
+    /**
+     * Convert an Excel 3d range such as "Sheet1!A1:D4" or "Sheet1:Sheet2!A1:D4" to
+     * a ptgArea3d.
+     *
+     * @param string $token an Excel range in the Sheet1!A1:A2 format
+     *
+     * @return string the packed ptgArea3d token on success
+     */
+    private function convertRange3d(string $token): string
+    {
+        [$ext_ref, $range] = PhpspreadsheetWorksheet::extractSheetTitle($token, true);
+        $ext_ref = $this->getRefIndex($ext_ref ?? '');
+        [$cell1, $cell2] = explode(':', $range ?? '');
+        if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\\d+)$/', $cell1)) {
+            [$row1, $col1] = $this->cellToPackedRowcol($cell1);
+            [$row2, $col2] = $this->cellToPackedRowcol($cell2);
+        } else { // It's a rows range (like 26:27)
+            [$row1, $col1, $row2, $col2] = $this->rangeToPackedRange($cell1 . ':' . $cell2);
+        }
+        $ptgArea = pack('C', $this->ptg['ptgArea3d']);
+        return $ptgArea . $ext_ref . $row1 . $row2 . $col1 . $col2;
+    }
+    /**
+     * Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
+     *
+     * @param string $cell An Excel cell reference
+     *
+     * @return string The cell in packed() format with the corresponding ptg
+     */
+    private function convertRef2d(string $cell): string
+    {
+        $cell_array = $this->cellToPackedRowcol($cell);
+        [$row, $col] = $cell_array;
+        $ptgRef = pack('C', $this->ptg['ptgRefA']);
+        return $ptgRef . $row . $col;
+    }
+    /**
+     * Convert an Excel 3d reference such as "Sheet1!A1" or "Sheet1:Sheet2!A1" to a
+     * ptgRef3d.
+     *
+     * @param string $cell An Excel cell reference
+     *
+     * @return string the packed ptgRef3d token on success
+     */
+    private function convertRef3d(string $cell): string
+    {
+        [$ext_ref, $cell] = PhpspreadsheetWorksheet::extractSheetTitle($cell, true);
+        $ext_ref = $this->getRefIndex($ext_ref ?? '');
+        [$row, $col] = $this->cellToPackedRowcol($cell ?? '');
+        $ptgRef = pack('C', $this->ptg['ptgRef3dA']);
+        return $ptgRef . $ext_ref . $row . $col;
+    }
+    /**
+     * Convert an error code to a ptgErr.
+     *
+     * @param string $errorCode The error code for conversion to its ptg value
+     *
+     * @return string The error code ptgErr
+     */
+    private function convertError(string $errorCode): string
+    {
+        return match ($errorCode) {
+            '#NULL!' => pack('C', 0x00),
+            '#DIV/0!' => pack('C', 0x07),
+            '#VALUE!' => pack('C', 0x0F),
+            '#REF!' => pack('C', 0x17),
+            '#NAME?' => pack('C', 0x1D),
+            '#NUM!' => pack('C', 0x24),
+            '#N/A' => pack('C', 0x2A),
+            default => pack('C', 0xFF),
+        };
+    }
+    private bool $tryDefinedName = false;
+    private function convertDefinedName(string $name): string
+    {
+        if (strlen($name) > 255) {
+            throw new WriterException('Defined Name is too long');
+        }
+        if ($this->tryDefinedName) {
+            $nameReference = 1;
+            foreach ($this->spreadsheet->getDefinedNames() as $definedName) {
+                if ($name === $definedName->getName()) {
+                    break;
+                }
+                ++$nameReference;
+            }
+            $ptgRef = pack('Cvxx', $this->ptg['ptgName'], $nameReference);
+            return $ptgRef;
+        }
+        throw new WriterException('Cannot yet write formulae with defined names to Xls');
+    }
+    /**
+     * Look up the REF index that corresponds to an external sheet name
+     * (or range). If it doesn't exist yet add it to the workbook's references
+     * array. It assumes all sheet names given must exist.
+     *
+     * @param string $ext_ref The name of the external reference
+     *
+     * @return string The reference index in packed() format on success
+     */
+    private function getRefIndex(string $ext_ref): string
+    {
+        $ext_ref = (string) preg_replace(["/^'/", "/'$/"], ['', ''], $ext_ref); // Remove leading and trailing ' if any.
+        $ext_ref = str_replace('\'\'', '\'', $ext_ref); // Replace escaped '' with '
+        if (preg_match('/:/', $ext_ref)) {
+            [$sheet_name1, $sheet_name2] = explode(':', $ext_ref);
+            $sheet1 = $this->getSheetIndex($sheet_name1);
+            if ($sheet1 == -1) {
+                throw new WriterException("Unknown sheet name $sheet_name1 in formula");
+            }
+            $sheet2 = $this->getSheetIndex($sheet_name2);
+            if ($sheet2 == -1) {
+                throw new WriterException("Unknown sheet name $sheet_name2 in formula");
+            }
+            if ($sheet1 > $sheet2) {
+                [$sheet1, $sheet2] = [$sheet2, $sheet1];
+            }
+        } else { // Single sheet name only.
+            $sheet1 = $this->getSheetIndex($ext_ref);
+            if ($sheet1 == -1) {
+                throw new WriterException("Unknown sheet name $ext_ref in formula");
+            }
+            $sheet2 = $sheet1;
+        }
+        $supbook_index = 0x00;
+        $ref = pack('vvv', $supbook_index, $sheet1, $sheet2);
+        $totalreferences = count($this->references);
+        $index = -1;
+        for ($i = 0; $i < $totalreferences; ++$i) {
+            if ($ref == $this->references[$i]) {
+                $index = $i;
+                break;
+            }
+        }
+        if ($index == -1) {
+            $this->references[$totalreferences] = $ref;
+            $index = $totalreferences;
+        }
+        return pack('v', $index);
+    }
+    /**
+     * Look up the index that corresponds to an external sheet name. The hash of
+     * sheet names is updated by the addworksheet() method of the
+     * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
+     *
+     * @param string $sheet_name Sheet name
+     *
+     * @return int The sheet index, -1 if the sheet was not found
+     */
+    private function getSheetIndex(string $sheet_name): int
+    {
+        if (!isset($this->externalSheets[$sheet_name])) {
+            return -1;
+        }
+        return $this->externalSheets[$sheet_name];
+    }
+    /**
+     * This method is used to update the array of sheet names. It is
+     * called by the addWorksheet() method of the
+     * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
+     *
+     * @param string $name The name of the worksheet being added
+     * @param int $index The index of the worksheet being added
+     *
+     * @see Workbook::addWorksheet
+     */
+    public function setExtSheet(string $name, int $index): void
+    {
+        $this->externalSheets[$name] = $index;
+    }
+    /**
+     * pack() row and column into the required 3 or 4 byte format.
+     *
+     * @param string $cell The Excel cell reference to be packed
+     *
+     * @return array Array containing the row and column in packed() format
+     */
+    private function cellToPackedRowcol(string $cell): array
+    {
+        $cell = strtoupper($cell);
+        [$row, $col, $row_rel, $col_rel] = $this->cellToRowcol($cell);
+        if ($col >= 256) {
+            throw new WriterException("Column in: $cell greater than 255");
+        }
+        if ($row >= 65536) {
+            throw new WriterException("Row in: $cell greater than 65536 ");
+        }
+        $col |= $col_rel << 14;
+        $col |= $row_rel << 15;
+        $col = pack('v', $col);
+        $row = pack('v', $row);
+        return [$row, $col];
+    }
+    /**
+     * pack() row range into the required 3 or 4 byte format.
+     * Just using maximum col/rows, which is probably not the correct solution.
+     *
+     * @param string $range The Excel range to be packed
+     *
+     * @return array Array containing (row1,col1,row2,col2) in packed() format
+     */
+    private function rangeToPackedRange(string $range): array
+    {
+        preg_match('/(\$)?(\d+)\:(\$)?(\d+)/', $range, $match);
+        $row1_rel = empty($match[1]) ? 1 : 0;
+        $row1 = $match[2];
+        $row2_rel = empty($match[3]) ? 1 : 0;
+        $row2 = $match[4];
+        --$row1;
+        --$row2;
+        $col1 = 0;
+        $col2 = 65535; // FIXME: maximum possible value for Excel 5 (change this!!!)
+        if (($row1 >= 65536) || ($row2 >= 65536)) {
+            throw new WriterException("Row in: $range greater than 65536 ");
+        }
+        $col1 |= $row1_rel << 15;
+        $col2 |= $row2_rel << 15;
+        $col1 = pack('v', $col1);
+        $col2 = pack('v', $col2);
+        $row1 = pack('v', $row1);
+        $row2 = pack('v', $row2);
+        return [$row1, $col1, $row2, $col2];
+    }
+    /**
+     * Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
+     * indexed row and column number. Also returns two (0,1) values to indicate
+     * whether the row or column are relative references.
+     *
+     * @param string $cell the Excel cell reference in A1 format
+     */
+    private function cellToRowcol(string $cell): array
+    {
+        preg_match('/(\$)?([A-I]?[A-Z])(\$)?(\d+)/', $cell, $match);
+        $col_rel = empty($match[1]) ? 1 : 0;
+        $col_ref = $match[2];
+        $row_rel = empty($match[3]) ? 1 : 0;
+        $row = $match[4];
+        $expn = strlen($col_ref) - 1;
+        $col = 0;
+        $col_ref_length = strlen($col_ref);
+        for ($i = 0; $i < $col_ref_length; ++$i) {
+            $col += (ord($col_ref[$i]) - 64) * 26 ** $expn;
+            --$expn;
+        }
+        --$row;
+        --$col;
+        return [$row, $col, $row_rel, $col_rel];
+    }
+    /**
+     * Advance to the next valid token.
+     */
+    private function advance(): void
+    {
+        $token = '';
+        $i = $this->currentCharacter;
+        $formula_length = strlen($this->formula);
+        if ($i < $formula_length) {
+            while ($this->formula[$i] == ' ') {
+                ++$i;
+            }
+            if ($i < ($formula_length - 1)) {
+                $this->lookAhead = $this->formula[$i + 1];
+            }
+            $token = '';
+        }
+        while ($i < $formula_length) {
+            $token .= $this->formula[$i];
+            if ($i < ($formula_length - 1)) {
+                $this->lookAhead = $this->formula[$i + 1];
+            } else {
+                $this->lookAhead = '';
+            }
+            if ($this->match($token) != '') {
+                $this->currentCharacter = $i + 1;
+                $this->currentToken = $token;
+                return;
+            }
+            if ($i < ($formula_length - 2)) {
+                $this->lookAhead = $this->formula[$i + 2];
+            } else { // if we run out of characters lookAhead becomes empty
+                $this->lookAhead = '';
+            }
+            ++$i;
+        }
+    }
+    /**
+     * Checks if it's a valid token.
+     *
+     * @param string $token the token to check
+     *
+     * @return string The checked token or empty string on failure
+     */
+    private function match(string $token): string
+    {
+        switch ($token) {
+            case '+':
+            case '-':
+            case '*':
+            case '/':
+            case '(':
+            case ')':
+            case ',':
+            case ';':
+            case '>=':
+            case '<=':
+            case '=':
+            case '<>':
+            case '^':
+            case '&':
+            case '%':
+                return $token;
+            case '>':
+                if ($this->lookAhead === '=') { // it's a GE token
+                    break;
+                }
+                return $token;
+            case '<':
+                if (($this->lookAhead === '=') || ($this->lookAhead === '>')) {
+                    break;
+                }
+                return $token;
+        }
+        if (preg_match('/^\$?[A-Ia-i]?[A-Za-z]\$?\d+$/', $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.') && ($this->lookAhead !== '!')) {
+            return $token;
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?\\d+$/u', $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.')) {
+            return $token;
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?\\d+$/u", $token) && !preg_match('/\d/', $this->lookAhead) && ($this->lookAhead !== ':') && ($this->lookAhead !== '.')) {
+            return $token;
+        }
+        if (preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+:(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $token) && !preg_match('/\d/', $this->lookAhead)) {
+            return $token;
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?\\d+:\$?([A-Ia-i]?[A-Za-z])?\$?\\d+$/u', $token) && !preg_match('/\d/', $this->lookAhead)) {
+            return $token;
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+:\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+$/u", $token) && !preg_match('/\d/', $this->lookAhead)) {
+            return $token;
+        }
+        if (is_numeric($token) && (!is_numeric($token . $this->lookAhead) || ($this->lookAhead == '')) && ($this->lookAhead !== '!') && ($this->lookAhead !== ':')) {
+            return $token;
+        }
+        if (preg_match('/"([^"]|""){0,255}"/', $token) && $this->lookAhead !== '"' && (substr_count($token, '"') % 2 == 0)) {
+            return $token;
+        }
+        if (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $token) || $token === '#N/A') {
+            return $token;
+        }
+        if (preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/i", $token) && ($this->lookAhead === '(')) {
+            return $token;
+        }
+        if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $token) && $this->spreadsheet->getDefinedName($token) !== null) {
+            return $token;
+        }
+        if (preg_match('/^true$/i', $token) && ($this->lookAhead === ')' || $this->lookAhead === ',')) {
+            return $token;
+        }
+        if (preg_match('/^false$/i', $token) && ($this->lookAhead === ')' || $this->lookAhead === ',')) {
+            return $token;
+        }
+        if (str_ends_with($token, ')')) {
+            return $token;
+        }
+        return '';
+    }
+    /**
+     * The parsing method. It parses a formula.
+     *
+     * @param string $formula the formula to parse, without the initial equal
+     *                        sign (=)
+     *
+     * @return bool true on success
+     */
+    public function parse(string $formula): bool
+    {
+        $this->currentCharacter = 0;
+        $this->formula = (string) $formula;
+        $this->lookAhead = $formula[1] ?? '';
+        $this->advance();
+        $this->parseTree = $this->condition();
+        return true;
+    }
+    /**
+     * It parses a condition. It assumes the following rule:
+     * Cond -> Expr [(">" | "<") Expr].
+     *
+     * @return array The parsed ptg'd tree on success
+     */
+    private function condition(): array
+    {
+        $result = $this->expression();
+        if ($this->currentToken == '<') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgLT', $result, $result2);
+        } elseif ($this->currentToken == '>') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgGT', $result, $result2);
+        } elseif ($this->currentToken == '<=') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgLE', $result, $result2);
+        } elseif ($this->currentToken == '>=') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgGE', $result, $result2);
+        } elseif ($this->currentToken == '=') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgEQ', $result, $result2);
+        } elseif ($this->currentToken == '<>') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgNE', $result, $result2);
+        }
+        return $result;
+    }
+    /**
+     * It parses a expression. It assumes the following rule:
+     * Expr -> Term [("+" | "-") Term]
+     *      -> "string"
+     *      -> "-" Term : Negative value
+     *      -> "+" Term : Positive value
+     *      -> Error code.
+     *
+     * @return array The parsed ptg'd tree on success
+     */
+    private function expression(): array
+    {
+        if (preg_match('/"([^"]|""){0,255}"/', $this->currentToken)) {
+            $tmp = str_replace('""', '"', $this->currentToken);
+            if (($tmp == '"') || ($tmp == '')) {
+                $tmp = '""';
+            }
+            $result = $this->createTree($tmp, '', '');
+            $this->advance();
+            return $result;
+        } elseif (preg_match('/^#[A-Z0\\/]{3,5}[!?]{1}$/', $this->currentToken) || $this->currentToken == '#N/A') { // error code
+            $result = $this->createTree($this->currentToken, 'ptgErr', '');
+            $this->advance();
+            return $result;
+        } elseif ($this->currentToken == '-') { // negative value
+            $this->advance();
+            $result2 = $this->expression();
+            return $this->createTree('ptgUminus', $result2, '');
+        } elseif ($this->currentToken == '+') { // positive value
+            $this->advance();
+            $result2 = $this->expression();
+            return $this->createTree('ptgUplus', $result2, '');
+        }
+        $result = $this->term();
+        while ($this->currentToken === '&') {
+            $this->advance();
+            $result2 = $this->expression();
+            $result = $this->createTree('ptgConcat', $result, $result2);
+        }
+        while (
+            ($this->currentToken == '+')
+            || ($this->currentToken == '-')
+            || ($this->currentToken == '^')
+        ) {
+            if ($this->currentToken == '+') {
+                $this->advance();
+                $result2 = $this->term();
+                $result = $this->createTree('ptgAdd', $result, $result2);
+            } elseif ($this->currentToken == '-') {
+                $this->advance();
+                $result2 = $this->term();
+                $result = $this->createTree('ptgSub', $result, $result2);
+            } else {
+                $this->advance();
+                $result2 = $this->term();
+                $result = $this->createTree('ptgPower', $result, $result2);
+            }
+        }
+        return $result;
+    }
+    /**
+     * This function just introduces a ptgParen element in the tree, so that Excel
+     * doesn't get confused when working with a parenthesized formula afterwards.
+     *
+     * @return array The parsed ptg'd tree
+     *
+     * @see fact()
+     */
+    private function parenthesizedExpression(): array
+    {
+        return $this->createTree('ptgParen', $this->expression(), '');
+    }
+    /**
+     * It parses a term. It assumes the following rule:
+     * Term -> Fact [("*" | "/") Fact].
+     *
+     * @return array The parsed ptg'd tree on success
+     */
+    private function term(): array
+    {
+        $result = $this->fact();
+        while (
+            ($this->currentToken == '*')
+            || ($this->currentToken == '/')
+        ) {
+            if ($this->currentToken == '*') {
+                $this->advance();
+                $result2 = $this->fact();
+                $result = $this->createTree('ptgMul', $result, $result2);
+            } else {
+                $this->advance();
+                $result2 = $this->fact();
+                $result = $this->createTree('ptgDiv', $result, $result2);
+            }
+        }
+        return $result;
+    }
+    /**
+     * It parses a factor. It assumes the following rule:
+     * Fact -> ( Expr )
+     *       | CellRef
+     *       | CellRange
+     *       | Number
+     *       | Function.
+     *
+     * @return array The parsed ptg'd tree on success
+     */
+    private function fact(): array
+    {
+        $currentToken = $this->currentToken;
+        if ($currentToken === '(') {
+            $this->advance(); // eat the "("
+            $result = $this->parenthesizedExpression();
+            if ($this->currentToken !== ')') {
+                throw new WriterException("')' token expected.");
+            }
+            $this->advance(); // eat the ")"
+            return $result;
+        }
+        if (preg_match('/^\$?[A-Ia-i]?[A-Za-z]\$?\d+$/', $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?\\d+$/u', $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?\\d+$/u", $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (
+            preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+:(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $this->currentToken)
+            || preg_match('/^(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+\.\.(\$)?[A-Ia-i]?[A-Za-z](\$)?\d+$/', $this->currentToken)
+        ) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (preg_match('/^' . self::REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self::REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?\\d+:\$?([A-Ia-i]?[A-Za-z])?\$?\\d+$/u', $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (preg_match("/^'" . self::REGEX_SHEET_TITLE_QUOTED . '(\\:' . self::REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+:\\$?([A-Ia-i]?[A-Za-z])?\\$?\\d+$/u", $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        if (is_numeric($this->currentToken)) {
+            if ($this->lookAhead === '%') {
+                $result = $this->createTree('ptgPercent', $this->currentToken, '');
+                $this->advance(); // Skip the percentage operator once we've pre-built that tree
+            } else {
+                $result = $this->createTree($this->currentToken, '', '');
+            }
+            $this->advance();
+            return $result;
+        }
+        if (preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/i", $this->currentToken) && ($this->lookAhead === '(')) {
+            return $this->func();
+        }
+        if (preg_match('/^' . Calculation::CALCULATION_REGEXP_DEFINEDNAME . '$/miu', $this->currentToken) && $this->spreadsheet->getDefinedName($this->currentToken) !== null) {
+            $result = $this->createTree('ptgName', $this->currentToken, '');
+            $this->advance();
+            return $result;
+        }
+        if (preg_match('/^true|false$/i', $this->currentToken)) {
+            $result = $this->createTree($this->currentToken, '', '');
+            $this->advance();
+            return $result;
+        }
+        throw new WriterException('Syntax error: ' . $this->currentToken . ', lookahead: ' . $this->lookAhead . ', current char: ' . $this->currentCharacter);
+    }
+    /**
+     * It parses a function call. It assumes the following rule:
+     * Func -> ( Expr [,Expr]* ).
+     *
+     * @return array The parsed ptg'd tree on success
+     */
+    private function func(): array
+    {
+        $num_args = 0; // number of arguments received
+        $function = strtoupper($this->currentToken);
+        $result = ''; // initialize result
+        $this->advance();
+        $this->advance(); // eat the "("
+        while ($this->currentToken !== ')') {
+            if ($num_args > 0) {
+                if ($this->currentToken === ',' || $this->currentToken === ';') {
+                    $this->advance(); // eat the "," or ";"
+                } else {
+                    throw new WriterException("Syntax error: comma expected in function $function, arg #{$num_args}");
+                }
+                $result2 = $this->condition();
+                $result = $this->createTree('arg', $result, $result2);
+            } else { // first argument
+                $result2 = $this->condition();
+                $result = $this->createTree('arg', '', $result2);
+            }
+            ++$num_args;
+        }
+        if (!isset($this->functions[$function])) {
+            throw new WriterException("Function $function() doesn't exist");
+        }
+        $args = $this->functions[$function][1];
+        if (($args >= 0) && ($args != $num_args)) {
+            throw new WriterException("Incorrect number of arguments in function $function() ");
+        }
+        $result = $this->createTree($function, $result, $num_args);
+        $this->advance(); // eat the ")"
+        return $result;
+    }
+    /**
+     * Creates a tree. In fact an array which may have one or two arrays (sub-trees)
+     * as elements.
+     *
+     * @param mixed $value the value of this node
+     * @param mixed $left the left array (sub-tree) or a final node
+     * @param mixed $right the right array (sub-tree) or a final node
+     *
+     * @return array A tree
+     */
+    private function createTree(mixed $value, mixed $left, mixed $right): array
+    {
+        return ['value' => $value, 'left' => $left, 'right' => $right];
+    }
+    /**
+     * Builds a string containing the tree in reverse polish notation (What you
+     * would use in a HP calculator stack).
+     * The following tree:.
+     *
+     *    +
+     *   / \
+     *  2   3
+     *
+     * produces: "23+"
+     *
+     * The following tree:
+     *
+     *    +
+     *   / \
+     *  3   *
+     *     / \
+     *    6   A1
+     *
+     * produces: "36A1*+"
+     *
+     * In fact all operands, functions, references, etc... are written as ptg's
+     *
+     * @param array $tree the optional tree to convert
+     *
+     * @return string The tree in reverse polish notation
+     */
+    public function toReversePolish(array $tree = []): string
+    {
+        $polish = ''; // the string we are going to return
+        if (empty($tree)) { // If it's the first call use parseTree
+            $tree = $this->parseTree;
+        }
+        if (!is_array($tree) || !isset($tree['left'], $tree['right'], $tree['value'])) {
+            throw new WriterException('Unexpected non-array');
+        }
+        if (is_array($tree['left'])) {
+            $converted_tree = $this->toReversePolish($tree['left']);
+            $polish .= $converted_tree;
+        } elseif ($tree['left'] != '') { // It's a final node
+            $converted_tree = $this->convert($tree['left']);
+            $polish .= $converted_tree;
+        }
+        if (is_array($tree['right'])) {
+            $converted_tree = $this->toReversePolish($tree['right']);
+            $polish .= $converted_tree;
+        } elseif ($tree['right'] != '') { // It's a final node
+            $converted_tree = $this->convert($tree['right']);
+            $polish .= $converted_tree;
+        }
+        if (
+            preg_match("/^[A-Z0-9\xc0-\xdc\\.]+$/", $tree['value'])
+            && !preg_match('/^([A-Ia-i]?[A-Za-z])(\d+)$/', $tree['value'])
+            && !preg_match('/^[A-Ia-i]?[A-Za-z](\\d+)\\.\\.[A-Ia-i]?[A-Za-z](\\d+)$/', $tree['value'])
+            && !is_numeric($tree['value'])
+            && !isset($this->ptg[$tree['value']])
+        ) {
+            if ($tree['left'] != '') {
+                $left_tree = $this->toReversePolish($tree['left']);
+            } else {
+                $left_tree = '';
+            }
+            return $left_tree . $this->convertFunction($tree['value'], $tree['right']);
+        }
+        $converted_tree = $this->convert($tree['value']);
+        return $polish . $converted_tree;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xls/Style/ColorMap.php
@@ -0,0 +1,72 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xls\Style;
+use PhpOffice\PhpSpreadsheet\Style\Color;
+/*
+ * Static array incorrectly used by Xls Writer for Conditional Styles.
+ *
+ * @deprecated since version 2.2
+ *
+ * @codecoverageignore
+ */
+class ColorMap
+{
+    /**
+     * @var array<string, int>
+     */
+    private static array $colorMap = [
+        '#000000' => 0x08,
+        '#FFFFFF' => 0x09,
+        '#FF0000' => 0x0A,
+        '#00FF00' => 0x0B,
+        '#0000FF' => 0x0C,
+        '#FFFF00' => 0x0D,
+        '#FF00FF' => 0x0E,
+        '#00FFFF' => 0x0F,
+        '#800000' => 0x10,
+        '#008000' => 0x11,
+        '#000080' => 0x12,
+        '#808000' => 0x13,
+        '#800080' => 0x14,
+        '#008080' => 0x15,
+        '#C0C0C0' => 0x16,
+        '#808080' => 0x17,
+        '#9999FF' => 0x18,
+        '#993366' => 0x19,
+        '#FFFFCC' => 0x1A,
+        '#CCFFFF' => 0x1B,
+        '#660066' => 0x1C,
+        '#FF8080' => 0x1D,
+        '#0066CC' => 0x1E,
+        '#CCCCFF' => 0x1F,
+        '#00CCFF' => 0x28,
+        '#CCFFCC' => 0x2A,
+        '#FFFF99' => 0x2B,
+        '#99CCFF' => 0x2C,
+        '#FF99CC' => 0x2D,
+        '#CC99FF' => 0x2E,
+        '#FFCC99' => 0x2F,
+        '#3366FF' => 0x30,
+        '#33CCCC' => 0x31,
+        '#99CC00' => 0x32,
+        '#FFCC00' => 0x33,
+        '#FF9900' => 0x34,
+        '#FF6600' => 0x35,
+        '#666699' => 0x36,
+        '#969696' => 0x37,
+        '#003366' => 0x38,
+        '#339966' => 0x39,
+        '#003300' => 0x3A,
+        '#333300' => 0x3B,
+        '#993300' => 0x3C,
+        '#333399' => 0x3E,
+        '#333333' => 0x3F,
+    ];
+    public static function lookup(Color $color, int $defaultIndex = 0x00): int
+    {
+        $colorRgb = strtoupper($color->getRGB());
+        if (is_string($colorRgb) && array_key_exists("#{$colorRgb}", self::$colorMap)) {
+            return self::$colorMap["#{$colorRgb}"];
+        }
+        return $defaultIndex;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xls/Workbook.php
@@ -0,0 +1,820 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
+use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\DefinedName;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Style;
+class Workbook extends BIFFwriter
+{
+    /**
+     * Formula parser.
+     */
+    private Parser $parser;
+    /*
+     * The BIFF file size for the workbook. Not currently used.
+     *
+     * @see calcSheetOffsets()
+     */
+    /**
+     * XF Writers.
+     *
+     * @var Xf[]
+     */
+    private array $xfWriters = [];
+    /**
+     * Array containing the colour palette.
+     */
+    private array $palette;
+    /**
+     * The codepage indicates the text encoding used for strings.
+     */
+    private int $codepage;
+    /**
+     * The country code used for localization.
+     */
+    private int $countryCode;
+    /**
+     * Workbook.
+     */
+    private Spreadsheet $spreadsheet;
+    /**
+     * Fonts writers.
+     *
+     * @var Font[]
+     */
+    private array $fontWriters = [];
+    /**
+     * Added fonts. Maps from font's hash => index in workbook.
+     */
+    private array $addedFonts = [];
+    /**
+     * Shared number formats.
+     */
+    private array $numberFormats = [];
+    /**
+     * Added number formats. Maps from numberFormat's hash => index in workbook.
+     */
+    private array $addedNumberFormats = [];
+    /**
+     * Sizes of the binary worksheet streams.
+     */
+    private array $worksheetSizes = [];
+    /**
+     * Offsets of the binary worksheet streams relative to the start of the global workbook stream.
+     */
+    private array $worksheetOffsets = [];
+    /**
+     * Total number of shared strings in workbook.
+     */
+    private int $stringTotal;
+    /**
+     * Number of unique shared strings in workbook.
+     */
+    private int $stringUnique;
+    /**
+     * Array of unique shared strings in workbook.
+     */
+    private array $stringTable;
+    /**
+     * Color cache.
+     */
+    private array $colors;
+    /**
+     * Escher object corresponding to MSODRAWINGGROUP.
+     */
+    private ?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher = null;
+    /**
+     * Class constructor.
+     *
+     * @param Spreadsheet $spreadsheet The Workbook
+     * @param int $str_total Total number of strings
+     * @param int $str_unique Total number of unique strings
+     * @param array $str_table String Table
+     * @param array $colors Colour Table
+     * @param Parser $parser The formula parser created for the Workbook
+     */
+    public function __construct(Spreadsheet $spreadsheet, int &$str_total, int &$str_unique, array &$str_table, array &$colors, Parser $parser)
+    {
+        parent::__construct();
+        $this->parser = $parser;
+        $this->palette = [];
+        $this->countryCode = -1;
+        $this->stringTotal = &$str_total;
+        $this->stringUnique = &$str_unique;
+        $this->stringTable = &$str_table;
+        $this->colors = &$colors;
+        $this->setPaletteXl97();
+        $this->spreadsheet = $spreadsheet;
+        $this->codepage = 0x04B0;
+        $countSheets = $spreadsheet->getSheetCount();
+        for ($i = 0; $i < $countSheets; ++$i) {
+            $phpSheet = $spreadsheet->getSheet($i);
+            $this->parser->setExtSheet($phpSheet->getTitle(), $i); // Register worksheet name with parser
+            $supbook_index = 0x00;
+            $ref = pack('vvv', $supbook_index, $i, $i);
+            $this->parser->references[] = $ref; // Register reference with parser
+            if ($phpSheet->isTabColorSet()) {
+                $this->addColor($phpSheet->getTabColor()->getRGB());
+            }
+        }
+    }
+    /**
+     * Add a new XF writer.
+     *
+     * @param bool $isStyleXf Is it a style XF?
+     *
+     * @return int Index to XF record
+     */
+    public function addXfWriter(Style $style, bool $isStyleXf = false): int
+    {
+        $xfWriter = new Xf($style);
+        $xfWriter->setIsStyleXf($isStyleXf);
+        $fontIndex = $this->addFont($style->getFont());
+        $xfWriter->setFontIndex($fontIndex);
+        $xfWriter->setFgColor($this->addColor($style->getFill()->getStartColor()->getRGB()));
+        $xfWriter->setBgColor($this->addColor($style->getFill()->getEndColor()->getRGB()));
+        $xfWriter->setBottomColor($this->addColor($style->getBorders()->getBottom()->getColor()->getRGB()));
+        $xfWriter->setTopColor($this->addColor($style->getBorders()->getTop()->getColor()->getRGB()));
+        $xfWriter->setRightColor($this->addColor($style->getBorders()->getRight()->getColor()->getRGB()));
+        $xfWriter->setLeftColor($this->addColor($style->getBorders()->getLeft()->getColor()->getRGB()));
+        $xfWriter->setDiagColor($this->addColor($style->getBorders()->getDiagonal()->getColor()->getRGB()));
+        if ($style->getNumberFormat()->getBuiltInFormatCode() === false) {
+            $numberFormatHashCode = $style->getNumberFormat()->getHashCode();
+            if (isset($this->addedNumberFormats[$numberFormatHashCode])) {
+                $numberFormatIndex = $this->addedNumberFormats[$numberFormatHashCode];
+            } else {
+                $numberFormatIndex = 164 + count($this->numberFormats);
+                $this->numberFormats[$numberFormatIndex] = $style->getNumberFormat();
+                $this->addedNumberFormats[$numberFormatHashCode] = $numberFormatIndex;
+            }
+        } else {
+            $numberFormatIndex = (int) $style->getNumberFormat()->getBuiltInFormatCode();
+        }
+        $xfWriter->setNumberFormatIndex($numberFormatIndex);
+        $this->xfWriters[] = $xfWriter;
+        return count($this->xfWriters) - 1;
+    }
+    /**
+     * Add a font to added fonts.
+     *
+     * @return int Index to FONT record
+     */
+    public function addFont(\PhpOffice\PhpSpreadsheet\Style\Font $font): int
+    {
+        $fontHashCode = $font->getHashCode();
+        if (isset($this->addedFonts[$fontHashCode])) {
+            $fontIndex = $this->addedFonts[$fontHashCode];
+        } else {
+            $countFonts = count($this->fontWriters);
+            $fontIndex = ($countFonts < 4) ? $countFonts : $countFonts + 1;
+            $fontWriter = new Font($font);
+            $fontWriter->setColorIndex($this->addColor($font->getColor()->getRGB()));
+            $this->fontWriters[] = $fontWriter;
+            $this->addedFonts[$fontHashCode] = $fontIndex;
+        }
+        return $fontIndex;
+    }
+    /**
+     * Alter color palette adding a custom color.
+     *
+     * @param string $rgb E.g. 'FF00AA'
+     *
+     * @return int Color index
+     */
+    public function addColor(string $rgb, int $default = 0): int
+    {
+        if (!isset($this->colors[$rgb])) {
+            $color
+                = [
+                    hexdec(substr($rgb, 0, 2)),
+                    hexdec(substr($rgb, 2, 2)),
+                    hexdec(substr($rgb, 4)),
+                    0,
+                ];
+            $colorIndex = array_search($color, $this->palette);
+            if ($colorIndex) {
+                $this->colors[$rgb] = $colorIndex;
+            } else {
+                if (count($this->colors) === 0) {
+                    $lastColor = 7;
+                } else {
+                    $lastColor = end($this->colors);
+                }
+                if ($lastColor < 57) {
+                    $colorIndex = $lastColor + 1;
+                    $this->palette[$colorIndex] = $color;
+                    $this->colors[$rgb] = $colorIndex;
+                } else {
+                    $colorIndex = $default;
+                }
+            }
+        } else {
+            $colorIndex = $this->colors[$rgb];
+        }
+        return $colorIndex;
+    }
+    /**
+     * Sets the colour palette to the Excel 97+ default.
+     */
+    private function setPaletteXl97(): void
+    {
+        $this->palette = [
+            0x08 => [0x00, 0x00, 0x00, 0x00],
+            0x09 => [0xFF, 0xFF, 0xFF, 0x00],
+            0x0A => [0xFF, 0x00, 0x00, 0x00],
+            0x0B => [0x00, 0xFF, 0x00, 0x00],
+            0x0C => [0x00, 0x00, 0xFF, 0x00],
+            0x0D => [0xFF, 0xFF, 0x00, 0x00],
+            0x0E => [0xFF, 0x00, 0xFF, 0x00],
+            0x0F => [0x00, 0xFF, 0xFF, 0x00],
+            0x10 => [0x80, 0x00, 0x00, 0x00],
+            0x11 => [0x00, 0x80, 0x00, 0x00],
+            0x12 => [0x00, 0x00, 0x80, 0x00],
+            0x13 => [0x80, 0x80, 0x00, 0x00],
+            0x14 => [0x80, 0x00, 0x80, 0x00],
+            0x15 => [0x00, 0x80, 0x80, 0x00],
+            0x16 => [0xC0, 0xC0, 0xC0, 0x00],
+            0x17 => [0x80, 0x80, 0x80, 0x00],
+            0x18 => [0x99, 0x99, 0xFF, 0x00],
+            0x19 => [0x99, 0x33, 0x66, 0x00],
+            0x1A => [0xFF, 0xFF, 0xCC, 0x00],
+            0x1B => [0xCC, 0xFF, 0xFF, 0x00],
+            0x1C => [0x66, 0x00, 0x66, 0x00],
+            0x1D => [0xFF, 0x80, 0x80, 0x00],
+            0x1E => [0x00, 0x66, 0xCC, 0x00],
+            0x1F => [0xCC, 0xCC, 0xFF, 0x00],
+            0x20 => [0x00, 0x00, 0x80, 0x00],
+            0x21 => [0xFF, 0x00, 0xFF, 0x00],
+            0x22 => [0xFF, 0xFF, 0x00, 0x00],
+            0x23 => [0x00, 0xFF, 0xFF, 0x00],
+            0x24 => [0x80, 0x00, 0x80, 0x00],
+            0x25 => [0x80, 0x00, 0x00, 0x00],
+            0x26 => [0x00, 0x80, 0x80, 0x00],
+            0x27 => [0x00, 0x00, 0xFF, 0x00],
+            0x28 => [0x00, 0xCC, 0xFF, 0x00],
+            0x29 => [0xCC, 0xFF, 0xFF, 0x00],
+            0x2A => [0xCC, 0xFF, 0xCC, 0x00],
+            0x2B => [0xFF, 0xFF, 0x99, 0x00],
+            0x2C => [0x99, 0xCC, 0xFF, 0x00],
+            0x2D => [0xFF, 0x99, 0xCC, 0x00],
+            0x2E => [0xCC, 0x99, 0xFF, 0x00],
+            0x2F => [0xFF, 0xCC, 0x99, 0x00],
+            0x30 => [0x33, 0x66, 0xFF, 0x00],
+            0x31 => [0x33, 0xCC, 0xCC, 0x00],
+            0x32 => [0x99, 0xCC, 0x00, 0x00],
+            0x33 => [0xFF, 0xCC, 0x00, 0x00],
+            0x34 => [0xFF, 0x99, 0x00, 0x00],
+            0x35 => [0xFF, 0x66, 0x00, 0x00],
+            0x36 => [0x66, 0x66, 0x99, 0x00],
+            0x37 => [0x96, 0x96, 0x96, 0x00],
+            0x38 => [0x00, 0x33, 0x66, 0x00],
+            0x39 => [0x33, 0x99, 0x66, 0x00],
+            0x3A => [0x00, 0x33, 0x00, 0x00],
+            0x3B => [0x33, 0x33, 0x00, 0x00],
+            0x3C => [0x99, 0x33, 0x00, 0x00],
+            0x3D => [0x99, 0x33, 0x66, 0x00],
+            0x3E => [0x33, 0x33, 0x99, 0x00],
+            0x3F => [0x33, 0x33, 0x33, 0x00],
+        ];
+    }
+    /**
+     * Assemble worksheets into a workbook and send the BIFF data to an OLE
+     * storage.
+     *
+     * @param array $worksheetSizes The sizes in bytes of the binary worksheet streams
+     *
+     * @return string Binary data for workbook stream
+     */
+    public function writeWorkbook(array $worksheetSizes): string
+    {
+        $this->worksheetSizes = $worksheetSizes;
+        $total_worksheets = $this->spreadsheet->getSheetCount();
+        $this->storeBof(0x0005);
+        $this->writeCodepage();
+        $this->writeWindow1();
+        $this->writeDateMode();
+        $this->writeAllFonts();
+        $this->writeAllNumberFormats();
+        $this->writeAllXfs();
+        $this->writeAllStyles();
+        $this->writePalette();
+        $part3 = '';
+        if ($this->countryCode !== -1) {
+            $part3 .= $this->writeCountry();
+        }
+        $part3 .= $this->writeRecalcId();
+        $part3 .= $this->writeSupbookInternal();
+        /* TODO: store external SUPBOOK records and XCT and CRN records
+        in case of external references for BIFF8 */
+        $part3 .= $this->writeExternalsheetBiff8();
+        $part3 .= $this->writeAllDefinedNamesBiff8();
+        $part3 .= $this->writeMsoDrawingGroup();
+        $part3 .= $this->writeSharedStringsTable();
+        $part3 .= $this->writeEof();
+        $this->calcSheetOffsets();
+        for ($i = 0; $i < $total_worksheets; ++$i) {
+            $this->writeBoundSheet($this->spreadsheet->getSheet($i), $this->worksheetOffsets[$i]);
+        }
+        $this->_data .= $part3;
+        return $this->_data;
+    }
+    /**
+     * Calculate offsets for Worksheet BOF records.
+     */
+    private function calcSheetOffsets(): void
+    {
+        $boundsheet_length = 10; // fixed length for a BOUNDSHEET record
+        $offset = $this->_datasize;
+        $total_worksheets = count($this->spreadsheet->getAllSheets());
+        foreach ($this->spreadsheet->getWorksheetIterator() as $sheet) {
+            $offset += $boundsheet_length + strlen(StringHelper::UTF8toBIFF8UnicodeShort($sheet->getTitle()));
+        }
+        for ($i = 0; $i < $total_worksheets; ++$i) {
+            $this->worksheetOffsets[$i] = $offset;
+            $offset += $this->worksheetSizes[$i];
+        }
+    }
+    /**
+     * Store the Excel FONT records.
+     */
+    private function writeAllFonts(): void
+    {
+        foreach ($this->fontWriters as $fontWriter) {
+            $this->append($fontWriter->writeFont());
+        }
+    }
+    /**
+     * Store user defined numerical formats i.e. FORMAT records.
+     */
+    private function writeAllNumberFormats(): void
+    {
+        foreach ($this->numberFormats as $numberFormatIndex => $numberFormat) {
+            $this->writeNumberFormat($numberFormat->getFormatCode(), $numberFormatIndex);
+        }
+    }
+    /**
+     * Write all XF records.
+     */
+    private function writeAllXfs(): void
+    {
+        foreach ($this->xfWriters as $xfWriter) {
+            $this->append($xfWriter->writeXf());
+        }
+    }
+    /**
+     * Write all STYLE records.
+     */
+    private function writeAllStyles(): void
+    {
+        $this->writeStyle();
+    }
+    private function parseDefinedNameValue(DefinedName $definedName): string
+    {
+        $definedRange = $definedName->getValue();
+        $splitCount = preg_match_all(
+            '/' . Calculation::CALCULATION_REGEXP_CELLREF . '/mui',
+            $definedRange,
+            $splitRanges,
+            PREG_OFFSET_CAPTURE
+        );
+        $lengths = array_map('strlen', array_column($splitRanges[0], 0));
+        $offsets = array_column($splitRanges[0], 1);
+        $worksheets = $splitRanges[2];
+        $columns = $splitRanges[6];
+        $rows = $splitRanges[7];
+        while ($splitCount > 0) {
+            --$splitCount;
+            $length = $lengths[$splitCount];
+            $offset = $offsets[$splitCount];
+            $worksheet = $worksheets[$splitCount][0];
+            $column = $columns[$splitCount][0];
+            $row = $rows[$splitCount][0];
+            $newRange = '';
+            if (empty($worksheet)) {
+                if (($offset === 0) || ($definedRange[$offset - 1] !== ':')) {
+                    $worksheet = $definedName->getWorksheet() ? $definedName->getWorksheet()->getTitle() : null;
+                }
+            } else {
+                $worksheet = str_replace("''", "'", trim($worksheet, "'"));
+            }
+            if (!empty($worksheet)) {
+                $newRange = "'" . str_replace("'", "''", $worksheet) . "'!";
+            }
+            if (!empty($column)) {
+                $newRange .= "\${$column}";
+            }
+            if (!empty($row)) {
+                $newRange .= "\${$row}";
+            }
+            $definedRange = substr($definedRange, 0, $offset) . $newRange . substr($definedRange, $offset + $length);
+        }
+        return $definedRange;
+    }
+    /**
+     * Writes all the DEFINEDNAME records (BIFF8).
+     * So far this is only used for repeating rows/columns (print titles) and print areas.
+     */
+    private function writeAllDefinedNamesBiff8(): string
+    {
+        $chunk = '';
+        $definedNames = $this->spreadsheet->getDefinedNames();
+        if (count($definedNames) > 0) {
+            foreach ($definedNames as $definedName) {
+                $range = $this->parseDefinedNameValue($definedName);
+                try {
+                    $this->parser->parse($range);
+                    $formulaData = $this->parser->toReversePolish();
+                    if (isset($formulaData[0]) && ($formulaData[0] == "\x7A" || $formulaData[0] == "\x5A")) {
+                        $formulaData = "\x3A" . substr($formulaData, 1);
+                    }
+                    if ($definedName->getLocalOnly()) {
+                        $scopeWs = $definedName->getScope();
+                        $scope = ($scopeWs === null) ? 0 : ($this->spreadsheet->getIndex($scopeWs) + 1);
+                    } else {
+                        $scope = 0;
+                    }
+                    $chunk .= $this->writeData($this->writeDefinedNameBiff8($definedName->getName(), $formulaData, $scope, false));
+                } catch (PhpSpreadsheetException) {
+                }
+            }
+        }
+        $total_worksheets = $this->spreadsheet->getSheetCount();
+        for ($i = 0; $i < $total_worksheets; ++$i) {
+            $sheetSetup = $this->spreadsheet->getSheet($i)->getPageSetup();
+            if ($sheetSetup->isColumnsToRepeatAtLeftSet() && $sheetSetup->isRowsToRepeatAtTopSet()) {
+                $repeat = $sheetSetup->getColumnsToRepeatAtLeft();
+                $colmin = Coordinate::columnIndexFromString($repeat[0]) - 1;
+                $colmax = Coordinate::columnIndexFromString($repeat[1]) - 1;
+                $repeat = $sheetSetup->getRowsToRepeatAtTop();
+                $rowmin = $repeat[0] - 1;
+                $rowmax = $repeat[1] - 1;
+                $formulaData = pack('Cv', 0x29, 0x17); // tMemFunc
+                $formulaData .= pack('Cvvvvv', 0x3B, $i, 0, 65535, $colmin, $colmax); // tArea3d
+                $formulaData .= pack('Cvvvvv', 0x3B, $i, $rowmin, $rowmax, 0, 255); // tArea3d
+                $formulaData .= pack('C', 0x10); // tList
+                $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x07), $formulaData, $i + 1, true));
+            } elseif ($sheetSetup->isColumnsToRepeatAtLeftSet() || $sheetSetup->isRowsToRepeatAtTopSet()) {
+                if ($sheetSetup->isColumnsToRepeatAtLeftSet()) {
+                    $repeat = $sheetSetup->getColumnsToRepeatAtLeft();
+                    $colmin = Coordinate::columnIndexFromString($repeat[0]) - 1;
+                    $colmax = Coordinate::columnIndexFromString($repeat[1]) - 1;
+                } else {
+                    $colmin = 0;
+                    $colmax = 255;
+                }
+                if ($sheetSetup->isRowsToRepeatAtTopSet()) {
+                    $repeat = $sheetSetup->getRowsToRepeatAtTop();
+                    $rowmin = $repeat[0] - 1;
+                    $rowmax = $repeat[1] - 1;
+                } else {
+                    $rowmin = 0;
+                    $rowmax = 65535;
+                }
+                $formulaData = pack('Cvvvvv', 0x3B, $i, $rowmin, $rowmax, $colmin, $colmax);
+                $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x07), $formulaData, $i + 1, true));
+            }
+        }
+        for ($i = 0; $i < $total_worksheets; ++$i) {
+            $sheetSetup = $this->spreadsheet->getSheet($i)->getPageSetup();
+            if ($sheetSetup->isPrintAreaSet()) {
+                $printArea = Coordinate::splitRange($sheetSetup->getPrintArea());
+                $countPrintArea = count($printArea);
+                $formulaData = '';
+                for ($j = 0; $j < $countPrintArea; ++$j) {
+                    $printAreaRect = $printArea[$j]; // e.g. A3:J6
+                    $printAreaRect[0] = Coordinate::indexesFromString($printAreaRect[0]);
+                    $printAreaRect[1] = Coordinate::indexesFromString($printAreaRect[1]);
+                    $print_rowmin = $printAreaRect[0][1] - 1;
+                    $print_rowmax = $printAreaRect[1][1] - 1;
+                    $print_colmin = $printAreaRect[0][0] - 1;
+                    $print_colmax = $printAreaRect[1][0] - 1;
+                    $formulaData .= pack('Cvvvvv', 0x3B, $i, $print_rowmin, $print_rowmax, $print_colmin, $print_colmax);
+                    if ($j > 0) {
+                        $formulaData .= pack('C', 0x10); // list operator token ','
+                    }
+                }
+                $chunk .= $this->writeData($this->writeDefinedNameBiff8(pack('C', 0x06), $formulaData, $i + 1, true));
+            }
+        }
+        for ($i = 0; $i < $total_worksheets; ++$i) {
+            $sheetAutoFilter = $this->spreadsheet->getSheet($i)->getAutoFilter();
+            $autoFilterRange = $sheetAutoFilter->getRange();
+            if (!empty($autoFilterRange)) {
+                $rangeBounds = Coordinate::rangeBoundaries($autoFilterRange);
+                $name = pack('C', 0x0D);
+                $chunk .= $this->writeData($this->writeShortNameBiff8($name, $i + 1, $rangeBounds, true));
+            }
+        }
+        return $chunk;
+    }
+    /**
+     * Write a DEFINEDNAME record for BIFF8 using explicit binary formula data.
+     *
+     * @param string $name The name in UTF-8
+     * @param string $formulaData The binary formula data
+     * @param int $sheetIndex 1-based sheet index the defined name applies to. 0 = global
+     * @param bool $isBuiltIn Built-in name?
+     *
+     * @return string Complete binary record data
+     */
+    private function writeDefinedNameBiff8(string $name, string $formulaData, int $sheetIndex = 0, bool $isBuiltIn = false): string
+    {
+        $record = 0x0018;
+        $options = $isBuiltIn ? 0x20 : 0x00;
+        $nlen = StringHelper::countCharacters($name);
+        $name = substr(StringHelper::UTF8toBIFF8UnicodeLong($name), 2);
+        $sz = strlen($formulaData);
+        $data = pack('vCCvvvCCCC', $options, 0, $nlen, $sz, 0, $sheetIndex, 0, 0, 0, 0)
+            . $name . $formulaData;
+        $length = strlen($data);
+        $header = pack('vv', $record, $length);
+        return $header . $data;
+    }
+    /**
+     * Write a short NAME record.
+     *
+     * @param int $sheetIndex 1-based sheet index the defined name applies to. 0 = global
+     * @param int[][] $rangeBounds range boundaries
+     *
+     * @return string Complete binary record data
+     * */
+    private function writeShortNameBiff8(string $name, int $sheetIndex, array $rangeBounds, bool $isHidden = false): string
+    {
+        $record = 0x0018;
+        $options = ($isHidden ? 0x21 : 0x00);
+        $extra = pack(
+            'Cvvvvv',
+            0x3B,
+            $sheetIndex - 1,
+            $rangeBounds[0][1] - 1,
+            $rangeBounds[1][1] - 1,
+            $rangeBounds[0][0] - 1,
+            $rangeBounds[1][0] - 1
+        );
+        $sz = strlen($extra);
+        $data = pack('vCCvvvCCCCC', $options, 0, 1, $sz, 0, $sheetIndex, 0, 0, 0, 0, 0)
+            . $name . $extra;
+        $length = strlen($data);
+        $header = pack('vv', $record, $length);
+        return $header . $data;
+    }
+    /**
+     * Stores the CODEPAGE biff record.
+     */
+    private function writeCodepage(): void
+    {
+        $record = 0x0042; // Record identifier
+        $length = 0x0002; // Number of bytes to follow
+        $cv = $this->codepage; // The code page
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $cv);
+        $this->append($header . $data);
+    }
+    /**
+     * Write Excel BIFF WINDOW1 record.
+     */
+    private function writeWindow1(): void
+    {
+        $record = 0x003D; // Record identifier
+        $length = 0x0012; // Number of bytes to follow
+        $xWn = 0x0000; // Horizontal position of window
+        $yWn = 0x0000; // Vertical position of window
+        $dxWn = 0x25BC; // Width of window
+        $dyWn = 0x1572; // Height of window
+        $grbit = 0x0038; // Option flags
+        $ctabsel = 1; // Number of workbook tabs selected
+        $wTabRatio = 0x0258; // Tab to scrollbar ratio
+        $itabFirst = 0; // 1st displayed worksheet
+        $itabCur = $this->spreadsheet->getActiveSheetIndex(); // Active worksheet
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvvvvvvv', $xWn, $yWn, $dxWn, $dyWn, $grbit, $itabCur, $itabFirst, $ctabsel, $wTabRatio);
+        $this->append($header . $data);
+    }
+    /**
+     * Writes Excel BIFF BOUNDSHEET record.
+     *
+     * @param int $offset Location of worksheet BOF
+     */
+    private function writeBoundSheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, int $offset): void
+    {
+        $sheetname = $sheet->getTitle();
+        $record = 0x0085; // Record identifier
+        $ss = match ($sheet->getSheetState()) {
+            \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_VISIBLE => 0x00,
+            \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_HIDDEN => 0x01,
+            \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet::SHEETSTATE_VERYHIDDEN => 0x02,
+            default => 0x00,
+        };
+        $st = 0x00;
+        $data = pack('VCC', $offset, $ss, $st);
+        $data .= StringHelper::UTF8toBIFF8UnicodeShort($sheetname);
+        $length = strlen($data);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $data);
+    }
+    /**
+     * Write Internal SUPBOOK record.
+     */
+    private function writeSupbookInternal(): string
+    {
+        $record = 0x01AE; // Record identifier
+        $length = 0x0004; // Bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vv', $this->spreadsheet->getSheetCount(), 0x0401);
+        return $this->writeData($header . $data);
+    }
+    /**
+     * Writes the Excel BIFF EXTERNSHEET record. These references are used by
+     * formulas.
+     */
+    private function writeExternalsheetBiff8(): string
+    {
+        $totalReferences = count($this->parser->references);
+        $record = 0x0017; // Record identifier
+        $length = 2 + 6 * $totalReferences; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $totalReferences);
+        for ($i = 0; $i < $totalReferences; ++$i) {
+            $data .= $this->parser->references[$i];
+        }
+        return $this->writeData($header . $data);
+    }
+    /**
+     * Write Excel BIFF STYLE records.
+     */
+    private function writeStyle(): void
+    {
+        $record = 0x0293; // Record identifier
+        $length = 0x0004; // Bytes to follow
+        $ixfe = 0x8000; // Index to cell style XF
+        $BuiltIn = 0x00; // Built-in style
+        $iLevel = 0xFF; // Outline style level
+        $header = pack('vv', $record, $length);
+        $data = pack('vCC', $ixfe, $BuiltIn, $iLevel);
+        $this->append($header . $data);
+    }
+    /**
+     * Writes Excel FORMAT record for non "built-in" numerical formats.
+     *
+     * @param string $format Custom format string
+     * @param int $ifmt Format index code
+     */
+    private function writeNumberFormat(string $format, int $ifmt): void
+    {
+        $record = 0x041E; // Record identifier
+        $numberFormatString = StringHelper::UTF8toBIFF8UnicodeLong($format);
+        $length = 2 + strlen($numberFormatString); // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $ifmt) . $numberFormatString;
+        $this->append($header . $data);
+    }
+    /**
+     * Write DATEMODE record to indicate the date system in use (1904 or 1900).
+     */
+    private function writeDateMode(): void
+    {
+        $record = 0x0022; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $f1904 = ($this->spreadsheet->getExcelCalendar() === Date::CALENDAR_MAC_1904)
+            ? 1  // Flag for 1904 date system
+            : 0; // Flag for 1900 date system
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $f1904);
+        $this->append($header . $data);
+    }
+    /**
+     * Stores the COUNTRY record for localization.
+     */
+    private function writeCountry(): string
+    {
+        $record = 0x008C; // Record identifier
+        $length = 4; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vv', $this->countryCode, $this->countryCode);
+        return $this->writeData($header . $data);
+    }
+    /**
+     * Write the RECALCID record.
+     */
+    private function writeRecalcId(): string
+    {
+        $record = 0x01C1; // Record identifier
+        $length = 8; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('VV', 0x000001C1, 0x00001E667);
+        return $this->writeData($header . $data);
+    }
+    /**
+     * Stores the PALETTE biff record.
+     */
+    private function writePalette(): void
+    {
+        $aref = $this->palette;
+        $record = 0x0092; // Record identifier
+        $length = 2 + 4 * count($aref); // Number of bytes to follow
+        $ccv = count($aref); // Number of RGB values to follow
+        $data = ''; // The RGB data
+        foreach ($aref as $color) {
+            foreach ($color as $byte) {
+                $data .= pack('C', $byte);
+            }
+        }
+        $header = pack('vvv', $record, $length, $ccv);
+        $this->append($header . $data);
+    }
+    /**
+     * Handling of the SST continue blocks is complicated by the need to include an
+     * additional continuation byte depending on whether the string is split between
+     * blocks or whether it starts at the beginning of the block. (There are also
+     * additional complications that will arise later when/if Rich Strings are
+     * supported).
+     *
+     * The Excel documentation says that the SST record should be followed by an
+     * EXTSST record. The EXTSST record is a hash table that is used to optimise
+     * access to SST. However, despite the documentation it doesn't seem to be
+     * required so we will ignore it.
+     *
+     * @return string Binary data
+     */
+    private function writeSharedStringsTable(): string
+    {
+        $continue_limit = 8224;
+        $recordDatas = [];
+        $recordData = pack('VV', $this->stringTotal, $this->stringUnique);
+        foreach (array_keys($this->stringTable) as $string) {
+            $headerinfo = unpack('vlength/Cencoding', $string);
+            $encoding = $headerinfo['encoding'] ?? 1;
+            $finished = false;
+            while ($finished === false) {
+                if (strlen($recordData) + strlen($string) <= $continue_limit) {
+                    $recordData .= $string;
+                    if (strlen($recordData) + strlen($string) == $continue_limit) {
+                        $recordDatas[] = $recordData;
+                        $recordData = '';
+                    }
+                    $finished = true;
+                } else {
+                    $space_remaining = $continue_limit - strlen($recordData);
+                    $min_space_needed = ($encoding == 1) ? 5 : 4;
+                    if ($space_remaining < $min_space_needed) {
+                        $recordDatas[] = $recordData;
+                        $recordData = '';
+                    } else {
+                        $effective_space_remaining = $space_remaining;
+                        if ($encoding == 1 && (strlen($string) - $space_remaining) % 2 == 1) {
+                            --$effective_space_remaining;
+                        }
+                        $recordData .= substr($string, 0, $effective_space_remaining);
+                        $string = substr($string, $effective_space_remaining); // for next cycle in while loop
+                        $recordDatas[] = $recordData;
+                        $recordData = pack('C', $encoding);
+                    }
+                }
+            }
+        }
+        if ($recordData !== '') {
+            $recordDatas[] = $recordData;
+        }
+        $chunk = '';
+        foreach ($recordDatas as $i => $recordData) {
+            $record = ($i == 0) ? 0x00FC : 0x003C;
+            $header = pack('vv', $record, strlen($recordData));
+            $data = $header . $recordData;
+            $chunk .= $this->writeData($data);
+        }
+        return $chunk;
+    }
+    /**
+     * Writes the MSODRAWINGGROUP record if needed. Possibly split using CONTINUE records.
+     */
+    private function writeMsoDrawingGroup(): string
+    {
+        if (isset($this->escher)) {
+            $writer = new Escher($this->escher);
+            $data = $writer->close();
+            $record = 0x00EB;
+            $length = strlen($data);
+            $header = pack('vv', $record, $length);
+            return $this->writeData($header . $data);
+        }
+        return '';
+    }
+    /**
+     * Get Escher object.
+     */
+    public function getEscher(): ?\PhpOffice\PhpSpreadsheet\Shared\Escher
+    {
+        return $this->escher;
+    }
+    /**
+     * Set Escher object.
+     */
+    public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher): void
+    {
+        $this->escher = $escher;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xls/Worksheet.php
@@ -0,0 +1,2378 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xls;
+use GdImage;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Cell\DataType;
+use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\RichText\Run;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Shared\Xls;
+use PhpOffice\PhpSpreadsheet\Style\Border;
+use PhpOffice\PhpSpreadsheet\Style\Borders;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\Protection;
+use PhpOffice\PhpSpreadsheet\Worksheet\PageSetup;
+use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
+use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
+class Worksheet extends BIFFwriter
+{
+    private static int $always0 = 0;
+    private static int $always1 = 1;
+    /**
+     * Formula parser.
+     */
+    private Parser $parser;
+    /**
+     * Array containing format information for columns.
+     */
+    private array $columnInfo;
+    /**
+     * The active pane for the worksheet.
+     */
+    private int $activePane;
+    /**
+     * Whether to use outline.
+     */
+    private bool $outlineOn;
+    /**
+     * Auto outline styles.
+     */
+    private bool $outlineStyle;
+    /**
+     * Whether to have outline summary below.
+     * Not currently used.
+     */
+    private bool $outlineBelow; //* @phpstan-ignore-line
+    /**
+     * Whether to have outline summary at the right.
+     * Not currently used.
+     */
+    private bool $outlineRight; //* @phpstan-ignore-line
+    /**
+     * Reference to the total number of strings in the workbook.
+     */
+    private int $stringTotal;
+    /**
+     * Reference to the number of unique strings in the workbook.
+     */
+    private int $stringUnique;
+    /**
+     * Reference to the array containing all the unique strings in the workbook.
+     */
+    private array $stringTable;
+    /**
+     * Color cache.
+     */
+    private array $colors;
+    /**
+     * Index of first used row (at least 0).
+     */
+    private int $firstRowIndex;
+    /**
+     * Index of last used row. (no used rows means -1).
+     */
+    private int $lastRowIndex;
+    /**
+     * Index of first used column (at least 0).
+     */
+    private int $firstColumnIndex;
+    /**
+     * Index of last used column (no used columns means -1).
+     */
+    private int $lastColumnIndex;
+    /**
+     * Sheet object.
+     */
+    public \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet;
+    /**
+     * Escher object corresponding to MSODRAWING.
+     */
+    private ?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher = null;
+    /**
+     * Array of font hashes associated to FONT records index.
+     */
+    public array $fontHashIndex;
+    private bool $preCalculateFormulas;
+    private int $printHeaders;
+    private ?Workbook $writerWorkbook;
+    /**
+     * Constructor.
+     *
+     * @param int $str_total Total number of strings
+     * @param int $str_unique Total number of unique strings
+     * @param array $str_table String Table
+     * @param array $colors Colour Table
+     * @param Parser $parser The formula parser created for the Workbook
+     * @param bool $preCalculateFormulas Flag indicating whether formulas should be calculated or just written
+     * @param \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet The worksheet to write
+     */
+    public function __construct(int &$str_total, int &$str_unique, array &$str_table, array &$colors, Parser $parser, bool $preCalculateFormulas, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet, ?Workbook $writerWorkbook = null)
+    {
+        parent::__construct();
+        $this->preCalculateFormulas = $preCalculateFormulas;
+        $this->stringTotal = &$str_total;
+        $this->stringUnique = &$str_unique;
+        $this->stringTable = &$str_table;
+        $this->colors = &$colors;
+        $this->parser = $parser;
+        $this->phpSheet = $phpSheet;
+        $this->columnInfo = [];
+        $this->activePane = 3;
+        $this->printHeaders = 0;
+        $this->outlineStyle = false;
+        $this->outlineBelow = true;
+        $this->outlineRight = true;
+        $this->outlineOn = true;
+        $this->fontHashIndex = [];
+        $minR = 1;
+        $minC = 'A';
+        $maxR = $this->phpSheet->getHighestRow();
+        $maxC = $this->phpSheet->getHighestColumn();
+        $this->firstRowIndex = $minR;
+        $this->lastRowIndex = ($maxR > 65535) ? 65535 : $maxR;
+        $this->firstColumnIndex = Coordinate::columnIndexFromString($minC);
+        $this->lastColumnIndex = Coordinate::columnIndexFromString($maxC);
+        if ($this->lastColumnIndex > 255) {
+            $this->lastColumnIndex = 255;
+        }
+        $this->writerWorkbook = $writerWorkbook;
+    }
+    /**
+     * Add data to the beginning of the workbook (note the reverse order)
+     * and to the end of the workbook.
+     *
+     * @see Workbook::storeWorkbook
+     */
+    public function close(): void
+    {
+        $phpSheet = $this->phpSheet;
+        $selectedCells = $this->phpSheet->getSelectedCells();
+        $activeSheetIndex = $this->phpSheet->getParentOrThrow()->getActiveSheetIndex();
+        $this->storeBof(0x0010);
+        $this->writePrintHeaders();
+        $this->writePrintGridlines();
+        $this->writeGridset();
+        $phpSheet->calculateColumnWidths();
+        if (($defaultWidth = $phpSheet->getDefaultColumnDimension()->getWidth()) < 0) {
+            $defaultWidth = \PhpOffice\PhpSpreadsheet\Shared\Font::getDefaultColumnWidthByFont($phpSheet->getParentOrThrow()->getDefaultStyle()->getFont());
+        }
+        $columnDimensions = $phpSheet->getColumnDimensions();
+        $maxCol = $this->lastColumnIndex - 1;
+        for ($i = 0; $i <= $maxCol; ++$i) {
+            $hidden = 0;
+            $level = 0;
+            $xfIndex = 15; // there are 15 cell style Xfs
+            $width = $defaultWidth;
+            $columnLetter = Coordinate::stringFromColumnIndex($i + 1);
+            if (isset($columnDimensions[$columnLetter])) {
+                $columnDimension = $columnDimensions[$columnLetter];
+                if ($columnDimension->getWidth() >= 0) {
+                    $width = $columnDimension->getWidth();
+                }
+                $hidden = $columnDimension->getVisible() ? 0 : 1;
+                $level = $columnDimension->getOutlineLevel();
+                $xfIndex = $columnDimension->getXfIndex() + 15; // there are 15 cell style Xfs
+            }
+            $this->columnInfo[] = [$i, $i, $width, $xfIndex, $hidden, $level];
+        }
+        $this->writeGuts();
+        $this->writeDefaultRowHeight();
+        $this->writeWsbool();
+        $this->writeBreaks();
+        $this->writeHeader();
+        $this->writeFooter();
+        $this->writeHcenter();
+        $this->writeVcenter();
+        $this->writeMarginLeft();
+        $this->writeMarginRight();
+        $this->writeMarginTop();
+        $this->writeMarginBottom();
+        $this->writeSetup();
+        $this->writeProtect();
+        $this->writeScenProtect();
+        $this->writeObjectProtect();
+        $this->writePassword();
+        $this->writeDefcol();
+        if (!empty($this->columnInfo)) {
+            $colcount = count($this->columnInfo);
+            for ($i = 0; $i < $colcount; ++$i) {
+                $this->writeColinfo($this->columnInfo[$i]);
+            }
+        }
+        $autoFilterRange = $phpSheet->getAutoFilter()->getRange();
+        if (!empty($autoFilterRange)) {
+            $this->writeAutoFilterInfo();
+        }
+        $this->writeDimensions();
+        foreach ($phpSheet->getRowDimensions() as $rowDimension) {
+            $xfIndex = $rowDimension->getXfIndex() + 15; // there are 15 cellXfs
+            $this->writeRow(
+                $rowDimension->getRowIndex() - 1,
+                (int) $rowDimension->getRowHeight(),
+                $xfIndex,
+                !$rowDimension->getVisible(),
+                $rowDimension->getOutlineLevel()
+            );
+        }
+        foreach ($phpSheet->getCellCollection()->getSortedCoordinates() as $coordinate) {
+            /** @var Cell $cell */
+            $cell = $phpSheet->getCellCollection()->get($coordinate);
+            $row = $cell->getRow() - 1;
+            $column = Coordinate::columnIndexFromString($cell->getColumn()) - 1;
+            if ($row > 65535 || $column > 255) {
+                throw new WriterException('Rows or columns overflow! Excel5 has limit to 65535 rows and 255 columns. Use XLSX instead.');
+            }
+            $xfIndex = $cell->getXfIndex() + 15; // there are 15 cell style Xfs
+            $cVal = $cell->getValue();
+            if ($cVal instanceof RichText) {
+                $arrcRun = [];
+                $str_pos = 0;
+                $elements = $cVal->getRichTextElements();
+                foreach ($elements as $element) {
+                    $str_fontidx = 0;
+                    if ($element instanceof Run) {
+                        $getFont = $element->getFont();
+                        if ($getFont !== null) {
+                            $str_fontidx = $this->fontHashIndex[$getFont->getHashCode()];
+                        }
+                    }
+                    $arrcRun[] = ['strlen' => $str_pos, 'fontidx' => $str_fontidx];
+                    $str_pos += StringHelper::countCharacters($element->getText(), 'UTF-8');
+                }
+                $this->writeRichTextString($row, $column, $cVal->getPlainText(), $xfIndex, $arrcRun);
+            } else {
+                switch ($cell->getDatatype()) {
+                    case DataType::TYPE_STRING:
+                    case DataType::TYPE_INLINE:
+                    case DataType::TYPE_NULL:
+                        if ($cVal === '' || $cVal === null) {
+                            $this->writeBlank($row, $column, $xfIndex);
+                        } else {
+                            $this->writeString($row, $column, $cell->getValueString(), $xfIndex);
+                        }
+                        break;
+                    case DataType::TYPE_NUMERIC:
+                        $this->writeNumber($row, $column, is_numeric($cVal) ? ($cVal + 0) : 0, $xfIndex);
+                        break;
+                    case DataType::TYPE_FORMULA:
+                        $calculatedValue = $this->preCalculateFormulas ? $cell->getCalculatedValue() : null;
+                        $calculatedValueString = $this->preCalculateFormulas ? $cell->getCalculatedValueString() : '';
+                        if (self::WRITE_FORMULA_EXCEPTION == $this->writeFormula($row, $column, $cell->getValueString(), $xfIndex, $calculatedValue)) {
+                            if ($calculatedValue === null) {
+                                $calculatedValue = $cell->getCalculatedValue();
+                            }
+                            $calctype = gettype($calculatedValue);
+                            match ($calctype) {
+                                'integer', 'double' => $this->writeNumber($row, $column, is_numeric($calculatedValue) ? ((float) $calculatedValue) : 0.0, $xfIndex),
+                                'string' => $this->writeString($row, $column, $calculatedValueString, $xfIndex),
+                                'boolean' => $this->writeBoolErr($row, $column, (int) $calculatedValueString, 0, $xfIndex),
+                                default => $this->writeString($row, $column, $cell->getValueString(), $xfIndex),
+                            };
+                        }
+                        break;
+                    case DataType::TYPE_BOOL:
+                        $this->writeBoolErr($row, $column, (int) $cell->getValueString(), 0, $xfIndex);
+                        break;
+                    case DataType::TYPE_ERROR:
+                        $this->writeBoolErr($row, $column, ErrorCode::error($cell->getValueString()), 1, $xfIndex);
+                        break;
+                }
+            }
+        }
+        $this->writeMsoDrawing();
+        $this->phpSheet->getParentOrThrow()->setActiveSheetIndex($activeSheetIndex);
+        $this->writeWindow2();
+        $this->writePageLayoutView();
+        $this->writeZoom();
+        if ($phpSheet->getFreezePane()) {
+            $this->writePanes();
+        }
+        $this->phpSheet->setSelectedCells($selectedCells);
+        $this->writeSelection();
+        $this->writeMergedCells();
+        $phpParent = $phpSheet->getParent();
+        $hyperlinkbase = ($phpParent === null) ? '' : $phpParent->getProperties()->getHyperlinkBase();
+        foreach ($phpSheet->getHyperLinkCollection() as $coordinate => $hyperlink) {
+            [$column, $row] = Coordinate::indexesFromString($coordinate);
+            $url = $hyperlink->getUrl();
+            if (str_contains($url, 'sheet://')) {
+                $url = str_replace('sheet://', 'internal:', $url);
+            } elseif (preg_match('/^(http:|https:|ftp:|mailto:)/', $url)) {
+            } elseif (!empty($hyperlinkbase) && preg_match('~^([A-Za-z]:)?[/\\\\]~', $url) !== 1) {
+                $url = "$hyperlinkbase$url";
+                if (preg_match('/^(http:|https:|ftp:|mailto:)/', $url) !== 1) {
+                    $url = 'external:' . $url;
+                }
+            } else {
+                $url = 'external:' . $url;
+            }
+            $this->writeUrl($row - 1, $column - 1, $url);
+        }
+        $this->writeDataValidity();
+        $this->writeSheetLayout();
+        $this->writeSheetProtection();
+        $this->writeRangeProtection();
+        $this->writeConditionalFormatting();
+        $this->storeEof();
+    }
+    private function writeConditionalFormatting(): void
+    {
+        $conditionalFormulaHelper = new ConditionalHelper($this->parser);
+        $arrConditionalStyles = [];
+        foreach ($this->phpSheet->getConditionalStylesCollection() as $key => $value) {
+            $keyExplode = explode(',', Coordinate::resolveUnionAndIntersection($key));
+            foreach ($keyExplode as $exploded) {
+                $arrConditionalStyles[$exploded] = $value;
+            }
+        }
+        if (!empty($arrConditionalStyles)) {
+            foreach ($arrConditionalStyles as $cellCoordinate => $conditionalStyles) {
+                $cfHeaderWritten = false;
+                foreach ($conditionalStyles as $conditional) {
+                    /** @var Conditional $conditional */
+                    if (
+                        $conditional->getConditionType() === Conditional::CONDITION_EXPRESSION
+                        || $conditional->getConditionType() === Conditional::CONDITION_CELLIS
+                    ) {
+                        if ($cfHeaderWritten === false) {
+                            $cfHeaderWritten = $this->writeCFHeader($cellCoordinate, $conditionalStyles);
+                        }
+                        if ($cfHeaderWritten === true) {
+                            $this->writeCFRule($conditionalFormulaHelper, $conditional, $cellCoordinate);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    /**
+     * Write a cell range address in BIFF8
+     * always fixed range
+     * See section 2.5.14 in OpenOffice.org's Documentation of the Microsoft Excel File Format.
+     *
+     * @param string $range E.g. 'A1' or 'A1:B6'
+     *
+     * @return string Binary data
+     */
+    private function writeBIFF8CellRangeAddressFixed(string $range): string
+    {
+        $explodes = explode(':', $range);
+        $firstCell = $explodes[0];
+        if (count($explodes) == 1) {
+            $lastCell = $firstCell;
+        } else {
+            $lastCell = $explodes[1];
+        }
+        $firstCellCoordinates = Coordinate::indexesFromString($firstCell); // e.g. [0, 1]
+        $lastCellCoordinates = Coordinate::indexesFromString($lastCell); // e.g. [1, 6]
+        return pack('vvvv', $firstCellCoordinates[1] - 1, $lastCellCoordinates[1] - 1, $firstCellCoordinates[0] - 1, $lastCellCoordinates[0] - 1);
+    }
+    /**
+     * Retrieves data from memory in one chunk, or from disk
+     * sized chunks.
+     *
+     * @return string The data
+     */
+    public function getData(): string
+    {
+        if (isset($this->_data)) {
+            $tmp = $this->_data;
+            $this->_data = null;
+            return $tmp;
+        }
+        return '';
+    }
+    /**
+     * Set the option to print the row and column headers on the printed page.
+     *
+     * @param int $print Whether to print the headers or not. Defaults to 1 (print).
+     */
+    public function printRowColHeaders(int $print = 1): void
+    {
+        $this->printHeaders = $print;
+    }
+    /**
+     * This method sets the properties for outlining and grouping. The defaults
+     * correspond to Excel's defaults.
+     */
+    public function setOutline(bool $visible = true, bool $symbols_below = true, bool $symbols_right = true, bool $auto_style = false): void
+    {
+        $this->outlineOn = $visible;
+        $this->outlineBelow = $symbols_below;
+        $this->outlineRight = $symbols_right;
+        $this->outlineStyle = $auto_style;
+    }
+    /**
+     * Write a double to the specified row and column (zero indexed).
+     * An integer can be written as a double. Excel will display an
+     * integer. $format is optional.
+     *
+     * Returns  0 : normal termination
+     *         -2 : row or column out of range
+     *
+     * @param int $row Zero indexed row
+     * @param int $col Zero indexed column
+     * @param float $num The number to write
+     * @param int $xfIndex The optional XF format
+     */
+    private function writeNumber(int $row, int $col, float $num, int $xfIndex): int
+    {
+        $record = 0x0203; // Record identifier
+        $length = 0x000E; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vvv', $row, $col, $xfIndex);
+        $xl_double = pack('d', $num);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $xl_double = strrev($xl_double);
+        }
+        $this->append($header . $data . $xl_double);
+        return 0;
+    }
+    /**
+     * Write a LABELSST record or a LABEL record. Which one depends on BIFF version.
+     *
+     * @param int $row Row index (0-based)
+     * @param int $col Column index (0-based)
+     * @param string $str The string
+     * @param int $xfIndex Index to XF record
+     */
+    private function writeString(int $row, int $col, string $str, int $xfIndex): void
+    {
+        $this->writeLabelSst($row, $col, $str, $xfIndex);
+    }
+    /**
+     * Write a LABELSST record or a LABEL record. Which one depends on BIFF version
+     * It differs from writeString by the writing of rich text strings.
+     *
+     * @param int $row Row index (0-based)
+     * @param int $col Column index (0-based)
+     * @param string $str The string
+     * @param int $xfIndex The XF format index for the cell
+     * @param array $arrcRun Index to Font record and characters beginning
+     */
+    private function writeRichTextString(int $row, int $col, string $str, int $xfIndex, array $arrcRun): void
+    {
+        $record = 0x00FD; // Record identifier
+        $length = 0x000A; // Bytes to follow
+        $str = StringHelper::UTF8toBIFF8UnicodeShort($str, $arrcRun);
+        if (!isset($this->stringTable[$str])) {
+            $this->stringTable[$str] = $this->stringUnique++;
+        }
+        ++$this->stringTotal;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvV', $row, $col, $xfIndex, $this->stringTable[$str]);
+        $this->append($header . $data);
+    }
+    /**
+     * Write a string to the specified row and column (zero indexed).
+     * This is the BIFF8 version (no 255 chars limit).
+     * $format is optional.
+     *
+     * @param int $row Zero indexed row
+     * @param int $col Zero indexed column
+     * @param string $str The string to write
+     * @param int $xfIndex The XF format index for the cell
+     */
+    private function writeLabelSst(int $row, int $col, string $str, int $xfIndex): void
+    {
+        $record = 0x00FD; // Record identifier
+        $length = 0x000A; // Bytes to follow
+        $str = StringHelper::UTF8toBIFF8UnicodeLong($str);
+        if (!isset($this->stringTable[$str])) {
+            $this->stringTable[$str] = $this->stringUnique++;
+        }
+        ++$this->stringTotal;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvV', $row, $col, $xfIndex, $this->stringTable[$str]);
+        $this->append($header . $data);
+    }
+    /**
+     * Write a blank cell to the specified row and column (zero indexed).
+     * A blank cell is used to specify formatting without adding a string
+     * or a number.
+     *
+     * A blank cell without a format serves no purpose. Therefore, we don't write
+     * a BLANK record unless a format is specified.
+     *
+     * Returns  0 : normal termination (including no format)
+     *         -1 : insufficient number of arguments
+     *         -2 : row or column out of range
+     *
+     * @param int $row Zero indexed row
+     * @param int $col Zero indexed column
+     * @param int $xfIndex The XF format index
+     */
+    public function writeBlank(int $row, int $col, int $xfIndex): int
+    {
+        $record = 0x0201; // Record identifier
+        $length = 0x0006; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vvv', $row, $col, $xfIndex);
+        $this->append($header . $data);
+        return 0;
+    }
+    /**
+     * Write a boolean or an error type to the specified row and column (zero indexed).
+     *
+     * @param int $row Row index (0-based)
+     * @param int $col Column index (0-based)
+     * @param int $isError Error or Boolean?
+     */
+    private function writeBoolErr(int $row, int $col, int $value, int $isError, int $xfIndex): int
+    {
+        $record = 0x0205;
+        $length = 8;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvCC', $row, $col, $xfIndex, $value, $isError);
+        $this->append($header . $data);
+        return 0;
+    }
+    const WRITE_FORMULA_NORMAL = 0;
+    const WRITE_FORMULA_ERRORS = -1;
+    const WRITE_FORMULA_RANGE = -2;
+    const WRITE_FORMULA_EXCEPTION = -3;
+    private static bool $allowThrow = false;
+    public static function setAllowThrow(bool $allowThrow): void
+    {
+        self::$allowThrow = $allowThrow;
+    }
+    public static function getAllowThrow(): bool
+    {
+        return self::$allowThrow;
+    }
+    /**
+     * Write a formula to the specified row and column (zero indexed).
+     * The textual representation of the formula is passed to the parser in
+     * Parser.php which returns a packed binary string.
+     *
+     * Returns  0 : WRITE_FORMULA_NORMAL  normal termination
+     *         -1 : WRITE_FORMULA_ERRORS formula errors (bad formula)
+     *         -2 : WRITE_FORMULA_RANGE  row or column out of range
+     *         -3 : WRITE_FORMULA_EXCEPTION parse raised exception, probably due to definedname
+     *
+     * @param int $row Zero indexed row
+     * @param int $col Zero indexed column
+     * @param string $formula The formula text string
+     * @param int $xfIndex The XF format index
+     * @param mixed $calculatedValue Calculated value
+     */
+    private function writeFormula(int $row, int $col, string $formula, int $xfIndex, mixed $calculatedValue): int
+    {
+        $record = 0x0006; // Record identifier
+        $stringValue = null;
+        if (isset($calculatedValue)) {
+            if (is_bool($calculatedValue)) {
+                $num = pack('CCCvCv', 0x01, 0x00, (int) $calculatedValue, 0x00, 0x00, 0xFFFF);
+            } elseif (is_int($calculatedValue) || is_float($calculatedValue)) {
+                $num = pack('d', $calculatedValue);
+            } elseif (is_string($calculatedValue)) {
+                $errorCodes = DataType::getErrorCodes();
+                if (isset($errorCodes[$calculatedValue])) {
+                    $num = pack('CCCvCv', 0x02, 0x00, ErrorCode::error($calculatedValue), 0x00, 0x00, 0xFFFF);
+                } elseif ($calculatedValue === '') {
+                    $num = pack('CCCvCv', 0x03, 0x00, 0x00, 0x00, 0x00, 0xFFFF);
+                } else {
+                    $stringValue = $calculatedValue;
+                    $num = pack('CCCvCv', 0x00, 0x00, 0x00, 0x00, 0x00, 0xFFFF);
+                }
+            } else {
+                $num = pack('d', 0x00);
+            }
+        } else {
+            $num = pack('d', 0x00);
+        }
+        $grbit = 0x03; // Option flags
+        $unknown = 0x0000; // Must be zero
+        if ($formula[0] == '=') {
+            $formula = substr($formula, 1);
+        } else {
+            $this->writeString($row, $col, 'Unrecognised character for formula', 0);
+            return self::WRITE_FORMULA_ERRORS;
+        }
+        try {
+            $this->parser->parse($formula);
+            $formula = $this->parser->toReversePolish();
+            $formlen = strlen($formula); // Length of the binary string
+            $length = 0x16 + $formlen; // Length of the record data
+            $header = pack('vv', $record, $length);
+            $data = pack('vvv', $row, $col, $xfIndex)
+                . $num
+                . pack('vVv', $grbit, $unknown, $formlen);
+            $this->append($header . $data . $formula);
+            if ($stringValue !== null) {
+                $this->writeStringRecord($stringValue);
+            }
+            return self::WRITE_FORMULA_NORMAL;
+        } catch (PhpSpreadsheetException $e) {
+            if (self::$allowThrow) {
+                throw $e;
+            }
+            return self::WRITE_FORMULA_EXCEPTION;
+        }
+    }
+    /**
+     * Write a STRING record. This.
+     */
+    private function writeStringRecord(string $stringValue): void
+    {
+        $record = 0x0207; // Record identifier
+        $data = StringHelper::UTF8toBIFF8UnicodeLong($stringValue);
+        $length = strlen($data);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $data);
+    }
+    /**
+     * Write a hyperlink.
+     * This is comprised of two elements: the visible label and
+     * the invisible link. The visible label is the same as the link unless an
+     * alternative string is specified. The label is written using the
+     * writeString() method. Therefore the 255 characters string limit applies.
+     * $string and $format are optional.
+     *
+     * The hyperlink can be to a http, ftp, mail, internal sheet (not yet), or external
+     * directory url.
+     *
+     * @param int $row Row
+     * @param int $col Column
+     * @param string $url URL string
+     */
+    private function writeUrl(int $row, int $col, string $url): void
+    {
+        $this->writeUrlRange($row, $col, $row, $col, $url);
+    }
+    /**
+     * This is the more general form of writeUrl(). It allows a hyperlink to be
+     * written to a range of cells. This function also decides the type of hyperlink
+     * to be written. These are either, Web (http, ftp, mailto), Internal
+     * (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
+     *
+     * @param int $row1 Start row
+     * @param int $col1 Start column
+     * @param int $row2 End row
+     * @param int $col2 End column
+     * @param string $url URL string
+     *
+     * @see writeUrl()
+     */
+    private function writeUrlRange(int $row1, int $col1, int $row2, int $col2, string $url): void
+    {
+        if (preg_match('[^internal:]', $url)) {
+            $this->writeUrlInternal($row1, $col1, $row2, $col2, $url);
+        }
+        if (preg_match('[^external:]', $url)) {
+            $this->writeUrlExternal($row1, $col1, $row2, $col2, $url);
+        }
+        $this->writeUrlWeb($row1, $col1, $row2, $col2, $url);
+    }
+    /**
+     * Used to write http, ftp and mailto hyperlinks.
+     * The link type ($options) is 0x03 is the same as absolute dir ref without
+     * sheet. However it is differentiated by the $unknown2 data stream.
+     *
+     * @param int $row1 Start row
+     * @param int $col1 Start column
+     * @param int $row2 End row
+     * @param int $col2 End column
+     * @param string $url URL string
+     *
+     * @see writeUrl()
+     */
+    public function writeUrlWeb(int $row1, int $col1, int $row2, int $col2, string $url): void
+    {
+        $record = 0x01B8; // Record identifier
+        $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
+        $unknown2 = pack('H*', 'E0C9EA79F9BACE118C8200AA004BA90B');
+        $options = pack('V', 0x03);
+        /** @phpstan-ignore-next-line */
+        $url = implode("\0", preg_split("''", $url, -1, PREG_SPLIT_NO_EMPTY));
+        $url = $url . "\0\0\0";
+        $url_len = pack('V', strlen($url));
+        $length = 0x34 + strlen($url);
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvv', $row1, $row2, $col1, $col2);
+        $this->append($header . $data . $unknown1 . $options . $unknown2 . $url_len . $url);
+    }
+    /**
+     * Used to write internal reference hyperlinks such as "Sheet1!A1".
+     *
+     * @param int $row1 Start row
+     * @param int $col1 Start column
+     * @param int $row2 End row
+     * @param int $col2 End column
+     * @param string $url URL string
+     *
+     * @see writeUrl()
+     */
+    private function writeUrlInternal(int $row1, int $col1, int $row2, int $col2, string $url): void
+    {
+        $record = 0x01B8; // Record identifier
+        $url = (string) preg_replace('/^internal:/', '', $url);
+        $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
+        $options = pack('V', 0x08);
+        $url .= "\0";
+        $url_len = StringHelper::countCharacters($url);
+        $url_len = pack('V', $url_len);
+        $url = StringHelper::convertEncoding($url, 'UTF-16LE', 'UTF-8');
+        $length = 0x24 + strlen($url);
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvv', $row1, $row2, $col1, $col2);
+        $this->append($header . $data . $unknown1 . $options . $url_len . $url);
+    }
+    /**
+     * Write links to external directory names such as 'c:\foo.xls',
+     * c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
+     *
+     * Note: Excel writes some relative links with the $dir_long string. We ignore
+     * these cases for the sake of simpler code.
+     *
+     * @param int $row1 Start row
+     * @param int $col1 Start column
+     * @param int $row2 End row
+     * @param int $col2 End column
+     * @param string $url URL string
+     *
+     * @see writeUrl()
+     */
+    private function writeUrlExternal(int $row1, int $col1, int $row2, int $col2, string $url): void
+    {
+        if (preg_match('[^external:\\\\]', $url)) {
+            return;
+        }
+        $record = 0x01B8; // Record identifier
+        $url = (string) preg_replace(['/^external:/', '/\//'], ['', '\\'], $url);
+        $absolute = 0x00; // relative path
+        if (preg_match('/^[A-Z]:/', $url)) {
+            $absolute = 0x02; // absolute path on Windows, e.g. C:\...
+        }
+        $link_type = 0x01 | $absolute;
+        $dir_long = $url;
+        if (preg_match('/\\#/', $url)) {
+            $link_type |= 0x08;
+        }
+        $link_type = pack('V', $link_type);
+        $up_count = preg_match_all('/\\.\\.\\\\/', $dir_long, $useless);
+        $up_count = pack('v', $up_count);
+        $dir_short = (string) preg_replace('/\\.\\.\\\\/', '', $dir_long) . "\0";
+        $dir_short_len = pack('V', strlen($dir_short));
+        $stream_len = pack('V', 0); //strlen($dir_long) + 0x06);
+        $unknown1 = pack('H*', 'D0C9EA79F9BACE118C8200AA004BA90B02000000');
+        $unknown2 = pack('H*', '0303000000000000C000000000000046');
+        $unknown3 = pack('H*', 'FFFFADDE000000000000000000000000000000000000000');
+        $data = pack('vvvv', $row1, $row2, $col1, $col2)
+            . $unknown1
+            . $link_type
+            . $unknown2
+            . $up_count
+            . $dir_short_len
+            . $dir_short
+            . $unknown3
+            . $stream_len; /*.
+                          $dir_long_len .
+                          $unknown4     .
+                          $dir_long     .
+                          $sheet_len    .
+                          $sheet        ;*/
+        $length = strlen($data);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $data);
+    }
+    /**
+     * This method is used to set the height and format for a row.
+     *
+     * @param int $row The row to set
+     * @param int $height Height we are giving to the row.
+     *                        Use null to set XF without setting height
+     * @param int $xfIndex The optional cell style Xf index to apply to the columns
+     * @param bool $hidden The optional hidden attribute
+     * @param int $level The optional outline level for row, in range [0,7]
+     */
+    private function writeRow(int $row, int $height, int $xfIndex, bool $hidden = false, int $level = 0): void
+    {
+        $record = 0x0208; // Record identifier
+        $length = 0x0010; // Number of bytes to follow
+        $colMic = 0x0000; // First defined column
+        $colMac = 0x0000; // Last defined column
+        $irwMac = 0x0000; // Used by Excel to optimise loading
+        $reserved = 0x0000; // Reserved
+        $grbit = 0x0000; // Option flags
+        $ixfe = $xfIndex;
+        if ($height < 0) {
+            $height = null;
+        }
+        if ($height !== null) {
+            $miyRw = $height * 20; // row height
+        } else {
+            $miyRw = 0xFF; // default row height is 256
+        }
+        $grbit |= $level;
+        if ($hidden === true) {
+            $grbit |= 0x0030;
+        }
+        if ($height !== null) {
+            $grbit |= 0x0040; // fUnsynced
+        }
+        if ($xfIndex !== 0xF) {
+            $grbit |= 0x0080;
+        }
+        $grbit |= 0x0100;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvvvvvv', $row, $colMic, $colMac, $miyRw, $irwMac, $reserved, $grbit, $ixfe);
+        $this->append($header . $data);
+    }
+    /**
+     * Writes Excel DIMENSIONS to define the area in which there is data.
+     */
+    private function writeDimensions(): void
+    {
+        $record = 0x0200; // Record identifier
+        $length = 0x000E;
+        $data = pack('VVvvv', $this->firstRowIndex, $this->lastRowIndex + 1, $this->firstColumnIndex, $this->lastColumnIndex + 1, 0x0000); // reserved
+        $header = pack('vv', $record, $length);
+        $this->append($header . $data);
+    }
+    /**
+     * Write BIFF record Window2.
+     */
+    private function writeWindow2(): void
+    {
+        $record = 0x023E; // Record identifier
+        $length = 0x0012;
+        $rwTop = 0x0000; // Top row visible in window
+        $colLeft = 0x0000; // Leftmost column visible in window
+        $fDspFmla = 0; // 0 - bit
+        $fDspGrid = $this->phpSheet->getShowGridlines() ? 1 : 0; // 1
+        $fDspRwCol = $this->phpSheet->getShowRowColHeaders() ? 1 : 0; // 2
+        $fFrozen = $this->phpSheet->getFreezePane() ? 1 : 0; // 3
+        $fDspZeros = 1; // 4
+        $fDefaultHdr = 1; // 5
+        $fArabic = $this->phpSheet->getRightToLeft() ? 1 : 0; // 6
+        $fDspGuts = $this->outlineOn; // 7
+        $fFrozenNoSplit = 0; // 0 - bit
+        $fSelected = ($this->phpSheet === $this->phpSheet->getParentOrThrow()->getActiveSheet()) ? 1 : 0;
+        $fPageBreakPreview = $this->phpSheet->getSheetView()->getView() === SheetView::SHEETVIEW_PAGE_BREAK_PREVIEW;
+        $grbit = $fDspFmla;
+        $grbit |= $fDspGrid << 1;
+        $grbit |= $fDspRwCol << 2;
+        $grbit |= $fFrozen << 3;
+        $grbit |= $fDspZeros << 4;
+        $grbit |= $fDefaultHdr << 5;
+        $grbit |= $fArabic << 6;
+        $grbit |= $fDspGuts << 7;
+        $grbit |= $fFrozenNoSplit << 8;
+        $grbit |= $fSelected << 9; // Selected sheets.
+        $grbit |= $fSelected << 10; // Active sheet.
+        $grbit |= $fPageBreakPreview << 11;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvv', $grbit, $rwTop, $colLeft);
+        $rgbHdr = 0x0040; // Row/column heading and gridline color index
+        $zoom_factor_page_break = ($fPageBreakPreview ? $this->phpSheet->getSheetView()->getZoomScale() : 0x0000);
+        $zoom_factor_normal = $this->phpSheet->getSheetView()->getZoomScaleNormal();
+        $data .= pack('vvvvV', $rgbHdr, 0x0000, $zoom_factor_page_break, $zoom_factor_normal, 0x00000000);
+        $this->append($header . $data);
+    }
+    /**
+     * Write BIFF record DEFAULTROWHEIGHT.
+     */
+    private function writeDefaultRowHeight(): void
+    {
+        $defaultRowHeight = $this->phpSheet->getDefaultRowDimension()->getRowHeight();
+        if ($defaultRowHeight < 0) {
+            return;
+        }
+        $defaultRowHeight = (int) 20 * $defaultRowHeight;
+        $record = 0x0225; // Record identifier
+        $length = 0x0004; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vv', 1, $defaultRowHeight);
+        $this->append($header . $data);
+    }
+    /**
+     * Write BIFF record DEFCOLWIDTH if COLINFO records are in use.
+     */
+    private function writeDefcol(): void
+    {
+        $defaultColWidth = 8;
+        $record = 0x0055; // Record identifier
+        $length = 0x0002; // Number of bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $defaultColWidth);
+        $this->append($header . $data);
+    }
+    /**
+     * Write BIFF record COLINFO to define column widths.
+     *
+     * Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
+     * length record.
+     *
+     * @param array $col_array This is the only parameter received and is composed of the following:
+     *                0 => First formatted column,
+     *                1 => Last formatted column,
+     *                2 => Col width (8.43 is Excel default),
+     *                3 => The optional XF format of the column,
+     *                4 => Option flags.
+     *                5 => Optional outline level
+     */
+    private function writeColinfo(array $col_array): void
+    {
+        $colFirst = $col_array[0] ?? null;
+        $colLast = $col_array[1] ?? null;
+        $coldx = $col_array[2] ?? 8.43;
+        $xfIndex = $col_array[3] ?? 15;
+        $grbit = $col_array[4] ?? 0;
+        $level = $col_array[5] ?? 0;
+        $record = 0x007D; // Record identifier
+        $length = 0x000C; // Number of bytes to follow
+        $coldx *= 256; // Convert to units of 1/256 of a char
+        $ixfe = $xfIndex;
+        $reserved = 0x0000; // Reserved
+        $level = max(0, min($level, 7));
+        $grbit |= $level << 8;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvvvv', $colFirst, $colLast, $coldx, $ixfe, $grbit, $reserved);
+        $this->append($header . $data);
+    }
+    /**
+     * Write BIFF record SELECTION.
+     */
+    private function writeSelection(): void
+    {
+        $selectedCells = Coordinate::splitRange($this->phpSheet->getSelectedCells());
+        $selectedCells = $selectedCells[0];
+        if (count($selectedCells) == 2) {
+            [$first, $last] = $selectedCells;
+        } else {
+            $first = $selectedCells[0];
+            $last = $selectedCells[0];
+        }
+        [$colFirst, $rwFirst] = Coordinate::coordinateFromString($first);
+        $colFirst = Coordinate::columnIndexFromString($colFirst) - 1; // base 0 column index
+        --$rwFirst; // base 0 row index
+        [$colLast, $rwLast] = Coordinate::coordinateFromString($last);
+        $colLast = Coordinate::columnIndexFromString($colLast) - 1; // base 0 column index
+        --$rwLast; // base 0 row index
+        $colFirst = min($colFirst, 255);
+        $colLast = min($colLast, 255);
+        $rwFirst = min($rwFirst, 65535);
+        $rwLast = min($rwLast, 65535);
+        $record = 0x001D; // Record identifier
+        $length = 0x000F; // Number of bytes to follow
+        $pnn = $this->activePane; // Pane position
+        $rwAct = $rwFirst; // Active row
+        $colAct = $colFirst; // Active column
+        $irefAct = 0; // Active cell ref
+        $cref = 1; // Number of refs
+        if ($rwFirst > $rwLast) {
+            [$rwFirst, $rwLast] = [$rwLast, $rwFirst];
+        }
+        if ($colFirst > $colLast) {
+            [$colFirst, $colLast] = [$colLast, $colFirst];
+        }
+        $header = pack('vv', $record, $length);
+        $data = pack('CvvvvvvCC', $pnn, $rwAct, $colAct, $irefAct, $cref, $rwFirst, $rwLast, $colFirst, $colLast);
+        $this->append($header . $data);
+    }
+    /**
+     * Store the MERGEDCELLS records for all ranges of merged cells.
+     */
+    private function writeMergedCells(): void
+    {
+        $mergeCells = $this->phpSheet->getMergeCells();
+        $countMergeCells = count($mergeCells);
+        if ($countMergeCells == 0) {
+            return;
+        }
+        $maxCountMergeCellsPerRecord = 1027;
+        $record = 0x00E5;
+        $i = 0;
+        $j = 0;
+        $recordData = '';
+        foreach ($mergeCells as $mergeCell) {
+            ++$i;
+            ++$j;
+            $range = Coordinate::splitRange($mergeCell);
+            [$first, $last] = $range[0];
+            [$firstColumn, $firstRow] = Coordinate::indexesFromString($first);
+            [$lastColumn, $lastRow] = Coordinate::indexesFromString($last);
+            $recordData .= pack('vvvv', $firstRow - 1, $lastRow - 1, $firstColumn - 1, $lastColumn - 1);
+            if ($j == $maxCountMergeCellsPerRecord || $i == $countMergeCells) {
+                $recordData = pack('v', $j) . $recordData;
+                $length = strlen($recordData);
+                $header = pack('vv', $record, $length);
+                $this->append($header . $recordData);
+                $recordData = '';
+                $j = 0;
+            }
+        }
+    }
+    /**
+     * Write SHEETLAYOUT record.
+     */
+    private function writeSheetLayout(): void
+    {
+        if (!$this->phpSheet->isTabColorSet()) {
+            return;
+        }
+        $recordData = pack(
+            'vvVVVvv',
+            0x0862,
+            0x0000, // unused
+            0x00000000, // unused
+            0x00000000, // unused
+            0x00000014, // size of record data
+            $this->colors[$this->phpSheet->getTabColor()->getRGB()], // color index
+            0x0000        // unused
+        );
+        $length = strlen($recordData);
+        $record = 0x0862; // Record identifier
+        $header = pack('vv', $record, $length);
+        $this->append($header . $recordData);
+    }
+    private static function protectionBitsDefaultFalse(?bool $value, int $shift): int
+    {
+        if ($value === false) {
+            return 1 << $shift;
+        }
+        return 0;
+    }
+    private static function protectionBitsDefaultTrue(?bool $value, int $shift): int
+    {
+        if ($value !== false) {
+            return 1 << $shift;
+        }
+        return 0;
+    }
+    /**
+     * Write SHEETPROTECTION.
+     */
+    private function writeSheetProtection(): void
+    {
+        $record = 0x0867;
+        $protection = $this->phpSheet->getProtection();
+        $options = self::protectionBitsDefaultTrue($protection->getObjects(), 0)
+            | self::protectionBitsDefaultTrue($protection->getScenarios(), 1)
+            | self::protectionBitsDefaultFalse($protection->getFormatCells(), 2)
+            | self::protectionBitsDefaultFalse($protection->getFormatColumns(), 3)
+            | self::protectionBitsDefaultFalse($protection->getFormatRows(), 4)
+            | self::protectionBitsDefaultFalse($protection->getInsertColumns(), 5)
+            | self::protectionBitsDefaultFalse($protection->getInsertRows(), 6)
+            | self::protectionBitsDefaultFalse($protection->getInsertHyperlinks(), 7)
+            | self::protectionBitsDefaultFalse($protection->getDeleteColumns(), 8)
+            | self::protectionBitsDefaultFalse($protection->getDeleteRows(), 9)
+            | self::protectionBitsDefaultTrue($protection->getSelectLockedCells(), 10)
+            | self::protectionBitsDefaultFalse($protection->getSort(), 11)
+            | self::protectionBitsDefaultFalse($protection->getAutoFilter(), 12)
+            | self::protectionBitsDefaultFalse($protection->getPivotTables(), 13)
+            | self::protectionBitsDefaultTrue($protection->getSelectUnlockedCells(), 14);
+        $recordData = pack(
+            'vVVCVVvv',
+            0x0867, // repeated record identifier
+            0x0000, // not used
+            0x0000, // not used
+            0x00, // not used
+            0x01000200, // unknown data
+            0xFFFFFFFF, // unknown data
+            $options, // options
+            0x0000 // not used
+        );
+        $length = strlen($recordData);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $recordData);
+    }
+    /**
+     * Write BIFF record RANGEPROTECTION.
+     *
+     * Openoffice.org's Documentation of the Microsoft Excel File Format uses term RANGEPROTECTION for these records
+     * Microsoft Office Excel 97-2007 Binary File Format Specification uses term FEAT for these records
+     */
+    private function writeRangeProtection(): void
+    {
+        foreach ($this->phpSheet->getProtectedCellRanges() as $range => $protectedCells) {
+            $password = $protectedCells->getPassword();
+            $cellRanges = explode(' ', $range);
+            $cref = count($cellRanges);
+            $recordData = pack(
+                'vvVVvCVvVv',
+                0x0868,
+                0x00,
+                0x0000,
+                0x0000,
+                0x02,
+                0x0,
+                0x0000,
+                $cref,
+                0x0000,
+                0x00
+            );
+            foreach ($cellRanges as $cellRange) {
+                $recordData .= $this->writeBIFF8CellRangeAddressFixed($cellRange);
+            }
+            $recordData .= pack(
+                'VV',
+                0x0000,
+                hexdec($password)
+            );
+            $recordData .= StringHelper::UTF8toBIFF8UnicodeLong('p' . md5($recordData));
+            $length = strlen($recordData);
+            $record = 0x0868; // Record identifier
+            $header = pack('vv', $record, $length);
+            $this->append($header . $recordData);
+        }
+    }
+    /**
+     * Writes the Excel BIFF PANE record.
+     * The panes can either be frozen or thawed (unfrozen).
+     * Frozen panes are specified in terms of an integer number of rows and columns.
+     * Thawed panes are specified in terms of Excel's units for rows and columns.
+     */
+    private function writePanes(): void
+    {
+        if (!$this->phpSheet->getFreezePane()) {
+            return;
+        }
+        [$column, $row] = Coordinate::indexesFromString($this->phpSheet->getFreezePane());
+        $x = $column - 1;
+        $y = $row - 1;
+        [$leftMostColumn, $topRow] = Coordinate::indexesFromString($this->phpSheet->getTopLeftCell() ?? '');
+        $rwTop = $topRow - 1;
+        $colLeft = $leftMostColumn - 1;
+        $record = 0x0041; // Record identifier
+        $length = 0x000A; // Number of bytes to follow
+        $pnnAct = 0;
+        if ($x != 0 && $y != 0) {
+            $pnnAct = 0; // Bottom right
+        }
+        if ($x != 0 && $y == 0) {
+            $pnnAct = 1; // Top right
+        }
+        if ($x == 0 && $y != 0) {
+            $pnnAct = 2; // Bottom left
+        }
+        if ($x == 0 && $y == 0) {
+            $pnnAct = 3; // Top left
+        }
+        $this->activePane = $pnnAct; // Used in writeSelection
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvvv', $x, $y, $rwTop, $colLeft, $pnnAct);
+        $this->append($header . $data);
+    }
+    /**
+     * Store the page setup SETUP BIFF record.
+     */
+    private function writeSetup(): void
+    {
+        $record = 0x00A1; // Record identifier
+        $length = 0x0022; // Number of bytes to follow
+        $iPaperSize = $this->phpSheet->getPageSetup()->getPaperSize(); // Paper size
+        $iScale = $this->phpSheet->getPageSetup()->getScale() ?: 100; // Print scaling factor
+        $iPageStart = 0x01; // Starting page number
+        $iFitWidth = (int) $this->phpSheet->getPageSetup()->getFitToWidth(); // Fit to number of pages wide
+        $iFitHeight = (int) $this->phpSheet->getPageSetup()->getFitToHeight(); // Fit to number of pages high
+        $iRes = 0x0258; // Print resolution
+        $iVRes = 0x0258; // Vertical print resolution
+        $numHdr = $this->phpSheet->getPageMargins()->getHeader(); // Header Margin
+        $numFtr = $this->phpSheet->getPageMargins()->getFooter(); // Footer Margin
+        $iCopies = 0x01; // Number of copies
+        $fLeftToRight = $this->phpSheet->getPageSetup()->getPageOrder() === PageSetup::PAGEORDER_DOWN_THEN_OVER
+            ? 0x0 : 0x1;
+        $fLandscape = ($this->phpSheet->getPageSetup()->getOrientation() == PageSetup::ORIENTATION_LANDSCAPE)
+            ? 0x0 : 0x1;
+        $fNoPls = 0x0; // Setup not read from printer
+        $fNoColor = 0x0; // Print black and white
+        $fDraft = 0x0; // Print draft quality
+        $fNotes = 0x0; // Print notes
+        $fNoOrient = 0x0; // Orientation not set
+        $fUsePage = 0x0; // Use custom starting page
+        $grbit = $fLeftToRight;
+        $grbit |= $fLandscape << 1;
+        $grbit |= $fNoPls << 2;
+        $grbit |= $fNoColor << 3;
+        $grbit |= $fDraft << 4;
+        $grbit |= $fNotes << 5;
+        $grbit |= $fNoOrient << 6;
+        $grbit |= $fUsePage << 7;
+        $numHdr = pack('d', $numHdr);
+        $numFtr = pack('d', $numFtr);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $numHdr = strrev($numHdr);
+            $numFtr = strrev($numFtr);
+        }
+        $header = pack('vv', $record, $length);
+        $data1 = pack('vvvvvvvv', $iPaperSize, $iScale, $iPageStart, $iFitWidth, $iFitHeight, $grbit, $iRes, $iVRes);
+        $data2 = $numHdr . $numFtr;
+        $data3 = pack('v', $iCopies);
+        $this->append($header . $data1 . $data2 . $data3);
+    }
+    /**
+     * Store the header caption BIFF record.
+     */
+    private function writeHeader(): void
+    {
+        $record = 0x0014; // Record identifier
+        /* removing for now
+        if (strlen($this->phpSheet->getHeaderFooter()->getOddHeader()) <= 255) {
+            $str      = $this->phpSheet->getHeaderFooter()->getOddHeader();       // header string
+        } else {
+            $str = '';
+        }
+        */
+        $recordData = StringHelper::UTF8toBIFF8UnicodeLong($this->phpSheet->getHeaderFooter()->getOddHeader());
+        $length = strlen($recordData);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $recordData);
+    }
+    /**
+     * Store the footer caption BIFF record.
+     */
+    private function writeFooter(): void
+    {
+        $record = 0x0015; // Record identifier
+        /* removing for now
+        if (strlen($this->phpSheet->getHeaderFooter()->getOddFooter()) <= 255) {
+            $str = $this->phpSheet->getHeaderFooter()->getOddFooter();
+        } else {
+            $str = '';
+        }
+        */
+        $recordData = StringHelper::UTF8toBIFF8UnicodeLong($this->phpSheet->getHeaderFooter()->getOddFooter());
+        $length = strlen($recordData);
+        $header = pack('vv', $record, $length);
+        $this->append($header . $recordData);
+    }
+    /**
+     * Store the horizontal centering HCENTER BIFF record.
+     */
+    private function writeHcenter(): void
+    {
+        $record = 0x0083; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fHCenter = $this->phpSheet->getPageSetup()->getHorizontalCentered() ? 1 : 0; // Horizontal centering
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fHCenter);
+        $this->append($header . $data);
+    }
+    /**
+     * Store the vertical centering VCENTER BIFF record.
+     */
+    private function writeVcenter(): void
+    {
+        $record = 0x0084; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fVCenter = $this->phpSheet->getPageSetup()->getVerticalCentered() ? 1 : 0; // Horizontal centering
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fVCenter);
+        $this->append($header . $data);
+    }
+    /**
+     * Store the LEFTMARGIN BIFF record.
+     */
+    private function writeMarginLeft(): void
+    {
+        $record = 0x0026; // Record identifier
+        $length = 0x0008; // Bytes to follow
+        $margin = $this->phpSheet->getPageMargins()->getLeft(); // Margin in inches
+        $header = pack('vv', $record, $length);
+        $data = pack('d', $margin);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $data = strrev($data);
+        }
+        $this->append($header . $data);
+    }
+    /**
+     * Store the RIGHTMARGIN BIFF record.
+     */
+    private function writeMarginRight(): void
+    {
+        $record = 0x0027; // Record identifier
+        $length = 0x0008; // Bytes to follow
+        $margin = $this->phpSheet->getPageMargins()->getRight(); // Margin in inches
+        $header = pack('vv', $record, $length);
+        $data = pack('d', $margin);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $data = strrev($data);
+        }
+        $this->append($header . $data);
+    }
+    /**
+     * Store the TOPMARGIN BIFF record.
+     */
+    private function writeMarginTop(): void
+    {
+        $record = 0x0028; // Record identifier
+        $length = 0x0008; // Bytes to follow
+        $margin = $this->phpSheet->getPageMargins()->getTop(); // Margin in inches
+        $header = pack('vv', $record, $length);
+        $data = pack('d', $margin);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $data = strrev($data);
+        }
+        $this->append($header . $data);
+    }
+    /**
+     * Store the BOTTOMMARGIN BIFF record.
+     */
+    private function writeMarginBottom(): void
+    {
+        $record = 0x0029; // Record identifier
+        $length = 0x0008; // Bytes to follow
+        $margin = $this->phpSheet->getPageMargins()->getBottom(); // Margin in inches
+        $header = pack('vv', $record, $length);
+        $data = pack('d', $margin);
+        if (self::getByteOrder()) { // if it's Big Endian
+            $data = strrev($data);
+        }
+        $this->append($header . $data);
+    }
+    /**
+     * Write the PRINTHEADERS BIFF record.
+     */
+    private function writePrintHeaders(): void
+    {
+        $record = 0x002A; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fPrintRwCol = $this->printHeaders; // Boolean flag
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fPrintRwCol);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
+     * GRIDSET record.
+     */
+    private function writePrintGridlines(): void
+    {
+        $record = 0x002B; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fPrintGrid = $this->phpSheet->getPrintGridlines() ? 1 : 0; // Boolean flag
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fPrintGrid);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the GRIDSET BIFF record. Must be used in conjunction with the
+     * PRINTGRIDLINES record.
+     */
+    private function writeGridset(): void
+    {
+        $record = 0x0082; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fGridSet = !$this->phpSheet->getPrintGridlines(); // Boolean flag
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fGridSet);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the AUTOFILTERINFO BIFF record. This is used to configure the number of autofilter select used in the sheet.
+     */
+    private function writeAutoFilterInfo(): void
+    {
+        $record = 0x009D; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $rangeBounds = Coordinate::rangeBoundaries($this->phpSheet->getAutoFilter()->getRange());
+        $iNumFilters = 1 + $rangeBounds[1][0] - $rangeBounds[0][0];
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $iNumFilters);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the GUTS BIFF record. This is used to configure the gutter margins
+     * where Excel outline symbols are displayed. The visibility of the gutters is
+     * controlled by a flag in WSBOOL.
+     *
+     * @see writeWsbool()
+     */
+    private function writeGuts(): void
+    {
+        $record = 0x0080; // Record identifier
+        $length = 0x0008; // Bytes to follow
+        $dxRwGut = 0x0000; // Size of row gutter
+        $dxColGut = 0x0000; // Size of col gutter
+        $maxRowOutlineLevel = 0;
+        foreach ($this->phpSheet->getRowDimensions() as $rowDimension) {
+            $maxRowOutlineLevel = max($maxRowOutlineLevel, $rowDimension->getOutlineLevel());
+        }
+        $col_level = 0;
+        $colcount = count($this->columnInfo);
+        for ($i = 0; $i < $colcount; ++$i) {
+            $col_level = max($this->columnInfo[$i][5], $col_level);
+        }
+        $col_level = max(0, min($col_level, 7));
+        if ($maxRowOutlineLevel) {
+            ++$maxRowOutlineLevel;
+        }
+        if ($col_level) {
+            ++$col_level;
+        }
+        $header = pack('vv', $record, $length);
+        $data = pack('vvvv', $dxRwGut, $dxColGut, $maxRowOutlineLevel, $col_level);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
+     * with the SETUP record.
+     */
+    private function writeWsbool(): void
+    {
+        $record = 0x0081; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $grbit = 0x0000;
+        $grbit |= 0x0001; // Auto page breaks visible
+        if ($this->outlineStyle) {
+            $grbit |= 0x0020; // Auto outline styles
+        }
+        if ($this->phpSheet->getShowSummaryBelow()) {
+            $grbit |= 0x0040; // Outline summary below
+        }
+        if ($this->phpSheet->getShowSummaryRight()) {
+            $grbit |= 0x0080; // Outline summary right
+        }
+        if ($this->phpSheet->getPageSetup()->getFitToPage()) {
+            $grbit |= 0x0100; // Page setup fit to page
+        }
+        if ($this->outlineOn) {
+            $grbit |= 0x0400; // Outline symbols displayed
+        }
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $grbit);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the HORIZONTALPAGEBREAKS and VERTICALPAGEBREAKS BIFF records.
+     */
+    private function writeBreaks(): void
+    {
+        $vbreaks = [];
+        $hbreaks = [];
+        foreach ($this->phpSheet->getRowBreaks() as $cell => $break) {
+            $coordinates = Coordinate::coordinateFromString($cell);
+            $hbreaks[] = $coordinates[1];
+        }
+        foreach ($this->phpSheet->getColumnBreaks() as $cell => $break) {
+            $coordinates = Coordinate::indexesFromString($cell);
+            $vbreaks[] = $coordinates[0] - 1;
+        }
+        if (!empty($hbreaks)) {
+            sort($hbreaks, SORT_NUMERIC);
+            if ($hbreaks[0] == 0) { // don't use first break if it's 0
+                array_shift($hbreaks);
+            }
+            $record = 0x001B; // Record identifier
+            $cbrk = count($hbreaks); // Number of page breaks
+            $length = 2 + 6 * $cbrk; // Bytes to follow
+            $header = pack('vv', $record, $length);
+            $data = pack('v', $cbrk);
+            foreach ($hbreaks as $hbreak) {
+                $data .= pack('vvv', $hbreak, 0x0000, 0x00FF);
+            }
+            $this->append($header . $data);
+        }
+        if (!empty($vbreaks)) {
+            $vbreaks = array_slice($vbreaks, 0, 1000);
+            sort($vbreaks, SORT_NUMERIC);
+            if ($vbreaks[0] == 0) { // don't use first break if it's 0
+                array_shift($vbreaks);
+            }
+            $record = 0x001A; // Record identifier
+            $cbrk = count($vbreaks); // Number of page breaks
+            $length = 2 + 6 * $cbrk; // Bytes to follow
+            $header = pack('vv', $record, $length);
+            $data = pack('v', $cbrk);
+            foreach ($vbreaks as $vbreak) {
+                $data .= pack('vvv', $vbreak, 0x0000, 0xFFFF);
+            }
+            $this->append($header . $data);
+        }
+    }
+    /**
+     * Set the Biff PROTECT record to indicate that the worksheet is protected.
+     */
+    private function writeProtect(): void
+    {
+        if ($this->phpSheet->getProtection()->getSheet() !== true) {
+            return;
+        }
+        $record = 0x0012; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $fLock = 1; // Worksheet is protected
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $fLock);
+        $this->append($header . $data);
+    }
+    /**
+     * Write SCENPROTECT.
+     */
+    private function writeScenProtect(): void
+    {
+        if ($this->phpSheet->getProtection()->getSheet() !== true) {
+            return;
+        }
+        if ($this->phpSheet->getProtection()->getScenarios() !== true) {
+            return;
+        }
+        $record = 0x00DD; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('v', 1);
+        $this->append($header . $data);
+    }
+    /**
+     * Write OBJECTPROTECT.
+     */
+    private function writeObjectProtect(): void
+    {
+        if ($this->phpSheet->getProtection()->getSheet() !== true) {
+            return;
+        }
+        if ($this->phpSheet->getProtection()->getObjects() !== true) {
+            return;
+        }
+        $record = 0x0063; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('v', 1);
+        $this->append($header . $data);
+    }
+    /**
+     * Write the worksheet PASSWORD record.
+     */
+    private function writePassword(): void
+    {
+        if ($this->phpSheet->getProtection()->getSheet() !== true || !$this->phpSheet->getProtection()->getPassword() || $this->phpSheet->getProtection()->getAlgorithm() !== '') {
+            return;
+        }
+        $record = 0x0013; // Record identifier
+        $length = 0x0002; // Bytes to follow
+        $wPassword = hexdec($this->phpSheet->getProtection()->getPassword()); // Encoded password
+        $header = pack('vv', $record, $length);
+        $data = pack('v', $wPassword);
+        $this->append($header . $data);
+    }
+    /**
+     * Insert a 24bit bitmap image in a worksheet.
+     *
+     * @param int $row The row we are going to insert the bitmap into
+     * @param int $col The column we are going to insert the bitmap into
+     * @param GdImage|string $bitmap The bitmap filename or GD-image resource
+     * @param int $x the horizontal position (offset) of the image inside the cell
+     * @param int $y the vertical position (offset) of the image inside the cell
+     * @param float $scale_x The horizontal scale
+     * @param float $scale_y The vertical scale
+     */
+    public function insertBitmap(int $row, int $col, GdImage|string $bitmap, int $x = 0, int $y = 0, float $scale_x = 1, float $scale_y = 1): void
+    {
+        $bitmap_array = $bitmap instanceof GdImage
+            ? $this->processBitmapGd($bitmap)
+            : $this->processBitmap($bitmap);
+        [$width, $height, $size, $data] = $bitmap_array;
+        $width *= $scale_x;
+        $height *= $scale_y;
+        $this->positionImage($col, $row, $x, $y, (int) $width, (int) $height);
+        $record = 0x007F;
+        $length = 8 + $size;
+        $cf = 0x09;
+        $env = 0x01;
+        $lcb = $size;
+        $header = pack('vvvvV', $record, $length, $cf, $env, $lcb);
+        $this->append($header . $data);
+    }
+    /**
+     * Calculate the vertices that define the position of the image as required by
+     * the OBJ record.
+     *
+     *         +------------+------------+
+     *         |     A      |      B     |
+     *   +-----+------------+------------+
+     *   |     |(x1,y1)     |            |
+     *   |  1  |(A1)._______|______      |
+     *   |     |    |              |     |
+     *   |     |    |              |     |
+     *   +-----+----|    BITMAP    |-----+
+     *   |     |    |              |     |
+     *   |  2  |    |______________.     |
+     *   |     |            |        (B2)|
+     *   |     |            |     (x2,y2)|
+     *   +---- +------------+------------+
+     *
+     * Example of a bitmap that covers some of the area from cell A1 to cell B2.
+     *
+     * Based on the width and height of the bitmap we need to calculate 8 vars:
+     *     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
+     * The width and height of the cells are also variable and have to be taken into
+     * account.
+     * The values of $col_start and $row_start are passed in from the calling
+     * function. The values of $col_end and $row_end are calculated by subtracting
+     * the width and height of the bitmap from the width and height of the
+     * underlying cells.
+     * The vertices are expressed as a percentage of the underlying cell width as
+     * follows (rhs values are in pixels):
+     *
+     *       x1 = X / W *1024
+     *       y1 = Y / H *256
+     *       x2 = (X-1) / W *1024
+     *       y2 = (Y-1) / H *256
+     *
+     *       Where:  X is distance from the left side of the underlying cell
+     *               Y is distance from the top of the underlying cell
+     *               W is the width of the cell
+     *               H is the height of the cell
+     * The SDK incorrectly states that the height should be expressed as a
+     *        percentage of 1024.
+     *
+     * @param int $col_start Col containing upper left corner of object
+     * @param int $row_start Row containing top left corner of object
+     * @param int $x1 Distance to left side of object
+     * @param int $y1 Distance to top of object
+     * @param int $width Width of image frame
+     * @param int $height Height of image frame
+     */
+    public function positionImage(int $col_start, int $row_start, int $x1, int $y1, int $width, int $height): void
+    {
+        $col_end = $col_start; // Col containing lower right corner of object
+        $row_end = $row_start; // Row containing bottom right corner of object
+        if ($x1 >= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1))) {
+            $x1 = 0;
+        }
+        if ($y1 >= Xls::sizeRow($this->phpSheet, $row_start + 1)) {
+            $y1 = 0;
+        }
+        $width = $width + $x1 - 1;
+        $height = $height + $y1 - 1;
+        while ($width >= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1))) {
+            $width -= Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1));
+            ++$col_end;
+        }
+        while ($height >= Xls::sizeRow($this->phpSheet, $row_end + 1)) {
+            $height -= Xls::sizeRow($this->phpSheet, $row_end + 1);
+            ++$row_end;
+        }
+        if (Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1)) == 0) {
+            return;
+        }
+        if (Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1)) == 0) {
+            return;
+        }
+        if (Xls::sizeRow($this->phpSheet, $row_start + 1) == 0) {
+            return;
+        }
+        if (Xls::sizeRow($this->phpSheet, $row_end + 1) == 0) {
+            return;
+        }
+        $x1 = $x1 / Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_start + 1)) * 1024;
+        $y1 = $y1 / Xls::sizeRow($this->phpSheet, $row_start + 1) * 256;
+        $x2 = $width / Xls::sizeCol($this->phpSheet, Coordinate::stringFromColumnIndex($col_end + 1)) * 1024; // Distance to right side of object
+        $y2 = $height / Xls::sizeRow($this->phpSheet, $row_end + 1) * 256; // Distance to bottom of object
+        $this->writeObjPicture($col_start, $x1, $row_start, $y1, $col_end, $x2, $row_end, $y2);
+    }
+    /**
+     * Store the OBJ record that precedes an IMDATA record. This could be generalise
+     * to support other Excel objects.
+     *
+     * @param int $colL Column containing upper left corner of object
+     * @param int $dxL Distance from left side of cell
+     * @param int $rwT Row containing top left corner of object
+     * @param float|int $dyT Distance from top of cell
+     * @param int $colR Column containing lower right corner of object
+     * @param int $dxR Distance from right of cell
+     * @param int $rwB Row containing bottom right corner of object
+     * @param int $dyB Distance from bottom of cell
+     */
+    private function writeObjPicture(int $colL, int $dxL, int $rwT, int|float $dyT, int $colR, int $dxR, int $rwB, int $dyB): void
+    {
+        $record = 0x005D; // Record identifier
+        $length = 0x003C; // Bytes to follow
+        $cObj = 0x0001; // Count of objects in file (set to 1)
+        $OT = 0x0008; // Object type. 8 = Picture
+        $id = 0x0001; // Object ID
+        $grbit = 0x0614; // Option flags
+        $cbMacro = 0x0000; // Length of FMLA structure
+        $Reserved1 = 0x0000; // Reserved
+        $Reserved2 = 0x0000; // Reserved
+        $icvBack = 0x09; // Background colour
+        $icvFore = 0x09; // Foreground colour
+        $fls = 0x00; // Fill pattern
+        $fAuto = 0x00; // Automatic fill
+        $icv = 0x08; // Line colour
+        $lns = 0xFF; // Line style
+        $lnw = 0x01; // Line weight
+        $fAutoB = 0x00; // Automatic border
+        $frs = 0x0000; // Frame style
+        $cf = 0x0009; // Image format, 9 = bitmap
+        $Reserved3 = 0x0000; // Reserved
+        $cbPictFmla = 0x0000; // Length of FMLA structure
+        $Reserved4 = 0x0000; // Reserved
+        $grbit2 = 0x0001; // Option flags
+        $Reserved5 = 0x0000; // Reserved
+        $header = pack('vv', $record, $length);
+        $data = pack('V', $cObj);
+        $data .= pack('v', $OT);
+        $data .= pack('v', $id);
+        $data .= pack('v', $grbit);
+        $data .= pack('v', $colL);
+        $data .= pack('v', $dxL);
+        $data .= pack('v', $rwT);
+        $data .= pack('v', $dyT);
+        $data .= pack('v', $colR);
+        $data .= pack('v', $dxR);
+        $data .= pack('v', $rwB);
+        $data .= pack('v', $dyB);
+        $data .= pack('v', $cbMacro);
+        $data .= pack('V', $Reserved1);
+        $data .= pack('v', $Reserved2);
+        $data .= pack('C', $icvBack);
+        $data .= pack('C', $icvFore);
+        $data .= pack('C', $fls);
+        $data .= pack('C', $fAuto);
+        $data .= pack('C', $icv);
+        $data .= pack('C', $lns);
+        $data .= pack('C', $lnw);
+        $data .= pack('C', $fAutoB);
+        $data .= pack('v', $frs);
+        $data .= pack('V', $cf);
+        $data .= pack('v', $Reserved3);
+        $data .= pack('v', $cbPictFmla);
+        $data .= pack('v', $Reserved4);
+        $data .= pack('v', $grbit2);
+        $data .= pack('V', $Reserved5);
+        $this->append($header . $data);
+    }
+    /**
+     * Convert a GD-image into the internal format.
+     *
+     * @param GdImage $image The image to process
+     *
+     * @return array Array with data and properties of the bitmap
+     */
+    public function processBitmapGd(GdImage $image): array
+    {
+        $width = imagesx($image);
+        $height = imagesy($image);
+        $data = pack('Vvvvv', 0x000C, $width, $height, 0x01, 0x18);
+        for ($j = $height; --$j;) {
+            for ($i = 0; $i < $width; ++$i) {
+                /** @phpstan-ignore-next-line */
+                $color = imagecolorsforindex($image, imagecolorat($image, $i, $j));
+                if ($color !== false) {
+                    foreach (['red', 'green', 'blue'] as $key) {
+                        $color[$key] = $color[$key] + (int) round((255 - $color[$key]) * $color['alpha'] / 127);
+                    }
+                    $data .= chr($color['blue']) . chr($color['green']) . chr($color['red']);
+                }
+            }
+            if (3 * $width % 4) {
+                $data .= str_repeat("\x00", 4 - 3 * $width % 4);
+            }
+        }
+        return [$width, $height, strlen($data), $data];
+    }
+    /**
+     * Convert a 24 bit bitmap into the modified internal format used by Windows.
+     * This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
+     * MSDN library.
+     *
+     * @param string $bitmap The bitmap to process
+     *
+     * @return array Array with data and properties of the bitmap
+     */
+    public function processBitmap(string $bitmap): array
+    {
+        $bmp_fd = @fopen($bitmap, 'rb');
+        if ($bmp_fd === false || 0 === (int) filesize($bitmap)) {
+            throw new WriterException("Couldn't import $bitmap");
+        }
+        $data = (string) fread($bmp_fd, (int) filesize($bitmap));
+        if (strlen($data) <= 0x36) {
+            throw new WriterException("$bitmap doesn't contain enough data.\n");
+        }
+        $identity = unpack('A2ident', $data);
+        if ($identity === false || $identity['ident'] != 'BM') {
+            throw new WriterException("$bitmap doesn't appear to be a valid bitmap image.\n");
+        }
+        $data = substr($data, 2);
+        $size_array = unpack('Vsa', substr($data, 0, 4)) ?: [];
+        $size = $size_array['sa'];
+        $data = substr($data, 4);
+        $size -= 0x36; // Subtract size of bitmap header.
+        $size += 0x0C; // Add size of BIFF header.
+        $data = substr($data, 12);
+        $width_and_height = unpack('V2', substr($data, 0, 8)) ?: [];
+        $width = $width_and_height[1];
+        $height = $width_and_height[2];
+        $data = substr($data, 8);
+        if ($width > 0xFFFF) {
+            throw new WriterException("$bitmap: largest image width supported is 65k.\n");
+        }
+        if ($height > 0xFFFF) {
+            throw new WriterException("$bitmap: largest image height supported is 65k.\n");
+        }
+        $planes_and_bitcount = unpack('v2', substr($data, 0, 4));
+        $data = substr($data, 4);
+        if ($planes_and_bitcount === false || $planes_and_bitcount[2] != 24) { // Bitcount
+            throw new WriterException("$bitmap isn't a 24bit true color bitmap.\n");
+        }
+        if ($planes_and_bitcount[1] != 1) {
+            throw new WriterException("$bitmap: only 1 plane supported in bitmap image.\n");
+        }
+        $compression = unpack('Vcomp', substr($data, 0, 4));
+        $data = substr($data, 4);
+        if ($compression === false || $compression['comp'] != 0) {
+            throw new WriterException("$bitmap: compression not supported in bitmap image.\n");
+        }
+        $data = substr($data, 20);
+        $header = pack('Vvvvv', 0x000C, $width, $height, 0x01, 0x18);
+        $data = $header . $data;
+        return [$width, $height, $size, $data];
+    }
+    /**
+     * Store the window zoom factor. This should be a reduced fraction but for
+     * simplicity we will store all fractions with a numerator of 100.
+     */
+    private function writeZoom(): void
+    {
+        if ($this->phpSheet->getSheetView()->getZoomScale() == 100) {
+            return;
+        }
+        $record = 0x00A0; // Record identifier
+        $length = 0x0004; // Bytes to follow
+        $header = pack('vv', $record, $length);
+        $data = pack('vv', $this->phpSheet->getSheetView()->getZoomScale(), 100);
+        $this->append($header . $data);
+    }
+    /**
+     * Get Escher object.
+     */
+    public function getEscher(): ?\PhpOffice\PhpSpreadsheet\Shared\Escher
+    {
+        return $this->escher;
+    }
+    /**
+     * Set Escher object.
+     */
+    public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $escher): void
+    {
+        $this->escher = $escher;
+    }
+    /**
+     * Write MSODRAWING record.
+     */
+    private function writeMsoDrawing(): void
+    {
+        if (isset($this->escher)) {
+            $writer = new Escher($this->escher);
+            $data = $writer->close();
+            $spOffsets = $writer->getSpOffsets();
+            $spTypes = $writer->getSpTypes();
+            $spOffsets[0] = 0;
+            $nm = count($spOffsets) - 1; // number of shapes excluding first shape
+            for ($i = 1; $i <= $nm; ++$i) {
+                $record = 0x00EC; // Record identifier
+                $dataChunk = substr($data, $spOffsets[$i - 1], $spOffsets[$i] - $spOffsets[$i - 1]);
+                $length = strlen($dataChunk);
+                $header = pack('vv', $record, $length);
+                $this->append($header . $dataChunk);
+                $record = 0x005D; // record identifier
+                $objData = '';
+                if ($spTypes[$i] == 0x00C9) {
+                    $objData
+                        .= pack(
+                            'vvvvvVVV',
+                            0x0015, // 0x0015 = ftCmo
+                            0x0012, // length of ftCmo data
+                            0x0014, // object type, 0x0014 = filter
+                            $i, // object id number, Excel seems to use 1-based index, local for the sheet
+                            0x2101, // option flags, 0x2001 is what OpenOffice.org uses
+                            0, // reserved
+                            0, // reserved
+                            0  // reserved
+                        );
+                    $objData .= pack('vv', 0x00C, 0x0014);
+                    $objData .= pack('H*', '0000000000000000640001000A00000010000100');
+                    $objData .= pack('vv', 0x0013, 0x1FEE);
+                    $objData .= pack('H*', '00000000010001030000020008005700');
+                } else {
+                    $objData
+                        .= pack(
+                            'vvvvvVVV',
+                            0x0015, // 0x0015 = ftCmo
+                            0x0012, // length of ftCmo data
+                            0x0008, // object type, 0x0008 = picture
+                            $i, // object id number, Excel seems to use 1-based index, local for the sheet
+                            0x6011, // option flags, 0x6011 is what OpenOffice.org uses
+                            0, // reserved
+                            0, // reserved
+                            0  // reserved
+                        );
+                }
+                $objData
+                    .= pack(
+                        'vv',
+                        0x0000, // 0x0000 = ftEnd
+                        0x0000  // length of ftEnd data
+                    );
+                $length = strlen($objData);
+                $header = pack('vv', $record, $length);
+                $this->append($header . $objData);
+            }
+        }
+    }
+    /**
+     * Store the DATAVALIDATIONS and DATAVALIDATION records.
+     */
+    private function writeDataValidity(): void
+    {
+        $dataValidationCollection = $this->phpSheet->getDataValidationCollection();
+        if (!empty($dataValidationCollection)) {
+            $record = 0x01B2; // Record identifier
+            $length = 0x0012; // Bytes to follow
+            $grbit = 0x0000; // Prompt box at cell, no cached validity data at DV records
+            $horPos = 0x00000000; // Horizontal position of prompt box, if fixed position
+            $verPos = 0x00000000; // Vertical position of prompt box, if fixed position
+            $objId = 0xFFFFFFFF; // Object identifier of drop down arrow object, or -1 if not visible
+            $header = pack('vv', $record, $length);
+            $data = pack('vVVVV', $grbit, $horPos, $verPos, $objId, count($dataValidationCollection));
+            $this->append($header . $data);
+            $record = 0x01BE; // Record identifier
+            foreach ($dataValidationCollection as $cellCoordinate => $dataValidation) {
+                $options = 0x00000000;
+                $type = CellDataValidation::type($dataValidation);
+                $options |= $type << 0;
+                $errorStyle = CellDataValidation::errorStyle($dataValidation);
+                $options |= $errorStyle << 4;
+                if ($type == 0x03 && preg_match('/^\".*\"$/', $dataValidation->getFormula1())) {
+                    $options |= 0x01 << 7;
+                }
+                $options |= $dataValidation->getAllowBlank() << 8;
+                $options |= (!$dataValidation->getShowDropDown()) << 9;
+                $options |= $dataValidation->getShowInputMessage() << 18;
+                $options |= $dataValidation->getShowErrorMessage() << 19;
+                $operator = CellDataValidation::operator($dataValidation);
+                $options |= $operator << 20;
+                $data = pack('V', $options);
+                $promptTitle = $dataValidation->getPromptTitle() !== ''
+                    ? $dataValidation->getPromptTitle() : chr(0);
+                $data .= StringHelper::UTF8toBIFF8UnicodeLong($promptTitle);
+                $errorTitle = $dataValidation->getErrorTitle() !== ''
+                    ? $dataValidation->getErrorTitle() : chr(0);
+                $data .= StringHelper::UTF8toBIFF8UnicodeLong($errorTitle);
+                $prompt = $dataValidation->getPrompt() !== ''
+                    ? $dataValidation->getPrompt() : chr(0);
+                $data .= StringHelper::UTF8toBIFF8UnicodeLong($prompt);
+                $error = $dataValidation->getError() !== ''
+                    ? $dataValidation->getError() : chr(0);
+                $data .= StringHelper::UTF8toBIFF8UnicodeLong($error);
+                try {
+                    $formula1 = $dataValidation->getFormula1();
+                    if ($type == 0x03) { // list type
+                        $formula1 = str_replace(',', chr(0), $formula1);
+                    }
+                    $this->parser->parse($formula1);
+                    $formula1 = $this->parser->toReversePolish();
+                    $sz1 = strlen($formula1);
+                } catch (PhpSpreadsheetException $e) {
+                    $sz1 = 0;
+                    $formula1 = '';
+                }
+                $data .= pack('vv', $sz1, 0x0000);
+                $data .= $formula1;
+                try {
+                    $formula2 = $dataValidation->getFormula2();
+                    if ($formula2 === '') {
+                        throw new WriterException('No formula2');
+                    }
+                    $this->parser->parse($formula2);
+                    $formula2 = $this->parser->toReversePolish();
+                    $sz2 = strlen($formula2);
+                } catch (PhpSpreadsheetException) {
+                    $sz2 = 0;
+                    $formula2 = '';
+                }
+                $data .= pack('vv', $sz2, 0x0000);
+                $data .= $formula2;
+                $data .= pack('v', 0x0001);
+                $data .= $this->writeBIFF8CellRangeAddressFixed($cellCoordinate);
+                $length = strlen($data);
+                $header = pack('vv', $record, $length);
+                $this->append($header . $data);
+            }
+        }
+    }
+    /**
+     * Write PLV Record.
+     */
+    private function writePageLayoutView(): void
+    {
+        $record = 0x088B; // Record identifier
+        $length = 0x0010; // Bytes to follow
+        $rt = 0x088B; // 2
+        $grbitFrt = 0x0000; // 2
+        $wScalvePLV = $this->phpSheet->getSheetView()->getZoomScale(); // 2
+        if ($this->phpSheet->getSheetView()->getView() == SheetView::SHEETVIEW_PAGE_LAYOUT) {
+            $fPageLayoutView = 1;
+        } else {
+            $fPageLayoutView = 0;
+        }
+        $fRulerVisible = 0;
+        $fWhitespaceHidden = 0;
+        $grbit = $fPageLayoutView; // 2
+        $grbit |= $fRulerVisible << 1;
+        $grbit |= $fWhitespaceHidden << 3;
+        $header = pack('vv', $record, $length);
+        $data = pack('vvVVvv', $rt, $grbitFrt, 0x00000000, 0x00000000, $wScalvePLV, $grbit);
+        $this->append($header . $data);
+    }
+    /**
+     * Write CFRule Record.
+     *
+     * @see https://www.openoffice.org/sc/excelfileformat.pdf Search for CFHEADER followed by CFRULE
+     */
+    private function writeCFRule(
+        ConditionalHelper $conditionalFormulaHelper,
+        Conditional $conditional,
+        string $cellRange
+    ): void {
+        $record = 0x01B1; // Record identifier
+        $type = null; // Type of the CF
+        $operatorType = null; // Comparison operator
+        if ($conditional->getConditionType() == Conditional::CONDITION_EXPRESSION) {
+            $type = 0x02;
+            $operatorType = 0x00;
+        } elseif ($conditional->getConditionType() == Conditional::CONDITION_CELLIS) {
+            $type = 0x01;
+            switch ($conditional->getOperatorType()) {
+                case Conditional::OPERATOR_NONE:
+                    $operatorType = 0x00;
+                    break;
+                case Conditional::OPERATOR_EQUAL:
+                    $operatorType = 0x03;
+                    break;
+                case Conditional::OPERATOR_GREATERTHAN:
+                    $operatorType = 0x05;
+                    break;
+                case Conditional::OPERATOR_GREATERTHANOREQUAL:
+                    $operatorType = 0x07;
+                    break;
+                case Conditional::OPERATOR_LESSTHAN:
+                    $operatorType = 0x06;
+                    break;
+                case Conditional::OPERATOR_LESSTHANOREQUAL:
+                    $operatorType = 0x08;
+                    break;
+                case Conditional::OPERATOR_NOTEQUAL:
+                    $operatorType = 0x04;
+                    break;
+                case Conditional::OPERATOR_BETWEEN:
+                    $operatorType = 0x01;
+                    break;
+            }
+        }
+        $arrConditions = $conditional->getConditions();
+        $numConditions = count($arrConditions);
+        $szValue1 = 0x0000;
+        $szValue2 = 0x0000;
+        $operand1 = null;
+        $operand2 = null;
+        if ($numConditions === 1) {
+            $conditionalFormulaHelper->processCondition($arrConditions[0], $cellRange);
+            $szValue1 = $conditionalFormulaHelper->size();
+            $operand1 = $conditionalFormulaHelper->tokens();
+        } elseif ($numConditions === 2 && ($conditional->getOperatorType() === Conditional::OPERATOR_BETWEEN)) {
+            $conditionalFormulaHelper->processCondition($arrConditions[0], $cellRange);
+            $szValue1 = $conditionalFormulaHelper->size();
+            $operand1 = $conditionalFormulaHelper->tokens();
+            $conditionalFormulaHelper->processCondition($arrConditions[1], $cellRange);
+            $szValue2 = $conditionalFormulaHelper->size();
+            $operand2 = $conditionalFormulaHelper->tokens();
+        }
+        /*$bAlignHz = ($conditional->getStyle()->getAlignment()->getHorizontal() === null ? 1 : 0);
+        $bAlignVt = ($conditional->getStyle()->getAlignment()->getVertical() === null ? 1 : 0);
+        $bAlignWrapTx = ($conditional->getStyle()->getAlignment()->getWrapText() === false ? 1 : 0);
+        $bTxRotation = ($conditional->getStyle()->getAlignment()->getTextRotation() === null ? 1 : 0);
+        $bIndent = ($conditional->getStyle()->getAlignment()->getIndent() === 0 ? 1 : 0);
+        $bShrinkToFit = ($conditional->getStyle()->getAlignment()->getShrinkToFit() === false ? 1 : 0);
+        if ($bAlignHz == 0 || $bAlignVt == 0 || $bAlignWrapTx == 0 || $bTxRotation == 0 || $bIndent == 0 || $bShrinkToFit == 0) {
+            $bFormatAlign = 1;
+        } else {
+            $bFormatAlign = 0;
+        }*/
+        /*$bProtLocked = ($conditional->getStyle()->getProtection()->getLocked() === null ? 1 : 0);
+        $bProtHidden = ($conditional->getStyle()->getProtection()->getHidden() === null ? 1 : 0);
+        if ($bProtLocked == 0 || $bProtHidden == 0) {
+            $bFormatProt = 1;
+        } else {
+            $bFormatProt = 0;
+        }*/
+        $bBorderLeft = ($conditional->getStyle()->getBorders()->getLeft()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
+        $bBorderRight = ($conditional->getStyle()->getBorders()->getRight()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
+        $bBorderTop = ($conditional->getStyle()->getBorders()->getTop()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
+        $bBorderBottom = ($conditional->getStyle()->getBorders()->getBottom()->getBorderStyle() !== Border::BORDER_OMIT) ? 1 : 0;
+        $bBorderDiagTop = self::$always0; //$diagonalDirection === Borders::DIAGONAL_DOWN || $diagonalDirection === Borders::DIAGONAL_BOTH;
+        $bBorderDiagBottom = self::$always0; //$diagonalDirection === Borders::DIAGONAL_UP || $diagonalDirection === Borders::DIAGONAL_BOTH;
+        if ($bBorderLeft === 1 || $bBorderRight === 1 || $bBorderTop === 1 || $bBorderBottom === 1 || $bBorderDiagTop === 1 || $bBorderDiagBottom === 1) {
+            $bFormatBorder = 1;
+        } else {
+            $bFormatBorder = 0;
+        }
+        $bFillStyle = ($conditional->getStyle()->getFill()->getFillType() === null ? 0 : 1);
+        $bFillColor = ($conditional->getStyle()->getFill()->getStartColor()->getARGB() === null ? 0 : 1);
+        $bFillColorBg = ($conditional->getStyle()->getFill()->getEndColor()->getARGB() === null ? 0 : 1);
+        if ($bFillStyle == 1 || $bFillColor == 1 || $bFillColorBg == 1) {
+            $bFormatFill = 1;
+        } else {
+            $bFormatFill = 0;
+        }
+        if (
+            $conditional->getStyle()->getFont()->getName() !== null
+            || $conditional->getStyle()->getFont()->getSize() !== null
+            || $conditional->getStyle()->getFont()->getBold() !== null
+            || $conditional->getStyle()->getFont()->getItalic() !== null
+            || $conditional->getStyle()->getFont()->getSuperscript() !== null
+            || $conditional->getStyle()->getFont()->getSubscript() !== null
+            || $conditional->getStyle()->getFont()->getUnderline() !== null
+            || $conditional->getStyle()->getFont()->getStrikethrough() !== null
+            || $conditional->getStyle()->getFont()->getColor()->getARGB() !== null
+        ) {
+            $bFormatFont = 1;
+        } else {
+            $bFormatFont = 0;
+        }
+        $flags = 0;
+        $flags |= (1 == self::$always1 ? 0x00000010 : 0);
+        $flags |= (1 == self::$always1 ? 0x00000080 : 0);
+        $flags |= (0 == $bBorderLeft ? 0x00000400 : 0);
+        $flags |= (0 == $bBorderRight ? 0x00000800 : 0);
+        $flags |= (0 == $bBorderTop ? 0x00001000 : 0);
+        $flags |= (0 == $bBorderBottom ? 0x00002000 : 0);
+        $flags |= (0 === $bBorderDiagTop ? 0x00004000 : 0); // Top left to Bottom right border
+        $flags |= (0 === $bBorderDiagBottom ? 0x00008000 : 0); // Bottom left to Top right border
+        $flags |= (1 == $bFillStyle ? 0x00010000 : 0);
+        $flags |= (1 == $bFillColor ? 0x00020000 : 0);
+        $flags |= (1 == $bFillColorBg ? 0x00040000 : 0);
+        $flags |= (1 == self::$always1 ? 0x00380000 : 0);
+        $flags |= (1 == $bFormatFont ? 0x04000000 : 0);
+        $flags |= (1 == $bFormatBorder ? 0x10000000 : 0);
+        $flags |= (1 == $bFormatFill ? 0x20000000 : 0);
+        $flags |= (1 == self::$always0 ? 0x80000000 : 0);
+        $dataBlockFont = null;
+        $dataBlockBorder = null;
+        $dataBlockFill = null;
+        if ($bFormatFont == 1) {
+            if ($conditional->getStyle()->getFont()->getName() === null) {
+                $dataBlockFont = pack('VVVVVVVV', 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);
+                $dataBlockFont .= pack('VVVVVVVV', 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);
+            } else {
+                $dataBlockFont = StringHelper::UTF8toBIFF8UnicodeLong($conditional->getStyle()->getFont()->getName());
+            }
+            if ($conditional->getStyle()->getFont()->getSize() === null) {
+                $dataBlockFont .= pack('V', 20 * 11);
+            } else {
+                $dataBlockFont .= pack('V', 20 * $conditional->getStyle()->getFont()->getSize());
+            }
+            $italicStrike = 0;
+            if ($conditional->getStyle()->getFont()->getItalic() === true) {
+                $italicStrike |= 2;
+            }
+            if ($conditional->getStyle()->getFont()->getStrikethrough() === true) {
+                $italicStrike |= 0x80;
+            }
+            $dataBlockFont .= pack('V', $italicStrike);
+            if ($conditional->getStyle()->getFont()->getBold() === true) {
+                $dataBlockFont .= pack('v', 0x02BC);
+            } elseif ($conditional->getStyle()->getFont()->getBold() === null) {
+                $dataBlockFont .= pack('v', 0x0000);
+            } else {
+                $dataBlockFont .= pack('v', 0x0190);
+            }
+            if ($conditional->getStyle()->getFont()->getSubscript() === true) {
+                $dataBlockFont .= pack('v', 0x02);
+                $fontEscapement = 0;
+            } elseif ($conditional->getStyle()->getFont()->getSuperscript() === true) {
+                $dataBlockFont .= pack('v', 0x01);
+                $fontEscapement = 0;
+            } else {
+                $dataBlockFont .= pack('v', 0x00);
+                $fontEscapement = 1;
+            }
+            switch ($conditional->getStyle()->getFont()->getUnderline()) {
+                case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_NONE:
+                    $dataBlockFont .= pack('C', 0x00);
+                    $fontUnderline = 0;
+                    break;
+                case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLE:
+                    $dataBlockFont .= pack('C', 0x02);
+                    $fontUnderline = 0;
+                    break;
+                case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLEACCOUNTING:
+                    $dataBlockFont .= pack('C', 0x22);
+                    $fontUnderline = 0;
+                    break;
+                case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLE:
+                    $dataBlockFont .= pack('C', 0x01);
+                    $fontUnderline = 0;
+                    break;
+                case \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLEACCOUNTING:
+                    $dataBlockFont .= pack('C', 0x21);
+                    $fontUnderline = 0;
+                    break;
+                default:
+                    $dataBlockFont .= pack('C', 0x00);
+                    $fontUnderline = 1;
+                    break;
+            }
+            $dataBlockFont .= pack('vC', 0x0000, 0x00);
+            $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getFont()->getColor()->getRgb(), 0);
+            $dataBlockFont .= pack('V', $colorIdx);
+            $dataBlockFont .= pack('V', 0x00000000);
+            $optionsFlags = 0;
+            $optionsFlags |= ($conditional->getStyle()->getFont()->getBold() === null && $conditional->getStyle()->getFont()->getItalic() === null) ? 2 : 0;
+            $optionsFlags |= (1 == self::$always1 ? 0x00000008 : 0);
+            $optionsFlags |= (1 == self::$always1 ? 0x00000010 : 0);
+            $optionsFlags |= (1 == self::$always0 ? 0x00000020 : 0);
+            $optionsFlags |= ($conditional->getStyle()->getFont()->getStrikethrough() === null) ? 0x80 : 0;
+            $dataBlockFont .= pack('V', $optionsFlags);
+            $dataBlockFont .= pack('V', $fontEscapement);
+            $dataBlockFont .= pack('V', $fontUnderline);
+            $dataBlockFont .= pack('V', 0x00000000);
+            $dataBlockFont .= pack('V', 0x00000000);
+            $dataBlockFont .= pack('VV', 0x00000000, 0x00000000);
+            $dataBlockFont .= pack('v', 0x0001);
+        }
+        /*if ($bFormatAlign === 1) {
+            $blockAlign = Style\CellAlignment::horizontal($conditional->getStyle()->getAlignment());
+            $blockAlign |= Style\CellAlignment::wrap($conditional->getStyle()->getAlignment()) << 3;
+            $blockAlign |= Style\CellAlignment::vertical($conditional->getStyle()->getAlignment()) << 4;
+            $blockAlign |= 0 << 7;
+            $blockRotation = $conditional->getStyle()->getAlignment()->getTextRotation();
+            $blockIndent = $conditional->getStyle()->getAlignment()->getIndent();
+            if ($conditional->getStyle()->getAlignment()->getShrinkToFit() === true) {
+                $blockIndent |= 1 << 4;
+            } else {
+                $blockIndent |= 0 << 4;
+            }
+            $blockIndent |= 0 << 6;
+            $blockIndentRelative = 255;
+            $dataBlockAlign = pack('CCvvv', $blockAlign, $blockRotation, $blockIndent, $blockIndentRelative, 0x0000);
+        }*/
+        if ($bFormatBorder === 1) {
+            $blockLineStyle = Style\CellBorder::style($conditional->getStyle()->getBorders()->getLeft());
+            $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getRight()) << 4;
+            $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getTop()) << 8;
+            $blockLineStyle |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getBottom()) << 12;
+            if ($bBorderLeft !== 0) {
+                $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getLeft()->getColor()->getRgb(), 0);
+                $blockLineStyle |= $colorIdx << 16;
+            }
+            if ($bBorderRight !== 0) {
+                $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getRight()->getColor()->getRgb(), 0);
+                $blockLineStyle |= $colorIdx << 23;
+            }
+            $blockColor = 0;
+            if ($bBorderTop !== 0) {
+                $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getTop()->getColor()->getRgb(), 0);
+                $blockColor |= $colorIdx;
+            }
+            if ($bBorderBottom !== 0) {
+                $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getBottom()->getColor()->getRgb(), 0);
+                $blockColor |= $colorIdx << 7;
+            }
+            /* Excel does not support condtional diagonal borders even for xlsx
+            if ($bBorderDiagTop !== 0 || $bBorderDiagBottom !== 0) {
+                $colorIdx = $this->workbookColorIndex($conditional->getStyle()->getBorders()->getDiagonal()->getColor()->getRgb(), 0);
+                $blockColor |= $colorIdx << 14;
+                $blockColor |= Style\CellBorder::style($conditional->getStyle()->getBorders()->getDiagonal()) << 21;
+                if ($bBorderDiagTop !== 0) {
+                    $blockLineStyle |= 1 << 30;
+                }
+                if ($bBorderDiagBottom !== 0) {
+                    $blockLineStyle |= 1 << 31;
+                }
+            }
+            */
+            $dataBlockBorder = pack('VV', $blockLineStyle, $blockColor);
+        }
+        if ($bFormatFill === 1) {
+            $blockFillPatternStyle = Style\CellFill::style($conditional->getStyle()->getFill());
+            $colorIdxBg = $this->workbookColorIndex($conditional->getStyle()->getFill()->getStartColor()->getRgb(), 0x41);
+            $colorIdxFg = $this->workbookColorIndex($conditional->getStyle()->getFill()->getEndColor()->getRgb(), 0x40);
+            $dataBlockFill = pack('v', $blockFillPatternStyle);
+            $dataBlockFill .= pack('v', $colorIdxFg | ($colorIdxBg << 7));
+        }
+        $data = pack('CCvvVv', $type, $operatorType, $szValue1, $szValue2, $flags, 0x0000);
+        if ($bFormatFont === 1) { // Block Formatting : OK
+            $data .= $dataBlockFont;
+        }
+        if ($bFormatBorder === 1) {
+            $data .= $dataBlockBorder;
+        }
+        if ($bFormatFill === 1) { // Block Formatting : OK
+            $data .= $dataBlockFill;
+        }
+        if ($operand1 !== null) {
+            $data .= $operand1;
+        }
+        if ($operand2 !== null) {
+            $data .= $operand2;
+        }
+        $header = pack('vv', $record, strlen($data));
+        $this->append($header . $data);
+    }
+    /**
+     * Write CFHeader record.
+     *
+     * @param Conditional[] $conditionalStyles
+     */
+    private function writeCFHeader(string $cellCoordinate, array $conditionalStyles): bool
+    {
+        $record = 0x01B0; // Record identifier
+        $length = 0x0016; // Bytes to follow
+        $numColumnMin = null;
+        $numColumnMax = null;
+        $numRowMin = null;
+        $numRowMax = null;
+        $arrConditional = [];
+        foreach ($conditionalStyles as $conditional) {
+            if (!in_array($conditional->getHashCode(), $arrConditional)) {
+                $arrConditional[] = $conditional->getHashCode();
+            }
+            $rangeCoordinates = Coordinate::rangeBoundaries($cellCoordinate);
+            if ($numColumnMin === null || ($numColumnMin > $rangeCoordinates[0][0])) {
+                $numColumnMin = $rangeCoordinates[0][0];
+            }
+            if ($numColumnMax === null || ($numColumnMax < $rangeCoordinates[1][0])) {
+                $numColumnMax = $rangeCoordinates[1][0];
+            }
+            if ($numRowMin === null || ($numRowMin > $rangeCoordinates[0][1])) {
+                $numRowMin = (int) $rangeCoordinates[0][1];
+            }
+            if ($numRowMax === null || ($numRowMax < $rangeCoordinates[1][1])) {
+                $numRowMax = (int) $rangeCoordinates[1][1];
+            }
+        }
+        if (count($arrConditional) === 0) {
+            return false;
+        }
+        $needRedraw = 1;
+        $cellRange = pack('vvvv', $numRowMin - 1, $numRowMax - 1, $numColumnMin - 1, $numColumnMax - 1);
+        $header = pack('vv', $record, $length);
+        $data = pack('vv', count($arrConditional), $needRedraw);
+        $data .= $cellRange;
+        $data .= pack('v', 0x0001);
+        $data .= $cellRange;
+        $this->append($header . $data);
+        return true;
+    }
+    /*private function getDataBlockProtection(Conditional $conditional): int
+    {
+        $dataBlockProtection = 0;
+        if ($conditional->getStyle()->getProtection()->getLocked() == Protection::PROTECTION_PROTECTED) {
+            $dataBlockProtection = 1;
+        }
+        if ($conditional->getStyle()->getProtection()->getHidden() == Protection::PROTECTION_PROTECTED) {
+            $dataBlockProtection = 1 << 1;
+        }
+        return $dataBlockProtection;
+    }*/
+    private function workbookColorIndex(?string $rgb, int $default): int
+    {
+        return (empty($rgb) || $this->writerWorkbook === null) ? $default : $this->writerWorkbook->addColor($rgb, $default);
+    }
+}

--- a/src/PhpSpreadsheet/Writer/Xlsx.php
+++ b//dev/null
@@ -1,564 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Writer;
-use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
-use PhpOffice\PhpSpreadsheet\Calculation\Functions;
-use PhpOffice\PhpSpreadsheet\HashTable;
-use PhpOffice\PhpSpreadsheet\Spreadsheet;
-use PhpOffice\PhpSpreadsheet\Style\Borders;
-use PhpOffice\PhpSpreadsheet\Style\Conditional;
-use PhpOffice\PhpSpreadsheet\Style\Fill;
-use PhpOffice\PhpSpreadsheet\Style\Font;
-use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
-use PhpOffice\PhpSpreadsheet\Worksheet\BaseDrawing;
-use PhpOffice\PhpSpreadsheet\Worksheet\Drawing as WorksheetDrawing;
-use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
-use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Chart;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Comments;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\ContentTypes;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\DocProps;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Drawing;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Rels;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\RelsRibbon;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\RelsVBA;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\StringTable;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Style;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Table;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Theme;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Workbook;
-use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Worksheet;
-use ZipArchive;
-use ZipStream\Exception\OverflowException;
-use ZipStream\ZipStream;
-class Xlsx extends BaseWriter
-{
-    /**
-     * Office2003 compatibility.
-     */
-    private bool $office2003compatibility = false;
-    /**
-     * Private Spreadsheet.
-     */
-    private Spreadsheet $spreadSheet;
-    /**
-     * Private string table.
-     *
-     * @var string[]
-     */
-    private array $stringTable = [];
-    /**
-     * Private unique Conditional HashTable.
-     *
-     * @var HashTable<Conditional>
-     */
-    private HashTable $stylesConditionalHashTable;
-    /**
-     * Private unique Style HashTable.
-     *
-     * @var HashTable<\PhpOffice\PhpSpreadsheet\Style\Style>
-     */
-    private HashTable $styleHashTable;
-    /**
-     * Private unique Fill HashTable.
-     *
-     * @var HashTable<Fill>
-     */
-    private HashTable $fillHashTable;
-    /**
-     * Private unique \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
-     *
-     * @var HashTable<Font>
-     */
-    private HashTable $fontHashTable;
-    /**
-     * Private unique Borders HashTable.
-     *
-     * @var HashTable<Borders>
-     */
-    private HashTable $bordersHashTable;
-    /**
-     * Private unique NumberFormat HashTable.
-     *
-     * @var HashTable<NumberFormat>
-     */
-    private HashTable $numFmtHashTable;
-    /**
-     * Private unique \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
-     *
-     * @var HashTable<BaseDrawing>
-     */
-    private HashTable $drawingHashTable;
-    /**
-     * Private handle for zip stream.
-     */
-    private ZipStream $zip;
-    private Chart $writerPartChart;
-    private Comments $writerPartComments;
-    private ContentTypes $writerPartContentTypes;
-    private DocProps $writerPartDocProps;
-    private Drawing $writerPartDrawing;
-    private Rels $writerPartRels;
-    private RelsRibbon $writerPartRelsRibbon;
-    private RelsVBA $writerPartRelsVBA;
-    private StringTable $writerPartStringTable;
-    private Style $writerPartStyle;
-    private Theme $writerPartTheme;
-    private Table $writerPartTable;
-    private Workbook $writerPartWorkbook;
-    private Worksheet $writerPartWorksheet;
-    private bool $explicitStyle0 = false;
-    /**
-     * Create a new Xlsx Writer.
-     */
-    public function __construct(Spreadsheet $spreadsheet)
-    {
-        $this->setSpreadsheet($spreadsheet);
-        $this->writerPartChart = new Chart($this);
-        $this->writerPartComments = new Comments($this);
-        $this->writerPartContentTypes = new ContentTypes($this);
-        $this->writerPartDocProps = new DocProps($this);
-        $this->writerPartDrawing = new Drawing($this);
-        $this->writerPartRels = new Rels($this);
-        $this->writerPartRelsRibbon = new RelsRibbon($this);
-        $this->writerPartRelsVBA = new RelsVBA($this);
-        $this->writerPartStringTable = new StringTable($this);
-        $this->writerPartStyle = new Style($this);
-        $this->writerPartTheme = new Theme($this);
-        $this->writerPartTable = new Table($this);
-        $this->writerPartWorkbook = new Workbook($this);
-        $this->writerPartWorksheet = new Worksheet($this);
-        $this->bordersHashTable = new HashTable();
-        $this->drawingHashTable = new HashTable();
-        $this->fillHashTable = new HashTable();
-        $this->fontHashTable = new HashTable();
-        $this->numFmtHashTable = new HashTable();
-        $this->styleHashTable = new HashTable();
-        $this->stylesConditionalHashTable = new HashTable();
-    }
-    public function getWriterPartChart(): Chart
-    {
-        return $this->writerPartChart;
-    }
-    public function getWriterPartComments(): Comments
-    {
-        return $this->writerPartComments;
-    }
-    public function getWriterPartContentTypes(): ContentTypes
-    {
-        return $this->writerPartContentTypes;
-    }
-    public function getWriterPartDocProps(): DocProps
-    {
-        return $this->writerPartDocProps;
-    }
-    public function getWriterPartDrawing(): Drawing
-    {
-        return $this->writerPartDrawing;
-    }
-    public function getWriterPartRels(): Rels
-    {
-        return $this->writerPartRels;
-    }
-    public function getWriterPartRelsRibbon(): RelsRibbon
-    {
-        return $this->writerPartRelsRibbon;
-    }
-    public function getWriterPartRelsVBA(): RelsVBA
-    {
-        return $this->writerPartRelsVBA;
-    }
-    public function getWriterPartStringTable(): StringTable
-    {
-        return $this->writerPartStringTable;
-    }
-    public function getWriterPartStyle(): Style
-    {
-        return $this->writerPartStyle;
-    }
-    public function getWriterPartTheme(): Theme
-    {
-        return $this->writerPartTheme;
-    }
-    public function getWriterPartTable(): Table
-    {
-        return $this->writerPartTable;
-    }
-    public function getWriterPartWorkbook(): Workbook
-    {
-        return $this->writerPartWorkbook;
-    }
-    public function getWriterPartWorksheet(): Worksheet
-    {
-        return $this->writerPartWorksheet;
-    }
-    /**
-     * Save PhpSpreadsheet to file.
-     *
-     * @param resource|string $filename
-     */
-    public function save($filename, int $flags = 0): void
-    {
-        $this->processFlags($flags);
-        $this->pathNames = [];
-        $this->spreadSheet->garbageCollect();
-        $saveDebugLog = Calculation::getInstance($this->spreadSheet)->getDebugLog()->getWriteDebugLog();
-        Calculation::getInstance($this->spreadSheet)->getDebugLog()->setWriteDebugLog(false);
-        $saveDateReturnType = Functions::getReturnDateType();
-        Functions::setReturnDateType(Functions::RETURNDATE_EXCEL);
-        $this->stringTable = [];
-        for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
-            $this->stringTable = $this->getWriterPartStringTable()->createStringTable($this->spreadSheet->getSheet($i), $this->stringTable);
-        }
-        $this->styleHashTable->addFromSource($this->getWriterPartStyle()->allStyles($this->spreadSheet));
-        $this->stylesConditionalHashTable->addFromSource($this->getWriterPartStyle()->allConditionalStyles($this->spreadSheet));
-        $this->fillHashTable->addFromSource($this->getWriterPartStyle()->allFills($this->spreadSheet));
-        $this->fontHashTable->addFromSource($this->getWriterPartStyle()->allFonts($this->spreadSheet));
-        $this->bordersHashTable->addFromSource($this->getWriterPartStyle()->allBorders($this->spreadSheet));
-        $this->numFmtHashTable->addFromSource($this->getWriterPartStyle()->allNumberFormats($this->spreadSheet));
-        $this->drawingHashTable->addFromSource($this->getWriterPartDrawing()->allDrawings($this->spreadSheet));
-        $zipContent = [];
-        $zipContent['[Content_Types].xml'] = $this->getWriterPartContentTypes()->writeContentTypes($this->spreadSheet, $this->includeCharts);
-        if ($this->spreadSheet->hasMacros()) {
-            $macrosCode = $this->spreadSheet->getMacrosCode();
-            if ($macrosCode !== null) {
-                $zipContent['xl/vbaProject.bin'] = $macrosCode; //allways in 'xl', allways named vbaProject.bin
-                if ($this->spreadSheet->hasMacrosCertificate()) {
-                    $zipContent['xl/vbaProjectSignature.bin'] = $this->spreadSheet->getMacrosCertificate();
-                    $zipContent['xl/_rels/vbaProject.bin.rels'] = $this->getWriterPartRelsVBA()->writeVBARelationships();
-                }
-            }
-        }
-        if ($this->spreadSheet->hasRibbon()) {
-            $tmpRibbonTarget = $this->spreadSheet->getRibbonXMLData('target');
-            $tmpRibbonTarget = is_string($tmpRibbonTarget) ? $tmpRibbonTarget : '';
-            $zipContent[$tmpRibbonTarget] = $this->spreadSheet->getRibbonXMLData('data');
-            if ($this->spreadSheet->hasRibbonBinObjects()) {
-                $tmpRootPath = dirname($tmpRibbonTarget) . '/';
-                $ribbonBinObjects = $this->spreadSheet->getRibbonBinObjects('data'); //the files to write
-                if (is_array($ribbonBinObjects)) {
-                    foreach ($ribbonBinObjects as $aPath => $aContent) {
-                        $zipContent[$tmpRootPath . $aPath] = $aContent;
-                    }
-                }
-                $zipContent[$tmpRootPath . '_rels/' . basename($tmpRibbonTarget) . '.rels'] = $this->getWriterPartRelsRibbon()->writeRibbonRelationships($this->spreadSheet);
-            }
-        }
-        $zipContent['_rels/.rels'] = $this->getWriterPartRels()->writeRelationships($this->spreadSheet);
-        $zipContent['xl/_rels/workbook.xml.rels'] = $this->getWriterPartRels()->writeWorkbookRelationships($this->spreadSheet);
-        $zipContent['docProps/app.xml'] = $this->getWriterPartDocProps()->writeDocPropsApp($this->spreadSheet);
-        $zipContent['docProps/core.xml'] = $this->getWriterPartDocProps()->writeDocPropsCore($this->spreadSheet);
-        $customPropertiesPart = $this->getWriterPartDocProps()->writeDocPropsCustom($this->spreadSheet);
-        if ($customPropertiesPart !== null) {
-            $zipContent['docProps/custom.xml'] = $customPropertiesPart;
-        }
-        $zipContent['xl/theme/theme1.xml'] = $this->getWriterPartTheme()->writeTheme($this->spreadSheet);
-        $zipContent['xl/sharedStrings.xml'] = $this->getWriterPartStringTable()->writeStringTable($this->stringTable);
-        $zipContent['xl/styles.xml'] = $this->getWriterPartStyle()->writeStyles($this->spreadSheet);
-        $zipContent['xl/workbook.xml'] = $this->getWriterPartWorkbook()->writeWorkbook($this->spreadSheet, $this->preCalculateFormulas);
-        $chartCount = 0;
-        for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
-            $zipContent['xl/worksheets/sheet' . ($i + 1) . '.xml'] = $this->getWriterPartWorksheet()->writeWorksheet($this->spreadSheet->getSheet($i), $this->stringTable, $this->includeCharts);
-            if ($this->includeCharts) {
-                $charts = $this->spreadSheet->getSheet($i)->getChartCollection();
-                if (count($charts) > 0) {
-                    foreach ($charts as $chart) {
-                        $zipContent['xl/charts/chart' . ($chartCount + 1) . '.xml'] = $this->getWriterPartChart()->writeChart($chart, $this->preCalculateFormulas);
-                        ++$chartCount;
-                    }
-                }
-            }
-        }
-        $chartRef1 = 0;
-        $tableRef1 = 1;
-        for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
-            $zipContent['xl/worksheets/_rels/sheet' . ($i + 1) . '.xml.rels'] = $this->getWriterPartRels()->writeWorksheetRelationships($this->spreadSheet->getSheet($i), ($i + 1), $this->includeCharts, $tableRef1, $zipContent);
-            $sheetCodeName = $this->spreadSheet->getSheet($i)->getCodeName();
-            $unparsedLoadedData = $this->spreadSheet->getUnparsedLoadedData();
-            if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['ctrlProps'])) {
-                foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['ctrlProps'] as $ctrlProp) {
-                    $zipContent[$ctrlProp['filePath']] = $ctrlProp['content'];
-                }
-            }
-            if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['printerSettings'])) {
-                foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['printerSettings'] as $ctrlProp) {
-                    $zipContent[$ctrlProp['filePath']] = $ctrlProp['content'];
-                }
-            }
-            $drawings = $this->spreadSheet->getSheet($i)->getDrawingCollection();
-            $drawingCount = count($drawings);
-            if ($this->includeCharts) {
-                $chartCount = $this->spreadSheet->getSheet($i)->getChartCount();
-            }
-            if (($drawingCount > 0) || ($chartCount > 0)) {
-                $zipContent['xl/drawings/_rels/drawing' . ($i + 1) . '.xml.rels'] = $this->getWriterPartRels()->writeDrawingRelationships($this->spreadSheet->getSheet($i), $chartRef1, $this->includeCharts);
-                $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $this->getWriterPartDrawing()->writeDrawings($this->spreadSheet->getSheet($i), $this->includeCharts);
-            } elseif (isset($unparsedLoadedData['sheets'][$sheetCodeName]['drawingAlternateContents'])) {
-                $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $this->getWriterPartDrawing()->writeDrawings($this->spreadSheet->getSheet($i), $this->includeCharts);
-            }
-            if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['Drawings']) && !isset($zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'])) {
-                foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['Drawings'] as $relId => $drawingXml) {
-                    $drawingFile = array_search($relId, $unparsedLoadedData['sheets'][$sheetCodeName]['drawingOriginalIds']);
-                    if ($drawingFile !== false) {
-                        $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $drawingXml;
-                    }
-                }
-            }
-            if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['drawingOriginalIds']) && !isset($zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'])) {
-                $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = '<xml></xml>';
-            }
-            $legacy = $unparsedLoadedData['sheets'][$this->spreadSheet->getSheet($i)->getCodeName()]['legacyDrawing'] ?? null;
-            if (count($this->spreadSheet->getSheet($i)->getComments()) > 0 || $legacy !== null) {
-                $zipContent['xl/drawings/_rels/vmlDrawing' . ($i + 1) . '.vml.rels'] = $this->getWriterPartRels()->writeVMLDrawingRelationships($this->spreadSheet->getSheet($i));
-                $zipContent['xl/drawings/vmlDrawing' . ($i + 1) . '.vml'] = $legacy ?? $this->getWriterPartComments()->writeVMLComments($this->spreadSheet->getSheet($i));
-            }
-            if (count($this->spreadSheet->getSheet($i)->getComments()) > 0) {
-                $zipContent['xl/comments' . ($i + 1) . '.xml'] = $this->getWriterPartComments()->writeComments($this->spreadSheet->getSheet($i));
-                foreach ($this->spreadSheet->getSheet($i)->getComments() as $comment) {
-                    if ($comment->hasBackgroundImage()) {
-                        $image = $comment->getBackgroundImage();
-                        $zipContent['xl/media/' . $image->getMediaFilename()] = $this->processDrawing($image);
-                    }
-                }
-            }
-            if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['vmlDrawings'])) {
-                foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['vmlDrawings'] as $vmlDrawing) {
-                    if (!isset($zipContent[$vmlDrawing['filePath']])) {
-                        $zipContent[$vmlDrawing['filePath']] = $vmlDrawing['content'];
-                    }
-                }
-            }
-            if (count($this->spreadSheet->getSheet($i)->getHeaderFooter()->getImages()) > 0) {
-                $zipContent['xl/drawings/vmlDrawingHF' . ($i + 1) . '.vml'] = $this->getWriterPartDrawing()->writeVMLHeaderFooterImages($this->spreadSheet->getSheet($i));
-                $zipContent['xl/drawings/_rels/vmlDrawingHF' . ($i + 1) . '.vml.rels'] = $this->getWriterPartRels()->writeHeaderFooterDrawingRelationships($this->spreadSheet->getSheet($i));
-                foreach ($this->spreadSheet->getSheet($i)->getHeaderFooter()->getImages() as $image) {
-                    if ($image->getPath() !== '') {
-                        $zipContent['xl/media/' . $image->getIndexedFilename()] = file_get_contents($image->getPath());
-                    }
-                }
-            }
-            $tables = $this->spreadSheet->getSheet($i)->getTableCollection();
-            foreach ($tables as $table) {
-                $zipContent['xl/tables/table' . $tableRef1 . '.xml'] = $this->getWriterPartTable()->writeTable($table, $tableRef1++);
-            }
-        }
-        for ($i = 0; $i < $this->getDrawingHashTable()->count(); ++$i) {
-            if ($this->getDrawingHashTable()->getByIndex($i) instanceof WorksheetDrawing) {
-                $imageContents = null;
-                $imagePath = $this->getDrawingHashTable()->getByIndex($i)->getPath();
-                if ($imagePath === '') {
-                    continue;
-                }
-                if (str_contains($imagePath, 'zip://')) {
-                    $imagePath = substr($imagePath, 6);
-                    $imagePathSplitted = explode('#', $imagePath);
-                    $imageZip = new ZipArchive();
-                    $imageZip->open($imagePathSplitted[0]);
-                    $imageContents = $imageZip->getFromName($imagePathSplitted[1]);
-                    $imageZip->close();
-                    unset($imageZip);
-                } else {
-                    $imageContents = file_get_contents($imagePath);
-                }
-                $zipContent['xl/media/' . $this->getDrawingHashTable()->getByIndex($i)->getIndexedFilename()] = $imageContents;
-            } elseif ($this->getDrawingHashTable()->getByIndex($i) instanceof MemoryDrawing) {
-                ob_start();
-                /** @var callable $callable */
-                $callable = $this->getDrawingHashTable()->getByIndex($i)->getRenderingFunction();
-                call_user_func(
-                    $callable,
-                    $this->getDrawingHashTable()->getByIndex($i)->getImageResource()
-                );
-                $imageContents = ob_get_contents();
-                ob_end_clean();
-                $zipContent['xl/media/' . $this->getDrawingHashTable()->getByIndex($i)->getIndexedFilename()] = $imageContents;
-            }
-        }
-        Functions::setReturnDateType($saveDateReturnType);
-        Calculation::getInstance($this->spreadSheet)->getDebugLog()->setWriteDebugLog($saveDebugLog);
-        $this->openFileHandle($filename);
-        $this->zip = ZipStream0::newZipStream($this->fileHandle);
-        $this->addZipFiles($zipContent);
-        try {
-            $this->zip->finish();
-        } catch (OverflowException) {
-            throw new WriterException('Could not close resource.');
-        }
-        $this->maybeCloseFileHandle();
-    }
-    /**
-     * Get Spreadsheet object.
-     */
-    public function getSpreadsheet(): Spreadsheet
-    {
-        return $this->spreadSheet;
-    }
-    /**
-     * Set Spreadsheet object.
-     *
-     * @param Spreadsheet $spreadsheet PhpSpreadsheet object
-     *
-     * @return $this
-     */
-    public function setSpreadsheet(Spreadsheet $spreadsheet): static
-    {
-        $this->spreadSheet = $spreadsheet;
-        return $this;
-    }
-    /**
-     * Get string table.
-     *
-     * @return string[]
-     */
-    public function getStringTable(): array
-    {
-        return $this->stringTable;
-    }
-    /**
-     * Get Style HashTable.
-     *
-     * @return HashTable<\PhpOffice\PhpSpreadsheet\Style\Style>
-     */
-    public function getStyleHashTable(): HashTable
-    {
-        return $this->styleHashTable;
-    }
-    /**
-     * Get Conditional HashTable.
-     *
-     * @return HashTable<Conditional>
-     */
-    public function getStylesConditionalHashTable(): HashTable
-    {
-        return $this->stylesConditionalHashTable;
-    }
-    /**
-     * Get Fill HashTable.
-     *
-     * @return HashTable<Fill>
-     */
-    public function getFillHashTable(): HashTable
-    {
-        return $this->fillHashTable;
-    }
-    /**
-     * Get \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
-     *
-     * @return HashTable<Font>
-     */
-    public function getFontHashTable(): HashTable
-    {
-        return $this->fontHashTable;
-    }
-    /**
-     * Get Borders HashTable.
-     *
-     * @return HashTable<Borders>
-     */
-    public function getBordersHashTable(): HashTable
-    {
-        return $this->bordersHashTable;
-    }
-    /**
-     * Get NumberFormat HashTable.
-     *
-     * @return HashTable<NumberFormat>
-     */
-    public function getNumFmtHashTable(): HashTable
-    {
-        return $this->numFmtHashTable;
-    }
-    /**
-     * Get \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
-     *
-     * @return HashTable<BaseDrawing>
-     */
-    public function getDrawingHashTable(): HashTable
-    {
-        return $this->drawingHashTable;
-    }
-    /**
-     * Get Office2003 compatibility.
-     */
-    public function getOffice2003Compatibility(): bool
-    {
-        return $this->office2003compatibility;
-    }
-    /**
-     * Set Office2003 compatibility.
-     *
-     * @param bool $office2003compatibility Office2003 compatibility?
-     *
-     * @return $this
-     */
-    public function setOffice2003Compatibility(bool $office2003compatibility): static
-    {
-        $this->office2003compatibility = $office2003compatibility;
-        return $this;
-    }
-    private array $pathNames = [];
-    private function addZipFile(string $path, string $content): void
-    {
-        if (!in_array($path, $this->pathNames)) {
-            $this->pathNames[] = $path;
-            $this->zip->addFile($path, $content);
-        }
-    }
-    private function addZipFiles(array $zipContent): void
-    {
-        foreach ($zipContent as $path => $content) {
-            $this->addZipFile($path, $content);
-        }
-    }
-    private function processDrawing(WorksheetDrawing $drawing): string|null|false
-    {
-        $data = null;
-        $filename = $drawing->getPath();
-        if ($filename === '') {
-            return null;
-        }
-        $imageData = getimagesize($filename);
-        if (!empty($imageData)) {
-            switch ($imageData[2]) {
-                case 1: // GIF, not supported by BIFF8, we convert to PNG
-                    $image = imagecreatefromgif($filename);
-                    if ($image !== false) {
-                        ob_start();
-                        imagepng($image);
-                        $data = ob_get_contents();
-                        ob_end_clean();
-                    }
-                    break;
-                case 2: // JPEG
-                    $data = file_get_contents($filename);
-                    break;
-                case 3: // PNG
-                    $data = file_get_contents($filename);
-                    break;
-                case 6: // Windows DIB (BMP), we convert to PNG
-                    $image = imagecreatefrombmp($filename);
-                    if ($image !== false) {
-                        ob_start();
-                        imagepng($image);
-                        $data = ob_get_contents();
-                        ob_end_clean();
-                    }
-                    break;
-            }
-        }
-        return $data;
-    }
-    public function getExplicitStyle0(): bool
-    {
-        return $this->explicitStyle0;
-    }
-    /**
-     * This may be useful if non-default Alignment is part of default style
-     * and you think you might want to open the spreadsheet
-     * with LibreOffice or Gnumeric.
-     */
-    public function setExplicitStyle0(bool $explicitStyle0): self
-    {
-        $this->explicitStyle0 = $explicitStyle0;
-        return $this;
-    }
-}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xlsx/Comments.php
@@ -0,0 +1,172 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Comment;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+use PhpOffice\PhpSpreadsheet\Style\Alignment;
+class Comments extends WriterPart
+{
+    private const VALID_HORIZONTAL_ALIGNMENT = [
+        Alignment::HORIZONTAL_CENTER,
+        Alignment::HORIZONTAL_DISTRIBUTED,
+        Alignment::HORIZONTAL_JUSTIFY,
+        Alignment::HORIZONTAL_LEFT,
+        Alignment::HORIZONTAL_RIGHT,
+    ];
+    /**
+     * Write comments to XML format.
+     *
+     * @return string XML Output
+     */
+    public function writeComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet): string
+    {
+        $objWriter = null;
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
+        $comments = $worksheet->getComments();
+        $authors = [];
+        $authorId = 0;
+        foreach ($comments as $comment) {
+            if (!isset($authors[$comment->getAuthor()])) {
+                $authors[$comment->getAuthor()] = $authorId++;
+            }
+        }
+        $objWriter->startElement('comments');
+        $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
+        $objWriter->startElement('authors');
+        foreach ($authors as $author => $index) {
+            $objWriter->writeElement('author', $author);
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('commentList');
+        foreach ($comments as $key => $value) {
+            $this->writeComment($objWriter, $key, $value, $authors);
+        }
+        $objWriter->endElement();
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    /**
+     * Write comment to XML format.
+     *
+     * @param string $cellReference Cell reference
+     * @param Comment $comment Comment
+     * @param array $authors Array of authors
+     */
+    private function writeComment(XMLWriter $objWriter, string $cellReference, Comment $comment, array $authors): void
+    {
+        $objWriter->startElement('comment');
+        $objWriter->writeAttribute('ref', $cellReference);
+        $objWriter->writeAttribute('authorId', $authors[$comment->getAuthor()]);
+        $objWriter->startElement('text');
+        $this->getParentWriter()->getWriterPartstringtable()->writeRichText($objWriter, $comment->getText());
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+    /**
+     * Write VML comments to XML format.
+     *
+     * @return string XML Output
+     */
+    public function writeVMLComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet): string
+    {
+        $objWriter = null;
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
+        $comments = $worksheet->getComments();
+        $objWriter->startElement('xml');
+        $objWriter->writeAttribute('xmlns:v', Namespaces::URN_VML);
+        $objWriter->writeAttribute('xmlns:o', Namespaces::URN_MSOFFICE);
+        $objWriter->writeAttribute('xmlns:x', Namespaces::URN_EXCEL);
+        $objWriter->startElement('o:shapelayout');
+        $objWriter->writeAttribute('v:ext', 'edit');
+        $objWriter->startElement('o:idmap');
+        $objWriter->writeAttribute('v:ext', 'edit');
+        $objWriter->writeAttribute('data', '1');
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->startElement('v:shapetype');
+        $objWriter->writeAttribute('id', '_x0000_t202');
+        $objWriter->writeAttribute('coordsize', '21600,21600');
+        $objWriter->writeAttribute('o:spt', '202');
+        $objWriter->writeAttribute('path', 'm,l,21600r21600,l21600,xe');
+        $objWriter->startElement('v:stroke');
+        $objWriter->writeAttribute('joinstyle', 'miter');
+        $objWriter->endElement();
+        $objWriter->startElement('v:path');
+        $objWriter->writeAttribute('gradientshapeok', 't');
+        $objWriter->writeAttribute('o:connecttype', 'rect');
+        $objWriter->endElement();
+        $objWriter->endElement();
+        foreach ($comments as $key => $value) {
+            $this->writeVMLComment($objWriter, $key, $value);
+        }
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    /**
+     * Write VML comment to XML format.
+     *
+     * @param string $cellReference Cell reference, eg: 'A1'
+     * @param Comment $comment Comment
+     */
+    private function writeVMLComment(XMLWriter $objWriter, string $cellReference, Comment $comment): void
+    {
+        [$column, $row] = Coordinate::indexesFromString($cellReference);
+        $id = 1024 + $column + $row;
+        $id = substr("$id", 0, 4);
+        $objWriter->startElement('v:shape');
+        $objWriter->writeAttribute('id', '_x0000_s' . $id);
+        $objWriter->writeAttribute('type', '#_x0000_t202');
+        $objWriter->writeAttribute('style', 'position:absolute;margin-left:' . $comment->getMarginLeft() . ';margin-top:' . $comment->getMarginTop() . ';width:' . $comment->getWidth() . ';height:' . $comment->getHeight() . ';z-index:1;visibility:' . ($comment->getVisible() ? 'visible' : 'hidden'));
+        $objWriter->writeAttribute('fillcolor', '#' . $comment->getFillColor()->getRGB());
+        $objWriter->writeAttribute('o:insetmode', 'auto');
+        $objWriter->startElement('v:fill');
+        $objWriter->writeAttribute('color2', '#' . $comment->getFillColor()->getRGB());
+        if ($comment->hasBackgroundImage()) {
+            $bgImage = $comment->getBackgroundImage();
+            $objWriter->writeAttribute('o:relid', 'rId' . $bgImage->getImageIndex());
+            $objWriter->writeAttribute('o:title', $bgImage->getName());
+            $objWriter->writeAttribute('type', 'frame');
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('v:shadow');
+        $objWriter->writeAttribute('on', 't');
+        $objWriter->writeAttribute('color', 'black');
+        $objWriter->writeAttribute('obscured', 't');
+        $objWriter->endElement();
+        $objWriter->startElement('v:path');
+        $objWriter->writeAttribute('o:connecttype', 'none');
+        $objWriter->endElement();
+        $textBoxArray = [Comment::TEXTBOX_DIRECTION_RTL => 'rtl', Comment::TEXTBOX_DIRECTION_LTR => 'ltr'];
+        $textboxRtl = $textBoxArray[strtolower($comment->getTextBoxDirection())] ?? 'auto';
+        $objWriter->startElement('v:textbox');
+        $objWriter->writeAttribute('style', "mso-direction-alt:$textboxRtl");
+        $objWriter->startElement('div');
+        $objWriter->writeAttribute('style', ($textboxRtl === 'rtl' ? 'text-align:right;direction:rtl' : 'text-align:left'));
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->startElement('x:ClientData');
+        $objWriter->writeAttribute('ObjectType', 'Note');
+        $objWriter->writeElement('x:MoveWithCells', '');
+        $objWriter->writeElement('x:SizeWithCells', '');
+        $objWriter->writeElement('x:AutoFill', 'False');
+        $alignment = strtolower($comment->getAlignment());
+        if (in_array($alignment, self::VALID_HORIZONTAL_ALIGNMENT, true)) {
+            $objWriter->writeElement('x:TextHAlign', ucfirst($alignment));
+        }
+        $objWriter->writeElement('x:Row', (string) ($row - 1));
+        $objWriter->writeElement('x:Column', (string) ($column - 1));
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+}

--- a/src/PhpSpreadsheet/Writer/Xlsx/ContentTypes.php
+++ b//dev/null
@@ -1,207 +0,0 @@
-<?php
-namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
-use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
-use PhpOffice\PhpSpreadsheet\Shared\File;
-use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
-use PhpOffice\PhpSpreadsheet\Spreadsheet;
-use PhpOffice\PhpSpreadsheet\Worksheet\Drawing as WorksheetDrawing;
-use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
-use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
-class ContentTypes extends WriterPart
-{
-    /**
-     * Write content types to XML format.
-     *
-     * @param bool $includeCharts Flag indicating if we should include drawing details for charts
-     *
-     * @return string XML Output
-     */
-    public function writeContentTypes(Spreadsheet $spreadsheet, bool $includeCharts = false): string
-    {
-        $objWriter = null;
-        if ($this->getParentWriter()->getUseDiskCaching()) {
-            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
-        } else {
-            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
-        }
-        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
-        $objWriter->startElement('Types');
-        $objWriter->writeAttribute('xmlns', Namespaces::CONTENT_TYPES);
-        $this->writeOverrideContentType($objWriter, '/xl/theme/theme1.xml', 'application/vnd.openxmlformats-officedocument.theme+xml');
-        $this->writeOverrideContentType($objWriter, '/xl/styles.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml');
-        $this->writeDefaultContentType($objWriter, 'rels', 'application/vnd.openxmlformats-package.relationships+xml');
-        $this->writeDefaultContentType($objWriter, 'xml', 'application/xml');
-        $this->writeDefaultContentType($objWriter, 'vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing');
-        if ($spreadsheet->hasMacros()) { //Macros in workbook ?
-            $this->writeOverrideContentType($objWriter, '/xl/workbook.xml', 'application/vnd.ms-excel.sheet.macroEnabled.main+xml');
-            $this->writeOverrideContentType($objWriter, '/xl/vbaProject.bin', 'application/vnd.ms-office.vbaProject');
-            if ($spreadsheet->hasMacrosCertificate()) {
-                $this->writeOverrideContentType($objWriter, '/xl/vbaProjectSignature.bin', 'application/vnd.ms-office.vbaProjectSignature');
-            }
-        } else {
-            $this->writeOverrideContentType($objWriter, '/xl/workbook.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml');
-        }
-        $this->writeOverrideContentType($objWriter, '/docProps/app.xml', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
-        $this->writeOverrideContentType($objWriter, '/docProps/core.xml', 'application/vnd.openxmlformats-package.core-properties+xml');
-        $customPropertyList = $spreadsheet->getProperties()->getCustomProperties();
-        if (!empty($customPropertyList)) {
-            $this->writeOverrideContentType($objWriter, '/docProps/custom.xml', 'application/vnd.openxmlformats-officedocument.custom-properties+xml');
-        }
-        $sheetCount = $spreadsheet->getSheetCount();
-        for ($i = 0; $i < $sheetCount; ++$i) {
-            $this->writeOverrideContentType($objWriter, '/xl/worksheets/sheet' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');
-        }
-        $this->writeOverrideContentType($objWriter, '/xl/sharedStrings.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml');
-        $table = 1;
-        for ($i = 0; $i < $sheetCount; ++$i) {
-            $tableCount = $spreadsheet->getSheet($i)->getTableCollection()->count();
-            for ($t = 1; $t <= $tableCount; ++$t) {
-                $this->writeOverrideContentType($objWriter, '/xl/tables/table' . $table++ . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml');
-            }
-        }
-        $unparsedLoadedData = $spreadsheet->getUnparsedLoadedData();
-        $chart = 1;
-        for ($i = 0; $i < $sheetCount; ++$i) {
-            $drawings = $spreadsheet->getSheet($i)->getDrawingCollection();
-            $drawingCount = count($drawings);
-            $chartCount = ($includeCharts) ? $spreadsheet->getSheet($i)->getChartCount() : 0;
-            $hasUnparsedDrawing = isset($unparsedLoadedData['sheets'][$spreadsheet->getSheet($i)->getCodeName()]['drawingOriginalIds']);
-            if (($drawingCount > 0) || ($chartCount > 0) || $hasUnparsedDrawing) {
-                $this->writeOverrideContentType($objWriter, '/xl/drawings/drawing' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.drawing+xml');
-            }
-            if ($chartCount > 0) {
-                for ($c = 0; $c < $chartCount; ++$c) {
-                    $this->writeOverrideContentType($objWriter, '/xl/charts/chart' . $chart++ . '.xml', 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml');
-                }
-            }
-        }
-        for ($i = 0; $i < $sheetCount; ++$i) {
-            if (count($spreadsheet->getSheet($i)->getComments()) > 0) {
-                $this->writeOverrideContentType($objWriter, '/xl/comments' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml');
-            }
-        }
-        $aMediaContentTypes = [];
-        $mediaCount = $this->getParentWriter()->getDrawingHashTable()->count();
-        for ($i = 0; $i < $mediaCount; ++$i) {
-            $extension = '';
-            $mimeType = '';
-            $drawing = $this->getParentWriter()->getDrawingHashTable()->getByIndex($i);
-            if ($drawing instanceof WorksheetDrawing && $drawing->getPath() !== '') {
-                $extension = strtolower($drawing->getExtension());
-                if ($drawing->getIsUrl()) {
-                    $mimeType = image_type_to_mime_type($drawing->getType());
-                } else {
-                    $mimeType = $this->getImageMimeType($drawing->getPath());
-                }
-            } elseif ($drawing instanceof MemoryDrawing) {
-                $extension = strtolower($drawing->getMimeType());
-                $extension = explode('/', $extension);
-                $extension = $extension[1];
-                $mimeType = $drawing->getMimeType();
-            }
-            if ($mimeType !== '' && !isset($aMediaContentTypes[$extension])) {
-                $aMediaContentTypes[$extension] = $mimeType;
-                $this->writeDefaultContentType($objWriter, $extension, $mimeType);
-            }
-        }
-        if ($spreadsheet->hasRibbonBinObjects()) {
-            $tabRibbonTypes = array_diff($spreadsheet->getRibbonBinObjects('types') ?? [], array_keys($aMediaContentTypes));
-            foreach ($tabRibbonTypes as $aRibbonType) {
-                $mimeType = 'image/.' . $aRibbonType; //we wrote $mimeType like customUI Editor
-                $this->writeDefaultContentType($objWriter, $aRibbonType, $mimeType);
-            }
-        }
-        $sheetCount = $spreadsheet->getSheetCount();
-        for ($i = 0; $i < $sheetCount; ++$i) {
-            if (count($spreadsheet->getSheet($i)->getHeaderFooter()->getImages()) > 0) {
-                foreach ($spreadsheet->getSheet($i)->getHeaderFooter()->getImages() as $image) {
-                    if ($image->getPath() !== '' && !isset($aMediaContentTypes[strtolower($image->getExtension())])) {
-                        $aMediaContentTypes[strtolower($image->getExtension())] = $this->getImageMimeType($image->getPath());
-                        $this->writeDefaultContentType($objWriter, strtolower($image->getExtension()), $aMediaContentTypes[strtolower($image->getExtension())]);
-                    }
-                }
-            }
-            if (count($spreadsheet->getSheet($i)->getComments()) > 0) {
-                foreach ($spreadsheet->getSheet($i)->getComments() as $comment) {
-                    if (!$comment->hasBackgroundImage()) {
-                        continue;
-                    }
-                    $bgImage = $comment->getBackgroundImage();
-                    $bgImageExtentionKey = strtolower($bgImage->getImageFileExtensionForSave(false));
-                    if (!isset($aMediaContentTypes[$bgImageExtentionKey])) {
-                        $aMediaContentTypes[$bgImageExtentionKey] = $bgImage->getImageMimeType();
-                        $this->writeDefaultContentType($objWriter, $bgImageExtentionKey, $aMediaContentTypes[$bgImageExtentionKey]);
-                    }
-                }
-            }
-            $bgImage = $spreadsheet->getSheet($i)->getBackgroundImage();
-            $mimeType = $spreadsheet->getSheet($i)->getBackgroundMime();
-            $extension = $spreadsheet->getSheet($i)->getBackgroundExtension();
-            if ($bgImage !== '' && !isset($aMediaContentTypes[$mimeType])) {
-                $this->writeDefaultContentType($objWriter, $extension, $mimeType);
-            }
-        }
-        if (isset($unparsedLoadedData['default_content_types'])) {
-            foreach ($unparsedLoadedData['default_content_types'] as $extName => $contentType) {
-                $this->writeDefaultContentType($objWriter, $extName, $contentType);
-            }
-        }
-        if (isset($unparsedLoadedData['override_content_types'])) {
-            foreach ($unparsedLoadedData['override_content_types'] as $partName => $overrideType) {
-                $this->writeOverrideContentType($objWriter, $partName, $overrideType);
-            }
-        }
-        $objWriter->endElement();
-        return $objWriter->getData();
-    }
-    private static int $three = 3; // phpstan silliness
-    /**
-     * Get image mime type.
-     *
-     * @param string $filename Filename
-     *
-     * @return string Mime Type
-     */
-    private function getImageMimeType(string $filename): string
-    {
-        if (File::fileExists($filename)) {
-            $image = getimagesize($filename);
-            return image_type_to_mime_type((is_array($image) && count($image) >= self::$three) ? $image[2] : 0);
-        }
-        throw new WriterException("File $filename does not exist");
-    }
-    /**
-     * Write Default content type.
-     *
-     * @param string $partName Part name
-     * @param string $contentType Content type
-     */
-    private function writeDefaultContentType(XMLWriter $objWriter, string $partName, string $contentType): void
-    {
-        if ($partName != '' && $contentType != '') {
-            $objWriter->startElement('Default');
-            $objWriter->writeAttribute('Extension', $partName);
-            $objWriter->writeAttribute('ContentType', $contentType);
-            $objWriter->endElement();
-        } else {
-            throw new WriterException('Invalid parameters passed.');
-        }
-    }
-    /**
-     * Write Override content type.
-     *
-     * @param string $partName Part name
-     * @param string $contentType Content type
-     */
-    private function writeOverrideContentType(XMLWriter $objWriter, string $partName, string $contentType): void
-    {
-        if ($partName != '' && $contentType != '') {
-            $objWriter->startElement('Override');
-            $objWriter->writeAttribute('PartName', $partName);
-            $objWriter->writeAttribute('ContentType', $contentType);
-            $objWriter->endElement();
-        } else {
-            throw new WriterException('Invalid parameters passed.');
-        }
-    }
-}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xlsx/Style.php
@@ -0,0 +1,504 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Style\Alignment;
+use PhpOffice\PhpSpreadsheet\Style\Border;
+use PhpOffice\PhpSpreadsheet\Style\Borders;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\Fill;
+use PhpOffice\PhpSpreadsheet\Style\Font;
+use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
+use PhpOffice\PhpSpreadsheet\Style\Protection;
+class Style extends WriterPart
+{
+    /**
+     * Write styles to XML format.
+     *
+     * @return string XML Output
+     */
+    public function writeStyles(Spreadsheet $spreadsheet): string
+    {
+        $objWriter = null;
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
+        $objWriter->startElement('styleSheet');
+        $objWriter->writeAttribute('xml:space', 'preserve');
+        $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
+        $objWriter->startElement('numFmts');
+        $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getNumFmtHashTable()->count());
+        for ($i = 0; $i < $this->getParentWriter()->getNumFmtHashTable()->count(); ++$i) {
+            $this->writeNumFmt($objWriter, $this->getParentWriter()->getNumFmtHashTable()->getByIndex($i), $i);
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('fonts');
+        $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getFontHashTable()->count());
+        for ($i = 0; $i < $this->getParentWriter()->getFontHashTable()->count(); ++$i) {
+            $thisfont = $this->getParentWriter()->getFontHashTable()->getByIndex($i);
+            if ($thisfont !== null) {
+                $this->writeFont($objWriter, $thisfont);
+            }
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('fills');
+        $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getFillHashTable()->count());
+        for ($i = 0; $i < $this->getParentWriter()->getFillHashTable()->count(); ++$i) {
+            $thisfill = $this->getParentWriter()->getFillHashTable()->getByIndex($i);
+            if ($thisfill !== null) {
+                $this->writeFill($objWriter, $thisfill);
+            }
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('borders');
+        $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getBordersHashTable()->count());
+        for ($i = 0; $i < $this->getParentWriter()->getBordersHashTable()->count(); ++$i) {
+            $thisborder = $this->getParentWriter()->getBordersHashTable()->getByIndex($i);
+            if ($thisborder !== null) {
+                $this->writeBorder($objWriter, $thisborder);
+            }
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('cellStyleXfs');
+        $objWriter->writeAttribute('count', '1');
+        $objWriter->startElement('xf');
+        $objWriter->writeAttribute('numFmtId', '0');
+        $objWriter->writeAttribute('fontId', '0');
+        $objWriter->writeAttribute('fillId', '0');
+        $objWriter->writeAttribute('borderId', '0');
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->startElement('cellXfs');
+        $objWriter->writeAttribute('count', (string) count($spreadsheet->getCellXfCollection()));
+        $alignment = new Alignment();
+        $defaultAlignHash = $alignment->getHashCode();
+        if ($defaultAlignHash !== $spreadsheet->getDefaultStyle()->getAlignment()->getHashCode()) {
+            $defaultAlignHash = '';
+        }
+        foreach ($spreadsheet->getCellXfCollection() as $cellXf) {
+            $this->writeCellStyleXf($objWriter, $cellXf, $spreadsheet, $defaultAlignHash);
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('cellStyles');
+        $objWriter->writeAttribute('count', '1');
+        $objWriter->startElement('cellStyle');
+        $objWriter->writeAttribute('name', 'Normal');
+        $objWriter->writeAttribute('xfId', '0');
+        $objWriter->writeAttribute('builtinId', '0');
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->startElement('dxfs');
+        $objWriter->writeAttribute('count', (string) $this->getParentWriter()->getStylesConditionalHashTable()->count());
+        for ($i = 0; $i < $this->getParentWriter()->getStylesConditionalHashTable()->count(); ++$i) {
+            $thisstyle = $this->getParentWriter()->getStylesConditionalHashTable()->getByIndex($i);
+            if ($thisstyle !== null) {
+                $this->writeCellStyleDxf($objWriter, $thisstyle->getStyle());
+            }
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('tableStyles');
+        $objWriter->writeAttribute('defaultTableStyle', 'TableStyleMedium9');
+        $objWriter->writeAttribute('defaultPivotStyle', 'PivotTableStyle1');
+        $objWriter->endElement();
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    /**
+     * Write Fill.
+     */
+    private function writeFill(XMLWriter $objWriter, Fill $fill): void
+    {
+        if (
+            $fill->getFillType() === Fill::FILL_GRADIENT_LINEAR
+            || $fill->getFillType() === Fill::FILL_GRADIENT_PATH
+        ) {
+            $this->writeGradientFill($objWriter, $fill);
+        } elseif ($fill->getFillType() !== null) {
+            $this->writePatternFill($objWriter, $fill);
+        }
+    }
+    /**
+     * Write Gradient Fill.
+     */
+    private function writeGradientFill(XMLWriter $objWriter, Fill $fill): void
+    {
+        $objWriter->startElement('fill');
+        $objWriter->startElement('gradientFill');
+        $objWriter->writeAttribute('type', (string) $fill->getFillType());
+        $objWriter->writeAttribute('degree', (string) $fill->getRotation());
+        $objWriter->startElement('stop');
+        $objWriter->writeAttribute('position', '0');
+        if ($fill->getStartColor()->getARGB() !== null) {
+            $objWriter->startElement('color');
+            $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
+            $objWriter->endElement();
+        }
+        $objWriter->endElement();
+        $objWriter->startElement('stop');
+        $objWriter->writeAttribute('position', '1');
+        if ($fill->getEndColor()->getARGB() !== null) {
+            $objWriter->startElement('color');
+            $objWriter->writeAttribute('rgb', $fill->getEndColor()->getARGB());
+            $objWriter->endElement();
+        }
+        $objWriter->endElement();
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+    private static function writePatternColors(Fill $fill): bool
+    {
+        if ($fill->getFillType() === Fill::FILL_NONE) {
+            return false;
+        }
+        return $fill->getFillType() === Fill::FILL_SOLID || $fill->getColorsChanged();
+    }
+    /**
+     * Write Pattern Fill.
+     */
+    private function writePatternFill(XMLWriter $objWriter, Fill $fill): void
+    {
+        $objWriter->startElement('fill');
+        $objWriter->startElement('patternFill');
+        $objWriter->writeAttribute('patternType', (string) $fill->getFillType());
+        if (self::writePatternColors($fill)) {
+            if ($fill->getStartColor()->getARGB()) {
+                if (!$fill->getEndColor()->getARGB() && $fill->getFillType() === Fill::FILL_SOLID) {
+                    $objWriter->startElement('bgColor');
+                    $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
+                } else {
+                    $objWriter->startElement('fgColor');
+                    $objWriter->writeAttribute('rgb', $fill->getStartColor()->getARGB());
+                }
+                $objWriter->endElement();
+            }
+            if ($fill->getEndColor()->getARGB()) {
+                $objWriter->startElement('bgColor');
+                $objWriter->writeAttribute('rgb', $fill->getEndColor()->getARGB());
+                $objWriter->endElement();
+            }
+        }
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+    private function startFont(XMLWriter $objWriter, bool &$fontStarted): void
+    {
+        if (!$fontStarted) {
+            $fontStarted = true;
+            $objWriter->startElement('font');
+        }
+    }
+    /**
+     * Write Font.
+     */
+    private function writeFont(XMLWriter $objWriter, Font $font): void
+    {
+        $fontStarted = false;
+        if ($font->getBold() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('b');
+            $objWriter->writeAttribute('val', $font->getBold() ? '1' : '0');
+            $objWriter->endElement();
+        }
+        if ($font->getItalic() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('i');
+            $objWriter->writeAttribute('val', $font->getItalic() ? '1' : '0');
+            $objWriter->endElement();
+        }
+        if ($font->getStrikethrough() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('strike');
+            $objWriter->writeAttribute('val', $font->getStrikethrough() ? '1' : '0');
+            $objWriter->endElement();
+        }
+        if ($font->getUnderline() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('u');
+            $objWriter->writeAttribute('val', $font->getUnderline());
+            $objWriter->endElement();
+        }
+        if ($font->getSuperscript() === true || $font->getSubscript() === true) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('vertAlign');
+            if ($font->getSuperscript() === true) {
+                $objWriter->writeAttribute('val', 'superscript');
+            } elseif ($font->getSubscript() === true) {
+                $objWriter->writeAttribute('val', 'subscript');
+            }
+            $objWriter->endElement();
+        }
+        if ($font->getSize() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('sz');
+            $objWriter->writeAttribute('val', StringHelper::formatNumber($font->getSize()));
+            $objWriter->endElement();
+        }
+        if ($font->getColor()->getARGB() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('color');
+            $objWriter->writeAttribute('rgb', $font->getColor()->getARGB());
+            $objWriter->endElement();
+        }
+        if ($font->getName() !== null) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('name');
+            $objWriter->writeAttribute('val', $font->getName());
+            $objWriter->endElement();
+        }
+        if (!empty($font->getScheme())) {
+            $this->startFont($objWriter, $fontStarted);
+            $objWriter->startElement('scheme');
+            $objWriter->writeAttribute('val', $font->getScheme());
+            $objWriter->endElement();
+        }
+        if ($fontStarted) {
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write Border.
+     */
+    private function writeBorder(XMLWriter $objWriter, Borders $borders): void
+    {
+        $objWriter->startElement('border');
+        switch ($borders->getDiagonalDirection()) {
+            case Borders::DIAGONAL_UP:
+                $objWriter->writeAttribute('diagonalUp', 'true');
+                $objWriter->writeAttribute('diagonalDown', 'false');
+                break;
+            case Borders::DIAGONAL_DOWN:
+                $objWriter->writeAttribute('diagonalUp', 'false');
+                $objWriter->writeAttribute('diagonalDown', 'true');
+                break;
+            case Borders::DIAGONAL_BOTH:
+                $objWriter->writeAttribute('diagonalUp', 'true');
+                $objWriter->writeAttribute('diagonalDown', 'true');
+                break;
+        }
+        $this->writeBorderPr($objWriter, 'left', $borders->getLeft());
+        $this->writeBorderPr($objWriter, 'right', $borders->getRight());
+        $this->writeBorderPr($objWriter, 'top', $borders->getTop());
+        $this->writeBorderPr($objWriter, 'bottom', $borders->getBottom());
+        $this->writeBorderPr($objWriter, 'diagonal', $borders->getDiagonal());
+        $objWriter->endElement();
+    }
+    /**
+     * Write Cell Style Xf.
+     */
+    private function writeCellStyleXf(XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $style, Spreadsheet $spreadsheet, string $defaultAlignHash): void
+    {
+        $objWriter->startElement('xf');
+        $objWriter->writeAttribute('xfId', '0');
+        $objWriter->writeAttribute('fontId', (string) (int) $this->getParentWriter()->getFontHashTable()->getIndexForHashCode($style->getFont()->getHashCode()));
+        if ($style->getQuotePrefix()) {
+            $objWriter->writeAttribute('quotePrefix', '1');
+        }
+        if ($style->getNumberFormat()->getBuiltInFormatCode() === false) {
+            $objWriter->writeAttribute('numFmtId', (string) (int) ($this->getParentWriter()->getNumFmtHashTable()->getIndexForHashCode($style->getNumberFormat()->getHashCode()) + 164));
+        } else {
+            $objWriter->writeAttribute('numFmtId', (string) (int) $style->getNumberFormat()->getBuiltInFormatCode());
+        }
+        $objWriter->writeAttribute('fillId', (string) (int) $this->getParentWriter()->getFillHashTable()->getIndexForHashCode($style->getFill()->getHashCode()));
+        $objWriter->writeAttribute('borderId', (string) (int) $this->getParentWriter()->getBordersHashTable()->getIndexForHashCode($style->getBorders()->getHashCode()));
+        $objWriter->writeAttribute('applyFont', ($spreadsheet->getDefaultStyle()->getFont()->getHashCode() != $style->getFont()->getHashCode()) ? '1' : '0');
+        $objWriter->writeAttribute('applyNumberFormat', ($spreadsheet->getDefaultStyle()->getNumberFormat()->getHashCode() != $style->getNumberFormat()->getHashCode()) ? '1' : '0');
+        $objWriter->writeAttribute('applyFill', ($spreadsheet->getDefaultStyle()->getFill()->getHashCode() != $style->getFill()->getHashCode()) ? '1' : '0');
+        $objWriter->writeAttribute('applyBorder', ($spreadsheet->getDefaultStyle()->getBorders()->getHashCode() != $style->getBorders()->getHashCode()) ? '1' : '0');
+        if ($defaultAlignHash !== '' && $defaultAlignHash === $style->getAlignment()->getHashCode()) {
+            $applyAlignment = '0';
+        } else {
+            $applyAlignment = '1';
+        }
+        $objWriter->writeAttribute('applyAlignment', $applyAlignment);
+        if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT || $style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
+            $objWriter->writeAttribute('applyProtection', 'true');
+        }
+        if ($applyAlignment === '1') {
+            $objWriter->startElement('alignment');
+            $vertical = Alignment::VERTICAL_ALIGNMENT_FOR_XLSX[$style->getAlignment()->getVertical()] ?? '';
+            $horizontal = Alignment::HORIZONTAL_ALIGNMENT_FOR_XLSX[$style->getAlignment()->getHorizontal()] ?? '';
+            if ($horizontal !== '') {
+                $objWriter->writeAttribute('horizontal', $horizontal);
+            }
+            if ($vertical !== '') {
+                $objWriter->writeAttribute('vertical', $vertical);
+            }
+            if ($style->getAlignment()->getTextRotation() >= 0) {
+                $textRotation = $style->getAlignment()->getTextRotation();
+            } else {
+                $textRotation = 90 - $style->getAlignment()->getTextRotation();
+            }
+            $objWriter->writeAttribute('textRotation', (string) $textRotation);
+            $objWriter->writeAttribute('wrapText', ($style->getAlignment()->getWrapText() ? 'true' : 'false'));
+            $objWriter->writeAttribute('shrinkToFit', ($style->getAlignment()->getShrinkToFit() ? 'true' : 'false'));
+            if ($style->getAlignment()->getIndent() > 0) {
+                $objWriter->writeAttribute('indent', (string) $style->getAlignment()->getIndent());
+            }
+            if ($style->getAlignment()->getReadOrder() > 0) {
+                $objWriter->writeAttribute('readingOrder', (string) $style->getAlignment()->getReadOrder());
+            }
+            $objWriter->endElement();
+        }
+        if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT || $style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
+            $objWriter->startElement('protection');
+            if ($style->getProtection()->getLocked() != Protection::PROTECTION_INHERIT) {
+                $objWriter->writeAttribute('locked', ($style->getProtection()->getLocked() == Protection::PROTECTION_PROTECTED ? 'true' : 'false'));
+            }
+            if ($style->getProtection()->getHidden() != Protection::PROTECTION_INHERIT) {
+                $objWriter->writeAttribute('hidden', ($style->getProtection()->getHidden() == Protection::PROTECTION_PROTECTED ? 'true' : 'false'));
+            }
+            $objWriter->endElement();
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write Cell Style Dxf.
+     */
+    private function writeCellStyleDxf(XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $style): void
+    {
+        $objWriter->startElement('dxf');
+        $this->writeFont($objWriter, $style->getFont());
+        $this->writeNumFmt($objWriter, $style->getNumberFormat());
+        $this->writeFill($objWriter, $style->getFill());
+        $this->writeBorder($objWriter, $style->getBorders());
+        $objWriter->endElement();
+    }
+    /**
+     * Write BorderPr.
+     *
+     * @param string $name Element name
+     */
+    private function writeBorderPr(XMLWriter $objWriter, string $name, Border $border): void
+    {
+        if ($border->getBorderStyle() === Border::BORDER_OMIT) {
+            return;
+        }
+        $objWriter->startElement($name);
+        if ($border->getBorderStyle() !== Border::BORDER_NONE) {
+            $objWriter->writeAttribute('style', $border->getBorderStyle());
+            if ($border->getColor()->getARGB() !== null) {
+                $objWriter->startElement('color');
+                $objWriter->writeAttribute('rgb', $border->getColor()->getARGB());
+                $objWriter->endElement();
+            }
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write NumberFormat.
+     *
+     * @param int $id Number Format identifier
+     */
+    private function writeNumFmt(XMLWriter $objWriter, ?NumberFormat $numberFormat, int $id = 0): void
+    {
+        $formatCode = ($numberFormat === null) ? null : $numberFormat->getFormatCode();
+        if ($formatCode !== null) {
+            $objWriter->startElement('numFmt');
+            $objWriter->writeAttribute('numFmtId', (string) ($id + 164));
+            $objWriter->writeAttribute('formatCode', $formatCode);
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Get an array of all styles.
+     *
+     * @return \PhpOffice\PhpSpreadsheet\Style\Style[] All styles in PhpSpreadsheet
+     */
+    public function allStyles(Spreadsheet $spreadsheet): array
+    {
+        return $spreadsheet->getCellXfCollection();
+    }
+    /**
+     * Get an array of all conditional styles.
+     *
+     * @return Conditional[] All conditional styles in PhpSpreadsheet
+     */
+    public function allConditionalStyles(Spreadsheet $spreadsheet): array
+    {
+        $aStyles = [];
+        $sheetCount = $spreadsheet->getSheetCount();
+        for ($i = 0; $i < $sheetCount; ++$i) {
+            foreach ($spreadsheet->getSheet($i)->getConditionalStylesCollection() as $conditionalStyles) {
+                foreach ($conditionalStyles as $conditionalStyle) {
+                    $aStyles[] = $conditionalStyle;
+                }
+            }
+        }
+        return $aStyles;
+    }
+    /**
+     * Get an array of all fills.
+     *
+     * @return Fill[] All fills in PhpSpreadsheet
+     */
+    public function allFills(Spreadsheet $spreadsheet): array
+    {
+        $aFills = [];
+        $fill0 = new Fill();
+        $fill0->setFillType(Fill::FILL_NONE);
+        $aFills[] = $fill0;
+        $fill1 = new Fill();
+        $fill1->setFillType(Fill::FILL_PATTERN_GRAY125);
+        $aFills[] = $fill1;
+        $aStyles = $this->allStyles($spreadsheet);
+        foreach ($aStyles as $style) {
+            if (!isset($aFills[$style->getFill()->getHashCode()])) {
+                $aFills[$style->getFill()->getHashCode()] = $style->getFill();
+            }
+        }
+        return $aFills;
+    }
+    /**
+     * Get an array of all fonts.
+     *
+     * @return Font[] All fonts in PhpSpreadsheet
+     */
+    public function allFonts(Spreadsheet $spreadsheet): array
+    {
+        $aFonts = [];
+        $aStyles = $this->allStyles($spreadsheet);
+        foreach ($aStyles as $style) {
+            if (!isset($aFonts[$style->getFont()->getHashCode()])) {
+                $aFonts[$style->getFont()->getHashCode()] = $style->getFont();
+            }
+        }
+        return $aFonts;
+    }
+    /**
+     * Get an array of all borders.
+     *
+     * @return Borders[] All borders in PhpSpreadsheet
+     */
+    public function allBorders(Spreadsheet $spreadsheet): array
+    {
+        $aBorders = [];
+        $aStyles = $this->allStyles($spreadsheet);
+        foreach ($aStyles as $style) {
+            if (!isset($aBorders[$style->getBorders()->getHashCode()])) {
+                $aBorders[$style->getBorders()->getHashCode()] = $style->getBorders();
+            }
+        }
+        return $aBorders;
+    }
+    /**
+     * Get an array of all number formats.
+     *
+     * @return NumberFormat[] All number formats in PhpSpreadsheet
+     */
+    public function allNumberFormats(Spreadsheet $spreadsheet): array
+    {
+        $aNumFmts = [];
+        $aStyles = $this->allStyles($spreadsheet);
+        foreach ($aStyles as $style) {
+            if ($style->getNumberFormat()->getBuiltInFormatCode() === false && !isset($aNumFmts[$style->getNumberFormat()->getHashCode()])) {
+                $aNumFmts[$style->getNumberFormat()->getHashCode()] = $style->getNumberFormat();
+            }
+        }
+        return $aNumFmts;
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xlsx/Workbook.php
@@ -0,0 +1,160 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
+use PhpOffice\PhpSpreadsheet\Shared\Date;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+use PhpOffice\PhpSpreadsheet\Spreadsheet;
+use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
+use PhpOffice\PhpSpreadsheet\Writer\Xlsx\DefinedNames as DefinedNamesWriter;
+class Workbook extends WriterPart
+{
+    /**
+     * Write workbook to XML format.
+     *
+     * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
+     *
+     * @return string XML Output
+     */
+    public function writeWorkbook(Spreadsheet $spreadsheet, bool $recalcRequired = false): string
+    {
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
+        $objWriter->startElement('workbook');
+        $objWriter->writeAttribute('xml:space', 'preserve');
+        $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
+        $objWriter->writeAttribute('xmlns:r', Namespaces::SCHEMA_OFFICE_DOCUMENT);
+        $this->writeFileVersion($objWriter);
+        $this->writeWorkbookPr($objWriter, $spreadsheet);
+        $this->writeWorkbookProtection($objWriter, $spreadsheet);
+        if ($this->getParentWriter()->getOffice2003Compatibility() === false) {
+            $this->writeBookViews($objWriter, $spreadsheet);
+        }
+        $this->writeSheets($objWriter, $spreadsheet);
+        (new DefinedNamesWriter($objWriter, $spreadsheet))->write();
+        $this->writeCalcPr($objWriter, $recalcRequired);
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    /**
+     * Write file version.
+     */
+    private function writeFileVersion(XMLWriter $objWriter): void
+    {
+        $objWriter->startElement('fileVersion');
+        $objWriter->writeAttribute('appName', 'xl');
+        $objWriter->writeAttribute('lastEdited', '4');
+        $objWriter->writeAttribute('lowestEdited', '4');
+        $objWriter->writeAttribute('rupBuild', '4505');
+        $objWriter->endElement();
+    }
+    /**
+     * Write WorkbookPr.
+     */
+    private function writeWorkbookPr(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
+    {
+        $objWriter->startElement('workbookPr');
+        if ($spreadsheet->getExcelCalendar() === Date::CALENDAR_MAC_1904) {
+            $objWriter->writeAttribute('date1904', '1');
+        }
+        $objWriter->writeAttribute('codeName', 'ThisWorkbook');
+        $objWriter->endElement();
+    }
+    /**
+     * Write BookViews.
+     */
+    private function writeBookViews(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
+    {
+        $objWriter->startElement('bookViews');
+        $objWriter->startElement('workbookView');
+        $objWriter->writeAttribute('activeTab', (string) $spreadsheet->getActiveSheetIndex());
+        $objWriter->writeAttribute('autoFilterDateGrouping', ($spreadsheet->getAutoFilterDateGrouping() ? 'true' : 'false'));
+        $objWriter->writeAttribute('firstSheet', (string) $spreadsheet->getFirstSheetIndex());
+        $objWriter->writeAttribute('minimized', ($spreadsheet->getMinimized() ? 'true' : 'false'));
+        $objWriter->writeAttribute('showHorizontalScroll', ($spreadsheet->getShowHorizontalScroll() ? 'true' : 'false'));
+        $objWriter->writeAttribute('showSheetTabs', ($spreadsheet->getShowSheetTabs() ? 'true' : 'false'));
+        $objWriter->writeAttribute('showVerticalScroll', ($spreadsheet->getShowVerticalScroll() ? 'true' : 'false'));
+        $objWriter->writeAttribute('tabRatio', (string) $spreadsheet->getTabRatio());
+        $objWriter->writeAttribute('visibility', $spreadsheet->getVisibility());
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+    /**
+     * Write WorkbookProtection.
+     */
+    private function writeWorkbookProtection(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
+    {
+        if ($spreadsheet->getSecurity()->isSecurityEnabled()) {
+            $objWriter->startElement('workbookProtection');
+            $objWriter->writeAttribute('lockRevision', ($spreadsheet->getSecurity()->getLockRevision() ? 'true' : 'false'));
+            $objWriter->writeAttribute('lockStructure', ($spreadsheet->getSecurity()->getLockStructure() ? 'true' : 'false'));
+            $objWriter->writeAttribute('lockWindows', ($spreadsheet->getSecurity()->getLockWindows() ? 'true' : 'false'));
+            if ($spreadsheet->getSecurity()->getRevisionsPassword() != '') {
+                $objWriter->writeAttribute('revisionsPassword', $spreadsheet->getSecurity()->getRevisionsPassword());
+            }
+            if ($spreadsheet->getSecurity()->getWorkbookPassword() != '') {
+                $objWriter->writeAttribute('workbookPassword', $spreadsheet->getSecurity()->getWorkbookPassword());
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write calcPr.
+     *
+     * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
+     */
+    private function writeCalcPr(XMLWriter $objWriter, bool $recalcRequired = true): void
+    {
+        $objWriter->startElement('calcPr');
+        $objWriter->writeAttribute('calcId', '999999');
+        $objWriter->writeAttribute('calcMode', 'auto');
+        $objWriter->writeAttribute('calcCompleted', ($recalcRequired) ? '1' : '0');
+        $objWriter->writeAttribute('fullCalcOnLoad', ($recalcRequired) ? '0' : '1');
+        $objWriter->writeAttribute('forceFullCalc', ($recalcRequired) ? '0' : '1');
+        $objWriter->endElement();
+    }
+    /**
+     * Write sheets.
+     */
+    private function writeSheets(XMLWriter $objWriter, Spreadsheet $spreadsheet): void
+    {
+        $objWriter->startElement('sheets');
+        $sheetCount = $spreadsheet->getSheetCount();
+        for ($i = 0; $i < $sheetCount; ++$i) {
+            $this->writeSheet(
+                $objWriter,
+                $spreadsheet->getSheet($i)->getTitle(),
+                ($i + 1),
+                ($i + 1 + 3),
+                $spreadsheet->getSheet($i)->getSheetState()
+            );
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write sheet.
+     *
+     * @param string $worksheetName Sheet name
+     * @param int $worksheetId Sheet id
+     * @param int $relId Relationship ID
+     * @param string $sheetState Sheet state (visible, hidden, veryHidden)
+     */
+    private function writeSheet(XMLWriter $objWriter, string $worksheetName, int $worksheetId = 1, int $relId = 1, string $sheetState = 'visible'): void
+    {
+        if ($worksheetName != '') {
+            $objWriter->startElement('sheet');
+            $objWriter->writeAttribute('name', $worksheetName);
+            $objWriter->writeAttribute('sheetId', (string) $worksheetId);
+            if ($sheetState !== 'visible' && $sheetState != '') {
+                $objWriter->writeAttribute('state', $sheetState);
+            }
+            $objWriter->writeAttribute('r:id', 'rId' . $relId);
+            $objWriter->endElement();
+        } else {
+            throw new WriterException('Invalid parameters passed.');
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/Xlsx/Worksheet.php
@@ -0,0 +1,1313 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
+use PhpOffice\PhpSpreadsheet\Calculation\Information\ErrorValue;
+use PhpOffice\PhpSpreadsheet\Cell\Cell;
+use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
+use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
+use PhpOffice\PhpSpreadsheet\RichText\RichText;
+use PhpOffice\PhpSpreadsheet\Settings;
+use PhpOffice\PhpSpreadsheet\Shared\StringHelper;
+use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
+use PhpOffice\PhpSpreadsheet\Style\Conditional;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalColorScale;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalDataBar;
+use PhpOffice\PhpSpreadsheet\Style\ConditionalFormatting\ConditionalFormattingRuleExtension;
+use PhpOffice\PhpSpreadsheet\Worksheet\RowDimension;
+use PhpOffice\PhpSpreadsheet\Worksheet\SheetView;
+use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet as PhpspreadsheetWorksheet;
+class Worksheet extends WriterPart
+{
+    private string $numberStoredAsText = '';
+    private string $formula = '';
+    private string $twoDigitTextYear = '';
+    private string $evalError = '';
+    private bool $explicitStyle0;
+    /**
+     * Write worksheet to XML format.
+     *
+     * @param string[] $stringTable
+     * @param bool $includeCharts Flag indicating if we should write charts
+     *
+     * @return string XML Output
+     */
+    public function writeWorksheet(PhpspreadsheetWorksheet $worksheet, array $stringTable = [], bool $includeCharts = false): string
+    {
+        $this->explicitStyle0 = $this->getParentWriter()->getExplicitStyle0();
+        $this->numberStoredAsText = '';
+        $this->formula = '';
+        $this->twoDigitTextYear = '';
+        $this->evalError = '';
+        $objWriter = null;
+        if ($this->getParentWriter()->getUseDiskCaching()) {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
+        } else {
+            $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
+        }
+        $objWriter->startDocument('1.0', 'UTF-8', 'yes');
+        $objWriter->startElement('worksheet');
+        $objWriter->writeAttribute('xml:space', 'preserve');
+        $objWriter->writeAttribute('xmlns', Namespaces::MAIN);
+        $objWriter->writeAttribute('xmlns:r', Namespaces::SCHEMA_OFFICE_DOCUMENT);
+        $objWriter->writeAttribute('xmlns:xdr', Namespaces::SPREADSHEET_DRAWING);
+        $objWriter->writeAttribute('xmlns:x14', Namespaces::DATA_VALIDATIONS1);
+        $objWriter->writeAttribute('xmlns:xm', Namespaces::DATA_VALIDATIONS2);
+        $objWriter->writeAttribute('xmlns:mc', Namespaces::COMPATIBILITY);
+        $objWriter->writeAttribute('mc:Ignorable', 'x14ac');
+        $objWriter->writeAttribute('xmlns:x14ac', Namespaces::SPREADSHEETML_AC);
+        $this->writeSheetPr($objWriter, $worksheet);
+        $this->writeDimension($objWriter, $worksheet);
+        $this->writeSheetViews($objWriter, $worksheet);
+        $this->writeSheetFormatPr($objWriter, $worksheet);
+        $this->writeCols($objWriter, $worksheet);
+        $this->writeSheetData($objWriter, $worksheet, $stringTable);
+        $this->writeSheetProtection($objWriter, $worksheet);
+        $this->writeProtectedRanges($objWriter, $worksheet);
+        $this->writeAutoFilter($objWriter, $worksheet);
+        $this->writeMergeCells($objWriter, $worksheet);
+        $this->writeConditionalFormatting($objWriter, $worksheet);
+        $this->writeDataValidations($objWriter, $worksheet);
+        $this->writeHyperlinks($objWriter, $worksheet);
+        $this->writePrintOptions($objWriter, $worksheet);
+        $this->writePageMargins($objWriter, $worksheet);
+        $this->writePageSetup($objWriter, $worksheet);
+        $this->writeHeaderFooter($objWriter, $worksheet);
+        $this->writeBreaks($objWriter, $worksheet);
+        $this->writeDrawings($objWriter, $worksheet, $includeCharts);
+        $this->writeLegacyDrawing($objWriter, $worksheet);
+        $this->writeLegacyDrawingHF($objWriter, $worksheet);
+        $this->writeAlternateContent($objWriter, $worksheet);
+        $this->writeIgnoredErrors($objWriter);
+        $this->writeBackgroundImage($objWriter, $worksheet);
+        $this->writeTable($objWriter, $worksheet);
+        $this->writeExtLst($objWriter, $worksheet);
+        $objWriter->endElement();
+        return $objWriter->getData();
+    }
+    private function writeIgnoredError(XMLWriter $objWriter, bool &$started, string $attr, string $cells): void
+    {
+        if ($cells !== '') {
+            if (!$started) {
+                $objWriter->startElement('ignoredErrors');
+                $started = true;
+            }
+            $objWriter->startElement('ignoredError');
+            $objWriter->writeAttribute('sqref', substr($cells, 1));
+            $objWriter->writeAttribute($attr, '1');
+            $objWriter->endElement();
+        }
+    }
+    private function writeIgnoredErrors(XMLWriter $objWriter): void
+    {
+        $started = false;
+        $this->writeIgnoredError($objWriter, $started, 'numberStoredAsText', $this->numberStoredAsText);
+        $this->writeIgnoredError($objWriter, $started, 'formula', $this->formula);
+        $this->writeIgnoredError($objWriter, $started, 'twoDigitTextYear', $this->twoDigitTextYear);
+        $this->writeIgnoredError($objWriter, $started, 'evalError', $this->evalError);
+        if ($started) {
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write SheetPr.
+     */
+    private function writeSheetPr(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('sheetPr');
+        if ($worksheet->getParentOrThrow()->hasMacros()) {
+            if (!$worksheet->hasCodeName()) {
+                $worksheet->setCodeName($worksheet->getTitle());
+            }
+            self::writeAttributeNotNull($objWriter, 'codeName', $worksheet->getCodeName());
+        }
+        $autoFilterRange = $worksheet->getAutoFilter()->getRange();
+        if (!empty($autoFilterRange)) {
+            $objWriter->writeAttribute('filterMode', '1');
+            if (!$worksheet->getAutoFilter()->getEvaluated()) {
+                $worksheet->getAutoFilter()->showHideRows();
+            }
+        }
+        $tables = $worksheet->getTableCollection();
+        if (count($tables)) {
+            foreach ($tables as $table) {
+                if (!$table->getAutoFilter()->getEvaluated()) {
+                    $table->getAutoFilter()->showHideRows();
+                }
+            }
+        }
+        if ($worksheet->isTabColorSet()) {
+            $objWriter->startElement('tabColor');
+            $objWriter->writeAttribute('rgb', $worksheet->getTabColor()->getARGB() ?? '');
+            $objWriter->endElement();
+        }
+        $objWriter->startElement('outlinePr');
+        $objWriter->writeAttribute('summaryBelow', ($worksheet->getShowSummaryBelow() ? '1' : '0'));
+        $objWriter->writeAttribute('summaryRight', ($worksheet->getShowSummaryRight() ? '1' : '0'));
+        $objWriter->endElement();
+        if ($worksheet->getPageSetup()->getFitToPage()) {
+            $objWriter->startElement('pageSetUpPr');
+            $objWriter->writeAttribute('fitToPage', '1');
+            $objWriter->endElement();
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write Dimension.
+     */
+    private function writeDimension(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('dimension');
+        $objWriter->writeAttribute('ref', $worksheet->calculateWorksheetDimension());
+        $objWriter->endElement();
+    }
+    /**
+     * Write SheetViews.
+     */
+    private function writeSheetViews(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('sheetViews');
+        $sheetSelected = false;
+        if ($this->getParentWriter()->getSpreadsheet()->getIndex($worksheet) == $this->getParentWriter()->getSpreadsheet()->getActiveSheetIndex()) {
+            $sheetSelected = true;
+        }
+        $objWriter->startElement('sheetView');
+        $objWriter->writeAttribute('tabSelected', $sheetSelected ? '1' : '0');
+        $objWriter->writeAttribute('workbookViewId', '0');
+        $zoomScale = $worksheet->getSheetView()->getZoomScale();
+        if ($zoomScale !== 100 && $zoomScale !== null) {
+            $objWriter->writeAttribute('zoomScale', (string) $zoomScale);
+        }
+        $zoomScale = $worksheet->getSheetView()->getZoomScaleNormal();
+        if ($zoomScale !== 100 && $zoomScale !== null) {
+            $objWriter->writeAttribute('zoomScaleNormal', (string) $zoomScale);
+        }
+        $zoomScale = $worksheet->getSheetView()->getZoomScalePageLayoutView();
+        if ($zoomScale !== 100) {
+            $objWriter->writeAttribute('zoomScalePageLayoutView', (string) $zoomScale);
+        }
+        $zoomScale = $worksheet->getSheetView()->getZoomScaleSheetLayoutView();
+        if ($zoomScale !== 100) {
+            $objWriter->writeAttribute('zoomScaleSheetLayoutView', (string) $zoomScale);
+        }
+        if ($worksheet->getSheetView()->getShowZeros() === false) {
+            $objWriter->writeAttribute('showZeros', '0');
+        }
+        if ($worksheet->getSheetView()->getView() !== SheetView::SHEETVIEW_NORMAL) {
+            $objWriter->writeAttribute('view', $worksheet->getSheetView()->getView());
+        }
+        if ($worksheet->getShowGridlines()) {
+            $objWriter->writeAttribute('showGridLines', 'true');
+        } else {
+            $objWriter->writeAttribute('showGridLines', 'false');
+        }
+        if ($worksheet->getShowRowColHeaders()) {
+            $objWriter->writeAttribute('showRowColHeaders', '1');
+        } else {
+            $objWriter->writeAttribute('showRowColHeaders', '0');
+        }
+        if ($worksheet->getRightToLeft()) {
+            $objWriter->writeAttribute('rightToLeft', 'true');
+        }
+        $topLeftCell = $worksheet->getTopLeftCell();
+        if (!empty($topLeftCell) && $worksheet->getPaneState() !== PhpspreadsheetWorksheet::PANE_FROZEN && $worksheet->getPaneState() !== PhpspreadsheetWorksheet::PANE_FROZENSPLIT) {
+            $objWriter->writeAttribute('topLeftCell', $topLeftCell);
+        }
+        $activeCell = $worksheet->getActiveCell();
+        $sqref = $worksheet->getSelectedCells();
+        if ($worksheet->usesPanes()) {
+            $objWriter->startElement('pane');
+            $xSplit = $worksheet->getXSplit();
+            $ySplit = $worksheet->getYSplit();
+            $pane = $worksheet->getActivePane();
+            $paneTopLeftCell = $worksheet->getPaneTopLeftCell();
+            $paneState = $worksheet->getPaneState();
+            $normalFreeze = '';
+            if ($paneState === PhpspreadsheetWorksheet::PANE_FROZEN) {
+                if ($ySplit > 0) {
+                    $normalFreeze = ($xSplit <= 0) ? 'bottomLeft' : 'bottomRight';
+                } else {
+                    $normalFreeze = 'topRight';
+                }
+            }
+            if ($xSplit > 0) {
+                $objWriter->writeAttribute('xSplit', "$xSplit");
+            }
+            if ($ySplit > 0) {
+                $objWriter->writeAttribute('ySplit', "$ySplit");
+            }
+            if ($normalFreeze !== '') {
+                $objWriter->writeAttribute('activePane', $normalFreeze);
+            } elseif ($pane !== '') {
+                $objWriter->writeAttribute('activePane', $pane);
+            }
+            if ($paneState !== '') {
+                $objWriter->writeAttribute('state', $paneState);
+            }
+            if ($paneTopLeftCell !== '') {
+                $objWriter->writeAttribute('topLeftCell', $paneTopLeftCell);
+            }
+            $objWriter->endElement(); // pane
+            if ($normalFreeze !== '') {
+                $objWriter->startElement('selection');
+                $objWriter->writeAttribute('pane', $normalFreeze);
+                if ($activeCell !== '') {
+                    $objWriter->writeAttribute('activeCell', $activeCell);
+                }
+                if ($sqref !== '') {
+                    $objWriter->writeAttribute('sqref', $sqref);
+                }
+                $objWriter->endElement(); // selection
+                $sqref = $activeCell = '';
+            } else {
+                foreach ($worksheet->getPanes() as $panex) {
+                    if ($panex !== null) {
+                        $sqref = $activeCell = '';
+                        $objWriter->startElement('selection');
+                        $objWriter->writeAttribute('pane', $panex->getPosition());
+                        $activeCellPane = $panex->getActiveCell();
+                        if ($activeCellPane !== '') {
+                            $objWriter->writeAttribute('activeCell', $activeCellPane);
+                        }
+                        $sqrefPane = $panex->getSqref();
+                        if ($sqrefPane !== '') {
+                            $objWriter->writeAttribute('sqref', $sqrefPane);
+                        }
+                        $objWriter->endElement(); // selection
+                    }
+                }
+            }
+        }
+        if (!empty($sqref) || !empty($activeCell)) {
+            $objWriter->startElement('selection');
+            if (!empty($activeCell)) {
+                $objWriter->writeAttribute('activeCell', $activeCell);
+            }
+            if (!empty($sqref)) {
+                $objWriter->writeAttribute('sqref', $sqref);
+            }
+            $objWriter->endElement(); // selection
+        }
+        $objWriter->endElement();
+        $objWriter->endElement();
+    }
+    /**
+     * Write SheetFormatPr.
+     */
+    private function writeSheetFormatPr(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('sheetFormatPr');
+        if ($worksheet->getDefaultRowDimension()->getRowHeight() >= 0) {
+            $objWriter->writeAttribute('customHeight', 'true');
+            $objWriter->writeAttribute('defaultRowHeight', StringHelper::formatNumber($worksheet->getDefaultRowDimension()->getRowHeight()));
+        } else {
+            $objWriter->writeAttribute('defaultRowHeight', '14.4');
+        }
+        if ($worksheet->getDefaultRowDimension()->getZeroHeight()) {
+            $objWriter->writeAttribute('zeroHeight', '1');
+        }
+        if ($worksheet->getDefaultColumnDimension()->getWidth() >= 0) {
+            $objWriter->writeAttribute('defaultColWidth', StringHelper::formatNumber($worksheet->getDefaultColumnDimension()->getWidth()));
+        }
+        $outlineLevelRow = 0;
+        foreach ($worksheet->getRowDimensions() as $dimension) {
+            if ($dimension->getOutlineLevel() > $outlineLevelRow) {
+                $outlineLevelRow = $dimension->getOutlineLevel();
+            }
+        }
+        $objWriter->writeAttribute('outlineLevelRow', (string) (int) $outlineLevelRow);
+        $outlineLevelCol = 0;
+        foreach ($worksheet->getColumnDimensions() as $dimension) {
+            if ($dimension->getOutlineLevel() > $outlineLevelCol) {
+                $outlineLevelCol = $dimension->getOutlineLevel();
+            }
+        }
+        $objWriter->writeAttribute('outlineLevelCol', (string) (int) $outlineLevelCol);
+        $objWriter->endElement();
+    }
+    /**
+     * Write Cols.
+     */
+    private function writeCols(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if (count($worksheet->getColumnDimensions()) > 0) {
+            $objWriter->startElement('cols');
+            $worksheet->calculateColumnWidths();
+            foreach ($worksheet->getColumnDimensions() as $colDimension) {
+                $objWriter->startElement('col');
+                $objWriter->writeAttribute('min', (string) Coordinate::columnIndexFromString($colDimension->getColumnIndex()));
+                $objWriter->writeAttribute('max', (string) Coordinate::columnIndexFromString($colDimension->getColumnIndex()));
+                if ($colDimension->getWidth() < 0) {
+                    $objWriter->writeAttribute('width', '9.10');
+                } else {
+                    $objWriter->writeAttribute('width', StringHelper::formatNumber($colDimension->getWidth()));
+                }
+                if ($colDimension->getVisible() === false) {
+                    $objWriter->writeAttribute('hidden', 'true');
+                }
+                if ($colDimension->getAutoSize()) {
+                    $objWriter->writeAttribute('bestFit', 'true');
+                }
+                if ($colDimension->getWidth() != $worksheet->getDefaultColumnDimension()->getWidth()) {
+                    $objWriter->writeAttribute('customWidth', 'true');
+                }
+                if ($colDimension->getCollapsed() === true) {
+                    $objWriter->writeAttribute('collapsed', 'true');
+                }
+                if ($colDimension->getOutlineLevel() > 0) {
+                    $objWriter->writeAttribute('outlineLevel', (string) $colDimension->getOutlineLevel());
+                }
+                $objWriter->writeAttribute('style', (string) $colDimension->getXfIndex());
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write SheetProtection.
+     */
+    private function writeSheetProtection(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $protection = $worksheet->getProtection();
+        if (!$protection->isProtectionEnabled()) {
+            return;
+        }
+        $objWriter->startElement('sheetProtection');
+        if ($protection->getAlgorithm()) {
+            $objWriter->writeAttribute('algorithmName', $protection->getAlgorithm());
+            $objWriter->writeAttribute('hashValue', $protection->getPassword());
+            $objWriter->writeAttribute('saltValue', $protection->getSalt());
+            $objWriter->writeAttribute('spinCount', (string) $protection->getSpinCount());
+        } elseif ($protection->getPassword() !== '') {
+            $objWriter->writeAttribute('password', $protection->getPassword());
+        }
+        self::writeProtectionAttribute($objWriter, 'sheet', $protection->getSheet());
+        self::writeProtectionAttribute($objWriter, 'objects', $protection->getObjects());
+        self::writeProtectionAttribute($objWriter, 'scenarios', $protection->getScenarios());
+        self::writeProtectionAttribute($objWriter, 'formatCells', $protection->getFormatCells());
+        self::writeProtectionAttribute($objWriter, 'formatColumns', $protection->getFormatColumns());
+        self::writeProtectionAttribute($objWriter, 'formatRows', $protection->getFormatRows());
+        self::writeProtectionAttribute($objWriter, 'insertColumns', $protection->getInsertColumns());
+        self::writeProtectionAttribute($objWriter, 'insertRows', $protection->getInsertRows());
+        self::writeProtectionAttribute($objWriter, 'insertHyperlinks', $protection->getInsertHyperlinks());
+        self::writeProtectionAttribute($objWriter, 'deleteColumns', $protection->getDeleteColumns());
+        self::writeProtectionAttribute($objWriter, 'deleteRows', $protection->getDeleteRows());
+        self::writeProtectionAttribute($objWriter, 'sort', $protection->getSort());
+        self::writeProtectionAttribute($objWriter, 'autoFilter', $protection->getAutoFilter());
+        self::writeProtectionAttribute($objWriter, 'pivotTables', $protection->getPivotTables());
+        self::writeProtectionAttribute($objWriter, 'selectLockedCells', $protection->getSelectLockedCells());
+        self::writeProtectionAttribute($objWriter, 'selectUnlockedCells', $protection->getSelectUnlockedCells());
+        $objWriter->endElement();
+    }
+    private static function writeProtectionAttribute(XMLWriter $objWriter, string $name, ?bool $value): void
+    {
+        if ($value === true) {
+            $objWriter->writeAttribute($name, '1');
+        } elseif ($value === false) {
+            $objWriter->writeAttribute($name, '0');
+        }
+    }
+    private static function writeAttributeIf(XMLWriter $objWriter, ?bool $condition, string $attr, string $val): void
+    {
+        if ($condition) {
+            $objWriter->writeAttribute($attr, $val);
+        }
+    }
+    private static function writeAttributeNotNull(XMLWriter $objWriter, string $attr, ?string $val): void
+    {
+        if ($val !== null) {
+            $objWriter->writeAttribute($attr, $val);
+        }
+    }
+    private static function writeElementIf(XMLWriter $objWriter, bool $condition, string $attr, string $val): void
+    {
+        if ($condition) {
+            $objWriter->writeElement($attr, $val);
+        }
+    }
+    private static function writeOtherCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
+    {
+        $conditions = $conditional->getConditions();
+        if (
+            $conditional->getConditionType() == Conditional::CONDITION_CELLIS
+            || $conditional->getConditionType() == Conditional::CONDITION_EXPRESSION
+            || !empty($conditions)
+        ) {
+            foreach ($conditions as $formula) {
+                if (is_bool($formula)) {
+                    $formula = $formula ? 'TRUE' : 'FALSE';
+                }
+                $objWriter->writeElement('formula', FunctionPrefix::addFunctionPrefix("$formula"));
+            }
+        } else {
+            if ($conditional->getConditionType() == Conditional::CONDITION_CONTAINSBLANKS) {
+                $objWriter->writeElement('formula', 'LEN(TRIM(' . $cellCoordinate . '))=0');
+            } elseif ($conditional->getConditionType() == Conditional::CONDITION_NOTCONTAINSBLANKS) {
+                $objWriter->writeElement('formula', 'LEN(TRIM(' . $cellCoordinate . '))>0');
+            } elseif ($conditional->getConditionType() == Conditional::CONDITION_CONTAINSERRORS) {
+                $objWriter->writeElement('formula', 'ISERROR(' . $cellCoordinate . ')');
+            } elseif ($conditional->getConditionType() == Conditional::CONDITION_NOTCONTAINSERRORS) {
+                $objWriter->writeElement('formula', 'NOT(ISERROR(' . $cellCoordinate . '))');
+            }
+        }
+    }
+    private static function writeTimePeriodCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
+    {
+        $txt = $conditional->getText();
+        if (!empty($txt)) {
+            $objWriter->writeAttribute('timePeriod', $txt);
+            if (empty($conditional->getConditions())) {
+                if ($conditional->getOperatorType() == Conditional::TIMEPERIOD_TODAY) {
+                    $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_TOMORROW) {
+                    $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()+1');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_YESTERDAY) {
+                    $objWriter->writeElement('formula', 'FLOOR(' . $cellCoordinate . ')=TODAY()-1');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_7_DAYS) {
+                    $objWriter->writeElement('formula', 'AND(TODAY()-FLOOR(' . $cellCoordinate . ',1)<=6,FLOOR(' . $cellCoordinate . ',1)<=TODAY())');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_WEEK) {
+                    $objWriter->writeElement('formula', 'AND(TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)<(WEEKDAY(TODAY())+7))');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_THIS_WEEK) {
+                    $objWriter->writeElement('formula', 'AND(TODAY()-ROUNDDOWN(' . $cellCoordinate . ',0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()<=7-WEEKDAY(TODAY()))');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_NEXT_WEEK) {
+                    $objWriter->writeElement('formula', 'AND(ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(' . $cellCoordinate . ',0)-TODAY()<(15-WEEKDAY(TODAY())))');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_LAST_MONTH) {
+                    $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(EDATE(TODAY(),0-1)),YEAR(' . $cellCoordinate . ')=YEAR(EDATE(TODAY(),0-1)))');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_THIS_MONTH) {
+                    $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(TODAY()),YEAR(' . $cellCoordinate . ')=YEAR(TODAY()))');
+                } elseif ($conditional->getOperatorType() == Conditional::TIMEPERIOD_NEXT_MONTH) {
+                    $objWriter->writeElement('formula', 'AND(MONTH(' . $cellCoordinate . ')=MONTH(EDATE(TODAY(),0+1)),YEAR(' . $cellCoordinate . ')=YEAR(EDATE(TODAY(),0+1)))');
+                }
+            } else {
+                $objWriter->writeElement('formula', (string) ($conditional->getConditions()[0]));
+            }
+        }
+    }
+    private static function writeTextCondElements(XMLWriter $objWriter, Conditional $conditional, string $cellCoordinate): void
+    {
+        $txt = $conditional->getText();
+        if (!empty($txt)) {
+            $objWriter->writeAttribute('text', $txt);
+            if (empty($conditional->getConditions())) {
+                if ($conditional->getOperatorType() == Conditional::OPERATOR_CONTAINSTEXT) {
+                    $objWriter->writeElement('formula', 'NOT(ISERROR(SEARCH("' . $txt . '",' . $cellCoordinate . ')))');
+                } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_BEGINSWITH) {
+                    $objWriter->writeElement('formula', 'LEFT(' . $cellCoordinate . ',LEN("' . $txt . '"))="' . $txt . '"');
+                } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_ENDSWITH) {
+                    $objWriter->writeElement('formula', 'RIGHT(' . $cellCoordinate . ',LEN("' . $txt . '"))="' . $txt . '"');
+                } elseif ($conditional->getOperatorType() == Conditional::OPERATOR_NOTCONTAINS) {
+                    $objWriter->writeElement('formula', 'ISERROR(SEARCH("' . $txt . '",' . $cellCoordinate . '))');
+                }
+            } else {
+                $objWriter->writeElement('formula', (string) ($conditional->getConditions()[0]));
+            }
+        }
+    }
+    private static function writeExtConditionalFormattingElements(XMLWriter $objWriter, ConditionalFormattingRuleExtension $ruleExtension): void
+    {
+        $prefix = 'x14';
+        $objWriter->startElementNs($prefix, 'conditionalFormatting', null);
+        $objWriter->startElementNs($prefix, 'cfRule', null);
+        $objWriter->writeAttribute('type', $ruleExtension->getCfRule());
+        $objWriter->writeAttribute('id', $ruleExtension->getId());
+        $objWriter->startElementNs($prefix, 'dataBar', null);
+        $dataBar = $ruleExtension->getDataBarExt();
+        foreach ($dataBar->getXmlAttributes() as $attrKey => $val) {
+            $objWriter->writeAttribute($attrKey, $val);
+        }
+        $minCfvo = $dataBar->getMinimumConditionalFormatValueObject();
+        if ($minCfvo !== null) {
+            $objWriter->startElementNs($prefix, 'cfvo', null);
+            $objWriter->writeAttribute('type', $minCfvo->getType());
+            if ($minCfvo->getCellFormula()) {
+                $objWriter->writeElement('xm:f', $minCfvo->getCellFormula());
+            }
+            $objWriter->endElement(); //end cfvo
+        }
+        $maxCfvo = $dataBar->getMaximumConditionalFormatValueObject();
+        if ($maxCfvo !== null) {
+            $objWriter->startElementNs($prefix, 'cfvo', null);
+            $objWriter->writeAttribute('type', $maxCfvo->getType());
+            if ($maxCfvo->getCellFormula()) {
+                $objWriter->writeElement('xm:f', $maxCfvo->getCellFormula());
+            }
+            $objWriter->endElement(); //end cfvo
+        }
+        foreach ($dataBar->getXmlElements() as $elmKey => $elmAttr) {
+            $objWriter->startElementNs($prefix, $elmKey, null);
+            foreach ($elmAttr as $attrKey => $attrVal) {
+                $objWriter->writeAttribute($attrKey, $attrVal);
+            }
+            $objWriter->endElement(); //end elmKey
+        }
+        $objWriter->endElement(); //end dataBar
+        $objWriter->endElement(); //end cfRule
+        $objWriter->writeElement('xm:sqref', $ruleExtension->getSqref());
+        $objWriter->endElement(); //end conditionalFormatting
+    }
+    private static function writeDataBarElements(XMLWriter $objWriter, ?ConditionalDataBar $dataBar): void
+    {
+        if ($dataBar) {
+            $objWriter->startElement('dataBar');
+            self::writeAttributeIf($objWriter, null !== $dataBar->getShowValue(), 'showValue', $dataBar->getShowValue() ? '1' : '0');
+            $minCfvo = $dataBar->getMinimumConditionalFormatValueObject();
+            if ($minCfvo) {
+                $objWriter->startElement('cfvo');
+                $objWriter->writeAttribute('type', $minCfvo->getType());
+                self::writeAttributeIf($objWriter, $minCfvo->getValue() !== null, 'val', (string) $minCfvo->getValue());
+                $objWriter->endElement();
+            }
+            $maxCfvo = $dataBar->getMaximumConditionalFormatValueObject();
+            if ($maxCfvo) {
+                $objWriter->startElement('cfvo');
+                $objWriter->writeAttribute('type', $maxCfvo->getType());
+                self::writeAttributeIf($objWriter, $maxCfvo->getValue() !== null, 'val', (string) $maxCfvo->getValue());
+                $objWriter->endElement();
+            }
+            if ($dataBar->getColor()) {
+                $objWriter->startElement('color');
+                $objWriter->writeAttribute('rgb', $dataBar->getColor());
+                $objWriter->endElement();
+            }
+            $objWriter->endElement(); // end dataBar
+            if ($dataBar->getConditionalFormattingRuleExt()) {
+                $objWriter->startElement('extLst');
+                $extension = $dataBar->getConditionalFormattingRuleExt();
+                $objWriter->startElement('ext');
+                $objWriter->writeAttribute('uri', '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}');
+                $objWriter->startElementNs('x14', 'id', null);
+                $objWriter->text($extension->getId());
+                $objWriter->endElement();
+                $objWriter->endElement();
+                $objWriter->endElement(); //end extLst
+            }
+        }
+    }
+    private static function writeColorScaleElements(XMLWriter $objWriter, ?ConditionalColorScale $colorScale): void
+    {
+        if ($colorScale) {
+            $objWriter->startElement('colorScale');
+            $minCfvo = $colorScale->getMinimumConditionalFormatValueObject();
+            $minArgb = $colorScale->getMinimumColor()?->getARGB();
+            $useMin = $minCfvo !== null || $minArgb !== null;
+            if ($useMin) {
+                $objWriter->startElement('cfvo');
+                $type = 'min';
+                $value = null;
+                if ($minCfvo !== null) {
+                    $typex = $minCfvo->getType();
+                    if ($typex === 'formula') {
+                        $value = $minCfvo->getCellFormula();
+                        if ($value !== null) {
+                            $type = $typex;
+                        }
+                    } else {
+                        $type = $typex;
+                        $defaults = ['number' => '0', 'percent' => '0', 'percentile' => '10'];
+                        $value = $minCfvo->getValue() ?? $defaults[$type] ?? null;
+                    }
+                }
+                $objWriter->writeAttribute('type', $type);
+                self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
+                $objWriter->endElement();
+            }
+            $midCfvo = $colorScale->getMidpointConditionalFormatValueObject();
+            $midArgb = $colorScale->getMidpointColor()?->getARGB();
+            $useMid = $midCfvo !== null || $midArgb !== null;
+            if ($useMid) {
+                $objWriter->startElement('cfvo');
+                $type = 'percentile';
+                $value = '50';
+                if ($midCfvo !== null) {
+                    $type = $midCfvo->getType();
+                    if ($type === 'formula') {
+                        $value = $midCfvo->getCellFormula();
+                        if ($value === null) {
+                            $type = 'percentile';
+                            $value = '50';
+                        }
+                    } else {
+                        $defaults = ['number' => '0', 'percent' => '50', 'percentile' => '50'];
+                        $value = $midCfvo->getValue() ?? $defaults[$type] ?? null;
+                    }
+                }
+                $objWriter->writeAttribute('type', $type);
+                self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
+                $objWriter->endElement();
+            }
+            $maxCfvo = $colorScale->getMaximumConditionalFormatValueObject();
+            $maxArgb = $colorScale->getMaximumColor()?->getARGB();
+            $useMax = $maxCfvo !== null || $maxArgb !== null;
+            if ($useMax) {
+                $objWriter->startElement('cfvo');
+                $type = 'max';
+                $value = null;
+                if ($maxCfvo !== null) {
+                    $typex = $maxCfvo->getType();
+                    if ($typex === 'formula') {
+                        $value = $maxCfvo->getCellFormula();
+                        if ($value !== null) {
+                            $type = $typex;
+                        }
+                    } else {
+                        $type = $typex;
+                        $defaults = ['number' => '0', 'percent' => '100', 'percentile' => '90'];
+                        $value = $maxCfvo->getValue() ?? $defaults[$type] ?? null;
+                    }
+                }
+                $objWriter->writeAttribute('type', $type);
+                self::writeAttributeIf($objWriter, $value !== null, 'val', (string) $value);
+                $objWriter->endElement();
+            }
+            if ($useMin) {
+                $objWriter->startElement('color');
+                self::writeAttributeIf($objWriter, $minArgb !== null, 'rgb', "$minArgb");
+                $objWriter->endElement();
+            }
+            if ($useMid) {
+                $objWriter->startElement('color');
+                self::writeAttributeIf($objWriter, $midArgb !== null, 'rgb', "$midArgb");
+                $objWriter->endElement();
+            }
+            if ($useMax) {
+                $objWriter->startElement('color');
+                self::writeAttributeIf($objWriter, $maxArgb !== null, 'rgb', "$maxArgb");
+                $objWriter->endElement();
+            }
+            $objWriter->endElement(); // end colorScale
+        }
+    }
+    /**
+     * Write ConditionalFormatting.
+     */
+    private function writeConditionalFormatting(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $id = 1;
+        foreach ($worksheet->getConditionalStylesCollection() as $cellCoordinate => $conditionalStyles) {
+            $objWriter->startElement('conditionalFormatting');
+            $outCoordinate = Coordinate::resolveUnionAndIntersection(str_replace('$', '', $cellCoordinate), ' ');
+            $objWriter->writeAttribute('sqref', $outCoordinate);
+            foreach ($conditionalStyles as $conditional) {
+                $objWriter->startElement('cfRule');
+                $objWriter->writeAttribute('type', $conditional->getConditionType());
+                self::writeAttributeIf(
+                    $objWriter,
+                    ($conditional->getConditionType() !== Conditional::CONDITION_COLORSCALE
+                        && $conditional->getConditionType() !== Conditional::CONDITION_DATABAR
+                        && $conditional->getNoFormatSet() === false),
+                    'dxfId',
+                    (string) $this->getParentWriter()->getStylesConditionalHashTable()->getIndexForHashCode($conditional->getHashCode())
+                );
+                $objWriter->writeAttribute('priority', (string) $id++);
+                self::writeAttributeif(
+                    $objWriter,
+                    (
+                        $conditional->getConditionType() === Conditional::CONDITION_CELLIS
+                        || $conditional->getConditionType() === Conditional::CONDITION_CONTAINSTEXT
+                        || $conditional->getConditionType() === Conditional::CONDITION_NOTCONTAINSTEXT
+                        || $conditional->getConditionType() === Conditional::CONDITION_BEGINSWITH
+                        || $conditional->getConditionType() === Conditional::CONDITION_ENDSWITH
+                    ) && $conditional->getOperatorType() !== Conditional::OPERATOR_NONE,
+                    'operator',
+                    $conditional->getOperatorType()
+                );
+                self::writeAttributeIf($objWriter, $conditional->getStopIfTrue(), 'stopIfTrue', '1');
+                $cellRange = Coordinate::splitRange(str_replace('$', '', strtoupper($cellCoordinate)));
+                [$topLeftCell] = $cellRange[0];
+                if (
+                    $conditional->getConditionType() === Conditional::CONDITION_CONTAINSTEXT
+                    || $conditional->getConditionType() === Conditional::CONDITION_NOTCONTAINSTEXT
+                    || $conditional->getConditionType() === Conditional::CONDITION_BEGINSWITH
+                    || $conditional->getConditionType() === Conditional::CONDITION_ENDSWITH
+                ) {
+                    self::writeTextCondElements($objWriter, $conditional, $topLeftCell);
+                } elseif ($conditional->getConditionType() === Conditional::CONDITION_TIMEPERIOD) {
+                    self::writeTimePeriodCondElements($objWriter, $conditional, $topLeftCell);
+                } elseif ($conditional->getConditionType() === Conditional::CONDITION_COLORSCALE) {
+                    self::writeColorScaleElements($objWriter, $conditional->getColorScale());
+                } else {
+                    self::writeOtherCondElements($objWriter, $conditional, $topLeftCell);
+                }
+                self::writeDataBarElements($objWriter, $conditional->getDataBar());
+                $objWriter->endElement(); //end cfRule
+            }
+            $objWriter->endElement(); //end conditionalFormatting
+        }
+    }
+    /**
+     * Write DataValidations.
+     */
+    private function writeDataValidations(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $dataValidationCollection = $worksheet->getDataValidationCollection();
+        if (!empty($dataValidationCollection)) {
+            $dataValidationCollection = Coordinate::mergeRangesInCollection($dataValidationCollection);
+            $objWriter->startElement('dataValidations');
+            $objWriter->writeAttribute('count', (string) count($dataValidationCollection));
+            foreach ($dataValidationCollection as $coordinate => $dv) {
+                $objWriter->startElement('dataValidation');
+                if ($dv->getType() != '') {
+                    $objWriter->writeAttribute('type', $dv->getType());
+                }
+                if ($dv->getErrorStyle() != '') {
+                    $objWriter->writeAttribute('errorStyle', $dv->getErrorStyle());
+                }
+                if ($dv->getOperator() != '') {
+                    $objWriter->writeAttribute('operator', $dv->getOperator());
+                }
+                $objWriter->writeAttribute('allowBlank', ($dv->getAllowBlank() ? '1' : '0'));
+                $objWriter->writeAttribute('showDropDown', (!$dv->getShowDropDown() ? '1' : '0'));
+                $objWriter->writeAttribute('showInputMessage', ($dv->getShowInputMessage() ? '1' : '0'));
+                $objWriter->writeAttribute('showErrorMessage', ($dv->getShowErrorMessage() ? '1' : '0'));
+                if ($dv->getErrorTitle() !== '') {
+                    $objWriter->writeAttribute('errorTitle', $dv->getErrorTitle());
+                }
+                if ($dv->getError() !== '') {
+                    $objWriter->writeAttribute('error', $dv->getError());
+                }
+                if ($dv->getPromptTitle() !== '') {
+                    $objWriter->writeAttribute('promptTitle', $dv->getPromptTitle());
+                }
+                if ($dv->getPrompt() !== '') {
+                    $objWriter->writeAttribute('prompt', $dv->getPrompt());
+                }
+                $objWriter->writeAttribute('sqref', $dv->getSqref() ?? $coordinate);
+                if ($dv->getFormula1() !== '') {
+                    $objWriter->writeElement('formula1', $dv->getFormula1());
+                }
+                if ($dv->getFormula2() !== '') {
+                    $objWriter->writeElement('formula2', $dv->getFormula2());
+                }
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write Hyperlinks.
+     */
+    private function writeHyperlinks(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $hyperlinkCollection = $worksheet->getHyperlinkCollection();
+        $relationId = 1;
+        if (!empty($hyperlinkCollection)) {
+            $objWriter->startElement('hyperlinks');
+            foreach ($hyperlinkCollection as $coordinate => $hyperlink) {
+                $objWriter->startElement('hyperlink');
+                $objWriter->writeAttribute('ref', $coordinate);
+                if (!$hyperlink->isInternal()) {
+                    $objWriter->writeAttribute('r:id', 'rId_hyperlink_' . $relationId);
+                    ++$relationId;
+                } else {
+                    $objWriter->writeAttribute('location', str_replace('sheet://', '', $hyperlink->getUrl()));
+                }
+                if ($hyperlink->getTooltip() !== '') {
+                    $objWriter->writeAttribute('tooltip', $hyperlink->getTooltip());
+                    $objWriter->writeAttribute('display', $hyperlink->getTooltip());
+                }
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write ProtectedRanges.
+     */
+    private function writeProtectedRanges(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if (count($worksheet->getProtectedCellRanges()) > 0) {
+            $objWriter->startElement('protectedRanges');
+            foreach ($worksheet->getProtectedCellRanges() as $protectedCell => $protectedRange) {
+                $objWriter->startElement('protectedRange');
+                $objWriter->writeAttribute('name', $protectedRange->getName());
+                $objWriter->writeAttribute('sqref', $protectedCell);
+                $passwordHash = $protectedRange->getPassword();
+                $this->writeAttributeIf($objWriter, $passwordHash !== '', 'password', $passwordHash);
+                $securityDescriptor = $protectedRange->getSecurityDescriptor();
+                $this->writeAttributeIf($objWriter, $securityDescriptor !== '', 'securityDescriptor', $securityDescriptor);
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write MergeCells.
+     */
+    private function writeMergeCells(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if (count($worksheet->getMergeCells()) > 0) {
+            $objWriter->startElement('mergeCells');
+            foreach ($worksheet->getMergeCells() as $mergeCell) {
+                $objWriter->startElement('mergeCell');
+                $objWriter->writeAttribute('ref', $mergeCell);
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write PrintOptions.
+     */
+    private function writePrintOptions(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('printOptions');
+        $objWriter->writeAttribute('gridLines', ($worksheet->getPrintGridlines() ? 'true' : 'false'));
+        $objWriter->writeAttribute('gridLinesSet', 'true');
+        if ($worksheet->getPageSetup()->getHorizontalCentered()) {
+            $objWriter->writeAttribute('horizontalCentered', 'true');
+        }
+        if ($worksheet->getPageSetup()->getVerticalCentered()) {
+            $objWriter->writeAttribute('verticalCentered', 'true');
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write PageMargins.
+     */
+    private function writePageMargins(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('pageMargins');
+        $objWriter->writeAttribute('left', StringHelper::formatNumber($worksheet->getPageMargins()->getLeft()));
+        $objWriter->writeAttribute('right', StringHelper::formatNumber($worksheet->getPageMargins()->getRight()));
+        $objWriter->writeAttribute('top', StringHelper::formatNumber($worksheet->getPageMargins()->getTop()));
+        $objWriter->writeAttribute('bottom', StringHelper::formatNumber($worksheet->getPageMargins()->getBottom()));
+        $objWriter->writeAttribute('header', StringHelper::formatNumber($worksheet->getPageMargins()->getHeader()));
+        $objWriter->writeAttribute('footer', StringHelper::formatNumber($worksheet->getPageMargins()->getFooter()));
+        $objWriter->endElement();
+    }
+    /**
+     * Write AutoFilter.
+     */
+    private function writeAutoFilter(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        AutoFilter::writeAutoFilter($objWriter, $worksheet);
+    }
+    /**
+     * Write Table.
+     */
+    private function writeTable(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $tableCount = $worksheet->getTableCollection()->count();
+        if ($tableCount === 0) {
+            return;
+        }
+        $objWriter->startElement('tableParts');
+        $objWriter->writeAttribute('count', (string) $tableCount);
+        for ($t = 1; $t <= $tableCount; ++$t) {
+            $objWriter->startElement('tablePart');
+            $objWriter->writeAttribute('r:id', 'rId_table_' . $t);
+            $objWriter->endElement();
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write Background Image.
+     */
+    private function writeBackgroundImage(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if ($worksheet->getBackgroundImage() !== '') {
+            $objWriter->startElement('picture');
+            $objWriter->writeAttribute('r:id', 'rIdBg');
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write PageSetup.
+     */
+    private function writePageSetup(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $objWriter->startElement('pageSetup');
+        $objWriter->writeAttribute('paperSize', (string) $worksheet->getPageSetup()->getPaperSize());
+        $objWriter->writeAttribute('orientation', $worksheet->getPageSetup()->getOrientation());
+        if ($worksheet->getPageSetup()->getScale() !== null) {
+            $objWriter->writeAttribute('scale', (string) $worksheet->getPageSetup()->getScale());
+        }
+        if ($worksheet->getPageSetup()->getFitToHeight() !== null) {
+            $objWriter->writeAttribute('fitToHeight', (string) $worksheet->getPageSetup()->getFitToHeight());
+        } else {
+            $objWriter->writeAttribute('fitToHeight', '0');
+        }
+        if ($worksheet->getPageSetup()->getFitToWidth() !== null) {
+            $objWriter->writeAttribute('fitToWidth', (string) $worksheet->getPageSetup()->getFitToWidth());
+        } else {
+            $objWriter->writeAttribute('fitToWidth', '0');
+        }
+        if (!empty($worksheet->getPageSetup()->getFirstPageNumber())) {
+            $objWriter->writeAttribute('firstPageNumber', (string) $worksheet->getPageSetup()->getFirstPageNumber());
+            $objWriter->writeAttribute('useFirstPageNumber', '1');
+        }
+        $objWriter->writeAttribute('pageOrder', $worksheet->getPageSetup()->getPageOrder());
+        $getUnparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
+        if (isset($getUnparsedLoadedData['sheets'][$worksheet->getCodeName()]['pageSetupRelId'])) {
+            $objWriter->writeAttribute('r:id', $getUnparsedLoadedData['sheets'][$worksheet->getCodeName()]['pageSetupRelId']);
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write Header / Footer.
+     */
+    private function writeHeaderFooter(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $headerFooter = $worksheet->getHeaderFooter();
+        $oddHeader = $headerFooter->getOddHeader();
+        $oddFooter = $headerFooter->getOddFooter();
+        $evenHeader = $headerFooter->getEvenHeader();
+        $evenFooter = $headerFooter->getEvenFooter();
+        $firstHeader = $headerFooter->getFirstHeader();
+        $firstFooter = $headerFooter->getFirstFooter();
+        if ("$oddHeader$oddFooter$evenHeader$evenFooter$firstHeader$firstFooter" === '') {
+            return;
+        }
+        $objWriter->startElement('headerFooter');
+        $objWriter->writeAttribute('differentOddEven', ($worksheet->getHeaderFooter()->getDifferentOddEven() ? 'true' : 'false'));
+        $objWriter->writeAttribute('differentFirst', ($worksheet->getHeaderFooter()->getDifferentFirst() ? 'true' : 'false'));
+        $objWriter->writeAttribute('scaleWithDoc', ($worksheet->getHeaderFooter()->getScaleWithDocument() ? 'true' : 'false'));
+        $objWriter->writeAttribute('alignWithMargins', ($worksheet->getHeaderFooter()->getAlignWithMargins() ? 'true' : 'false'));
+        self::writeElementIf($objWriter, $oddHeader !== '', 'oddHeader', $oddHeader);
+        self::writeElementIf($objWriter, $oddFooter !== '', 'oddFooter', $oddFooter);
+        self::writeElementIf($objWriter, $evenHeader !== '', 'evenHeader', $evenHeader);
+        self::writeElementIf($objWriter, $evenFooter !== '', 'evenFooter', $evenFooter);
+        self::writeElementIf($objWriter, $firstHeader !== '', 'firstHeader', $firstHeader);
+        self::writeElementIf($objWriter, $firstFooter !== '', 'firstFooter', $firstFooter);
+        $objWriter->endElement(); // headerFooter
+    }
+    /**
+     * Write Breaks.
+     */
+    private function writeBreaks(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $aRowBreaks = [];
+        $aColumnBreaks = [];
+        foreach ($worksheet->getRowBreaks() as $cell => $break) {
+            $aRowBreaks[$cell] = $break;
+        }
+        foreach ($worksheet->getColumnBreaks() as $cell => $break) {
+            $aColumnBreaks[$cell] = $break;
+        }
+        if (!empty($aRowBreaks)) {
+            $objWriter->startElement('rowBreaks');
+            $objWriter->writeAttribute('count', (string) count($aRowBreaks));
+            $objWriter->writeAttribute('manualBreakCount', (string) count($aRowBreaks));
+            foreach ($aRowBreaks as $cell => $break) {
+                $coords = Coordinate::coordinateFromString($cell);
+                $objWriter->startElement('brk');
+                $objWriter->writeAttribute('id', $coords[1]);
+                $objWriter->writeAttribute('man', '1');
+                $rowBreakMax = $break->getMaxColOrRow();
+                if ($rowBreakMax >= 0) {
+                    $objWriter->writeAttribute('max', "$rowBreakMax");
+                }
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+        if (!empty($aColumnBreaks)) {
+            $objWriter->startElement('colBreaks');
+            $objWriter->writeAttribute('count', (string) count($aColumnBreaks));
+            $objWriter->writeAttribute('manualBreakCount', (string) count($aColumnBreaks));
+            foreach ($aColumnBreaks as $cell => $break) {
+                $coords = Coordinate::indexesFromString($cell);
+                $objWriter->startElement('brk');
+                $objWriter->writeAttribute('id', (string) ((int) $coords[0] - 1));
+                $objWriter->writeAttribute('man', '1');
+                $objWriter->endElement();
+            }
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write SheetData.
+     *
+     * @param string[] $stringTable String table
+     */
+    private function writeSheetData(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, array $stringTable): void
+    {
+        $aFlippedStringTable = $this->getParentWriter()->getWriterPartstringtable()->flipStringTable($stringTable);
+        $objWriter->startElement('sheetData');
+        $colCount = Coordinate::columnIndexFromString($worksheet->getHighestColumn());
+        $highestRow = $worksheet->getHighestRow();
+        /** @var array<int, string> $cellsByRow */
+        $cellsByRow = [];
+        foreach ($worksheet->getCoordinates() as $coordinate) {
+            [$column, $row] = Coordinate::coordinateFromString($coordinate);
+            $cellsByRow[$row] = $cellsByRow[$row] ?? '';
+            $cellsByRow[$row] .= "{$column},";
+        }
+        $currentRow = 0;
+        $emptyDimension = new RowDimension();
+        while ($currentRow++ < $highestRow) {
+            $isRowSet = isset($cellsByRow[$currentRow]);
+            if ($isRowSet || $worksheet->rowDimensionExists($currentRow)) {
+                $rowDimension = $worksheet->rowDimensionExists($currentRow) ? $worksheet->getRowDimension($currentRow) : $emptyDimension;
+                $writeCurrentRow = $isRowSet || $rowDimension->getRowHeight() >= 0 || $rowDimension->getVisible() === false || $rowDimension->getCollapsed() === true || $rowDimension->getOutlineLevel() > 0 || $rowDimension->getXfIndex() !== null;
+                if ($writeCurrentRow) {
+                    $objWriter->startElement('row');
+                    $objWriter->writeAttribute('r', "$currentRow");
+                    $objWriter->writeAttribute('spans', '1:' . $colCount);
+                    if ($rowDimension->getRowHeight() >= 0) {
+                        $objWriter->writeAttribute('customHeight', '1');
+                        $objWriter->writeAttribute('ht', StringHelper::formatNumber($rowDimension->getRowHeight()));
+                    }
+                    if (!$rowDimension->getVisible() === true) {
+                        $objWriter->writeAttribute('hidden', 'true');
+                    }
+                    if ($rowDimension->getCollapsed() === true) {
+                        $objWriter->writeAttribute('collapsed', 'true');
+                    }
+                    if ($rowDimension->getOutlineLevel() > 0) {
+                        $objWriter->writeAttribute('outlineLevel', (string) $rowDimension->getOutlineLevel());
+                    }
+                    if ($rowDimension->getXfIndex() !== null) {
+                        $objWriter->writeAttribute('s', (string) $rowDimension->getXfIndex());
+                        $objWriter->writeAttribute('customFormat', '1');
+                    }
+                    if (isset($cellsByRow[$currentRow])) {
+                        $columnsInRow = explode(',', $cellsByRow[$currentRow]);
+                        array_pop($columnsInRow);
+                        foreach ($columnsInRow as $column) {
+                            $coord = "$column$currentRow";
+                            if ($worksheet->getCell($coord)->getIgnoredErrors()->getNumberStoredAsText()) {
+                                $this->numberStoredAsText .= " $coord";
+                            }
+                            if ($worksheet->getCell($coord)->getIgnoredErrors()->getFormula()) {
+                                $this->formula .= " $coord";
+                            }
+                            if ($worksheet->getCell($coord)->getIgnoredErrors()->getTwoDigitTextYear()) {
+                                $this->twoDigitTextYear .= " $coord";
+                            }
+                            if ($worksheet->getCell($coord)->getIgnoredErrors()->getEvalError()) {
+                                $this->evalError .= " $coord";
+                            }
+                            $this->writeCell($objWriter, $worksheet, $coord, $aFlippedStringTable);
+                        }
+                    }
+                    $objWriter->endElement();
+                }
+            }
+        }
+        $objWriter->endElement();
+    }
+    private function writeCellInlineStr(XMLWriter $objWriter, string $mappedType, RichText|string $cellValue): void
+    {
+        $objWriter->writeAttribute('t', $mappedType);
+        if (!$cellValue instanceof RichText) {
+            $objWriter->startElement('is');
+            $objWriter->writeElement(
+                't',
+                StringHelper::controlCharacterPHP2OOXML(htmlspecialchars($cellValue, Settings::htmlEntityFlags()))
+            );
+            $objWriter->endElement();
+        } else {
+            $objWriter->startElement('is');
+            $this->getParentWriter()->getWriterPartstringtable()->writeRichText($objWriter, $cellValue);
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * @param string[] $flippedStringTable
+     */
+    private function writeCellString(XMLWriter $objWriter, string $mappedType, RichText|string $cellValue, array $flippedStringTable): void
+    {
+        $objWriter->writeAttribute('t', $mappedType);
+        if (!$cellValue instanceof RichText) {
+            self::writeElementIf($objWriter, isset($flippedStringTable[$cellValue]), 'v', $flippedStringTable[$cellValue] ?? '');
+        } else {
+            $objWriter->writeElement('v', $flippedStringTable[$cellValue->getHashCode()]);
+        }
+    }
+    private function writeCellNumeric(XMLWriter $objWriter, float|int $cellValue): void
+    {
+        if (is_float($cellValue)) {
+            $cellValue = str_replace(',', '.', (string) $cellValue);
+            if (!str_contains($cellValue, '.')) {
+                $cellValue = $cellValue . '.0';
+            }
+        }
+        $objWriter->writeElement('v', "$cellValue");
+    }
+    private function writeCellBoolean(XMLWriter $objWriter, string $mappedType, bool $cellValue): void
+    {
+        $objWriter->writeAttribute('t', $mappedType);
+        $objWriter->writeElement('v', $cellValue ? '1' : '0');
+    }
+    private function writeCellError(XMLWriter $objWriter, string $mappedType, string $cellValue, string $formulaerr = '#NULL!'): void
+    {
+        $objWriter->writeAttribute('t', $mappedType);
+        $cellIsFormula = str_starts_with($cellValue, '=');
+        self::writeElementIf($objWriter, $cellIsFormula, 'f', FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
+        $objWriter->writeElement('v', $cellIsFormula ? $formulaerr : $cellValue);
+    }
+    private function writeCellFormula(XMLWriter $objWriter, string $cellValue, Cell $cell): void
+    {
+        $calculatedValue = $this->getParentWriter()->getPreCalculateFormulas() ? $cell->getCalculatedValue() : $cellValue;
+        $calculatedValueString = $this->getParentWriter()->getPreCalculateFormulas() ? $cell->getCalculatedValueString() : $cellValue;
+        if (is_string($calculatedValue)) {
+            if (ErrorValue::isError($calculatedValue)) {
+                $this->writeCellError($objWriter, 'e', $cellValue, $calculatedValue);
+                return;
+            }
+            $objWriter->writeAttribute('t', 'str');
+            $calculatedValue = StringHelper::controlCharacterPHP2OOXML($calculatedValue);
+            $calculatedValueString = $calculatedValue;
+        } elseif (is_bool($calculatedValue)) {
+            $objWriter->writeAttribute('t', 'b');
+            $calculatedValue = (int) $calculatedValue;
+            $calculatedValueString = (string) $calculatedValue;
+        }
+        $attributes = $cell->getFormulaAttributes();
+        if (is_array($attributes) && ($attributes['t'] ?? null) === 'array') {
+            $objWriter->startElement('f');
+            $objWriter->writeAttribute('t', 'array');
+            $objWriter->writeAttribute('ref', $cell->getCoordinate());
+            $objWriter->writeAttribute('aca', '1');
+            $objWriter->writeAttribute('ca', '1');
+            $objWriter->text(FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
+            $objWriter->endElement();
+        } else {
+            $objWriter->writeElement('f', FunctionPrefix::addFunctionPrefixStripEquals($cellValue));
+            self::writeElementIf(
+                $objWriter,
+                $this->getParentWriter()->getOffice2003Compatibility() === false
+                && $this->getParentWriter()->getPreCalculateFormulas()
+                && $calculatedValue !== null,
+                'v',
+                (!is_array($calculatedValue) && !str_starts_with($calculatedValueString, '#'))
+                    ? StringHelper::formatNumber($calculatedValueString) : '0'
+            );
+        }
+    }
+    /**
+     * Write Cell.
+     *
+     * @param string $cellAddress Cell Address
+     * @param string[] $flippedStringTable String table (flipped), for faster index searching
+     */
+    private function writeCell(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, string $cellAddress, array $flippedStringTable): void
+    {
+        $pCell = $worksheet->getCell($cellAddress);
+        $xfi = $pCell->getXfIndex();
+        $cellValue = $pCell->getValue();
+        $cellValueString = $pCell->getValueString();
+        $writeValue = $cellValue !== '' && $cellValue !== null;
+        if (empty($xfi) && !$writeValue) {
+            return;
+        }
+        $objWriter->startElement('c');
+        $objWriter->writeAttribute('r', $cellAddress);
+        if ($xfi) {
+            $objWriter->writeAttribute('s', "$xfi");
+        } elseif ($this->explicitStyle0) {
+            $objWriter->writeAttribute('s', '0');
+        }
+        if ($writeValue) {
+            $mappedType = $pCell->getDataType();
+            switch (strtolower($mappedType)) {
+                case 'inlinestr':    // Inline string
+                    /** @var RichText|string */
+                    $richText = $cellValue;
+                    $this->writeCellInlineStr($objWriter, $mappedType, $richText);
+                    break;
+                case 's':            // String
+                    $this->writeCellString($objWriter, $mappedType, ($cellValue instanceof RichText) ? $cellValue : $cellValueString, $flippedStringTable);
+                    break;
+                case 'f':            // Formula
+                    $this->writeCellFormula($objWriter, $cellValueString, $pCell);
+                    break;
+                case 'n':            // Numeric
+                    $cellValueNumeric = is_numeric($cellValue) ? ($cellValue + 0) : 0;
+                    $this->writeCellNumeric($objWriter, $cellValueNumeric);
+                    break;
+                case 'b':            // Boolean
+                    $this->writeCellBoolean($objWriter, $mappedType, (bool) $cellValue);
+                    break;
+                case 'e':            // Error
+                    $this->writeCellError($objWriter, $mappedType, $cellValueString);
+            }
+        }
+        $objWriter->endElement();
+    }
+    /**
+     * Write Drawings.
+     *
+     * @param bool $includeCharts Flag indicating if we should include drawing details for charts
+     */
+    private function writeDrawings(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet, bool $includeCharts = false): void
+    {
+        $unparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
+        $hasUnparsedDrawing = isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds']);
+        $chartCount = ($includeCharts) ? $worksheet->getChartCollection()->count() : 0;
+        if ($chartCount == 0 && $worksheet->getDrawingCollection()->count() == 0 && !$hasUnparsedDrawing) {
+            return;
+        }
+        $objWriter->startElement('drawing');
+        $rId = 'rId1';
+        if (isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds'])) {
+            $drawingOriginalIds = $unparsedLoadedData['sheets'][$worksheet->getCodeName()]['drawingOriginalIds'];
+            $rId = reset($drawingOriginalIds);
+        }
+        $objWriter->writeAttribute('r:id', $rId);
+        $objWriter->endElement();
+    }
+    /**
+     * Write LegacyDrawing.
+     */
+    private function writeLegacyDrawing(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $unparsedLoadedData = $worksheet->getParentOrThrow()->getUnparsedLoadedData();
+        if (count($worksheet->getComments()) > 0 || isset($unparsedLoadedData['sheets'][$worksheet->getCodeName()]['legacyDrawing'])) {
+            $objWriter->startElement('legacyDrawing');
+            $objWriter->writeAttribute('r:id', 'rId_comments_vml1');
+            $objWriter->endElement();
+        }
+    }
+    /**
+     * Write LegacyDrawingHF.
+     */
+    private function writeLegacyDrawingHF(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if (count($worksheet->getHeaderFooter()->getImages()) > 0) {
+            $objWriter->startElement('legacyDrawingHF');
+            $objWriter->writeAttribute('r:id', 'rId_headerfooter_vml1');
+            $objWriter->endElement();
+        }
+    }
+    private function writeAlternateContent(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        if (empty($worksheet->getParentOrThrow()->getUnparsedLoadedData()['sheets'][$worksheet->getCodeName()]['AlternateContents'])) {
+            return;
+        }
+        foreach ($worksheet->getParentOrThrow()->getUnparsedLoadedData()['sheets'][$worksheet->getCodeName()]['AlternateContents'] as $alternateContent) {
+            $objWriter->writeRaw($alternateContent);
+        }
+    }
+    /**
+     * write <ExtLst>
+     * only implementation conditionalFormattings.
+     *
+     * @url https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/07d607af-5618-4ca2-b683-6a78dc0d9627
+     */
+    private function writeExtLst(XMLWriter $objWriter, PhpspreadsheetWorksheet $worksheet): void
+    {
+        $conditionalFormattingRuleExtList = [];
+        foreach ($worksheet->getConditionalStylesCollection() as $cellCoordinate => $conditionalStyles) {
+            /** @var Conditional $conditional */
+            foreach ($conditionalStyles as $conditional) {
+                $dataBar = $conditional->getDataBar();
+                if ($dataBar && $dataBar->getConditionalFormattingRuleExt()) {
+                    $conditionalFormattingRuleExtList[] = $dataBar->getConditionalFormattingRuleExt();
+                }
+            }
+        }
+        if (count($conditionalFormattingRuleExtList) > 0) {
+            $conditionalFormattingRuleExtNsPrefix = 'x14';
+            $objWriter->startElement('extLst');
+            $objWriter->startElement('ext');
+            $objWriter->writeAttribute('uri', '{78C0D931-6437-407d-A8EE-F0AAD7539E65}');
+            $objWriter->startElementNs($conditionalFormattingRuleExtNsPrefix, 'conditionalFormattings', null);
+            foreach ($conditionalFormattingRuleExtList as $extension) {
+                self::writeExtConditionalFormattingElements($objWriter, $extension);
+            }
+            $objWriter->endElement(); //end conditionalFormattings
+            $objWriter->endElement(); //end ext
+            $objWriter->endElement(); //end extLst
+        }
+    }
+}

--- a//dev/null
+++ b/src/PhpSpreadsheet/Writer/ZipStream3.php
@@ -0,0 +1,18 @@
+<?php
+namespace PhpOffice\PhpSpreadsheet\Writer;
+use ZipStream\ZipStream;
+class ZipStream3
+{
+    /**
+     * @param resource $fileHandle
+     */
+    public static function newZipStream($fileHandle): ZipStream
+    {
+        return new ZipStream(
+            enableZip64: false,
+            outputStream: $fileHandle,
+            sendHttpHeaders: false,
+            defaultEnableZeroHeader: false,
+        );
+    }
+}
