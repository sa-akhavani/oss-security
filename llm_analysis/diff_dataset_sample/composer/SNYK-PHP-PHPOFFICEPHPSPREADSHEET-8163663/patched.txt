# ====================================================================
# FILE: samples/Basic4/45_Quadratic_equation_solver.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     3| use PhpOffice\PhpSpreadsheet\Helper\Sample;
     4| use PhpOffice\PhpSpreadsheet\Settings;
     5| require __DIR__ . '/../Header.php';
     6| $helper = new Sample();
     7| if ($helper->isCli()) {
     8|     $helper->log('This example should only be run from a Web Browser' . PHP_EOL);
     9|     return;
    10| }
    11| ?>
    12| <form action="45_Quadratic_equation_solver.php" method="POST">
    13|     Enter the coefficients for Ax<sup>2</sup> + Bx + C = 0
    14|     <table border="0" cellpadding="0" cellspacing="0">
    15|         <tr>
    16|             <td>
    17|                 <b>A&nbsp;</b>
    18|             </td>
    19|             <td>
    20|                 <input name="A" type="text" size="8" value="<?php echo (isset($_POST['A'])) ? htmlentities($_POST['A'], Settings::htmlEntityFlags()) : ''; ?>">
    21|             </td>
    22|         </tr>
    23|         <tr>
    24|             <td>
    25|                 <b>B&nbsp;</b>
    26|             </td>
    27|             <td>
    28|                 <input name="B" type="text" size="8" value="<?php echo (isset($_POST['B'])) ? htmlentities($_POST['B'], Settings::htmlEntityFlags()) : ''; ?>">
    29|             </td>
    30|         </tr>
    31|         <tr>
    32|             <td><b>C&nbsp;</b>
    33|             </td>
    34|             <td>
    35|                 <input name="C" type="text" size="8" value="<?php echo (isset($_POST['C'])) ? htmlentities($_POST['C'], Settings::htmlEntityFlags()) : ''; ?>">
    36|             </td>
    37|         </tr>
    38|     </table>
    39|     <input name="submit" type="submit" value="calculate"><br />
    40|     If A=0, the equation is not quadratic.
    41| </form>
    42| <?php
    43| /**     If the user has submitted the form, then we need to execute a calculation * */
    44| if (isset($_POST['submit'])) {
    45|     if (!is_numeric($_POST['A']) || !is_numeric($_POST['B']) || !is_numeric($_POST['C'])) { // validate input
    46|         $helper->log('Non-numeric input');
    47|     } elseif ($_POST['A'] == 0) {
    48|         $helper->log('The equation is not quadratic');
    49|     } else {
    50|         $helper->log('<hr /><b>Roots:</b><br />');
    51|         $discriminantFormula = '=POWER(' . $_POST['B'] . ',2) - (4 * ' . $_POST['A'] . ' * ' . $_POST['C'] . ')';
    52|         $discriminant = Calculation::getInstance()->calculateFormula($discriminantFormula);
    53|         $r1Formula = '=IMDIV(IMSUM(-' . $_POST['B'] . ',IMSQRT(' . $discriminant . ')),2 * ' . $_POST['A'] . ')';
    54|         $r2Formula = '=IF(' . $discriminant . '=0,"Only one root",IMDIV(IMSUB(-' . $_POST['B'] . ',IMSQRT(' . $discriminant . ')),2 * ' . $_POST['A'] . '))';
    55|         /** @var string */
    56|         $output = Calculation::getInstance()->calculateFormula($r1Formula);
    57|         $helper->log("$output");
    58|         /** @var string */
    59|         $output = Calculation::getInstance()->calculateFormula($r2Formula);
    60|         $helper->log("$output");
    61|         $callEndTime = microtime(true);
    62|         $helper->logEndingNotes();
    63|     }
    64| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Calculation/Financial/Amortization.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-186 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Calculation\Financial;
     3| use PhpOffice\PhpSpreadsheet\Calculation\DateTimeExcel;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Exception;
     5| use PhpOffice\PhpSpreadsheet\Calculation\Financial\Constants as FinancialConstants;
     6| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     7| class Amortization
     8| {
     9|     /**
    10|      * AMORDEGRC.
    11|      *
    12|      * Returns the depreciation for each accounting period.
    13|      * This function is provided for the French accounting system. If an asset is purchased in
    14|      * the middle of the accounting period, the prorated depreciation is taken into account.
    15|      * The function is similar to AMORLINC, except that a depreciation coefficient is applied in
    16|      * the calculation depending on the life of the assets.
    17|      * This function will return the depreciation until the last period of the life of the assets
    18|      * or until the cumulated value of depreciation is greater than the cost of the assets minus
    19|      * the salvage value.
    20|      *
    21|      * Excel Function:
    22|      *        AMORDEGRC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
    23|      *
    24|      * @param mixed $cost The float cost of the asset
    25|      * @param mixed $purchased Date of the purchase of the asset
    26|      * @param mixed $firstPeriod Date of the end of the first period
    27|      * @param mixed $salvage The salvage value at the end of the life of the asset
    28|      * @param mixed $period the period (float)
    29|      * @param mixed $rate rate of depreciation (float)
    30|      * @param mixed $basis The type of day count to use (int).
    31|      *                         0 or omitted    US (NASD) 30/360
    32|      *                         1               Actual/actual
    33|      *                         2               Actual/360
    34|      *                         3               Actual/365
    35|      *                         4               European 30/360
    36|      *
    37|      * @return float|string (string containing the error type if there is an error)
    38|      */
    39|     public static function AMORDEGRC(
    40|         mixed $cost,
    41|         mixed $purchased,
    42|         mixed $firstPeriod,
    43|         mixed $salvage,
    44|         mixed $period,
    45|         mixed $rate,
    46|         mixed $basis = FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
    47|     ): string|float {
    48|         $cost = Functions::flattenSingleValue($cost);
    49|         $purchased = Functions::flattenSingleValue($purchased);
    50|         $firstPeriod = Functions::flattenSingleValue($firstPeriod);
    51|         $salvage = Functions::flattenSingleValue($salvage);
    52|         $period = Functions::flattenSingleValue($period);
    53|         $rate = Functions::flattenSingleValue($rate);
    54|         $basis = ($basis === null)
    55|             ? FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
    56|             : Functions::flattenSingleValue($basis);
    57|         try {
    58|             $cost = FinancialValidations::validateFloat($cost);
    59|             $purchased = FinancialValidations::validateDate($purchased);
    60|             $firstPeriod = FinancialValidations::validateDate($firstPeriod);
    61|             $salvage = FinancialValidations::validateFloat($salvage);
    62|             $period = FinancialValidations::validateInt($period);
    63|             $rate = FinancialValidations::validateFloat($rate);
    64|             $basis = FinancialValidations::validateBasis($basis);
    65|         } catch (Exception $e) {
    66|             return $e->getMessage();
    67|         }
    68|         $yearFracx = DateTimeExcel\YearFrac::fraction($purchased, $firstPeriod, $basis);
    69|         if (is_string($yearFracx)) {
    70|             return $yearFracx;
    71|         }
    72|         /** @var float $yearFrac */
    73|         $yearFrac = $yearFracx;
    74|         $amortiseCoeff = self::getAmortizationCoefficient($rate);
    75|         $rate *= $amortiseCoeff;
    76|         $rate = (float) (string) $rate; // ugly way to avoid rounding problem
    77|         $fNRate = round($yearFrac * $rate * $cost, 0);
    78|         $cost -= $fNRate;
    79|         $fRest = $cost - $salvage;
    80|         for ($n = 0; $n < $period; ++$n) {
    81|             $fNRate = round($rate * $cost, 0);
    82|             $fRest -= $fNRate;
    83|             if ($fRest < 0.0) {
    84|                 return match ($period - $n) {
    85|                     1 => round($cost * 0.5, 0),
    86|                     default => 0.0,
    87|                 };
    88|             }
    89|             $cost -= $fNRate;
    90|         }
    91|         return $fNRate;
    92|     }
    93|     /**
    94|      * AMORLINC.
    95|      *
    96|      * Returns the depreciation for each accounting period.
    97|      * This function is provided for the French accounting system. If an asset is purchased in
    98|      * the middle of the accounting period, the prorated depreciation is taken into account.
    99|      *
   100|      * Excel Function:
   101|      *        AMORLINC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
   102|      *
   103|      * @param mixed $cost The cost of the asset as a float
   104|      * @param mixed $purchased Date of the purchase of the asset
   105|      * @param mixed $firstPeriod Date of the end of the first period
   106|      * @param mixed $salvage The salvage value at the end of the life of the asset
   107|      * @param mixed $period The period as a float
   108|      * @param mixed $rate Rate of depreciation as  float
   109|      * @param mixed $basis Integer indicating the type of day count to use.
   110|      *                             0 or omitted    US (NASD) 30/360
   111|      *                             1               Actual/actual
   112|      *                             2               Actual/360
   113|      *                             3               Actual/365
   114|      *                             4               European 30/360
   115|      *
   116|      * @return float|string (string containing the error type if there is an error)
   117|      */
   118|     public static function AMORLINC(
   119|         mixed $cost,
   120|         mixed $purchased,
   121|         mixed $firstPeriod,
   122|         mixed $salvage,
   123|         mixed $period,
   124|         mixed $rate,
   125|         mixed $basis = FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
   126|     ): string|float {
   127|         $cost = Functions::flattenSingleValue($cost);
   128|         $purchased = Functions::flattenSingleValue($purchased);
   129|         $firstPeriod = Functions::flattenSingleValue($firstPeriod);
   130|         $salvage = Functions::flattenSingleValue($salvage);
   131|         $period = Functions::flattenSingleValue($period);
   132|         $rate = Functions::flattenSingleValue($rate);
   133|         $basis = ($basis === null)
   134|             ? FinancialConstants::BASIS_DAYS_PER_YEAR_NASD
   135|             : Functions::flattenSingleValue($basis);
   136|         try {
   137|             $cost = FinancialValidations::validateFloat($cost);
   138|             $purchased = FinancialValidations::validateDate($purchased);
   139|             $firstPeriod = FinancialValidations::validateDate($firstPeriod);
   140|             $salvage = FinancialValidations::validateFloat($salvage);
   141|             $period = FinancialValidations::validateFloat($period);
   142|             $rate = FinancialValidations::validateFloat($rate);
   143|             $basis = FinancialValidations::validateBasis($basis);
   144|         } catch (Exception $e) {
   145|             return $e->getMessage();
   146|         }
   147|         $fOneRate = $cost * $rate;
   148|         $fCostDelta = $cost - $salvage;
   149|         $purchasedYear = DateTimeExcel\DateParts::year($purchased);
   150|         $yearFracx = DateTimeExcel\YearFrac::fraction($purchased, $firstPeriod, $basis);
   151|         if (is_string($yearFracx)) {
   152|             return $yearFracx;
   153|         }
   154|         /** @var float $yearFrac */
   155|         $yearFrac = $yearFracx;
   156|         if (
   157|             $basis == FinancialConstants::BASIS_DAYS_PER_YEAR_ACTUAL
   158|             && $yearFrac < 1
   159|             && DateTimeExcel\Helpers::isLeapYear(Functions::scalar($purchasedYear))
   160|         ) {
   161|             $yearFrac *= 365 / 366;
   162|         }
   163|         $f0Rate = $yearFrac * $rate * $cost;
   164|         $nNumOfFullPeriods = (int) (($cost - $salvage - $f0Rate) / $fOneRate);
   165|         if ($period == 0) {
   166|             return $f0Rate;
   167|         } elseif ($period <= $nNumOfFullPeriods) {
   168|             return $fOneRate;
   169|         } elseif ($period == ($nNumOfFullPeriods + 1)) {
   170|             return $fCostDelta - $fOneRate * $nNumOfFullPeriods - $f0Rate;
   171|         }
   172|         return 0.0;
   173|     }
   174|     private static function getAmortizationCoefficient(float $rate): float
   175|     {
   176|         $fUsePer = 1.0 / $rate;
   177|         if ($fUsePer < 3.0) {
   178|             return 1.0;
   179|         } elseif ($fUsePer < 4.0) {
   180|             return 1.5;
   181|         } elseif ($fUsePer <= 6.0) {
   182|             return 2.0;
   183|         }
   184|         return 2.5;
   185|     }
   186| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Cell/Cell.php
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 26-65 ---
    26|      * Value of the cell.
    27|      */
    28|     private mixed $value;
    29|     /**
    30|      *    Calculated value of the cell (used for caching)
    31|      *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
    32|      *        create the original spreadsheet file.
    33|      *    Note that this value is not guaranteed to reflect the actual calculated value because it is
    34|      *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data
    35|      *        values used by the formula have changed since it was last calculated.
    36|      *
    37|      * @var mixed
    38|      */
    39|     private $calculatedValue;
    40|     /**
    41|      * Type of the cell data.
    42|      */
    43|     private string $dataType;
    44|     /**
    45|      * The collection of cells that this cell belongs to (i.e. The Cell Collection for the parent Worksheet).
    46|      */
    47|     private ?Cells $parent;
    48|     /**
    49|      * Index to the cellXf reference for the styling of this cell.
    50|      */
    51|     private int $xfIndex = 0;
    52|     /**
    53|      * Attributes of the formula.
    54|      */
    55|     private mixed $formulaAttributes = null;
    56|     private IgnoredErrors $ignoredErrors;
    57|     /**
    58|      * Update the cell into the cell collection.
    59|      *
    60|      * @throws SpreadsheetException
    61|      */
    62|     public function updateInCollection(): self
    63|     {
    64|         $parent = $this->parent;
    65|         if ($parent === null) {

# --- HUNK 2: Lines 246-300 ---
   246|                 }
   247|                 $this->value = (string) $value;
   248|                 break;
   249|             case DataType::TYPE_BOOL:
   250|                 $this->value = (bool) $value;
   251|                 break;
   252|             case DataType::TYPE_ISO_DATE:
   253|                 $this->value = SharedDate::convertIsoDate($value);
   254|                 $dataType = DataType::TYPE_NUMERIC;
   255|                 break;
   256|             case DataType::TYPE_ERROR:
   257|                 $this->value = DataType::checkErrorCode($value);
   258|                 break;
   259|             default:
   260|                 throw new SpreadsheetException('Invalid datatype: ' . $dataType);
   261|         }
   262|         $this->dataType = $dataType;
   263|         $this->updateInCollection();
   264|         $cellCoordinate = $this->getCoordinate();
   265|         self::updateIfCellIsTableHeader($this->getParent()?->getParent(), $this, $oldValue, $value);
   266|         $worksheet = $this->getWorksheet();
   267|         $spreadsheet = $worksheet->getParent();
   268|         if (isset($spreadsheet)) {
   269|             $originalSelected = $worksheet->getSelectedCells();
   270|             $activeSheetIndex = $spreadsheet->getActiveSheetIndex();
   271|             $style = $this->getStyle();
   272|             $oldQuotePrefix = $style->getQuotePrefix();
   273|             if ($oldQuotePrefix !== $quotePrefix) {
   274|                 $style->setQuotePrefix($quotePrefix);
   275|             }
   276|             $worksheet->setSelectedCells($originalSelected);
   277|             if ($activeSheetIndex >= 0) {
   278|                 $spreadsheet->setActiveSheetIndex($activeSheetIndex);
   279|             }
   280|         }
   281|         return $this->getParent()?->get($cellCoordinate) ?? $this;
   282|     }
   283|     public const CALCULATE_DATE_TIME_ASIS = 0;
   284|     public const CALCULATE_DATE_TIME_FLOAT = 1;
   285|     public const CALCULATE_TIME_FLOAT = 2;
   286|     private static int $calculateDateTimeType = self::CALCULATE_DATE_TIME_ASIS;
   287|     public static function getCalculateDateTimeType(): int
   288|     {
   289|         return self::$calculateDateTimeType;
   290|     }
   291|     /** @throws CalculationException */
   292|     public static function setCalculateDateTimeType(int $calculateDateTimeType): void
   293|     {
   294|         self::$calculateDateTimeType = match ($calculateDateTimeType) {
   295|             self::CALCULATE_DATE_TIME_ASIS, self::CALCULATE_DATE_TIME_FLOAT, self::CALCULATE_TIME_FLOAT => $calculateDateTimeType,
   296|             default => throw new CalculationException("Invalid value $calculateDateTimeType for calculated date time type"),
   297|         };
   298|     }
   299|     /**
   300|      * Convert date, time, or datetime from int to float if desired.


# ====================================================================
# FILE: src/PhpSpreadsheet/Helper/Sample.php
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Helper;
     3| use PhpOffice\PhpSpreadsheet\Chart\Chart;
     4| use PhpOffice\PhpSpreadsheet\Chart\Renderer\MtJpGraphRenderer;
     5| use PhpOffice\PhpSpreadsheet\IOFactory;
     6| use PhpOffice\PhpSpreadsheet\Settings;
     7| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     8| use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;
     9| use PhpOffice\PhpSpreadsheet\Writer\IWriter;
    10| use PhpOffice\PhpSpreadsheet\Writer\Pdf\Dompdf;
    11| use RecursiveDirectoryIterator;
    12| use RecursiveIteratorIterator;
    13| use RecursiveRegexIterator;
    14| use ReflectionClass;
    15| use RegexIterator;
    16| use RuntimeException;
    17| use Throwable;
    18| /**
    19|  * Helper class to be used in sample code.
    20|  */
    21| class Sample
    22| {
    23|     /**
    24|      * Returns whether we run on CLI or browser.
    25|      */
    26|     public function isCli(): bool
    27|     {
    28|         return PHP_SAPI === 'cli';
    29|     }
    30|     /**

# --- HUNK 2: Lines 90-134 ---
    90|         return $files;
    91|     }
    92|     /**
    93|      * Write documents.
    94|      *
    95|      * @param string[] $writers
    96|      */
    97|     public function write(Spreadsheet $spreadsheet, string $filename, array $writers = ['Xlsx', 'Xls'], bool $withCharts = false, ?callable $writerCallback = null, bool $resetActiveSheet = true): void
    98|     {
    99|         if ($resetActiveSheet) {
   100|             $spreadsheet->setActiveSheetIndex(0);
   101|         }
   102|         foreach ($writers as $writerType) {
   103|             $path = $this->getFilename($filename, mb_strtolower($writerType));
   104|             $writer = IOFactory::createWriter($spreadsheet, $writerType);
   105|             $writer->setIncludeCharts($withCharts);
   106|             if ($writerCallback !== null) {
   107|                 $writerCallback($writer);
   108|             }
   109|             $callStartTime = microtime(true);
   110|             if (PHP_VERSION_ID >= 80400 && $writer instanceof Dompdf) {
   111|                 @$writer->save($path);
   112|             } else {
   113|                 $writer->save($path);
   114|             }
   115|             $this->logWrite($writer, $path, $callStartTime);
   116|             if ($this->isCli() === false) {
   117|                 echo '<a href="/download.php?type=' . pathinfo($path, PATHINFO_EXTENSION) . '&name=' . basename($path) . '">Download ' . basename($path) . '</a><br />';
   118|             }
   119|         }
   120|         $this->logEndingNotes();
   121|     }
   122|     protected function isDirOrMkdir(string $folder): bool
   123|     {
   124|         return \is_dir($folder) || \mkdir($folder);
   125|     }
   126|     /**
   127|      * Returns the temporary directory and make sure it exists.
   128|      */
   129|     public function getTemporaryFolder(): string
   130|     {
   131|         $tempFolder = sys_get_temp_dir() . '/phpspreadsheet';
   132|         if (!$this->isDirOrMkdir($tempFolder)) {
   133|             throw new RuntimeException(sprintf('Directory "%s" was not created', $tempFolder));
   134|         }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Csv.php
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 35-86 ---
    35|      */
    36|     private string $fallbackEncoding = self::DEFAULT_FALLBACK_ENCODING;
    37|     /**
    38|      * Delimiter.
    39|      */
    40|     private ?string $delimiter = null;
    41|     /**
    42|      * Enclosure.
    43|      */
    44|     private string $enclosure = '"';
    45|     /**
    46|      * Sheet index to read.
    47|      */
    48|     private int $sheetIndex = 0;
    49|     /**
    50|      * Load rows contiguously.
    51|      */
    52|     private bool $contiguous = false;
    53|     /**
    54|      * The character that can escape the enclosure.
    55|      * This will probably become unsupported in Php 9.
    56|      * Not yet ready to mark deprecated in order to give users
    57|      * a migration path.
    58|      */
    59|     private ?string $escapeCharacter = null;
    60|     /**
    61|      * The character that will be supplied to fgetcsv
    62|      * when escapeCharacter is null.
    63|      * It is anticipated that it will conditionally be set
    64|      * to null-string for Php9 and above.
    65|      */
    66|     private static string $defaultEscapeCharacter = '\\';
    67|     /**
    68|      * Callback for setting defaults in construction.
    69|      *
    70|      * @var ?callable
    71|      */
    72|     private static $constructorCallback;
    73|     /**
    74|      * Attempt autodetect line endings (deprecated after PHP8.1)?
    75|      */
    76|     private bool $testAutodetect = true;
    77|     protected bool $castFormattedNumberToNumeric = false;
    78|     protected bool $preserveNumericFormatting = false;
    79|     private bool $preserveNullString = false;
    80|     private bool $sheetNameIsFileName = false;
    81|     private string $getTrue = 'true';
    82|     private string $getFalse = 'false';
    83|     private string $thousandsSeparator = ',';
    84|     private string $decimalSeparator = '.';
    85|     /**
    86|      * Create a new CSV Reader instance.

# --- HUNK 2: Lines 141-214 ---
   141|     protected function checkSeparator(): void
   142|     {
   143|         $line = fgets($this->fileHandle);
   144|         if ($line === false) {
   145|             return;
   146|         }
   147|         if ((strlen(trim($line, "\r\n")) == 5) && (stripos($line, 'sep=') === 0)) {
   148|             $this->delimiter = substr($line, 4, 1);
   149|             return;
   150|         }
   151|         $this->skipBOM();
   152|     }
   153|     /**
   154|      * Infer the separator if it isn't explicitly set in the file or specified by the user.
   155|      */
   156|     protected function inferSeparator(): void
   157|     {
   158|         if ($this->delimiter !== null) {
   159|             return;
   160|         }
   161|         $inferenceEngine = new Delimiter($this->fileHandle, $this->escapeCharacter ?? self::$defaultEscapeCharacter, $this->enclosure);
   162|         if ($inferenceEngine->linesCounted() === 0) {
   163|             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
   164|             $this->skipBOM();
   165|             return;
   166|         }
   167|         $this->delimiter = $inferenceEngine->infer();
   168|         if ($this->delimiter === null) {
   169|             $this->delimiter = $inferenceEngine->getDefaultDelimiter();
   170|         }
   171|         $this->skipBOM();
   172|     }
   173|     /**
   174|      * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
   175|      */
   176|     public function listWorksheetInfo(string $filename): array
   177|     {
   178|         $this->openFileOrMemory($filename);
   179|         $fileHandle = $this->fileHandle;
   180|         $this->skipBOM();
   181|         $this->checkSeparator();
   182|         $this->inferSeparator();
   183|         $worksheetInfo = [];
   184|         $worksheetInfo[0]['worksheetName'] = 'Worksheet';
   185|         $worksheetInfo[0]['lastColumnLetter'] = 'A';
   186|         $worksheetInfo[0]['lastColumnIndex'] = 0;
   187|         $worksheetInfo[0]['totalRows'] = 0;
   188|         $worksheetInfo[0]['totalColumns'] = 0;
   189|         $delimiter = $this->delimiter ?? '';
   190|         $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   191|         while (is_array($rowData)) {
   192|             ++$worksheetInfo[0]['totalRows'];
   193|             $worksheetInfo[0]['lastColumnIndex'] = max($worksheetInfo[0]['lastColumnIndex'], count($rowData) - 1);
   194|             $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   195|         }
   196|         $worksheetInfo[0]['lastColumnLetter'] = Coordinate::stringFromColumnIndex($worksheetInfo[0]['lastColumnIndex'] + 1);
   197|         $worksheetInfo[0]['totalColumns'] = $worksheetInfo[0]['lastColumnIndex'] + 1;
   198|         fclose($fileHandle);
   199|         return $worksheetInfo;
   200|     }
   201|     /**
   202|      * Loads Spreadsheet from file.
   203|      */
   204|     protected function loadSpreadsheetFromFile(string $filename): Spreadsheet
   205|     {
   206|         $spreadsheet = new Spreadsheet();
   207|         return $this->loadIntoExisting($filename, $spreadsheet);
   208|     }
   209|     /**
   210|      * Loads Spreadsheet from string.
   211|      */
   212|     public function loadSpreadsheetFromString(string $contents): Spreadsheet
   213|     {
   214|         $spreadsheet = new Spreadsheet();

# --- HUNK 3: Lines 285-360 ---
   285|         $iniset = $this->setAutoDetect('1');
   286|         if ($dataUri) {
   287|             $this->openDataUri($filename);
   288|         } else {
   289|             $this->openFileOrMemory($filename);
   290|         }
   291|         $fileHandle = $this->fileHandle;
   292|         $this->skipBOM();
   293|         $this->checkSeparator();
   294|         $this->inferSeparator();
   295|         while ($spreadsheet->getSheetCount() <= $this->sheetIndex) {
   296|             $spreadsheet->createSheet();
   297|         }
   298|         $sheet = $spreadsheet->setActiveSheetIndex($this->sheetIndex);
   299|         if ($this->sheetNameIsFileName) {
   300|             $sheet->setTitle(substr(basename($filename, '.csv'), 0, Worksheet::SHEET_TITLE_MAXIMUM_LENGTH));
   301|         }
   302|         $currentRow = 1;
   303|         $outRow = 0;
   304|         $delimiter = $this->delimiter ?? '';
   305|         $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   306|         $valueBinder = Cell::getValueBinder();
   307|         $preserveBooleanString = method_exists($valueBinder, 'getBooleanConversion') && $valueBinder->getBooleanConversion();
   308|         $this->getTrue = Calculation::getTRUE();
   309|         $this->getFalse = Calculation::getFALSE();
   310|         $this->thousandsSeparator = StringHelper::getThousandsSeparator();
   311|         $this->decimalSeparator = StringHelper::getDecimalSeparator();
   312|         while (is_array($rowData)) {
   313|             $noOutputYet = true;
   314|             $columnLetter = 'A';
   315|             foreach ($rowData as $rowDatum) {
   316|                 if ($preserveBooleanString) {
   317|                     $rowDatum = $rowDatum ?? '';
   318|                 } else {
   319|                     $this->convertBoolean($rowDatum);
   320|                 }
   321|                 $numberFormatMask = $this->castFormattedNumberToNumeric ? $this->convertFormattedNumber($rowDatum) : '';
   322|                 if (($rowDatum !== '' || $this->preserveNullString) && $this->readFilter->readCell($columnLetter, $currentRow)) {
   323|                     if ($this->contiguous) {
   324|                         if ($noOutputYet) {
   325|                             $noOutputYet = false;
   326|                             ++$outRow;
   327|                         }
   328|                     } else {
   329|                         $outRow = $currentRow;
   330|                     }
   331|                     if ($numberFormatMask !== '') {
   332|                         $sheet->getStyle($columnLetter . $outRow)
   333|                             ->getNumberFormat()
   334|                             ->setFormatCode($numberFormatMask);
   335|                     }
   336|                     $sheet->getCell($columnLetter . $outRow)->setValue($rowDatum);
   337|                 }
   338|                 ++$columnLetter;
   339|             }
   340|             $rowData = self::getCsv($fileHandle, 0, $delimiter, $this->enclosure, $this->escapeCharacter);
   341|             ++$currentRow;
   342|         }
   343|         fclose($fileHandle);
   344|         $this->setAutoDetect($iniset);
   345|         return $spreadsheet;
   346|     }
   347|     /**
   348|      * Convert string true/false to boolean, and null to null-string.
   349|      */
   350|     private function convertBoolean(mixed &$rowDatum): void
   351|     {
   352|         if (is_string($rowDatum)) {
   353|             if (strcasecmp($this->getTrue, $rowDatum) === 0 || strcasecmp('true', $rowDatum) === 0) {
   354|                 $rowDatum = true;
   355|             } elseif (strcasecmp($this->getFalse, $rowDatum) === 0 || strcasecmp('false', $rowDatum) === 0) {
   356|                 $rowDatum = false;
   357|             }
   358|         } else {
   359|             $rowDatum = $rowDatum ?? '';
   360|         }

# --- HUNK 4: Lines 408-460 ---
   408|         return $this;
   409|     }
   410|     public function getSheetIndex(): int
   411|     {
   412|         return $this->sheetIndex;
   413|     }
   414|     public function setSheetIndex(int $indexValue): self
   415|     {
   416|         $this->sheetIndex = $indexValue;
   417|         return $this;
   418|     }
   419|     public function setContiguous(bool $contiguous): self
   420|     {
   421|         $this->contiguous = $contiguous;
   422|         return $this;
   423|     }
   424|     public function getContiguous(): bool
   425|     {
   426|         return $this->contiguous;
   427|     }
   428|     /**
   429|      * Php9 intends to drop support for this parameter in fgetcsv.
   430|      * Not yet ready to mark deprecated in order to give users
   431|      * a migration path.
   432|      */
   433|     public function setEscapeCharacter(string $escapeCharacter): self
   434|     {
   435|         $this->escapeCharacter = $escapeCharacter;
   436|         return $this;
   437|     }
   438|     public function getEscapeCharacter(): string
   439|     {
   440|         return $this->escapeCharacter ?? self::$defaultEscapeCharacter;
   441|     }
   442|     /**
   443|      * Can the current IReader read the file?
   444|      */
   445|     public function canRead(string $filename): bool
   446|     {
   447|         try {
   448|             $this->openFile($filename);
   449|         } catch (ReaderException) {
   450|             return false;
   451|         }
   452|         fclose($this->fileHandle);
   453|         $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
   454|         if (in_array($extension, ['csv', 'tsv'])) {
   455|             return true;
   456|         }
   457|         $type = mime_content_type($filename);
   458|         $supportedTypes = [
   459|             'application/csv',
   460|             'text/csv',

# --- HUNK 5: Lines 512-554 ---
   512|         $encoding = self::guessEncodingBom($filename);
   513|         if ($encoding === '') {
   514|             $encoding = self::guessEncodingNoBom($filename);
   515|         }
   516|         return ($encoding === '') ? $dflt : $encoding;
   517|     }
   518|     public function setPreserveNullString(bool $value): self
   519|     {
   520|         $this->preserveNullString = $value;
   521|         return $this;
   522|     }
   523|     public function getPreserveNullString(): bool
   524|     {
   525|         return $this->preserveNullString;
   526|     }
   527|     public function setSheetNameIsFileName(bool $sheetNameIsFileName): self
   528|     {
   529|         $this->sheetNameIsFileName = $sheetNameIsFileName;
   530|         return $this;
   531|     }
   532|     /**
   533|      * Php8.4 deprecates use of anything other than null string
   534|      * as escape Character.
   535|      *
   536|      * @param resource $stream
   537|      * @param null|int<0, max> $length
   538|      *
   539|      * @return array<int,?string>|false
   540|      */
   541|     private static function getCsv(
   542|         $stream,
   543|         ?int $length = null,
   544|         string $separator = ',',
   545|         string $enclosure = '"',
   546|         ?string $escape = null
   547|     ): array|false {
   548|         $escape = $escape ?? self::$defaultEscapeCharacter;
   549|         if (PHP_VERSION_ID >= 80400 && $escape !== '') {
   550|             return @fgetcsv($stream, $length, $separator, $enclosure, $escape);
   551|         }
   552|         return fgetcsv($stream, $length, $separator, $enclosure, $escape);
   553|     }
   554| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Security/XmlScanner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-76 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Reader\Security;
     3| use PhpOffice\PhpSpreadsheet\Reader;
     4| class XmlScanner
     5| {
     6|     private string $pattern;
     7|     /** @var ?callable */
     8|     private $callback;
     9|     public function __construct(string $pattern = '<!DOCTYPE')
    10|     {
    11|         $this->pattern = $pattern;
    12|     }
    13|     public static function getInstance(Reader\IReader $reader): self
    14|     {
    15|         $pattern = ($reader instanceof Reader\Html) ? '<!ENTITY' : '<!DOCTYPE';
    16|         return new self($pattern);
    17|     }
    18|     public function setAdditionalCallback(callable $callback): void
    19|     {
    20|         $this->callback = $callback;
    21|     }
    22|     private static function forceString(mixed $arg): string
    23|     {
    24|         return is_string($arg) ? $arg : '';
    25|     }
    26|     private function toUtf8(string $xml): string
    27|     {
    28|         $charset = $this->findCharSet($xml);
    29|         if ($charset !== 'UTF-8') {
    30|             $xml = self::forceString(mb_convert_encoding($xml, 'UTF-8', $charset));
    31|             $charset = $this->findCharSet($xml);
    32|             if ($charset !== 'UTF-8') {
    33|                 throw new Reader\Exception('Suspicious Double-encoded XML, spreadsheet file load() aborted to prevent XXE/XEE attacks');
    34|             }
    35|         }
    36|         return $xml;
    37|     }
    38|     private function findCharSet(string $xml): string
    39|     {
    40|         $patterns = [
    41|             '/encoding\\s*=\\s*"([^"]*]?)"/',
    42|             "/encoding\\s*=\\s*'([^']*?)'/",
    43|         ];
    44|         foreach ($patterns as $pattern) {
    45|             if (preg_match($pattern, $xml, $matches)) {
    46|                 return strtoupper($matches[1]);
    47|             }
    48|         }
    49|         return 'UTF-8';
    50|     }
    51|     /**
    52|      * Scan the XML for use of <!ENTITY to prevent XXE/XEE attacks.
    53|      *
    54|      * @param false|string $xml
    55|      */
    56|     public function scan($xml): string
    57|     {
    58|         $xml = "$xml";
    59|         $xml = $this->toUtf8($xml);
    60|         $pattern = '/\\0?' . implode('\\0?', str_split($this->pattern)) . '\\0?/';
    61|         if (preg_match($pattern, $xml)) {
    62|             throw new Reader\Exception('Detected use of ENTITY in XML, spreadsheet file load() aborted to prevent XXE/XEE attacks');
    63|         }
    64|         if ($this->callback !== null) {
    65|             $xml = call_user_func($this->callback, $xml);
    66|         }
    67|         return $xml;
    68|     }
    69|     /**
    70|      * Scan theXML for use of <!ENTITY to prevent XXE/XEE attacks.
    71|      */
    72|     public function scanFile(string $filestream): string
    73|     {
    74|         return $this->scan(file_get_contents($filestream));
    75|     }
    76| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Reader/Xlsx.php
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 717-764 ---
   717|                                         }
   718|                                         if ($this->readEmptyCells || ($value !== null && $value !== '')) {
   719|                                             if ($value instanceof RichText && $this->readDataOnly) {
   720|                                                 $value = $value->getPlainText();
   721|                                             }
   722|                                             $cell = $docSheet->getCell($r);
   723|                                             if ($cellDataType != '') {
   724|                                                 if ($cellDataType === DataType::TYPE_NUMERIC && ($value === '' || $value === null)) {
   725|                                                     $cellDataType = DataType::TYPE_NULL;
   726|                                                 }
   727|                                                 if ($cellDataType !== DataType::TYPE_NULL) {
   728|                                                     $cell->setValueExplicit($value, $cellDataType);
   729|                                                 }
   730|                                             } else {
   731|                                                 $cell->setValue($value);
   732|                                             }
   733|                                             if ($calculatedValue !== null) {
   734|                                                 $cell->setCalculatedValue($calculatedValue, $originalCellDataTypeNumeric);
   735|                                             }
   736|                                             if (!$this->readDataOnly) {
   737|                                                 $cAttrS = (int) ($cAttr['s'] ?? 0);
   738|                                                 $cAttrS = isset($styles[$cAttrS]) ? $cAttrS : 0;
   739|                                                 $cell->setXfIndex($cAttrS);
   740|                                                 if ($cellDataType === DataType::TYPE_FORMULA && $styles[$cAttrS]->quotePrefix === true) {
   741|                                                     $holdSelected = $docSheet->getSelectedCells();
   742|                                                     $cell->getStyle()->setQuotePrefix(false);
   743|                                                     $docSheet->setSelectedCells($holdSelected);
   744|                                                 }
   745|                                             }
   746|                                         }
   747|                                         ++$rowIndex;
   748|                                     }
   749|                                     ++$cIndex;
   750|                                 }
   751|                             }
   752|                             $docSheet->setSelectedCells($holdSelectedCells);
   753|                             if ($xmlSheetNS && $xmlSheetNS->ignoredErrors) {
   754|                                 foreach ($xmlSheetNS->ignoredErrors->ignoredError as $ignoredErrorx) {
   755|                                     $ignoredError = self::testSimpleXml($ignoredErrorx);
   756|                                     $this->processIgnoredErrors($ignoredError, $docSheet);
   757|                                 }
   758|                             }
   759|                             if (!$this->readDataOnly && $xmlSheetNS && $xmlSheetNS->sheetProtection) {
   760|                                 $protAttr = $xmlSheetNS->sheetProtection->attributes() ?? [];
   761|                                 foreach ($protAttr as $key => $value) {
   762|                                     $method = 'set' . ucfirst($key);
   763|                                     $docSheet->getProtection()->$method(self::boolean((string) $value));
   764|                                 }

# --- HUNK 2: Lines 1024-1064 ---
  1024|                                             }
  1025|                                             $vmlDrawing = $this->loadZipNoNamespace($vmlRelationship, '');
  1026|                                             $vmlDrawing->registerXPathNamespace('v', Namespaces::URN_VML);
  1027|                                             $hfImages = [];
  1028|                                             $shapes = self::xpathNoFalse($vmlDrawing, '//v:shape');
  1029|                                             foreach ($shapes as $idx => $shape) {
  1030|                                                 $shape->registerXPathNamespace('v', Namespaces::URN_VML);
  1031|                                                 $imageData = $shape->xpath('//v:imagedata');
  1032|                                                 if (empty($imageData)) {
  1033|                                                     continue;
  1034|                                                 }
  1035|                                                 $imageData = $imageData[$idx];
  1036|                                                 $imageData = self::getAttributes($imageData, Namespaces::URN_MSOFFICE);
  1037|                                                 $style = self::toCSSArray((string) $shape['style']);
  1038|                                                 if (array_key_exists((string) $imageData['relid'], $drawings)) {
  1039|                                                     $shapeId = (string) $shape['id'];
  1040|                                                     $hfImages[$shapeId] = new HeaderFooterDrawing();
  1041|                                                     if (isset($imageData['title'])) {
  1042|                                                         $hfImages[$shapeId]->setName((string) $imageData['title']);
  1043|                                                     }
  1044|                                                     $hfImages[$shapeId]->setPath('zip://' . File::realpath($filename) . '#' . $drawings[(string) $imageData['relid']], false, $zip);
  1045|                                                     $hfImages[$shapeId]->setResizeProportional(false);
  1046|                                                     $hfImages[$shapeId]->setWidth($style['width']);
  1047|                                                     $hfImages[$shapeId]->setHeight($style['height']);
  1048|                                                     if (isset($style['margin-left'])) {
  1049|                                                         $hfImages[$shapeId]->setOffsetX($style['margin-left']);
  1050|                                                     }
  1051|                                                     $hfImages[$shapeId]->setOffsetY($style['margin-top']);
  1052|                                                     $hfImages[$shapeId]->setResizeProportional(true);
  1053|                                                 }
  1054|                                             }
  1055|                                             $docSheet->getHeaderFooter()->setImages($hfImages);
  1056|                                         }
  1057|                                     }
  1058|                                 }
  1059|                             }
  1060|                             $drawingFilename = dirname("$dir/$fileWorksheet")
  1061|                                 . '/_rels/'
  1062|                                 . basename($fileWorksheet)
  1063|                                 . '.rels';
  1064|                             if (str_starts_with($drawingFilename, 'xl//xl/')) {

# --- HUNK 3: Lines 1128-1181 ---
  1128|                                             foreach ($xmlDrawingChildren->oneCellAnchor as $oneCellAnchor) {
  1129|                                                 $oneCellAnchor = self::testSimpleXml($oneCellAnchor);
  1130|                                                 if ($oneCellAnchor->pic->blipFill) {
  1131|                                                     /** @var SimpleXMLElement $blip */
  1132|                                                     $blip = $oneCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->blip;
  1133|                                                     /** @var SimpleXMLElement $xfrm */
  1134|                                                     $xfrm = $oneCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->xfrm;
  1135|                                                     /** @var SimpleXMLElement $outerShdw */
  1136|                                                     $outerShdw = $oneCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->effectLst->outerShdw;
  1137|                                                     $objDrawing = new \PhpOffice\PhpSpreadsheet\Worksheet\Drawing();
  1138|                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'name'));
  1139|                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($oneCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
  1140|                                                     $embedImageKey = (string) self::getArrayItem(
  1141|                                                         self::getAttributes($blip, $xmlNamespaceBase),
  1142|                                                         'embed'
  1143|                                                     );
  1144|                                                     if (isset($images[$embedImageKey])) {
  1145|                                                         $objDrawing->setPath(
  1146|                                                             'zip://' . File::realpath($filename) . '#'
  1147|                                                             . $images[$embedImageKey],
  1148|                                                             false,
  1149|                                                             $zip
  1150|                                                         );
  1151|                                                     } else {
  1152|                                                         $linkImageKey = (string) self::getArrayItem(
  1153|                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
  1154|                                                             'link'
  1155|                                                         );
  1156|                                                         if (isset($images[$linkImageKey])) {
  1157|                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
  1158|                                                             $objDrawing->setPath($url, false);
  1159|                                                         }
  1160|                                                         if ($objDrawing->getPath() === '') {
  1161|                                                             continue;
  1162|                                                         }
  1163|                                                     }
  1164|                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $oneCellAnchor->from->col) + 1) . ($oneCellAnchor->from->row + 1));
  1165|                                                     $objDrawing->setOffsetX((int) Drawing::EMUToPixels($oneCellAnchor->from->colOff));
  1166|                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($oneCellAnchor->from->rowOff));
  1167|                                                     $objDrawing->setResizeProportional(false);
  1168|                                                     $objDrawing->setWidth(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cx')));
  1169|                                                     $objDrawing->setHeight(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($oneCellAnchor->ext), 'cy')));
  1170|                                                     if ($xfrm) {
  1171|                                                         $objDrawing->setRotation((int) Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($xfrm), 'rot')));
  1172|                                                         $objDrawing->setFlipVertical((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipV'));
  1173|                                                         $objDrawing->setFlipHorizontal((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipH'));
  1174|                                                     }
  1175|                                                     if ($outerShdw) {
  1176|                                                         $shadow = $objDrawing->getShadow();
  1177|                                                         $shadow->setVisible(true);
  1178|                                                         $shadow->setBlurRadius(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'blurRad')));
  1179|                                                         $shadow->setDistance(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'dist')));
  1180|                                                         $shadow->setDirection(Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($outerShdw), 'dir')));
  1181|                                                         $shadow->setAlignment((string) self::getArrayItem(self::getAttributes($outerShdw), 'algn'));

# --- HUNK 4: Lines 1215-1268 ---
  1215|                                                     $blip = $twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->blip;
  1216|                                                     if (isset($twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->srcRect)) {
  1217|                                                         $objDrawing->setSrcRect($twoCellAnchor->pic->blipFill->children(Namespaces::DRAWINGML)->srcRect->attributes());
  1218|                                                     }
  1219|                                                     $xfrm = $twoCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->xfrm;
  1220|                                                     $outerShdw = $twoCellAnchor->pic->spPr->children(Namespaces::DRAWINGML)->effectLst->outerShdw;
  1221|                                                     $editAs = $twoCellAnchor->attributes();
  1222|                                                     if (isset($editAs, $editAs['editAs'])) {
  1223|                                                         $objDrawing->setEditAs($editAs['editAs']);
  1224|                                                     }
  1225|                                                     $objDrawing->setName((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'name'));
  1226|                                                     $objDrawing->setDescription((string) self::getArrayItem(self::getAttributes($twoCellAnchor->pic->nvPicPr->cNvPr), 'descr'));
  1227|                                                     $embedImageKey = (string) self::getArrayItem(
  1228|                                                         self::getAttributes($blip, $xmlNamespaceBase),
  1229|                                                         'embed'
  1230|                                                     );
  1231|                                                     if (isset($images[$embedImageKey])) {
  1232|                                                         $objDrawing->setPath(
  1233|                                                             'zip://' . File::realpath($filename) . '#'
  1234|                                                             . $images[$embedImageKey],
  1235|                                                             false,
  1236|                                                             $zip
  1237|                                                         );
  1238|                                                     } else {
  1239|                                                         $linkImageKey = (string) self::getArrayItem(
  1240|                                                             $blip->attributes('http://schemas.openxmlformats.org/officeDocument/2006/relationships'),
  1241|                                                             'link'
  1242|                                                         );
  1243|                                                         if (isset($images[$linkImageKey])) {
  1244|                                                             $url = str_replace('xl/drawings/', '', $images[$linkImageKey]);
  1245|                                                             $objDrawing->setPath($url, false);
  1246|                                                         }
  1247|                                                         if ($objDrawing->getPath() === '') {
  1248|                                                             continue;
  1249|                                                         }
  1250|                                                     }
  1251|                                                     $objDrawing->setCoordinates(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->from->col) + 1) . ($twoCellAnchor->from->row + 1));
  1252|                                                     $objDrawing->setOffsetX(Drawing::EMUToPixels($twoCellAnchor->from->colOff));
  1253|                                                     $objDrawing->setOffsetY(Drawing::EMUToPixels($twoCellAnchor->from->rowOff));
  1254|                                                     $objDrawing->setCoordinates2(Coordinate::stringFromColumnIndex(((int) $twoCellAnchor->to->col) + 1) . ($twoCellAnchor->to->row + 1));
  1255|                                                     $objDrawing->setOffsetX2(Drawing::EMUToPixels($twoCellAnchor->to->colOff));
  1256|                                                     $objDrawing->setOffsetY2(Drawing::EMUToPixels($twoCellAnchor->to->rowOff));
  1257|                                                     $objDrawing->setResizeProportional(false);
  1258|                                                     if ($xfrm) {
  1259|                                                         $objDrawing->setWidth(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($xfrm->ext), 'cx')));
  1260|                                                         $objDrawing->setHeight(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($xfrm->ext), 'cy')));
  1261|                                                         $objDrawing->setRotation(Drawing::angleToDegrees(self::getArrayItem(self::getAttributes($xfrm), 'rot')));
  1262|                                                         $objDrawing->setFlipVertical((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipV'));
  1263|                                                         $objDrawing->setFlipHorizontal((bool) self::getArrayItem(self::getAttributes($xfrm), 'flipH'));
  1264|                                                     }
  1265|                                                     if ($outerShdw) {
  1266|                                                         $shadow = $objDrawing->getShadow();
  1267|                                                         $shadow->setVisible(true);
  1268|                                                         $shadow->setBlurRadius(Drawing::EMUToPixels(self::getArrayItem(self::getAttributes($outerShdw), 'blurRad')));


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/BaseDrawing.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-438 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use PhpOffice\PhpSpreadsheet\Cell\Hyperlink;
     4| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     5| use PhpOffice\PhpSpreadsheet\IComparable;
     6| use PhpOffice\PhpSpreadsheet\Worksheet\Drawing\Shadow;
     7| use SimpleXMLElement;
     8| class BaseDrawing implements IComparable
     9| {
    10|     const EDIT_AS_ABSOLUTE = 'absolute';
    11|     const EDIT_AS_ONECELL = 'oneCell';
    12|     const EDIT_AS_TWOCELL = 'twoCell';
    13|     private const VALID_EDIT_AS = [
    14|         self::EDIT_AS_ABSOLUTE,
    15|         self::EDIT_AS_ONECELL,
    16|         self::EDIT_AS_TWOCELL,
    17|     ];
    18|     /**
    19|      * The editAs attribute, used only with two cell anchor.
    20|      */
    21|     protected string $editAs = '';
    22|     /**
    23|      * Image counter.
    24|      */
    25|     private static int $imageCounter = 0;
    26|     /**
    27|      * Image index.
    28|      */
    29|     private int $imageIndex;
    30|     /**
    31|      * Name.
    32|      */
    33|     protected string $name = '';
    34|     /**
    35|      * Description.
    36|      */
    37|     protected string $description = '';
    38|     /**
    39|      * Worksheet.
    40|      */
    41|     protected ?Worksheet $worksheet = null;
    42|     /**
    43|      * Coordinates.
    44|      */
    45|     protected string $coordinates = 'A1';
    46|     /**
    47|      * Offset X.
    48|      */
    49|     protected int $offsetX = 0;
    50|     /**
    51|      * Offset Y.
    52|      */
    53|     protected int $offsetY = 0;
    54|     /**
    55|      * Coordinates2.
    56|      */
    57|     protected string $coordinates2 = '';
    58|     /**
    59|      * Offset X2.
    60|      */
    61|     protected int $offsetX2 = 0;
    62|     /**
    63|      * Offset Y2.
    64|      */
    65|     protected int $offsetY2 = 0;
    66|     /**
    67|      * Width.
    68|      */
    69|     protected int $width = 0;
    70|     /**
    71|      * Height.
    72|      */
    73|     protected int $height = 0;
    74|     /**
    75|      * Pixel width of image. See $width for the size the Drawing will be in the sheet.
    76|      */
    77|     protected int $imageWidth = 0;
    78|     /**
    79|      * Pixel width of image. See $height for the size the Drawing will be in the sheet.
    80|      */
    81|     protected int $imageHeight = 0;
    82|     /**
    83|      * Proportional resize.
    84|      */
    85|     protected bool $resizeProportional = true;
    86|     /**
    87|      * Rotation.
    88|      */
    89|     protected int $rotation = 0;
    90|     protected bool $flipVertical = false;
    91|     protected bool $flipHorizontal = false;
    92|     /**
    93|      * Shadow.
    94|      */
    95|     protected Shadow $shadow;
    96|     /**
    97|      * Image hyperlink.
    98|      */
    99|     private ?Hyperlink $hyperlink = null;
   100|     /**
   101|      * Image type.
   102|      */
   103|     protected int $type = IMAGETYPE_UNKNOWN;
   104|     /** @var null|SimpleXMLElement|string[] */
   105|     protected $srcRect = [];
   106|     /**
   107|      * Create a new BaseDrawing.
   108|      */
   109|     public function __construct()
   110|     {
   111|         $this->setShadow();
   112|         ++self::$imageCounter;
   113|         $this->imageIndex = self::$imageCounter;
   114|     }
   115|     public function __destruct()
   116|     {
   117|         $this->worksheet = null;
   118|     }
   119|     public function getImageIndex(): int
   120|     {
   121|         return $this->imageIndex;
   122|     }
   123|     public function getName(): string
   124|     {
   125|         return $this->name;
   126|     }
   127|     public function setName(string $name): self
   128|     {
   129|         $this->name = $name;
   130|         return $this;
   131|     }
   132|     public function getDescription(): string
   133|     {
   134|         return $this->description;
   135|     }
   136|     public function setDescription(string $description): self
   137|     {
   138|         $this->description = $description;
   139|         return $this;
   140|     }
   141|     public function getWorksheet(): ?Worksheet
   142|     {
   143|         return $this->worksheet;
   144|     }
   145|     /**
   146|      * Set Worksheet.
   147|      *
   148|      * @param bool $overrideOld If a Worksheet has already been assigned, overwrite it and remove image from old Worksheet?
   149|      */
   150|     public function setWorksheet(?Worksheet $worksheet = null, bool $overrideOld = false): self
   151|     {
   152|         if ($this->worksheet === null) {
   153|             if ($worksheet !== null && !($this instanceof Drawing && $this->getPath() === '')) {
   154|                 $this->worksheet = $worksheet;
   155|                 $this->worksheet->getCell($this->coordinates);
   156|                 $this->worksheet->getDrawingCollection()->append($this);
   157|             }
   158|         } else {
   159|             if ($overrideOld) {
   160|                 $iterator = $this->worksheet->getDrawingCollection()->getIterator();
   161|                 while ($iterator->valid()) {
   162|                     if ($iterator->current()->getHashCode() === $this->getHashCode()) {
   163|                         $this->worksheet->getDrawingCollection()->offsetUnset($iterator->key());
   164|                         $this->worksheet = null;
   165|                         break;
   166|                     }
   167|                 }
   168|                 $this->setWorksheet($worksheet);
   169|             } else {
   170|                 throw new PhpSpreadsheetException('A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.');
   171|             }
   172|         }
   173|         return $this;
   174|     }
   175|     public function getCoordinates(): string
   176|     {
   177|         return $this->coordinates;
   178|     }
   179|     public function setCoordinates(string $coordinates): self
   180|     {
   181|         $this->coordinates = $coordinates;
   182|         return $this;
   183|     }
   184|     public function getOffsetX(): int
   185|     {
   186|         return $this->offsetX;
   187|     }
   188|     public function setOffsetX(int $offsetX): self
   189|     {
   190|         $this->offsetX = $offsetX;
   191|         return $this;
   192|     }
   193|     public function getOffsetY(): int
   194|     {
   195|         return $this->offsetY;
   196|     }
   197|     public function setOffsetY(int $offsetY): self
   198|     {
   199|         $this->offsetY = $offsetY;
   200|         return $this;
   201|     }
   202|     public function getCoordinates2(): string
   203|     {
   204|         return $this->coordinates2;
   205|     }
   206|     public function setCoordinates2(string $coordinates2): self
   207|     {
   208|         $this->coordinates2 = $coordinates2;
   209|         return $this;
   210|     }
   211|     public function getOffsetX2(): int
   212|     {
   213|         return $this->offsetX2;
   214|     }
   215|     public function setOffsetX2(int $offsetX2): self
   216|     {
   217|         $this->offsetX2 = $offsetX2;
   218|         return $this;
   219|     }
   220|     public function getOffsetY2(): int
   221|     {
   222|         return $this->offsetY2;
   223|     }
   224|     public function setOffsetY2(int $offsetY2): self
   225|     {
   226|         $this->offsetY2 = $offsetY2;
   227|         return $this;
   228|     }
   229|     public function getWidth(): int
   230|     {
   231|         return $this->width;
   232|     }
   233|     public function setWidth(int $width): self
   234|     {
   235|         if ($this->resizeProportional && $width != 0) {
   236|             $ratio = $this->height / ($this->width != 0 ? $this->width : 1);
   237|             $this->height = (int) round($ratio * $width);
   238|         }
   239|         $this->width = $width;
   240|         return $this;
   241|     }
   242|     public function getHeight(): int
   243|     {
   244|         return $this->height;
   245|     }
   246|     public function setHeight(int $height): self
   247|     {
   248|         if ($this->resizeProportional && $height != 0) {
   249|             $ratio = $this->width / ($this->height != 0 ? $this->height : 1);
   250|             $this->width = (int) round($ratio * $height);
   251|         }
   252|         $this->height = $height;
   253|         return $this;
   254|     }
   255|     /**
   256|      * Set width and height with proportional resize.
   257|      *
   258|      * Example:
   259|      * <code>
   260|      * $objDrawing->setResizeProportional(true);
   261|      * $objDrawing->setWidthAndHeight(160,120);
   262|      * </code>
   263|      *
   264|      * @author Vincent@luo MSN:kele_100@hotmail.com
   265|      */
   266|     public function setWidthAndHeight(int $width, int $height): self
   267|     {
   268|         $xratio = $width / ($this->width != 0 ? $this->width : 1);
   269|         $yratio = $height / ($this->height != 0 ? $this->height : 1);
   270|         if ($this->resizeProportional && !($width == 0 || $height == 0)) {
   271|             if (($xratio * $this->height) < $height) {
   272|                 $this->height = (int) ceil($xratio * $this->height);
   273|                 $this->width = $width;
   274|             } else {
   275|                 $this->width = (int) ceil($yratio * $this->width);
   276|                 $this->height = $height;
   277|             }
   278|         } else {
   279|             $this->width = $width;
   280|             $this->height = $height;
   281|         }
   282|         return $this;
   283|     }
   284|     public function getResizeProportional(): bool
   285|     {
   286|         return $this->resizeProportional;
   287|     }
   288|     public function setResizeProportional(bool $resizeProportional): self
   289|     {
   290|         $this->resizeProportional = $resizeProportional;
   291|         return $this;
   292|     }
   293|     public function getRotation(): int
   294|     {
   295|         return $this->rotation;
   296|     }
   297|     public function setRotation(int $rotation): self
   298|     {
   299|         $this->rotation = $rotation;
   300|         return $this;
   301|     }
   302|     public function getShadow(): Shadow
   303|     {
   304|         return $this->shadow;
   305|     }
   306|     public function setShadow(?Shadow $shadow = null): self
   307|     {
   308|         $this->shadow = $shadow ?? new Shadow();
   309|         return $this;
   310|     }
   311|     /**
   312|      * Get hash code.
   313|      *
   314|      * @return string Hash code
   315|      */
   316|     public function getHashCode(): string
   317|     {
   318|         return md5(
   319|             $this->name
   320|             . $this->description
   321|             . (($this->worksheet === null) ? '' : $this->worksheet->getHashCode())
   322|             . $this->coordinates
   323|             . $this->offsetX
   324|             . $this->offsetY
   325|             . $this->coordinates2
   326|             . $this->offsetX2
   327|             . $this->offsetY2
   328|             . $this->width
   329|             . $this->height
   330|             . $this->rotation
   331|             . $this->shadow->getHashCode()
   332|             . __CLASS__
   333|         );
   334|     }
   335|     /**
   336|      * Implement PHP __clone to create a deep clone, not just a shallow copy.
   337|      */
   338|     public function __clone()
   339|     {
   340|         $vars = get_object_vars($this);
   341|         foreach ($vars as $key => $value) {
   342|             if ($key == 'worksheet') {
   343|                 $this->worksheet = null;
   344|             } elseif (is_object($value)) {
   345|                 $this->$key = clone $value;
   346|             } else {
   347|                 $this->$key = $value;
   348|             }
   349|         }
   350|     }
   351|     public function setHyperlink(?Hyperlink $hyperlink = null): void
   352|     {
   353|         $this->hyperlink = $hyperlink;
   354|     }
   355|     public function getHyperlink(): ?Hyperlink
   356|     {
   357|         return $this->hyperlink;
   358|     }
   359|     /**
   360|      * Set Fact Sizes and Type of Image.
   361|      */
   362|     protected function setSizesAndType(string $path): void
   363|     {
   364|         if ($this->imageWidth === 0 && $this->imageHeight === 0 && $this->type === IMAGETYPE_UNKNOWN) {
   365|             $imageData = getimagesize($path);
   366|             if (!empty($imageData)) {
   367|                 $this->imageWidth = $imageData[0];
   368|                 $this->imageHeight = $imageData[1];
   369|                 $this->type = $imageData[2];
   370|             }
   371|         }
   372|         if ($this->width === 0 && $this->height === 0) {
   373|             $this->width = $this->imageWidth;
   374|             $this->height = $this->imageHeight;
   375|         }
   376|     }
   377|     /**
   378|      * Get Image Type.
   379|      */
   380|     public function getType(): int
   381|     {
   382|         return $this->type;
   383|     }
   384|     public function getImageWidth(): int
   385|     {
   386|         return $this->imageWidth;
   387|     }
   388|     public function getImageHeight(): int
   389|     {
   390|         return $this->imageHeight;
   391|     }
   392|     public function getEditAs(): string
   393|     {
   394|         return $this->editAs;
   395|     }
   396|     public function setEditAs(string $editAs): self
   397|     {
   398|         $this->editAs = $editAs;
   399|         return $this;
   400|     }
   401|     public function validEditAs(): bool
   402|     {
   403|         return in_array($this->editAs, self::VALID_EDIT_AS, true);
   404|     }
   405|     /**
   406|      * @return null|SimpleXMLElement|string[]
   407|      */
   408|     public function getSrcRect()
   409|     {
   410|         return $this->srcRect;
   411|     }
   412|     /**
   413|      * @param null|SimpleXMLElement|string[] $srcRect
   414|      */
   415|     public function setSrcRect($srcRect): self
   416|     {
   417|         $this->srcRect = $srcRect;
   418|         return $this;
   419|     }
   420|     public function setFlipHorizontal(bool $flipHorizontal): self
   421|     {
   422|         $this->flipHorizontal = $flipHorizontal;
   423|         return $this;
   424|     }
   425|     public function getFlipHorizontal(): bool
   426|     {
   427|         return $this->flipHorizontal;
   428|     }
   429|     public function setFlipVertical(bool $flipVertical): self
   430|     {
   431|         $this->flipVertical = $flipVertical;
   432|         return $this;
   433|     }
   434|     public function getFlipVertical(): bool
   435|     {
   436|         return $this->flipVertical;
   437|     }
   438| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/Drawing.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-203 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Worksheet;
     3| use PhpOffice\PhpSpreadsheet\Exception as PhpSpreadsheetException;
     4| use ZipArchive;
     5| class Drawing extends BaseDrawing
     6| {
     7|     const IMAGE_TYPES_CONVERTION_MAP = [
     8|         IMAGETYPE_GIF => IMAGETYPE_PNG,
     9|         IMAGETYPE_JPEG => IMAGETYPE_JPEG,
    10|         IMAGETYPE_PNG => IMAGETYPE_PNG,
    11|         IMAGETYPE_BMP => IMAGETYPE_PNG,
    12|     ];
    13|     /**
    14|      * Path.
    15|      */
    16|     private string $path;
    17|     /**
    18|      * Whether or not we are dealing with a URL.
    19|      */
    20|     private bool $isUrl;
    21|     /**
    22|      * Create a new Drawing.
    23|      */
    24|     public function __construct()
    25|     {
    26|         $this->path = '';
    27|         $this->isUrl = false;
    28|         parent::__construct();
    29|     }
    30|     /**
    31|      * Get Filename.
    32|      */
    33|     public function getFilename(): string
    34|     {
    35|         return basename($this->path);
    36|     }
    37|     /**
    38|      * Get indexed filename (using image index).
    39|      */
    40|     public function getIndexedFilename(): string
    41|     {
    42|         return md5($this->path) . '.' . $this->getExtension();
    43|     }
    44|     /**
    45|      * Get Extension.
    46|      */
    47|     public function getExtension(): string
    48|     {
    49|         $exploded = explode('.', basename($this->path));
    50|         return $exploded[count($exploded) - 1];
    51|     }
    52|     /**
    53|      * Get full filepath to store drawing in zip archive.
    54|      */
    55|     public function getMediaFilename(): string
    56|     {
    57|         if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
    58|             throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
    59|         }
    60|         return sprintf('image%d%s', $this->getImageIndex(), $this->getImageFileExtensionForSave());
    61|     }
    62|     /**
    63|      * Get Path.
    64|      */
    65|     public function getPath(): string
    66|     {
    67|         return $this->path;
    68|     }
    69|     /**
    70|      * Set Path.
    71|      *
    72|      * @param string $path File path
    73|      * @param bool $verifyFile Verify file
    74|      * @param ?ZipArchive $zip Zip archive instance
    75|      *
    76|      * @return $this
    77|      */
    78|     public function setPath(string $path, bool $verifyFile = true, ?ZipArchive $zip = null): static
    79|     {
    80|         $this->isUrl = false;
    81|         if (preg_match('~^data:image/[a-z]+;base64,~', $path) === 1) {
    82|             $this->path = $path;
    83|             return $this;
    84|         }
    85|         $this->path = '';
    86|         if (filter_var($path, FILTER_VALIDATE_URL)) {
    87|             if (!preg_match('/^(http|https|file|ftp|s3):/', $path)) {
    88|                 throw new PhpSpreadsheetException('Invalid protocol for linked drawing');
    89|             }
    90|             $this->isUrl = true;
    91|             $ctx = null;
    92|             if (str_starts_with($path, 'https:')) {
    93|                 $ctx = stream_context_create(['ssl' => ['crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT]]);
    94|             }
    95|             $imageContents = @file_get_contents($path, false, $ctx);
    96|             if ($imageContents !== false) {
    97|                 $filePath = tempnam(sys_get_temp_dir(), 'Drawing');
    98|                 if ($filePath) {
    99|                     $put = @file_put_contents($filePath, $imageContents);
   100|                     if ($put !== false) {
   101|                         if ($this->isImage($filePath)) {
   102|                             $this->path = $path;
   103|                             $this->setSizesAndType($filePath);
   104|                         }
   105|                         unlink($filePath);
   106|                     }
   107|                 }
   108|             }
   109|         } elseif ($zip instanceof ZipArchive) {
   110|             $zipPath = explode('#', $path)[1];
   111|             $locate = @$zip->locateName($zipPath);
   112|             if ($locate !== false) {
   113|                 if ($this->isImage($path)) {
   114|                     $this->path = $path;
   115|                     $this->setSizesAndType($path);
   116|                 }
   117|             }
   118|         } else {
   119|             $exists = @file_exists($path);
   120|             if ($exists !== false && $this->isImage($path)) {
   121|                 $this->path = $path;
   122|                 $this->setSizesAndType($path);
   123|             }
   124|         }
   125|         if ($this->path === '' && $verifyFile) {
   126|             throw new PhpSpreadsheetException("File $path not found!");
   127|         }
   128|         return $this;
   129|     }
   130|     private function isImage(string $path): bool
   131|     {
   132|         $mime = (string) @mime_content_type($path);
   133|         $retVal = false;
   134|         if (str_starts_with($mime, 'image/')) {
   135|             $retVal = true;
   136|         } elseif ($mime === 'application/octet-stream') {
   137|             $extension = pathinfo($path, PATHINFO_EXTENSION);
   138|             $retVal = in_array($extension, ['bin', 'emf'], true);
   139|         }
   140|         return $retVal;
   141|     }
   142|     /**
   143|      * Get isURL.
   144|      */
   145|     public function getIsURL(): bool
   146|     {
   147|         return $this->isUrl;
   148|     }
   149|     /**
   150|      * Set isURL.
   151|      *
   152|      * @return $this
   153|      */
   154|     public function setIsURL(bool $isUrl): self
   155|     {
   156|         $this->isUrl = $isUrl;
   157|         return $this;
   158|     }
   159|     /**
   160|      * Get hash code.
   161|      *
   162|      * @return string Hash code
   163|      */
   164|     public function getHashCode(): string
   165|     {
   166|         return md5(
   167|             $this->path
   168|             . parent::getHashCode()
   169|             . __CLASS__
   170|         );
   171|     }
   172|     /**
   173|      * Get Image Type for Save.
   174|      */
   175|     public function getImageTypeForSave(): int
   176|     {
   177|         if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
   178|             throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
   179|         }
   180|         return self::IMAGE_TYPES_CONVERTION_MAP[$this->type];
   181|     }
   182|     /**
   183|      * Get Image file extention for Save.
   184|      */
   185|     public function getImageFileExtensionForSave(bool $includeDot = true): string
   186|     {
   187|         if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
   188|             throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
   189|         }
   190|         $result = image_type_to_extension(self::IMAGE_TYPES_CONVERTION_MAP[$this->type], $includeDot);
   191|         return "$result";
   192|     }
   193|     /**
   194|      * Get Image mime type.
   195|      */
   196|     public function getImageMimeType(): string
   197|     {
   198|         if (!array_key_exists($this->type, self::IMAGE_TYPES_CONVERTION_MAP)) {
   199|             throw new PhpSpreadsheetException('Unsupported image type in comment background. Supported types: PNG, JPEG, BMP, GIF.');
   200|         }
   201|         return image_type_to_mime_type(self::IMAGE_TYPES_CONVERTION_MAP[$this->type]);
   202|     }
   203| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Worksheet/Worksheet.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3080-3106 ---
  3080|         $referenceHelper = ReferenceHelper::getInstance();
  3081|         foreach ($toArray as $destination) {
  3082|             if ($destination !== $fromCell) {
  3083|                 $toIndexes = Coordinate::indexesFromString($destination);
  3084|                 $this->getCell($destination)->setValue($referenceHelper->updateFormulaReferences($valueString, 'A1', $toIndexes[0] - $fromIndexes[0], $toIndexes[1] - $fromIndexes[1]));
  3085|                 if ($copyStyle) {
  3086|                     $this->getCell($destination)->getStyle()->applyFromArray($style);
  3087|                 }
  3088|             }
  3089|         }
  3090|     }
  3091|     public function applyStylesFromArray(string $coordinate, array $styleArray): bool
  3092|     {
  3093|         $spreadsheet = $this->parent;
  3094|         if ($spreadsheet === null) {
  3095|             return false;
  3096|         }
  3097|         $activeSheetIndex = $spreadsheet->getActiveSheetIndex();
  3098|         $originalSelected = $this->selectedCells;
  3099|         $this->getStyle($coordinate)->applyFromArray($styleArray);
  3100|         $this->setSelectedCells($originalSelected);
  3101|         if ($activeSheetIndex >= 0) {
  3102|             $spreadsheet->setActiveSheetIndex($activeSheetIndex);
  3103|         }
  3104|         return true;
  3105|     }
  3106| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Html.php
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 443-537 ---
   443|         return $html;
   444|     }
   445|     private function extendRowsAndColumns(Worksheet $worksheet, int &$colMax, int &$rowMax): void
   446|     {
   447|         if ($this->includeCharts) {
   448|             foreach ($worksheet->getChartCollection() as $chart) {
   449|                 if ($chart instanceof Chart) {
   450|                     $chartCoordinates = $chart->getTopLeftPosition();
   451|                     $this->sheetCharts[$chartCoordinates['cell']] = $chart;
   452|                     $chartTL = Coordinate::indexesFromString($chartCoordinates['cell']);
   453|                     if ($chartTL[1] > $rowMax) {
   454|                         $rowMax = $chartTL[1];
   455|                     }
   456|                     if ($chartTL[0] > $colMax) {
   457|                         $colMax = $chartTL[0];
   458|                     }
   459|                 }
   460|             }
   461|         }
   462|         foreach ($worksheet->getDrawingCollection() as $drawing) {
   463|             if ($drawing instanceof Drawing && $drawing->getPath() === '') {
   464|                 continue;
   465|             }
   466|             $imageTL = Coordinate::indexesFromString($drawing->getCoordinates());
   467|             $this->sheetDrawings[$drawing->getCoordinates()] = $drawing;
   468|             if ($imageTL[1] > $rowMax) {
   469|                 $rowMax = $imageTL[1];
   470|             }
   471|             if ($imageTL[0] > $colMax) {
   472|                 $colMax = $imageTL[0];
   473|             }
   474|         }
   475|     }
   476|     /**
   477|      * Convert Windows file name to file protocol URL.
   478|      *
   479|      * @param string $filename file name on local system
   480|      */
   481|     public static function winFileToUrl(string $filename, bool $mpdf = false): string
   482|     {
   483|         if (substr($filename, 1, 2) === ':\\') {
   484|             $protocol = $mpdf ? '' : 'file:///';
   485|             $filename = $protocol . str_replace('\\', '/', $filename);
   486|         }
   487|         return $filename;
   488|     }
   489|     /**
   490|      * Generate image tag in cell.
   491|      *
   492|      * @param string $coordinates Cell coordinates
   493|      */
   494|     private function writeImageInCell(string $coordinates): string
   495|     {
   496|         $html = '';
   497|         $drawing = $this->sheetDrawings[$coordinates] ?? null;
   498|         if ($drawing !== null) {
   499|             $filedesc = $drawing->getDescription();
   500|             $filedesc = $filedesc ? htmlspecialchars($filedesc, ENT_QUOTES) : 'Embedded image';
   501|             if ($drawing instanceof Drawing && $drawing->getPath() !== '') {
   502|                 $filename = $drawing->getPath();
   503|                 $filename = (string) preg_replace('/^[.]/', '', $filename);
   504|                 $filename = $this->getImagesRoot() . $filename;
   505|                 $filename = (string) preg_replace('@^[.]([^/])@', '$1', $filename);
   506|                 $filename = htmlspecialchars($filename, Settings::htmlEntityFlags());
   507|                 $html .= PHP_EOL;
   508|                 $imageData = self::winFileToUrl($filename, $this instanceof Pdf\Mpdf);
   509|                 if ($this->embedImages || str_starts_with($imageData, 'zip://')) {
   510|                     $imageData = 'data:,';
   511|                     $picture = @file_get_contents($filename);
   512|                     if ($picture !== false) {
   513|                         $mimeContentType = (string) @mime_content_type($filename);
   514|                         if (str_starts_with($mimeContentType, 'image/')) {
   515|                             $base64 = base64_encode($picture);
   516|                             $imageData = 'data:' . $mimeContentType . ';base64,' . $base64;
   517|                         }
   518|                     }
   519|                 }
   520|                 $html .= '<img style="position: absolute; z-index: 1; left: '
   521|                     . $drawing->getOffsetX() . 'px; top: ' . $drawing->getOffsetY() . 'px; width: '
   522|                     . $drawing->getWidth() . 'px; height: ' . $drawing->getHeight() . 'px;" src="'
   523|                     . $imageData . '" alt="' . $filedesc . '" />';
   524|             } elseif ($drawing instanceof MemoryDrawing) {
   525|                 $imageResource = $drawing->getImageResource();
   526|                 if ($imageResource) {
   527|                     ob_start(); //  Let's start output buffering.
   528|                     imagepng($imageResource); //  This will normally output the image, but because of ob_start(), it won't.
   529|                     $contents = (string) ob_get_contents(); //  Instead, output above is saved to $contents
   530|                     ob_end_clean(); //  End the output buffer.
   531|                     $dataUri = 'data:image/png;base64,' . base64_encode($contents);
   532|                     $html .= '<img alt="' . $filedesc . '" src="' . $dataUri . '" style="width:' . $drawing->getWidth() . 'px;left: '
   533|                         . $drawing->getOffsetX() . 'px; top: ' . $drawing->getOffsetY() . 'px;position: absolute; z-index: 1;" />';
   534|                 }
   535|             }
   536|         }
   537|         return $html;

# --- HUNK 2: Lines 1151-1198 ---
  1151|         $html .= $this->writeComment($worksheet, $coordinate);
  1152|         $html .= $cellData;
  1153|         $html .= '</' . $cellType . '>' . PHP_EOL;
  1154|     }
  1155|     /**
  1156|      * Generate row.
  1157|      *
  1158|      * @param array $values Array containing cells in a row
  1159|      * @param int $row Row number (0-based)
  1160|      * @param string $cellType eg: 'td'
  1161|      */
  1162|     private function generateRow(Worksheet $worksheet, array $values, int $row, string $cellType): string
  1163|     {
  1164|         $sheetIndex = $worksheet->getParentOrThrow()->getIndex($worksheet);
  1165|         $html = $this->generateRowStart($worksheet, $sheetIndex, $row);
  1166|         $colNum = 0;
  1167|         foreach ($values as $cellAddress) {
  1168|             [$cell, $cssClass, $coordinate] = $this->generateRowCellCss($worksheet, $cellAddress, $row, $colNum);
  1169|             $cellData = $this->generateRowCellData($worksheet, $cell, $cssClass);
  1170|             if ($worksheet->hyperlinkExists($coordinate) && !$worksheet->getHyperlink($coordinate)->isInternal()) {
  1171|                 $url = $worksheet->getHyperlink($coordinate)->getUrl();
  1172|                 $urldecode = strtolower(html_entity_decode(trim($url), encoding: 'UTF-8'));
  1173|                 $parseScheme = preg_match('/^(\\w+):/', $urldecode, $matches);
  1174|                 if ($parseScheme === 1 && !in_array($matches[1], ['http', 'https', 'file', 'ftp', 's3'], true)) {
  1175|                     $cellData = htmlspecialchars($url, Settings::htmlEntityFlags());
  1176|                 } else {
  1177|                     $cellData = '<a href="' . htmlspecialchars($url, Settings::htmlEntityFlags()) . '" title="' . htmlspecialchars($worksheet->getHyperlink($coordinate)->getTooltip(), Settings::htmlEntityFlags()) . '">' . $cellData . '</a>';
  1178|                 }
  1179|             }
  1180|             $writeCell = !(isset($this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])
  1181|                 && $this->isSpannedCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum]);
  1182|             $colSpan = 1;
  1183|             $rowSpan = 1;
  1184|             if (isset($this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum])) {
  1185|                 $spans = $this->isBaseCell[$worksheet->getParentOrThrow()->getIndex($worksheet)][$row + 1][$colNum];
  1186|                 $rowSpan = $spans['rowspan'];
  1187|                 $colSpan = $spans['colspan'];
  1188|                 $endCellCoord = Coordinate::stringFromColumnIndex($colNum + $colSpan) . ($row + $rowSpan);
  1189|                 if (!$this->useInlineCss) {
  1190|                     $cssClass .= ' style' . $worksheet->getCell($endCellCoord)->getXfIndex();
  1191|                 } else {
  1192|                     $endBorders = $this->spreadsheet->getCellXfByIndex($worksheet->getCell($endCellCoord)->getXfIndex())->getBorders();
  1193|                     $altBorders = $this->createCSSStyleBorders($endBorders);
  1194|                     foreach ($altBorders as $altKey => $altValue) {
  1195|                         if (str_contains($altValue, '!important')) {
  1196|                             $cssClass[$altKey] = $altValue;
  1197|                         }
  1198|                     }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xls.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 312-352 ---
   312|                 if ($newImage === false) {
   313|                     throw new Exception("Unable to create image from $filename");
   314|                 }
   315|                 ob_start();
   316|                 imagepng($newImage);
   317|                 $blipData = ob_get_contents();
   318|                 ob_end_clean();
   319|                 break;
   320|         }
   321|         if ($blipData) {
   322|             $blip = new Blip();
   323|             $blip->setData($blipData);
   324|             $BSE = new BSE();
   325|             $BSE->setBlipType($blipType);
   326|             $BSE->setBlip($blip);
   327|             $bstoreContainer->addBSE($BSE);
   328|         }
   329|     }
   330|     private function processBaseDrawing(BstoreContainer &$bstoreContainer, BaseDrawing $drawing): void
   331|     {
   332|         if ($drawing instanceof Drawing && $drawing->getPath() !== '') {
   333|             $this->processDrawing($bstoreContainer, $drawing);
   334|         } elseif ($drawing instanceof MemoryDrawing) {
   335|             $this->processMemoryDrawing($bstoreContainer, $drawing, $drawing->getRenderingFunction());
   336|         }
   337|     }
   338|     private function checkForDrawings(): bool
   339|     {
   340|         $found = false;
   341|         foreach ($this->spreadsheet->getAllSheets() as $sheet) {
   342|             if (count($sheet->getDrawingCollection()) > 0) {
   343|                 $found = true;
   344|                 break;
   345|             }
   346|         }
   347|         return $found;
   348|     }
   349|     /**
   350|      * Build the Escher object corresponding to the MSODRAWINGGROUP record.
   351|      */
   352|     private function buildWorkbookEscher(): void


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-564 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer;
     3| use PhpOffice\PhpSpreadsheet\Calculation\Calculation;
     4| use PhpOffice\PhpSpreadsheet\Calculation\Functions;
     5| use PhpOffice\PhpSpreadsheet\HashTable;
     6| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     7| use PhpOffice\PhpSpreadsheet\Style\Borders;
     8| use PhpOffice\PhpSpreadsheet\Style\Conditional;
     9| use PhpOffice\PhpSpreadsheet\Style\Fill;
    10| use PhpOffice\PhpSpreadsheet\Style\Font;
    11| use PhpOffice\PhpSpreadsheet\Style\NumberFormat;
    12| use PhpOffice\PhpSpreadsheet\Worksheet\BaseDrawing;
    13| use PhpOffice\PhpSpreadsheet\Worksheet\Drawing as WorksheetDrawing;
    14| use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
    15| use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
    16| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Chart;
    17| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Comments;
    18| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\ContentTypes;
    19| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\DocProps;
    20| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Drawing;
    21| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Rels;
    22| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\RelsRibbon;
    23| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\RelsVBA;
    24| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\StringTable;
    25| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Style;
    26| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Table;
    27| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Theme;
    28| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Workbook;
    29| use PhpOffice\PhpSpreadsheet\Writer\Xlsx\Worksheet;
    30| use ZipArchive;
    31| use ZipStream\Exception\OverflowException;
    32| use ZipStream\ZipStream;
    33| class Xlsx extends BaseWriter
    34| {
    35|     /**
    36|      * Office2003 compatibility.
    37|      */
    38|     private bool $office2003compatibility = false;
    39|     /**
    40|      * Private Spreadsheet.
    41|      */
    42|     private Spreadsheet $spreadSheet;
    43|     /**
    44|      * Private string table.
    45|      *
    46|      * @var string[]
    47|      */
    48|     private array $stringTable = [];
    49|     /**
    50|      * Private unique Conditional HashTable.
    51|      *
    52|      * @var HashTable<Conditional>
    53|      */
    54|     private HashTable $stylesConditionalHashTable;
    55|     /**
    56|      * Private unique Style HashTable.
    57|      *
    58|      * @var HashTable<\PhpOffice\PhpSpreadsheet\Style\Style>
    59|      */
    60|     private HashTable $styleHashTable;
    61|     /**
    62|      * Private unique Fill HashTable.
    63|      *
    64|      * @var HashTable<Fill>
    65|      */
    66|     private HashTable $fillHashTable;
    67|     /**
    68|      * Private unique \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
    69|      *
    70|      * @var HashTable<Font>
    71|      */
    72|     private HashTable $fontHashTable;
    73|     /**
    74|      * Private unique Borders HashTable.
    75|      *
    76|      * @var HashTable<Borders>
    77|      */
    78|     private HashTable $bordersHashTable;
    79|     /**
    80|      * Private unique NumberFormat HashTable.
    81|      *
    82|      * @var HashTable<NumberFormat>
    83|      */
    84|     private HashTable $numFmtHashTable;
    85|     /**
    86|      * Private unique \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
    87|      *
    88|      * @var HashTable<BaseDrawing>
    89|      */
    90|     private HashTable $drawingHashTable;
    91|     /**
    92|      * Private handle for zip stream.
    93|      */
    94|     private ZipStream $zip;
    95|     private Chart $writerPartChart;
    96|     private Comments $writerPartComments;
    97|     private ContentTypes $writerPartContentTypes;
    98|     private DocProps $writerPartDocProps;
    99|     private Drawing $writerPartDrawing;
   100|     private Rels $writerPartRels;
   101|     private RelsRibbon $writerPartRelsRibbon;
   102|     private RelsVBA $writerPartRelsVBA;
   103|     private StringTable $writerPartStringTable;
   104|     private Style $writerPartStyle;
   105|     private Theme $writerPartTheme;
   106|     private Table $writerPartTable;
   107|     private Workbook $writerPartWorkbook;
   108|     private Worksheet $writerPartWorksheet;
   109|     private bool $explicitStyle0 = false;
   110|     /**
   111|      * Create a new Xlsx Writer.
   112|      */
   113|     public function __construct(Spreadsheet $spreadsheet)
   114|     {
   115|         $this->setSpreadsheet($spreadsheet);
   116|         $this->writerPartChart = new Chart($this);
   117|         $this->writerPartComments = new Comments($this);
   118|         $this->writerPartContentTypes = new ContentTypes($this);
   119|         $this->writerPartDocProps = new DocProps($this);
   120|         $this->writerPartDrawing = new Drawing($this);
   121|         $this->writerPartRels = new Rels($this);
   122|         $this->writerPartRelsRibbon = new RelsRibbon($this);
   123|         $this->writerPartRelsVBA = new RelsVBA($this);
   124|         $this->writerPartStringTable = new StringTable($this);
   125|         $this->writerPartStyle = new Style($this);
   126|         $this->writerPartTheme = new Theme($this);
   127|         $this->writerPartTable = new Table($this);
   128|         $this->writerPartWorkbook = new Workbook($this);
   129|         $this->writerPartWorksheet = new Worksheet($this);
   130|         $this->bordersHashTable = new HashTable();
   131|         $this->drawingHashTable = new HashTable();
   132|         $this->fillHashTable = new HashTable();
   133|         $this->fontHashTable = new HashTable();
   134|         $this->numFmtHashTable = new HashTable();
   135|         $this->styleHashTable = new HashTable();
   136|         $this->stylesConditionalHashTable = new HashTable();
   137|     }
   138|     public function getWriterPartChart(): Chart
   139|     {
   140|         return $this->writerPartChart;
   141|     }
   142|     public function getWriterPartComments(): Comments
   143|     {
   144|         return $this->writerPartComments;
   145|     }
   146|     public function getWriterPartContentTypes(): ContentTypes
   147|     {
   148|         return $this->writerPartContentTypes;
   149|     }
   150|     public function getWriterPartDocProps(): DocProps
   151|     {
   152|         return $this->writerPartDocProps;
   153|     }
   154|     public function getWriterPartDrawing(): Drawing
   155|     {
   156|         return $this->writerPartDrawing;
   157|     }
   158|     public function getWriterPartRels(): Rels
   159|     {
   160|         return $this->writerPartRels;
   161|     }
   162|     public function getWriterPartRelsRibbon(): RelsRibbon
   163|     {
   164|         return $this->writerPartRelsRibbon;
   165|     }
   166|     public function getWriterPartRelsVBA(): RelsVBA
   167|     {
   168|         return $this->writerPartRelsVBA;
   169|     }
   170|     public function getWriterPartStringTable(): StringTable
   171|     {
   172|         return $this->writerPartStringTable;
   173|     }
   174|     public function getWriterPartStyle(): Style
   175|     {
   176|         return $this->writerPartStyle;
   177|     }
   178|     public function getWriterPartTheme(): Theme
   179|     {
   180|         return $this->writerPartTheme;
   181|     }
   182|     public function getWriterPartTable(): Table
   183|     {
   184|         return $this->writerPartTable;
   185|     }
   186|     public function getWriterPartWorkbook(): Workbook
   187|     {
   188|         return $this->writerPartWorkbook;
   189|     }
   190|     public function getWriterPartWorksheet(): Worksheet
   191|     {
   192|         return $this->writerPartWorksheet;
   193|     }
   194|     /**
   195|      * Save PhpSpreadsheet to file.
   196|      *
   197|      * @param resource|string $filename
   198|      */
   199|     public function save($filename, int $flags = 0): void
   200|     {
   201|         $this->processFlags($flags);
   202|         $this->pathNames = [];
   203|         $this->spreadSheet->garbageCollect();
   204|         $saveDebugLog = Calculation::getInstance($this->spreadSheet)->getDebugLog()->getWriteDebugLog();
   205|         Calculation::getInstance($this->spreadSheet)->getDebugLog()->setWriteDebugLog(false);
   206|         $saveDateReturnType = Functions::getReturnDateType();
   207|         Functions::setReturnDateType(Functions::RETURNDATE_EXCEL);
   208|         $this->stringTable = [];
   209|         for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
   210|             $this->stringTable = $this->getWriterPartStringTable()->createStringTable($this->spreadSheet->getSheet($i), $this->stringTable);
   211|         }
   212|         $this->styleHashTable->addFromSource($this->getWriterPartStyle()->allStyles($this->spreadSheet));
   213|         $this->stylesConditionalHashTable->addFromSource($this->getWriterPartStyle()->allConditionalStyles($this->spreadSheet));
   214|         $this->fillHashTable->addFromSource($this->getWriterPartStyle()->allFills($this->spreadSheet));
   215|         $this->fontHashTable->addFromSource($this->getWriterPartStyle()->allFonts($this->spreadSheet));
   216|         $this->bordersHashTable->addFromSource($this->getWriterPartStyle()->allBorders($this->spreadSheet));
   217|         $this->numFmtHashTable->addFromSource($this->getWriterPartStyle()->allNumberFormats($this->spreadSheet));
   218|         $this->drawingHashTable->addFromSource($this->getWriterPartDrawing()->allDrawings($this->spreadSheet));
   219|         $zipContent = [];
   220|         $zipContent['[Content_Types].xml'] = $this->getWriterPartContentTypes()->writeContentTypes($this->spreadSheet, $this->includeCharts);
   221|         if ($this->spreadSheet->hasMacros()) {
   222|             $macrosCode = $this->spreadSheet->getMacrosCode();
   223|             if ($macrosCode !== null) {
   224|                 $zipContent['xl/vbaProject.bin'] = $macrosCode; //allways in 'xl', allways named vbaProject.bin
   225|                 if ($this->spreadSheet->hasMacrosCertificate()) {
   226|                     $zipContent['xl/vbaProjectSignature.bin'] = $this->spreadSheet->getMacrosCertificate();
   227|                     $zipContent['xl/_rels/vbaProject.bin.rels'] = $this->getWriterPartRelsVBA()->writeVBARelationships();
   228|                 }
   229|             }
   230|         }
   231|         if ($this->spreadSheet->hasRibbon()) {
   232|             $tmpRibbonTarget = $this->spreadSheet->getRibbonXMLData('target');
   233|             $tmpRibbonTarget = is_string($tmpRibbonTarget) ? $tmpRibbonTarget : '';
   234|             $zipContent[$tmpRibbonTarget] = $this->spreadSheet->getRibbonXMLData('data');
   235|             if ($this->spreadSheet->hasRibbonBinObjects()) {
   236|                 $tmpRootPath = dirname($tmpRibbonTarget) . '/';
   237|                 $ribbonBinObjects = $this->spreadSheet->getRibbonBinObjects('data'); //the files to write
   238|                 if (is_array($ribbonBinObjects)) {
   239|                     foreach ($ribbonBinObjects as $aPath => $aContent) {
   240|                         $zipContent[$tmpRootPath . $aPath] = $aContent;
   241|                     }
   242|                 }
   243|                 $zipContent[$tmpRootPath . '_rels/' . basename($tmpRibbonTarget) . '.rels'] = $this->getWriterPartRelsRibbon()->writeRibbonRelationships($this->spreadSheet);
   244|             }
   245|         }
   246|         $zipContent['_rels/.rels'] = $this->getWriterPartRels()->writeRelationships($this->spreadSheet);
   247|         $zipContent['xl/_rels/workbook.xml.rels'] = $this->getWriterPartRels()->writeWorkbookRelationships($this->spreadSheet);
   248|         $zipContent['docProps/app.xml'] = $this->getWriterPartDocProps()->writeDocPropsApp($this->spreadSheet);
   249|         $zipContent['docProps/core.xml'] = $this->getWriterPartDocProps()->writeDocPropsCore($this->spreadSheet);
   250|         $customPropertiesPart = $this->getWriterPartDocProps()->writeDocPropsCustom($this->spreadSheet);
   251|         if ($customPropertiesPart !== null) {
   252|             $zipContent['docProps/custom.xml'] = $customPropertiesPart;
   253|         }
   254|         $zipContent['xl/theme/theme1.xml'] = $this->getWriterPartTheme()->writeTheme($this->spreadSheet);
   255|         $zipContent['xl/sharedStrings.xml'] = $this->getWriterPartStringTable()->writeStringTable($this->stringTable);
   256|         $zipContent['xl/styles.xml'] = $this->getWriterPartStyle()->writeStyles($this->spreadSheet);
   257|         $zipContent['xl/workbook.xml'] = $this->getWriterPartWorkbook()->writeWorkbook($this->spreadSheet, $this->preCalculateFormulas);
   258|         $chartCount = 0;
   259|         for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
   260|             $zipContent['xl/worksheets/sheet' . ($i + 1) . '.xml'] = $this->getWriterPartWorksheet()->writeWorksheet($this->spreadSheet->getSheet($i), $this->stringTable, $this->includeCharts);
   261|             if ($this->includeCharts) {
   262|                 $charts = $this->spreadSheet->getSheet($i)->getChartCollection();
   263|                 if (count($charts) > 0) {
   264|                     foreach ($charts as $chart) {
   265|                         $zipContent['xl/charts/chart' . ($chartCount + 1) . '.xml'] = $this->getWriterPartChart()->writeChart($chart, $this->preCalculateFormulas);
   266|                         ++$chartCount;
   267|                     }
   268|                 }
   269|             }
   270|         }
   271|         $chartRef1 = 0;
   272|         $tableRef1 = 1;
   273|         for ($i = 0; $i < $this->spreadSheet->getSheetCount(); ++$i) {
   274|             $zipContent['xl/worksheets/_rels/sheet' . ($i + 1) . '.xml.rels'] = $this->getWriterPartRels()->writeWorksheetRelationships($this->spreadSheet->getSheet($i), ($i + 1), $this->includeCharts, $tableRef1, $zipContent);
   275|             $sheetCodeName = $this->spreadSheet->getSheet($i)->getCodeName();
   276|             $unparsedLoadedData = $this->spreadSheet->getUnparsedLoadedData();
   277|             if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['ctrlProps'])) {
   278|                 foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['ctrlProps'] as $ctrlProp) {
   279|                     $zipContent[$ctrlProp['filePath']] = $ctrlProp['content'];
   280|                 }
   281|             }
   282|             if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['printerSettings'])) {
   283|                 foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['printerSettings'] as $ctrlProp) {
   284|                     $zipContent[$ctrlProp['filePath']] = $ctrlProp['content'];
   285|                 }
   286|             }
   287|             $drawings = $this->spreadSheet->getSheet($i)->getDrawingCollection();
   288|             $drawingCount = count($drawings);
   289|             if ($this->includeCharts) {
   290|                 $chartCount = $this->spreadSheet->getSheet($i)->getChartCount();
   291|             }
   292|             if (($drawingCount > 0) || ($chartCount > 0)) {
   293|                 $zipContent['xl/drawings/_rels/drawing' . ($i + 1) . '.xml.rels'] = $this->getWriterPartRels()->writeDrawingRelationships($this->spreadSheet->getSheet($i), $chartRef1, $this->includeCharts);
   294|                 $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $this->getWriterPartDrawing()->writeDrawings($this->spreadSheet->getSheet($i), $this->includeCharts);
   295|             } elseif (isset($unparsedLoadedData['sheets'][$sheetCodeName]['drawingAlternateContents'])) {
   296|                 $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $this->getWriterPartDrawing()->writeDrawings($this->spreadSheet->getSheet($i), $this->includeCharts);
   297|             }
   298|             if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['Drawings']) && !isset($zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'])) {
   299|                 foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['Drawings'] as $relId => $drawingXml) {
   300|                     $drawingFile = array_search($relId, $unparsedLoadedData['sheets'][$sheetCodeName]['drawingOriginalIds']);
   301|                     if ($drawingFile !== false) {
   302|                         $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = $drawingXml;
   303|                     }
   304|                 }
   305|             }
   306|             if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['drawingOriginalIds']) && !isset($zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'])) {
   307|                 $zipContent['xl/drawings/drawing' . ($i + 1) . '.xml'] = '<xml></xml>';
   308|             }
   309|             $legacy = $unparsedLoadedData['sheets'][$this->spreadSheet->getSheet($i)->getCodeName()]['legacyDrawing'] ?? null;
   310|             if (count($this->spreadSheet->getSheet($i)->getComments()) > 0 || $legacy !== null) {
   311|                 $zipContent['xl/drawings/_rels/vmlDrawing' . ($i + 1) . '.vml.rels'] = $this->getWriterPartRels()->writeVMLDrawingRelationships($this->spreadSheet->getSheet($i));
   312|                 $zipContent['xl/drawings/vmlDrawing' . ($i + 1) . '.vml'] = $legacy ?? $this->getWriterPartComments()->writeVMLComments($this->spreadSheet->getSheet($i));
   313|             }
   314|             if (count($this->spreadSheet->getSheet($i)->getComments()) > 0) {
   315|                 $zipContent['xl/comments' . ($i + 1) . '.xml'] = $this->getWriterPartComments()->writeComments($this->spreadSheet->getSheet($i));
   316|                 foreach ($this->spreadSheet->getSheet($i)->getComments() as $comment) {
   317|                     if ($comment->hasBackgroundImage()) {
   318|                         $image = $comment->getBackgroundImage();
   319|                         $zipContent['xl/media/' . $image->getMediaFilename()] = $this->processDrawing($image);
   320|                     }
   321|                 }
   322|             }
   323|             if (isset($unparsedLoadedData['sheets'][$sheetCodeName]['vmlDrawings'])) {
   324|                 foreach ($unparsedLoadedData['sheets'][$sheetCodeName]['vmlDrawings'] as $vmlDrawing) {
   325|                     if (!isset($zipContent[$vmlDrawing['filePath']])) {
   326|                         $zipContent[$vmlDrawing['filePath']] = $vmlDrawing['content'];
   327|                     }
   328|                 }
   329|             }
   330|             if (count($this->spreadSheet->getSheet($i)->getHeaderFooter()->getImages()) > 0) {
   331|                 $zipContent['xl/drawings/vmlDrawingHF' . ($i + 1) . '.vml'] = $this->getWriterPartDrawing()->writeVMLHeaderFooterImages($this->spreadSheet->getSheet($i));
   332|                 $zipContent['xl/drawings/_rels/vmlDrawingHF' . ($i + 1) . '.vml.rels'] = $this->getWriterPartRels()->writeHeaderFooterDrawingRelationships($this->spreadSheet->getSheet($i));
   333|                 foreach ($this->spreadSheet->getSheet($i)->getHeaderFooter()->getImages() as $image) {
   334|                     if ($image->getPath() !== '') {
   335|                         $zipContent['xl/media/' . $image->getIndexedFilename()] = file_get_contents($image->getPath());
   336|                     }
   337|                 }
   338|             }
   339|             $tables = $this->spreadSheet->getSheet($i)->getTableCollection();
   340|             foreach ($tables as $table) {
   341|                 $zipContent['xl/tables/table' . $tableRef1 . '.xml'] = $this->getWriterPartTable()->writeTable($table, $tableRef1++);
   342|             }
   343|         }
   344|         for ($i = 0; $i < $this->getDrawingHashTable()->count(); ++$i) {
   345|             if ($this->getDrawingHashTable()->getByIndex($i) instanceof WorksheetDrawing) {
   346|                 $imageContents = null;
   347|                 $imagePath = $this->getDrawingHashTable()->getByIndex($i)->getPath();
   348|                 if ($imagePath === '') {
   349|                     continue;
   350|                 }
   351|                 if (str_contains($imagePath, 'zip://')) {
   352|                     $imagePath = substr($imagePath, 6);
   353|                     $imagePathSplitted = explode('#', $imagePath);
   354|                     $imageZip = new ZipArchive();
   355|                     $imageZip->open($imagePathSplitted[0]);
   356|                     $imageContents = $imageZip->getFromName($imagePathSplitted[1]);
   357|                     $imageZip->close();
   358|                     unset($imageZip);
   359|                 } else {
   360|                     $imageContents = file_get_contents($imagePath);
   361|                 }
   362|                 $zipContent['xl/media/' . $this->getDrawingHashTable()->getByIndex($i)->getIndexedFilename()] = $imageContents;
   363|             } elseif ($this->getDrawingHashTable()->getByIndex($i) instanceof MemoryDrawing) {
   364|                 ob_start();
   365|                 /** @var callable $callable */
   366|                 $callable = $this->getDrawingHashTable()->getByIndex($i)->getRenderingFunction();
   367|                 call_user_func(
   368|                     $callable,
   369|                     $this->getDrawingHashTable()->getByIndex($i)->getImageResource()
   370|                 );
   371|                 $imageContents = ob_get_contents();
   372|                 ob_end_clean();
   373|                 $zipContent['xl/media/' . $this->getDrawingHashTable()->getByIndex($i)->getIndexedFilename()] = $imageContents;
   374|             }
   375|         }
   376|         Functions::setReturnDateType($saveDateReturnType);
   377|         Calculation::getInstance($this->spreadSheet)->getDebugLog()->setWriteDebugLog($saveDebugLog);
   378|         $this->openFileHandle($filename);
   379|         $this->zip = ZipStream0::newZipStream($this->fileHandle);
   380|         $this->addZipFiles($zipContent);
   381|         try {
   382|             $this->zip->finish();
   383|         } catch (OverflowException) {
   384|             throw new WriterException('Could not close resource.');
   385|         }
   386|         $this->maybeCloseFileHandle();
   387|     }
   388|     /**
   389|      * Get Spreadsheet object.
   390|      */
   391|     public function getSpreadsheet(): Spreadsheet
   392|     {
   393|         return $this->spreadSheet;
   394|     }
   395|     /**
   396|      * Set Spreadsheet object.
   397|      *
   398|      * @param Spreadsheet $spreadsheet PhpSpreadsheet object
   399|      *
   400|      * @return $this
   401|      */
   402|     public function setSpreadsheet(Spreadsheet $spreadsheet): static
   403|     {
   404|         $this->spreadSheet = $spreadsheet;
   405|         return $this;
   406|     }
   407|     /**
   408|      * Get string table.
   409|      *
   410|      * @return string[]
   411|      */
   412|     public function getStringTable(): array
   413|     {
   414|         return $this->stringTable;
   415|     }
   416|     /**
   417|      * Get Style HashTable.
   418|      *
   419|      * @return HashTable<\PhpOffice\PhpSpreadsheet\Style\Style>
   420|      */
   421|     public function getStyleHashTable(): HashTable
   422|     {
   423|         return $this->styleHashTable;
   424|     }
   425|     /**
   426|      * Get Conditional HashTable.
   427|      *
   428|      * @return HashTable<Conditional>
   429|      */
   430|     public function getStylesConditionalHashTable(): HashTable
   431|     {
   432|         return $this->stylesConditionalHashTable;
   433|     }
   434|     /**
   435|      * Get Fill HashTable.
   436|      *
   437|      * @return HashTable<Fill>
   438|      */
   439|     public function getFillHashTable(): HashTable
   440|     {
   441|         return $this->fillHashTable;
   442|     }
   443|     /**
   444|      * Get \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
   445|      *
   446|      * @return HashTable<Font>
   447|      */
   448|     public function getFontHashTable(): HashTable
   449|     {
   450|         return $this->fontHashTable;
   451|     }
   452|     /**
   453|      * Get Borders HashTable.
   454|      *
   455|      * @return HashTable<Borders>
   456|      */
   457|     public function getBordersHashTable(): HashTable
   458|     {
   459|         return $this->bordersHashTable;
   460|     }
   461|     /**
   462|      * Get NumberFormat HashTable.
   463|      *
   464|      * @return HashTable<NumberFormat>
   465|      */
   466|     public function getNumFmtHashTable(): HashTable
   467|     {
   468|         return $this->numFmtHashTable;
   469|     }
   470|     /**
   471|      * Get \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
   472|      *
   473|      * @return HashTable<BaseDrawing>
   474|      */
   475|     public function getDrawingHashTable(): HashTable
   476|     {
   477|         return $this->drawingHashTable;
   478|     }
   479|     /**
   480|      * Get Office2003 compatibility.
   481|      */
   482|     public function getOffice2003Compatibility(): bool
   483|     {
   484|         return $this->office2003compatibility;
   485|     }
   486|     /**
   487|      * Set Office2003 compatibility.
   488|      *
   489|      * @param bool $office2003compatibility Office2003 compatibility?
   490|      *
   491|      * @return $this
   492|      */
   493|     public function setOffice2003Compatibility(bool $office2003compatibility): static
   494|     {
   495|         $this->office2003compatibility = $office2003compatibility;
   496|         return $this;
   497|     }
   498|     private array $pathNames = [];
   499|     private function addZipFile(string $path, string $content): void
   500|     {
   501|         if (!in_array($path, $this->pathNames)) {
   502|             $this->pathNames[] = $path;
   503|             $this->zip->addFile($path, $content);
   504|         }
   505|     }
   506|     private function addZipFiles(array $zipContent): void
   507|     {
   508|         foreach ($zipContent as $path => $content) {
   509|             $this->addZipFile($path, $content);
   510|         }
   511|     }
   512|     private function processDrawing(WorksheetDrawing $drawing): string|null|false
   513|     {
   514|         $data = null;
   515|         $filename = $drawing->getPath();
   516|         if ($filename === '') {
   517|             return null;
   518|         }
   519|         $imageData = getimagesize($filename);
   520|         if (!empty($imageData)) {
   521|             switch ($imageData[2]) {
   522|                 case 1: // GIF, not supported by BIFF8, we convert to PNG
   523|                     $image = imagecreatefromgif($filename);
   524|                     if ($image !== false) {
   525|                         ob_start();
   526|                         imagepng($image);
   527|                         $data = ob_get_contents();
   528|                         ob_end_clean();
   529|                     }
   530|                     break;
   531|                 case 2: // JPEG
   532|                     $data = file_get_contents($filename);
   533|                     break;
   534|                 case 3: // PNG
   535|                     $data = file_get_contents($filename);
   536|                     break;
   537|                 case 6: // Windows DIB (BMP), we convert to PNG
   538|                     $image = imagecreatefrombmp($filename);
   539|                     if ($image !== false) {
   540|                         ob_start();
   541|                         imagepng($image);
   542|                         $data = ob_get_contents();
   543|                         ob_end_clean();
   544|                     }
   545|                     break;
   546|             }
   547|         }
   548|         return $data;
   549|     }
   550|     public function getExplicitStyle0(): bool
   551|     {
   552|         return $this->explicitStyle0;
   553|     }
   554|     /**
   555|      * This may be useful if non-default Alignment is part of default style
   556|      * and you think you might want to open the spreadsheet
   557|      * with LibreOffice or Gnumeric.
   558|      */
   559|     public function setExplicitStyle0(bool $explicitStyle0): self
   560|     {
   561|         $this->explicitStyle0 = $explicitStyle0;
   562|         return $this;
   563|     }
   564| }


# ====================================================================
# FILE: src/PhpSpreadsheet/Writer/Xlsx/ContentTypes.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-207 ---
     1| <?php
     2| namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx;
     3| use PhpOffice\PhpSpreadsheet\Reader\Xlsx\Namespaces;
     4| use PhpOffice\PhpSpreadsheet\Shared\File;
     5| use PhpOffice\PhpSpreadsheet\Shared\XMLWriter;
     6| use PhpOffice\PhpSpreadsheet\Spreadsheet;
     7| use PhpOffice\PhpSpreadsheet\Worksheet\Drawing as WorksheetDrawing;
     8| use PhpOffice\PhpSpreadsheet\Worksheet\MemoryDrawing;
     9| use PhpOffice\PhpSpreadsheet\Writer\Exception as WriterException;
    10| class ContentTypes extends WriterPart
    11| {
    12|     /**
    13|      * Write content types to XML format.
    14|      *
    15|      * @param bool $includeCharts Flag indicating if we should include drawing details for charts
    16|      *
    17|      * @return string XML Output
    18|      */
    19|     public function writeContentTypes(Spreadsheet $spreadsheet, bool $includeCharts = false): string
    20|     {
    21|         $objWriter = null;
    22|         if ($this->getParentWriter()->getUseDiskCaching()) {
    23|             $objWriter = new XMLWriter(XMLWriter::STORAGE_DISK, $this->getParentWriter()->getDiskCachingDirectory());
    24|         } else {
    25|             $objWriter = new XMLWriter(XMLWriter::STORAGE_MEMORY);
    26|         }
    27|         $objWriter->startDocument('1.0', 'UTF-8', 'yes');
    28|         $objWriter->startElement('Types');
    29|         $objWriter->writeAttribute('xmlns', Namespaces::CONTENT_TYPES);
    30|         $this->writeOverrideContentType($objWriter, '/xl/theme/theme1.xml', 'application/vnd.openxmlformats-officedocument.theme+xml');
    31|         $this->writeOverrideContentType($objWriter, '/xl/styles.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml');
    32|         $this->writeDefaultContentType($objWriter, 'rels', 'application/vnd.openxmlformats-package.relationships+xml');
    33|         $this->writeDefaultContentType($objWriter, 'xml', 'application/xml');
    34|         $this->writeDefaultContentType($objWriter, 'vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing');
    35|         if ($spreadsheet->hasMacros()) { //Macros in workbook ?
    36|             $this->writeOverrideContentType($objWriter, '/xl/workbook.xml', 'application/vnd.ms-excel.sheet.macroEnabled.main+xml');
    37|             $this->writeOverrideContentType($objWriter, '/xl/vbaProject.bin', 'application/vnd.ms-office.vbaProject');
    38|             if ($spreadsheet->hasMacrosCertificate()) {
    39|                 $this->writeOverrideContentType($objWriter, '/xl/vbaProjectSignature.bin', 'application/vnd.ms-office.vbaProjectSignature');
    40|             }
    41|         } else {
    42|             $this->writeOverrideContentType($objWriter, '/xl/workbook.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml');
    43|         }
    44|         $this->writeOverrideContentType($objWriter, '/docProps/app.xml', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
    45|         $this->writeOverrideContentType($objWriter, '/docProps/core.xml', 'application/vnd.openxmlformats-package.core-properties+xml');
    46|         $customPropertyList = $spreadsheet->getProperties()->getCustomProperties();
    47|         if (!empty($customPropertyList)) {
    48|             $this->writeOverrideContentType($objWriter, '/docProps/custom.xml', 'application/vnd.openxmlformats-officedocument.custom-properties+xml');
    49|         }
    50|         $sheetCount = $spreadsheet->getSheetCount();
    51|         for ($i = 0; $i < $sheetCount; ++$i) {
    52|             $this->writeOverrideContentType($objWriter, '/xl/worksheets/sheet' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');
    53|         }
    54|         $this->writeOverrideContentType($objWriter, '/xl/sharedStrings.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml');
    55|         $table = 1;
    56|         for ($i = 0; $i < $sheetCount; ++$i) {
    57|             $tableCount = $spreadsheet->getSheet($i)->getTableCollection()->count();
    58|             for ($t = 1; $t <= $tableCount; ++$t) {
    59|                 $this->writeOverrideContentType($objWriter, '/xl/tables/table' . $table++ . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml');
    60|             }
    61|         }
    62|         $unparsedLoadedData = $spreadsheet->getUnparsedLoadedData();
    63|         $chart = 1;
    64|         for ($i = 0; $i < $sheetCount; ++$i) {
    65|             $drawings = $spreadsheet->getSheet($i)->getDrawingCollection();
    66|             $drawingCount = count($drawings);
    67|             $chartCount = ($includeCharts) ? $spreadsheet->getSheet($i)->getChartCount() : 0;
    68|             $hasUnparsedDrawing = isset($unparsedLoadedData['sheets'][$spreadsheet->getSheet($i)->getCodeName()]['drawingOriginalIds']);
    69|             if (($drawingCount > 0) || ($chartCount > 0) || $hasUnparsedDrawing) {
    70|                 $this->writeOverrideContentType($objWriter, '/xl/drawings/drawing' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.drawing+xml');
    71|             }
    72|             if ($chartCount > 0) {
    73|                 for ($c = 0; $c < $chartCount; ++$c) {
    74|                     $this->writeOverrideContentType($objWriter, '/xl/charts/chart' . $chart++ . '.xml', 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml');
    75|                 }
    76|             }
    77|         }
    78|         for ($i = 0; $i < $sheetCount; ++$i) {
    79|             if (count($spreadsheet->getSheet($i)->getComments()) > 0) {
    80|                 $this->writeOverrideContentType($objWriter, '/xl/comments' . ($i + 1) . '.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml');
    81|             }
    82|         }
    83|         $aMediaContentTypes = [];
    84|         $mediaCount = $this->getParentWriter()->getDrawingHashTable()->count();
    85|         for ($i = 0; $i < $mediaCount; ++$i) {
    86|             $extension = '';
    87|             $mimeType = '';
    88|             $drawing = $this->getParentWriter()->getDrawingHashTable()->getByIndex($i);
    89|             if ($drawing instanceof WorksheetDrawing && $drawing->getPath() !== '') {
    90|                 $extension = strtolower($drawing->getExtension());
    91|                 if ($drawing->getIsUrl()) {
    92|                     $mimeType = image_type_to_mime_type($drawing->getType());
    93|                 } else {
    94|                     $mimeType = $this->getImageMimeType($drawing->getPath());
    95|                 }
    96|             } elseif ($drawing instanceof MemoryDrawing) {
    97|                 $extension = strtolower($drawing->getMimeType());
    98|                 $extension = explode('/', $extension);
    99|                 $extension = $extension[1];
   100|                 $mimeType = $drawing->getMimeType();
   101|             }
   102|             if ($mimeType !== '' && !isset($aMediaContentTypes[$extension])) {
   103|                 $aMediaContentTypes[$extension] = $mimeType;
   104|                 $this->writeDefaultContentType($objWriter, $extension, $mimeType);
   105|             }
   106|         }
   107|         if ($spreadsheet->hasRibbonBinObjects()) {
   108|             $tabRibbonTypes = array_diff($spreadsheet->getRibbonBinObjects('types') ?? [], array_keys($aMediaContentTypes));
   109|             foreach ($tabRibbonTypes as $aRibbonType) {
   110|                 $mimeType = 'image/.' . $aRibbonType; //we wrote $mimeType like customUI Editor
   111|                 $this->writeDefaultContentType($objWriter, $aRibbonType, $mimeType);
   112|             }
   113|         }
   114|         $sheetCount = $spreadsheet->getSheetCount();
   115|         for ($i = 0; $i < $sheetCount; ++$i) {
   116|             if (count($spreadsheet->getSheet($i)->getHeaderFooter()->getImages()) > 0) {
   117|                 foreach ($spreadsheet->getSheet($i)->getHeaderFooter()->getImages() as $image) {
   118|                     if ($image->getPath() !== '' && !isset($aMediaContentTypes[strtolower($image->getExtension())])) {
   119|                         $aMediaContentTypes[strtolower($image->getExtension())] = $this->getImageMimeType($image->getPath());
   120|                         $this->writeDefaultContentType($objWriter, strtolower($image->getExtension()), $aMediaContentTypes[strtolower($image->getExtension())]);
   121|                     }
   122|                 }
   123|             }
   124|             if (count($spreadsheet->getSheet($i)->getComments()) > 0) {
   125|                 foreach ($spreadsheet->getSheet($i)->getComments() as $comment) {
   126|                     if (!$comment->hasBackgroundImage()) {
   127|                         continue;
   128|                     }
   129|                     $bgImage = $comment->getBackgroundImage();
   130|                     $bgImageExtentionKey = strtolower($bgImage->getImageFileExtensionForSave(false));
   131|                     if (!isset($aMediaContentTypes[$bgImageExtentionKey])) {
   132|                         $aMediaContentTypes[$bgImageExtentionKey] = $bgImage->getImageMimeType();
   133|                         $this->writeDefaultContentType($objWriter, $bgImageExtentionKey, $aMediaContentTypes[$bgImageExtentionKey]);
   134|                     }
   135|                 }
   136|             }
   137|             $bgImage = $spreadsheet->getSheet($i)->getBackgroundImage();
   138|             $mimeType = $spreadsheet->getSheet($i)->getBackgroundMime();
   139|             $extension = $spreadsheet->getSheet($i)->getBackgroundExtension();
   140|             if ($bgImage !== '' && !isset($aMediaContentTypes[$mimeType])) {
   141|                 $this->writeDefaultContentType($objWriter, $extension, $mimeType);
   142|             }
   143|         }
   144|         if (isset($unparsedLoadedData['default_content_types'])) {
   145|             foreach ($unparsedLoadedData['default_content_types'] as $extName => $contentType) {
   146|                 $this->writeDefaultContentType($objWriter, $extName, $contentType);
   147|             }
   148|         }
   149|         if (isset($unparsedLoadedData['override_content_types'])) {
   150|             foreach ($unparsedLoadedData['override_content_types'] as $partName => $overrideType) {
   151|                 $this->writeOverrideContentType($objWriter, $partName, $overrideType);
   152|             }
   153|         }
   154|         $objWriter->endElement();
   155|         return $objWriter->getData();
   156|     }
   157|     private static int $three = 3; // phpstan silliness
   158|     /**
   159|      * Get image mime type.
   160|      *
   161|      * @param string $filename Filename
   162|      *
   163|      * @return string Mime Type
   164|      */
   165|     private function getImageMimeType(string $filename): string
   166|     {
   167|         if (File::fileExists($filename)) {
   168|             $image = getimagesize($filename);
   169|             return image_type_to_mime_type((is_array($image) && count($image) >= self::$three) ? $image[2] : 0);
   170|         }
   171|         throw new WriterException("File $filename does not exist");
   172|     }
   173|     /**
   174|      * Write Default content type.
   175|      *
   176|      * @param string $partName Part name
   177|      * @param string $contentType Content type
   178|      */
   179|     private function writeDefaultContentType(XMLWriter $objWriter, string $partName, string $contentType): void
   180|     {
   181|         if ($partName != '' && $contentType != '') {
   182|             $objWriter->startElement('Default');
   183|             $objWriter->writeAttribute('Extension', $partName);
   184|             $objWriter->writeAttribute('ContentType', $contentType);
   185|             $objWriter->endElement();
   186|         } else {
   187|             throw new WriterException('Invalid parameters passed.');
   188|         }
   189|     }
   190|     /**
   191|      * Write Override content type.
   192|      *
   193|      * @param string $partName Part name
   194|      * @param string $contentType Content type
   195|      */
   196|     private function writeOverrideContentType(XMLWriter $objWriter, string $partName, string $contentType): void
   197|     {
   198|         if ($partName != '' && $contentType != '') {
   199|             $objWriter->startElement('Override');
   200|             $objWriter->writeAttribute('PartName', $partName);
   201|             $objWriter->writeAttribute('ContentType', $contentType);
   202|             $objWriter->endElement();
   203|         } else {
   204|             throw new WriterException('Invalid parameters passed.');
   205|         }
   206|     }
   207| }

