--- a//dev/null
+++ b/.devcontainer/setup-project.sh
@@ -0,0 +1,20 @@
+set -ex
+wait_for_docker() {
+  while true; do
+    docker ps > /dev/null 2>&1 && break
+    sleep 1
+  done
+  echo "Docker is ready."
+}
+wait_for_docker
+ddev debug download-images
+ddev poweroff
+ddev -v
+ddev config global --web-environment="MAUTIC_URL=https://${CODESPACE_NAME}-80.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN},PHPMYADMIN_URL=https://${CODESPACE_NAME}-8036.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN},MAILHOG_URL=https://${CODESPACE_NAME}-8025.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN}"
+cat <<EOF >.ddev/docker-compose.phpmyadmin_norouter.yaml
+services:
+  phpmyadmin:
+    ports:
+      - 8036:80
+EOF
+ddev start -y

--- a//dev/null
+++ b/app/AppKernel.php
@@ -0,0 +1,283 @@
+<?php
+use Mautic\CoreBundle\Loader\ParameterLoader;
+use Mautic\CoreBundle\Release\ThisRelease;
+use Symfony\Component\Config\Loader\LoaderInterface;
+use Symfony\Component\DependencyInjection\ContainerBuilder;
+use Symfony\Component\HttpFoundation\RedirectResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\HttpKernel\HttpKernelInterface;
+use Symfony\Component\HttpKernel\Kernel;
+/**
+ * Mautic Application Kernel.
+ */
+class AppKernel extends Kernel
+{
+    /**
+     * @var bool|null
+     */
+    private $installed;
+    /**
+     * @var ParameterLoader|null
+     */
+    private $parameterLoader;
+    /**
+     * @var string
+     */
+    private $projectDir;
+    /**
+     * @param string $environment The environment
+     * @param bool   $debug       Whether to enable debugging or not
+     *
+     * @api
+     */
+    public function __construct($environment, $debug)
+    {
+        $metadata = ThisRelease::getMetadata();
+        defined('MAUTIC_ENV') or define('MAUTIC_ENV', $environment);
+        defined('MAUTIC_VERSION') or define('MAUTIC_VERSION', $metadata->getVersion());
+        /**
+         * This is required for Doctrine's automatic database detection. When Mautic hasn't been
+         * installed yet, we don't have a database to connect to, causing automatic database platform
+         * detection to fail. We use the MAUTIC_DB_SERVER_VERSION constant to temporarily set a server_version
+         * if no database settings have been provided yet.
+         */
+        if (!defined('MAUTIC_DB_SERVER_VERSION')) {
+            $localConfigFile = ParameterLoader::getLocalConfigFile($this->getApplicationDir().'/app', false);
+            define('MAUTIC_DB_SERVER_VERSION', file_exists($localConfigFile) ? null : '5.7');
+        }
+        parent::__construct($environment, $debug);
+    }
+    public function handle(Request $request, $type = HttpKernelInterface::MAIN_REQUEST, $catch = true): Response
+    {
+        if (false !== strpos($request->getRequestUri(), 'installer') || !$this->isInstalled()) {
+            defined('MAUTIC_INSTALLER') or define('MAUTIC_INSTALLER', 1);
+        }
+        if (defined('MAUTIC_INSTALLER')) {
+            $uri = $request->getRequestUri();
+            if (false === strpos($uri, 'installer')) {
+                $base   = $request->getBaseUrl();
+                $prefix = '';
+                if (false === stripos($request->server->get('SERVER_SOFTWARE', ''), 'apache')
+                    || !file_exists($this->getProjectDir().'/.htaccess')
+                    && false === strpos(
+                        $base,
+                        'index'
+                    )
+                ) {
+                    $prefix .= '/index.php';
+                }
+                return new RedirectResponse($request->getUriForPath($prefix.'/installer'));
+            }
+        }
+        if (false === $this->booted) {
+            $this->boot();
+        }
+        if (!defined('MAUTIC_INSTALLER')) {
+            $db = $this->getContainer()->get('database_connection');
+            try {
+                $db->connect();
+            } catch (Exception $e) {
+                error_log($e);
+                throw new Mautic\CoreBundle\Exception\DatabaseConnectionException($this->getContainer()->get('translator')->trans('mautic.core.db.connection.error', ['%code%' => $e->getCode()]), 0, $e);
+            }
+        }
+        return parent::handle($request, $type, $catch);
+    }
+    public function registerBundles(): iterable
+    {
+        $bundles = [
+            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
+            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
+            new Symfony\Bundle\MonologBundle\MonologBundle(),
+            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
+            new Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle(),
+            new Doctrine\Bundle\MigrationsBundle\DoctrineMigrationsBundle(),
+            new Knp\Bundle\MenuBundle\KnpMenuBundle(),
+            new FOS\OAuthServerBundle\FOSOAuthServerBundle(),
+            new FOS\RestBundle\FOSRestBundle(),
+            new JMS\SerializerBundle\JMSSerializerBundle(),
+            new Oneup\UploaderBundle\OneupUploaderBundle(),
+            new Symfony\Bundle\TwigBundle\TwigBundle(),
+            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
+            new LightSaml\SymfonyBridgeBundle\LightSamlSymfonyBridgeBundle(),
+            new LightSaml\SpBundle\LightSamlSpBundle(),
+            new Noxlogic\RateLimitBundle\NoxlogicRateLimitBundle(),
+            new FM\ElfinderBundle\FMElfinderBundle(),
+            new Exercise\HTMLPurifierBundle\ExerciseHTMLPurifierBundle(),
+            new Mautic\ApiBundle\MauticApiBundle(),
+            new Mautic\AssetBundle\MauticAssetBundle(),
+            new Mautic\CampaignBundle\MauticCampaignBundle(),
+            new Mautic\CategoryBundle\MauticCategoryBundle(),
+            new Mautic\ChannelBundle\MauticChannelBundle(),
+            new Mautic\ConfigBundle\MauticConfigBundle(),
+            new Mautic\CoreBundle\MauticCoreBundle(),
+            new Mautic\DashboardBundle\MauticDashboardBundle(),
+            new Mautic\DynamicContentBundle\MauticDynamicContentBundle(),
+            new Mautic\EmailBundle\MauticEmailBundle(),
+            new Mautic\FormBundle\MauticFormBundle(),
+            new Mautic\InstallBundle\MauticInstallBundle(),
+            new Mautic\IntegrationsBundle\IntegrationsBundle(),
+            new Mautic\LeadBundle\MauticLeadBundle(),
+            new Mautic\MarketplaceBundle\MarketplaceBundle(),
+            new Mautic\MessengerBundle\MauticMessengerBundle(),
+            new Mautic\NotificationBundle\MauticNotificationBundle(),
+            new Mautic\PageBundle\MauticPageBundle(),
+            new Mautic\PluginBundle\MauticPluginBundle(),
+            new Mautic\PointBundle\MauticPointBundle(),
+            new Mautic\ReportBundle\MauticReportBundle(),
+            new Mautic\SmsBundle\MauticSmsBundle(),
+            new Mautic\StageBundle\MauticStageBundle(),
+            new Mautic\StatsBundle\MauticStatsBundle(),
+            new Mautic\UserBundle\MauticUserBundle(),
+            new Mautic\WebhookBundle\MauticWebhookBundle(),
+            new Mautic\CacheBundle\MauticCacheBundle(),
+        ];
+        $searchPath = $this->getApplicationDir().'/plugins';
+        $finder     = new Symfony\Component\Finder\Finder();
+        $finder->files()
+            ->followLinks()
+            ->depth('1')
+            ->in($searchPath)
+            ->name('*Bundle.php');
+        foreach ($finder as $file) {
+            $dirname  = basename($file->getRelativePath());
+            $filename = substr($file->getFilename(), 0, -4);
+            $class = '\\MauticPlugin\\'.$dirname.'\\'.$filename;
+            if (class_exists($class)) {
+                $plugin = new $class();
+                if ($plugin instanceof Symfony\Component\HttpKernel\Bundle\Bundle) {
+                    if (defined($class.'::MINIMUM_MAUTIC_VERSION')) {
+                        if (version_compare($this->getVersion(), constant($class.'::MINIMUM_MAUTIC_VERSION'), 'lt')) {
+                            continue;
+                        }
+                    }
+                    $bundles[] = $plugin;
+                }
+                unset($plugin);
+            }
+        }
+        if (in_array($this->getEnvironment(), ['dev', 'test'])) {
+            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
+            $bundles[] = new Symfony\Bundle\MakerBundle\MakerBundle();
+        }
+        if (in_array($this->getEnvironment(), ['test'])) {
+            $bundles[] = new Liip\FunctionalTestBundle\LiipFunctionalTestBundle();
+            $bundles[] = new Liip\TestFixturesBundle\LiipTestFixturesBundle();
+        }
+        if (file_exists($this->getProjectDir().'/config/bundles_local.php')) {
+            include $this->getProjectDir().'/config/bundles_local.php';
+        }
+        return $bundles;
+    }
+    protected function build(ContainerBuilder $container): void
+    {
+        $container->registerForAutoconfiguration(Mautic\CoreBundle\Model\MauticModelInterface::class)
+            ->addTag(Mautic\CoreBundle\DependencyInjection\Compiler\ModelPass::TAG);
+    }
+    public function boot(): void
+    {
+        if (true === $this->booted) {
+            return;
+        }
+        $parameterLoader = $this->getParameterLoader();
+        $parameterLoader->loadIntoEnvironment();
+        if (!defined('MAUTIC_TABLE_PREFIX')) {
+            $prefix = $_SERVER['MAUTIC_TABLE_PREFIX'];
+            if (empty($prefix)) {
+                $prefix = $parameterLoader->getLocalParameterBag()->get('db_table_prefix', '');
+            }
+            define('MAUTIC_TABLE_PREFIX', $prefix);
+        }
+        $this->initializeBundles();
+        $this->initializeContainer();
+        foreach ($this->getBundles() as $name => $bundle) {
+            $bundle->setContainer($this->container);
+            $bundle->boot();
+        }
+        $this->booted = true;
+    }
+    protected function prepareContainer(ContainerBuilder $container): void
+    {
+        $container->setParameter('mautic.application_dir', $this->getApplicationDir());
+        parent::prepareContainer($container);
+    }
+    public function registerContainerConfiguration(LoaderInterface $loader): void
+    {
+        $loader->load($this->getApplicationDir().'/app/config/config_'.$this->getEnvironment().'.php');
+    }
+    /**
+     * Retrieves the application's version number.
+     */
+    public function getVersion(): string
+    {
+        return MAUTIC_VERSION;
+    }
+    /**
+     * Checks if the application has been installed.
+     */
+    protected function isInstalled(): bool
+    {
+        if (null === $this->installed) {
+            $localParameters = $this->getParameterLoader()->getLocalParameterBag();
+            $dbDriver        = $localParameters->get('db_driver');
+            $siteUrl         = $localParameters->get('site_url');
+            $this->installed = !empty($dbDriver) && !empty($siteUrl);
+        }
+        return $this->installed;
+    }
+    public function getApplicationDir(): string
+    {
+        return dirname(__DIR__);
+    }
+    public function getProjectDir(): string
+    {
+        if (null === $this->projectDir) {
+            $r = new ReflectionObject($this);
+            if (!is_file($dir = $r->getFileName())) {
+                throw new LogicException(sprintf('Cannot auto-detect project dir for kernel of class "%s".', $r->name));
+            }
+            $dir = $rootDir = \dirname($dir, 2);
+            while (!is_file($dir.'/composer.json')) {
+                if ($dir === \dirname($dir)) {
+                    return $this->projectDir = $rootDir;
+                }
+                $dir = \dirname($dir);
+            }
+            $this->projectDir = $dir;
+        }
+        return $this->projectDir;
+    }
+    /**
+     * @api
+     */
+    public function getCacheDir(): string
+    {
+        if ($cachePath = $this->getParameterLoader()->getLocalParameterBag()->get('cache_path')) {
+            $envFolder = ('/' != substr($cachePath, -1)) ? '/'.$this->environment : $this->environment;
+            return str_replace('%kernel.project_dir%', $this->getProjectDir(), $cachePath.$envFolder);
+        }
+        return $this->getProjectDir().'/var/cache/'.$this->getEnvironment();
+    }
+    public function getLogDir(): string
+    {
+        if ($logPath = $this->getParameterLoader()->getLocalParameterBag()->get('log_path')) {
+            return str_replace('%kernel.project_dir%', $this->getProjectDir(), $logPath);
+        }
+        return $this->getProjectDir().'/var/logs';
+    }
+    /**
+     * Get local config file.
+     */
+    public function getLocalConfigFile(): string
+    {
+        return ParameterLoader::getLocalConfigFile($this->getApplicationDir().'/app');
+    }
+    private function getParameterLoader(): ParameterLoader
+    {
+        if ($this->parameterLoader) {
+            return $this->parameterLoader;
+        }
+        return $this->parameterLoader = new ParameterLoader();
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Config/config.php
@@ -0,0 +1,102 @@
+<?php
+return [
+    'routes' => [
+        'public' => [
+            'fos_oauth_server_token' => [
+                'path'       => '/oauth/v2/token',
+                'controller' => 'fos_oauth_server.controller.token::tokenAction',
+                'method'     => 'GET|POST',
+            ],
+            'fos_oauth_server_authorize' => [
+                'path'       => '/oauth/v2/authorize',
+                'controller' => 'Mautic\ApiBundle\Controller\oAuth2\AuthorizeController::authorizeAction',
+                'method'     => 'GET|POST',
+            ],
+            'mautic_oauth2_server_auth_login' => [
+                'path'       => '/oauth/v2/authorize_login',
+                'controller' => 'Mautic\ApiBundle\Controller\oAuth2\SecurityController::loginAction',
+                'method'     => 'GET|POST',
+            ],
+            'mautic_oauth2_server_auth_login_check' => [
+                'path'       => '/oauth/v2/authorize_login_check',
+                'controller' => 'Mautic\ApiBundle\Controller\oAuth2\SecurityController::loginCheckAction',
+                'method'     => 'GET|POST',
+            ],
+        ],
+        'main' => [
+            'mautic_client_index' => [
+                'path'       => '/credentials/{page}',
+                'controller' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
+            ],
+            'mautic_client_action' => [
+                'path'       => '/credentials/{objectAction}/{objectId}',
+                'controller' => 'Mautic\ApiBundle\Controller\ClientController::executeAction',
+            ],
+        ],
+    ],
+    'menu' => [
+        'admin' => [
+            'items' => [
+                'mautic.api.client.menu.index' => [
+                    'route'     => 'mautic_client_index',
+                    'access'    => 'api:clients:view',
+                    'parent'    => 'mautic.core.integrations',
+                    'iconClass' => 'ri-terminal-box-line',
+                    'priority'  => 17,
+                    'checks'    => [
+                        'parameters' => [
+                            'api_enabled' => true,
+                        ],
+                    ],
+                ],
+            ],
+        ],
+    ],
+    'services' => [
+        'helpers' => [
+            'mautic.api.helper.entity_result' => [
+                'class' => Mautic\ApiBundle\Helper\EntityResultHelper::class,
+            ],
+        ],
+        'other' => [
+            'mautic.api.oauth.event_listener' => [
+                'class'     => Mautic\ApiBundle\EventListener\PreAuthorizationEventListener::class,
+                'arguments' => [
+                    'doctrine.orm.entity_manager',
+                    'mautic.security',
+                    'translator',
+                ],
+                'tags' => [
+                    'kernel.event_listener',
+                    'kernel.event_listener',
+                ],
+                'tagArguments' => [
+                    [
+                        'event'  => 'fos_oauth_server.pre_authorization_process',
+                        'method' => 'onPreAuthorizationProcess',
+                    ],
+                    [
+                        'event'  => 'fos_oauth_server.post_authorization_process',
+                        'method' => 'onPostAuthorizationProcess',
+                    ],
+                ],
+            ],
+            'fos_oauth_server.security.authentication.listener.class' => Mautic\ApiBundle\Security\OAuth2\Firewall\OAuthListener::class,
+            'mautic.validator.oauthcallback'                          => [
+                'class' => Mautic\ApiBundle\Form\Validator\Constraints\OAuthCallbackValidator::class,
+                'tag'   => 'validator.constraint_validator',
+            ],
+        ],
+    ],
+    'parameters' => [
+        'api_enabled'                       => false,
+        'api_enable_basic_auth'             => false,
+        'api_oauth2_access_token_lifetime'  => 60,
+        'api_oauth2_refresh_token_lifetime' => 14,
+        'api_batch_max_limit'               => 200,
+        'api_rate_limiter_limit'            => 0,
+        'api_rate_limiter_cache'            => [
+            'adapter' => 'cache.adapter.filesystem',
+        ],
+    ],
+];

--- a//dev/null
+++ b/app/bundles/ApiBundle/Controller/ClientController.php
@@ -0,0 +1,394 @@
+<?php
+namespace Mautic\ApiBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Model\ClientModel;
+use Mautic\CoreBundle\Controller\AbstractStandardFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\FormBundle\Helper\FormFieldHelper;
+use Mautic\UserBundle\Entity\User;
+use OAuth2\OAuth2;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\RedirectResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
+class ClientController extends AbstractStandardFormController
+{
+    public function __construct(
+        private ClientModel $clientModel,
+        FormFactoryInterface $formFactory,
+        FormFieldHelper $fieldHelper,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * Generate's default client list.
+     *
+     * @param int $page
+     *
+     * @return Response
+     */
+    public function indexAction(Request $request, PageHelperFactoryInterface $pageHelperFactory, $page = 1)
+    {
+        if (!$this->security->isGranted('api:clients:view')) {
+            return $this->accessDenied();
+        }
+        $this->setListFilters();
+        $pageHelper= $pageHelperFactory->make('mautic.api.client', $page);
+        $limit     = $pageHelper->getLimit();
+        $start     = $pageHelper->getStart();
+        $orderBy   = $request->getSession()->get('mautic.api.client.orderby', 'c.name');
+        $orderByDir= $request->getSession()->get('mautic.api.client.orderbydir', 'ASC');
+        $filter    = $request->get('search', $request->getSession()->get('mautic.api.client.filter', ''));
+        $apiMode   = $request->get('api_mode', $request->getSession()->get('mautic.api.client.filter.api_mode', 'oauth2'));
+        $request->getSession()->set('mautic.api.client.filter.api_mode', $apiMode);
+        $request->getSession()->set('mautic.api.client.filter', $filter);
+        $clients = $this->clientModel->getEntities(
+            [
+                'start'      => $start,
+                'limit'      => $limit,
+                'filter'     => $filter,
+                'orderBy'    => $orderBy,
+                'orderByDir' => $orderByDir,
+            ]
+        );
+        $count = count($clients);
+        if ($count && $count < ($start + 1)) {
+            $lastPage  = $pageHelper->countPage($count);
+            $returnUrl = $this->generateUrl('mautic_client_index', ['page' => $lastPage]);
+            $pageHelper->rememberPage($lastPage);
+            return $this->postActionRedirect(
+                [
+                    'returnUrl'       => $returnUrl,
+                    'viewParameters'  => ['page' => $lastPage],
+                    'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
+                    'passthroughVars' => [
+                        'activeLink'    => 'mautic_client_index',
+                        'mauticContent' => 'client',
+                    ],
+                ]
+            );
+        }
+        $pageHelper->rememberPage($page);
+        $filters = [];
+        $apiOptions           = [];
+        $apiOptions['oauth2'] = 'OAuth 2';
+        $filters['api_mode']  = [
+            'values'  => [$apiMode],
+            'options' => $apiOptions,
+        ];
+        return $this->delegateView(
+            [
+                'viewParameters'  => [
+                    'items'       => $clients,
+                    'page'        => $page,
+                    'limit'       => $limit,
+                    'permissions' => [
+                        'create' => $this->security->isGranted('api:clients:create'),
+                        'edit'   => $this->security->isGranted('api:clients:editother'),
+                        'delete' => $this->security->isGranted('api:clients:deleteother'),
+                    ],
+                    'tmpl'        => $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index',
+                    'searchValue' => $filter,
+                    'filters'     => $filters,
+                ],
+                'contentTemplate' => '@MauticApi/Client/list.html.twig',
+                'passthroughVars' => [
+                    'route'         => $this->generateUrl('mautic_client_index', ['page' => $page]),
+                    'mauticContent' => 'client',
+                ],
+            ]
+        );
+    }
+    public function authorizedClientsAction(TokenStorageInterface $tokenStorage): Response
+    {
+        $me = $tokenStorage->getToken()->getUser();
+        \assert($me instanceof User);
+        $clients = $this->clientModel->getUserClients($me);
+        return $this->render('@MauticApi/Client/authorized.html.twig', ['clients' => $clients]);
+    }
+    /**
+     * @param int $clientId
+     */
+    public function revokeAction(Request $request, $clientId): Response
+    {
+        $success = 0;
+        $flashes = [];
+        if ('POST' == $request->getMethod()) {
+            $client = $this->clientModel->getEntity($clientId);
+            if (null === $client) {
+                $flashes[] = [
+                    'type'    => 'error',
+                    'msg'     => 'mautic.api.client.error.notfound',
+                    'msgVars' => ['%id%' => $clientId],
+                ];
+            } else {
+                $name = $client->getName();
+                $this->clientModel->revokeAccess($client);
+                $flashes[] = [
+                    'type'    => 'notice',
+                    'msg'     => 'mautic.api.client.notice.revoked',
+                    'msgVars' => [
+                        '%name%' => $name,
+                    ],
+                ];
+            }
+        }
+        return $this->postActionRedirect(
+            [
+                'returnUrl'       => $this->generateUrl('mautic_user_account'),
+                'contentTemplate' => 'Mautic\UserBundle\Controller\ProfileController::indexAction',
+                'passthroughVars' => [
+                    'success' => $success,
+                ],
+                'flashes' => $flashes,
+            ]
+        );
+    }
+    /**
+     * @param mixed $objectId
+     *
+     * @return array|JsonResponse|RedirectResponse|Response
+     */
+    public function newAction(Request $request, $objectId = 0)
+    {
+        if (!$this->security->isGranted('api:clients:create')) {
+            return $this->accessDenied();
+        }
+        $apiMode = (0 === $objectId) ? $request->getSession()->get('mautic.client.filter.api_mode', 'oauth2') : $objectId;
+        $request->getSession()->set('mautic.client.filter.api_mode', $apiMode);
+        $this->clientModel->setApiMode($apiMode);
+        $client = $this->clientModel->getEntity();
+        $returnUrl = $this->generateUrl('mautic_client_index');
+        $action = $this->generateUrl('mautic_client_action', ['objectAction' => 'new']);
+        $form   = $this->clientModel->createForm($client, $this->formFactory, $action);
+        $form->remove('randomId');
+        $form->remove('secret');
+        $form->remove('publicId');
+        $form->remove('consumerKey');
+        $form->remove('consumerSecret');
+        if ('POST' == $request->getMethod()) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    /** @var User $user */
+                    $user = $this->getUser();
+                    if (ClientModel::API_MODE_OAUTH2 == $apiMode && $user->getRole()->isAdmin()) {
+                        $client->addGrantType(OAuth2::GRANT_TYPE_CLIENT_CREDENTIALS);
+                    }
+                    $client->setRole($user->getRole());
+                    $this->clientModel->saveEntity($client);
+                    $this->addFlashMessage(
+                        'mautic.api.client.notice.created',
+                        [
+                            '%name%'         => $client->getName(),
+                            '%clientId%'     => $client->getPublicId(),
+                            '%clientSecret%' => $client->getSecret(),
+                            '%url%'          => $this->generateUrl(
+                                'mautic_client_action',
+                                [
+                                    'objectAction' => 'edit',
+                                    'objectId'     => $client->getId(),
+                                ]
+                            ),
+                        ]
+                    );
+                }
+            }
+            if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
+                return $this->postActionRedirect(
+                    [
+                        'returnUrl'       => $returnUrl,
+                        'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
+                        'passthroughVars' => [
+                            'activeLink'    => '#mautic_client_index',
+                            'mauticContent' => 'client',
+                        ],
+                    ]
+                );
+            } elseif ($valid && !$cancelled) {
+                return $this->editAction($request, $client->getId(), true);
+            }
+        }
+        return $this->delegateView(
+            [
+                'viewParameters' => [
+                    'form' => $form->createView(),
+                    'tmpl' => $request->get('tmpl', 'form'),
+                ],
+                'contentTemplate' => '@MauticApi/Client/form.html.twig',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_client_new',
+                    'route'         => $action,
+                    'mauticContent' => 'client',
+                ],
+            ]
+        );
+    }
+    /**
+     * Generates edit form and processes post data.
+     *
+     * @param int  $objectId
+     * @param bool $ignorePost
+     *
+     * @return JsonResponse|RedirectResponse|Response
+     */
+    public function editAction(Request $request, $objectId, $ignorePost = false)
+    {
+        if (!$this->security->isGranted('api:clients:editother')) {
+            return $this->accessDenied();
+        }
+        $client    = $this->clientModel->getEntity($objectId);
+        $returnUrl = $this->generateUrl('mautic_client_index');
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_client_index',
+                'mauticContent' => 'client',
+            ],
+        ];
+        if (null === $client) {
+            return $this->postActionRedirect(
+                array_merge(
+                    $postActionVars,
+                    [
+                        'flashes' => [
+                            [
+                                'type'    => 'error',
+                                'msg'     => 'mautic.api.client.error.notfound',
+                                'msgVars' => ['%id%' => $objectId],
+                            ],
+                        ],
+                    ]
+                )
+            );
+        } elseif ($this->clientModel->isLocked($client)) {
+            return $this->isLocked($postActionVars, $client, 'api.client');
+        }
+        $action = $this->generateUrl('mautic_client_action', ['objectAction' => 'edit', 'objectId' => $objectId]);
+        $form   = $this->clientModel->createForm($client, $this->formFactory, $action);
+        $form->remove('api_mode');
+        if (!$ignorePost && 'POST' == $request->getMethod()) {
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $this->clientModel->saveEntity($client, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
+                    $this->addFlashMessage(
+                        'mautic.core.notice.updated',
+                        [
+                            '%name%'      => $client->getName(),
+                            '%menu_link%' => 'mautic_client_index',
+                            '%url%'       => $this->generateUrl(
+                                'mautic_client_action',
+                                [
+                                    'objectAction' => 'edit',
+                                    'objectId'     => $client->getId(),
+                                ]
+                            ),
+                        ]
+                    );
+                    if ($this->getFormButton($form, ['buttons', 'save'])->isClicked()) {
+                        return $this->postActionRedirect($postActionVars);
+                    }
+                }
+            } else {
+                $this->clientModel->unlockEntity($client);
+                return $this->postActionRedirect($postActionVars);
+            }
+        } else {
+            $this->clientModel->lockEntity($client);
+        }
+        return $this->delegateView(
+            [
+                'viewParameters' => [
+                    'form' => $form->createView(),
+                    'tmpl' => $request->get('tmpl', 'form'),
+                ],
+                'contentTemplate' => '@MauticApi/Client/form.html.twig',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_client_index',
+                    'route'         => $action,
+                    'mauticContent' => 'client',
+                ],
+            ]
+        );
+    }
+    /**
+     * Deletes the entity.
+     *
+     * @param int $objectId
+     *
+     * @return Response
+     */
+    public function deleteAction(Request $request, $objectId)
+    {
+        if (!$this->security->isGranted('api:clients:delete')) {
+            return $this->accessDenied();
+        }
+        $returnUrl = $this->generateUrl('mautic_client_index');
+        $success   = 0;
+        $flashes   = [];
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_client_index',
+                'success'       => $success,
+                'mauticContent' => 'client',
+            ],
+        ];
+        if ('POST' === $request->getMethod()) {
+            $entity = $this->clientModel->getEntity($objectId);
+            if (null === $entity) {
+                $flashes[] = [
+                    'type'    => 'error',
+                    'msg'     => 'mautic.api.client.error.notfound',
+                    'msgVars' => ['%id%' => $objectId],
+                ];
+            } elseif ($this->clientModel->isLocked($entity)) {
+                return $this->isLocked($postActionVars, $entity, 'api.client');
+            } else {
+                $this->clientModel->deleteEntity($entity);
+                $name      = $entity->getName();
+                $flashes[] = [
+                    'type'    => 'notice',
+                    'msg'     => 'mautic.core.notice.deleted',
+                    'msgVars' => [
+                        '%name%' => $name,
+                        '%id%'   => $objectId,
+                    ],
+                ];
+            }
+        }
+        return $this->postActionRedirect(
+            array_merge(
+                $postActionVars,
+                [
+                    'flashes' => $flashes,
+                ]
+            )
+        );
+    }
+    public function getModelName(): string
+    {
+        return 'api.client';
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Controller/CommonApiController.php
@@ -0,0 +1,472 @@
+<?php
+namespace Mautic\ApiBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use FOS\RestBundle\View\View;
+use Mautic\ApiBundle\ApiEvents;
+use Mautic\ApiBundle\Event\ApiEntityEvent;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\CategoryBundle\Entity\Category;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\Form;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Component\HttpFoundation\RedirectResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Routing\RouterInterface;
+/**
+ * @template E of object
+ *
+ * @extends FetchCommonApiController<E>
+ */
+class CommonApiController extends FetchCommonApiController
+{
+    /**
+     * @var array
+     */
+    protected $dataInputMasks = [];
+    /**
+     * Model object for processing the entity.
+     *
+     * @var FormModel<E>|null
+     */
+    protected $model;
+    /**
+     * @var array
+     */
+    protected $routeParams = [];
+    /**
+     * @var array
+     */
+    protected $entityRequestParameters = [];
+    public function __construct(
+        CorePermissions $security,
+        Translator $translator,
+        EntityResultHelper $entityResultHelper,
+        protected RouterInterface $router,
+        protected FormFactoryInterface $formFactory,
+        AppVersion $appVersion,
+        RequestStack $requestStack,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        EventDispatcherInterface $dispatcher,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($security, $translator, $entityResultHelper, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * Delete a batch of entities.
+     *
+     * @return array|Response
+     */
+    public function deleteEntitiesAction(Request $request)
+    {
+        $parameters = $request->query->all();
+        $valid = $this->validateBatchPayload($parameters);
+        if ($valid instanceof Response) {
+            return $valid;
+        }
+        $errors            = [];
+        $entities          = $this->getBatchEntities($parameters, $errors, true);
+        $this->inBatchMode = true;
+        $payload = [$this->entityNameMulti => $entities];
+        $view    = $this->view($payload, Response::HTTP_OK);
+        $this->setSerializationContext($view);
+        $response = $this->handleView($view);
+        foreach ($entities as $key => $entity) {
+            if (null === $entity || !$entity->getId()) {
+                $this->setBatchError($key, 'mautic.core.error.notfound', Response::HTTP_NOT_FOUND, $errors, $entities, $entity);
+                continue;
+            }
+            if (!$this->checkEntityAccess($entity, 'delete')) {
+                $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
+                continue;
+            }
+            $this->model->deleteEntity($entity);
+            $this->doctrine->getManager()->detach($entity);
+        }
+        if (!empty($errors)) {
+            $content           = json_decode($response->getContent(), true);
+            $content['errors'] = $errors;
+            $response->setContent(json_encode($content));
+        }
+        return $response;
+    }
+    /**
+     * Deletes an entity.
+     *
+     * @param int $id Entity ID
+     *
+     * @return Response
+     */
+    public function deleteEntityAction($id)
+    {
+        $entity = $this->model->getEntity($id);
+        if (null !== $entity) {
+            if (!$this->checkEntityAccess($entity, 'delete')) {
+                return $this->accessDenied();
+            }
+            $this->model->deleteEntity($entity);
+            $this->preSerializeEntity($entity);
+            $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK);
+            $this->setSerializationContext($view);
+            return $this->handleView($view);
+        }
+        return $this->notFound();
+    }
+    /**
+     * Edit a batch of entities.
+     *
+     * @return array|Response
+     */
+    public function editEntitiesAction(Request $request)
+    {
+        $parameters = $request->request->all();
+        $valid = $this->validateBatchPayload($parameters);
+        if ($valid instanceof Response) {
+            return $valid;
+        }
+        $errors      = [];
+        $statusCodes = [];
+        $entities    = $this->getBatchEntities($parameters, $errors);
+        foreach ($parameters as $key => $params) {
+            $method = $request->getMethod();
+            $entity = $entities[$key] ?? null;
+            $statusCode = Response::HTTP_OK;
+            if (null === $entity || !$entity->getId()) {
+                if ('PATCH' === $method) {
+                    $this->setBatchError($key, 'mautic.core.error.notfound', Response::HTTP_NOT_FOUND, $errors, $entities, $entity);
+                    $statusCodes[$key] = Response::HTTP_NOT_FOUND;
+                    continue;
+                }
+                $entity = $this->model->getEntity();
+                if (!$this->checkEntityAccess($entity, 'create')) {
+                    $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
+                    $statusCodes[$key] = Response::HTTP_FORBIDDEN;
+                    continue;
+                }
+                $statusCode = Response::HTTP_CREATED;
+            }
+            if (!$this->checkEntityAccess($entity, 'edit')) {
+                $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
+                $statusCodes[$key] = Response::HTTP_FORBIDDEN;
+                continue;
+            }
+            $this->processBatchForm($request, $key, $entity, $params, $method, $errors, $entities);
+            if (isset($errors[$key])) {
+                $statusCodes[$key] = $errors[$key]['code'];
+            } else {
+                $statusCodes[$key] = $statusCode;
+            }
+        }
+        $payload = [
+            $this->entityNameMulti => $entities,
+            'statusCodes'          => $statusCodes,
+        ];
+        if (!empty($errors)) {
+            $payload['errors'] = $errors;
+        }
+        $view = $this->view($payload, Response::HTTP_OK);
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    /**
+     * Edits an existing entity or creates one on PUT if it doesn't exist.
+     *
+     * @param int $id Entity ID
+     *
+     * @return Response
+     */
+    public function editEntityAction(Request $request, $id)
+    {
+        $entity     = $this->model->getEntity($id);
+        $parameters = $request->request->all();
+        $method     = $request->getMethod();
+        if (null === $entity || !$entity->getId()) {
+            if ('PATCH' === $method) {
+                return $this->notFound();
+            }
+            $entity = $this->model->getEntity();
+            if (!$this->checkEntityAccess($entity, 'create')) {
+                return $this->accessDenied();
+            }
+        }
+        if (!$this->checkEntityAccess($entity, 'edit')) {
+            return $this->accessDenied();
+        }
+        return $this->processForm($request, $entity, $parameters, $method);
+    }
+    /**
+     * Create a batch of new entities.
+     *
+     * @return array|Response
+     */
+    public function newEntitiesAction(Request $request)
+    {
+        $entity = $this->model->getEntity();
+        if (!$this->checkEntityAccess($entity, 'create')) {
+            return $this->accessDenied();
+        }
+        $parameters = $request->request->all();
+        $valid = $this->validateBatchPayload($parameters);
+        if ($valid instanceof Response) {
+            return $valid;
+        }
+        $this->inBatchMode = true;
+        $entities          = [];
+        $errors            = [];
+        $statusCodes       = [];
+        foreach ($parameters as $key => $params) {
+            $entity       = $this->getNewEntity($params);
+            $entityExists = false;
+            $method       = 'POST';
+            if ($entity->getId()) {
+                $entityExists = true;
+                $method       = 'PATCH';
+                if (!$this->checkEntityAccess($entity, 'edit')) {
+                    $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
+                    $statusCodes[$key] = Response::HTTP_FORBIDDEN;
+                    continue;
+                }
+            }
+            $this->processBatchForm($request, $key, $entity, $params, $method, $errors, $entities);
+            if (isset($errors[$key])) {
+                $statusCodes[$key] = $errors[$key]['code'];
+            } elseif ($entityExists) {
+                $statusCodes[$key] = Response::HTTP_OK;
+            } else {
+                $statusCodes[$key] = Response::HTTP_CREATED;
+            }
+        }
+        $payload = [
+            $this->entityNameMulti => $entities,
+            'statusCodes'          => $statusCodes,
+        ];
+        if (!empty($errors)) {
+            $payload['errors'] = $errors;
+        }
+        $view = $this->view($payload, Response::HTTP_CREATED);
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    /**
+     * Creates a new entity.
+     *
+     * @return Response
+     */
+    public function newEntityAction(Request $request)
+    {
+        $parameters = $request->request->all();
+        $entity     = $this->getNewEntity($parameters);
+        if (!$this->checkEntityAccess($entity, 'create')) {
+            return $this->accessDenied();
+        }
+        return $this->processForm($request, $entity, $parameters, 'POST');
+    }
+    /**
+     * @return FormInterface<mixed>
+     */
+    protected function createEntityForm($entity): FormInterface
+    {
+        return $this->model->createForm(
+            $entity,
+            $this->formFactory,
+            null,
+            array_merge(
+                [
+                    'csrf_protection'    => false,
+                    'allow_extra_fields' => true,
+                ],
+                $this->getEntityFormOptions()
+            )
+        );
+    }
+    /**
+     * Gives child controllers opportunity to analyze and do whatever to an entity before populating the form.
+     *
+     * @param string $action
+     *
+     * @return mixed
+     */
+    protected function prePopulateForm(&$entity, $parameters, $action = 'edit')
+    {
+    }
+    /**
+     * Give the controller an opportunity to process the entity before persisting.
+     *
+     * @return mixed
+     */
+    protected function preSaveEntity(&$entity, $form, $parameters, $action = 'edit')
+    {
+    }
+    /**
+     * Convert posted parameters into what the form needs in order to successfully bind.
+     *
+     * @param mixed[] $parameters
+     * @param object  $entity
+     * @param string  $action
+     *
+     * @return mixed
+     */
+    protected function prepareParametersForBinding(Request $request, $parameters, $entity, $action)
+    {
+        return $parameters;
+    }
+    protected function processBatchForm(Request $request, $key, $entity, $params, $method, &$errors, &$entities)
+    {
+        $this->inBatchMode = true;
+        $formResponse      = $this->processForm($request, $entity, $params, $method);
+        if ($formResponse instanceof Response) {
+            if (!$formResponse instanceof RedirectResponse) {
+                $this->setBatchError(
+                    $key,
+                    InputHelper::string($formResponse->getContent()),
+                    $formResponse->getStatusCode(),
+                    $errors,
+                    $entities,
+                    $entity
+                );
+            }
+        } elseif (is_object($formResponse) && $formResponse::class === $entity::class) {
+            $entities[$key] = $formResponse;
+        } elseif (is_array($formResponse) && isset($formResponse['code'], $formResponse['message'])) {
+            $errors[$key] = $formResponse;
+        }
+        $this->doctrine->getManager()->detach($entity);
+        $this->inBatchMode = false;
+    }
+    /**
+     * Processes API Form.
+     *
+     * @param array<mixed>|null $parameters
+     * @param string            $method
+     *
+     * @return mixed
+     */
+    protected function processForm(Request $request, $entity, $parameters = null, $method = 'PUT')
+    {
+        $categoryId = null;
+        if (null === $parameters) {
+            $parameters = $request->request->all();
+        }
+        $this->entityRequestParameters = $parameters;
+        if (isset($parameters['id'])) {
+            unset($parameters['id']);
+        }
+        if ($entity->getId()) {
+            $statusCode = Response::HTTP_OK;
+            $action     = 'edit';
+        } else {
+            $statusCode = Response::HTTP_CREATED;
+            $action     = 'new';
+            $defaultProperties = $this->getEntityDefaultProperties($entity);
+            $parameters        = array_merge($defaultProperties, $parameters);
+        }
+        if (
+            (
+                array_key_exists('isPublished', $parameters)
+                || array_key_exists('publishUp', $parameters)
+                || array_key_exists('publishDown', $parameters)
+            )
+            && $this->security->checkPermissionExists($this->permissionBase.':publish')) {
+            if ($this->security->checkPermissionExists($this->permissionBase.':publishown')) {
+                if (!$this->checkEntityAccess($entity, 'publish')) {
+                    if ('new' === $action) {
+                        $parameters['isPublished'] = 0;
+                    } else {
+                        unset($parameters['isPublished'], $parameters['publishUp'], $parameters['publishDown']);
+                    }
+                }
+            }
+        }
+        $form         = $this->createEntityForm($entity);
+        $submitParams = $this->prepareParametersForBinding($request, $parameters, $entity, $action);
+        if ($submitParams instanceof Response) {
+            return $submitParams;
+        }
+        if (isset($submitParams['category'])) {
+            $categoryId = (int) $submitParams['category'];
+            unset($submitParams['category']);
+        }
+        $this->prepareParametersFromRequest($form, $submitParams, $entity, $this->dataInputMasks);
+        $form->submit($submitParams, 'PATCH' !== $method);
+        if ($form->isSubmitted() && $form->isValid()) {
+            $this->setCategory($entity, $categoryId);
+            $preSaveError = $this->preSaveEntity($entity, $form, $submitParams, $action);
+            if ($preSaveError instanceof Response) {
+                return $preSaveError;
+            }
+            try {
+                if ($this->dispatcher->hasListeners(ApiEvents::API_ON_ENTITY_PRE_SAVE)) {
+                    $this->dispatcher->dispatch(new ApiEntityEvent($entity, $this->entityRequestParameters, $request), ApiEvents::API_ON_ENTITY_PRE_SAVE);
+                }
+            } catch (\Exception $e) {
+                return $this->returnError($e->getMessage(), $e->getCode());
+            }
+            $statusCode = $this->saveEntity($entity, $statusCode);
+            $headers = [];
+            if (in_array($statusCode, [Response::HTTP_CREATED, Response::HTTP_ACCEPTED])) {
+                $route = (null !== $this->router->getRouteCollection()->get('mautic_api_'.$this->entityNameMulti.'_getone'))
+                    ? 'mautic_api_'.$this->entityNameMulti.'_getone' : 'mautic_api_get'.$this->entityNameOne;
+                $headers['Location'] = $this->generateUrl(
+                    $route,
+                    array_merge(['id' => $entity->getId()], $this->routeParams),
+                    true
+                );
+            }
+            try {
+                if ($this->dispatcher->hasListeners(ApiEvents::API_ON_ENTITY_POST_SAVE)) {
+                    $this->dispatcher->dispatch(new ApiEntityEvent($entity, $this->entityRequestParameters, $request), ApiEvents::API_ON_ENTITY_POST_SAVE);
+                }
+            } catch (\Exception $e) {
+                return $this->returnError($e->getMessage(), $e->getCode());
+            }
+            $this->preSerializeEntity($entity, $action);
+            if ($this->inBatchMode) {
+                return $entity;
+            } else {
+                $view = $this->view([$this->entityNameOne => $entity], $statusCode, $headers);
+            }
+            $this->setSerializationContext($view);
+        } else {
+            $formErrors     = $this->getFormErrorMessages($form);
+            $formErrorCodes = $this->getFormErrorCodes($form);
+            $msg            = $this->getFormErrorMessage($formErrors);
+            if (!$msg) {
+                $msg = $this->translator->trans('mautic.core.error.badrequest', [], 'flashes');
+            }
+            $responseCode = in_array(Response::HTTP_UNPROCESSABLE_ENTITY, $formErrorCodes) ? Response::HTTP_UNPROCESSABLE_ENTITY : Response::HTTP_BAD_REQUEST;
+            return $this->returnError($msg, $responseCode, $formErrors);
+        }
+        return $this->handleView($view);
+    }
+    protected function saveEntity($entity, int $statusCode): int
+    {
+        $this->model->saveEntity($entity);
+        return $statusCode;
+    }
+    /**
+     * @param object $entity
+     * @param int    $categoryId
+     *
+     * @throws \UnexpectedValueException
+     */
+    protected function setCategory($entity, $categoryId)
+    {
+        if (!empty($categoryId) && method_exists($entity, 'setCategory')) {
+            $category = $this->doctrine->getManager()->find(Category::class, $categoryId);
+            if (null === $category) {
+                throw new \UnexpectedValueException("Category $categoryId does not exist");
+            }
+            $entity->setCategory($category);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Controller/FetchCommonApiController.php
@@ -0,0 +1,644 @@
+<?php
+namespace Mautic\ApiBundle\Controller;
+use Doctrine\ORM\Mapping\ClassMetadata;
+use Doctrine\ORM\Tools\Pagination\Paginator;
+use Doctrine\Persistence\ManagerRegistry;
+use FOS\RestBundle\Controller\AbstractFOSRestController;
+use FOS\RestBundle\View\View;
+use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
+use Mautic\ApiBundle\ApiEvents;
+use Mautic\ApiBundle\Event\ApiSerializationContextEvent;
+use Mautic\ApiBundle\Helper\BatchIdToEntityHelper;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\ApiBundle\Serializer\Exclusion\ParentChildrenExclusionStrategy;
+use Mautic\ApiBundle\Serializer\Exclusion\PublishDetailsExclusionStrategy;
+use Mautic\CoreBundle\Controller\FormErrorMessagesTrait;
+use Mautic\CoreBundle\Controller\MauticController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Form\RequestTrait;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\AbstractCommonModel;
+use Mautic\CoreBundle\Model\MauticModelInterface;
+use Mautic\CoreBundle\Security\Exception\PermissionException;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\UserBundle\Entity\User;
+use Symfony\Component\DependencyInjection\ParameterBag\ContainerBagInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\Form;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+/**
+ * @template E of object
+ */
+class FetchCommonApiController extends AbstractFOSRestController implements MauticController
+{
+    use RequestTrait;
+    use FormErrorMessagesTrait;
+    /**
+     * If set to true, serializer will not return null values.
+     *
+     * @var bool
+     */
+    protected $customSelectRequested = false;
+    /**
+     * Class for the entity.
+     *
+     * @var class-string<E>
+     */
+    protected $entityClass;
+    /**
+     * Key to return for entity lists.
+     *
+     * @var string
+     */
+    protected $entityNameMulti;
+    /**
+     * Key to return for a single entity.
+     *
+     * @var string
+     */
+    protected $entityNameOne;
+    /**
+     * Custom JMS strategies to add to the view's context.
+     *
+     * @var array<int, ExclusionStrategyInterface>
+     */
+    protected $exclusionStrategies = [];
+    /**
+     * Pass to the model's getEntities() method.
+     *
+     * @var array<mixed>
+     */
+    protected $extraGetEntitiesArguments = [];
+    /**
+     * @var bool
+     */
+    protected $inBatchMode = false;
+    /**
+     * Used to set default filters for entity lists such as restricting to owning user.
+     *
+     * @var array<array<string, mixed>>
+     */
+    protected $listFilters = [];
+    /**
+     * Model object for processing the entity.
+     *
+     * @var AbstractCommonModel<E>|null
+     */
+    protected $model;
+    /**
+     * The level parent/children should stop loading if applicable.
+     *
+     * @var int
+     */
+    protected $parentChildrenLevelDepth = 3;
+    /**
+     * Permission base for the entity such as page:pages.
+     *
+     * @var string|null
+     */
+    protected $permissionBase;
+    /**
+     * @var array<int, string>
+     */
+    protected $serializerGroups = [];
+    /**
+     * @var Translator
+     */
+    protected $translator;
+    protected ContainerBagInterface $parametersContainer;
+    /**
+     * @param ModelFactory<E> $modelFactory
+     */
+    public function __construct(
+        protected CorePermissions $security,
+        Translator $translator,
+        protected EntityResultHelper $entityResultHelper,
+        private AppVersion $appVersion,
+        private RequestStack $requestStack,
+        protected ManagerRegistry $doctrine,
+        protected ModelFactory $modelFactory,
+        protected EventDispatcherInterface $dispatcher,
+        protected CoreParametersHelper $coreParametersHelper,
+    ) {
+        $this->translator           = $translator;
+        if (null !== $this->model && !$this->permissionBase && method_exists($this->model, 'getPermissionBase')) {
+            $this->permissionBase = $this->model->getPermissionBase();
+        }
+    }
+    /**
+     * Obtains a list of entities as defined by the API URL.
+     *
+     * @return Response
+     */
+    public function getEntitiesAction(Request $request, UserHelper $userHelper)
+    {
+        $repo          = $this->model->getRepository();
+        $tableAlias    = $repo->getTableAlias();
+        $publishedOnly = $request->get('published', 0);
+        $minimal       = $request->get('minimal', 0);
+        try {
+            if (!$this->security->isGranted($this->permissionBase.':view')) {
+                return $this->accessDenied();
+            }
+        } catch (PermissionException $e) {
+            return $this->accessDenied($e->getMessage());
+        }
+        if ($this->security->checkPermissionExists($this->permissionBase.':viewother')
+            && !$this->security->isGranted($this->permissionBase.':viewother')
+            && null !== $user = $userHelper->getUser()
+        ) {
+            $this->listFilters[] = [
+                'column' => $tableAlias.'.createdBy',
+                'expr'   => 'eq',
+                'value'  => $user->getId(),
+            ];
+        }
+        if ($publishedOnly) {
+            $this->listFilters[] = [
+                'column' => $tableAlias.'.isPublished',
+                'expr'   => 'eq',
+                'value'  => true,
+            ];
+        }
+        if ($minimal) {
+            if (isset($this->serializerGroups[0])) {
+                $this->serializerGroups[0] = str_replace('Details', 'List', $this->serializerGroups[0]);
+            }
+        }
+        $args = array_merge(
+            [
+                'start'  => $request->query->get('start', 0),
+                'limit'  => $request->query->get('limit', $this->coreParametersHelper->get('default_pagelimit')),
+                'filter' => [
+                    'string' => $request->query->get('search', ''),
+                    'force'  => $this->listFilters,
+                ],
+                'orderBy'        => $this->addAliasIfNotPresent($request->query->get('orderBy', ''), $tableAlias),
+                'orderByDir'     => $request->query->get('orderByDir', 'ASC'),
+                'withTotalCount' => true, // for repositories that break free of Paginator
+            ],
+            $this->extraGetEntitiesArguments
+        );
+        if ($select = InputHelper::cleanArray($request->query->all()['select'] ?? $request->request->all()['select'] ?? [])) {
+            $args['select']              = $select;
+            $this->customSelectRequested = true;
+        }
+        if ($where = $this->getWhereFromRequest($request)) {
+            $args['filter']['where'] = $where;
+        }
+        if ($order = $this->getOrderFromRequest($request)) {
+            $args['filter']['order'] = $order;
+        }
+        if ($totalCountTtl = $this->getTotalCountTtl()) {
+            $args['totalCountTtl'] = $totalCountTtl;
+        }
+        $results = $this->model->getEntities($args);
+        [$entities, $totalCount] = $this->prepareEntitiesForView($results);
+        $view = $this->view(
+            [
+                'total'                => $totalCount,
+                $this->entityNameMulti => $entities,
+            ],
+            Response::HTTP_OK
+        );
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    /**
+     * Sanitizes and returns an array of where statements from the request.
+     *
+     * @return array<mixed>
+     */
+    protected function getWhereFromRequest(Request $request)
+    {
+        $where = $request->query->all()['where'] ?? [];
+        $this->sanitizeWhereClauseArrayFromRequest($where);
+        return $where;
+    }
+    /**
+     * Sanitizes and returns an array of ORDER statements from the request.
+     *
+     * @return array<mixed>
+     */
+    protected function getOrderFromRequest(Request $request): array
+    {
+        return InputHelper::cleanArray($request->query->all()['order'] ?? []);
+    }
+    /**
+     * Adds the repository alias to the column name if it doesn't exist.
+     *
+     * @return string $column name with alias prefix
+     */
+    protected function addAliasIfNotPresent(string $columns, string $alias): string
+    {
+        if (!$columns) {
+            return $columns;
+        }
+        $columns = explode(',', trim($columns));
+        $prefix  = $alias.'.';
+        array_walk(
+            $columns,
+            function (&$column, $key, $prefix): void {
+                $column = trim($column);
+                if (1 === count(explode('.', $column))) {
+                    $column = $prefix.$column;
+                }
+            },
+            $prefix
+        );
+        return implode(',', $columns);
+    }
+    /**
+     * Obtains a specific entity as defined by the API URL.
+     *
+     * @param int $id Entity ID
+     *
+     * @return Response
+     */
+    public function getEntityAction(Request $request, $id)
+    {
+        $args = [];
+        if ($select = InputHelper::cleanArray($request->get('select', []))) {
+            $args['select']              = $select;
+            $this->customSelectRequested = true;
+        }
+        if (!empty($args)) {
+            $args['id'] = $id;
+            $entity     = $this->model->getEntity($args);
+        } else {
+            $entity = $this->model->getEntity($id);
+        }
+        if (!$entity instanceof $this->entityClass) {
+            return $this->notFound();
+        }
+        if (!$this->checkEntityAccess($entity)) {
+            return $this->accessDenied();
+        }
+        $this->preSerializeEntity($entity);
+        $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK);
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    /**
+     * Creates new entity from provided params.
+     *
+     * @param array<mixed> $params
+     *
+     * @return object
+     */
+    public function getNewEntity(array $params)
+    {
+        return $this->model->getEntity();
+    }
+    public function getCurrentRequest(): Request
+    {
+        $request = $this->requestStack->getCurrentRequest();
+        if (null === $request) {
+            throw new \RuntimeException('Request is not set.');
+        }
+        return $request;
+    }
+    /**
+     * Alias for notFound method. It's used in the LeadAccessTrait.
+     *
+     * @param array<mixed> $args
+     *
+     * @return Response
+     */
+    public function postActionRedirect(array $args = [])
+    {
+        return $this->notFound('mautic.contact.error.notfound');
+    }
+    /**
+     * Returns a 403 Access Denied.
+     *
+     * @param string $msg
+     *
+     * @return Response
+     */
+    protected function accessDenied($msg = 'mautic.core.error.accessdenied')
+    {
+        return $this->returnError($msg, Response::HTTP_FORBIDDEN);
+    }
+    protected function addExclusionStrategy(ExclusionStrategyInterface $strategy): void
+    {
+        $this->exclusionStrategies[] = $strategy;
+    }
+    /**
+     * Returns a 400 Bad Request.
+     *
+     * @param string $msg
+     *
+     * @return Response
+     */
+    protected function badRequest($msg = 'mautic.core.error.badrequest')
+    {
+        return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
+    }
+    /**
+     * Checks if user has permission to access retrieved entity.
+     *
+     * @param mixed  $entity
+     * @param string $action view|create|edit|publish|delete
+     *
+     * @return bool|Response
+     */
+    protected function checkEntityAccess($entity, $action = 'view')
+    {
+        if ('create' !== $action && is_object($entity) && method_exists($entity, 'getCreatedBy')) {
+            $ownPerm   = "{$this->permissionBase}:{$action}own";
+            $otherPerm = "{$this->permissionBase}:{$action}other";
+            $owner = (method_exists($entity, 'getPermissionUser')) ? $entity->getPermissionUser() : $entity->getCreatedBy();
+            return $this->security->hasEntityAccess($ownPerm, $otherPerm, $owner);
+        }
+        try {
+            return $this->security->isGranted("{$this->permissionBase}:{$action}");
+        } catch (PermissionException $e) {
+            return $this->accessDenied($e->getMessage());
+        }
+    }
+    /**
+     * @param mixed[]                   $parameters
+     * @param mixed[]                   $errors
+     * @param bool                      $prepareForSerialization
+     * @param string                    $requestIdColumn
+     * @param MauticModelInterface|null $model
+     * @param bool                      $returnWithOriginalKeys
+     *
+     * @return mixed[]
+     */
+    protected function getBatchEntities($parameters, &$errors, $prepareForSerialization = false, $requestIdColumn = 'id', $model = null, $returnWithOriginalKeys = true): array
+    {
+        $idHelper = new BatchIdToEntityHelper($parameters, $requestIdColumn);
+        if (!$idHelper->hasIds()) {
+            return [];
+        }
+        /** @var AbstractCommonModel<object> $model */
+        $model    = $model ?: $this->model;
+        $entities = $model->getEntities(
+            [
+                'filter' => [
+                    'force' => [
+                        [
+                            'column' => $model->getRepository()->getTableAlias().'.id',
+                            'expr'   => 'in',
+                            'value'  => $idHelper->getIds(),
+                        ],
+                    ],
+                ],
+                'ignore_paginator' => true,
+            ]
+        );
+        $idHelper->setIsAssociative(true);
+        [$entities, $total] = $prepareForSerialization
+                ?
+                $this->prepareEntitiesForView($entities)
+                :
+                $this->prepareEntityResultsToArray($entities);
+        if ($idHelper->hasErrors()) {
+            foreach ($idHelper->getErrors() as $key => $error) {
+                $this->setBatchError($key, $error, Response::HTTP_BAD_REQUEST, $errors);
+            }
+        }
+        if ($returnWithOriginalKeys) {
+            if ($entities instanceof \ArrayObject) {
+                $entities = $entities->getArrayCopy();
+            }
+            return $idHelper->orderByOriginalKey($entities);
+        }
+        $return = [];
+        foreach ($entities as $entity) {
+            $return[$entity->getId()] = $entity;
+        }
+        return $return;
+    }
+    /**
+     * Get the default properties of an entity and parents.
+     *
+     * @phpstan-param E $entity
+     *
+     * @return array<mixed>
+     */
+    protected function getEntityDefaultProperties(object $entity): array
+    {
+        $class         = $entity::class;
+        $chain         = array_reverse(class_parents($entity), true) + [$class => $class];
+        $defaultValues = [];
+        $classMetdata = new ClassMetadata($class);
+        foreach ($chain as $class) {
+            if (method_exists($class, 'loadMetadata')) {
+                $class::loadMetadata($classMetdata);
+            }
+            $defaultValues += (new \ReflectionClass($class))->getDefaultProperties();
+        }
+        $fields = $classMetdata->getFieldNames();
+        $properties = [];
+        foreach ($fields as $field) {
+            $properties[$field] = $defaultValues[$field];
+        }
+        return $properties;
+    }
+    /**
+     * Append options to the form.
+     *
+     * @return array<string, mixed>
+     */
+    protected function getEntityFormOptions(): array
+    {
+        return [];
+    }
+    /**
+     * Get a model instance from the service container.
+     *
+     * @return AbstractCommonModel<E>
+     */
+    protected function getModel(string $modelNameKey): AbstractCommonModel
+    {
+        return $this->modelFactory->getModel($modelNameKey);
+    }
+    /**
+     * Returns a 404 Not Found.
+     *
+     * @return Response
+     */
+    protected function notFound(string $msg = 'mautic.core.error.notfound')
+    {
+        return $this->returnError($msg, Response::HTTP_NOT_FOUND);
+    }
+    /**
+     * Gives child controllers opportunity to analyze and do whatever to an entity before going through serializer.
+     *
+     * @phpstan-param E $entity
+     */
+    protected function preSerializeEntity(object $entity, string $action = 'view'): void
+    {
+    }
+    /**
+     * Prepares entities returned from repository getEntities().
+     *
+     * @param array<mixed>|Paginator<E> $results
+     *
+     * @return array{0: array<mixed>|\ArrayObject<int,mixed>, 1: int}
+     */
+    protected function prepareEntitiesForView($results): array
+    {
+        return $this->prepareEntityResultsToArray(
+            $results,
+            function ($entity): void {
+                $this->preSerializeEntity($entity);
+            }
+        );
+    }
+    /**
+     * @param array<mixed>|Paginator<E> $results
+     * @param callable|null             $callback
+     *
+     * @return array{0: array<mixed>|\ArrayObject<int,mixed>, 1: int}
+     */
+    protected function prepareEntityResultsToArray($results, $callback = null): array
+    {
+        if (is_array($results) && isset($results['count'])) {
+            $totalCount = $results['count'];
+            $results    = $results['results'];
+        } else {
+            $totalCount = count($results);
+        }
+        $entities = $this->entityResultHelper->getArray($results, $callback);
+        return [$entities, $totalCount];
+    }
+    /**
+     * Returns an error.
+     *
+     * @param array<mixed> $details
+     *
+     * @return Response|array<string, array<mixed>|int|string|null>
+     */
+    protected function returnError(string $msg, int $code = Response::HTTP_INTERNAL_SERVER_ERROR, array $details = [])
+    {
+        if ($this->translator->hasId($msg, 'flashes')) {
+            $msg = $this->translator->trans($msg, [], 'flashes');
+        } elseif ($this->translator->hasId($msg, 'messages')) {
+            $msg = $this->translator->trans($msg, [], 'messages');
+        }
+        $error = [
+            'code'    => $code,
+            'message' => $msg,
+            'details' => $details,
+            'type'    => null,
+        ];
+        if ($this->inBatchMode) {
+            return $error;
+        }
+        $view = $this->view(
+            [
+                'errors' => [
+                    $error,
+                ],
+            ],
+            $code
+        );
+        return $this->handleView($view);
+    }
+    /**
+     * @param array<mixed> $where
+     */
+    protected function sanitizeWhereClauseArrayFromRequest(array &$where): void
+    {
+        foreach ($where as $key => $statement) {
+            if (isset($statement['internal'])) {
+                unset($where[$key]);
+            } elseif (in_array($statement['expr'], ['andX', 'orX'])) {
+                $this->sanitizeWhereClauseArrayFromRequest($statement['val']);
+            }
+        }
+    }
+    /**
+     * @param array<int, array<string|int>> $errors
+     * @param array<int, object|null>       $entities
+     *
+     * @phpstan-param E|null $entity
+     * @phpstan-param array<int, E|null> $entities
+     */
+    protected function setBatchError(int $key, string $msg, int $code, array &$errors, array &$entities = [], ?object $entity = null): void
+    {
+        unset($entities[$key]);
+        if ($entity) {
+            $this->doctrine->getManager()->detach($entity);
+        }
+        $errors[$key] = [
+            'message' => $this->translator->hasId($msg, 'flashes') ? $this->translator->trans($msg, [], 'flashes') : $msg,
+            'code'    => $code,
+            'type'    => 'api',
+        ];
+    }
+    /**
+     * Set serialization groups and exclusion strategies.
+     */
+    protected function setSerializationContext(View $view): void
+    {
+        $context = $view->getContext();
+        if ($this->dispatcher->hasListeners(ApiEvents::API_PRE_SERIALIZATION_CONTEXT)) {
+            $apiSerializationContextEvent = new ApiSerializationContextEvent($context, $this->getCurrentRequest());
+            $this->dispatcher->dispatch($apiSerializationContextEvent, ApiEvents::API_PRE_SERIALIZATION_CONTEXT);
+            $context = $apiSerializationContextEvent->getContext();
+        }
+        if (!empty($this->serializerGroups)) {
+            $context->setGroups($this->serializerGroups);
+        }
+        $context->addExclusionStrategy(
+            new PublishDetailsExclusionStrategy()
+        );
+        if ($this->parentChildrenLevelDepth) {
+            $context->addExclusionStrategy(
+                new ParentChildrenExclusionStrategy($this->parentChildrenLevelDepth)
+            );
+        }
+        foreach ($this->exclusionStrategies as $strategy) {
+            $context->addExclusionStrategy($strategy);
+        }
+        if (!$this->customSelectRequested) {
+            $context->setSerializeNull(true);
+        }
+        if ($this->dispatcher->hasListeners(ApiEvents::API_POST_SERIALIZATION_CONTEXT)) {
+            $apiSerializationContextEvent = new ApiSerializationContextEvent($context, $this->getCurrentRequest());
+            $this->dispatcher->dispatch($apiSerializationContextEvent, ApiEvents::API_POST_SERIALIZATION_CONTEXT);
+            $context = $apiSerializationContextEvent->getContext();
+        }
+        $view->setContext($context);
+    }
+    /**
+     * @param array<mixed> $parameters
+     *
+     * @return array<string, array<mixed>|int|string|null>|bool|Response
+     */
+    protected function validateBatchPayload(array $parameters)
+    {
+        $batchLimit = (int) $this->coreParametersHelper->get('api_batch_max_limit', 200);
+        if (count($parameters) > $batchLimit) {
+            return $this->returnError($this->translator->trans('mautic.api.call.batch_exception', ['%limit%' => $batchLimit]));
+        }
+        return true;
+    }
+    /**
+     * @param mixed|null                $data
+     * @param array<string, string|int> $headers
+     */
+    protected function view($data = null, ?int $statusCode = null, array $headers = []): View
+    {
+        if ($data instanceof Paginator) {
+            $data = iterator_to_array($data->getIterator(), true);
+        }
+        $headers['Mautic-Version'] = $this->appVersion->getVersion();
+        return parent::view($data, $statusCode, $headers);
+    }
+    protected function getTotalCountTtl(): ?int
+    {
+        return null;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Controller/oAuth2/AuthorizeController.php
@@ -0,0 +1,70 @@
+<?php
+namespace Mautic\ApiBundle\Controller\oAuth2;
+use FOS\OAuthServerBundle\Form\Handler\AuthorizeFormHandler;
+use FOS\OAuthServerBundle\Model\ClientManagerInterface;
+use OAuth2\OAuth2;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\Form;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
+use Symfony\Component\Security\Core\Exception\AccessDeniedException;
+use Twig\Environment;
+use Twig\Error\LoaderError;
+use Twig\Error\RuntimeError;
+use Twig\Error\SyntaxError;
+class AuthorizeController extends \FOS\OAuthServerBundle\Controller\AuthorizeController
+{
+    private TokenStorageInterface $tokenStorage;
+    /**
+     * This constructor must be duplicated from the extended class so our custom code could access the properties.
+     */
+    public function __construct(
+        RequestStack $requestStack,
+        Form $authorizeForm,
+        AuthorizeFormHandler $authorizeFormHandler,
+        OAuth2 $oAuth2Server,
+        TokenStorageInterface $tokenStorage,
+        UrlGeneratorInterface $router,
+        ClientManagerInterface $clientManager,
+        EventDispatcherInterface $eventDispatcher,
+        private Environment $twig,
+    ) {
+        parent::__construct(
+            $requestStack,
+            $authorizeForm,
+            $authorizeFormHandler,
+            $oAuth2Server,
+            $twig,
+            $tokenStorage,
+            $router,
+            $clientManager,
+            $eventDispatcher
+        );
+        $this->tokenStorage = $tokenStorage;
+    }
+    /**
+     * @param array<string , mixed> $data Various data to be passed to the twig template
+     *
+     * @throws LoaderError
+     * @throws RuntimeError
+     * @throws SyntaxError
+     */
+    protected function renderAuthorize(array $data): Response
+    {
+        $response = $this->twig->render(
+            '@MauticApi/Authorize/oAuth2/authorize.html.twig',
+            $data
+        );
+        return new Response($response);
+    }
+    public function authorizeAction(Request $request): Response
+    {
+        if (null === $this->tokenStorage->getToken()) {
+            throw new AccessDeniedException('This user does not have access to this section. No token.');
+        }
+        return parent::authorizeAction($request);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Controller/oAuth2/SecurityController.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\ApiBundle\Controller\oAuth2;
+use Mautic\CoreBundle\Controller\CommonController;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Security\Core\Exception;
+use Symfony\Component\Security\Http\SecurityRequestAttributes;
+class SecurityController extends CommonController
+{
+    public function loginAction(Request $request): Response
+    {
+        $session = $request->getSession();
+        if ($request->attributes->has(SecurityRequestAttributes::AUTHENTICATION_ERROR)) {
+            $error = $request->attributes->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
+        } else {
+            $error = $session->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
+            $session->remove(SecurityRequestAttributes::AUTHENTICATION_ERROR);
+        }
+        if (!empty($error)) {
+            if ($error instanceof Exception\BadCredentialsException) {
+                $msg = 'mautic.user.auth.error.invalidlogin';
+            } else {
+                $msg = $error->getMessage();
+            }
+            $this->addFlashMessage($msg, [], 'error', null, false);
+        }
+        if ($session->has('_security.target_path')) {
+            if (str_contains($session->get('_security.target_path'), $this->generateUrl('fos_oauth_server_authorize'))) {
+                $session->set('_fos_oauth_server.ensure_logout', true);
+            }
+        }
+        return $this->render(
+            '@MauticApi/Security/login.html.twig',
+            [
+                'last_username' => $session->get(SecurityRequestAttributes::LAST_USERNAME),
+                'route'         => 'mautic_oauth2_server_auth_login_check',
+            ]
+        );
+    }
+    public function loginCheckAction(): Response
+    {
+        return new Response('', 400);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Entity/oAuth2/Client.php
@@ -0,0 +1,201 @@
+<?php
+namespace Mautic\ApiBundle\Entity\oAuth2;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\ORM\Mapping as ORM;
+use FOS\OAuthServerBundle\Model\Client as BaseClient;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\UserBundle\Entity\Role;
+use Mautic\UserBundle\Entity\User;
+use OAuth2\OAuth2;
+use Symfony\Component\Validator\Constraints as Assert;
+use Symfony\Component\Validator\Mapping\ClassMetadata;
+class Client extends BaseClient
+{
+    /**
+     * @var int
+     */
+    protected $id;
+    /**
+     * @var string
+     */
+    protected $name;
+    /**
+     * @var ArrayCollection<int, User>
+     */
+    protected $users;
+    /**
+     * @var ArrayCollection
+     */
+    protected $authCodes;
+    protected ?string $randomId = null;
+    protected ?string $secret = null;
+    /**
+     * @var array<string>
+     */
+    protected array $redirectUris = [];
+    /**
+     * @var array<string>
+     */
+    protected array $allowedGrantTypes;
+    protected ?Role $role;
+    public function __construct()
+    {
+        parent::__construct();
+        $this->allowedGrantTypes = [
+            OAuth2::GRANT_TYPE_AUTH_CODE,
+            OAuth2::GRANT_TYPE_REFRESH_TOKEN,
+        ];
+        $this->users     = new ArrayCollection();
+        $this->authCodes = new ArrayCollection();
+    }
+    public static function loadMetadata(ORM\ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable('oauth2_clients')
+            ->setCustomRepositoryClass(ClientRepository::class)
+            ->addIndex(['random_id'], 'client_id_search');
+        $builder->addIdColumns('name', false);
+        $builder->createManyToMany('users', User::class)
+            ->setJoinTable('oauth2_user_client_xref')
+            ->addInverseJoinColumn('user_id', 'id', false, false, 'CASCADE')
+            ->addJoinColumn('client_id', 'id', false, false, 'CASCADE')
+            ->fetchExtraLazy()
+            ->build();
+        $builder->createField('randomId', 'string')
+            ->columnName('random_id')
+            ->build();
+        $builder->addField('secret', 'string');
+        $builder->createField('redirectUris', 'array')
+            ->columnName('redirect_uris')
+            ->build();
+        $builder->createField('allowedGrantTypes', 'array')
+            ->columnName('allowed_grant_types')
+            ->build();
+        $builder->createManyToOne('role', Role::class)
+            ->addJoinColumn('role_id', 'id', true, false)
+            ->cascadePersist()
+            ->build();
+    }
+    public static function loadValidatorMetadata(ClassMetadata $metadata): void
+    {
+        $metadata->addPropertyConstraint('name', new Assert\NotBlank(
+            ['message' => 'mautic.core.name.required']
+        ));
+        $metadata->addPropertyConstraint('redirectUris', new Assert\NotBlank(
+            ['message' => 'mautic.api.client.redirecturis.notblank']
+        ));
+    }
+    /**
+     * @var array
+     */
+    protected $changes;
+    protected function isChanged($prop, $val)
+    {
+        $getter  = 'get'.ucfirst($prop);
+        $current = $this->$getter();
+        if ($current != $val) {
+            $this->changes[$prop] = [$current, $val];
+        }
+    }
+    /**
+     * @return array
+     */
+    public function getChanges()
+    {
+        return $this->changes;
+    }
+    /**
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * @param string $name
+     *
+     * @return Client
+     */
+    public function setName($name)
+    {
+        $this->isChanged('name', $name);
+        $this->name = $name;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getName()
+    {
+        return $this->name;
+    }
+    public function setRedirectUris(array $redirectUris): void
+    {
+        $this->isChanged('redirectUris', $redirectUris);
+        $this->redirectUris = $redirectUris;
+    }
+    /**
+     * @return Client
+     */
+    public function addAuthCode(AuthCode $authCodes)
+    {
+        $this->authCodes[] = $authCodes;
+        return $this;
+    }
+    public function removeAuthCode(AuthCode $authCodes): void
+    {
+        $this->authCodes->removeElement($authCodes);
+    }
+    /**
+     * @return \Doctrine\Common\Collections\Collection
+     */
+    public function getAuthCodes()
+    {
+        return $this->authCodes;
+    }
+    /**
+     * Determines if a client attempting API access is already authorized by the user.
+     *
+     * @return bool
+     */
+    public function isAuthorizedClient(User $user)
+    {
+        $users = $this->getUsers();
+        return $users->contains($user);
+    }
+    /**
+     * @return Client
+     */
+    public function addUser(User $users)
+    {
+        $this->users[] = $users;
+        return $this;
+    }
+    public function removeUser(User $users): void
+    {
+        $this->users->removeElement($users);
+    }
+    /**
+     * @return \Doctrine\Common\Collections\Collection
+     */
+    public function getUsers()
+    {
+        return $this->users;
+    }
+    /**
+     * Add Authorization Grant Type.
+     */
+    public function addGrantType(string $grantType): Client
+    {
+        $this->allowedGrantTypes[] = $grantType;
+        return $this;
+    }
+    public function getRole(): Role
+    {
+        return $this->role;
+    }
+    public function setRole(Role $role): void
+    {
+        $this->role = $role;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Event/ApiEntityEvent.php
@@ -0,0 +1,37 @@
+<?php
+namespace Mautic\ApiBundle\Event;
+use Mautic\CoreBundle\Event\CommonEvent;
+use Symfony\Component\HttpFoundation\Request;
+class ApiEntityEvent extends CommonEvent
+{
+    /**
+     * @param object $entity
+     */
+    public function __construct(
+        protected $entity,
+        protected array $entityRequestParameters,
+        private Request $request,
+    ) {
+    }
+    /**
+     * @return object
+     */
+    public function getEntity()
+    {
+        return $this->entity;
+    }
+    /**
+     * @return array
+     */
+    public function getEntityRequestParameters()
+    {
+        return $this->entityRequestParameters;
+    }
+    /**
+     * @return Request
+     */
+    public function getRequest()
+    {
+        return $this->request;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/EventListener/ApiSubscriber.php
@@ -0,0 +1,141 @@
+<?php
+namespace Mautic\ApiBundle\EventListener;
+use Mautic\ApiBundle\Helper\RequestHelper;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpKernel\Event\RequestEvent;
+use Symfony\Component\HttpKernel\Event\ResponseEvent;
+use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
+use Symfony\Component\HttpKernel\KernelEvents;
+class ApiSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+        private Translator $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            KernelEvents::REQUEST  => ['onKernelRequest', 255],
+            KernelEvents::RESPONSE => ['onKernelResponse', 0],
+        ];
+    }
+    /**
+     * Check for API requests and throw denied access if API is disabled.
+     *
+     * @throws AccessDeniedHttpException
+     */
+    public function onKernelRequest(RequestEvent $event): void
+    {
+        if (!$event->isMainRequest()) {
+            return;
+        }
+        $request = $event->getRequest();
+        if (!RequestHelper::isApiRequest($request)) {
+            return;
+        }
+        $apiEnabled = $this->coreParametersHelper->get('api_enabled');
+        if (!$apiEnabled) {
+            $response   = new JsonResponse(
+                [
+                    'errors' => [
+                        [
+                            'message' => $this->translator->trans('mautic.api.error.api.disabled'),
+                            'code'    => 403,
+                            'type'    => 'api_disabled',
+                        ],
+                    ],
+                ],
+                403
+            );
+            $event->setResponse($response);
+            return;
+        }
+        $hasBasicAuth     = RequestHelper::hasBasicAuth($request);
+        $basicAuthEnabled = $this->coreParametersHelper->get('api_enable_basic_auth');
+        if ($hasBasicAuth && !$basicAuthEnabled) {
+            $response   = new JsonResponse(
+                [
+                    'errors' => [
+                        [
+                            'message' => $this->translator->trans('mautic.api.error.basic.auth.disabled'),
+                            'code'    => 403,
+                            'type'    => 'access_denied',
+                        ],
+                    ],
+                ],
+                403
+            );
+            $event->setResponse($response);
+        }
+    }
+    public function onKernelResponse(ResponseEvent $event): void
+    {
+        $request      = $event->getRequest();
+        $isApiRequest = RequestHelper::isApiRequest($request);
+        $hasBasicAuth = RequestHelper::hasBasicAuth($event->getRequest());
+        if (!$isApiRequest) {
+            return;
+        }
+        $response = $event->getResponse();
+        $content  = $response->getContent();
+        if (!str_contains($content, 'error')) {
+            return;
+        }
+        if (!$data = json_decode($content, true)) {
+            return;
+        }
+        if (!isset($data['error'])) {
+            return;
+        }
+        $type  = null;
+        $error = $data['error'];
+        if (is_array($error)) {
+            if (!isset($error['message'])) {
+                return;
+            }
+            $error = $error['message'];
+        }
+        switch ($error) {
+            case 'access_denied':
+                $type    = $error;
+                $message = $this->translator->trans('mautic.api.auth.error.accessdenied');
+                if ($hasBasicAuth) {
+                    if ($this->coreParametersHelper->get('api_enable_basic_auth')) {
+                        $message = $this->translator->trans('mautic.api.error.basic.auth.invalid.credentials');
+                    } else {
+                        $message = $this->translator->trans('mautic.api.error.basic.auth.disabled');
+                    }
+                }
+                break;
+            default:
+                if (isset($data['error_description'])) {
+                    $message = $data['error_description'];
+                    $type    = $error;
+                } elseif ($this->translator->hasId('mautic.api.auth.error.'.$error)) {
+                    $message = $this->translator->trans('mautic.api.auth.error.'.$error);
+                    $type    = $error;
+                }
+        }
+        if (!isset($message)) {
+            return;
+        }
+        $statusCode = $response->getStatusCode();
+        $response   = new JsonResponse(
+            [
+                'errors' => [
+                    [
+                        'message' => $message,
+                        'code'    => $response->getStatusCode(),
+                        'type'    => $type,
+                    ],
+                ],
+            ],
+            $statusCode
+        );
+        $event->setResponse($response);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/EventListener/ClientSubscriber.php
@@ -0,0 +1,57 @@
+<?php
+namespace Mautic\ApiBundle\EventListener;
+use Mautic\ApiBundle\ApiEvents;
+use Mautic\ApiBundle\Event as Events;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class ClientSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private IpLookupHelper $ipLookupHelper,
+        private AuditLogModel $auditLogModel,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ApiEvents::CLIENT_POST_SAVE   => ['onClientPostSave', 0],
+            ApiEvents::CLIENT_POST_DELETE => ['onClientDelete', 0],
+        ];
+    }
+    /**
+     * Add a client change entry to the audit log.
+     */
+    public function onClientPostSave(Events\ClientEvent $event): void
+    {
+        $client = $event->getClient();
+        if (!$details = $event->getChanges()) {
+            return;
+        }
+        $log = [
+            'bundle'    => 'api',
+            'object'    => 'client',
+            'objectId'  => $client->getId(),
+            'action'    => ($event->isNew()) ? 'create' : 'update',
+            'details'   => $details,
+            'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+        ];
+        $this->auditLogModel->writeToLog($log);
+    }
+    /**
+     * Add a role delete entry to the audit log.
+     */
+    public function onClientDelete(Events\ClientEvent $event): void
+    {
+        $client = $event->getClient();
+        $log    = [
+            'bundle'    => 'api',
+            'object'    => 'client',
+            'objectId'  => $client->deletedId,
+            'action'    => 'delete',
+            'details'   => ['name' => $client->getName()],
+            'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+        ];
+        $this->auditLogModel->writeToLog($log);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/EventListener/PreAuthorizationEventListener.php
@@ -0,0 +1,52 @@
+<?php
+namespace Mautic\ApiBundle\EventListener;
+use Doctrine\ORM\EntityManager;
+use FOS\OAuthServerBundle\Event\OAuthEvent;
+use Mautic\ApiBundle\Entity\oAuth2\Client;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Component\Security\Core\Exception\AccessDeniedException;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class PreAuthorizationEventListener
+{
+    public function __construct(
+        private EntityManager $em,
+        private CorePermissions $mauticSecurity,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    /**
+     * @throws AccessDeniedException
+     */
+    public function onPreAuthorizationProcess(OAuthEvent $event): void
+    {
+        if ($user = $this->getUser($event)) {
+            if (!$this->mauticSecurity->isGranted('api:access:full')) {
+                throw new AccessDeniedException($this->translator->trans('mautic.core.error.accessdenied', [], 'flashes'));
+            }
+            $client = $event->getClient();
+            if ($client instanceof Client) {
+                $event->setAuthorizedClient(
+                    $client->isAuthorizedClient($user)
+                );
+            }
+        }
+    }
+    public function onPostAuthorizationProcess(OAuthEvent $event): void
+    {
+        if ($event->isAuthorizedClient() && null !== $client = $event->getClient()) {
+            if ($client instanceof Client) {
+                $user = $this->getUser($event);
+                $client->addUser($user);
+                $this->em->persist($client);
+                $this->em->flush();
+            }
+        }
+    }
+    /**
+     * @return mixed
+     */
+    protected function getUser(OAuthEvent $event)
+    {
+        return $this->em->getRepository(\Mautic\UserBundle\Entity\User::class)->findOneByUsername($event->getUser()->getUserIdentifier());
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/EventListener/RateLimitGenerateKeySubscriber.php
@@ -0,0 +1,24 @@
+<?php
+namespace Mautic\ApiBundle\EventListener;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Noxlogic\RateLimitBundle\Events\GenerateKeyEvent;
+use Noxlogic\RateLimitBundle\Events\RateLimitEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class RateLimitGenerateKeySubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            RateLimitEvents::GENERATE_KEY => ['onGenerateKey', 0],
+        ];
+    }
+    public function onGenerateKey(GenerateKeyEvent $event): void
+    {
+        $suffix = rawurlencode($this->coreParametersHelper->get('site_url'));
+        $event->addToKey($suffix);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/EventListener/SearchSubscriber.php
@@ -0,0 +1,47 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ApiBundle\EventListener;
+use Mautic\ApiBundle\Model\ClientModel;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
+use Mautic\CoreBundle\Event as MauticEvents;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\GlobalSearch;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class SearchSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private ClientModel $apiClientModel,
+        private CorePermissions $security,
+        private GlobalSearch $globalSearch,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
+            CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
+        ];
+    }
+    public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
+    {
+        $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
+        $results   = $this->globalSearch->performSearch(
+            $filterDTO,
+            $this->apiClientModel,
+            '@MauticApi/SubscribedEvents/Search/global.html.twig'
+        );
+        if (!empty($results)) {
+            $event->addResults('mautic.api.client.menu.index', $results);
+        }
+    }
+    public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
+    {
+        if ($this->security->isGranted('api:clients:view')) {
+            $event->addCommands(
+                'mautic.api.client.header.index',
+                $this->apiClientModel->getCommandList()
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Form/Type/ClientType.php
@@ -0,0 +1,153 @@
+<?php
+namespace Mautic\ApiBundle\Form\Type;
+use Mautic\ApiBundle\Entity\oAuth2\Client;
+use Mautic\ApiBundle\Form\Validator\Constraints\OAuthCallback;
+use Mautic\CoreBundle\Form\DataTransformer as Transformers;
+use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
+use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Form\FormError;
+use Symfony\Component\Form\FormEvent;
+use Symfony\Component\Form\FormEvents;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Component\Validator\Validator\ValidatorInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<Client>
+ */
+class ClientType extends AbstractType
+{
+    public function __construct(
+        private RequestStack $requestStack,
+        private TranslatorInterface $translator,
+        private ValidatorInterface $validator,
+        private RouterInterface $router,
+    ) {
+    }
+    /**
+     * @return bool|mixed
+     */
+    private function getApiMode()
+    {
+        return $this->requestStack->getCurrentRequest()->get(
+            'api_mode',
+            $this->requestStack->getSession()->get('mautic.client.filter.api_mode', 'oauth2')
+        );
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $apiMode = $this->getApiMode();
+        $builder->addEventSubscriber(new CleanFormSubscriber([]));
+        $builder->addEventSubscriber(new FormExitSubscriber('api.client', $options));
+        if (!$options['data']->getId()) {
+            $builder->add(
+                'api_mode',
+                ChoiceType::class,
+                [
+                    'mapped'     => false,
+                    'label'      => 'mautic.api.client.form.auth_protocol',
+                    'label_attr' => ['class' => 'control-label'],
+                    'attr'       => [
+                        'class'    => 'form-control',
+                        'onchange' => 'Mautic.refreshApiClientForm(\''.$this->router->generate('mautic_client_action', ['objectAction' => 'new']).'\', this)',
+                    ],
+                    'choices' => [
+                        'OAuth 2'    => 'oauth2',
+                    ],
+                    'required'          => false,
+                    'placeholder'       => false,
+                    'data'              => $apiMode,
+                ]
+            );
+        }
+        $builder->add(
+            'name',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.name',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+            ]
+        );
+        $arrayStringTransformer = new Transformers\ArrayStringTransformer();
+        $builder->add(
+            $builder->create(
+                'redirectUris',
+                TextType::class,
+                [
+                    'label'      => 'mautic.api.client.redirecturis',
+                    'label_attr' => ['class' => 'control-label'],
+                    'attr'       => [
+                        'class'   => 'form-control',
+                        'tooltip' => 'mautic.api.client.form.help.requesturis',
+                    ],
+                ]
+            )
+                ->addViewTransformer($arrayStringTransformer)
+        );
+        $builder->add(
+            'publicId',
+            TextType::class,
+            [
+                'label'      => 'mautic.api.client.form.clientid',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+                'disabled'   => true,
+                'required'   => false,
+                'mapped'     => false,
+                'data'       => $options['data']->getPublicId(),
+            ]
+        );
+        $builder->add(
+            'secret',
+            TextType::class,
+            [
+                'label'      => 'mautic.api.client.form.clientsecret',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+                'disabled'   => true,
+                'required'   => false,
+            ]
+        );
+        $builder->addEventListener(
+            FormEvents::POST_SUBMIT,
+            function (FormEvent $event): void {
+                $form = $event->getForm();
+                $data = $event->getData();
+                if ($form->has('redirectUris')) {
+                    foreach ($data->getRedirectUris() as $uri) {
+                        $urlConstraint          = new OAuthCallback();
+                        $urlConstraint->message = $this->translator->trans(
+                            'mautic.api.client.redirecturl.invalid',
+                            ['%url%' => $uri],
+                            'validators'
+                        );
+                        $errors = $this->validator->validate($uri, $urlConstraint);
+                        foreach ($errors as $error) {
+                            $form['redirectUris']->addError(new FormError($error->getMessage()));
+                        }
+                    }
+                }
+            }
+        );
+        $builder->add('buttons', FormButtonsType::class);
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $dataClass = Client::class;
+        $resolver->setDefaults(
+            [
+                'data_class' => $dataClass,
+            ]
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Form/Type/ConfigType.php
@@ -0,0 +1,78 @@
+<?php
+namespace Mautic\ApiBundle\Form\Type;
+use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\NumberType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints\NotBlank;
+/**
+ * @extends AbstractType<mixed>
+ */
+class ConfigType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'api_enabled',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.api.config.form.api.enabled',
+                'data'  => isset($options['data']['api_enabled']) && (bool) $options['data']['api_enabled'],
+                'help'  => 'mautic.api.config.form.api.enabled.help',
+            ]
+        );
+        $builder->add(
+            'api_enable_basic_auth',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.api.config.form.api.basic_auth_enabled',
+                'data'  => isset($options['data']['api_enable_basic_auth']) && (bool) $options['data']['api_enable_basic_auth'],
+                'attr'  => [
+                    'tooltip' => 'mautic.api.config.form.api.basic_auth.tooltip',
+                ],
+            ]
+        );
+        $builder->add(
+            'api_oauth2_access_token_lifetime',
+            NumberType::class,
+            [
+                'label' => 'mautic.api.config.form.api.oauth2_access_token_lifetime',
+                'attr'  => [
+                    'tooltip'      => 'mautic.api.config.form.api.oauth2_access_token_lifetime.tooltip',
+                    'class'        => 'form-control',
+                    'data-show-on' => '{"config_apiconfig_api_enabled_1":"checked"}',
+                ],
+                'constraints' => [
+                    new NotBlank(
+                        [
+                            'message' => 'mautic.core.value.required',
+                        ]
+                    ),
+                ],
+            ]
+        );
+        $builder->add(
+            'api_oauth2_refresh_token_lifetime',
+            NumberType::class,
+            [
+                'label' => 'mautic.api.config.form.api.oauth2_refresh_token_lifetime',
+                'attr'  => [
+                    'tooltip'      => 'mautic.api.config.form.api.oauth2_refresh_token_lifetime.tooltip',
+                    'class'        => 'form-control',
+                    'data-show-on' => '{"config_apiconfig_api_enabled_1":"checked"}',
+                ],
+                'constraints' => [
+                    new NotBlank(
+                        [
+                            'message' => 'mautic.core.value.required',
+                        ]
+                    ),
+                ],
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'apiconfig';
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Form/Validator/Constraints/OAuthCallback.php
@@ -0,0 +1,11 @@
+<?php
+namespace Mautic\ApiBundle\Form\Validator\Constraints;
+use Symfony\Component\Validator\Constraint;
+class OAuthCallback extends Constraint
+{
+    public $message = 'The callback URL is invalid.';
+    public function validatedBy(): string
+    {
+        return OAuthCallbackValidator::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Helper/BatchIdToEntityHelper.php
@@ -0,0 +1,126 @@
+<?php
+namespace Mautic\ApiBundle\Helper;
+class BatchIdToEntityHelper
+{
+    /**
+     * @var array
+     */
+    private $ids = [];
+    private array $originalKeys = [];
+    private array $errors = [];
+    private bool $isAssociative = false;
+    /**
+     * @param string $idKey
+     */
+    public function __construct(
+        array $parameters,
+        private $idKey = 'id',
+    ) {
+        $this->extractIds($parameters);
+    }
+    public function hasIds(): bool
+    {
+        return !empty($this->ids);
+    }
+    /**
+     * @return array
+     */
+    public function getIds()
+    {
+        return $this->ids;
+    }
+    public function hasErrors(): bool
+    {
+        return !empty($this->errors);
+    }
+    /**
+     * @return array
+     */
+    public function getErrors()
+    {
+        return $this->errors;
+    }
+    /**
+     * Reorder the entities based on the original keys
+     * BC allowed a request to have associative keys (don't ask why; yes it's terrible implementation but we're keeping BC here)
+     * The issue this solves is the response should match the format given by the request. If the request had associative keys, the response
+     * will return with associative keys (json object). If the request was a sequential numeric array starting with 0, the response will
+     * be a simple array (json array).
+     */
+    public function orderByOriginalKey(array $entities): array
+    {
+        if (!$this->isAssociative) {
+            return array_values($entities);
+        }
+        $entitiesKeyedById = [];
+        foreach ($entities as $entity) {
+            $entitiesKeyedById[$entity->getId()] = $entity;
+        }
+        $orderedEntities = [];
+        foreach ($this->ids as $key => $id) {
+            if (!isset($entitiesKeyedById[$id])) {
+                continue;
+            }
+            $originalKey                   = $this->originalKeys[$key];
+            $orderedEntities[$originalKey] = $entitiesKeyedById[$id];
+        }
+        return $orderedEntities;
+    }
+    private function extractIds(array $parameters): void
+    {
+        $this->ids = [];
+        if (isset($parameters['ids'])) {
+            $this->extractIdsFromIdKey($parameters['ids']);
+            return;
+        }
+        $this->extractIdsFromParams($parameters);
+    }
+    /**
+     * @param mixed $ids
+     */
+    private function extractIdsFromIdKey($ids): void
+    {
+        if (is_array($ids)) {
+            $this->isAssociative = $this->isAssociativeArray($ids);
+            $this->ids           = array_values($ids);
+            $this->originalKeys  = array_keys($ids);
+            return;
+        }
+        if (str_contains($ids, ',') || is_numeric($ids)) {
+            $this->ids           = str_getcsv($ids);
+            $this->originalKeys  = array_keys($this->ids);
+            $this->isAssociative = false;
+            return;
+        }
+        $this->errors[] = 'mautic.api.call.id_missing';
+    }
+    private function extractIdsFromParams(array $parameters): void
+    {
+        $this->isAssociative = $this->isAssociativeArray($parameters);
+        $this->originalKeys  = array_keys($parameters);
+        $firstKey            = array_key_first($parameters);
+        if (!is_array($parameters[$firstKey])) {
+            $this->ids = array_values($parameters);
+            return;
+        }
+        foreach ($parameters as $key => $params) {
+            if (!isset($params[$this->idKey])) {
+                $this->errors[$key] = 'mautic.api.call.id_missing';
+                continue;
+            }
+            $this->ids[] = $params[$this->idKey];
+        }
+    }
+    private function isAssociativeArray(array $array): bool
+    {
+        if (empty($array)) {
+            return false;
+        }
+        $firstKey = array_key_first($array);
+        return array_keys($array) !== range(0, count($array) - 1) && 0 !== $firstKey;
+    }
+    public function setIsAssociative(bool $isAssociative): void
+    {
+        $this->isAssociative = $isAssociative;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/MauticApiBundle.php
@@ -0,0 +1,13 @@
+<?php
+namespace Mautic\ApiBundle;
+use Mautic\ApiBundle\DependencyInjection\Compiler\SerializerPass;
+use Symfony\Component\DependencyInjection\ContainerBuilder;
+use Symfony\Component\HttpKernel\Bundle\Bundle;
+class MauticApiBundle extends Bundle
+{
+    public function build(ContainerBuilder $container): void
+    {
+        parent::build($container);
+        $container->addCompilerPass(new SerializerPass(), \Symfony\Component\DependencyInjection\Compiler\PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Model/ClientModel.php
@@ -0,0 +1,136 @@
+<?php
+namespace Mautic\ApiBundle\Model;
+use Doctrine\ORM\EntityManager;
+use Mautic\ApiBundle\ApiEvents;
+use Mautic\ApiBundle\Entity\oAuth2\Client;
+use Mautic\ApiBundle\Event\ClientEvent;
+use Mautic\ApiBundle\Form\Type\ClientType;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Model\GlobalSearchInterface;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\UserBundle\Entity\User;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @extends FormModel<Client>
+ */
+class ClientModel extends FormModel implements GlobalSearchInterface
+{
+    /**
+     * @var string
+     */
+    public const API_MODE_OAUTH2 = 'oauth2';
+    private ?string $apiMode = null;
+    private const DEFAULT_API_MODE = 'oauth2';
+    public function __construct(
+        private RequestStack $requestStack,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    private function getApiMode(): string
+    {
+        if (null !== $this->apiMode) {
+            return $this->apiMode;
+        }
+        if (null !== $request = $this->requestStack->getCurrentRequest()) {
+            return $request->get('api_mode', $request->getSession()->get('mautic.client.filter.api_mode', self::DEFAULT_API_MODE));
+        }
+        return self::DEFAULT_API_MODE;
+    }
+    public function setApiMode($apiMode): void
+    {
+        $this->apiMode = $apiMode;
+    }
+    public function getRepository(): \Mautic\ApiBundle\Entity\oAuth2\ClientRepository
+    {
+        return $this->em->getRepository(Client::class);
+    }
+    public function getPermissionBase(): string
+    {
+        return 'api:clients';
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
+    {
+        if (!$entity instanceof Client) {
+            throw new MethodNotAllowedHttpException(['Client']);
+        }
+        $params = (!empty($action)) ? ['action' => $action] : [];
+        return $formFactory->create(ClientType::class, $entity, $params);
+    }
+    public function getEntity($id = null): ?Client
+    {
+        if (null === $id) {
+            return 'oauth2' === $this->getApiMode() ? new Client() : null;
+        }
+        return parent::getEntity($id);
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
+    {
+        if (!$entity instanceof Client) {
+            throw new MethodNotAllowedHttpException(['Client']);
+        }
+        switch ($action) {
+            case 'post_save':
+                $name = ApiEvents::CLIENT_POST_SAVE;
+                break;
+            case 'post_delete':
+                $name = ApiEvents::CLIENT_POST_DELETE;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new ClientEvent($entity, $isNew);
+                $event->setEntityManager($this->em);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        }
+        return null;
+    }
+    /**
+     * @return array
+     */
+    public function getUserClients(User $user)
+    {
+        return $this->getRepository()->getUserClients($user);
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    public function revokeAccess($entity): void
+    {
+        if (!$entity instanceof Client) {
+            throw new MethodNotAllowedHttpException(['Client']);
+        }
+        if ('oauth2' === $this->getApiMode()) {
+            $entity->removeUser($this->userHelper->getUser());
+            $this->saveEntity($entity);
+        } else {
+            $this->getRepository()->deleteAccessTokens($entity, $this->userHelper->getUser());
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Serializer/Driver/ApiMetadataDriver.php
@@ -0,0 +1,256 @@
+<?php
+namespace Mautic\ApiBundle\Serializer\Driver;
+use JMS\Serializer\Metadata\ClassMetadata;
+use JMS\Serializer\Metadata\PropertyMetadata;
+use Metadata\ClassMetadata as BaseClassMetadata;
+use Metadata\Driver\DriverInterface;
+class ApiMetadataDriver implements DriverInterface
+{
+    private ?ClassMetadata $metadata = null;
+    /**
+     * @var PropertyMetadata[]
+     */
+    private array $properties = [];
+    private string $groupPrefix = '';
+    private string $defaultVersion = '1.0';
+    private ?string $currentPropertyName = null;
+    /**
+     * @throws \ReflectionException
+     */
+    public function loadMetadataForClass(\ReflectionClass $class): ?BaseClassMetadata
+    {
+        if ($class->hasMethod('loadApiMetadata')) {
+            $this->metadata = new ClassMetadata($class->getName());
+            $class->getMethod('loadApiMetadata')->invoke(null, $this);
+            $metadata = $this->metadata;
+            $this->resetDefaults();
+            return $metadata;
+        } else {
+            return new ClassMetadata($class->getName());
+        }
+    }
+    private function resetDefaults(): void
+    {
+        $this->metadata       = null;
+        $this->properties     = [];
+        $this->defaultVersion = '1.0';
+        $this->groupPrefix    = '';
+    }
+    /**
+     * Set the root (base key).
+     *
+     * @return $this
+     */
+    public function setRoot($root)
+    {
+        $this->metadata->xmlRootName = $root;
+        return $this;
+    }
+    /**
+     * Set prefix for the List and Details groups.
+     *
+     * @return $this
+     */
+    public function setGroupPrefix($name)
+    {
+        $this->groupPrefix = $name;
+        return $this;
+    }
+    /**
+     * Set the default version for the properties if different than 1.0.
+     *
+     * @return $this
+     */
+    public function setDefaultVersion(string $version)
+    {
+        $this->defaultVersion = $version;
+        return $this;
+    }
+    /**
+     * Create a new property.
+     *
+     * @return $this
+     */
+    public function createProperty($name)
+    {
+        if (!isset($this->properties[$name])) {
+            $this->properties[$name] = new PropertyMetadata($this->metadata->name, $name);
+        }
+        $this->currentPropertyName = $name;
+        return $this;
+    }
+    /**
+     * Add property and set default version and Details group.
+     *
+     * @param bool $useGetter
+     *
+     * @return $this
+     */
+    public function addProperty($name, $serializedName = null, $useGetter = false)
+    {
+        if (empty($name)) {
+            return $this;
+        }
+        $this->createProperty($name);
+        if ($useGetter && !$this->properties[$name]->getter) {
+            $this->properties[$name]->getter = 'get'.ucfirst($name);
+        }
+        $this->properties[$name]->serializedName = $serializedName ?? $name;
+        if ($this->defaultVersion) {
+            $this->setSinceVersion($this->defaultVersion);
+        }
+        $this->addGroup($this->groupPrefix.'Details');
+        return $this;
+    }
+    /**
+     * Create properties.
+     *
+     * @param bool|false $addToListGroup
+     * @param bool|false $useGetter
+     *
+     * @return $this
+     */
+    public function addProperties(array $properties, $addToListGroup = false, $useGetter = false)
+    {
+        foreach ($properties as $prop) {
+            if (!empty($prop)) {
+                $serializedName = null;
+                if (is_array($prop)) {
+                    [$prop, $serializedName] = $prop;
+                }
+                $this->addProperty($prop, $serializedName, $useGetter);
+                if ($addToListGroup) {
+                    $this->inListGroup();
+                }
+            }
+        }
+        return $this;
+    }
+    /**
+     * Create properties and add to the List group.
+     *
+     * @return $this
+     */
+    public function addListProperties(array $properties)
+    {
+        $this->addProperties($properties, true);
+        return $this;
+    }
+    /**
+     * @return $this
+     */
+    public function setSinceVersion($version, $property = null)
+    {
+        if (null === $property) {
+            $property = $this->getCurrentPropertyName();
+        }
+        $this->properties[$property]->sinceVersion = $version;
+        return $this;
+    }
+    /**
+     * @return $this
+     */
+    public function setUntilVersion($version, $property = null)
+    {
+        if (null === $property) {
+            $property = $this->getCurrentPropertyName();
+        }
+        $this->properties[$property]->untilVersion = $version;
+        return $this;
+    }
+    /**
+     * @return $this
+     */
+    public function setSerializedName($name, $property = null)
+    {
+        if (null === $property) {
+            $property = $this->getCurrentPropertyName();
+        }
+        $this->properties[$property]->serializedName = $name;
+        return $this;
+    }
+    /**
+     * Set the groups a property belongs to.
+     *
+     * @return $this
+     */
+    public function setGroups($groups, $property = null)
+    {
+        if (!is_array($groups)) {
+            $groups = [$groups];
+        }
+        if (null === $property) {
+            $property = $this->getCurrentPropertyName();
+        }
+        $this->properties[$property]->groups = $groups;
+        return $this;
+    }
+    /**
+     * Add a group the property belongs to.
+     *
+     * @param mixed $property
+     *
+     * @return $this
+     */
+    public function addGroup($group, $property = null)
+    {
+        if (true === $property) {
+            foreach ($this->properties as $prop => $metadata) {
+                $this->addGroup($group, $prop);
+            }
+        } else {
+            if (null === $property) {
+                $property = $this->getCurrentPropertyName();
+            }
+            $this->properties[$property]->groups[] = $group;
+        }
+        return $this;
+    }
+    /**
+     * Add property to the List group.
+     *
+     * @return $this
+     */
+    public function inListGroup()
+    {
+        $this->properties[$this->currentPropertyName]->groups[] =
+            $this->groupPrefix.'List';
+        return $this;
+    }
+    /**
+     * Set max depth for the property if an association.
+     *
+     * @return $this
+     */
+    public function setMaxDepth($depth, $property = null)
+    {
+        if (null === $property) {
+            $property = $this->getCurrentPropertyName();
+        }
+        $this->properties[$property]->maxDepth = (int) $depth;
+        return $this;
+    }
+    /**
+     * Push the properties into ClassMetadata.
+     */
+    public function build(): void
+    {
+        foreach ($this->properties as $prop) {
+            $this->metadata->addPropertyMetadata($prop);
+        }
+        $this->currentPropertyName = null;
+        $this->properties          = [];
+    }
+    /**
+     * @return string
+     *
+     * @throws \Exception
+     */
+    protected function getCurrentPropertyName()
+    {
+        if (empty($this->currentPropertyName)) {
+            throw new \Exception('Current property is not set');
+        }
+        return $this->currentPropertyName;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Serializer/Exclusion/FieldExclusionStrategy.php
@@ -0,0 +1,45 @@
+<?php
+namespace Mautic\ApiBundle\Serializer\Exclusion;
+use JMS\Serializer\Context;
+use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
+use JMS\Serializer\Metadata\ClassMetadata;
+use JMS\Serializer\Metadata\PropertyMetadata;
+/**
+ * Exclude specific fields at a specific level.
+ */
+class FieldExclusionStrategy implements ExclusionStrategyInterface
+{
+    private int $level;
+    /**
+     * @param int         $level
+     * @param string|null $path
+     */
+    public function __construct(
+        private array $fields,
+        $level = 3,
+        private $path = null,
+    ) {
+        $this->level  = (int) $level;
+    }
+    public function shouldSkipClass(ClassMetadata $metadata, Context $navigatorContext): bool
+    {
+        return false;
+    }
+    public function shouldSkipProperty(PropertyMetadata $property, Context $navigatorContext): bool
+    {
+        if ($this->path) {
+            $path = implode('.', $navigatorContext->getCurrentPath());
+            if ($path !== $this->path) {
+                return false;
+            }
+        }
+        $name = $property->serializedName ?: $property->name;
+        if (!in_array($name, $this->fields)) {
+            return false;
+        }
+        if ($navigatorContext->getDepth() <= $this->level) {
+            return false;
+        }
+        return true;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ApiBundle/Serializer/Exclusion/FieldInclusionStrategy.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\ApiBundle\Serializer\Exclusion;
+use JMS\Serializer\Context;
+use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
+use JMS\Serializer\Metadata\ClassMetadata;
+use JMS\Serializer\Metadata\PropertyMetadata;
+/**
+ * Include specific fields at a specific level.
+ */
+class FieldInclusionStrategy implements ExclusionStrategyInterface
+{
+    private int $level;
+    /**
+     * @param int $level
+     */
+    public function __construct(
+        private array $fields,
+        $level = 3,
+        private $path = null,
+    ) {
+        $this->level  = (int) $level;
+    }
+    public function shouldSkipClass(ClassMetadata $metadata, Context $navigatorContext): bool
+    {
+        return false;
+    }
+    public function shouldSkipProperty(PropertyMetadata $property, Context $navigatorContext): bool
+    {
+        if ($this->path) {
+            $path = implode('.', $navigatorContext->getCurrentPath());
+            if ($path !== $this->path) {
+                return false;
+            }
+        }
+        $name = $property->serializedName ?: $property->name;
+        if (in_array($name, $this->fields)) {
+            return false;
+        }
+        if ($navigatorContext->getDepth() <= $this->level) {
+            return false;
+        }
+        return true;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Config/config.php
@@ -0,0 +1,108 @@
+<?php
+return [
+    'routes' => [
+        'main' => [
+            'mautic_asset_index' => [
+                'path'       => '/assets/{page}',
+                'controller' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+            ],
+            'mautic_asset_remote' => [
+                'path'       => '/assets/remote',
+                'controller' => 'Mautic\AssetBundle\Controller\AssetController::remoteAction',
+            ],
+            'mautic_asset_action' => [
+                'path'       => '/assets/{objectAction}/{objectId}',
+                'controller' => 'Mautic\AssetBundle\Controller\AssetController::executeAction',
+            ],
+        ],
+        'api' => [
+            'mautic_api_assetsstandard' => [
+                'standard_entity' => true,
+                'name'            => 'assets',
+                'path'            => '/assets',
+                'controller'      => Mautic\AssetBundle\Controller\Api\AssetApiController::class,
+            ],
+        ],
+        'public' => [
+            'mautic_asset_download' => [
+                'path'       => '/asset/{slug}',
+                'controller' => 'Mautic\AssetBundle\Controller\PublicController::downloadAction',
+                'defaults'   => [
+                    'slug' => '',
+                ],
+            ],
+        ],
+    ],
+    'menu' => [
+        'main' => [
+            'items' => [
+                'mautic.asset.assets' => [
+                    'route'    => 'mautic_asset_index',
+                    'access'   => ['asset:assets:viewown', 'asset:assets:viewother'],
+                    'parent'   => 'mautic.core.components',
+                    'priority' => 300,
+                ],
+            ],
+        ],
+    ],
+    'categories' => [
+        'asset' => [
+            'class' => Mautic\AssetBundle\Entity\Asset::class,
+        ],
+    ],
+    'services' => [
+        'permissions' => [
+            'mautic.asset.permissions' => [
+                'class'     => Mautic\AssetBundle\Security\Permissions\AssetPermissions::class,
+                'arguments' => [
+                    'mautic.helper.core_parameters',
+                ],
+            ],
+        ],
+        'others' => [
+            'mautic.asset.upload.error.handler' => [
+                'class'     => Mautic\AssetBundle\ErrorHandler\DropzoneErrorHandler::class,
+            ],
+            'oneup_uploader.controller.dropzone.class' => [
+                'class'     => Mautic\AssetBundle\Controller\UploadController::class,
+            ],
+        ],
+        'fixtures' => [
+            'mautic.asset.fixture.asset' => [
+                'class'     => Mautic\AssetBundle\DataFixtures\ORM\LoadAssetData::class,
+                'tag'       => Doctrine\Bundle\FixturesBundle\DependencyInjection\CompilerPass\FixturesCompilerPass::FIXTURE_TAG,
+            ],
+        ],
+    ],
+    'parameters' => [
+        'upload_dir'          => '%mautic.application_dir%/media/files',
+        'max_size'            => '6',
+        'allowed_extensions'  => ['csv', 'doc', 'docx', 'epub', 'gif', 'jpg', 'jpeg', 'mpg', 'mpeg', 'mp3', 'odt', 'odp', 'ods', 'pdf', 'png', 'ppt', 'pptx', 'tif', 'tiff', 'txt', 'xls', 'xlsx', 'wav'],
+        'streamed_extensions' => ['gif', 'jpg', 'jpeg', 'mpg', 'mpeg', 'mp3', 'pdf', 'png', 'wav'],
+        'allowed_mimetypes'   => [
+            'csv'  => 'text/csv',
+            'doc'  => 'application/msword',
+            'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+            'epub' => 'application/epub+zip',
+            'gif'  => 'image/gif',
+            'jpg'  => 'image/jpeg',
+            'jpeg' => 'image/jpeg',
+            'mpg'  => 'video/mpeg',
+            'mpeg' => 'video/mpeg',
+            'mp3'  => 'audio/mpeg',
+            'odt'  => 'application/vnd.oasis.opendocument.text',
+            'odp'  => 'application/vnd.oasis.opendocument.presentation',
+            'ods'  => 'application/vnd.oasis.opendocument.spreadsheet',
+            'pdf'  => 'application/pdf',
+            'png'  => 'image/png',
+            'ppt'  => 'application/vnd.ms-powerpoint',
+            'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
+            'tif'  => 'image/tiff',
+            'tiff' => 'image/tiff',
+            'txt'  => 'text/plain',
+            'xls'  => 'application/vnd.ms-excel',
+            'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
+            'wav'  => 'audio/wav',
+        ],
+    ],
+];

--- a//dev/null
+++ b/app/bundles/AssetBundle/Controller/AjaxController.php
@@ -0,0 +1,58 @@
+<?php
+namespace Mautic\AssetBundle\Controller;
+use Gaufrette\Filesystem;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Event\RemoteAssetBrowseEvent;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\PluginBundle\Helper\IntegrationHelper;
+use Symfony\Component\HttpFoundation\Request;
+class AjaxController extends CommonAjaxController
+{
+    public function categoryListAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
+    {
+        $assetModel = $this->getModel('asset');
+        \assert($assetModel instanceof AssetModel);
+        $filter     = InputHelper::clean($request->query->get('filter'));
+        $results    = $assetModel->getLookupResults('category', $filter, 10);
+        $dataArray  = [];
+        foreach ($results as $r) {
+            $dataArray[] = [
+                'label' => $r['title']." ({$r['id']})",
+                'value' => $r['id'],
+            ];
+        }
+        return $this->sendJsonResponse($dataArray);
+    }
+    /**
+     * @throws \Exception
+     */
+    public function fetchRemoteFilesAction(Request $request, IntegrationHelper $integrationHelper): \Symfony\Component\HttpFoundation\JsonResponse
+    {
+        $provider   = InputHelper::string($request->request->get('provider'));
+        $path       = InputHelper::string($request->request->get('path', ''));
+        $dispatcher = $this->dispatcher;
+        $name       = AssetEvents::ASSET_ON_REMOTE_BROWSE;
+        if (!$dispatcher->hasListeners($name)) {
+            return $this->sendJsonResponse(['success' => 0]);
+        }
+        /** @var \Mautic\PluginBundle\Integration\AbstractIntegration $integration */
+        $integration = $integrationHelper->getIntegrationObject($provider);
+        $event = new RemoteAssetBrowseEvent($integration);
+        $dispatcher->dispatch($event, $name);
+        if (!$adapter = $event->getAdapter()) {
+            return $this->sendJsonResponse(['success' => 0]);
+        }
+        $connector = new Filesystem($adapter);
+        $output = $this->renderView(
+            '@MauticAsset/Remote/list.html.twig',
+            [
+                'connector'   => $connector,
+                'integration' => $integration,
+                'items'       => $connector->listKeys($path),
+            ]
+        );
+        return $this->sendJsonResponse(['success' => 1, 'output' => $output]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Controller/Api/AssetApiController.php
@@ -0,0 +1,90 @@
+<?php
+namespace Mautic\AssetBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Controller\CommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\AssetBundle\Entity\Asset;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Routing\RouterInterface;
+/**
+ * @extends CommonApiController<Asset>
+ */
+class AssetApiController extends CommonApiController
+{
+    /**
+     * @var AssetModel|null
+     */
+    protected $model;
+    public function __construct(
+        CorePermissions $security,
+        Translator $translator,
+        EntityResultHelper $entityResultHelper,
+        RouterInterface $router,
+        FormFactoryInterface $formFactory,
+        AppVersion $appVersion,
+        RequestStack $requestStack,
+        private CoreParametersHelper $parametersHelper,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        EventDispatcherInterface $dispatcher,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        $assetModel = $modelFactory->getModel('asset');
+        \assert($assetModel instanceof AssetModel);
+        $this->model            = $assetModel;
+        $this->entityClass      = Asset::class;
+        $this->entityNameOne    = 'asset';
+        $this->entityNameMulti  = 'assets';
+        $this->serializerGroups = ['assetDetails', 'categoryList', 'publishDetails'];
+        parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * Gives child controllers opportunity to analyze and do whatever to an entity before going through serializer.
+     */
+    protected function preSerializeEntity(object $entity, string $action = 'view'): void
+    {
+        $entity->setDownloadUrl(
+            $this->model->generateUrl($entity, true)
+        );
+    }
+    /**
+     * Convert posted parameters into what the form needs in order to successfully bind.
+     *
+     * @return mixed
+     */
+    protected function prepareParametersForBinding(Request $request, $parameters, $entity, $action)
+    {
+        $assetDir = $this->parametersHelper->get('upload_dir');
+        $entity->setUploadDir($assetDir);
+        if (isset($parameters['file'])) {
+            if ('local' === $parameters['storageLocation']) {
+                $entity->setPath($parameters['file']);
+                $entity->setFileInfoFromFile();
+                if (null === $entity->loadFile()) {
+                    return $this->returnError('File '.$parameters['file'].' was not found in the asset directory.', Response::HTTP_BAD_REQUEST);
+                }
+            } elseif ('remote' === $parameters['storageLocation']) {
+                $parameters['remotePath'] = $parameters['file'];
+                $entity->setTitle($parameters['title']);
+                $entity->setStorageLocation('remote');
+                $entity->setRemotePath($parameters['remotePath']);
+                $entity->preUpload();
+                $entity->upload();
+            }
+            unset($parameters['file']);
+        } elseif ('new' === $action) {
+            return $this->returnError('File of the asset is required.', Response::HTTP_BAD_REQUEST);
+        }
+        return $parameters;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Controller/AssetController.php
@@ -0,0 +1,624 @@
+<?php
+namespace Mautic\AssetBundle\Controller;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Controller\FormController;
+use Mautic\CoreBundle\Form\Type\DateRangeType;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\FileHelper;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Mautic\PluginBundle\Helper\IntegrationHelper;
+use Oneup\UploaderBundle\Templating\Helper\UploaderHelper;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+class AssetController extends FormController
+{
+    /**
+     * @return JsonResponse|Response
+     */
+    public function indexAction(Request $request, CoreParametersHelper $parametersHelper, AssetModel $assetModel, int $page = 1)
+    {
+        $permissions = $this->security->isGranted([
+            'asset:assets:viewown',
+            'asset:assets:viewother',
+            'asset:assets:create',
+            'asset:assets:editown',
+            'asset:assets:editother',
+            'asset:assets:deleteown',
+            'asset:assets:deleteother',
+            'asset:assets:publishown',
+            'asset:assets:publishother',
+        ], 'RETURN_ARRAY');
+        if (!$permissions['asset:assets:viewown'] && !$permissions['asset:assets:viewother']) {
+            return $this->accessDenied();
+        }
+        $this->setListFilters();
+        $limit = $request->getSession()->get('mautic.asset.limit', $parametersHelper->get('default_assetlimit'));
+        $start = (1 === $page) ? 0 : (($page - 1) * $limit);
+        if ($start < 0) {
+            $start = 0;
+        }
+        $search = $request->get('search', $request->getSession()->get('mautic.asset.filter', ''));
+        $request->getSession()->set('mautic.asset.filter', $search);
+        $filter = ['string' => $search, 'force' => []];
+        if (!$permissions['asset:assets:viewother']) {
+            $filter['force'][] =
+                ['column' => 'a.createdBy', 'expr' => 'eq', 'value' => $this->user->getId()];
+        }
+        $orderBy    = $request->getSession()->get('mautic.asset.orderby', 'a.dateModified');
+        $orderByDir = $request->getSession()->get('mautic.asset.orderbydir', $this->getDefaultOrderDirection());
+        $assets = $assetModel->getEntities(
+            [
+                'start'      => $start,
+                'limit'      => $limit,
+                'filter'     => $filter,
+                'orderBy'    => $orderBy,
+                'orderByDir' => $orderByDir,
+            ]
+        );
+        $count = count($assets);
+        if ($count && $count < ($start + 1)) {
+            if (1 === $count) {
+                $lastPage = 1;
+            } else {
+                $lastPage = (ceil($count / $limit)) ?: 1;
+            }
+            $request->getSession()->set('mautic.asset.asset', $lastPage);
+            $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $lastPage]);
+            return $this->postActionRedirect([
+                'returnUrl'       => $returnUrl,
+                'viewParameters'  => ['asset' => $lastPage],
+                'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_asset_index',
+                    'mauticContent' => 'asset',
+                ],
+            ]);
+        }
+        $request->getSession()->set('mautic.asset.page', $page);
+        $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
+        $categories = $assetModel->getLookupResults('category', '', 0);
+        return $this->delegateView([
+            'viewParameters' => [
+                'searchValue' => $search,
+                'items'       => $assets,
+                'categories'  => $categories,
+                'limit'       => $limit,
+                'permissions' => $permissions,
+                'model'       => $assetModel,
+                'tmpl'        => $tmpl,
+                'page'        => $page,
+                'security'    => $this->security,
+            ],
+            'contentTemplate' => '@MauticAsset/Asset/list.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_asset_index',
+                'mauticContent' => 'asset',
+                'route'         => $this->generateUrl('mautic_asset_index', ['page' => $page]),
+            ],
+        ]);
+    }
+    /**
+     * Loads a specific form into the detailed panel.
+     *
+     * @param int $objectId
+     *
+     * @return JsonResponse|Response
+     */
+    public function viewAction(Request $request, AssetModel $model, $objectId)
+    {
+        $activeAsset = $model->getEntity($objectId);
+        $page = $request->getSession()->get('mautic.asset.page', 1);
+        $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'details') : 'details';
+        $dateRangeValues = $request->get('daterange', []);
+        $action          = $this->generateUrl('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $objectId]);
+        $dateRangeForm   = $this->formFactory->create(DateRangeType::class, $dateRangeValues, ['action' => $action]);
+        if (null === $activeAsset) {
+            $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
+            return $this->postActionRedirect([
+                'returnUrl'       => $returnUrl,
+                'viewParameters'  => ['page' => $page],
+                'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_asset_index',
+                    'mauticContent' => 'asset',
+                ],
+                'flashes' => [
+                    [
+                        'type'    => 'error',
+                        'msg'     => 'mautic.asset.asset.error.notfound',
+                        'msgVars' => ['%id%' => $objectId],
+                    ],
+                ],
+            ]);
+        } elseif (!$this->security->hasEntityAccess('asset:assets:viewown', 'asset:assets:viewother', $activeAsset->getCreatedBy())) {
+            return $this->accessDenied();
+        }
+        $auditLogModel = $this->getModel('core.auditlog');
+        \assert($auditLogModel instanceof AuditLogModel);
+        $logs          = $auditLogModel->getLogForObject('asset', $activeAsset->getId(), $activeAsset->getDateAdded());
+        return $this->delegateView([
+            'returnUrl'      => $action,
+            'viewParameters' => [
+                'activeAsset' => $activeAsset,
+                'tmpl'        => $tmpl,
+                'permissions' => $this->security->isGranted([
+                    'asset:assets:viewown',
+                    'asset:assets:viewother',
+                    'asset:assets:create',
+                    'asset:assets:editown',
+                    'asset:assets:editother',
+                    'asset:assets:deleteown',
+                    'asset:assets:deleteother',
+                    'asset:assets:publishown',
+                    'asset:assets:publishother',
+                ], 'RETURN_ARRAY'),
+                'stats' => [
+                    'downloads' => [
+                        'total'     => $activeAsset->getDownloadCount(),
+                        'unique'    => $activeAsset->getUniqueDownloadCount(),
+                        'timeStats' => $model->getDownloadsLineChartData(
+                            null,
+                            new \DateTime($dateRangeForm->get('date_from')->getData()),
+                            new \DateTime($dateRangeForm->get('date_to')->getData()),
+                            null,
+                            ['asset_id' => $activeAsset->getId()]
+                        ),
+                    ],
+                ],
+                'security'         => $this->security,
+                'assetDownloadUrl' => $model->generateUrl($activeAsset, true),
+                'logs'             => $logs,
+                'dateRangeForm'    => $dateRangeForm->createView(),
+            ],
+            'contentTemplate' => '@MauticAsset/Asset/'.$tmpl.'.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_asset_index',
+                'mauticContent' => 'asset',
+            ],
+        ]);
+    }
+    /**
+     * Show a preview of the file.
+     *
+     * @param int $objectId
+     *
+     * @return JsonResponse|Response
+     */
+    public function previewAction(Request $request, AssetModel $model, $objectId)
+    {
+        $activeAsset = $model->getEntity($objectId);
+        if (null === $activeAsset || !$this->security->hasEntityAccess('asset:assets:viewown', 'asset:assets:viewother', $activeAsset->getCreatedBy())) {
+            return $this->modalAccessDenied();
+        }
+        $download = $request->query->get('download', 0);
+        $defaultStream = in_array($activeAsset->getExtension(), $this->coreParametersHelper->get('streamed_extensions')) ? '1' : null;
+        $stream        = $request->query->get('stream', $defaultStream);
+        if ('1' === $download || '1' === $stream) {
+            try {
+                $activeAsset->setUploadDir($this->coreParametersHelper->get('upload_dir'));
+                $contents = $activeAsset->getFileContents();
+            } catch (\Exception) {
+                return $this->notFound();
+            }
+            $response = new Response();
+            $response->headers->set('Content-Type', $activeAsset->getFileMimeType());
+            if ('1' === $download) {
+                $response->headers->set('Content-Disposition', 'attachment;filename="'.$activeAsset->getOriginalFileName());
+            }
+            $response->setContent($contents);
+            return $response;
+        }
+        return $this->delegateView([
+            'viewParameters' => [
+                'activeAsset'      => $activeAsset,
+                'assetDownloadUrl' => $model->generateUrl($activeAsset),
+            ],
+            'contentTemplate' => '@MauticAsset/Asset/preview.html.twig',
+            'passthroughVars' => [
+                'route' => false,
+            ],
+        ]);
+    }
+    /**
+     * Generates new form and processes post data.
+     *
+     * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function newAction(Request $request, CoreParametersHelper $parametersHelper, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $entity = null)
+    {
+        if (null == $entity) {
+            $entity = $model->getEntity();
+        }
+        $entity->setMaxSize(FileHelper::convertMegabytesToBytes($this->coreParametersHelper->get('max_size')));
+        $method  = $request->getMethod();
+        $session = $request->getSession();
+        if (!$this->security->isGranted('asset:assets:create')) {
+            return $this->accessDenied();
+        }
+        $maxSize    = $model->getMaxUploadSize();
+        $extensions = '.'.implode(', .', $this->coreParametersHelper->get('allowed_extensions'));
+        $maxSizeError = $this->translator->trans('mautic.asset.asset.error.file.size', [
+            '%fileSize%' => '{{filesize}}',
+            '%maxSize%'  => '{{maxFilesize}}',
+        ], 'validators');
+        $extensionError = $this->translator->trans('mautic.asset.asset.error.file.extension.js', [
+            '%extensions%' => $extensions,
+        ], 'validators');
+        $asset  = $request->request->all()['asset'] ?? [];
+        $tempId = 'POST' === $method ? ($asset['tempId'] ?? '') : uniqid('tmp_');
+        $entity->setTempId($tempId);
+        $page   = $session->get('mautic.asset.page', 1);
+        $action = $this->generateUrl('mautic_asset_action', ['objectAction' => 'new']);
+        $uploadEndpoint = $uploaderHelper->endpoint('asset');
+        $form = $model->createForm($entity, $this->formFactory, $action);
+        if ('POST' == $method) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $entity->setUploadDir($parametersHelper->get('upload_dir'));
+                    $entity->preUpload();
+                    $entity->upload();
+                    $entity->setDateModified(new \DateTime());
+                    $model->saveEntity($entity);
+                    $request->files->remove('asset');
+                    $this->addFlashMessage('mautic.core.notice.created', [
+                        '%name%'      => $entity->getTitle(),
+                        '%menu_link%' => 'mautic_asset_index',
+                        '%url%'       => $this->generateUrl('mautic_asset_action', [
+                            'objectAction' => 'edit',
+                            'objectId'     => $entity->getId(),
+                        ]),
+                    ]);
+                    if (!$this->getFormButton($form, ['buttons', 'save'])->isClicked()) {
+                        return $this->editAction($request, $uploaderHelper, $integrationHelper, $model, $entity->getId(), true);
+                    }
+                    $viewParameters = [
+                        'objectAction' => 'view',
+                        'objectId'     => $entity->getId(),
+                    ];
+                    $returnUrl = $this->generateUrl('mautic_asset_action', $viewParameters);
+                    $template  = 'Mautic\AssetBundle\Controller\AssetController::viewAction';
+                }
+            } else {
+                $viewParameters = ['page' => $page];
+                $returnUrl      = $this->generateUrl('mautic_asset_index', $viewParameters);
+                $template       = 'Mautic\AssetBundle\Controller\AssetController::indexAction';
+            }
+            if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
+                return $this->postActionRedirect([
+                    'returnUrl'       => $returnUrl,
+                    'viewParameters'  => $viewParameters,
+                    'contentTemplate' => $template,
+                    'passthroughVars' => [
+                        'activeLink'    => 'mautic_asset_index',
+                        'mauticContent' => 'asset',
+                    ],
+                ]);
+            }
+        }
+        $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
+        return $this->delegateView([
+            'viewParameters' => [
+                'form'             => $form->createView(),
+                'activeAsset'      => $entity,
+                'assetDownloadUrl' => $model->generateUrl($entity),
+                'integrations'     => $integrations,
+                'startOnLocal'     => $entity->isLocal(),
+                'uploadEndpoint'   => $uploadEndpoint,
+                'maxSize'          => $maxSize,
+                'maxSizeError'     => $maxSizeError,
+                'extensions'       => $extensions,
+                'extensionError'   => $extensionError,
+            ],
+            'contentTemplate' => '@MauticAsset/Asset/form.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_asset_index',
+                'mauticContent' => 'asset',
+                'route'         => $this->generateUrl('mautic_asset_action', [
+                    'objectAction' => 'new',
+                ]),
+            ],
+        ]);
+    }
+    /**
+     * Generates edit form and processes post data.
+     *
+     * @param int  $objectId
+     * @param bool $ignorePost
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function editAction(Request $request, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $objectId, $ignorePost = false)
+    {
+        $entity = $model->getEntity($objectId);
+        if (!$this->security->hasEntityAccess('asset:assets:editown', 'asset:assets:editother', $entity->getCreatedBy())) {
+            return $this->accessDenied();
+        }
+        $entity->setMaxSize(FileHelper::convertMegabytesToBytes($this->coreParametersHelper->get('max_size')));
+        $session    = $request->getSession();
+        $page       = $session->get('mautic.asset.page', 1);
+        $method     = $request->getMethod();
+        $maxSize    = $model->getMaxUploadSize();
+        $extensions = '.'.implode(', .', $this->coreParametersHelper->get('allowed_extensions'));
+        $maxSizeError = $this->translator->trans('mautic.asset.asset.error.file.size', [
+            '%fileSize%' => '{{filesize}}',
+            '%maxSize%'  => '{{maxFilesize}}',
+        ], 'validators');
+        $extensionError = $this->translator->trans('mautic.asset.asset.error.file.extension.js', [
+            '%extensions%' => $extensions,
+        ], 'validators');
+        $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
+        $uploadEndpoint = $uploaderHelper->endpoint('asset');
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'viewParameters'  => ['page' => $page],
+            'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => 'mautic_asset_index',
+                'mauticContent' => 'asset',
+            ],
+        ];
+        if (null === $entity) {
+            return $this->postActionRedirect(
+                array_merge($postActionVars, [
+                    'flashes' => [
+                        [
+                            'type'    => 'error',
+                            'msg'     => 'mautic.asset.asset.error.notfound',
+                            'msgVars' => ['%id%' => $objectId],
+                        ],
+                    ],
+                ])
+            );
+        } elseif (!$this->security->hasEntityAccess(
+            'asset:assets:viewown', 'asset:assets:viewother', $entity->getCreatedBy()
+        )
+        ) {
+            return $this->accessDenied();
+        } elseif ($model->isLocked($entity)) {
+            return $this->isLocked($postActionVars, $entity, 'asset.asset');
+        }
+        $asset  = $request->request->all()['asset'] ?? [];
+        $tempId = 'POST' === $method ? ($asset['tempId'] ?? '') : uniqid('tmp_');
+        $entity->setTempId($tempId);
+        $action = $this->generateUrl('mautic_asset_action', ['objectAction' => 'edit', 'objectId' => $objectId]);
+        $form   = $model->createForm($entity, $this->formFactory, $action);
+        if (!$ignorePost && 'POST' == $method) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $entity->setUploadDir($this->coreParametersHelper->get('upload_dir'));
+                    $entity->preUpload();
+                    $entity->upload();
+                    $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
+                    $request->files->remove('asset');
+                    $this->addFlashMessage('mautic.core.notice.updated', [
+                        '%name%'      => $entity->getTitle(),
+                        '%menu_link%' => 'mautic_asset_index',
+                        '%url%'       => $this->generateUrl('mautic_asset_action', [
+                            'objectAction' => 'edit',
+                            'objectId'     => $entity->getId(),
+                        ]),
+                    ]);
+                    $returnUrl = $this->generateUrl('mautic_asset_action', [
+                        'objectAction' => 'view',
+                        'objectId'     => $entity->getId(),
+                    ]);
+                    $viewParams = ['objectId' => $entity->getId()];
+                    $template   = 'Mautic\AssetBundle\Controller\AssetController::viewAction';
+                }
+            } else {
+                $session->remove('mautic.asestbuilder.'.$objectId.'.content');
+                $model->unlockEntity($entity);
+                $returnUrl  = $this->generateUrl('mautic_asset_index', ['page' => $page]);
+                $viewParams = ['page' => $page];
+                $template   = 'Mautic\AssetBundle\Controller\AssetController::indexAction';
+            }
+            if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
+                return $this->postActionRedirect(
+                    array_merge($postActionVars, [
+                        'returnUrl'       => $returnUrl,
+                        'viewParameters'  => $viewParams,
+                        'contentTemplate' => $template,
+                    ])
+                );
+            }
+        } else {
+            $model->lockEntity($entity);
+        }
+        $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
+        return $this->delegateView([
+            'viewParameters' => [
+                'form'             => $form->createView(),
+                'activeAsset'      => $entity,
+                'assetDownloadUrl' => $model->generateUrl($entity),
+                'integrations'     => $integrations,
+                'startOnLocal'     => $entity->isLocal(),
+                'uploadEndpoint'   => $uploadEndpoint,
+                'maxSize'          => $maxSize,
+                'maxSizeError'     => $maxSizeError,
+                'extensions'       => $extensions,
+                'extensionError'   => $extensionError,
+            ],
+            'contentTemplate' => '@MauticAsset/Asset/form.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_asset_index',
+                'mauticContent' => 'asset',
+                'route'         => $this->generateUrl('mautic_asset_action', [
+                    'objectAction' => 'edit',
+                    'objectId'     => $entity->getId(),
+                ]),
+            ],
+        ]);
+    }
+    /**
+     * Clone an entity.
+     *
+     * @param int $objectId
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function cloneAction(Request $request, CoreParametersHelper $parametersHelper, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $objectId)
+    {
+        $entity = $model->getEntity($objectId);
+        $clone  = null;
+        if (null != $entity) {
+            if (!$this->security->isGranted('asset:assets:create')
+                || !$this->security->hasEntityAccess(
+                    'asset:assets:viewown', 'asset:assets:viewother', $entity->getCreatedBy()
+                )
+            ) {
+                return $this->accessDenied();
+            }
+            $clone = clone $entity;
+            $clone->setDownloadCount(0);
+            $clone->setUniqueDownloadCount(0);
+            $clone->setRevision(0);
+            $clone->setIsPublished(false);
+        }
+        return $this->newAction($request, $parametersHelper, $uploaderHelper, $integrationHelper, $model, $clone);
+    }
+    /**
+     * Deletes the entity.
+     *
+     * @param int $objectId
+     *
+     * @return Response
+     */
+    public function deleteAction(Request $request, AssetModel $model, $objectId)
+    {
+        $page      = $request->getSession()->get('mautic.asset.page', 1);
+        $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
+        $flashes   = [];
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'viewParameters'  => ['page' => $page],
+            'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => 'mautic_asset_index',
+                'mauticContent' => 'asset',
+            ],
+        ];
+        if ('POST' === $request->getMethod()) {
+            $entity = $model->getEntity($objectId);
+            if (null === $entity) {
+                $flashes[] = [
+                    'type'    => 'error',
+                    'msg'     => 'mautic.asset.asset.error.notfound',
+                    'msgVars' => ['%id%' => $objectId],
+                ];
+            } elseif (!$this->security->hasEntityAccess(
+                'asset:assets:deleteown',
+                'asset:assets:deleteother',
+                $entity->getCreatedBy()
+            )
+            ) {
+                return $this->accessDenied();
+            } elseif ($model->isLocked($entity)) {
+                return $this->isLocked($postActionVars, $entity, 'asset.asset');
+            }
+            $entity->removeUpload();
+            $model->deleteEntity($entity);
+            $flashes[] = [
+                'type'    => 'notice',
+                'msg'     => 'mautic.core.notice.deleted',
+                'msgVars' => [
+                    '%name%' => $entity->getTitle(),
+                    '%id%'   => $objectId,
+                ],
+            ];
+        } // else don't do anything
+        return $this->postActionRedirect(
+            array_merge($postActionVars, [
+                'flashes' => $flashes,
+            ])
+        );
+    }
+    /**
+     * Deletes a group of entities.
+     */
+    public function batchDeleteAction(Request $request, AssetModel $model): Response
+    {
+        $page      = $request->getSession()->get('mautic.asset.page', 1);
+        $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
+        $flashes   = [];
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'viewParameters'  => ['page' => $page],
+            'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => 'mautic_asset_index',
+                'mauticContent' => 'asset',
+            ],
+        ];
+        if ('POST' === $request->getMethod()) {
+            $ids       = json_decode($request->query->get('ids', '{}'));
+            $deleteIds = [];
+            foreach ($ids as $objectId) {
+                $entity = $model->getEntity($objectId);
+                if (null === $entity) {
+                    $flashes[] = [
+                        'type'    => 'error',
+                        'msg'     => 'mautic.asset.asset.error.notfound',
+                        'msgVars' => ['%id%' => $objectId],
+                    ];
+                } elseif (!$this->security->hasEntityAccess(
+                    'asset:assets:deleteown', 'asset:assets:deleteother', $entity->getCreatedBy()
+                )
+                ) {
+                    $flashes[] = $this->accessDenied(true);
+                } elseif ($model->isLocked($entity)) {
+                    $flashes[] = $this->isLocked($postActionVars, $entity, 'asset', true);
+                } else {
+                    $deleteIds[] = $objectId;
+                }
+            }
+            if (!empty($deleteIds)) {
+                $entities = $model->deleteEntities($deleteIds);
+                $flashes[] = [
+                    'type'    => 'notice',
+                    'msg'     => 'mautic.asset.asset.notice.batch_deleted',
+                    'msgVars' => [
+                        '%count%' => count($entities),
+                    ],
+                ];
+            }
+        } // else don't do anything
+        return $this->postActionRedirect(
+            array_merge($postActionVars, [
+                'flashes' => $flashes,
+            ])
+        );
+    }
+    /**
+     * Renders the container for the remote file browser.
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function remoteAction(Request $request, IntegrationHelper $integrationHelper): Response
+    {
+        $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
+        $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
+        return $this->delegateView([
+            'viewParameters' => [
+                'integrations' => $integrations,
+                'tmpl'         => $tmpl,
+            ],
+            'contentTemplate' => '@MauticAsset/Remote/browse.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_asset_index',
+                'mauticContent' => 'asset',
+                'route'         => $this->generateUrl('mautic_asset_index', ['page' => $request->getSession()->get('mautic.asset.page', 1)]),
+            ],
+        ]);
+    }
+    public function getModelName(): string
+    {
+        return 'asset';
+    }
+    protected function getDefaultOrderDirection(): string
+    {
+        return 'DESC';
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Entity/Asset.php
@@ -0,0 +1,1235 @@
+<?php
+namespace Mautic\AssetBundle\Entity;
+use ApiPlatform\Core\Annotation\ApiResource;
+use Doctrine\DBAL\Types\Types;
+use Doctrine\ORM\Mapping as ORM;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\FormEntity;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Mautic\CoreBundle\Helper\FileHelper;
+use Mautic\CoreBundle\Loader\ParameterLoader;
+use Symfony\Component\Filesystem\Filesystem;
+use Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException;
+use Symfony\Component\HttpFoundation\File\File;
+use Symfony\Component\HttpFoundation\File\UploadedFile;
+use Symfony\Component\Serializer\Annotation\Groups;
+use Symfony\Component\Validator\Constraints as Assert;
+use Symfony\Component\Validator\Context\ExecutionContextInterface;
+use Symfony\Component\Validator\Mapping\ClassMetadata;
+/**
+ * @ApiResource(
+ *   attributes={
+ *     "security"="false",
+ *     "normalization_context"={
+ *       "groups"={
+ *         "asset:read"
+ *        },
+ *       "swagger_definition_name"="Read",
+ *       "api_included"={"category"}
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "asset:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Asset extends FormEntity implements UuidInterface
+{
+    use UuidTrait;
+    /**
+     * @var int|null
+     *
+     * @Groups({"asset:read", "download:read", "email:read"})
+     */
+    private $id;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $title;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $description;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $storageLocation = 'local';
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $path;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $remotePath;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $originalFileName;
+    /**
+     * @var File
+     */
+    private $file;
+    /**
+     * Holds upload directory.
+     */
+    private $uploadDir;
+    /**
+     * Holds max size of uploaded file.
+     */
+    private $maxSize;
+    /**
+     * Temporary location when asset file is beeing updated.
+     * We need to keep the old file till we are sure the new
+     * one is stored correctly.
+     */
+    private $temp;
+    /**
+     * Temporary ID used for file upload and validations
+     * before the actual ID is known.
+     */
+    private $tempId;
+    /**
+     * Temporary file name used for file upload and validations
+     * before the actual ID is known.
+     */
+    private $tempName;
+    /**
+     * @var string
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $alias;
+    /**
+     * @var string
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $language = 'en';
+    /**
+     * @var \DateTimeInterface|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $publishUp;
+    /**
+     * @var \DateTimeInterface|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $publishDown;
+    /**
+     * @var int
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $downloadCount = 0;
+    /**
+     * @var int
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $uniqueDownloadCount = 0;
+    /**
+     * @var int
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $revision = 1;
+    /**
+     * @var \Mautic\CategoryBundle\Entity\Category|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     **/
+    private $category;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $extension;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $mime;
+    /**
+     * @var int|null
+     */
+    private $size;
+    /**
+     * @var string|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $downloadUrl;
+    /**
+     * @var bool|null
+     *
+     * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
+     */
+    private $disallow = true;
+    public static function loadMetadata(ORM\ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable('assets')
+            ->setCustomRepositoryClass(AssetRepository::class)
+            ->addIndex(['alias'], 'asset_alias_search');
+        $builder->addIdColumns('title');
+        $builder->addField('alias', 'string');
+        $builder->createField('storageLocation', 'string')
+            ->columnName('storage_location')
+            ->nullable()
+            ->build();
+        $builder->createField('path', 'string')
+            ->nullable()
+            ->build();
+        $builder->createField('remotePath', Types::TEXT)
+            ->columnName('remote_path')
+            ->nullable()
+            ->build();
+        $builder->createField('originalFileName', Types::TEXT)
+            ->columnName('original_file_name')
+            ->nullable()
+            ->build();
+        $builder->createField('language', 'string')
+            ->columnName('lang')
+            ->build();
+        $builder->addPublishDates();
+        $builder->createField('downloadCount', 'integer')
+            ->columnName('download_count')
+            ->build();
+        $builder->createField('uniqueDownloadCount', 'integer')
+            ->columnName('unique_download_count')
+            ->build();
+        $builder->addField('revision', 'integer');
+        $builder->addCategory();
+        $builder->createField('extension', 'string')
+            ->nullable()
+            ->build();
+        $builder->createField('mime', 'string')
+            ->nullable()
+            ->build();
+        $builder->createField('size', 'integer')
+            ->nullable()
+            ->build();
+        $builder->createField('disallow', 'boolean')
+            ->nullable()
+            ->build();
+        static::addUuidField($builder);
+    }
+    /**
+     * Prepares the metadata for API usage.
+     */
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('asset')
+            ->addListProperties(
+                [
+                    'id',
+                    'title',
+                    'alias',
+                    'category',
+                    'description',
+                ]
+            )
+            ->addProperties(
+                [
+                    'language',
+                    'publishUp',
+                    'publishDown',
+                    'downloadCount',
+                    'uniqueDownloadCount',
+                    'revision',
+                    'extension',
+                    'mime',
+                    'size',
+                    'downloadUrl',
+                    'storageLocation',
+                    'disallow',
+                ]
+            )
+            ->build();
+    }
+    /**
+     * Clone magic function.
+     */
+    public function __clone()
+    {
+        $this->id = null;
+        parent::__clone();
+    }
+    /**
+     * Get id.
+     *
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * Sets file.
+     */
+    public function setFile(File $file = null): void
+    {
+        $this->file = $file;
+        if (isset($this->path)) {
+            $this->temp = $this->path;
+            $this->path = null;
+        }
+    }
+    /**
+     * Get file.
+     *
+     * @return UploadedFile
+     */
+    public function getFile()
+    {
+        if ($this->isLocal() && empty($this->file)) {
+            $tempFile = $this->loadFile(true);
+            if ($tempFile) {
+                $this->setFile($tempFile);
+            }
+        }
+        return $this->file;
+    }
+    /**
+     * Set title.
+     *
+     * @param string $title
+     *
+     * @return Asset
+     */
+    public function setTitle($title)
+    {
+        $this->isChanged('title', $title);
+        $this->title = $title;
+        return $this;
+    }
+    /**
+     * Get title.
+     *
+     * @return string
+     */
+    public function getTitle()
+    {
+        return $this->title;
+    }
+    /**
+     * @return mixed
+     */
+    public function getExtension()
+    {
+        return $this->extension;
+    }
+    /**
+     * @param mixed $extension
+     */
+    public function setExtension($extension): void
+    {
+        $this->extension = $extension;
+    }
+    /**
+     * @return mixed
+     */
+    public function getMime()
+    {
+        return $this->mime;
+    }
+    /**
+     * @param mixed $mime
+     */
+    public function setMime($mime): void
+    {
+        $this->mime = $mime;
+    }
+    /**
+     * Set originalFileName.
+     *
+     * @param string $originalFileName
+     *
+     * @return Asset
+     */
+    public function setOriginalFileName($originalFileName)
+    {
+        $this->isChanged('originalFileName', $originalFileName);
+        $this->originalFileName = $originalFileName;
+        return $this;
+    }
+    /**
+     * Get originalFileName.
+     *
+     * @return string
+     */
+    public function getOriginalFileName()
+    {
+        return $this->originalFileName;
+    }
+    /**
+     * Set storage location.
+     *
+     * @param string $storageLocation
+     *
+     * @return Asset
+     */
+    public function setStorageLocation($storageLocation)
+    {
+        $this->isChanged('storageLocation', $storageLocation);
+        $this->storageLocation = $storageLocation;
+        return $this;
+    }
+    /**
+     * Get storage location.
+     *
+     * @return string
+     */
+    public function getStorageLocation()
+    {
+        if (null === $this->storageLocation) {
+            $this->storageLocation = 'local';
+        }
+        return $this->storageLocation;
+    }
+    /**
+     * Set path.
+     *
+     * @param string $path
+     *
+     * @return Asset
+     */
+    public function setPath($path)
+    {
+        $this->isChanged('path', $path);
+        $this->path = $path;
+        return $this;
+    }
+    /**
+     * Get path.
+     *
+     * @return string
+     */
+    public function getPath()
+    {
+        return $this->path;
+    }
+    /**
+     * Set remote path.
+     *
+     * @param string $remotePath
+     *
+     * @return Asset
+     */
+    public function setRemotePath($remotePath)
+    {
+        $this->isChanged('remotePath', $remotePath);
+        $this->remotePath = $remotePath;
+        return $this;
+    }
+    /**
+     * Get remote path.
+     *
+     * @return string
+     */
+    public function getRemotePath()
+    {
+        return $this->remotePath;
+    }
+    /**
+     * Set alias.
+     *
+     * @param string $alias
+     *
+     * @return Asset
+     */
+    public function setAlias($alias)
+    {
+        $this->isChanged('alias', $alias);
+        $this->alias = $alias;
+        return $this;
+    }
+    /**
+     * Get alias.
+     *
+     * @return string
+     */
+    public function getAlias()
+    {
+        return $this->alias;
+    }
+    /**
+     * Set publishUp.
+     *
+     * @param \DateTime $publishUp
+     *
+     * @return Asset
+     */
+    public function setPublishUp($publishUp)
+    {
+        $this->isChanged('publishUp', $publishUp);
+        $this->publishUp = $publishUp;
+        return $this;
+    }
+    /**
+     * Get publishUp.
+     *
+     * @return \DateTimeInterface
+     */
+    public function getPublishUp()
+    {
+        return $this->publishUp;
+    }
+    /**
+     * Set publishDown.
+     *
+     * @param \DateTimeInterface $publishDown
+     *
+     * @return Asset
+     */
+    public function setPublishDown($publishDown)
+    {
+        $this->isChanged('publishDown', $publishDown);
+        $this->publishDown = $publishDown;
+        return $this;
+    }
+    /**
+     * Get publishDown.
+     *
+     * @return \DateTimeInterface
+     */
+    public function getPublishDown()
+    {
+        return $this->publishDown;
+    }
+    /**
+     * Set downloadCount.
+     *
+     * @param int $downloadCount
+     *
+     * @return Asset
+     */
+    public function setDownloadCount($downloadCount)
+    {
+        $this->downloadCount = $downloadCount;
+        return $this;
+    }
+    /**
+     * Get downloadCount.
+     *
+     * @return int
+     */
+    public function getDownloadCount()
+    {
+        return $this->downloadCount;
+    }
+    /**
+     * Set revision.
+     *
+     * @param int $revision
+     *
+     * @return Asset
+     */
+    public function setRevision($revision)
+    {
+        $this->revision = $revision;
+        return $this;
+    }
+    /**
+     * Get revision.
+     *
+     * @return int
+     */
+    public function getRevision()
+    {
+        return $this->revision;
+    }
+    /**
+     * Set language.
+     *
+     * @param string $language
+     *
+     * @return Asset
+     */
+    public function setLanguage($language)
+    {
+        $this->isChanged('language', $language);
+        $this->language = $language;
+        return $this;
+    }
+    /**
+     * Get language.
+     *
+     * @return string
+     */
+    public function getLanguage()
+    {
+        return $this->language;
+    }
+    /**
+     * Set category.
+     *
+     * @return Asset
+     */
+    public function setCategory(\Mautic\CategoryBundle\Entity\Category $category = null)
+    {
+        $this->isChanged('category', $category);
+        $this->category = $category;
+        return $this;
+    }
+    /**
+     * Get category.
+     *
+     * @return \Mautic\CategoryBundle\Entity\Category
+     */
+    public function getCategory()
+    {
+        return $this->category;
+    }
+    /**
+     * Set uniqueDownloadCount.
+     *
+     * @param int $uniqueDownloadCount
+     *
+     * @return Asset
+     */
+    public function setUniqueDownloadCount($uniqueDownloadCount)
+    {
+        $this->uniqueDownloadCount = $uniqueDownloadCount;
+        return $this;
+    }
+    /**
+     * Get uniqueDownloadCount.
+     *
+     * @return int
+     */
+    public function getUniqueDownloadCount()
+    {
+        return $this->uniqueDownloadCount;
+    }
+    public function setFileNameFromRemote(): void
+    {
+        $fileName = basename($this->getRemotePath());
+        $this->setOriginalFileName($fileName);
+        if (null === $this->getTitle()) {
+            $this->setTitle($fileName);
+        }
+    }
+    public function preUpload(): void
+    {
+        if (null !== $this->getFile()) {
+            if (null === $this->getTitle()) {
+                $this->setTitle($this->file->getClientOriginalName());
+            }
+            $filename  = sha1(uniqid(mt_rand(), true));
+            $extension = $this->getFile()->guessExtension();
+            if (empty($extension)) {
+                $extension = pathinfo($this->originalFileName, PATHINFO_EXTENSION);
+            }
+            $this->path = $filename.'.'.$extension;
+        } elseif ($this->isRemote() && null !== $this->getRemotePath()) {
+            $this->setFileNameFromRemote();
+        }
+    }
+    public function upload(): void
+    {
+        if (null === $this->getFile()) {
+            if ($this->isRemote()) {
+                $this->setFileInfoFromFile();
+            }
+            return;
+        }
+        $this->getFile()->move($this->getUploadDir(), $this->path);
+        $filePath = $this->getUploadDir().'/'.$this->temp;
+        $this->setFileInfoFromFile();
+        if (isset($this->temp) && file_exists($filePath)) {
+            unlink($filePath);
+            $this->temp = null;
+        }
+        $fs = new Filesystem();
+        $fs->remove($this->getAbsoluteTempDir());
+        $this->file = null;
+    }
+    /**
+     * Remove a file.
+     */
+    public function setFileInfoFromFile(): void
+    {
+        $fileInfo = $this->getFileInfo();
+        if (!is_array($fileInfo)) {
+            return;
+        }
+        $this->setExtension($fileInfo['extension']);
+        $this->setMime($fileInfo['mime']);
+        $this->setSize($fileInfo['size']);
+    }
+    /**
+     * Remove a file.
+     *
+     * @param bool $temp >> regular uploaded file or temporary
+     */
+    public function removeUpload($temp = false): void
+    {
+        if ($temp) {
+            $file = $this->getAbsoluteTempPath();
+        } else {
+            $file = $this->getAbsolutePath();
+        }
+        if ($file && file_exists($file)) {
+            unlink($file);
+        }
+    }
+    /**
+     * Returns absolute path to the file.
+     *
+     * @return string
+     */
+    public function getAbsolutePath()
+    {
+        return null === $this->path
+            ? null
+            : $this->getUploadDir().'/'.$this->path;
+    }
+    /**
+     * Returns absolute path to temporary file.
+     *
+     * @return string
+     */
+    public function getAbsoluteTempPath()
+    {
+        return null === $this->tempId || null === $this->tempName
+            ? null
+            : $this->getAbsoluteTempDir().'/'.$this->tempName;
+    }
+    /**
+     * Returns absolute path to temporary file.
+     *
+     * @return string
+     */
+    public function getAbsoluteTempDir()
+    {
+        return null === $this->tempId
+            ? null
+            : $this->getUploadDir().'/tmp/'.$this->tempId;
+    }
+    /**
+     * Returns absolute path to upload dir.
+     *
+     * @return string
+     */
+    protected function getUploadDir()
+    {
+        if ($this->uploadDir) {
+            return $this->uploadDir;
+        }
+        return 'media/files';
+    }
+    /**
+     * Set uploadDir.
+     *
+     * @param string $uploadDir
+     *
+     * @return Asset
+     */
+    public function setUploadDir($uploadDir)
+    {
+        $this->uploadDir = $uploadDir;
+        return $this;
+    }
+    /**
+     * Returns maximal uploadable size in bytes.
+     * If not set, 6000000 is default.
+     *
+     * @return string
+     */
+    protected function getMaxSize()
+    {
+        if ($this->maxSize) {
+            return $this->maxSize;
+        }
+        return 6_000_000;
+    }
+    /**
+     * Set max size.
+     *
+     * @param string $maxSize
+     *
+     * @return Asset
+     */
+    public function setMaxSize($maxSize)
+    {
+        $this->maxSize = $maxSize;
+        return $this;
+    }
+    /**
+     * Returns file extension.
+     *
+     * @return string
+     */
+    public function getFileType()
+    {
+        if (!empty($this->extension) && empty($this->changes['originalFileName'])) {
+            return $this->extension;
+        }
+        if ($this->isRemote()) {
+            return pathinfo(parse_url($this->getRemotePath(), PHP_URL_PATH), PATHINFO_EXTENSION);
+        }
+        if (null === $this->loadFile()) {
+            return '';
+        }
+        return $this->loadFile()->guessExtension();
+    }
+    /**
+     * Returns some file info.
+     *
+     * @return array
+     */
+    public function getFileInfo()
+    {
+        $fileInfo = [];
+        if ($this->isRemote()) {
+            $ch = curl_init($this->getRemotePath());
+            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
+            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
+            curl_setopt($ch, CURLOPT_HEADER, true);
+            curl_setopt($ch, CURLOPT_NOBODY, true);
+            curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
+            curl_exec($ch);
+            $fileInfo['mime']      = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
+            $fileInfo['extension'] = $this->getFileType();
+            $fileInfo['size']      = curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD);
+            return $fileInfo;
+        }
+        if (null === $this->loadFile()) {
+            return '';
+        }
+        $fileInfo['mime']      = $this->loadFile()->getMimeType();
+        $fileInfo['extension'] = $this->getFileType();
+        $fileInfo['size']      = $this->getSize(false, true);
+        return $fileInfo;
+    }
+    /**
+     * Returns file mime type.
+     *
+     * @return string
+     */
+    public function getFileMimeType()
+    {
+        if ($this->isRemote()) {
+            $ch = curl_init($this->getRemotePath());
+            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
+            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
+            curl_setopt($ch, CURLOPT_HEADER, true);
+            curl_setopt($ch, CURLOPT_NOBODY, true);
+            curl_exec($ch);
+            return curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
+        }
+        if (null === $this->loadFile()) {
+            return '';
+        }
+        return $this->loadFile()->getMimeType();
+    }
+    /**
+     * Returns icon class based on file type.
+     */
+    public function getIconClass(): string
+    {
+        $fileType = $this->getFileType();
+        if (!$fileType) {
+            return 'ri-prohibited-line';
+        }
+        $fileTypes = $this->getFileExtensions();
+        foreach ($fileTypes as $icon => $extensions) {
+            if (in_array($fileType, $extensions)) {
+                return 'ri-file-'.$icon.'-line';
+            }
+        }
+        return 'ri-file-line';
+    }
+    /**
+     * Decides if an asset is image displayable by browser.
+     */
+    public function isImage(): bool
+    {
+        $fileType = strtolower($this->getFileType());
+        if (!$fileType) {
+            return false;
+        }
+        $imageTypes = ['jpg', 'jpeg', 'png', 'gif'];
+        if (in_array($fileType, $imageTypes)) {
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Returns array of common extensions.
+     *
+     * @return array<string, string[]>
+     */
+    public function getFileExtensions(): array
+    {
+        return [
+            'excel' => [
+                'xlsx',
+                'xlsm',
+                'xlsb',
+                'xltx',
+                'xltm',
+                'xls',
+                'xlt',
+            ],
+            'word' => [
+                'doc',
+                'docx',
+                'docm',
+                'dotx',
+            ],
+            'pdf' => [
+                'pdf',
+            ],
+            'audio' => [
+                'mp3',
+            ],
+            'zip' => [
+                'zip',
+                'rar',
+                'iso',
+                'tar',
+                'gz',
+                '7z',
+            ],
+            'image' => [
+                'jpg',
+                'jpeg',
+                'png',
+                'gif',
+                'ico',
+                'bmp',
+                'psd',
+            ],
+            'text' => [
+                'txt',
+                'pub',
+            ],
+            'code' => [
+                'php',
+                'js',
+                'json',
+                'yaml',
+                'xml',
+                'html',
+                'htm',
+                'sql',
+            ],
+            'ppt' => [
+                'ppt',
+                'pptx',
+                'pptm',
+                'xps',
+                'potm',
+                'potx',
+                'pot',
+                'pps',
+                'odp',
+            ],
+            'video' => [
+                'wmv',
+                'avi',
+                'mp4',
+                'mkv',
+                'mpeg',
+            ],
+        ];
+    }
+    /**
+     * Load the file object from it's path.
+     *
+     * @return File|null
+     */
+    public function loadFile($temp = false)
+    {
+        if ($temp) {
+            $path = $this->getAbsoluteTempPath();
+        } else {
+            $path = $this->getAbsolutePath();
+        }
+        if (!$path || !file_exists($path)) {
+            return null;
+        }
+        try {
+            $file = new File($path);
+        } catch (FileNotFoundException) {
+            $file = null;
+        }
+        return $file;
+    }
+    /**
+     * Load content of the file from it's path.
+     */
+    public function getFileContents(): string|bool
+    {
+        $path = $this->getFilePath();
+        return file_get_contents($path);
+    }
+    /**
+     * Get the path to the file; a URL if remote or full file path if local.
+     *
+     * @return string
+     */
+    public function getFilePath()
+    {
+        return $this->isRemote() ? $this->getRemotePath() : $this->getAbsolutePath();
+    }
+    /**
+     * @return mixed
+     */
+    public function getDescription()
+    {
+        return $this->description;
+    }
+    /**
+     * @param mixed $description
+     */
+    public function setDescription($description): void
+    {
+        $this->description = $description;
+    }
+    public static function loadValidatorMetadata(ClassMetadata $metadata): void
+    {
+        $metadata->addConstraint(new Assert\Callback([self::class, 'validateFile']));
+    }
+    /**
+     * Validator to ensure proper data for the file fields.
+     *
+     * @param Asset                     $object  Entity object to validate
+     * @param ExecutionContextInterface $context Context object
+     */
+    public static function validateFile($object, ExecutionContextInterface $context): void
+    {
+        if ($object->isLocal()) {
+            $tempName = $object->getTempName();
+            $path     = $object->getPath();
+            if ($object->isNew() && null === $tempName && null === $path) {
+                $context->buildViolation('mautic.asset.asset.error.missing.file')
+                    ->atPath('tempName')
+                    ->setTranslationDomain('validators')
+                    ->addViolation();
+            }
+            if (null === $object->getTitle()) {
+                $context->buildViolation('mautic.asset.asset.error.missing.title')
+                    ->atPath('title')
+                    ->setTranslationDomain('validators')
+                    ->addViolation();
+            }
+            $loader           = new ParameterLoader();
+            $parameters       = $loader->getParameterBag();
+            $mimeTypesAllowed = $parameters->get('allowed_mimetypes');
+            if (!empty($object->getFileMimeType()) && !in_array($object->getFileMimeType(), $mimeTypesAllowed)) {
+                $context->buildViolation('mautic.asset.asset.error.invalid.mimetype', [
+                    '%fileMimetype%'=> $object->getFileMimeType(),
+                    '%mimetypes%'   => implode(', ', $mimeTypesAllowed),
+                ])->atPath('file')
+                    ->setTranslationDomain('validators')
+                    ->addViolation();
+            }
+            $extensionsAllowed = array_keys($mimeTypesAllowed);
+            $fileType          = $object->getExtension();
+            if (null !== $object->getExtension() && !in_array($fileType, $extensionsAllowed)) {
+                $context->buildViolation('mautic.asset.asset.error.file.extension', [
+                    '%fileExtension%'=> $object->getExtension(),
+                    '%extensions%'   => implode(', ', $extensionsAllowed),
+                ])->atPath('file')
+                    ->setTranslationDomain('validators')
+                    ->addViolation();
+            }
+            $object->setRemotePath(null);
+        } elseif ($object->isRemote()) {
+            if (null === $object->getRemotePath()) {
+                $context->buildViolation('mautic.asset.asset.error.missing.remote.path')
+                    ->atPath('remotePath')
+                    ->setTranslationDomain('validators')
+                    ->addViolation();
+            }
+            $object->setPath(null);
+        }
+    }
+    /**
+     * Set temporary ID.
+     *
+     * @param string $tempId
+     *
+     * @return Asset
+     */
+    public function setTempId($tempId)
+    {
+        $this->tempId = $tempId;
+        return $this;
+    }
+    /**
+     * Get temporary ID.
+     *
+     * @return string
+     */
+    public function getTempId()
+    {
+        return $this->tempId;
+    }
+    /**
+     * Set temporary file name.
+     *
+     * @param string $tempName
+     *
+     * @return Asset
+     */
+    public function setTempName($tempName)
+    {
+        $this->tempName = $tempName;
+        return $this;
+    }
+    /**
+     * Get temporary file name.
+     *
+     * @return string
+     */
+    public function getTempName()
+    {
+        return $this->tempName;
+    }
+    /**
+     * @param bool   $humanReadable
+     * @param bool   $forceUpdate
+     * @param string $inUnit
+     *
+     * @return float|string
+     */
+    public function getSize($humanReadable = true, $forceUpdate = false, $inUnit = '')
+    {
+        if (empty($this->size) || $forceUpdate) {
+            if ($this->isRemote()) {
+                $ch = curl_init($this->getRemotePath());
+                curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
+                curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
+                curl_setopt($ch, CURLOPT_HEADER, true);
+                curl_setopt($ch, CURLOPT_NOBODY, true);
+                curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
+                curl_exec($ch);
+                $this->setSize(round(curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD)));
+            }
+            if (null === $this->loadFile()) {
+                return 0;
+            }
+            $this->setSize(round($this->loadFile()->getSize()));
+        }
+        return ($humanReadable) ? static::convertBytesToHumanReadable($this->size, $inUnit) : $this->size;
+    }
+    /**
+     * @param mixed $size
+     *
+     * @return Asset
+     */
+    public function setSize($size)
+    {
+        $this->size = $size;
+        return $this;
+    }
+    /**
+     * Get value from PHP configuration with special handling of -1.
+     *
+     * @param string    $setting
+     * @param bool|true $convertToBytes
+     */
+    public static function getIniValue($setting, $convertToBytes = true): int
+    {
+        $value = ini_get($setting);
+        if (-1 == $value || 0 === $value) {
+            return PHP_INT_MAX;
+        }
+        if ($convertToBytes) {
+            $value = FileHelper::convertPHPSizeToBytes($value);
+        }
+        return (int) $value;
+    }
+    /**
+     * @param string $unit
+     */
+    public static function convertBytesToHumanReadable($size, $unit = ''): string
+    {
+        [$number, $unit] = self::convertBytesToUnit($size, $unit);
+        $number = number_format($number, 2);
+        $number = str_contains($number, '.') ? rtrim(rtrim($number, '0'), '.') : $number;
+        return $number.' '.$unit;
+    }
+    /**
+     * @param string $unit
+     */
+    public static function convertBytesToUnit($size, $unit = ''): array
+    {
+        $unit = strtoupper($unit);
+        if ((!$unit && $size >= 1 << 30) || 'GB' == $unit || 'G' == $unit) {
+            return [$size / (1 << 30), 'GB'];
+        }
+        if ((!$unit && $size >= 1 << 20) || 'MB' == $unit || 'M' == $unit) {
+            return [$size / (1 << 20), 'MB'];
+        }
+        if ((!$unit && $size >= 1 << 10) || 'KB' == $unit || 'K' == $unit) {
+            return [$size / (1 << 10), 'KB'];
+        }
+        return [$size, 'bytes'];
+    }
+    /**
+     * @return string|null
+     */
+    public function getDownloadUrl()
+    {
+        return $this->downloadUrl;
+    }
+    /**
+     * @param string|null $downloadUrl
+     *
+     * @return Asset
+     */
+    public function setDownloadUrl($downloadUrl)
+    {
+        $this->downloadUrl = $downloadUrl;
+        return $this;
+    }
+    public function isLocal(): bool
+    {
+        return 'local' === $this->storageLocation;
+    }
+    public function isRemote(): bool
+    {
+        return 'remote' === $this->storageLocation;
+    }
+    /**
+     * @return bool
+     */
+    public function getDisallow()
+    {
+        return $this->disallow;
+    }
+    /**
+     * @param mixed $disallow
+     */
+    public function setDisallow($disallow): void
+    {
+        $this->disallow = $disallow;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Entity/AssetRepository.php
@@ -0,0 +1,178 @@
+<?php
+namespace Mautic\AssetBundle\Entity;
+use Doctrine\Common\Collections\Order;
+use Doctrine\ORM\NonUniqueResultException;
+use Doctrine\ORM\NoResultException;
+use Doctrine\ORM\Tools\Pagination\Paginator;
+use Mautic\CoreBundle\Entity\CommonRepository;
+/**
+ * @extends CommonRepository<Asset>
+ */
+class AssetRepository extends CommonRepository
+{
+    /**
+     * Get a list of entities.
+     *
+     * @return Paginator
+     */
+    public function getEntities(array $args = [])
+    {
+        $q = $this
+            ->createQueryBuilder('a')
+            ->select('a')
+            ->leftJoin('a.category', 'c');
+        $args['qb'] = $q;
+        return parent::getEntities($args);
+    }
+    /**
+     * @param string     $search
+     * @param int        $limit
+     * @param int        $start
+     * @param bool|false $viewOther
+     *
+     * @return array
+     */
+    public function getAssetList($search = '', $limit = 10, $start = 0, $viewOther = false)
+    {
+        $q = $this->createQueryBuilder('a');
+        $q->select('partial a.{id, title, path, alias, language}');
+        if (!empty($search)) {
+            $q->andWhere($q->expr()->like('a.title', ':search'))
+                ->setParameter('search', "%{$search}%");
+        }
+        if (!$viewOther) {
+            $q->andWhere($q->expr()->eq('a.createdBy', ':id'))
+                ->setParameter('id', $this->currentUser->getId());
+        }
+        $q->orderBy('a.title');
+        if (!empty($limit)) {
+            $q->setFirstResult($start)
+                ->setMaxResults($limit);
+        }
+        return $q->getQuery()->getArrayResult();
+    }
+    /**
+     * @param \Doctrine\ORM\QueryBuilder|\Doctrine\DBAL\Query\QueryBuilder $q
+     */
+    protected function addCatchAllWhereClause($q, $filter): array
+    {
+        return $this->addStandardCatchAllWhereClause($q, $filter, [
+            'a.title',
+            'a.alias',
+        ]);
+    }
+    /**
+     * @param \Doctrine\ORM\QueryBuilder|\Doctrine\DBAL\Query\QueryBuilder $q
+     */
+    protected function addSearchCommandWhereClause($q, $filter): array
+    {
+        [$expr, $parameters] = $this->addStandardSearchCommandWhereClause($q, $filter);
+        if ($expr) {
+            return [$expr, $parameters];
+        }
+        $command         = $field         = $filter->command;
+        $unique          = $this->generateRandomParameterName();
+        $returnParameter = false; // returning a parameter that is not used will lead to a Doctrine error
+        switch ($command) {
+            case $this->translator->trans('mautic.asset.asset.searchcommand.lang'):
+                $langUnique      = $this->generateRandomParameterName();
+                $langValue       = $filter->string.'_%';
+                $forceParameters = [
+                    $langUnique => $langValue,
+                    $unique     => $filter->string,
+                ];
+                $expr = $q->expr()->or(
+                    $q->expr()->eq('a.language', ":$unique"),
+                    $q->expr()->like('a.language', ":$langUnique")
+                );
+                $returnParameter = true;
+                break;
+        }
+        if ($expr && $filter->not) {
+            $expr = $q->expr()->not($expr);
+        }
+        if (!empty($forceParameters)) {
+            $parameters = $forceParameters;
+        } elseif (!$returnParameter) {
+            $parameters = [];
+        } else {
+            $string     = ($filter->strict) ? $filter->string : "%{$filter->string}%";
+            $parameters = ["$unique" => $string];
+        }
+        return [$expr, $parameters];
+    }
+    /**
+     * @return string[]
+     */
+    public function getSearchCommands(): array
+    {
+        $commands = [
+            'mautic.core.searchcommand.ispublished',
+            'mautic.core.searchcommand.isunpublished',
+            'mautic.core.searchcommand.isuncategorized',
+            'mautic.core.searchcommand.ismine',
+            'mautic.core.searchcommand.category',
+            'mautic.asset.asset.searchcommand.lang',
+        ];
+        return array_merge($commands, parent::getSearchCommands());
+    }
+    /**
+     * @return array<array<string>>
+     */
+    protected function getDefaultOrder(): array
+    {
+        return [
+            ['a.title', 'ASC'],
+        ];
+    }
+    public function getTableAlias(): string
+    {
+        return 'a';
+    }
+    /**
+     * Gets the sum size of assets.
+     */
+    public function getAssetSize(array $assets): int
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->select('sum(a.size) as total_size')
+            ->from(MAUTIC_TABLE_PREFIX.'assets', 'a')
+            ->where('a.id IN (:assetIds)')
+            ->setParameter('assetIds', $assets, \Doctrine\DBAL\ArrayParameterType::INTEGER);
+        $result = $q->executeQuery()->fetchAllAssociative();
+        return (int) $result[0]['total_size'];
+    }
+    /**
+     * @param int        $increaseBy
+     * @param bool|false $unique
+     */
+    public function upDownloadCount($id, $increaseBy = 1, $unique = false): void
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->update(MAUTIC_TABLE_PREFIX.'assets')
+            ->set('download_count', 'download_count + '.(int) $increaseBy)
+            ->where('id = '.(int) $id);
+        if ($unique) {
+            $q->set('unique_download_count', 'unique_download_count + '.(int) $increaseBy);
+        }
+        $q->executeStatement();
+    }
+    /**
+     * @param int $categoryId
+     *
+     * @return Asset
+     *
+     * @throws NoResultException
+     * @throws NonUniqueResultException
+     */
+    public function getLatestAssetForCategory($categoryId)
+    {
+        $q = $this->createQueryBuilder($this->getTableAlias());
+        $q->where($this->getTableAlias().'.category = :categoryId');
+        $q->andWhere($this->getTableAlias().'.isPublished = TRUE');
+        $q->setParameter('categoryId', $categoryId);
+        $q->orderBy($this->getTableAlias().'.dateAdded', Order::Descending->value);
+        $q->setMaxResults(1);
+        return $q->getQuery()->getSingleResult();
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Event/AssetLoadEvent.php
@@ -0,0 +1,36 @@
+<?php
+namespace Mautic\AssetBundle\Event;
+use Mautic\AssetBundle\Entity\Download;
+use Mautic\CoreBundle\Event\CommonEvent;
+class AssetLoadEvent extends CommonEvent
+{
+    public function __construct(
+        Download $download,
+        protected bool $unique,
+    ) {
+        $this->entity = $download;
+    }
+    /**
+     * Returns the Download entity.
+     *
+     * @return Download
+     */
+    public function getRecord()
+    {
+        return $this->entity;
+    }
+    /**
+     * @return \Mautic\AssetBundle\Entity\Asset
+     */
+    public function getAsset()
+    {
+        return $this->entity->getAsset();
+    }
+    /**
+     * Returns if this is the first download for the session.
+     */
+    public function isUnique(): bool
+    {
+        return $this->unique;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Event/RemoteAssetBrowseEvent.php
@@ -0,0 +1,25 @@
+<?php
+namespace Mautic\AssetBundle\Event;
+use Gaufrette\Adapter;
+use Mautic\CoreBundle\Event\CommonEvent;
+use Mautic\PluginBundle\Integration\UnifiedIntegrationInterface;
+class RemoteAssetBrowseEvent extends CommonEvent
+{
+    private ?Adapter $adapter = null;
+    public function __construct(
+        private UnifiedIntegrationInterface $integration,
+    ) {
+    }
+    public function getAdapter(): ?Adapter
+    {
+        return $this->adapter;
+    }
+    public function getIntegration(): UnifiedIntegrationInterface
+    {
+        return $this->integration;
+    }
+    public function setAdapter(Adapter $adapter): void
+    {
+        $this->adapter = $adapter;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/AssetSubscriber.php
@@ -0,0 +1,57 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Event as Events;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class AssetSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private IpLookupHelper $ipLookupHelper,
+        private AuditLogModel $auditLogModel,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            AssetEvents::ASSET_POST_SAVE   => ['onAssetPostSave', 0],
+            AssetEvents::ASSET_POST_DELETE => ['onAssetDelete', 0],
+        ];
+    }
+    /**
+     * Add an entry to the audit log.
+     */
+    public function onAssetPostSave(Events\AssetEvent $event): void
+    {
+        $asset = $event->getAsset();
+        if ($details = $event->getChanges()) {
+            $log = [
+                'bundle'    => 'asset',
+                'object'    => 'asset',
+                'objectId'  => $asset->getId(),
+                'action'    => ($event->isNew()) ? 'create' : 'update',
+                'details'   => $details,
+                'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+            ];
+            $this->auditLogModel->writeToLog($log);
+        }
+    }
+    /**
+     * Add a delete entry to the audit log.
+     */
+    public function onAssetDelete(Events\AssetEvent $event): void
+    {
+        $asset = $event->getAsset();
+        $log   = [
+            'bundle'    => 'asset',
+            'object'    => 'asset',
+            'objectId'  => $asset->deletedId,
+            'action'    => 'delete',
+            'details'   => ['name' => $asset->getTitle()],
+            'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+        ];
+        $this->auditLogModel->writeToLog($log);
+        $asset->removeUpload();
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/BuilderSubscriber.php
@@ -0,0 +1,80 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Helper\TokenHelper;
+use Mautic\CoreBundle\Event\BuilderEvent;
+use Mautic\CoreBundle\Helper\BuilderTokenHelperFactory;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\EmailBundle\EmailEvents;
+use Mautic\EmailBundle\Event\EmailSendEvent;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+use Mautic\PageBundle\Event\PageDisplayEvent;
+use Mautic\PageBundle\PageEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class BuilderSubscriber implements EventSubscriberInterface
+{
+    private string $assetToken = '{assetlink=(.*?)}';
+    public function __construct(
+        private CorePermissions $security,
+        private TokenHelper $tokenHelper,
+        private ContactTracker $contactTracker,
+        private BuilderTokenHelperFactory $builderTokenHelperFactory,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            EmailEvents::EMAIL_ON_BUILD   => ['onBuilderBuild', 0],
+            EmailEvents::EMAIL_ON_SEND    => ['onEmailGenerate', 0],
+            EmailEvents::EMAIL_ON_DISPLAY => ['onEmailGenerate', 0],
+            PageEvents::PAGE_ON_BUILD     => ['onBuilderBuild', 0],
+            PageEvents::PAGE_ON_DISPLAY   => ['onPageDisplay', 0],
+        ];
+    }
+    public function onBuilderBuild(BuilderEvent $event): void
+    {
+        if ($event->tokensRequested($this->assetToken)) {
+            $tokenHelper = $this->builderTokenHelperFactory->getBuilderTokenHelper('asset');
+            $event->addTokensFromHelper($tokenHelper, $this->assetToken, 'title', 'id', true);
+        }
+    }
+    public function onEmailGenerate(EmailSendEvent $event): void
+    {
+        $lead   = $event->getLead();
+        $leadId = (int) (null !== $lead ? $lead['id'] : null);
+        $email  = $event->getEmail();
+        $tokens = $this->generateTokensFromContent($event, $leadId, $event->getSource(), null === $email ? null : $email->getId());
+        $event->addTokens($tokens);
+    }
+    public function onPageDisplay(PageDisplayEvent $event): void
+    {
+        if (!$lead = $event->getLead()) {
+            $lead = $this->security->isAnonymous() ? $this->contactTracker->getContact() : null;
+        }
+        $leadId  = $lead ? $lead->getId() : null;
+        $page    = $event->getPage();
+        $tokens  = $this->generateTokensFromContent($event, $leadId, ['page', $page->getId()]);
+        $content = $event->getContent();
+        if ([] !== $tokens) {
+            $content = str_ireplace(array_keys($tokens), $tokens, $content);
+        }
+        $event->setContent($content);
+    }
+    /**
+     * @param PageDisplayEvent|EmailSendEvent $event
+     * @param array                           $source
+     * @param int|null                        $emailId
+     *
+     * @return mixed[]
+     */
+    private function generateTokensFromContent($event, ?int $leadId, $source = [], $emailId = null): array
+    {
+        if ($event instanceof PageDisplayEvent || ($event instanceof EmailSendEvent && $event->shouldAppendClickthrough())) {
+            $clickthrough = [
+                'source' => $source,
+                'lead'   => $leadId ?? false,
+                'email'  => $emailId ?? false,
+            ];
+        }
+        return $this->tokenHelper->findAssetTokens($event->getContent(), array_filter($clickthrough ?? []));
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/CampaignSubscriber.php
@@ -0,0 +1,60 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Event\AssetLoadEvent;
+use Mautic\AssetBundle\Form\Type\CampaignEventAssetDownloadType;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
+use Mautic\CampaignBundle\Event\CampaignExecutionEvent;
+use Mautic\CampaignBundle\Executioner\RealTimeExecutioner;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class CampaignSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private RealTimeExecutioner $realTimeExecutioner,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::CAMPAIGN_ON_BUILD         => ['onCampaignBuild', 0],
+            AssetEvents::ASSET_ON_LOAD                => ['onAssetDownload', 0],
+            AssetEvents::ON_CAMPAIGN_TRIGGER_DECISION => ['onCampaignTriggerDecision', 0],
+        ];
+    }
+    public function onCampaignBuild(CampaignBuilderEvent $event): void
+    {
+        $trigger = [
+            'label'          => 'mautic.asset.campaign.event.download',
+            'description'    => 'mautic.asset.campaign.event.download_descr',
+            'eventName'      => AssetEvents::ON_CAMPAIGN_TRIGGER_DECISION,
+            'formType'       => CampaignEventAssetDownloadType::class,
+            'channel'        => 'asset',
+            'channelIdField' => 'assets',
+        ];
+        $event->addDecision('asset.download', $trigger);
+    }
+    /**
+     * Trigger point actions for asset download.
+     */
+    public function onAssetDownload(AssetLoadEvent $event): void
+    {
+        $asset = $event->getRecord()->getAsset();
+        if (null !== $asset) {
+            $this->realTimeExecutioner->execute('asset.download', $asset, 'asset', $asset->getId());
+        }
+    }
+    public function onCampaignTriggerDecision(CampaignExecutionEvent $event)
+    {
+        $eventDetails = $event->getEventDetails();
+        if (null == $eventDetails) {
+            return $event->setResult(true);
+        }
+        $assetId       = $eventDetails->getId();
+        $limitToAssets = $event->getConfig()['assets'];
+        if (!empty($limitToAssets) && !in_array($assetId, $limitToAssets)) {
+            return $event->setResult(false);
+        }
+        $event->setResult(true);
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/DashboardSubscriber.php
@@ -0,0 +1,147 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\DashboardBundle\Event\WidgetDetailEvent;
+use Mautic\DashboardBundle\EventListener\DashboardSubscriber as MainDashboardSubscriber;
+use Symfony\Component\Routing\RouterInterface;
+class DashboardSubscriber extends MainDashboardSubscriber
+{
+    /**
+     * Define the name of the bundle/category of the widget(s).
+     *
+     * @var string
+     */
+    protected $bundle = 'asset';
+    /**
+     * Define the widget(s).
+     *
+     * @var array
+     */
+    protected $types = [
+        'asset.downloads.in.time'        => [],
+        'unique.vs.repetitive.downloads' => [],
+        'popular.assets'                 => [],
+        'created.assets'                 => [],
+    ];
+    /**
+     * Define permissions to see those widgets.
+     *
+     * @var array
+     */
+    protected $permissions = [
+        'asset:assets:viewown',
+        'asset:assets:viewother',
+    ];
+    public function __construct(
+        protected AssetModel $assetModel,
+        protected RouterInterface $router,
+    ) {
+    }
+    /**
+     * Set a widget detail when needed.
+     */
+    public function onWidgetDetailGenerate(WidgetDetailEvent $event): void
+    {
+        $this->checkPermissions($event);
+        $canViewOthers = $event->hasPermission('asset:assets:viewother');
+        if ('asset.downloads.in.time' == $event->getType()) {
+            $widget = $event->getWidget();
+            $params = $widget->getParams();
+            if (!$event->isCached()) {
+                $event->setTemplateData([
+                    'chartType'   => 'line',
+                    'chartHeight' => $widget->getHeight() - 80,
+                    'chartData'   => $this->assetModel->getDownloadsLineChartData(
+                        $params['timeUnit'],
+                        $params['dateFrom'],
+                        $params['dateTo'],
+                        $params['dateFormat'],
+                        $canViewOthers
+                    ),
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/chart.html.twig');
+            $event->stopPropagation();
+        }
+        if ('unique.vs.repetitive.downloads' == $event->getType()) {
+            if (!$event->isCached()) {
+                $params = $event->getWidget()->getParams();
+                $event->setTemplateData([
+                    'chartType'   => 'pie',
+                    'chartHeight' => $event->getWidget()->getHeight() - 80,
+                    'chartData'   => $this->assetModel->getUniqueVsRepetitivePieChartData($params['dateFrom'], $params['dateTo'], $canViewOthers),
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/chart.html.twig');
+            $event->stopPropagation();
+        }
+        if ('popular.assets' == $event->getType()) {
+            if (!$event->isCached()) {
+                $params = $event->getWidget()->getParams();
+                if (empty($params['limit'])) {
+                    $limit = round((($event->getWidget()->getHeight() - 80) / 35) - 1);
+                } else {
+                    $limit = $params['limit'];
+                }
+                $assets = $this->assetModel->getPopularAssets($limit, $params['dateFrom'], $params['dateTo'], $canViewOthers);
+                $items  = [];
+                foreach ($assets as &$asset) {
+                    $assetUrl = $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $asset['id']]);
+                    $row      = [
+                        [
+                            'value' => $asset['title'],
+                            'type'  => 'link',
+                            'link'  => $assetUrl,
+                        ],
+                        [
+                            'value' => $asset['download_count'],
+                        ],
+                    ];
+                    $items[] = $row;
+                }
+                $event->setTemplateData([
+                    'headItems' => [
+                        'mautic.dashboard.label.title',
+                        'mautic.dashboard.label.downloads',
+                    ],
+                    'bodyItems' => $items,
+                    'raw'       => $assets,
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/table.html.twig');
+            $event->stopPropagation();
+        }
+        if ('created.assets' == $event->getType()) {
+            if (!$event->isCached()) {
+                $params = $event->getWidget()->getParams();
+                if (empty($params['limit'])) {
+                    $limit = round((($event->getWidget()->getHeight() - 80) / 35) - 1);
+                } else {
+                    $limit = $params['limit'];
+                }
+                $assets = $this->assetModel->getAssetList($limit, $params['dateFrom'], $params['dateTo'], [], ['canViewOthers' => $canViewOthers]);
+                $items  = [];
+                foreach ($assets as &$asset) {
+                    $assetUrl = $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $asset['id']]);
+                    $row      = [
+                        [
+                            'value' => $asset['name'],
+                            'type'  => 'link',
+                            'link'  => $assetUrl,
+                        ],
+                    ];
+                    $items[] = $row;
+                }
+                $event->setTemplateData([
+                    'headItems' => [
+                        'mautic.dashboard.label.title',
+                    ],
+                    'bodyItems' => $items,
+                    'raw'       => $assets,
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/table.html.twig');
+            $event->stopPropagation();
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/DetermineWinnerSubscriber.php
@@ -0,0 +1,96 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Doctrine\ORM\EntityManagerInterface;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Entity\Download;
+use Mautic\CoreBundle\Event\DetermineWinnerEvent;
+use Mautic\EmailBundle\Entity\Email;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class DetermineWinnerSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private EntityManagerInterface $em,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            AssetEvents::ON_DETERMINE_DOWNLOAD_RATE_WINNER => ['onDetermineDownloadRateWinner', 0],
+        ];
+    }
+    /**
+     * Determines the winner of A/B test based on number of asset downloads.
+     */
+    public function onDetermineDownloadRateWinner(DetermineWinnerEvent $event): void
+    {
+        $repo       = $this->em->getRepository(Download::class);
+        $parameters = $event->getParameters();
+        $parent     = $parameters['parent'];
+        $children   = $parameters['children'];
+        $type = ($parent instanceof Email) ? 'email' : 'page';
+        $ids = [$parent->getId()];
+        foreach ($children as $c) {
+            if ($c->isPublished()) {
+                $id    = $c->getId();
+                $ids[] = $id;
+            }
+        }
+        $startDate = $parent->getVariantStartDate();
+        if (null != $startDate && !empty($ids)) {
+            $counts = ('page' == $type) ? $repo->getDownloadCountsByPage($ids, $startDate) : $repo->getDownloadCountsByEmail($ids, $startDate);
+            $translator = $this->translator;
+            if ($counts) {
+                $downloads  = $support  = $data  = [];
+                $hasResults = [];
+                $downloadsLabel = $translator->trans('mautic.asset.abtest.label.downloads');
+                $hitsLabel      = ('page' == $type) ? $translator->trans('mautic.asset.abtest.label.hits') : $translator->trans('mautic.asset.abtest.label.sentemils');
+                foreach ($counts as $stats) {
+                    $rate                    = ($stats['total']) ? round(($stats['count'] / $stats['total']) * 100, 2) : 0;
+                    $downloads[$stats['id']] = $rate;
+                    $data[$downloadsLabel][] = $stats['count'];
+                    $data[$hitsLabel][]      = $stats['total'];
+                    $support['labels'][]     = $stats['id'].':'.$stats['name'].' ('.$rate.'%)';
+                    $hasResults[]            = $stats['id'];
+                }
+                if (!in_array($parent->getId(), $hasResults)) {
+                    $data[$downloadsLabel][] = 0;
+                    $data[$hitsLabel][]      = 0;
+                    $support['labels'][]     = $parent->getId().':'.(('page' == $type) ? $parent->getTitle() : $parent->getName()).' (0%)';
+                }
+                foreach ($children as $c) {
+                    if ($c->isPublished()) {
+                        if (!in_array($c->getId(), $hasResults)) {
+                            $data[$downloadsLabel][] = 0;
+                            $data[$hitsLabel][]      = 0;
+                            $support['labels'][]     = $c->getId().':'.(('page' == $type) ? $c->getTitle() : $c->getName()).' (0%)';
+                        }
+                    }
+                }
+                $support['data'] = $data;
+                $maxes = [];
+                foreach ($support['data'] as $data) {
+                    $maxes[] = max($data);
+                }
+                $top                   = max($maxes);
+                $support['step_width'] = (ceil($top / 10) * 10);
+                asort($downloads);
+                $max = max($downloads);
+                $winners = ($max > 0) ? array_keys($downloads, $max) : [];
+                $event->setAbTestResults([
+                    'winners'         => $winners,
+                    'support'         => $support,
+                    'basedOn'         => 'asset.downloads',
+                    'supportTemplate' => '@MauticPage/SubscribedEvents/AbTest/bargraph.html.twig',
+                ]);
+                return;
+            }
+        }
+        $event->setAbTestResults([
+            'winners' => [],
+            'support' => [],
+            'basedOn' => 'asset.downloads',
+        ]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/FormSubscriber.php
@@ -0,0 +1,133 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Doctrine\ORM\NonUniqueResultException;
+use Doctrine\ORM\NoResultException;
+use Mautic\AssetBundle\Entity\Asset;
+use Mautic\AssetBundle\Form\Type\FormSubmitActionDownloadFileType;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\ThemeHelperInterface;
+use Mautic\CoreBundle\Twig\Helper\AnalyticsHelper;
+use Mautic\CoreBundle\Twig\Helper\AssetsHelper;
+use Mautic\FormBundle\Entity\Form;
+use Mautic\FormBundle\Event\FormBuilderEvent;
+use Mautic\FormBundle\Event\SubmissionEvent;
+use Mautic\FormBundle\FormEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Contracts\Translation\TranslatorInterface;
+use Twig\Environment;
+class FormSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private AssetModel $assetModel,
+        protected TranslatorInterface $translator,
+        private AnalyticsHelper $analyticsHelper,
+        private AssetsHelper $assetsHelper,
+        private ThemeHelperInterface $themeHelper,
+        private Environment $twig,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            FormEvents::FORM_ON_BUILD                 => ['onFormBuilder', 0],
+            FormEvents::ON_EXECUTE_SUBMIT_ACTION      => [
+                ['onFormSubmitActionAssetDownload', 0],
+                ['onFormSubmitActionDownloadFile', 0],
+            ],
+        ];
+    }
+    /**
+     * Add a lead generation action to available form submit actions.
+     */
+    public function onFormBuilder(FormBuilderEvent $event): void
+    {
+        $event->addSubmitAction('asset.download', [
+            'group'              => 'mautic.asset.actions',
+            'label'              => 'mautic.asset.asset.submitaction.downloadfile',
+            'description'        => 'mautic.asset.asset.submitaction.downloadfile_descr',
+            'formType'           => FormSubmitActionDownloadFileType::class,
+            'formTypeCleanMasks' => ['message' => 'html'],
+            'eventName'          => FormEvents::ON_EXECUTE_SUBMIT_ACTION,
+            'allowCampaignForm'  => true,
+            'template'           => '@MauticAsset/Action/asset.html.twig',
+        ]);
+    }
+    public function onFormSubmitActionAssetDownload(SubmissionEvent $event): void
+    {
+        if (false === $event->checkContext('asset.download')) {
+            return;
+        }
+        $properties = $event->getAction()->getProperties();
+        $assetId    = $properties['asset'];
+        $categoryId = $properties['category'] ?? null;
+        $asset      = null;
+        if (null !== $assetId) {
+            $asset = $this->assetModel->getEntity($assetId);
+        } elseif (null !== $categoryId) {
+            try {
+                $asset = $this->assetModel->getRepository()->getLatestAssetForCategory($categoryId);
+            } catch (NoResultException|NonUniqueResultException) {
+                $asset = null;
+            }
+        }
+        if ($asset instanceof Asset && $asset->isPublished()) {
+            $event->setPostSubmitCallback('asset.download_file', [
+                'eventName' => FormEvents::ON_EXECUTE_SUBMIT_ACTION,
+                'form'      => $event->getAction()->getForm(),
+                'asset'     => $asset,
+                'message'   => $properties['message'] ?? '',
+            ]);
+        }
+    }
+    public function onFormSubmitActionDownloadFile(SubmissionEvent $event): void
+    {
+        if (false === $event->checkContext('asset.download_file')) {
+            return;
+        }
+        /*
+         * No further actions can run after this, as we need to send the
+         * download response to the client.
+         */
+        $event->stopPropagation();
+        /**
+         * @var Form   $form
+         * @var Asset  $asset
+         * @var string $message
+         * @var bool   $messengerMode
+         */
+        [
+            'form'          => $form,
+            'asset'         => $asset,
+            'message'       => $message,
+            'messengerMode' => $messengerMode,
+        ]    = $event->getPostSubmitCallback('asset.download_file');
+        $url = $this->assetModel->generateUrl($asset, true, [
+            'lead'    => $event->getLead() ? $event->getLead()->getId() : null,
+            'channel' => ['form' => $form->getId()],
+        ]).'&stream=0';
+        if ($messengerMode) {
+            $event->setPostSubmitResponse(['download' => $url]);
+            return;
+        }
+        $msg = $message.$this->translator->trans('mautic.asset.asset.submitaction.downloadfile.msg', [
+            '%url%' => $url,
+        ]);
+        $analytics = $this->analyticsHelper->getCode();
+        if (!empty($analytics)) {
+            $this->assetsHelper->addCustomDeclaration($analytics);
+        }
+        $event->setPostSubmitResponse(new Response(
+            $this->twig->render(
+                $this->themeHelper->checkForTwigTemplate('@themes/'.$this->coreParametersHelper->get('theme').'/html/message.html.twig'),
+                [
+                    'message'  => $msg,
+                    'type'     => 'notice',
+                    'template' => $this->coreParametersHelper->get('theme'),
+                ]
+            )
+        ));
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/LeadSubscriber.php
@@ -0,0 +1,80 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Entity\DownloadRepository;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\LeadBundle\Event\LeadChangeEvent;
+use Mautic\LeadBundle\Event\LeadMergeEvent;
+use Mautic\LeadBundle\Event\LeadTimelineEvent;
+use Mautic\LeadBundle\LeadEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class LeadSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private AssetModel $assetModel,
+        private TranslatorInterface $translator,
+        private RouterInterface $router,
+        private DownloadRepository $downloadRepository,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
+            LeadEvents::CURRENT_LEAD_CHANGED => ['onLeadChange', 0],
+            LeadEvents::LEAD_POST_MERGE      => ['onLeadMerge', 0],
+        ];
+    }
+    /**
+     * Compile events for the lead timeline.
+     */
+    public function onTimelineGenerate(LeadTimelineEvent $event): void
+    {
+        $eventTypeKey  = 'asset.download';
+        $eventTypeName = $this->translator->trans('mautic.asset.event.download');
+        $event->addEventType($eventTypeKey, $eventTypeName);
+        $event->addSerializerGroup('assetList');
+        if (!$event->isApplicable($eventTypeKey)) {
+            return;
+        }
+        $downloads = $this->downloadRepository->getLeadDownloads($event->getLeadId(), $event->getQueryOptions());
+        $event->addToCounter($eventTypeKey, $downloads);
+        if (!$event->isEngagementCount()) {
+            foreach ($downloads['results'] as $download) {
+                $asset = $this->assetModel->getEntity($download['asset_id']);
+                $event->addEvent(
+                    [
+                        'event'      => $eventTypeKey,
+                        'eventId'    => $eventTypeKey.$download['download_id'],
+                        'eventLabel' => [
+                            'label' => $download['title'],
+                            'href'  => $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $download['asset_id']]),
+                        ],
+                        'extra' => [
+                            'asset'            => $asset,
+                            'assetDownloadUrl' => $this->assetModel->generateUrl($asset),
+                        ],
+                        'eventType'       => $eventTypeName,
+                        'timestamp'       => $download['dateDownload'],
+                        'icon'            => 'ri-download-line',
+                        'contentTemplate' => '@MauticAsset/SubscribedEvents/Timeline/index.html.twig',
+                        'contactId'       => $download['lead_id'],
+                    ]
+                );
+            }
+        }
+    }
+    public function onLeadChange(LeadChangeEvent $event): void
+    {
+        $this->assetModel->getDownloadRepository()->updateLeadByTrackingId(
+            $event->getNewLead()->getId(),
+            $event->getNewTrackingId(),
+            $event->getOldTrackingId()
+        );
+    }
+    public function onLeadMerge(LeadMergeEvent $event): void
+    {
+        $this->assetModel->getDownloadRepository()->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/PointSubscriber.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Event\AssetLoadEvent;
+use Mautic\AssetBundle\Form\Type\PointActionAssetDownloadType;
+use Mautic\PointBundle\Event\PointBuilderEvent;
+use Mautic\PointBundle\Model\PointModel;
+use Mautic\PointBundle\PointEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class PointSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private PointModel $pointModel,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            PointEvents::POINT_ON_BUILD => ['onPointBuild', 0],
+            AssetEvents::ASSET_ON_LOAD  => ['onAssetDownload', 0],
+        ];
+    }
+    public function onPointBuild(PointBuilderEvent $event): void
+    {
+        $action = [
+            'group'       => 'mautic.asset.actions',
+            'label'       => 'mautic.asset.point.action.download',
+            'description' => 'mautic.asset.point.action.download_descr',
+            'callback'    => [\Mautic\AssetBundle\Helper\PointActionHelper::class, 'validateAssetDownload'],
+            'formType'    => PointActionAssetDownloadType::class,
+        ];
+        $event->addAction('asset.download', $action);
+    }
+    /**
+     * Trigger point actions for asset download.
+     */
+    public function onAssetDownload(AssetLoadEvent $event): void
+    {
+        $asset = $event->getRecord()->getAsset();
+        if (null !== $asset) {
+            $this->pointModel->triggerAction('asset.download', $asset);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/ReportSubscriber.php
@@ -0,0 +1,231 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Entity\DownloadRepository;
+use Mautic\CoreBundle\Helper\Chart\LineChart;
+use Mautic\LeadBundle\Model\CompanyReportData;
+use Mautic\ReportBundle\Event\ReportBuilderEvent;
+use Mautic\ReportBundle\Event\ReportGeneratorEvent;
+use Mautic\ReportBundle\Event\ReportGraphEvent;
+use Mautic\ReportBundle\ReportEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class ReportSubscriber implements EventSubscriberInterface
+{
+    public const CONTEXT_ASSET          = 'assets';
+    public const CONTEXT_ASSET_DOWNLOAD = 'asset.downloads';
+    public function __construct(
+        private CompanyReportData $companyReportData,
+        private DownloadRepository $downloadRepository,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ReportEvents::REPORT_ON_BUILD          => ['onReportBuilder', 0],
+            ReportEvents::REPORT_ON_GENERATE       => ['onReportGenerate', 0],
+            ReportEvents::REPORT_ON_GRAPH_GENERATE => ['onReportGraphGenerate', 0],
+        ];
+    }
+    /**
+     * Add available tables and columns to the report builder lookup.
+     */
+    public function onReportBuilder(ReportBuilderEvent $event): void
+    {
+        if (!$event->checkContext([self::CONTEXT_ASSET, self::CONTEXT_ASSET_DOWNLOAD])) {
+            return;
+        }
+        $prefix  = 'a.';
+        $columns = [
+            $prefix.'download_count' => [
+                'alias' => 'download_count',
+                'label' => 'mautic.asset.report.download_count',
+                'type'  => 'int',
+            ],
+            $prefix.'unique_download_count' => [
+                'alias' => 'unique_download_count',
+                'label' => 'mautic.asset.report.unique_download_count',
+                'type'  => 'int',
+            ],
+            $prefix.'alias' => [
+                'label' => 'mautic.core.alias',
+                'type'  => 'string',
+            ],
+            $prefix.'lang' => [
+                'label' => 'mautic.core.language',
+                'type'  => 'string',
+            ],
+            $prefix.'title' => [
+                'label' => 'mautic.core.title',
+                'type'  => 'string',
+            ],
+        ];
+        $columns = array_merge(
+            $columns,
+            $event->getStandardColumns($prefix, ['name'], 'mautic_asset_action'),
+            $event->getCategoryColumns()
+        );
+        $event->addTable(
+            self::CONTEXT_ASSET,
+            [
+                'display_name' => 'mautic.asset.assets',
+                'columns'      => $columns,
+            ]
+        );
+        if ($event->checkContext([self::CONTEXT_ASSET_DOWNLOAD])) {
+            $columns[$prefix.'download_count']['formula']        = 'COUNT(ad.id)';
+            $columns[$prefix.'unique_download_count']['formula'] = 'COUNT(DISTINCT ad.lead_id)';
+            $downloadPrefix  = 'ad.';
+            $downloadColumns = [
+                $downloadPrefix.'date_download' => [
+                    'label'          => 'mautic.asset.report.download.date_download',
+                    'type'           => 'datetime',
+                    'groupByFormula' => 'DATE('.$downloadPrefix.'date_download)',
+                ],
+                $downloadPrefix.'code' => [
+                    'label' => 'mautic.asset.report.download.code',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'referer' => [
+                    'label' => 'mautic.core.referer',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'source' => [
+                    'label' => 'mautic.report.field.source',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'source_id' => [
+                    'label' => 'mautic.report.field.source_id',
+                    'type'  => 'int',
+                ],
+                $downloadPrefix.'utm_campaign' => [
+                    'label' => 'mautic.report.field.utm_campaign',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'utm_content' => [
+                    'label' => 'mautic.report.field.utm_content',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'utm_medium' => [
+                    'label' => 'mautic.report.field.utm_medium',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'utm_source' => [
+                    'label' => 'mautic.report.field.utm_source',
+                    'type'  => 'string',
+                ],
+                $downloadPrefix.'utm_term' => [
+                    'label' => 'mautic.report.field.utm_term',
+                    'type'  => 'string',
+                ],
+            ];
+            $companyColumns = $this->companyReportData->getCompanyData();
+            $event->addTable(
+                self::CONTEXT_ASSET_DOWNLOAD,
+                [
+                    'display_name' => 'mautic.asset.report.downloads.table',
+                    'columns'      => array_merge(
+                        $columns,
+                        $downloadColumns,
+                        $event->getCampaignByChannelColumns(),
+                        $event->getLeadColumns(),
+                        $event->getIpColumn(),
+                        $companyColumns
+                    ),
+                ],
+                self::CONTEXT_ASSET
+            );
+            $context = self::CONTEXT_ASSET_DOWNLOAD;
+            $event->addGraph($context, 'line', 'mautic.asset.graph.line.downloads');
+            $event->addGraph($context, 'table', 'mautic.asset.table.most.downloaded');
+            $event->addGraph($context, 'table', 'mautic.asset.table.top.referrers');
+            $event->addGraph($context, 'pie', 'mautic.asset.graph.pie.statuses', ['translate' => false]);
+        }
+    }
+    /**
+     * Initialize the QueryBuilder object to generate reports from.
+     */
+    public function onReportGenerate(ReportGeneratorEvent $event): void
+    {
+        if (!$event->checkContext([self::CONTEXT_ASSET, self::CONTEXT_ASSET_DOWNLOAD])) {
+            return;
+        }
+        $queryBuilder = $event->getQueryBuilder();
+        if ($event->checkContext(self::CONTEXT_ASSET)) {
+            $queryBuilder->from(MAUTIC_TABLE_PREFIX.'assets', 'a');
+            $event->addCategoryLeftJoin($queryBuilder, 'a');
+        } elseif ($event->checkContext(self::CONTEXT_ASSET_DOWNLOAD)) {
+            $event->applyDateFilters($queryBuilder, 'date_download', 'ad');
+            $queryBuilder->from(MAUTIC_TABLE_PREFIX.'asset_downloads', 'ad')
+                ->leftJoin('ad', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = ad.asset_id');
+            $event->addCategoryLeftJoin($queryBuilder, 'a');
+            $event->addLeadLeftJoin($queryBuilder, 'ad');
+            $event->addIpAddressLeftJoin($queryBuilder, 'ad');
+            $event->addCampaignByChannelJoin($queryBuilder, 'a', 'asset');
+            if ($this->companyReportData->eventHasCompanyColumns($event)) {
+                $event->addCompanyLeftJoin($queryBuilder);
+            }
+            if (!$event->hasGroupBy()) {
+                $queryBuilder->groupBy('ad.id');
+            }
+        }
+        $event->setQueryBuilder($queryBuilder);
+    }
+    /**
+     * Initialize the QueryBuilder object to generate reports from.
+     */
+    public function onReportGraphGenerate(ReportGraphEvent $event): void
+    {
+        if (!$event->checkContext(self::CONTEXT_ASSET_DOWNLOAD)) {
+            return;
+        }
+        $graphs = $event->getRequestedGraphs();
+        $qb     = $event->getQueryBuilder();
+        foreach ($graphs as $g) {
+            $options      = $event->getOptions($g);
+            $queryBuilder = clone $qb;
+            $chartQuery   = clone $options['chartQuery'];
+            $chartQuery->applyDateFilters($queryBuilder, 'date_download', 'ad');
+            switch ($g) {
+                case 'mautic.asset.graph.line.downloads':
+                    $chart = new LineChart(null, $options['dateFrom'], $options['dateTo']);
+                    $chartQuery->modifyTimeDataQuery($queryBuilder, 'date_download', 'ad');
+                    $downloads = $chartQuery->loadAndBuildTimeData($queryBuilder);
+                    $chart->setDataset($options['translator']->trans($g), $downloads);
+                    $data         = $chart->render();
+                    $data['name'] = $g;
+                    $event->setGraph($g, $data);
+                    break;
+                case 'mautic.asset.table.most.downloaded':
+                    $limit                  = 10;
+                    $offset                 = 0;
+                    $items                  = $this->downloadRepository->getMostDownloaded($queryBuilder, $limit, $offset);
+                    $graphData              = [];
+                    $graphData['data']      = $items;
+                    $graphData['name']      = $g;
+                    $graphData['iconClass'] = 'ri-download-line';
+                    $graphData['link']      = 'mautic_asset_action';
+                    $event->setGraph($g, $graphData);
+                    break;
+                case 'mautic.asset.table.top.referrers':
+                    $limit                  = 10;
+                    $offset                 = 0;
+                    $items                  = $this->downloadRepository->getTopReferrers($queryBuilder, $limit, $offset);
+                    $graphData              = [];
+                    $graphData['data']      = $items;
+                    $graphData['name']      = $g;
+                    $graphData['iconClass'] = 'ri-download-line';
+                    $graphData['link']      = 'mautic_asset_action';
+                    $event->setGraph($g, $graphData);
+                    break;
+                case 'mautic.asset.graph.pie.statuses':
+                    $items                  = $this->downloadRepository->getHttpStatuses($queryBuilder);
+                    $graphData              = [];
+                    $graphData['data']      = $items;
+                    $graphData['name']      = $g;
+                    $graphData['iconClass'] = 'ri-earth-line';
+                    $event->setGraph($g, $graphData);
+                    break;
+            }
+            unset($queryBuilder);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/SearchSubscriber.php
@@ -0,0 +1,47 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
+use Mautic\CoreBundle\Event as MauticEvents;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\GlobalSearch;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class SearchSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private AssetModel $assetModel,
+        private CorePermissions $security,
+        private GlobalSearch $globalSearch,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
+            CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
+        ];
+    }
+    public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
+    {
+        $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
+        $results   = $this->globalSearch->performSearch(
+            $filterDTO,
+            $this->assetModel,
+            '@MauticAsset/SubscribedEvents/Search/global.html.twig'
+        );
+        if (!empty($results)) {
+            $event->addResults('mautic.asset.assets', $results);
+        }
+    }
+    public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
+    {
+        if ($this->security->isGranted(['asset:assets:viewown', 'asset:assets:viewother'], 'MATCH_ONE')) {
+            $event->addCommands(
+                'mautic.asset.assets',
+                $this->assetModel->getCommandList()
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/EventListener/UploadSubscriber.php
@@ -0,0 +1,89 @@
+<?php
+namespace Mautic\AssetBundle\EventListener;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Exception\FileInvalidException;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\CoreBundle\Validator\FileUploadValidator;
+use Oneup\UploaderBundle\Event\PostUploadEvent;
+use Oneup\UploaderBundle\Event\ValidationEvent;
+use Oneup\UploaderBundle\Uploader\Exception\ValidationException;
+use Oneup\UploaderBundle\UploadEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class UploadSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+        private AssetModel $assetModel,
+        protected Translator $translator,
+        private FileUploadValidator $fileUploadValidator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            UploadEvents::POST_UPLOAD => ['onPostUpload', 0],
+            UploadEvents::VALIDATION  => ['onUploadValidation', 0],
+        ];
+    }
+    /**
+     * Moves upladed file to temporary directory where it can be found later
+     * and all uploaded files in there cleared. Also sets file name to the response.
+     */
+    public function onPostUpload(PostUploadEvent $event): void
+    {
+        $request   = $event->getRequest()->request;
+        $response  = $event->getResponse();
+        $tempId    = basename($request->get('tempId'));
+        $file      = $event->getFile();
+        $config    = $event->getConfig();
+        $uploadDir = $config['storage']['directory'];
+        $tmpDir    = $uploadDir.'/tmp/'.$tempId;
+        $file->move($tmpDir);
+        $response['state']       = 1;
+        $response['tmpFileName'] = $file->getBasename();
+    }
+    /**
+     * Validates file before upload.
+     *
+     * @throws ValidationException
+     */
+    public function onUploadValidation(ValidationEvent $event): void
+    {
+        $file       = $event->getFile();
+        $mimetypes  = $this->coreParametersHelper->get('allowed_mimetypes');
+        $extensions = array_keys($mimetypes);
+        $maxSize    = $this->assetModel->getMaxUploadSize('B');
+        if (null === $file) {
+            return;
+        }
+        try {
+            $this->fileUploadValidator->checkFileSize($file->getSize(), $maxSize, 'mautic.asset.asset.error.file.size');
+        } catch (FileInvalidException $e) {
+            throw new ValidationException($e->getMessage());
+        }
+        try {
+            $this->fileUploadValidator->checkExtension($file->getExtension(), $extensions, 'mautic.asset.asset.error.file.extension');
+        } catch (FileInvalidException $e) {
+            throw new ValidationException($e->getMessage());
+        }
+        try {
+            $this->checkMimeType($file->getMimeType(), $mimetypes, 'mautic.asset.asset.error.file.mimetype');
+        } catch (FileInvalidException $e) {
+            throw new ValidationException($e->getMessage());
+        }
+    }
+    /**
+     * @param array<string,string> $allowedMimeTypes
+     */
+    private function checkMimeType(string $mimeType, array $allowedMimeTypes, string $extensionErrorMsg): void
+    {
+        if (!in_array(strtolower($mimeType), array_map('strtolower', $allowedMimeTypes), true)) {
+            $error = $this->translator->trans($extensionErrorMsg, [
+                '%fileMimetype%' => $mimeType,
+                '%mimetypes%'    => implode(', ', $allowedMimeTypes),
+            ], 'validators');
+            throw new FileInvalidException($error);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/AssetListType.php
@@ -0,0 +1,47 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class AssetListType extends AbstractType
+{
+    public function __construct(
+        private CorePermissions $corePermissions,
+        private AssetModel $assetModel,
+        private UserHelper $userHelper,
+    ) {
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'choices'           => $this->getAssetChoices(),
+            'placeholder'       => false,
+            'expanded'          => false,
+            'multiple'          => true,
+            'required'          => false,
+        ]);
+    }
+    public function getParent(): ?string
+    {
+        return ChoiceType::class;
+    }
+    private function getAssetChoices(): array
+    {
+        $choices   = [];
+        $viewOther = $this->corePermissions->isGranted('asset:assets:viewother');
+        $repo      = $this->assetModel->getRepository();
+        $repo->setCurrentUser($this->userHelper->getUser());
+        $assets = $repo->getAssetList('', 0, 0, $viewOther);
+        foreach ($assets as $asset) {
+            $choices[$asset['language']][$asset['title']] = $asset['id'];
+        }
+        ksort($choices);
+        return $choices;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/AssetType.php
@@ -0,0 +1,204 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Mautic\AssetBundle\Entity\Asset;
+use Mautic\AssetBundle\Model\AssetModel;
+use Mautic\CategoryBundle\Form\Type\CategoryListType;
+use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
+use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
+use Mautic\CoreBundle\Form\Type\ButtonGroupType;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Mautic\CoreBundle\Form\Type\PublishDownDateType;
+use Mautic\CoreBundle\Form\Type\PublishUpDateType;
+use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
+use Mautic\CoreBundle\Loader\ParameterLoader;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\Extension\Core\Type\LocaleType;
+use Symfony\Component\Form\Extension\Core\Type\TextareaType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Validator\Constraints\Callback;
+use Symfony\Component\Validator\Constraints\NotBlank;
+use Symfony\Component\Validator\Constraints\Url;
+use Symfony\Component\Validator\Context\ExecutionContextInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<Asset>
+ */
+class AssetType extends AbstractType
+{
+    public function __construct(
+        private TranslatorInterface $translator,
+        private AssetModel $assetModel,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->addEventSubscriber(new CleanFormSubscriber(['description' => 'html']));
+        $builder->addEventSubscriber(new FormExitSubscriber('asset.asset', $options));
+        $builder->add('storageLocation', ButtonGroupType::class, [
+            'label'   => 'mautic.asset.asset.form.storageLocation',
+            'choices' => [
+                'mautic.asset.asset.form.storageLocation.local'  => 'local',
+                'mautic.asset.asset.form.storageLocation.remote' => 'remote',
+            ],
+            'attr'              => [
+                'onchange' => 'Mautic.changeAssetStorageLocation();',
+            ],
+        ]);
+        $maxUploadSize = $this->assetModel->getMaxUploadSize('', true);
+        $builder->add(
+            'tempName',
+            HiddenType::class,
+            [
+                'label'       => $this->translator->trans('mautic.asset.asset.form.file.upload', ['%max%' => $maxUploadSize]),
+                'label_attr'  => ['class' => 'control-label'],
+                'required'    => false,
+                'constraints' => [
+                    new Callback([$this, 'validateExtension']),
+                ],
+            ]
+        );
+        $builder->add(
+            'originalFileName',
+            HiddenType::class,
+            [
+                'required'    => false,
+                'constraints' => [
+                    new Callback([$this, 'validateExtension']),
+                ],
+            ],
+        );
+        $builder->add(
+            'disallow',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.asset.asset.form.disallow.crawlers',
+                'attr'  => [
+                    'tooltip'      => 'mautic.asset.asset.form.disallow.crawlers.descr',
+                    'data-show-on' => '{"asset_storageLocation_0":"checked"}',
+                ],
+                'data'=> empty($options['data']->getDisallow()) ? false : true,
+            ]
+        );
+        $builder->add(
+            'remotePath',
+            TextType::class,
+            [
+                'label'       => 'mautic.asset.asset.form.remotePath',
+                'label_attr'  => ['class' => 'control-label'],
+                'attr'        => ['class' => 'form-control'],
+                'required'    => false,
+                'constraints' => [
+                    new Url(
+                        [
+                            'message' => 'mautic.asset.validation.error.url',
+                        ]
+                    ),
+                ],
+            ]
+        );
+        $builder->add(
+            'title',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.title',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+            ]
+        );
+        $builder->add(
+            'alias',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.alias',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.asset.help.alias',
+                ],
+                'required' => false,
+            ]
+        );
+        $builder->add(
+            'description',
+            TextareaType::class,
+            [
+                'label'      => 'mautic.core.description',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control editor'],
+                'required'   => false,
+            ]
+        );
+        $builder->add(
+            'category',
+            CategoryListType::class,
+            [
+                'bundle' => 'asset',
+            ]
+        );
+        $builder->add('language', LocaleType::class, [
+            'label'      => 'mautic.core.language',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => [
+                'class'   => 'form-control',
+                'tooltip' => 'mautic.asset.asset.form.language.help',
+            ],
+            'required'    => true,
+            'constraints' => [
+                new NotBlank(
+                    [
+                        'message' => 'mautic.core.value.required',
+                    ]
+                ),
+            ],
+        ]);
+        $builder->add('isPublished', YesNoButtonGroupType::class, [
+            'label' => 'mautic.core.form.available',
+        ]);
+        $builder->add('publishUp', PublishUpDateType::class);
+        $builder->add('publishDown', PublishDownDateType::class);
+        $builder->add(
+            'tempId',
+            HiddenType::class,
+            [
+                'required' => false,
+            ]
+        );
+        $builder->add('buttons', FormButtonsType::class, []);
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+    }
+    /**
+     * @param Asset|string|null $object
+     */
+    public function validateExtension($object, ExecutionContextInterface $context): void
+    {
+        if (empty($object)) {
+            return;
+        }
+        $parameters       = (new ParameterLoader())->getParameterBag();
+        $mimeTypesAllowed = $parameters->get('allowed_mimetypes');
+        $extensions       = array_keys($mimeTypesAllowed);
+        $fileName         = $object;
+        if (!is_string($object) && $object instanceof Asset) {
+            $fileName = $object->getOriginalFileName();
+        }
+        $fileExtension    = pathinfo($fileName, PATHINFO_EXTENSION);
+        if (!in_array($fileExtension, $extensions, true)) {
+            $context->buildViolation('mautic.asset.asset.error.file.extension', [
+                '%fileExtension%'=> $fileExtension,
+                '%extensions%'   => implode(', ', $extensions),
+            ])
+                ->atPath('file')
+                ->setTranslationDomain('validators')
+                ->addViolation();
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(['data_class' => Asset::class]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/CampaignEventAssetDownloadType.php
@@ -0,0 +1,29 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CampaignEventAssetDownloadType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'assets',
+            AssetListType::class,
+            [
+                'label'      => 'mautic.asset.campaign.event.assets',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.campaign.event.assets.descr',
+                ],
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent_assetdownload';
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/ConfigType.php
@@ -0,0 +1,70 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Mautic\CoreBundle\Form\DataTransformer\ArrayStringTransformer;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints\NotBlank;
+/**
+ * @extends AbstractType<mixed>
+ */
+class ConfigType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'upload_dir',
+            TextType::class,
+            [
+                'label'      => 'mautic.asset.config.form.upload.dir',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.config.form.upload.dir.tooltip',
+                ],
+                'constraints' => [
+                    new NotBlank([
+                        'message' => 'mautic.core.value.required',
+                    ]),
+                ],
+            ]
+        );
+        $builder->add(
+            'max_size',
+            TextType::class,
+            [
+                'label'      => 'mautic.asset.config.form.max.size',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.config.form.max.size.tooltip',
+                ],
+                'constraints' => [
+                    new NotBlank([
+                        'message' => 'mautic.core.value.required',
+                    ]),
+                ],
+            ]
+        );
+        $arrayStringTransformer = new ArrayStringTransformer();
+        $builder->add(
+            $builder->create(
+                'allowed_extensions',
+                TextType::class,
+                [
+                    'label'      => 'mautic.asset.config.form.allowed.extensions',
+                    'label_attr' => ['class' => 'control-label'],
+                    'attr'       => [
+                        'class'   => 'form-control',
+                        'tooltip' => 'mautic.asset.config.form.allowed.extensions.tooltip',
+                    ],
+                    'required' => false,
+                ]
+            )->addViewTransformer($arrayStringTransformer)
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'assetconfig';
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/FormSubmitActionDownloadFileType.php
@@ -0,0 +1,51 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Mautic\CategoryBundle\Form\Type\CategoryListType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class FormSubmitActionDownloadFileType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'asset',
+            AssetListType::class,
+            [
+                'expanded'    => false,
+                'multiple'    => false,
+                'label'       => 'mautic.asset.form.submit.assets',
+                'label_attr'  => ['class' => 'control-label'],
+                'placeholder' => 'mautic.asset.form.submit.latest.category',
+                'required'    => false,
+                'attr'        => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.form.submit.assets_descr',
+                ],
+            ]
+        );
+        $builder->add(
+            'category',
+            CategoryListType::class,
+            [
+                'label'         => 'mautic.asset.form.submit.latest.category',
+                'label_attr'    => ['class' => 'control-label'],
+                'placeholder'   => false,
+                'required'      => false,
+                'bundle'        => 'asset',
+                'return_entity' => false,
+                'attr'          => [
+                    'class'        => 'form-control',
+                    'tooltip'      => 'mautic.asset.form.submit.latest.category_descr',
+                    'data-show-on' => '{"formaction_properties_asset":""}',
+                ],
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'asset_submitaction_downloadfile';
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Form/Type/PointActionAssetDownloadType.php
@@ -0,0 +1,33 @@
+<?php
+namespace Mautic\AssetBundle\Form\Type;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class PointActionAssetDownloadType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'assets',
+            AssetListType::class,
+            [
+                'expanded'    => false,
+                'multiple'    => true,
+                'label'       => 'mautic.asset.point.action.assets',
+                'label_attr'  => ['class' => 'control-label'],
+                'placeholder' => false,
+                'required'    => false,
+                'attr'        => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.asset.point.action.assets.descr',
+                ],
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'pointaction_assetdownload';
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Helper/TokenHelper.php
@@ -0,0 +1,24 @@
+<?php
+namespace Mautic\AssetBundle\Helper;
+use Mautic\AssetBundle\Model\AssetModel;
+class TokenHelper
+{
+    public function __construct(
+        protected AssetModel $model,
+    ) {
+    }
+    public function findAssetTokens($content, $clickthrough = []): array
+    {
+        $tokens = [];
+        preg_match_all('/{assetlink=(.*?)}/', $content, $matches);
+        foreach ($matches[1] as $key => $assetId) {
+            $token = $matches[0][$key];
+            if (isset($tokens[$token])) {
+                continue;
+            }
+            $asset          = $this->model->getEntity($assetId);
+            $tokens[$token] = (null !== $asset) ? $this->model->generateUrl($asset, true, $clickthrough) : '';
+        }
+        return $tokens;
+    }
+}

--- a//dev/null
+++ b/app/bundles/AssetBundle/Model/AssetModel.php
@@ -0,0 +1,525 @@
+<?php
+namespace Mautic\AssetBundle\Model;
+use Doctrine\ORM\EntityManager;
+use Doctrine\ORM\PersistentCollection;
+use Mautic\AssetBundle\AssetEvents;
+use Mautic\AssetBundle\Entity\Asset;
+use Mautic\AssetBundle\Entity\Download;
+use Mautic\AssetBundle\Event\AssetEvent;
+use Mautic\AssetBundle\Event\AssetLoadEvent;
+use Mautic\AssetBundle\Form\Type\AssetType;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CoreBundle\Helper\Chart\ChartQuery;
+use Mautic\CoreBundle\Helper\Chart\LineChart;
+use Mautic\CoreBundle\Helper\Chart\PieChart;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\FileHelper;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Model\GlobalSearchInterface;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\EmailBundle\Entity\Email;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\LeadModel;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+use Mautic\LeadBundle\Tracker\Factory\DeviceDetectorFactory\DeviceDetectorFactoryInterface;
+use Mautic\LeadBundle\Tracker\Service\DeviceCreatorService\DeviceCreatorServiceInterface;
+use Mautic\LeadBundle\Tracker\Service\DeviceTrackingService\DeviceTrackingServiceInterface;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @extends FormModel<Asset>
+ */
+class AssetModel extends FormModel implements GlobalSearchInterface
+{
+    /**
+     * @var int
+     */
+    protected $maxAssetSize;
+    public function __construct(
+        protected LeadModel $leadModel,
+        protected CategoryModel $categoryModel,
+        private RequestStack $requestStack,
+        protected IpLookupHelper $ipLookupHelper,
+        private DeviceCreatorServiceInterface $deviceCreatorService,
+        private DeviceDetectorFactoryInterface $deviceDetectorFactory,
+        private DeviceTrackingServiceInterface $deviceTrackingService,
+        private ContactTracker $contactTracker,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $logger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        $this->maxAssetSize           = $coreParametersHelper->get('max_size');
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $logger, $coreParametersHelper);
+    }
+    public function saveEntity($entity, $unlock = true): void
+    {
+        if (empty($this->inConversion)) {
+            $alias = $entity->getAlias();
+            if (empty($alias)) {
+                $alias = $entity->getTitle();
+            }
+            $alias = $this->cleanAlias($alias, '', 0, '-');
+            $repo      = $this->getRepository();
+            $testAlias = $alias;
+            $count     = $repo->checkUniqueAlias($testAlias, $entity);
+            $aliasTag  = $count;
+            while ($count) {
+                $testAlias = $alias.$aliasTag;
+                $count     = $repo->checkUniqueAlias($testAlias, $entity);
+                ++$aliasTag;
+            }
+            if ($testAlias != $alias) {
+                $alias = $testAlias;
+            }
+            $entity->setAlias($alias);
+        }
+        if (!$entity->isNew()) {
+            $revision = $entity->getRevision();
+            ++$revision;
+            $entity->setRevision($revision);
+        }
+        parent::saveEntity($entity, $unlock);
+    }
+    /**
+     * @param array $systemEntry
+     *
+     * @throws \Doctrine\ORM\ORMException
+     * @throws \Exception
+     */
+    public function trackDownload($asset, $request = null, int $code = 200, $systemEntry = []): void
+    {
+        if (empty($systemEntry) && !$this->security->isAnonymous()) {
+            return;
+        }
+        if (null == $request) {
+            $request = $this->requestStack->getCurrentRequest();
+        }
+        if (!($request instanceof Request)) {
+            return;
+        }
+        $download = new Download();
+        $download->setDateDownload(new \DateTime());
+        $download->setUtmCampaign($request->get('utm_campaign'));
+        $download->setUtmContent($request->get('utm_content'));
+        $download->setUtmMedium($request->get('utm_medium'));
+        $download->setUtmSource($request->get('utm_source'));
+        $download->setUtmTerm($request->get('utm_term'));
+        if (empty($systemEntry)) {
+            $clickthrough = $request->get('ct', false);
+            if (!empty($clickthrough)) {
+                $clickthrough = $this->decodeArrayFromUrl($clickthrough);
+                if (!empty($clickthrough['lead'])) {
+                    $lead = $this->leadModel->getEntity($clickthrough['lead']);
+                    if (null !== $lead) {
+                        $wasTrackedAlready                    = $this->deviceTrackingService->isTracked();
+                        $deviceDetector                       = $this->deviceDetectorFactory->create($request->server->get('HTTP_USER_AGENT'));
+                        $deviceDetector->parse();
+                        $currentDevice                             = $this->deviceCreatorService->getCurrentFromDetector($deviceDetector, $lead);
+                        $trackedDevice                             = $this->deviceTrackingService->trackCurrentDevice($currentDevice, false);
+                        $trackingId                                = $trackedDevice->getTrackingId();
+                        $trackingNewlyGenerated                    = !$wasTrackedAlready;
+                        $leadClickthrough                          = true;
+                        $this->contactTracker->setTrackedContact($lead);
+                    }
+                }
+                if (!empty($clickthrough['channel'])) {
+                    if (1 === count($clickthrough['channel'])) {
+                        $channelId = reset($clickthrough['channel']);
+                        $channel   = key($clickthrough['channel']);
+                    } else {
+                        $channel   = $clickthrough['channel'][0];
+                        $channelId = (int) $clickthrough['channel'][1];
+                    }
+                    $download->setSource($channel);
+                    $download->setSourceId($channelId);
+                } elseif (!empty($clickthrough['source'])) {
+                    $download->setSource($clickthrough['source'][0]);
+                    $download->setSourceId($clickthrough['source'][1]);
+                }
+                if (!empty($clickthrough['email'])) {
+                    $emailRepo = $this->em->getRepository(Email::class);
+                    if ($emailEntity = $emailRepo->getEntity($clickthrough['email'])) {
+                        $download->setEmail($emailEntity);
+                    }
+                }
+            }
+            if (empty($leadClickthrough)) {
+                $wasTrackedAlready         = $this->deviceTrackingService->isTracked();
+                $lead                      = $this->contactTracker->getContact();
+                $trackedDevice             = $this->deviceTrackingService->getTrackedDevice();
+                $trackingId                = null;
+                $trackingNewlyGenerated    = false;
+                if (null !== $trackedDevice) {
+                    $trackingId             = $trackedDevice->getTrackingId();
+                    $trackingNewlyGenerated = !$wasTrackedAlready;
+                }
+            }
+            $download->setLead($lead);
+        } else {
+            $trackingId = '';
+            if (isset($systemEntry['lead'])) {
+                $lead = $systemEntry['lead'];
+                if (!$lead instanceof Lead) {
+                    $leadId = is_array($lead) ? $lead['id'] : $lead;
+                    $lead   = $this->em->getReference(Lead::class, $leadId);
+                }
+                $download->setLead($lead);
+            }
+            if (!empty($systemEntry['source'])) {
+                $download->setSource($systemEntry['source'][0]);
+                $download->setSourceId($systemEntry['source'][1]);
+            }
+            if (isset($systemEntry['email'])) {
+                $email = $systemEntry['email'];
+                if (!$email instanceof Email) {
+                    $emailId = is_array($email) ? $email['id'] : $email;
+                    $email   = $this->em->getReference(Email::class, $emailId);
+                }
+                $download->setEmail($email);
+            }
+            if (isset($systemEntry['tracking_id'])) {
+                $trackingId             = $systemEntry['tracking_id'];
+                $trackingNewlyGenerated = false;
+            } elseif ($this->security->isAnonymous() && !defined('IN_MAUTIC_CONSOLE')) {
+                $deviceWasTracked       = $this->deviceTrackingService->isTracked();
+                $deviceDetector         = $this->deviceDetectorFactory->create($request->server->get('HTTP_USER_AGENT'));
+                $deviceDetector->parse();
+                $currentDevice          = $this->deviceCreatorService->getCurrentFromDetector($deviceDetector, $lead);
+                $trackedDevice          = $this->deviceTrackingService->trackCurrentDevice($currentDevice, false);
+                $trackingId             = $trackedDevice->getTrackingId();
+                $trackingNewlyGenerated = !$deviceWasTracked;
+            }
+        }
+        $isUnique = true;
+        if (!empty($trackingNewlyGenerated)) {
+            $isUnique = $trackingNewlyGenerated;
+        } elseif (!empty($trackingId)) {
+            $isUnique = $this->getDownloadRepository()->isUniqueDownload($asset->getId(), $trackingId);
+        }
+        $download->setTrackingId($trackingId);
+        if (empty($systemEntry)) {
+            $download->setAsset($asset);
+            $this->getRepository()->upDownloadCount($asset->getId(), 1, $isUnique);
+        }
+        $ipAddress = $this->ipLookupHelper->getIpAddress();
+        $download->setCode($code);
+        $download->setIpAddress($ipAddress);
+        $download->setReferer($request->server->get('HTTP_REFERER'));
+        if ($this->dispatcher->hasListeners(AssetEvents::ASSET_ON_LOAD)) {
+            $event = new AssetLoadEvent($download, $isUnique);
+            $this->dispatcher->dispatch($event, AssetEvents::ASSET_ON_LOAD);
+        }
+        try {
+            $this->em->persist($download);
+            $this->em->flush();
+        } catch (\Exception $e) {
+            if (MAUTIC_ENV === 'dev') {
+                throw $e;
+            } else {
+                error_log($e);
+            }
+        }
+        $this->em->detach($download);
+    }
+    /**
+     * Increase the download count.
+     *
+     * @param int        $increaseBy
+     * @param bool|false $unique
+     */
+    public function upDownloadCount($asset, $increaseBy = 1, $unique = false): void
+    {
+        $id = ($asset instanceof Asset) ? $asset->getId() : (int) $asset;
+        $this->getRepository()->upDownloadCount($id, $increaseBy, $unique);
+    }
+    /**
+     * @return \Mautic\AssetBundle\Entity\AssetRepository
+     */
+    public function getRepository()
+    {
+        return $this->em->getRepository(Asset::class);
+    }
+    /**
+     * @return \Mautic\AssetBundle\Entity\DownloadRepository
+     */
+    public function getDownloadRepository()
+    {
+        return $this->em->getRepository(Download::class);
+    }
+    public function getPermissionBase(): string
+    {
+        return 'asset:assets';
+    }
+    public function getNameGetter(): string
+    {
+        return 'getTitle';
+    }
+    /**
+     * @throws NotFoundHttpException
+     */
+    public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
+    {
+        if (!$entity instanceof Asset) {
+            throw new MethodNotAllowedHttpException(['Asset']);
+        }
+        if (!empty($action)) {
+            $options['action'] = $action;
+        }
+        return $formFactory->create(AssetType::class, $entity, $options);
+    }
+    /**
+     * Get a specific entity or generate a new one if id is empty.
+     */
+    public function getEntity($id = null): ?Asset
+    {
+        if (null === $id) {
+            $entity = new Asset();
+        } else {
+            $entity = parent::getEntity($id);
+        }
+        return $entity;
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
+    {
+        if (!$entity instanceof Asset) {
+            throw new MethodNotAllowedHttpException(['Asset']);
+        }
+        switch ($action) {
+            case 'pre_save':
+                $name = AssetEvents::ASSET_PRE_SAVE;
+                break;
+            case 'post_save':
+                $name = AssetEvents::ASSET_POST_SAVE;
+                break;
+            case 'pre_delete':
+                $name = AssetEvents::ASSET_PRE_DELETE;
+                break;
+            case 'post_delete':
+                $name = AssetEvents::ASSET_POST_DELETE;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new AssetEvent($entity, $isNew);
+                $event->setEntityManager($this->em);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        } else {
+            return null;
+        }
+    }
+    /**
+     * Get list of entities for autopopulate fields.
+     *
+     * @return array
+     */
+    public function getLookupResults($type, $filter = '', $limit = 10)
+    {
+        $results = [];
+        switch ($type) {
+            case 'asset':
+                $viewOther = $this->security->isGranted('asset:assets:viewother');
+                $request   = $this->requestStack->getCurrentRequest();
+                $repo      = $this->getRepository();
+                $repo->setCurrentUser($this->userHelper->getUser());
+                if ('mautic_segment_action' === $request->get('_route')
+                    && (Request::METHOD_POST === $request->getMethod() || 'edit' === $request->get('objectAction'))
+                ) {
+                    $limit = 0;
+                }
+                $results = $repo->getAssetList($filter, $limit, 0, $viewOther);
+                break;
+            case 'category':
+                $results = $this->categoryModel->getRepository()->getCategoryList($filter, $limit, 0);
+                break;
+        }
+        return $results;
+    }
+    /**
+     * Generate url for an asset.
+     *
+     * @param Asset $entity
+     * @param bool  $absolute
+     * @param array $clickthrough
+     *
+     * @return string
+     */
+    public function generateUrl($entity, $absolute = true, $clickthrough = [])
+    {
+        $assetSlug = $entity->getId().':'.$entity->getAlias();
+        $slugs = [
+            'slug' => $assetSlug,
+        ];
+        return $this->buildUrl('mautic_asset_download', $slugs, $absolute, $clickthrough);
+    }
+    /**
+     * Determine the max upload size based on PHP restrictions and config.
+     *
+     * @param string     $unit          If '', determine the best unit based on the number
+     * @param bool|false $humanReadable Return as a human readable filesize
+     *
+     * @return float
+     */
+    public function getMaxUploadSize($unit = 'M', $humanReadable = false)
+    {
+        $maxAssetSize  = $this->maxAssetSize;
+        $maxAssetSize  = (-1 == $maxAssetSize || 0 === $maxAssetSize) ? PHP_INT_MAX : FileHelper::convertMegabytesToBytes($maxAssetSize);
+        $maxPostSize   = Asset::getIniValue('post_max_size');
+        $maxUploadSize = Asset::getIniValue('upload_max_filesize');
+        $memoryLimit   = Asset::getIniValue('memory_limit');
+        $maxAllowed    = min(array_filter([$maxAssetSize, $maxPostSize, $maxUploadSize, $memoryLimit]));
+        if ($humanReadable) {
+            $number = Asset::convertBytesToHumanReadable($maxAllowed);
+        } else {
+            [$number, $unit] = Asset::convertBytesToUnit($maxAllowed, $unit);
+        }
+        return $number;
+    }
+    /**
+     * @return int|string
+     */
+    public function getTotalFilesize($assets)
+    {
+        $firstAsset = is_array($assets) ? reset($assets) : false;
+        if ($assets instanceof PersistentCollection || is_object($firstAsset)) {
+            $assetIds = [];
+            foreach ($assets as $asset) {
+                $assetIds[] = $asset->getId();
+            }
+            $assets = $assetIds;
+        }
+        if (!is_array($assets)) {
+            $assets = [$assets];
+        }
+        if (empty($assets)) {
+            return 0;
+        }
+        $repo = $this->getRepository();
+        $size = $repo->getAssetSize($assets);
+        if ($size) {
+            $size = Asset::convertBytesToHumanReadable($size);
+        }
+        return $size;
+    }
+    /**
+     * Get line chart data of downloads.
+     *
+     * @param string|null $unit          {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
+     * @param string      $dateFormat
+     * @param array       $filter
+     * @param bool        $canViewOthers
+     */
+    public function getDownloadsLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = [], $canViewOthers = true): array
+    {
+        $chart = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
+        $query = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $q     = $query->prepareTimeDataQuery('asset_downloads', 'date_download', $filter);
+        if (!$canViewOthers) {
+            $q->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
+                ->andWhere('a.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+        }
+        $data = $query->loadAndBuildTimeData($q);
+        $chart->setDataset($this->translator->trans('mautic.asset.downloadcount'), $data);
+        return $chart->render();
+    }
+    /**
+     * Get pie chart data of unique vs repetitive downloads.
+     * Repetitive in this case mean if a lead downloaded any of the assets more than once.
+     *
+     * @param string $dateFrom
+     * @param string $dateTo
+     * @param array  $filters
+     * @param bool   $canViewOthers
+     */
+    public function getUniqueVsRepetitivePieChartData($dateFrom, $dateTo, $filters = [], $canViewOthers = true): array
+    {
+        $chart   = new PieChart();
+        $query   = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $allQ    = $query->getCountQuery('asset_downloads', 'id', 'date_download', $filters);
+        $uniqueQ = $query->getCountQuery('asset_downloads', 'lead_id', 'date_download', $filters, ['getUnique' => true]);
+        if (!$canViewOthers) {
+            $allQ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
+                ->andWhere('a.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+            $uniqueQ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
+                ->andWhere('a.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+        }
+        $all    = $query->fetchCount($allQ);
+        $unique = $query->fetchCount($uniqueQ);
+        $repetitive = $all - $unique;
+        $chart->setDataset($this->translator->trans('mautic.asset.unique'), $unique);
+        $chart->setDataset($this->translator->trans('mautic.asset.repetitive'), $repetitive);
+        return $chart->render();
+    }
+    /**
+     * Get a list of popular (by downloads) assets.
+     *
+     * @param int    $limit
+     * @param string $dateFrom
+     * @param string $dateTo
+     * @param array  $filters
+     * @param bool   $canViewOthers
+     */
+    public function getPopularAssets($limit = 10, $dateFrom = null, $dateTo = null, $filters = [], $canViewOthers = true): array
+    {
+        $q = $this->em->getConnection()->createQueryBuilder();
+        $q->select('COUNT(DISTINCT t.id) AS download_count, a.id, a.title')
+            ->from(MAUTIC_TABLE_PREFIX.'asset_downloads', 't')
+            ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
+            ->orderBy('download_count', 'DESC')
+            ->groupBy('a.id')
+            ->setMaxResults($limit);
+        if (!$canViewOthers) {
+            $q->andWhere('a.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+        }
+        $chartQuery = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $chartQuery->applyFilters($q, $filters);
+        $chartQuery->applyDateFilters($q, 'date_download');
+        return $q->executeQuery()->fetchAllAssociative();
+    }
+    /**
+     * Get a list of assets in a date range.
+     *
+     * @param int   $limit
+     * @param array $filters
+     * @param array $options
+     */
+    public function getAssetList($limit = 10, \DateTime $dateFrom = null, \DateTime $dateTo = null, $filters = [], $options = []): array
+    {
+        $q = $this->em->getConnection()->createQueryBuilder();
+        $q->select('t.id, t.title as name, t.date_added, t.date_modified')
+            ->from(MAUTIC_TABLE_PREFIX.'assets', 't')
+            ->setMaxResults($limit);
+        if (!empty($options['canViewOthers'])) {
+            $q->andWhere('t.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+        }
+        $chartQuery = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $chartQuery->applyFilters($q, $filters);
+        $chartQuery->applyDateFilters($q, 'date_added');
+        return $q->executeQuery()->fetchAllAssociative();
+    }
+}

--- a//dev/null
+++ b/app/bundles/CacheBundle/Cache/CacheProvider.php
@@ -0,0 +1,135 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CacheBundle\Cache;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Psr\Cache\CacheItemInterface;
+use Psr\Cache\InvalidArgumentException as Psr6CacheInterface;
+use Symfony\Component\Cache\Adapter\TagAwareAdapterInterface;
+use Symfony\Component\Cache\CacheItem;
+use Symfony\Component\Cache\Exception\InvalidArgumentException;
+use Symfony\Component\Cache\Psr16Cache;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+/**
+ * Povides caching mechanism using adapters, it provides both PSR-6 and PSR-16.
+ */
+final class CacheProvider implements CacheProviderInterface
+{
+    private ?Psr16Cache $psr16 = null;
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+        private ContainerInterface $container,
+    ) {
+    }
+    public function getCacheAdapter(): TagAwareAdapterInterface
+    {
+        $selectedAdapter = $this->coreParametersHelper->get('cache_adapter');
+        if (!$selectedAdapter || !$this->container->has($selectedAdapter)) {
+            throw new InvalidArgumentException('Requested cache adapter "'.$selectedAdapter.'" is not available');
+        }
+        $adaptor = $this->container->get($selectedAdapter);
+        if (!$adaptor instanceof TagAwareAdapterInterface) {
+            throw new InvalidArgumentException(sprintf('Requested cache adapter "%s" is not a %s', $selectedAdapter, TagAwareAdapterInterface::class));
+        }
+        return $adaptor;
+    }
+    public function getSimpleCache(): Psr16Cache
+    {
+        if (is_null($this->psr16)) {
+            $this->psr16 = new Psr16Cache($this->getCacheAdapter());
+        }
+        return $this->psr16;
+    }
+    /**
+     * @param string $key
+     *
+     * @throws Psr6CacheInterface
+     */
+    public function getItem($key): CacheItem
+    {
+        return $this->getCacheAdapter()->getItem($key);
+    }
+    /**
+     * @return CacheItem[]|\Traversable
+     *
+     * @throws Psr6CacheInterface
+     */
+    public function getItems(array $keys = []): \Traversable
+    {
+        return $this->getCacheAdapter()->getItems($keys);
+    }
+    /**
+     * @param string $key
+     *
+     * @throws Psr6CacheInterface
+     */
+    public function hasItem($key): bool
+    {
+        return $this->getCacheAdapter()->hasItem($key);
+    }
+    public function clear(string $prefix = ''): bool
+    {
+        return $this->getCacheAdapter()->clear($prefix);
+    }
+    public function deleteItem($key): bool
+    {
+        return $this->getCacheAdapter()->deleteItem($key);
+    }
+    /**
+     * Removes multiple items from the pool.
+     *
+     * @param string[] $keys An array of keys that should be removed from the pool
+     *
+     * @return bool True if the items were successfully removed. False if there was an error.
+     *
+     * @throws Psr6CacheInterface If any of the keys in $keys are not a legal value a \Psr\Cache\InvalidArgumentException
+     *                            MUST be thrown
+     */
+    public function deleteItems(array $keys): bool
+    {
+        return $this->getCacheAdapter()->deleteItems($keys);
+    }
+    /**
+     * Persists a cache item immediately.
+     *
+     * @param CacheItemInterface $item The cache item to save
+     *
+     * @return bool True if the item was successfully persisted. False if there was an error.
+     */
+    public function save(CacheItemInterface $item): bool
+    {
+        return $this->getCacheAdapter()->save($item);
+    }
+    /**
+     * Sets a cache item to be persisted later.
+     *
+     * @param CacheItemInterface $item The cache item to save
+     *
+     * @return bool False if the item could not be queued or if a commit was attempted and failed. True otherwise.
+     */
+    public function saveDeferred(CacheItemInterface $item): bool
+    {
+        return $this->getCacheAdapter()->saveDeferred($item);
+    }
+    /**
+     * Persists any deferred cache items.
+     *
+     * @return bool True if all not-yet-saved items were successfully saved or there were none. False otherwise.
+     */
+    public function commit(): bool
+    {
+        return $this->getCacheAdapter()->commit();
+    }
+    /**
+     * Invalidates cached items using tags.
+     *
+     * @param string[] $tags An array of tags to invalidate
+     *
+     * @return bool True on success
+     *
+     * @throws Psr6CacheInterface When $tags is not valid
+     */
+    public function invalidateTags(array $tags): bool
+    {
+        return $this->getCacheAdapter()->invalidateTags($tags);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CacheBundle/Command/ClearCacheCommand.php
@@ -0,0 +1,27 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CacheBundle\Command;
+use Mautic\CacheBundle\Cache\CacheProviderInterface;
+use Symfony\Component\Console\Command\Command;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Output\OutputInterface;
+/**
+ * CLI Command to clear the application cache.
+ */
+class ClearCacheCommand extends Command
+{
+    public function __construct(
+        private CacheProviderInterface $cacheProvider,
+    ) {
+        parent::__construct();
+    }
+    protected function configure(): void
+    {
+        $this->setName('mautic:cache:clear');
+    }
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        return (int) !$this->cacheProvider->clear();
+    }
+    protected static $defaultDescription = 'Clears Mautic\'s cache';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Assets/js/campaign.js
@@ -0,0 +1,1893 @@
+/**
+ * Setup the campaign view
+ *
+ * @param container
+ */
+Mautic.campaignOnLoad = function (container, response) {
+    Mautic.lazyLoadContactListOnCampaignDetail();
+    const $flashes = mQuery('#flashes');
+    const $builder = mQuery('#campaign-builder');
+    const isCampaignPreview = $builder.hasClass('preview');
+    if (mQuery(container + ' #list-search').length) {
+        Mautic.activateSearchAutocomplete('list-search', 'campaign');
+    }
+    if (mQuery('#CampaignEventPanel').length) {
+        var tooltipTimeout = null;
+        mQuery('#CampaignEventPanelGroups button').on('click', function() {
+            var eventType = mQuery(this).data('type');
+            Mautic.campaignBuilderUpdateEventList([eventType], false, 'lists', true);
+        });
+        mQuery('#CampaignEventPanelLists button').on('click', function() {
+            Mautic.campaignBuilderUpdateEventList(Mautic.campaignBuilderAnchorClickedAllowedEvents, true, 'groups', true);
+        });
+        if (!isCampaignPreview) {
+            mQuery('#CampaignCanvas .list-campaign-event, #CampaignCanvas .list-campaign-source').off('.eventbuttons')
+                .on('mouseover.eventbuttons', function() {
+                    mQuery(this).find('.campaign-event-buttons').removeClass('hide');
+                })
+                .on('mouseout.eventbuttons', function() {
+                    mQuery(this).find('.campaign-event-buttons').addClass('hide');
+                })
+                .on('dblclick.eventbuttons', function(event) {
+                    event.preventDefault();
+                    mQuery(this).find('.btn-edit').first().click();
+                });
+        } else {
+            mQuery("#CampaignCanvas div.list-campaign-event").each(function () {
+                var thisId = mQuery(this).attr('id');
+                var option  = mQuery('#'+thisId+' option[value="' + mQuery(this).val() + '"]');
+            });
+        }
+        mQuery('.campaign-event-selector').on('chosen:showing_dropdown', function (event) {
+            mQuery('.builder-content').css('overflow', 'hidden');
+            var thisSelect = mQuery(event.target).attr('id');
+            Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, false);
+            mQuery('#'+thisSelect+'_chosen .chosen-search input').on('keydown.tooltip', function () {
+                Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, true);
+            }).on('keyup.tooltip', function() {
+                if (tooltipTimeout) {
+                    clearTimeout(tooltipTimeout);
+                }
+                tooltipTimeout = setTimeout(function () {
+                    Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, false);
+                }, 200);
+            });
+        });
+        mQuery('.campaign-event-selector').on('chosen:hiding_dropdown', function (event) {
+            mQuery('.builder-content').css('overflow', 'auto');
+            var thisSelect = mQuery(event.target).attr('id');
+            Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, true);
+            mQuery('#'+thisSelect+'_chosen .chosen-search input').off('keyup.tooltip')
+                .off('keydown.tooltip');
+        });
+        mQuery('.campaign-event-selector').on('change', function() {
+            if (!mQuery('#CampaignEvent_newsource').length) {
+                Mautic.hideCampaignEventPanel();
+            }
+            var thisId = mQuery(this).attr('id');
+            var option  = mQuery('#'+thisId+' option[value="' + mQuery(this).val() + '"]');
+            if (option.attr('data-href') && Mautic.campaignBuilderAnchorNameClicked) {
+                var updatedUrl = option.attr('data-href').replace(/anchor=(.*?)$/, "anchor=" + Mautic.campaignBuilderAnchorNameClicked + "&anchorEventType=" + Mautic.campaignBuilderAnchorEventTypeClicked);
+                option.attr('data-href', updatedUrl);
+            }
+            mQuery('#'+thisId).trigger('chosen:close');
+            Mautic.ajaxifyModal(option);
+            mQuery(this).val('');
+            mQuery(this).trigger('chosen:updated');
+        });
+        mQuery('#CampaignCanvas').on('click', function(event) {
+            if (!mQuery(event.target).parents('#CampaignCanvas').length && !mQuery('#CampaignEvent_newsource').length) {
+                Mautic.hideCampaignEventPanel();
+            }
+        });
+        $builder.on('campaign-builder:show', function () {
+            $builder.addClass('builder-active').removeClass('hide');
+            $flashes.addClass('alert-offset');
+        });
+        $builder.on('campaign-builder:hide', function () {
+            $builder.addClass('hide').removeClass('builder-active');
+            $flashes.removeClass('alert-offset');
+        });
+        Mautic.prepareCampaignCanvas();
+        if (response && response.inBuilder) {
+            Mautic.launchCampaignEditor();
+            Mautic.processBuilderErrors(response);
+        }
+        const campaignEmailStats = mQuery(container).find('[data-load="campaign-email-stats"]').first();
+        if(campaignEmailStats.length) {
+            mQuery(campaignEmailStats).on('click', () => {
+                const $campaignWeekdaysContainer = mQuery('[data-campaign-email-stats-weekdays]');
+                const $campaignHoursContainer = mQuery('[data-campaign-email-stats-hours]');
+                if ($campaignWeekdaysContainer.find('canvas').length === 0) {
+                    mQuery.ajax({
+                        url: $campaignWeekdaysContainer.data('campaign-email-stats-weekdays'),
+                        success: function (response) {
+                            $campaignWeekdaysContainer.html(response);
+                            Mautic.renderCharts($campaignWeekdaysContainer);
+                        }
+                    });
+                }
+                if ($campaignHoursContainer.find('canvas').length === 0) {
+                    mQuery.ajax({
+                        url: $campaignHoursContainer.data('campaign-email-stats-hours'),
+                        success: function (response) {
+                            $campaignHoursContainer.html(response);
+                            Mautic.renderCharts($campaignHoursContainer);
+                        }
+                    });
+                }
+            });
+        }
+        window.addEventListener('storage', function(event) {
+            if (event.key === 'mautic_campaign_event_clone') {
+                Mautic.campaignBuilderUpdateEventCloneDescription();
+            }
+        });
+        mQuery(document).ajaxError(function(event, jqxhr, settings, thrownError) {
+            var path = settings.url.split('?')[0];
+            if (path === "/s/campaigns/events/insert") {
+                Mautic.campaignEventInsertOnError(event, jqxhr);
+            }
+        });
+        if (isCampaignPreview) {
+            Mautic.previewCampaignLabels();
+        }
+    }
+};
+Mautic.lazyLoadContactListOnCampaignDetail = function() {
+    let containerId = '#leads-container';
+    let container = mQuery(containerId);
+    if (!container.length) {
+        return;
+    }
+    let campaignContactUrl = container.data('target-url');
+    mQuery.get(campaignContactUrl, function(response) {
+        response.target = containerId;
+        Mautic.processPageContent(response);
+    });
+};
+/**
+ * Update chosen tooltips
+ *
+ * @param theSelect
+ * @param onlyDestroy
+ */
+Mautic.campaignBuilderUpdateEventListTooltips = function(theSelect, onlyDestroy) {
+    const $select = mQuery('#'+theSelect);
+    const dataAttribute = 'tooltips';
+    if (undefined === $select.data(dataAttribute)) {
+        $select.data(dataAttribute, []);
+    }
+    const tooltips = $select.data(dataAttribute);
+    mQuery.each(tooltips, function (index, $tooltip) {
+        if (undefined === $tooltip) {
+            return;
+        }
+        $tooltip.tooltip('hide');
+        $tooltip.tooltip('destroy');
+    });
+    $select.data(dataAttribute, []);
+    if (true === onlyDestroy) {
+        return;
+    }
+    $select.find('option').each(function () {
+        if (mQuery(this).attr('id')) {
+            const chosenOption = '#' + theSelect + '_chosen .option_' + mQuery(this).attr('id');
+            const $tooltip = mQuery(chosenOption).tooltip({html: true, container: 'body', placement: 'left'});
+            $select.data(dataAttribute).push($tooltip);
+        }
+    });
+}
+/**
+ * Delete the builder instance so it's regenerated when reopening the campaign event builder
+ */
+Mautic.campaignOnUnload = function(container) {
+    delete Mautic.campaignBuilderInstance;
+    delete Mautic.campaignBuilderLabels;
+}
+Mautic.campaignEventCloneOnLoad = function(container, response) {
+    Mautic.setCampaignEventClone({
+        'sourceEventName': response['eventName'],
+        'sourceEventType': response['eventType'],
+        'sourceType': response['type'],
+        'sourceCampaignId': response['campaignId'],
+        'sourceCampaignName': response['campaignName'],
+    });
+    const flashMessage = Mautic.addInfoFlashMessage(Mautic.translate('mautic.campaign.event.clone.success'));
+    Mautic.setFlashes(flashMessage);
+    Mautic.campaignBuilderUpdateEventCloneDescription();
+};
+Mautic.campaignEventInsertOnError = function (event, jqxhr) {
+    Mautic.clearCampaignEventClone();
+    Mautic.hideCampaignEventPanel();
+    if (jqxhr.responseJSON.error) {
+        const flashMessage = Mautic.addErrorFlashMessage(jqxhr.responseJSON.error);
+        Mautic.setFlashes(flashMessage);
+    }
+};
+/**
+ * Setup the campaign event view
+ *
+ * @param container
+ * @param response
+ */
+Mautic.campaignEventOnLoad = function (container, response) {
+    if (mQuery('#campaignevent_triggerHour').length) {
+        Mautic.campaignEventUpdateIntervalHours();
+        mQuery('#campaignevent_triggerHour').on('change', Mautic.campaignEventUpdateIntervalHours);
+        mQuery('#campaignevent_triggerRestrictedStartHour').on('change', Mautic.campaignEventUpdateIntervalHours);
+        mQuery('#campaignevent_triggerRestrictedStopHour').on('change', Mautic.campaignEventUpdateIntervalHours);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_0').on('change', Mautic.campaignEventSelectDOW);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_1').on('change', Mautic.campaignEventSelectDOW);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_2').on('change', Mautic.campaignEventSelectDOW);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_3').on('change', Mautic.campaignEventSelectDOW);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_4').on('change', Mautic.campaignEventSelectDOW);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').on('change', Mautic.campaignEventSelectDOW);
+    }
+    if (!response.hasOwnProperty('eventId')) {
+        return;
+    }
+    var domEventId = 'CampaignEvent_' + response.eventId;
+    var eventId = '#' + domEventId;
+    Mautic.campaignBuilderLabels[domEventId] = (response.label) ? response.label : '';
+    if (!response.success && Mautic.campaignBuilderConnectionRequiresUpdate) {
+        Mautic.campaignBuilderInstance.deleteConnection(Mautic.campaignBuilderLastConnection);
+    }
+    Mautic.campaignBuilderConnectionRequiresUpdate = false;
+    Mautic.campaignBuilderUpdateLabel(domEventId);
+    Mautic.campaignBuilderCanvasEvents[response.event.id] = response.event;
+    if (response.deleted) {
+        Mautic.campaignBuilderInstance.remove(document.getElementById(domEventId));
+        delete Mautic.campaignBuilderEventPositions[domEventId];
+        delete Mautic.campaignBuilderCanvasEvents[response.event.id];
+    } else if (response.updateHtml) {
+        mQuery(eventId + " .campaign-event-content").replaceWith(response.updateHtml);
+    } else if (response.eventHtml) {
+        var newHtml = response.eventHtml;
+        var x = parseInt(mQuery('#droppedX').val());
+        var y = parseInt(mQuery('#droppedY').val());
+        Mautic.campaignBuilderEventPositions[domEventId] = {
+            'left': x,
+            'top': y
+        };
+        mQuery(newHtml).appendTo('#CampaignCanvas');
+        mQuery(eventId).css({'left': x + 'px', 'top': y + 'px'});
+        Mautic.campaignBuilderRegisterAnchors(Mautic.getAnchorsForEvent(response.event), eventId);
+        Mautic.campaignBuilderInstance.draggable(domEventId, Mautic.campaignDragOptions);
+        mQuery(eventId + " a[data-toggle='ajax']").click(function (event) {
+            event.preventDefault();
+            return Mautic.ajaxifyLink(this, event);
+        });
+        mQuery(eventId + " a[data-toggle='ajaxmodal']").on('click.ajaxmodal', function (event) {
+            event.preventDefault();
+            Mautic.ajaxifyModal(this, event);
+        });
+        mQuery(eventId).off('.eventbuttons')
+            .on('mouseover.eventbuttons', function() {
+                mQuery(this).find('.campaign-event-buttons').removeClass('hide');
+            })
+            .on('mouseout.eventbuttons', function() {
+                mQuery(this).find('.campaign-event-buttons').addClass('hide');
+            })
+            .on('dblclick.eventbuttons', function(event) {
+                event.preventDefault();
+                mQuery(this).find('.btn-edit').first().click();
+            });
+        mQuery(eventId + " *[data-toggle='tooltip']").tooltip({html: true});
+        Mautic.campaignBuilderInstance.connect({
+            uuids: [
+                Mautic.campaignBuilderAnchorClicked,
+                domEventId+'_top'
+            ]
+        });
+    }
+    if (response.hasOwnProperty('clearCloneStorage')) {
+        Mautic.hideCampaignEventPanel();
+        Mautic.clearCampaignEventClone();
+    }
+    Mautic.campaignBuilderInstance.repaintEverything();
+};
+/**
+ * Update the trigger hour based on the interval unit selected
+ */
+Mautic.campaignEventUpdateIntervalHours = function () {
+    var hour = mQuery('#campaignevent_triggerHour').val();
+    var start = mQuery('#campaignevent_triggerRestrictedStartHour').val();
+    var stop = mQuery('#campaignevent_triggerRestrictedStopHour').val();
+    if (hour) {
+        mQuery('#campaignevent_triggerRestrictedStartHour').val('');
+        mQuery('#campaignevent_triggerRestrictedStopHour').val('');
+        mQuery('#campaignevent_triggerRestrictedStartHour').prop('disabled', true);
+        mQuery('#campaignevent_triggerRestrictedStopHour').prop('disabled', true);
+    } else if (start || stop) {
+        mQuery('#campaignevent_triggerHour').val('');
+        mQuery('#campaignevent_triggerHour').prop('disabled', true);
+    } else {
+        mQuery('#campaignevent_triggerHour').val('');
+        mQuery('#campaignevent_triggerRestrictedStartHour').val('');
+        mQuery('#campaignevent_triggerRestrictedStopHour').val('');
+        mQuery('#campaignevent_triggerHour').prop('disabled', false);
+        mQuery('#campaignevent_triggerRestrictedStartHour').prop('disabled', false);
+        mQuery('#campaignevent_triggerRestrictedStopHour').prop('disabled', false);
+    }
+};
+/**
+ * Update DOW for weekday selection
+ */
+Mautic.campaignEventSelectDOW = function() {
+    if (mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').prop('checked')) {
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_0').prop('checked', true);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_1').prop('checked', true);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_2').prop('checked', true);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_3').prop('checked', true);
+        mQuery('#campaignevent_triggerRestrictedDaysOfWeek_4').prop('checked', true);
+    }
+    mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').prop('checked', false);
+};
+/**
+ * Determine anchors to set up for the given event.
+ *
+ * This inspects the `connectionRestrictions` property
+ * within the event's settings that were passed when
+ * registering the event in your bundle's CampaignEventListener.
+ *
+ * @param event
+ */
+Mautic.getAnchorsForEvent = function (event) {
+    var restrictions = Mautic.campaignBuilderConnectionRestrictions[event.type].target;
+    if (
+        restrictions.decision.length === 1 && restrictions.decision[0] === "none" &&
+        restrictions.action.length === 1 && restrictions.action[0] === "none" &&
+        restrictions.condition.length === 1 && restrictions.condition[0] === "none"
+    ) {
+        return ['top'];
+    }
+    if (event.eventType === 'decision' || event.eventType === 'condition') {
+        return ['top', 'yes', 'no'];
+    }
+    return ['top', 'bottom'];
+};
+/**
+ * Setup the campaign source view
+ *
+ * @param container
+ * @param response
+ */
+Mautic.campaignSourceOnLoad = function (container, response) {
+    var domEventId = 'CampaignEvent_' + response.sourceType;
+    var eventId = '#' + domEventId;
+    if (response.deleted) {
+        Mautic.campaignBuilderInstance.remove(document.getElementById(domEventId));
+        delete Mautic.campaignBuilderEventPositions[domEventId];
+        mQuery('#campaignLeadSource_' + response.sourceType).prop('disabled', false);
+        mQuery('#SourceList').trigger('chosen:updated');
+        if (!mQuery('.list-campaign-source:not(#CampaignEvent_newsource_hide)').length) {
+            mQuery('#CampaignEvent_newsource_hide').attr('id', 'CampaignEvent_newsource');
+            Mautic.campaignBuilderPrepareNewSource();
+        }
+    } else if (response.updateHtml) {
+        mQuery(eventId + " .campaign-event-content").html(response.updateHtml);
+    } else if (response.sourceHtml) {
+        mQuery('#campaignLeadSource_' + response.sourceType).prop('disabled', true);
+        mQuery('#SourceList').trigger('chosen:updated');
+        var newHtml = response.sourceHtml;
+        if (mQuery('#CampaignEvent_newsource').length) {
+            var x = mQuery('#CampaignEvent_newsource').position().left;
+            var y = mQuery('#CampaignEvent_newsource').position().top;
+            mQuery('#CampaignEvent_newsource').attr('id', 'CampaignEvent_newsource_hide');
+            Mautic.hideCampaignEventPanel();
+            var autoConnect = false;
+        } else {
+            var x = parseInt(mQuery('#droppedX').val());
+            var y = parseInt(mQuery('#droppedY').val());
+            var autoConnect = true;
+        }
+        mQuery(newHtml).appendTo('#CampaignCanvas');
+        Mautic.campaignBuilderEventPositions[domEventId] = {
+            'left': x,
+            'top': y
+        };
+        mQuery(eventId).css({'left': x + 'px', 'top': y + 'px'});
+        Mautic.campaignBuilderRegisterAnchors(['leadSource', 'leadSourceLeft', 'leadSourceRight'], eventId);
+        Mautic.campaignBuilderInstance.draggable(domEventId, Mautic.campaignDragOptions);
+        mQuery(eventId + " a[data-toggle='ajax']").click(function (event) {
+            event.preventDefault();
+            return Mautic.ajaxifyLink(this, event);
+        });
+        mQuery(eventId + " a[data-toggle='ajaxmodal']").on('click.ajaxmodal', function (event) {
+            event.preventDefault();
+            Mautic.ajaxifyModal(this, event);
+        });
+        mQuery(eventId).off('.eventbuttons')
+            .on('mouseover.eventbuttons', function() {
+                mQuery(this).find('.campaign-event-buttons').removeClass('hide');
+            })
+            .on('mouseout.eventbuttons', function() {
+                mQuery(this).find('.campaign-event-buttons').addClass('hide');
+            })
+            .on('dblclick.eventbuttons', function(event) {
+                event.preventDefault();
+                mQuery(this).find('.btn-edit').first().click();
+            });
+        mQuery(eventId + " *[data-toggle='tooltip']").tooltip({html: true});
+        if (autoConnect) {
+            if (Mautic.campaignBuilderAnchorClicked.search('left') !== -1) {
+                var source = domEventId + '_leadsourceright';
+                var target = Mautic.campaignBuilderAnchorClicked;
+            } else {
+                var source = Mautic.campaignBuilderAnchorClicked;
+                var target = domEventId + '_leadsourceleft';
+            }
+            Mautic.campaignBuilderInstance.connect({
+                uuids: [
+                    source,
+                    target
+                ]
+            });
+        }
+        if (!mQuery('.list-campaign-event').length) {
+            mQuery('.jtk-endpoint_anchor_leadsource.'+domEventId).trigger('click');
+        }
+    }
+    Mautic.campaignBuilderInstance.repaintEverything();
+};
+/**
+ * Update a connectors label
+ *
+ * @param domEventId
+ */
+Mautic.campaignBuilderUpdateLabel = function (domEventId) {
+    var theLabel = typeof Mautic.campaignBuilderLabels[domEventId] == 'undefined' ? '' : Mautic.campaignBuilderLabels[domEventId];
+    var currentConnections = Mautic.campaignBuilderInstance.select({
+        target: domEventId
+    });
+    if (currentConnections.length > 0) {
+        currentConnections.each(function(conn) {
+            var overlays = conn.getOverlays();
+            if (overlays.length > 0) {
+                for (var i = 0; i <= overlays.length; i++ ) {
+                    if ( typeof overlays[i] != 'undefined' && overlays[i].type == 'Label') {
+                        conn.removeOverlay(overlays[i].id);
+                    }
+                }
+            }
+            if (theLabel) {
+                conn.addOverlay(["Label", {
+                    label: theLabel,
+                    location: 0.65,
+                    cssClass: "jtk-label",
+                    id: conn.sourceId + "_" + conn.targetId + "_connectionLabel"
+                }]);
+            }
+        });
+    }
+};
+/**
+ * Launch campaign builder modal
+ */
+Mautic.launchCampaignEditor = function() {
+    Mautic.stopIconSpinPostEvent();
+    mQuery('body').css('overflow-y', 'hidden');
+    mQuery('#campaign-builder').trigger('campaign-builder:show');
+    if (mQuery('#CampaignEvent_newsource').length) {
+        Mautic.campaignBuilderPrepareNewSource();
+    }
+    if (Mautic.campaignBuilderCanvasSettings) {
+        Mautic.campaignBuilderInstance.setSuspendDrawing(true);
+        Mautic.campaignBuilderReconnectEndpoints();
+        Mautic.campaignBuilderInstance.setSuspendDrawing(false, true);
+    }
+    Mautic.campaignBuilderInstance.repaintEverything();
+};
+/**
+ * Launch campaign preview view
+ */
+Mautic.launchCampaignPreview = function() {
+    Mautic.stopIconSpinPostEvent();
+    if (Mautic.campaignBuilderCanvasSettings) {
+        Mautic.campaignBuilderInstance.setSuspendDrawing(true);
+        Mautic.campaignBuilderReconnectEndpoints();
+        Mautic.campaignBuilderInstance.setSuspendDrawing(false, true);
+    }
+    Mautic.campaignBuilderInstance.repaintEverything();
+};
+/**
+ *
+ * @type {{source: {leadsource: {source: Array, action: [*], condition: [*], decision: [*]}, leadsourceleft: {source: [*], action: Array, condition: Array, decision: Array}, leadsourceright: {source: [*], action: Array, condition: Array, decision: Array}}, action: {top: {source: [*], action: Array, condition: [*], decision: [*]}, bottom: {source: Array, action: Array, condition: [*], decision: [*]}}, condition: {top: {source: [*], action: [*], condition: [*], decision: [*]}, yes: {source: Array, action: [*], condition: [*], decision: [*]}, no: {source: Array, action: [*], condition: [*], decision: [*]}}, decision: {top: {action: [*], source: [*], condition: [*], decision: Array}, yes: {source: Array, action: [*], condition: [*], decision: Array}, no: {source: Array, action: [*], condition: [*], decision: Array}}}}
+ */
+Mautic.campaignBuilderConnectionsMap = {
+    'source': {
+        'leadsource': {
+            'source': [],
+            'action': ['top'], // target anchors
+            'condition': ['top'],
+            'decision': ['top'],
+        },
+        'leadsourceleft': {
+            'source': ['leadsourceright'],
+            'action': [],
+            'condition': [],
+            'decision': []
+        },
+        'leadsourceright': {
+            'source': ['leadsourceleft'],
+            'action': [],
+            'condition': [],
+            'decision': []
+        }
+    },
+    'action': {
+        'top': {
+            'source': ['leadsource'],
+            'action': ['bottom'],
+            'condition': ['yes', 'no'],
+            'decision': ['yes', 'no']
+        },
+        'bottom': {
+            'source': [],
+            'action': ['top'],
+            'condition': ['top'],
+            'decision': ['top']
+        }
+    },
+    'condition': {
+        'top': {
+            'source': ['leadsource'],
+            'action': ['bottom'],
+            'condition': ['yes', 'no'],
+            'decision': ['yes', 'no']
+        },
+        'yes': {
+            'source': [],
+            'action': ['top'],
+            'condition': ['top'],
+            'decision': ['top']
+        },
+        'no': {
+            'source': [],
+            'action': ['top'],
+            'condition': ['top'],
+            'decision': ['top']
+        }
+    },
+    'decision': {
+        'top': {
+            'action': ['bottom'],
+            'source': ['leadsource'],
+            'condition': ['yes', 'no'],
+            'decision': [],
+        },
+        'yes': {
+            'source': [],
+            'action': ['top'],
+            'condition': ['top'],
+            'decision': [],
+        },
+        'no': {
+            'source': [],
+            'action': ['top'],
+            'condition': ['top'],
+            'decision': [],
+        }
+    }
+};
+Mautic.campaignBuilderAnchorDefaultColor = 'var(--border-subtle)';
+Mautic.campaignEndpointDefinitions = {
+    'top': {
+        anchors: [0.5, 0, 0, -1, 0, 0],
+        isTarget: true
+    },
+    'bottom': {
+        anchors: [0.5, 1, 0, 1, 0, 0],
+        isTarget: false
+    },
+    'yes': {
+        anchors: [0, 1, 0, 1, 30, 0],
+        connectorColor: 'var(--support-success-inverse)',
+        isTarget: false
+    },
+    'no': {
+        anchors: [1, 1, 0, 1, -30, 0],
+        connectorColor: 'var(--support-error-inverse)',
+        isTarget: false
+    },
+    'leadSource': {
+        anchors: [0.5, 1, 0, 1, 0, 0],
+        isTarget: false
+    },
+    'leadSourceLeft': {
+        anchors: [0, 0.5, -1, 0, -1, 0],
+        connectorColor: '#fdb933',
+        isTarget: true,
+        connectorStyle: 'Straight'
+    },
+    'leadSourceRight': {
+        anchors: [1, 0.5, 1, 0, 1, 0],
+        connectorColor: '#fdb933',
+        isTarget: false,
+        connectorStyle: 'Straight'
+    }
+};
+/**
+ * Push callbacks to these events
+ *
+ * @type {{connection: Array, connectionDetached: Array, connectionMoved: Array, beforeDrop: Array}}
+ */
+Mautic.campaignConnectionCallbacks = {
+    'beforeDetach': [],
+    'beforeDrag': [],
+    'beforeStartDetach': [],
+    'beforeDrop': [],
+    'onHover': [],
+    'beforeAnchorsRegistered': [],
+    'afterAnchorsRegistered': [],
+    'beforeEndpointsRegistered': [],
+    'beforeEndpointsReconnected': [],
+    'afterEndpointsReconnected': []
+};
+Mautic.campaignBuilderAnchorClicked = false;
+Mautic.campaignBuilderEventPositions = {};
+Mautic.prepareCampaignCanvas = function() {
+    if (typeof Mautic.campaignBuilderInstance == 'undefined') {
+        Mautic.campaignBuilderInstance = jsPlumb.getInstance({
+            Container: document.querySelector("#CampaignCanvas")
+        });
+        Mautic.campaignEndpoints = {};
+        var startingPosition;
+        Mautic.campaignDragOptions = {
+            start: function (params) {
+                startingPosition =
+                    {
+                        top: params.el.offsetTop,
+                        left: params.el.offsetLeft,
+                    };
+            },
+            stop: function (params) {
+                var endingPosition =
+                    {
+                        top: params.finalPos[0],
+                        left: params.finalPos[1]
+                    };
+                if (startingPosition.left !== endingPosition.left || startingPosition.top !== endingPosition.top) {
+                    Mautic.campaignBuilderEventPositions[mQuery(params.el).attr('id')] = {
+                        'left': parseInt(endingPosition.left),
+                        'top': parseInt(endingPosition.top)
+                    };
+                    var campaignId = mQuery('#campaignId').val();
+                    var query = "action=campaign:updateCoordinates&campaignId=" + campaignId + "&droppedX=" + endingPosition.top + "&droppedY=" + endingPosition.left + "&eventId=" + mQuery(params.el).attr('id');
+                    mQuery.ajax({
+                        url: mauticAjaxUrl,
+                        type: "POST",
+                        data: query,
+                        dataType: "json",
+                        error: function (request, textStatus, errorThrown) {
+                            Mautic.processAjaxError(request, textStatus, errorThrown);
+                        }
+                    });
+                }
+            },
+            containment:true
+        };
+        Mautic.campaignBuilderEventDimensions = {
+            'width': 200,
+            'height': 45,
+            'anchor': 10,
+            'wiggleWidth': 30,
+            'wiggleHeight': 50
+        };
+        Mautic.campaignBuilderLabels = {};
+        Mautic.campaignBuilderInstance.bind("connection", function (info, originalEvent) {
+            Mautic.campaignBuilderConnectionRequiresUpdate = false;
+            Mautic.campaignBuilderLastConnection           = info.connection;
+            var epDetails          = Mautic.campaignBuilderGetEndpointDetails(info.sourceEndpoint);
+            var targetElementId    = info.targetEndpoint.elementId;
+            var previousConnection = mQuery('#'+targetElementId).attr('data-connected');
+            var editButton         = mQuery('#'+targetElementId).find('a.btn-edit');
+            var editUrl            = editButton.attr('href');
+            if (editUrl) {
+                var anchorQueryParams = 'anchor=' + epDetails.anchorName + "&anchorEventType=" + epDetails.eventType;
+                if (editUrl.search('anchor=') !== -1) {
+                    editUrl.replace(/anchor=(.*?)$/, anchorQueryParams);
+                } else {
+                    var delimiter = (editUrl.indexOf('?') === -1) ? '?' : '&';
+                    editUrl = editUrl + delimiter + anchorQueryParams;
+                }
+                editButton.attr('data-href', editUrl);
+                if (previousConnection && previousConnection != epDetails.anchorName && (previousConnection == 'no' || epDetails.anchorName == 'no')) {
+                    editButton.attr('data-prevent-dismiss', true);
+                    Mautic.campaignBuilderConnectionRequiresUpdate = true;
+                    editButton.trigger('click');
+                }
+            }
+            mQuery('#'+targetElementId).attr('data-connected', epDetails.anchorName);
+            Mautic.campaignBuilderUpdateLabel(info.connection.targetId);
+            info.targetEndpoint.setPaintStyle(
+                {
+                    fill: info.connection.getPaintStyle().stroke
+                }
+            );
+            info.sourceEndpoint.setPaintStyle(
+                {
+                    fill: info.connection.getPaintStyle().stroke
+                }
+            );
+        });
+        Mautic.campaignBuilderInstance.bind("connectionDetached", function (info, originalEvent) {
+            Mautic.campaignBuilderUpdateLabel(info.connection.targetId);
+            info.targetEndpoint.setPaintStyle(
+                {
+                    fill: "#d5d4d4"
+                }
+            );
+            var currentConnections = info.sourceEndpoint.connections.length;
+            currentConnections -= 1;
+            if (!currentConnections) {
+                info.sourceEndpoint.setPaintStyle(
+                    {
+                        fill: "#d5d4d4"
+                    }
+                );
+            }
+        });
+        Mautic.campaignBuilderInstance.bind("connectionMoved", function (info, originalEvent) {
+            Mautic.campaignBuilderUpdateLabel(info.connection.originalTargetId);
+            info.originalTargetEndpoint.setPaintStyle(
+                {
+                    fill: "#d5d4d4"
+                }
+            );
+            Mautic.campaignBuilderUpdateLabel(info.connection.newTargetId);
+            info.newTargetEndpoint.setPaintStyle(
+                {
+                    fill: info.newSourceEndpoint.getPaintStyle().fill
+                }
+            );
+        });
+        mQuery('.builder-content').scroll(function () {
+            Mautic.campaignBuilderInstance.repaintEverything();
+        });
+        mQuery.each(Mautic.campaignConnectionCallbacks.beforeEndpointsRegistered, function (index, callback) {
+            callback();
+        });
+        mQuery.each(Mautic.campaignEndpointDefinitions, function (ep, definition) {
+            Mautic.campaignBuilderRegisterEndpoint(ep, definition);
+        });
+        mQuery.each(Mautic.campaignConnectionCallbacks.beforeAnchorsRegistered, function (index, callback) {
+            callback();
+        });
+        mQuery("#CampaignCanvas div[data-event-id]").each(function () {
+            var event = Mautic.campaignBuilderCanvasEvents[mQuery(this).data('eventId')];
+            Mautic.campaignBuilderRegisterAnchors(Mautic.getAnchorsForEvent(event), this);
+        });
+        mQuery("#CampaignCanvas div.list-campaign-event.list-campaign-source").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function () {
+            Mautic.campaignBuilderRegisterAnchors(['bottom'], this);
+        });
+        mQuery("#CampaignCanvas div.list-campaign-leadsource").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function () {
+            Mautic.campaignBuilderRegisterAnchors(['leadSource', 'leadSourceLeft', 'leadSourceRight'], this);
+        });
+        mQuery.each(Mautic.campaignConnectionCallbacks.afterAnchorsRegistered, function (index, callback) {
+            callback();
+        });
+        if (mQuery('.preview').length) {
+            Mautic.launchCampaignPreview();
+        } else {
+            Mautic.campaignBuilderInstance.draggable(
+                document.querySelectorAll("#CampaignCanvas .draggable"),
+                Mautic.campaignDragOptions
+            );
+        }
+    }
+};
+/**
+ * Validate a connection before it can be made
+ *
+ * @param params
+ * @returns {boolean}
+ */
+Mautic.campaignBeforeDropCallback = function(params) {
+    var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(params.connection.endpoints[0]);
+    var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(params.dropEndpoint);
+    var callbackAllowed = null;
+    mQuery.each(Mautic.campaignConnectionCallbacks.beforeDrop, function(index, callback) {
+        var result = callback(sourceEndpoint, targetEndpoint, params);
+        if (null !== result) {
+            callbackAllowed = result;
+            return false;
+        }
+    });
+    if (null !== callbackAllowed) {
+        return callbackAllowed;
+    }
+    if (!Mautic.campaignBuilderValidateConnection(sourceEndpoint, targetEndpoint.eventType, targetEndpoint.event)){
+        return false;
+    }
+    if (mQuery.inArray(targetEndpoint.anchorName, ['top', 'leadsourceleft', 'leadsourceright'])) {
+        var sourceConnections = Mautic.campaignBuilderInstance.select({
+            source: params.targetId
+        });
+        var loopDetected = false;
+        sourceConnections.each(function (conn) {
+            if (conn.sourceId == targetEndpoint.elementId && conn.targetId == sourceEndpoint.elementId) {
+                loopDetected = true;
+                return false;
+            }
+        });
+    }
+    if (params.sourceId == params.targetId) {
+        return false;
+    }
+    var allowedConnections = Mautic.campaignBuilderConnectionsMap[sourceEndpoint.eventType][sourceEndpoint.anchorName][targetEndpoint.eventType];
+    var allowed = mQuery.inArray(targetEndpoint.anchorName, allowedConnections) !== -1;
+    if (allowed) {
+        if (params.dropEndpoint.connections.length > 0) {
+            mQuery.each(params.dropEndpoint.connections, function(key, conn) {
+                Mautic.campaignBuilderInstance.deleteConnection(conn);
+            });
+        }
+    }
+    return allowed;
+};
+/**
+ * Process beforeDetach event callbacks
+ *
+ * @param connection
+ * @returns {*}
+ */
+Mautic.campaignBeforeDetachCallback = function(connection) {
+    var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(connection.sourceId);
+    var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(connection.targetId);
+    var callbackAllowed = null;
+    mQuery.each(Mautic.campaignConnectionCallbacks.beforeDetach, function (index, callback) {
+        var result = callback(sourceEndpoint, targetEndpoint, connection);
+        if (null !== result) {
+            callbackAllowed = result;
+            return false;
+        }
+    });
+    if (null !== callbackAllowed) {
+        return callbackAllowed;
+    }
+    return true;
+};
+/**
+ * Process beforeDetach event callbacks
+ *
+ * @param connection
+ */
+Mautic.campaignBeforeDragCallback = function(endpoint, source, sourceId) {
+    var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(sourceId);
+    var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+    var callbackAllowed = null;
+    mQuery.each(Mautic.campaignConnectionCallbacks.beforeDrag, function (index, callback) {
+        var result = callback(sourceEndpoint, targetEndpoint, endpoint, source, sourceId);
+        if (null !== result) {
+            callbackAllowed = result;
+            return false;
+        }
+    });
+    if (null !== callbackAllowed) {
+        return callbackAllowed;
+    }
+    return true;
+};
+/**
+ * Process beforeDetach event callbacks
+ *
+ * @param endpoint
+ * @param source
+ * @param sourceId
+ * @param connection
+ * @returns {*}
+ */
+Mautic.campaignBeforeStartDetachCallback = function(endpoint, source, sourceId, connection) {
+    var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(sourceId);
+    var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+    var callbackAllowed = null;
+    mQuery.each(Mautic.campaignConnectionCallbacks.beforeStartDetach, function (index, callback) {
+        var result = callback(sourceEndpoint, targetEndpoint, endpoint, source, sourceId, connection);
+        if (null !== result) {
+            callbackAllowed = result;
+            return false;
+        }
+    });
+    if (null !== callbackAllowed) {
+        return callbackAllowed;
+    }
+    return true;
+};
+/**
+ * Process beforeDetach event callbacks
+ *
+ * @param connection
+ */
+Mautic.campaignHoverCallback = function(sourceEndpoint, endpoint, event) {
+    var callbackAllowed = null;
+    mQuery.each(Mautic.campaignConnectionCallbacks.onHover, function (index, callback) {
+        var result = callback(sourceEndpoint, endpoint, event);
+        if (null !== result) {
+            callbackAllowed = result;
+            return false;
+        }
+    });
+    if (null !== callbackAllowed) {
+        return callbackAllowed;
+    }
+    return true;
+};
+/**
+ * Enable/Disable timeframe settings if the toggle for immediate trigger is changed
+ */
+Mautic.campaignToggleTimeframes = function() {
+    const triggerModes = {
+        immediate: mQuery('#campaignevent_triggerMode_0').prop('checked'),
+        interval: mQuery('#campaignevent_triggerMode_1').prop('checked'),
+        date: mQuery('#campaignevent_triggerMode_2').prop('checked'),
+        optimal: mQuery('#campaignevent_triggerMode_3').prop('checked')
+    };
+    if (!mQuery('#campaignevent_triggerMode_2').length) {
+        triggerModes.date = triggerModes.interval;
+        triggerModes.interval = triggerModes.immediate;
+        triggerModes.immediate = false;
+    }
+    if (mQuery('#campaignevent_triggerInterval').length) {
+        mQuery('#triggerInterval').toggleClass('hide', !triggerModes.interval);
+        mQuery('#triggerDate').toggleClass('hide', !triggerModes.date);
+        mQuery('#triggerOptimized').toggleClass('hide', !triggerModes.optimal);
+    }
+};
+/**
+ * Close campaign builder
+ */
+Mautic.closeCampaignBuilder = function() {
+    mQuery('.btns-builder').find('button').prop('disabled', true);
+    var builderCss = {
+        margin: "0",
+        padding: "0",
+        border: "none",
+        width: "100%",
+        height: "100%"
+    };
+    var panelHeight = (mQuery('.builder-content').css('right') == '0px') ? mQuery('.builder-panel').height() : 0,
+        panelWidth = (mQuery('.builder-content').css('right') == '0px') ? 0 : mQuery('.builder-panel').width(),
+        spinnerLeft = (mQuery(window).width() - panelWidth - 60) / 2,
+        spinnerTop = (mQuery(window).height() - panelHeight - 60) / 2;
+    var overlay = mQuery('<div id="builder-overlay" class="modal-backdrop fade in"><div style="position: absolute; top:' + spinnerTop + 'px; left:' + spinnerLeft + 'px" class=".builder-spinner"><i class="ri-loader-3-line ri-spin ri-5x"></i></div></div>').css(builderCss).appendTo('.builder-content');
+    mQuery('#builder-errors').hide('fast').text('');
+    Mautic.updateConnections(function(err, response) {
+        mQuery('body').css('overflow-y', '');
+        if (!err) {
+            mQuery('#builder-overlay').remove();
+            mQuery('body').css('overflow-y', '');
+            if (response.success) {
+                mQuery('#campaign-builder').trigger('campaign-builder:hide');
+                mQuery('.btns-builder').find('button').prop('disabled', false);
+            }
+        }
+    });
+};
+Mautic.saveCampaignFromBuilder = function() {
+    mQuery('.btns-builder').find('button').prop('disabled', true);
+    Mautic.activateButtonLoadingIndicator(mQuery('.btn-apply-builder'));
+    Mautic.updateConnections(function(err) {
+        if (!err) {
+            var applyBtn = mQuery('.btn-apply');
+            Mautic.inBuilderSubmissionOn(applyBtn.closest('form'));
+            applyBtn.trigger('click');
+            Mautic.inBuilderSubmissionOff();
+        }
+    });
+};
+Mautic.updateConnections = function(callback) {
+    var nodes = [];
+    mQuery("#CampaignCanvas .list-campaign-event").each(function (idx, elem) {
+        nodes.push({
+            id:        mQuery(elem).attr('id').replace('CampaignEvent_', ''),
+            positionX: parseInt(mQuery(elem).css('left'), 10),
+            positionY: parseInt(mQuery(elem).css('top'), 10)
+        });
+    });
+    mQuery("#CampaignCanvas .list-campaign-source").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function (idx, elem) {
+        nodes.push({
+            id:        mQuery(elem).attr('id').replace('CampaignEvent_', ''),
+            positionX: parseInt(mQuery(elem).css('left'), 10),
+            positionY: parseInt(mQuery(elem).css('top'), 10)
+        });
+    });
+    var connections = [];
+    mQuery.each(Mautic.campaignBuilderInstance.getConnections(), function (idx, connection) {
+        connections.push({
+            sourceId:     connection.sourceId.replace('CampaignEvent_', ''),
+            targetId:     connection.targetId.replace('CampaignEvent_', ''),
+            anchors:      mQuery.map(connection.endpoints, function (endpoint) {
+                var anchor = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+                return {
+                    'endpoint': anchor.anchorName,
+                    'eventId':  anchor.eventId
+                };
+            })
+        });
+    });
+    var chart          = {};
+    chart.nodes        = nodes;
+    chart.connections  = connections;
+    var canvasSettings = {canvasSettings: chart};
+    var campaignId     = mQuery('#campaignId').val();
+    var query          = "action=campaign:updateConnections&campaignId=" + campaignId;
+    mQuery.ajax({
+        url: mauticAjaxUrl + '?' + query,
+        type: "POST",
+        data: canvasSettings,
+        dataType: "json",
+        success: function (response) {
+            if (typeof callback === 'function') callback(false, response);
+        },
+        error: function (response, textStatus, errorThrown) {
+            Mautic.processAjaxError(response, textStatus, errorThrown);
+            if (typeof callback === 'function') callback(true, response);
+        }
+    });
+};
+/**
+ * Submit the campaign event form
+ * @param e
+ */
+Mautic.submitCampaignEvent = function(e) {
+    e.preventDefault();
+    mQuery('#campaignevent_canvasSettings_droppedX').val(mQuery('#droppedX').val());
+    mQuery('#campaignevent_canvasSettings_droppedY').val(mQuery('#droppedY').val());
+    mQuery('.btns-builder').find('button').prop('disabled', true);
+    const runningAjax = mQuery.active;
+    mQuery('form[name="campaignevent"]').submit();
+    const waitForElement = function (){
+        if(mQuery.active <= runningAjax){
+            mQuery('.btns-builder').find('button').prop('disabled', false);
+        }
+        else{
+            setTimeout(waitForElement, 100);
+        }
+    }
+    waitForElement();
+};
+/**
+ * Submit source form
+ * @param e
+ */
+Mautic.submitCampaignSource = function(e) {
+    e.preventDefault();
+    mQuery('#campaign_leadsource_droppedX').val(mQuery('#droppedX').val());
+    mQuery('#campaign_leadsource_droppedY').val(mQuery('#droppedY').val());
+    mQuery('form[name="campaign_leadsource"]').submit();
+};
+/**
+ * Reconnect jsplumb connections
+ */
+Mautic.campaignBuilderReconnectEndpoints = function () {
+    mQuery.each(Mautic.campaignConnectionCallbacks.beforeEndpointsReconnected, function (index, callback) {
+        callback();
+    });
+    if (typeof Mautic.campaignBuilderCanvasSettings == 'undefined') {
+        return;
+    }
+    if (typeof Mautic.campaignBuilderCanvasSettings.nodes !== 'undefined') {
+        var sourceFound = false;
+        mQuery.each(Mautic.campaignBuilderCanvasSettings.nodes, function (key, node) {
+            if (typeof Mautic.campaignBuilderCanvasSources[node.id] !== 'undefined') {
+                sourceFound = true;
+            }
+            mQuery('#CampaignEvent_' + node.id).css({
+                position: 'absolute',
+                left: node.positionX + 'px',
+                top: node.positionY + 'px'
+            });
+            Mautic.campaignBuilderEventPositions['CampaignEvent_' + node.id] = {
+                left: parseInt(node.positionX),
+                top: parseInt(node.positionY)
+            };
+        });
+    }
+    if (typeof Mautic.campaignBuilderCanvasSettings.connections !== 'undefined') {
+        mQuery.each(Mautic.campaignBuilderCanvasSettings.connections, function (key, connection) {
+            if (typeof Mautic.campaignBuilderCanvasEvents[connection.targetId] !== 'undefined') {
+                var targetEvent = Mautic.campaignBuilderCanvasEvents[connection.targetId];
+            } else if (typeof Mautic.campaignBuilderCanvasSources[connection.targetId] !== 'undefined') {
+                var targetEvent = Mautic.campaignBuilderCanvasSources[connection.targetId];
+            }
+            if (targetEvent && targetEvent.label) {
+                Mautic.campaignBuilderLabels["CampaignEvent_" + connection.targetId] = targetEvent.label;
+            }
+            Mautic.campaignBuilderInstance.connect({
+                uuids: [
+                    "CampaignEvent_" + connection.sourceId + '_' + connection.anchors.source,
+                    "CampaignEvent_" + connection.targetId + '_' + connection.anchors.target
+                ]
+            });
+        });
+    }
+    if (!sourceFound) {
+        var topOffset = 25;
+        mQuery.each(Mautic.campaignBuilderCanvasSources, function (type, source) {
+            mQuery('#CampaignEvent_' + type).css({
+                position: 'absolute',
+                left: '20px',
+                top: topOffset + 'px'
+            });
+        });
+        topOffset += 45;
+    }
+    mQuery.each(Mautic.campaignConnectionCallbacks.afterEndpointsReconnected, function (index, callback) {
+        callback();
+    });
+    delete Mautic.campaignBuilderCanvasSettings;
+};
+/**
+ * Register an endpoint with JsPlumb
+ *
+ * @param name
+ * @param params
+ */
+Mautic.campaignBuilderRegisterEndpoint = function (name, params) {
+    var isTarget, isSource, color, connectorColor, connectorStyle;
+    if (params.color) {
+        color = params.color;
+    } else {
+        color = Mautic.campaignBuilderAnchorDefaultColor;
+    }
+    if (params.connectorColor) {
+        connectorColor = params.connectorColor;
+    } else {
+        connectorColor = color;
+    }
+    if (params.connectorStyle) {
+        connectorStyle = params.connectorStyle;
+    } else {
+        connectorStyle = ["Bezier", {curviness: 25}];
+    }
+    isTarget = params.isTarget;
+    isSource = true;
+    if (isTarget === null) {
+        isTarget = true;
+    } else {
+        if (typeof isTarget == 'undefined') {
+            isTarget = false;
+        }
+        if (isTarget) {
+            isSource = false;
+        }
+    }
+    Mautic.campaignEndpoints[name] = {
+        endpoint: ["Dot", { radius: 10 }],
+        paintStyle: {
+            fill: color
+        },
+        endpointStyle: {
+          fill: color
+        },
+        connectorStyle: {
+            stroke: connectorColor,
+            strokeWidth: 2
+        },
+        connector: connectorStyle,
+        connectorOverlays: [],
+        maxConnections: -1,
+        isTarget: isTarget,
+        isSource: isSource,
+        beforeDrop: Mautic.campaignBeforeDropCallback,
+        beforeDetach: Mautic.campaignBeforeDetachCallback,
+        beforeStartDetach: Mautic.campaignBeforeStartDetachCallback,
+        beforeDrag: Mautic.campaignBeforeDragCallback
+    }
+};
+/**
+ * Register an anchor with JsPlumb
+ *
+ * @param names
+ * @param el
+ */
+Mautic.campaignBuilderRegisterAnchors = function(names, el) {
+    var id = mQuery(el).attr('id');
+    mQuery(names).each(function(key, anchorName) {
+        var theAnchor = Mautic.campaignEndpointDefinitions[anchorName]['anchors'];
+        theAnchor[6] = anchorName.toLowerCase() + ' ' + id;
+        var ep = Mautic.campaignBuilderInstance.addEndpoint(
+            id,
+            {
+                anchor: theAnchor,
+                uuid: id + "_" + anchorName.toLowerCase()
+            },
+            Mautic.campaignEndpoints[anchorName]
+        );
+        ep.bind("mouseover", function (endpoint, event) {
+            var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+            if (!Mautic.campaignHoverCallback(epDetails, endpoint, event)) {
+                return;
+            }
+            if (epDetails.anchorName == 'top') {
+                return;
+            }
+            if (epDetails.anchorName == 'leadsourceleft' || epDetails.anchorName == 'leadsourceright') {
+                if (mQuery('#SourceList option:enabled').length === 1) {
+                    return;
+                }
+            }
+            endpoint.setPaintStyle(
+                {
+                    fill: endpoint.connectorStyle.stroke
+                }
+            );
+            var dot = mQuery(endpoint.canvas);
+            dot.addClass('jtk-clickable_anchor');
+            if (!dot.find('svg text').length) {
+                var svg = dot.find('svg')[0];
+                var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
+                textElement.setAttributeNS(null, 'x', '50%');
+                textElement.setAttributeNS(null, 'y', '50%');
+                textElement.setAttributeNS(null, 'text-anchor', 'middle');
+                textElement.setAttributeNS(null, 'stroke-width', '1px');
+                textElement.setAttributeNS(null, 'stroke', '#ffffff');
+                textElement.setAttributeNS(null, 'dy', '.3em');
+                var textNode = document.createTextNode('+');
+                textElement.appendChild(textNode);
+                svg.appendChild(textElement);
+            }
+        });
+        ep.bind("mouseout", function (endpoint) {
+            var dot = mQuery(endpoint.canvas);
+            dot.removeClass('jtk-clickable_anchor');
+            if (!endpoint.connections.length) {
+                endpoint.setPaintStyle(
+                    {
+                        fill: Mautic.campaignBuilderAnchorDefaultColor
+                    }
+                );
+            }
+        });
+        ep.bind("click", function (endpoint, event) {
+            if (mQuery('#CampaignEvent_newsource').length) {
+                return;
+            }
+            var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+            if (epDetails.anchorName == 'top') {
+                return;
+            }
+            if (epDetails.anchorName == 'leadsourceleft' || epDetails.anchorName == 'leadsourceright') {
+                if (mQuery('#SourceList option:enabled').length === 1) {
+                    return;
+                }
+            }
+            var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
+            var clickedAnchorName = epDetails.anchorName;
+            Mautic.campaignBuilderAnchorClicked = endpoint.elementId+'_'+clickedAnchorName;
+            Mautic.campaignBuilderAnchorNameClicked = clickedAnchorName;
+            Mautic.campaignBuilderAnchorEventTypeClicked = epDetails.eventType;
+            var elPos = Mautic.campaignBuilderGetEventPosition(endpoint.element);
+            var spotFound = false,
+                putLeft = elPos.left,
+                putTop = elPos.top,
+                direction = '', // xl, xr, yu, yd
+                fullWidth = Mautic.campaignBuilderEventDimensions.width + Mautic.campaignBuilderEventDimensions.anchor,
+                wiggleWidth = fullWidth + Mautic.campaignBuilderEventDimensions.wiggleWidth,
+                fullHeight = Mautic.campaignBuilderEventDimensions.height + Mautic.campaignBuilderEventDimensions.anchor,
+                wiggleHeight = fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight,
+                debug = false;
+            if (debug) {
+                console.log(Mautic.campaignBuilderEventPositions);
+                console.log(clickedAnchorName+' - starting with: x = '+ putLeft+', y = '+putTop);
+            }
+            switch (clickedAnchorName) {
+                case 'leadsourceleft':
+                    direction = 'xl';
+                    putLeft -= wiggleWidth;
+                    break;
+                case 'leadsourceright':
+                    direction = 'xr';
+                    putLeft += wiggleWidth;
+                    break;
+                case 'bottom':
+                    direction = 'yd';
+                    putTop += wiggleHeight;
+                    break;
+                case 'yes':
+                case 'leadsource':
+                    putLeft -= Mautic.campaignBuilderEventDimensions.width/2;
+                    putTop  += wiggleHeight;
+                    direction = 'xl';
+                    break;
+                case 'no':
+                    putLeft += Mautic.campaignBuilderEventDimensions.width/2;
+                    putTop  += wiggleHeight;
+                    direction = 'xr';
+                    break;
+                case 'top':
+                    directon = 'yu';
+                    putTop -= wiggleHeight;
+                    break;
+            }
+            if (debug) {
+                console.log('Going direction: '+direction);
+                console.log('Start test with: x = '+ putLeft+', y = '+putTop);
+            }
+            var counter = 0;
+            var windowWidth = mQuery(window).width();
+            while (!spotFound) {
+                var isOccupied = false;
+                mQuery.each(Mautic.campaignBuilderEventPositions, function (id, pos) {
+                    var l = Math.max(putLeft, pos.left);
+                    var r = Math.min(putLeft + fullWidth, pos.left + fullWidth);
+                    var b = Math.max(putTop, pos.top);
+                    var t = Math.min(putTop + fullHeight, pos.top + fullHeight);
+                    var h = t-b;
+                    var w = r-l;
+                    if (debug) {
+                        console.log('Checking ' + id);
+                        console.log(putLeft, putTop, l,r,b,t,h,w);
+                    }
+                    if (h > 0 && w > 0) {
+                        if (debug) {
+                            console.log('Slot occupied by '+id);
+                        }
+                        isOccupied = true;
+                        switch (direction) {
+                            case 'xl':
+                                putLeft -= (w + Mautic.campaignBuilderEventDimensions.wiggleWidth);
+                                if (putLeft <= 0) {
+                                    putLeft = 0;
+                                    direction = 'yd';
+                                    putTop += fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight;
+                                }
+                                break;
+                            case 'xr':
+                                if (putLeft + w + Mautic.campaignBuilderEventDimensions.wiggleWidth > windowWidth) {
+                                    direction = 'yd';
+                                    putLeft -= Mautic.campaignBuilderEventDimensions.wiggleWidth;
+                                    putTop += fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight;
+                                } else {
+                                    putLeft += (w + Mautic.campaignBuilderEventDimensions.wiggleWidth);
+                                }
+                                break;
+                            case 'yu':
+                                putTop -= (h - Mautic.campaignBuilderEventDimensions.wiggleHeight);
+                                if (putTop <= 0) {
+                                    putTop = 0;
+                                    direction = 'xr';
+                                }
+                                break;
+                            case 'yd':
+                                putTop += (h + Mautic.campaignBuilderEventDimensions.wiggleHeight);
+                                break;
+                        }
+                        return false
+                    }
+                });
+                if (!isOccupied) {
+                    if (debug) {
+                       console.log('It fits!');
+                    }
+                    spotFound = true;
+                }
+                counter++;
+                if (counter >= 100) {
+                    putTop = 10;
+                    putLeft = 10;
+                    if (debug) {
+                        console.log('Too many loops');
+                    }
+                    spotFound = true;
+                }
+            }
+            if (debug) {
+                console.log('To be placed at: x = '+ putLeft+', y = '+putTop);
+            }
+            if (putLeft <= 0) {
+                putLeft = 10;
+            }
+            if (putTop <= 0) {
+                putTop = 10;
+            }
+            mQuery('#droppedX').val(putLeft);
+            mQuery('#droppedY').val(putTop);
+            var allowedEvents = [];
+            mQuery.each(Mautic.campaignBuilderConnectionsMap[epDetails.eventType][epDetails.anchorName], function (group, eventTypes) {
+                if (eventTypes.length) {
+                    allowedEvents[allowedEvents.length] = group.charAt(0).toUpperCase() + group.substr(1);
+                }
+            });
+            Mautic.campaignBuilderAnchorClickedAllowedEvents = allowedEvents;
+            Mautic.campaignBuilderIsEventCloneAllowed = Mautic.isCampaignCloneEventAllowedForEndpoint(epDetails);
+            if (!(mQuery('.preview').length)) {
+                var el = (mQuery(event.target).hasClass('jtk-endpoint')) ? event.target : mQuery(event.target).parents('.jtk-endpoint')[0];
+                Mautic.campaignBuilderAnchorClickedPosition = Mautic.campaignBuilderGetEventPosition(el);
+                Mautic.campaignBuilderUpdateEventList(allowedEvents, false, 'groups');
+                Mautic.campaignBuilderUpdateEventCloneButton(allowedEvents, epDetails.eventType, epDetails.anchorName);
+                Mautic.campaignBuilderUpdateEventCloneDescription();
+            }
+            mQuery('.campaign-event-selector:not(#SourceList) option').prop('disabled', false);
+            if ('source' == epDetails.eventType) {
+                var checkSelects = ['action', 'decision', 'condition'];
+            } else {
+                var primaryType       = (epDetails.eventType === 'decision') ? 'action': 'decision';
+                var checkSelects = [primaryType, 'condition'];
+            }
+            mQuery.each(checkSelects, function(key, targetType) {
+                var selectId = '#' + targetType.charAt(0).toUpperCase() + targetType.slice(1) + 'List';
+                mQuery(selectId + ' option').each(function () {
+                    var optionVal = mQuery(this).val();
+                    if (optionVal) {
+                        if (!Mautic.campaignBuilderValidateConnection(epDetails, targetType, optionVal)) {
+                            mQuery(this).prop('disabled', true);
+                        }
+                    }
+                });
+                mQuery(selectId).trigger('chosen:updated');
+            });
+        });
+    });
+};
+/**
+ * Extract information about an event/endpoint from element
+ *
+ * @param el
+ * @returns {{left: Number, top: Number}}
+ */
+Mautic.campaignBuilderGetEventPosition = function(el) {
+    return {
+        'left': parseInt(mQuery(el).css('left')),
+        'top': parseInt(mQuery(el).css('top'))
+    }
+};
+/**
+ * Update the event select list
+ *
+ * @param groups
+ * @param hidden
+ * @param view
+ * @param active
+ * @param forcePosition
+ */
+Mautic.campaignBuilderUpdateEventList = function (groups, hidden, view, active, forcePosition) {
+    var groupsEnabled = 0;
+    var inGroupsView = ('groups' == view);
+    if (groups.length === 1 && mQuery.inArray('Source', groups) !== -1 && !hidden) {
+        inGroupsView = false;
+    }
+    mQuery.each(['Source', 'Action', 'Decision', 'Condition'], function (key, theGroup) {
+        if (mQuery.inArray(theGroup, groups) !== -1) {
+            if (inGroupsView) {
+                mQuery('#' + theGroup + 'GroupSelector').removeClass('hide');
+                if ('source' != theGroup) {
+                    groupsEnabled++;
+                }
+            } else {
+                mQuery('#' + theGroup + 'GroupList').removeClass('hide');
+            }
+        } else {
+            if (inGroupsView) {
+                mQuery('#' + theGroup + 'GroupSelector').addClass('hide');
+            } else {
+                mQuery('#' + theGroup + 'GroupList').addClass('hide');
+            }
+        }
+    });
+    mQuery('#CampaignEventPanelGroups').removeClass('groups-enabled-1 groups-enabled-2 groups-enabled-3')
+    mQuery('#CampaignEventPanelGroups').addClass('groups-enabled-' + groups.length)
+    if (inGroupsView) {
+        mQuery.each(groups, function (key, theGroup) {
+            mQuery('#'+theGroup+'GroupSelector').removeClass(
+                function (index, css) {
+                    return (css.match(/col-(\S+)/g) || []).join(' ');
+                }
+            ).addClass('col-md-' + (12 / groupsEnabled));
+        });
+        var newWidth = (500 / 3) * groupsEnabled;
+        if (newWidth >= mQuery(window).width()) {
+            newWidth = mQuery(window).width() - 10;
+        }
+        var leftPos = (forcePosition) ? forcePosition.left : Mautic.campaignBuilderAnchorClickedPosition.left - (newWidth / 2 - 10);
+        var topPos  = (forcePosition) ? forcePosition.top : Mautic.campaignBuilderAnchorClickedPosition.top + 25;
+        mQuery('#CampaignEventPanel').css({
+                left: (leftPos >=0 ) ? leftPos : 10,
+                top: topPos,
+                width: newWidth,
+            });
+        mQuery('#CampaignEventPanel').removeClass('hide');
+        mQuery('#CampaignEventPanelGroups').removeClass('hide');
+        mQuery('#CampaignEventPanelLists').addClass('hide');
+        if (Mautic.campaignBuilderIsEventCloneAllowed) {
+            mQuery('#CampaignPasteContainer').removeClass('hide');
+        } else {
+            mQuery('#CampaignPasteContainer').addClass('hide');
+        }
+    } else {
+        var leftPos = (forcePosition) ? forcePosition.left : Mautic.campaignBuilderAnchorClickedPosition.left - 125;
+        var topPos  = (forcePosition) ? forcePosition.top : Mautic.campaignBuilderAnchorClickedPosition.top + 25;
+        mQuery('#CampaignEventPanel').css({
+            left: (leftPos >= 0) ? leftPos : 10,
+            top: topPos,
+            width: 300,
+        });
+        mQuery('#CampaignEventPanelGroups').addClass('hide');
+        mQuery('#CampaignEventPanelLists').removeClass('hide');
+        mQuery('#CampaignEventPanel').removeClass('hide');
+        if (groups.length === 1) {
+            setTimeout(function () {
+                mQuery('#CampaignEventPanelLists #' + groups[0] + 'List').trigger('chosen:open');
+            }, 10);
+        }
+    }
+};
+Mautic.campaignBuilderUpdateEventCloneButton = function (groups, eventType, anchorName) {
+    var $insertButton = mQuery('#EventInsertButton');
+    var updatedUrl = $insertButton.attr('href').replace(/anchor=(.*?)$/, "anchor=" + anchorName + "&anchorEventType=" + eventType);
+    $insertButton.attr('href', updatedUrl);
+};
+Mautic.campaignBuilderUpdateEventCloneDescription = function () {
+    var cloneDetails = Mautic.getCampaignEventClone();
+    if (cloneDetails) {
+        mQuery('[data-campaign-event-clone="sourceEventName"]').html(cloneDetails['sourceEventName']);
+        mQuery('[data-campaign-event-clone="sourceCampaignName"]').html(cloneDetails['sourceCampaignName']);
+    }
+};
+/**
+ *
+ * @param endpoint
+ * @param nameOnly
+ * @returns {{endpointName: *, elementId: *}}
+ */
+Mautic.campaignBuilderGetEndpointDetails = function(endpoint) {
+    var anchorName, eventId;
+    if (typeof endpoint === 'string') {
+        eventId = endpoint;
+    } else {
+        var parts = endpoint.anchor.cssClass.split(' ');
+        if (parts.length > 1) {
+            anchorName = parts[0];
+            eventId = parts[1];
+        } else {
+            anchorName = parts[0];
+            eventId = endpoint.elementId
+        }
+    }
+    return {
+        'anchorName': anchorName,
+        'eventId': eventId.replace('CampaignEvent_', ''),
+        'elementId' : eventId,
+        'eventType': mQuery('#'+eventId).data('type'),
+        'event': mQuery('#'+eventId).data('event')
+    };
+};
+/**
+ * Display new source when required
+ */
+Mautic.campaignBuilderPrepareNewSource = function () {
+    var newSourcePos = {
+        left: mQuery(window).width()/2 - 100,
+        top: 50
+    };
+    mQuery('#CampaignEvent_newsource').css(newSourcePos);
+    Mautic.campaignBuilderUpdateEventList(['Source'], false, 'list', false, {
+        left: newSourcePos.left - 50,
+        top: newSourcePos.top + 35
+    });
+    mQuery('#SourceList').trigger('chosen:open');
+};
+/**
+ *
+ * @param epDetails
+ * @param targetType action|decision|condition
+ * @param targetEvent
+ * @returns {boolean}
+ */
+Mautic.campaignBuilderValidateConnection = function (epDetails, targetType, targetEvent) {
+    var valid = true;
+    var sourceType  = epDetails.eventType;
+    var sourceEvent = 'source' === sourceType ? sourceType : epDetails.event;
+    if (typeof Mautic.campaignBuilderConnectionRestrictions[targetEvent] !== 'undefined') {
+        if ('source' === sourceEvent) {
+            mQuery.each(Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'], function(eventType, events) {
+                if (events.length) {
+                    valid = false;
+                    return false;
+                }
+            });
+            return valid;
+        }
+        if (
+            typeof Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType] !== 'undefined' &&
+            Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType].length &&
+            mQuery.inArray(sourceEvent, Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType]) === -1
+        ) {
+            valid = false;
+        }
+    }
+    if (
+        typeof Mautic.campaignBuilderConnectionRestrictions[sourceEvent] !== 'undefined' &&
+        typeof Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType] !== 'undefined' &&
+        Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType].length
+    ) {
+        valid = (mQuery.inArray(targetEvent, Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType]) !== -1);
+    }
+    if (
+        typeof Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType] !== 'undefined' &&
+        typeof Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType][targetEvent] !== 'undefined'
+    ) {
+        mQuery(Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType][targetEvent]).each(
+            function(key, anchor) {
+                switch (anchor) {
+                    case 'inaction':
+                        anchor = 'no';
+                        break;
+                    case 'action':
+                        anchor = 'yes';
+                        break;
+                }
+                if (anchor == epDetails.anchorName) {
+                    valid = false;
+                    return false;
+                }
+            }
+        );
+    }
+    return valid;
+};
+/**
+ *
+ * @param eventId
+ * @param contactId
+ */
+Mautic.updateScheduledCampaignEvent = function(eventId, contactId) {
+    mQuery('#timeline-campaign-event-'+eventId+' .btn-reschedule').addClass('disabled');
+    var converting = false;
+    var eventWrapper = '#timeline-campaign-event-'+eventId;
+    var eventSpan = '.timeline-campaign-event-date-'+eventId;
+    var eventText = '#timeline-campaign-event-text-'+eventId;
+    var saveButton = '#timeline-campaign-event-save-' + eventId;
+    var originalDate = mQuery(eventWrapper+' '+eventSpan).first().text();
+    var revertInput = function(input) {
+        converting = true;
+        mQuery(input).datetimepicker('destroy');
+        mQuery(eventSpan).text(originalDate);
+        mQuery(eventWrapper+' .btn-reschedule').removeClass('disabled');
+    };
+    var date = mQuery(eventSpan).attr('data-date');
+    mQuery(saveButton).show();
+    var input = mQuery('<input type="text" id="timeline-reschedule"/>')
+        .css('height', '20px')
+        .css('color', '#000000')
+        .val(date)
+        .on('keyup', function(e) {
+            var code = e.keyCode || e.which;
+            if (code == 13) {
+                e.preventDefault();
+                converting = true
+                mQuery(input).prop('readonly', true);
+                mQuery(input).datetimepicker('destroy');
+                Mautic.ajaxActionRequest('campaign:updateScheduledCampaignEvent',
+                    {
+                        eventId: eventId,
+                        contactId: contactId,
+                        date: mQuery(this).val(),
+                        originalDate: date
+                    }, function (response) {
+                        mQuery(eventSpan).text(response.formattedDate);
+                        mQuery(eventSpan).attr('data-date', response.date);
+                        mQuery(eventWrapper+' .btn-reschedule').removeClass('disabled');
+                        if (response.success) {
+                            mQuery(eventText).removeClass('text-warning').addClass('text-info');
+                            mQuery(eventSpan).css('textDecoration', 'inherit');
+                            mQuery('.fa.timeline-campaign-event-cancelled-'+eventId).remove();
+                            mQuery('.timeline-campaign-event-scheduled-'+eventId).removeClass('hide');
+                            mQuery('.timeline-campaign-event-cancelled-'+eventId).addClass('hide');
+                            mQuery(saveButton).hide();
+                        }
+                    }, false
+                );
+            } else if (code == 27) {
+                e.preventDefault();
+                revertInput(input);
+                mQuery(saveButton).hide();
+            }
+        })
+        .on('blur', function (e) {
+            if (!converting) {
+                revertInput(input);
+            }
+            mQuery(saveButton).hide();
+        });
+    mQuery('#timeline-campaign-event-'+eventId+' '+eventSpan).html(input);
+    Mautic.activateDateTimeInputs('#timeline-reschedule');
+    mQuery('#timeline-reschedule').focus();
+};
+/**
+ *
+ * @param eventId
+ * @param contactId
+ */
+Mautic.saveScheduledCampaignEvent = function (eventId, contactId) {
+    var saveButton = '#timeline-campaign-event-save-' + eventId;
+    mQuery(saveButton).addClass('disabled');
+    var eventWrapper = '#timeline-campaign-event-' + eventId;
+    var eventSpan = '.timeline-campaign-event-date-' + eventId;
+    var eventText = '#timeline-campaign-event-text-' + eventId;
+    var date = mQuery(eventSpan).attr('data-date');
+    Mautic.ajaxActionRequest('campaign:updateScheduledCampaignEvent',
+        {
+            eventId: eventId,
+            contactId: contactId,
+            date: mQuery('#timeline-reschedule').val(),
+            originalDate: date
+        }, function (response) {
+            mQuery(eventSpan).text(response.formattedDate);
+            mQuery(eventSpan).attr('data-date', response.date);
+            if (response.success) {
+                mQuery(eventText).removeClass('text-warning').addClass('text-info');
+                mQuery(eventSpan).css('textDecoration', 'inherit');
+                mQuery('.fa.timeline-campaign-event-cancelled-' + eventId).remove();
+                mQuery('.timeline-campaign-event-scheduled-' + eventId).removeClass('hide');
+                mQuery('.timeline-campaign-event-cancelled-' + eventId).addClass('hide');
+            }
+            mQuery(saveButton).removeClass('disabled').hide();
+            mQuery(eventWrapper + ' .btn-reschedule').removeClass('disabled');
+        }, false);
+};
+/**
+ *
+ * @param eventId
+ * @param contactId
+ */
+Mautic.cancelScheduledCampaignEvent = function(eventId, contactId) {
+    mQuery('#timeline-campaign-event-'+eventId+' .btn').prop('disabled', true).addClass('disabled');
+    var eventWrapper = '#timeline-campaign-event-'+eventId;
+    var eventSpan = '.timeline-campaign-event-date-' + eventId;
+    var eventText = '#timeline-campaign-event-text-' + eventId;
+    Mautic.ajaxActionRequest('campaign:cancelScheduledCampaignEvent',
+        {
+            eventId: eventId,
+            contactId: contactId,
+        }, function (response) {
+            if (response.success) {
+                mQuery(eventText).removeClass('text-info').addClass('text-warning');
+                mQuery(eventWrapper+' .btn-edit').prop('disabled', false).removeClass('disabled');
+                mQuery('.timeline-campaign-event-scheduled-'+eventId).addClass('hide');
+                mQuery('.timeline-campaign-event-cancelled-'+eventId).removeClass('hide');
+            } else {
+                mQuery(eventWrapper+' .btn').prop('disabled', false).removeClass('disabled');
+            }
+        }, false
+    );
+};
+/**
+ * Update the "Jump to Event" select list to be available events.
+ */
+Mautic.updateJumpToEventOptions = function() {
+    var jumpToEventSelectNode = mQuery("#campaignevent_properties_jumpToEvent");
+    jumpToEventSelectNode.children().remove();
+    for (var eventId in Mautic.campaignBuilderCanvasEvents) {
+        var event = Mautic.campaignBuilderCanvasEvents[eventId];
+        if (event.type !== 'campaign.jump_to_event' && event.eventType !== 'decision') {
+            var opt = mQuery("<option />")
+                .attr("value", event.id)
+                .text(event.name)
+            if (event.id == jumpToEventSelectNode.data("selected")) {
+                opt.attr("selected", "selected");
+            }
+            jumpToEventSelectNode.append(opt);
+        }
+    }
+    jumpToEventSelectNode.trigger("chosen:updated");
+};
+Mautic.highlightJumpTarget = function(event, el) {
+    var element = mQuery(el);
+    var parentEventElement = element.parent().parent();
+    var highlightedAlready = parentEventElement.data('highlighted');
+    var jumpTargetID = '#CampaignEvent_' + element.data('jumpTarget');
+    var jumpTarget = mQuery(jumpTargetID);
+    var overlay = mQuery('#EventJumpOverlay');
+    if (highlightedAlready) {
+        parentEventElement.data('highlighted', false);
+        overlay.hide();
+        parentEventElement.css("z-index", 1010);
+        jumpTarget.css("z-index", 1010);
+    } else {
+        parentEventElement.data('highlighted', true);
+        overlay.show();
+        parentEventElement.css("z-index", 2010);
+        jumpTarget.css("z-index", 2010);
+    }
+};
+/**
+ * Display confirmation modal if user wishes to unpublish the campaign.
+ */
+Mautic.showCampaignConfirmation = function (el) {
+    let element = mQuery(el);
+    if (element.prop('checked') && element.val() !== "1") {
+        Mautic.showConfirmation(element);
+    }
+};
+/**
+ * Cancel Callback to trigger the yes button and dismiss the confirmation modal.
+ */
+Mautic.setPublishedButtonToYes = function (el) {
+    Mautic.dismissConfirmation();
+    var yesButton  = mQuery(el).parent('.btn-no').siblings('.btn-yes').children('input');
+    var yesButtonId = mQuery(yesButton).attr('id');
+    if (yesButtonId !== undefined) {
+        mQuery('#' + yesButtonId).trigger('click');
+        mQuery(el).parent('.btn-no').removeClass('active');
+        mQuery(el).parent('.btn-no').siblings('.btn-yes').addClass('active');
+    }
+};
+/**
+ * Onclick Callback to show the confirmation modal during toggling campaign status.
+ */
+Mautic.confirmationCampaignPublishStatus = function (el) {
+    let element = mQuery(el);
+    if (element.data('status') === 'published') {
+        Mautic.showConfirmation(element);
+    }
+    else {
+        Mautic.confirmCallbackCampaignPublishStatus('', el);
+    }
+}
+/**
+ * Confirm Callback to toggling campaign status if user chooses Yes.
+ */
+Mautic.confirmCallbackCampaignPublishStatus = function (action, el) {
+    let element = mQuery(el);
+    let idClass = element.data('id-class');
+    let model = element.data('model');
+    let itemId = element.data('item-id');
+    let query = element.data('query');
+    let backdrop = element.data('backdrop');
+    Mautic.togglePublishStatus(event, idClass, model, itemId, query, backdrop);
+    Mautic.dismissConfirmation();
+}
+Mautic.isCampaignCloneEventAllowedForEndpoint = function(endpointDetails) {
+    const eventClone = Mautic.getCampaignEventClone();
+    if (!eventClone) {
+        return false;
+    }
+    const eventType = eventClone['sourceEventType'].charAt(0).toUpperCase() + eventClone['sourceEventType'].slice(1);
+    const allowedEvents = Mautic.campaignBuilderAnchorClickedAllowedEvents || [];
+    const isValidConnection = Mautic.campaignBuilderValidateConnection(endpointDetails, eventClone['sourceEventType'], eventClone['sourceType']);
+    return allowedEvents.includes(eventType) && isValidConnection;
+}
+Mautic.getCampaignEventClone = function() {
+    const eventClone = localStorage.getItem("mautic_campaign_event_clone");
+    return eventClone === null ? null : JSON.parse(eventClone);
+}
+Mautic.setCampaignEventClone = function(data) {
+    localStorage.setItem("mautic_campaign_event_clone", JSON.stringify(data));
+}
+Mautic.clearCampaignEventClone = function() {
+    localStorage.removeItem("mautic_campaign_event_clone");
+}
+Mautic.hideCampaignEventPanel = function() {
+    mQuery('#CampaignEventPanel').addClass('hide');
+}
+Mautic.previewCampaignLabels = function() {
+    const campaignBuilder = Mautic.campaignBuilderInstance;
+    const managedElements = Mautic.campaignBuilderInstance.getManagedElements();
+    const allElements = Object.values(managedElements).map(el => el.el);
+    allElements.forEach(function(element) {
+        const id = element.id;
+        const connections = campaignBuilder.getConnections({source: id});
+        connections.forEach(function(connection) {
+            const connectionAnchor = connection.target.dataset.connected ?? null;
+            if (connectionAnchor === 'yes') {
+                connection.addOverlay(["Label", {
+                    label: element.dataset.eventYesPercent + '%',
+                    location: 0.44,
+                    cssClass: 'jtk-label jtk-label--success',
+                    id: element.id + 'yes-path-label'
+                }]);
+            }
+            if (connectionAnchor === 'no') {
+                connection.addOverlay(["Label", {
+                    label: element.dataset.eventNoPercent + '%',
+                    location: 0.44,
+                    cssClass: 'jtk-label jtk-label--error',
+                    id: element.id + 'no-path-label'
+                }]);
+            }
+        });
+    });
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/CampaignDeleteEventLogsCommand.php
@@ -0,0 +1,53 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Command;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Symfony\Component\Console\Command\Command;
+use Symfony\Component\Console\Input\InputArgument;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+class CampaignDeleteEventLogsCommand extends Command
+{
+    protected static $defaultDescription = 'Delete campaign event logs';
+    /**
+     * @var string
+     */
+    public const COMMAND_NAME = 'mautic:campaign:delete-event-logs';
+    public function __construct(private LeadEventLogRepository $leadEventLogRepository, private CampaignModel $campaignModel, private EventModel $eventModel)
+    {
+        parent::__construct();
+    }
+    protected function configure(): void
+    {
+        $this->setName(self::COMMAND_NAME)
+            ->addArgument(
+                'campaign_event_ids',
+                InputArgument::IS_ARRAY | InputArgument::OPTIONAL,
+                'Campaign event ids to delete event logs.'
+            )
+            ->addOption(
+                '--campaign-id',
+                '-i',
+                InputOption::VALUE_OPTIONAL,
+                'Delete campaign also otherwise will delete event and event log only.'
+            );
+    }
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        $eventIds   = $input->getArgument('campaign_event_ids');
+        $campaignId = (int) $input->getOption('campaign-id');
+        if (!empty($campaignId)) {
+            $this->leadEventLogRepository->removeEventLogsByCampaignId($campaignId);
+            $this->eventModel->deleteEventsByCampaignId($campaignId);
+            $campaign = $this->campaignModel->getEntity($campaignId);
+            $this->campaignModel->deleteCampaign($campaign);
+        } elseif (!empty($eventIds)) {
+            $this->leadEventLogRepository->removeEventLogs($eventIds);
+            $this->eventModel->deleteEventsByEventIds($eventIds);
+        }
+        return Command::SUCCESS;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/ExecuteEventCommand.php
@@ -0,0 +1,51 @@
+<?php
+namespace Mautic\CampaignBundle\Command;
+use Mautic\CampaignBundle\Executioner\ScheduledExecutioner;
+use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
+use Symfony\Component\Console\Command\Command;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ExecuteEventCommand extends Command
+{
+    use WriteCountTrait;
+    public function __construct(
+        private ScheduledExecutioner $scheduledExecutioner,
+        private TranslatorInterface $translator,
+        private FormatterHelper $formatterHelper,
+    ) {
+        parent::__construct();
+    }
+    protected function configure()
+    {
+        $this
+            ->setName('mautic:campaigns:execute')
+            ->addOption(
+                '--scheduled-log-ids',
+                null,
+                InputOption::VALUE_REQUIRED,
+                'CSV of specific scheduled log IDs to execute.'
+            )
+            ->addOption(
+                '--execution-time',
+                null,
+                InputOption::VALUE_REQUIRED,
+                'Scheduled execution time of event log'
+            );
+        parent::configure();
+    }
+    /**
+     * @throws \Exception
+     */
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
+        $now     = empty($input->getOption('execution-time')) ? null : new \DateTime($input->getOption('execution-time'));
+        $ids     = $this->formatterHelper->simpleCsvToArray($input->getOption('scheduled-log-ids'), 'int');
+        $counter = $this->scheduledExecutioner->executeByIds($ids, $output, $now);
+        $this->writeCounts($output, $this->translator, $counter);
+        return Command::SUCCESS;
+    }
+    protected static $defaultDescription = 'Execute specific scheduled events.';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/SummarizeCommand.php
@@ -0,0 +1,67 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Command;
+use Mautic\CampaignBundle\Model\SummaryModel;
+use Mautic\CoreBundle\Command\ModeratedCommand;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class SummarizeCommand extends ModeratedCommand
+{
+    use WriteCountTrait;
+    public const NAME = 'mautic:campaigns:summarize';
+    public function __construct(
+        private TranslatorInterface $translator,
+        private SummaryModel $summaryModel,
+        PathsHelper $pathsHelper,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($pathsHelper, $coreParametersHelper);
+    }
+    protected function configure(): void
+    {
+        $this->setName(self::NAME)
+            ->addOption(
+                '--batch-limit',
+                '-l',
+                InputOption::VALUE_OPTIONAL,
+                'Number of hours to process per batch. 1 hour is default value.',
+                '1'
+            )
+            ->addOption(
+                '--max-hours',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Optionally specify how many hours back in time you wish to summarize.'
+            )
+            ->addOption(
+                '--rebuild',
+                null,
+                InputOption::VALUE_NONE,
+                'Rebuild existing data. To be used only if database exceptions have been known to cause inaccuracies.'
+            );
+        parent::configure();
+    }
+    /**
+     * @throws \Doctrine\DBAL\Exception
+     */
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        if (!$this->checkRunStatus($input, $output)) {
+            return \Symfony\Component\Console\Command\Command::SUCCESS;
+        }
+        $batchLimit = (int) $input->getOption('batch-limit');
+        $maxHours   = (int) $input->getOption('max-hours');
+        $rebuild    = (bool) $input->getOption('rebuild');
+        $output->writeln(
+            "<info>{$this->translator->trans('mautic.campaign.summarizing', ['%batch%' => $batchLimit])}</info>"
+        );
+        $this->summaryModel->summarize($output, $batchLimit, $maxHours, $rebuild);
+        $this->completeRun();
+        return \Symfony\Component\Console\Command\Command::SUCCESS;
+    }
+    protected static $defaultDescription = 'Builds historical campaign summary statistics if they do not already exist.';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/TriggerCampaignCommand.php
@@ -0,0 +1,336 @@
+<?php
+namespace Mautic\CampaignBundle\Command;
+use Exception;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\CampaignBundle\Event\CampaignTriggerEvent;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\InactiveExecutioner;
+use Mautic\CampaignBundle\Executioner\KickoffExecutioner;
+use Mautic\CampaignBundle\Executioner\ScheduledExecutioner;
+use Mautic\CoreBundle\Command\ModeratedCommand;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
+use Mautic\LeadBundle\Helper\SegmentCountCacheHelper;
+use Mautic\LeadBundle\Model\ListModel;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\NullOutput;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class TriggerCampaignCommand extends ModeratedCommand
+{
+    use WriteCountTrait;
+    private bool $kickoffOnly  = false;
+    private bool $inactiveOnly = false;
+    private bool $scheduleOnly = false;
+    /**
+     * @var OutputInterface
+     */
+    protected $output;
+    private ?ContactLimiter $limiter = null;
+    private ?Campaign $campaign = null;
+    public function __construct(
+        private CampaignRepository $campaignRepository,
+        private EventDispatcherInterface $dispatcher,
+        private TranslatorInterface $translator,
+        private KickoffExecutioner $kickoffExecutioner,
+        private ScheduledExecutioner $scheduledExecutioner,
+        private InactiveExecutioner $inactiveExecutioner,
+        private LoggerInterface $logger,
+        private FormatterHelper $formatterHelper,
+        private ListModel $listModel,
+        private SegmentCountCacheHelper $segmentCountCacheHelper,
+        PathsHelper $pathsHelper,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($pathsHelper, $coreParametersHelper);
+    }
+    protected function configure()
+    {
+        $this
+            ->setName('mautic:campaigns:trigger')
+            ->addOption(
+                '--campaign-id',
+                '-i',
+                InputOption::VALUE_OPTIONAL,
+                'Trigger events for a specific campaign.  Otherwise, all campaigns will be triggered.',
+                null
+            )
+            ->addOption(
+                '--campaign-limit',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Limit number of contacts on a per campaign basis',
+                null
+            )
+            ->addOption(
+                '--contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Trigger events for a specific contact.',
+                null
+            )
+            ->addOption(
+                '--contact-ids',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'CSV of contact IDs to evaluate.'
+            )
+            ->addOption(
+                '--min-contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Trigger events starting at a specific contact ID.',
+                null
+            )
+            ->addOption(
+                '--max-contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Trigger events starting up to a specific contact ID.',
+                null
+            )
+            ->addOption(
+                '--thread-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The number of this current process if running multiple in parallel.'
+            )
+            ->addOption(
+                '--max-threads',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The maximum number of processes you intend to run in parallel.'
+            )
+            ->addOption(
+                '--kickoff-only',
+                null,
+                InputOption::VALUE_NONE,
+                'Just kickoff the campaign'
+            )
+            ->addOption(
+                '--scheduled-only',
+                null,
+                InputOption::VALUE_NONE,
+                'Just execute scheduled events'
+            )
+            ->addOption(
+                '--inactive-only',
+                null,
+                InputOption::VALUE_NONE,
+                'Just execute scheduled events'
+            )
+            ->addOption(
+                '--batch-limit',
+                '-l',
+                InputOption::VALUE_OPTIONAL,
+                'Set batch size of contacts to process per round. Defaults to 100.',
+                100
+            )
+            ->addOption(
+                'exclude',
+                'd',
+                InputOption::VALUE_IS_ARRAY | InputOption::VALUE_OPTIONAL,
+                'Exclude a specific campaign from being triggered. Otherwise, all campaigns will be triggered.',
+                []
+            );
+        parent::configure();
+    }
+    /**
+     * @throws \Exception
+     */
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        $quiet              = $input->getOption('quiet');
+        $this->output       = $quiet ? new NullOutput() : $output;
+        $this->kickoffOnly  = $input->getOption('kickoff-only');
+        $this->scheduleOnly = $input->getOption('scheduled-only');
+        $this->inactiveOnly = $input->getOption('inactive-only');
+        $id               = $input->getOption('campaign-id');
+        $batchLimit       = $input->getOption('batch-limit');
+        $campaignLimit    = $input->getOption('campaign-limit');
+        $contactMinId     = $input->getOption('min-contact-id');
+        $contactMaxId     = $input->getOption('max-contact-id');
+        $contactId        = $input->getOption('contact-id');
+        $contactIds       = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
+        $threadId         = $input->getOption('thread-id');
+        $maxThreads       = $input->getOption('max-threads');
+        $excludeCampaigns = $input->getOption('exclude');
+        if (is_numeric($id)) {
+            $id = (int) $id;
+        }
+        if (is_numeric($maxThreads)) {
+            $maxThreads = (int) $maxThreads;
+        }
+        if (is_numeric($threadId)) {
+            $threadId = (int) $threadId;
+        }
+        if (is_numeric($contactMaxId)) {
+            $contactMaxId = (int) $contactMaxId;
+        }
+        if (is_numeric($contactMinId)) {
+            $contactMinId = (int) $contactMinId;
+        }
+        if (is_numeric($contactId)) {
+            $contactId = (int) $contactId;
+        }
+        if (is_numeric($campaignLimit)) {
+            $campaignLimit = (int) $campaignLimit;
+        }
+        if ($threadId && $maxThreads && (int) $threadId > (int) $maxThreads) {
+            $this->output->writeln('--thread-id cannot be larger than --max-thread');
+            return \Symfony\Component\Console\Command\Command::FAILURE;
+        }
+        $this->limiter = new ContactLimiter($batchLimit, $contactId, $contactMinId, $contactMaxId, $contactIds, $threadId, $maxThreads, $campaignLimit);
+        defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
+        $moderationKey = sprintf('%s-%s', $id, $threadId);
+        if (!$this->checkRunStatus($input, $this->output, $moderationKey)) {
+            return \Symfony\Component\Console\Command\Command::SUCCESS;
+        }
+        if ($id) {
+            $statusCode = 0;
+            /** @var Campaign $campaign */
+            if ($campaign = $this->campaignRepository->getEntity($id)) {
+                $this->triggerCampaign($campaign);
+            } else {
+                $output->writeln('<error>'.$this->translator->trans('mautic.campaign.rebuild.not_found', ['%id%' => $id]).'</error>');
+                $statusCode = 1;
+            }
+            $this->completeRun();
+            return (int) $statusCode;
+        }
+        $filter = [
+            'iterable_mode' => true,
+            'orderBy'       => 'c.dateAdded',
+            'orderByDir'    => 'DESC',
+        ];
+        if (is_array($excludeCampaigns) && count($excludeCampaigns) > 0) {
+            $filter['filter'] = [
+                'force' => [
+                    [
+                        'expr'   => 'notIn',
+                        'column' => $this->campaignRepository->getTableAlias().'.id',
+                        'value'  => $excludeCampaigns,
+                    ],
+                ],
+            ];
+        }
+        /** @var \Doctrine\ORM\Internal\Hydration\IterableResult $campaigns */
+        $campaigns = $this->campaignRepository->getEntities($filter);
+        foreach ($campaigns as $campaign) {
+            $this->triggerCampaign($campaign);
+            if ($this->limiter->hasCampaignLimit()) {
+                $this->limiter->resetCampaignLimitRemaining();
+            }
+        }
+        $this->completeRun();
+        return \Symfony\Component\Console\Command\Command::SUCCESS;
+    }
+    /**
+     * @return bool
+     */
+    protected function dispatchTriggerEvent(Campaign $campaign)
+    {
+        if ($this->dispatcher->hasListeners(CampaignEvents::CAMPAIGN_ON_TRIGGER)) {
+            /** @var CampaignTriggerEvent $event */
+            $event = $this->dispatcher->dispatch(
+                new CampaignTriggerEvent($campaign),
+                CampaignEvents::CAMPAIGN_ON_TRIGGER
+            );
+            return $event->shouldTrigger();
+        }
+        return true;
+    }
+    /**
+     * @throws \Exception
+     */
+    private function triggerCampaign(Campaign $campaign): void
+    {
+        if (!$campaign->isPublished()) {
+            return;
+        }
+        if (!$this->dispatchTriggerEvent($campaign)) {
+            return;
+        }
+        $this->campaign = $campaign;
+        try {
+            $this->output->writeln('<info>'.$this->translator->trans('mautic.campaign.trigger.triggering', ['%id%' => $campaign->getId()]).'</info>');
+            $this->limiter->resetBatchMinContactId();
+            if (!$this->inactiveOnly && !$this->scheduleOnly) {
+                $this->executeKickoff();
+            }
+            $this->limiter->resetBatchMinContactId();
+            if (!$this->inactiveOnly && !$this->kickoffOnly) {
+                $this->executeScheduled();
+            }
+            $this->limiter->resetBatchMinContactId();
+            if (!$this->scheduleOnly && !$this->kickoffOnly) {
+                $this->executeInactive();
+            }
+        } catch (\Exception $exception) {
+            if ('prod' !== MAUTIC_ENV) {
+                throw $exception;
+            }
+            $this->logger->error('CAMPAIGN: '.$exception->getMessage());
+        } finally {
+            $this->updateCampaignSegmentContactCount($campaign);
+        }
+        if ('test' !== MAUTIC_ENV) {
+            $this->campaignRepository->detachEntity($campaign);
+        }
+    }
+    /**
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    private function executeKickoff(): void
+    {
+        $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.starting').'</comment>');
+        $counter = $this->kickoffExecutioner->execute($this->campaign, $this->limiter, $this->output);
+        $this->writeCounts($this->output, $this->translator, $counter);
+    }
+    /**
+     * @throws \Doctrine\ORM\Query\QueryException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    private function executeScheduled(): void
+    {
+        $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.scheduled').'</comment>');
+        $counter = $this->scheduledExecutioner->execute($this->campaign, $this->limiter, $this->output);
+        $this->writeCounts($this->output, $this->translator, $counter);
+    }
+    /**
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    private function executeInactive(): void
+    {
+        $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.negative').'</comment>');
+        $counter = $this->inactiveExecutioner->execute($this->campaign, $this->limiter, $this->output);
+        $this->writeCounts($this->output, $this->translator, $counter);
+    }
+    /**
+     * @throws \Exception
+     */
+    private function updateCampaignSegmentContactCount(Campaign $campaign): void
+    {
+        $segmentIds = $this->campaignRepository->getCampaignListIds((int) $campaign->getId());
+        foreach ($segmentIds as $segmentId) {
+            $totalLeadCount = $this->listModel->getRepository()->getLeadCount($segmentId);
+            $this->segmentCountCacheHelper->setSegmentContactCount($segmentId, (int) $totalLeadCount);
+        }
+    }
+    protected static $defaultDescription = 'Trigger timed events for published campaigns.';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/UpdateLeadCampaignsCommand.php
@@ -0,0 +1,198 @@
+<?php
+namespace Mautic\CampaignBundle\Command;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Membership\MembershipBuilder;
+use Mautic\CoreBundle\Command\ModeratedCommand;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\NullOutput;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class UpdateLeadCampaignsCommand extends ModeratedCommand
+{
+    private int $runLimit = 0;
+    private ContactLimiter $contactLimiter;
+    private bool $quiet = false;
+    public function __construct(
+        private CampaignRepository $campaignRepository,
+        private TranslatorInterface $translator,
+        private MembershipBuilder $membershipBuilder,
+        private LoggerInterface $logger,
+        private FormatterHelper $formatterHelper,
+        PathsHelper $pathsHelper,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($pathsHelper, $coreParametersHelper);
+    }
+    protected function configure()
+    {
+        $this
+            ->setName('mautic:campaigns:rebuild')
+            ->setAliases(['mautic:campaigns:update'])
+            ->addOption('--batch-limit', '-l', InputOption::VALUE_OPTIONAL, 'Set batch size of contacts to process per round. Defaults to 300.', 300)
+            ->addOption(
+                '--max-contacts',
+                '-m',
+                InputOption::VALUE_OPTIONAL,
+                'Set max number of contacts to process per campaign for this script execution. Defaults to all.',
+                0
+            )
+            ->addOption(
+                '--campaign-id',
+                '-i',
+                InputOption::VALUE_OPTIONAL,
+                'Build membership for a specific campaign.  Otherwise, all campaigns will be rebuilt.',
+                null
+            )
+            ->addOption(
+                '--contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Build membership for a specific contact.',
+                null
+            )
+            ->addOption(
+                '--contact-ids',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'CSV of contact IDs to evaluate.'
+            )
+            ->addOption(
+                '--min-contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Build membership starting at a specific contact ID.',
+                null
+            )
+            ->addOption(
+                '--max-contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Build membership up to a specific contact ID.',
+                null
+            )
+            ->addOption(
+                '--thread-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The number of this current process if running multiple in parallel.'
+            )
+            ->addOption(
+                '--max-threads',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The maximum number of processes you intend to run in parallel.'
+            )
+            ->addOption(
+                'exclude',
+                'd',
+                InputOption::VALUE_IS_ARRAY | InputOption::VALUE_OPTIONAL,
+                'Exclude a specific campaign from being rebuilt. Otherwise, all campaigns will be rebuilt.',
+                []
+            );
+        parent::configure();
+    }
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        $id               = $input->getOption('campaign-id');
+        $batchLimit       = $input->getOption('batch-limit');
+        $contactMinId     = $input->getOption('min-contact-id');
+        $contactMaxId     = $input->getOption('max-contact-id');
+        $contactId        = $input->getOption('contact-id');
+        $contactIds       = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
+        $threadId         = $input->getOption('thread-id');
+        $maxThreads       = $input->getOption('max-threads');
+        $this->runLimit   = $input->getOption('max-contacts');
+        $this->quiet      = (bool) $input->getOption('quiet');
+        $this->output     = ($this->quiet) ? new NullOutput() : $output;
+        $excludeCampaigns = $input->getOption('exclude');
+        if (is_numeric($id)) {
+            $id = (int) $id;
+        }
+        if (is_numeric($maxThreads)) {
+            $maxThreads = (int) $maxThreads;
+        }
+        if (is_numeric($threadId)) {
+            $threadId = (int) $threadId;
+        }
+        if (is_numeric($contactMaxId)) {
+            $contactMaxId = (int) $contactMaxId;
+        }
+        if (is_numeric($contactMinId)) {
+            $contactMinId = (int) $contactMinId;
+        }
+        if (is_numeric($contactId)) {
+            $contactId = (int) $contactId;
+        }
+        if ($threadId && $maxThreads && (int) $threadId > (int) $maxThreads) {
+            $this->output->writeln('--thread-id cannot be larger than --max-thread');
+            return \Symfony\Component\Console\Command\Command::FAILURE;
+        }
+        if (!$this->checkRunStatus($input, $output, $id)) {
+            return \Symfony\Component\Console\Command\Command::SUCCESS;
+        }
+        $this->contactLimiter = new ContactLimiter($batchLimit, $contactId, $contactMinId, $contactMaxId, $contactIds, $threadId, $maxThreads);
+        if ($id) {
+            $campaign = $this->campaignRepository->getEntity($id);
+            if (null === $campaign) {
+                $output->writeln('<error>'.$this->translator->trans('mautic.campaign.rebuild.not_found', ['%id%' => $id]).'</error>');
+                return \Symfony\Component\Console\Command\Command::FAILURE;
+            }
+            $this->updateCampaign($campaign);
+        } else {
+            $filter = [
+                'iterable_mode' => true,
+            ];
+            if (is_array($excludeCampaigns) && count($excludeCampaigns) > 0) {
+                $filter['filter'] = [
+                    'force' => [
+                        [
+                            'expr'   => 'notIn',
+                            'column' => $this->campaignRepository->getTableAlias().'.id',
+                            'value'  => $excludeCampaigns,
+                        ],
+                    ],
+                ];
+            }
+            $campaigns = $this->campaignRepository->getEntities($filter);
+            foreach ($campaigns as $campaign) {
+                $this->updateCampaign($campaign);
+                unset($campaign);
+            }
+        }
+        $this->completeRun();
+        return \Symfony\Component\Console\Command\Command::SUCCESS;
+    }
+    /**
+     * @throws \Exception
+     */
+    private function updateCampaign(Campaign $campaign): void
+    {
+        if (!$campaign->isPublished()) {
+            return;
+        }
+        try {
+            $this->output->writeln(
+                '<info>'.$this->translator->trans('mautic.campaign.rebuild.rebuilding', ['%id%' => $campaign->getId()]).'</info>'
+            );
+            $this->contactLimiter->resetBatchMinContactId();
+            $this->membershipBuilder->build($campaign, $this->contactLimiter, $this->runLimit, ($this->quiet) ? null : $this->output);
+        } catch (\Exception $exception) {
+            if ('prod' !== MAUTIC_ENV) {
+                throw $exception;
+            }
+            $this->logger->error('CAMPAIGN: '.$exception->getMessage());
+        }
+        if ('test' !== MAUTIC_ENV) {
+            $this->campaignRepository->detachEntity($campaign);
+        }
+        $this->output->writeln('');
+    }
+    protected static $defaultDescription = 'Rebuild campaigns based on contact segments.';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Command/ValidateEventCommand.php
@@ -0,0 +1,74 @@
+<?php
+namespace Mautic\CampaignBundle\Command;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\InactiveExecutioner;
+use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
+use Symfony\Component\Console\Command\Command;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ValidateEventCommand extends Command
+{
+    use WriteCountTrait;
+    public function __construct(
+        private InactiveExecutioner $inactiveExecution,
+        private TranslatorInterface $translator,
+        private FormatterHelper $formatterHelper,
+    ) {
+        parent::__construct();
+    }
+    protected function configure()
+    {
+        $this
+            ->setName('mautic:campaigns:validate')
+            ->addOption(
+                '--decision-id',
+                null,
+                InputOption::VALUE_REQUIRED,
+                'ID of the decision to evaluate.'
+            )
+            ->addOption(
+                '--contact-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'Evaluate for specific contact'
+            )
+            ->addOption(
+                '--contact-ids',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'CSV of contact IDs to evaluate.'
+            );
+        parent::configure();
+    }
+    /**
+     * @throws \Exception
+     */
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
+        $decisionId = $input->getOption('decision-id');
+        $contactId  = $input->getOption('contact-id');
+        if (is_numeric($decisionId)) {
+            $decisionId = (int) $decisionId;
+        }
+        if (is_numeric($contactId)) {
+            $contactId = (int) $contactId;
+        }
+        $contactIds = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
+        if (!$contactIds && !$contactId) {
+            $output->writeln(
+                "\n".
+                '<comment>'.$this->translator->trans('mautic.campaign.trigger.events_executed', ['%count%' => 0])
+                .'</comment>'
+            );
+            return Command::SUCCESS;
+        }
+        $limiter = new ContactLimiter(null, $contactId, null, null, $contactIds);
+        $counter = $this->inactiveExecution->validate($decisionId, $limiter, $output);
+        $this->writeCounts($output, $this->translator, $counter);
+        return Command::SUCCESS;
+    }
+    protected static $defaultDescription = 'Validate if a contact has been inactive for a decision and execute events if so.';
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Config/config.php
@@ -0,0 +1,377 @@
+<?php
+return [
+    'routes' => [
+        'main' => [
+            'mautic_campaignevent_action'  => [
+                'path'       => '/campaigns/events/{objectAction}/{objectId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\EventController::executeAction',
+            ],
+            'mautic_campaignsource_action' => [
+                'path'       => '/campaigns/sources/{objectAction}/{objectId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\SourceController::executeAction',
+            ],
+            'mautic_campaign_index'        => [
+                'path'       => '/campaigns/{page}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::indexAction',
+            ],
+            'mautic_campaign_action'       => [
+                'path'       => '/campaigns/{objectAction}/{objectId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::executeAction',
+            ],
+            'mautic_campaign_contacts'     => [
+                'path'       => '/campaigns/view/{objectId}/contact/{page}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::contactsAction',
+            ],
+            'mautic_campaign_preview'      => [
+                'path'       => '/campaign/preview/{objectId}',
+                'controller' => 'Mautic\EmailBundle\Controller\PublicController::previewAction',
+            ],
+            'mautic_campaign_map_stats' => [
+                'path'       => '/campaign-map-stats/{objectId}/{dateFrom}/{dateTo}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignMapStatsController::viewAction',
+            ],
+            'mautic_campaign_metrics_email_weekdays' => [
+                'path'       => '/campaign/metrics/email-weekdays/{objectId}/{dateFrom}/{dateTo}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignMetricsController::emailWeekdaysAction',
+            ],
+            'mautic_campaign_metrics_email_hours' => [
+                'path'       => '/campaign/metrics/email-hours/{objectId}/{dateFrom}/{dateTo}',
+                'controller' => 'Mautic\CampaignBundle\Controller\CampaignMetricsController::emailHoursAction',
+            ],
+        ],
+        'api'  => [
+            'mautic_api_campaignsstandard'            => [
+                'standard_entity' => true,
+                'name'            => 'campaigns',
+                'path'            => '/campaigns',
+                'controller'      => Mautic\CampaignBundle\Controller\Api\CampaignApiController::class,
+            ],
+            'mautic_api_campaigneventsstandard'       => [
+                'standard_entity'     => true,
+                'supported_endpoints' => [
+                    'getone',
+                    'getall',
+                ],
+                'name'                => 'events',
+                'path'                => '/campaigns/events',
+                'controller'          => Mautic\CampaignBundle\Controller\Api\EventApiController::class,
+            ],
+            'mautic_api_campaigns_events_contact'     => [
+                'path'       => '/campaigns/events/contact/{contactId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::getContactEventsAction',
+                'method'     => 'GET',
+            ],
+            'mautic_api_campaigns_edit_contact_event' => [
+                'path'       => '/campaigns/events/{eventId}/contact/{contactId}/edit',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::editContactEventAction',
+                'method'     => 'PUT',
+            ],
+            'mautic_api_campaigns_batchedit_events'   => [
+                'path'       => '/campaigns/events/batch/edit',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::editEventsAction',
+                'method'     => 'PUT',
+            ],
+            'mautic_api_campaign_contact_events'      => [
+                'path'       => '/campaigns/{campaignId}/events/contact/{contactId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::getContactEventsAction',
+                'method'     => 'GET',
+            ],
+            'mautic_api_campaigngetcontacts'          => [
+                'path'       => '/campaigns/{id}/contacts',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::getContactsAction',
+            ],
+            'mautic_api_campaignaddcontact'           => [
+                'path'       => '/campaigns/{id}/contact/{leadId}/add',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::addLeadAction',
+                'method'     => 'POST',
+            ],
+            'mautic_api_campaignremovecontact'        => [
+                'path'       => '/campaigns/{id}/contact/{leadId}/remove',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::removeLeadAction',
+                'method'     => 'POST',
+            ],
+            'mautic_api_contact_clone_campaign' => [
+                'path'       => '/campaigns/clone/{campaignId}',
+                'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::cloneCampaignAction',
+                'method'     => 'POST',
+            ],
+        ],
+    ],
+    'menu' => [
+        'main' => [
+            'mautic.campaign.menu.index' => [
+                'iconClass' => 'ri-megaphone-fill',
+                'route'     => 'mautic_campaign_index',
+                'access'    => 'campaign:campaigns:view',
+                'priority'  => 50,
+            ],
+        ],
+    ],
+    'categories' => [
+        'campaign' => [
+            'class' => Mautic\CampaignBundle\Entity\Campaign::class,
+        ],
+    ],
+    'services' => [
+        'execution'    => [
+            'mautic.campaign.contact_finder.kickoff'  => [
+                'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\KickoffContactFinder::class,
+                'arguments' => [
+                    'mautic.lead.repository.lead',
+                    'mautic.campaign.repository.campaign',
+                    'monolog.logger.mautic',
+                ],
+            ],
+            'mautic.campaign.contact_finder.scheduled'  => [
+                'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\ScheduledContactFinder::class,
+                'arguments' => [
+                    'mautic.lead.repository.lead',
+                    'monolog.logger.mautic',
+                ],
+            ],
+            'mautic.campaign.contact_finder.inactive'     => [
+                'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder::class,
+                'arguments' => [
+                    'mautic.lead.repository.lead',
+                    'mautic.campaign.repository.lead',
+                    'monolog.logger.mautic',
+                ],
+            ],
+            'mautic.campaign.dispatcher.action'        => [
+                'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher::class,
+                'arguments' => [
+                    'event_dispatcher',
+                    'monolog.logger.mautic',
+                    'mautic.campaign.scheduler',
+                    'mautic.campaign.legacy_event_dispatcher',
+                ],
+            ],
+            'mautic.campaign.dispatcher.condition'        => [
+                'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\ConditionDispatcher::class,
+                'arguments' => [
+                    'event_dispatcher',
+                ],
+            ],
+            'mautic.campaign.dispatcher.decision'        => [
+                'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\DecisionDispatcher::class,
+                'arguments' => [
+                    'event_dispatcher',
+                    'mautic.campaign.legacy_event_dispatcher',
+                ],
+            ],
+            'mautic.campaign.event_logger' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Logger\EventLogger::class,
+                'arguments' => [
+                    'mautic.helper.ip_lookup',
+                    'mautic.tracker.contact',
+                    'mautic.campaign.repository.lead_event_log',
+                    'mautic.campaign.repository.lead',
+                    'mautic.campaign.model.summary',
+                ],
+            ],
+            'mautic.campaign.event_collector' => [
+                'class'     => Mautic\CampaignBundle\EventCollector\EventCollector::class,
+                'arguments' => [
+                    'translator',
+                    'event_dispatcher',
+                ],
+            ],
+            'mautic.campaign.scheduler.datetime'      => [
+                'class'     => Mautic\CampaignBundle\Executioner\Scheduler\Mode\DateTime::class,
+                'arguments' => [
+                    'monolog.logger.mautic',
+                ],
+            ],
+            'mautic.campaign.scheduler.interval'      => [
+                'class'     => Mautic\CampaignBundle\Executioner\Scheduler\Mode\Interval::class,
+                'arguments' => [
+                    'monolog.logger.mautic',
+                    'mautic.helper.core_parameters',
+                ],
+            ],
+            'mautic.campaign.scheduler'               => [
+                'class'     => Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler::class,
+                'arguments' => [
+                    'monolog.logger.mautic',
+                    'mautic.campaign.event_logger',
+                    'mautic.campaign.scheduler.interval',
+                    'mautic.campaign.scheduler.datetime',
+                    'mautic.campaign.scheduler.optimized',
+                    'mautic.campaign.event_collector',
+                    'event_dispatcher',
+                    'mautic.helper.core_parameters',
+                ],
+            ],
+            'mautic.campaign.executioner.action' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Event\ActionExecutioner::class,
+                'arguments' => [
+                    'mautic.campaign.dispatcher.action',
+                    'mautic.campaign.event_logger',
+                ],
+            ],
+            'mautic.campaign.executioner.condition' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Event\ConditionExecutioner::class,
+                'arguments' => [
+                    'mautic.campaign.dispatcher.condition',
+                ],
+            ],
+            'mautic.campaign.executioner.decision' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Event\DecisionExecutioner::class,
+                'arguments' => [
+                    'mautic.campaign.event_logger',
+                    'mautic.campaign.dispatcher.decision',
+                ],
+            ],
+            'mautic.campaign.event_executioner' => [
+                'class'     => Mautic\CampaignBundle\Executioner\EventExecutioner::class,
+                'arguments' => [
+                    'mautic.campaign.event_collector',
+                    'mautic.campaign.event_logger',
+                    'mautic.campaign.executioner.action',
+                    'mautic.campaign.executioner.condition',
+                    'mautic.campaign.executioner.decision',
+                    'monolog.logger.mautic',
+                    'mautic.campaign.scheduler',
+                    'mautic.campaign.helper.removed_contact_tracker',
+                ],
+            ],
+            'mautic.campaign.executioner.kickoff'     => [
+                'class'     => Mautic\CampaignBundle\Executioner\KickoffExecutioner::class,
+                'arguments' => [
+                    'monolog.logger.mautic',
+                    'mautic.campaign.contact_finder.kickoff',
+                    'translator',
+                    'mautic.campaign.event_executioner',
+                    'mautic.campaign.scheduler',
+                ],
+            ],
+            'mautic.campaign.executioner.realtime'     => [
+                'class'     => Mautic\CampaignBundle\Executioner\RealTimeExecutioner::class,
+                'arguments' => [
+                    'monolog.logger.mautic',
+                    'mautic.lead.model.lead',
+                    'mautic.campaign.repository.event',
+                    'mautic.campaign.event_executioner',
+                    'mautic.campaign.executioner.decision',
+                    'mautic.campaign.event_collector',
+                    'mautic.campaign.scheduler',
+                    'mautic.tracker.contact',
+                    'mautic.campaign.helper.decision',
+                ],
+            ],
+            'mautic.campaign.helper.decision' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Helper\DecisionHelper::class,
+                'arguments' => [
+                    'mautic.campaign.repository.lead',
+                ],
+            ],
+            'mautic.campaign.helper.inactivity' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Helper\InactiveHelper::class,
+                'arguments' => [
+                    'mautic.campaign.scheduler',
+                    'mautic.campaign.contact_finder.inactive',
+                    'mautic.campaign.repository.lead_event_log',
+                    'mautic.campaign.repository.event',
+                    'monolog.logger.mautic',
+                    'mautic.campaign.helper.decision',
+                ],
+            ],
+            'mautic.campaign.helper.removed_contact_tracker' => [
+                'class' => Mautic\CampaignBundle\Helper\RemovedContactTracker::class,
+            ],
+            'mautic.campaign.helper.notification' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Helper\NotificationHelper::class,
+                'arguments' => [
+                    'mautic.user.model.user',
+                    'mautic.core.model.notification',
+                    'translator',
+                    'router',
+                    'mautic.helper.core_parameters',
+                ],
+            ],
+            'mautic.campaign.legacy_event_dispatcher' => [
+                'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\LegacyEventDispatcher::class,
+                'arguments' => [
+                    'event_dispatcher',
+                    'mautic.campaign.scheduler',
+                    'monolog.logger.mautic',
+                    'mautic.tracker.contact',
+                ],
+            ],
+        ],
+        'membership' => [
+            'mautic.campaign.membership.adder' => [
+                'class'     => Mautic\CampaignBundle\Membership\Action\Adder::class,
+                'arguments' => [
+                    'mautic.campaign.repository.lead',
+                    'mautic.campaign.repository.lead_event_log',
+                ],
+            ],
+            'mautic.campaign.membership.remover' => [
+                'class'     => Mautic\CampaignBundle\Membership\Action\Remover::class,
+                'arguments' => [
+                    'mautic.campaign.repository.lead',
+                    'mautic.campaign.repository.lead_event_log',
+                    'translator',
+                    'mautic.helper.twig.date',
+                ],
+            ],
+            'mautic.campaign.membership.event_dispatcher' => [
+                'class'     => Mautic\CampaignBundle\Membership\EventDispatcher::class,
+                'arguments' => [
+                    'event_dispatcher',
+                ],
+            ],
+            'mautic.campaign.membership.manager' => [
+                'class'     => Mautic\CampaignBundle\Membership\MembershipManager::class,
+                'arguments' => [
+                    'mautic.campaign.membership.adder',
+                    'mautic.campaign.membership.remover',
+                    'mautic.campaign.membership.event_dispatcher',
+                    'mautic.campaign.repository.lead',
+                    'monolog.logger.mautic',
+                ],
+            ],
+            'mautic.campaign.membership.builder' => [
+                'class'     => Mautic\CampaignBundle\Membership\MembershipBuilder::class,
+                'arguments' => [
+                    'mautic.campaign.membership.manager',
+                    'mautic.campaign.repository.lead',
+                    'mautic.lead.repository.lead',
+                    'translator',
+                ],
+            ],
+        ],
+        'services' => [
+            'mautic.campaign.service.campaign'=> [
+                /** @phpstan-ignore-next-line */
+                'class'     => Mautic\CampaignBundle\Service\Campaign::class,
+                'arguments' => [
+                    'mautic.campaign.repository.campaign',
+                    'mautic.email.repository.email',
+                ],
+            ],
+        ],
+        'fixtures' => [
+            'mautic.campaign.fixture.campaign' => [
+                'class'    => Mautic\CampaignBundle\DataFixtures\ORM\CampaignData::class,
+                'tag'      => Doctrine\Bundle\FixturesBundle\DependencyInjection\CompilerPass\FixturesCompilerPass::FIXTURE_TAG,
+                'optional' => true,
+            ],
+        ],
+    ],
+    'parameters' => [
+        'campaign_time_wait_on_event_false'                                                     => 'PT1H',
+        'campaign_use_summary'                                                                  => 0,
+        'campaign_by_range'                                                                     => 0,
+        'delete_campaign_event_log_in_background'                                               => false,
+        'campaign_email_stats_enabled'                                                          => true,
+        'peak_interaction_timer_cache_timeout'                                                  => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_CACHE_TIMEOUT,
+        'peak_interaction_timer_best_default_hour_start'                                        => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_HOUR_START,
+        'peak_interaction_timer_best_default_hour_end'                                          => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_HOUR_END,
+        'peak_interaction_timer_best_default_days'                                              => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_DAYS,
+        'peak_interaction_timer_fetch_interactions_from'                                        => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_FETCH_INTERACTIONS_FROM,
+        'peak_interaction_timer_fetch_limit'                                                    => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_FETCH_LIMIT,
+        'peak_interaction_timer_max_optimal_days'                                               => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_MAX_OPTIMAL_DAYS,
+    ],
+];

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Config/services.php
@@ -0,0 +1,43 @@
+<?php
+declare(strict_types=1);
+use Mautic\CoreBundle\DependencyInjection\MauticCoreExtension;
+use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
+return function (ContainerConfigurator $configurator): void {
+    $services = $configurator->services()
+        ->defaults()
+        ->autowire()
+        ->autoconfigure()
+        ->public();
+    $excludes = [
+        'EventCollector',
+        'Executioner/ContactFinder/Limiter/ContactLimiter.php',
+        'Executioner/Dispatcher/Exception',
+        'Executioner/Scheduler/Mode/DAO',
+        'Membership/Exception',
+    ];
+    $services->load('Mautic\\CampaignBundle\\', '../')
+        ->exclude('../{'.implode(',', array_merge(MauticCoreExtension::DEFAULT_EXCLUDES, $excludes)).'}');
+    $services->load('Mautic\\CampaignBundle\\Entity\\', '../Entity/*Repository.php')
+        ->tag(Doctrine\Bundle\DoctrineBundle\DependencyInjection\Compiler\ServiceRepositoryCompilerPass::REPOSITORY_SERVICE_TAG);
+    $services->alias('mautic.campaign.model.campaign', Mautic\CampaignBundle\Model\CampaignModel::class);
+    $services->alias('mautic.campaign.model.event', Mautic\CampaignBundle\Model\EventModel::class);
+    $services->alias('mautic.campaign.model.event_log', Mautic\CampaignBundle\Model\EventLogModel::class);
+    $services->alias('mautic.campaign.model.summary', Mautic\CampaignBundle\Model\SummaryModel::class);
+    $services->alias('mautic.campaign.repository.campaign', Mautic\CampaignBundle\Entity\CampaignRepository::class);
+    $services->alias('mautic.campaign.repository.lead', Mautic\CampaignBundle\Entity\LeadRepository::class);
+    $services->alias('mautic.campaign.repository.event', Mautic\CampaignBundle\Entity\EventRepository::class);
+    $services->alias('mautic.campaign.repository.lead_event_log', Mautic\CampaignBundle\Entity\LeadEventLogRepository::class);
+    $services->alias('mautic.campaign.repository.summary', Mautic\CampaignBundle\Entity\SummaryRepository::class);
+    $services->alias('mautic.campaign.executioner.inactive', Mautic\CampaignBundle\Executioner\InactiveExecutioner::class);
+    $services->alias('mautic.campaign.executioner.scheduled', Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class);
+    $services->alias('mautic.campaign.scheduler.optimized', Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized::class);
+    $services->set(Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class)->tag('kernel.reset', ['method' => 'reset']);
+    if ('test' === ($_ENV['APP_ENV'] ?? $_SERVER['APP_ENV'] ?? 'prod')) {
+        $services->set(Mautic\CampaignBundle\Executioner\TestInactiveExecutioner::class)
+            ->decorate(Mautic\CampaignBundle\Executioner\InactiveExecutioner::class)
+            ->tag('kernel.reset', ['method' => 'reset']);
+        $services->set(Mautic\CampaignBundle\Executioner\TestScheduledExecutioner::class)
+            ->decorate(Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class)
+            ->tag('kernel.reset', ['method' => 'reset']);
+    }
+};

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/AjaxController.php
@@ -0,0 +1,120 @@
+<?php
+namespace Mautic\CampaignBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Model\EventLogModel;
+use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\CoreBundle\Twig\Helper\DateHelper;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+class AjaxController extends CommonAjaxController
+{
+    public function __construct(
+        private DateHelper $dateHelper,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    public function updateConnectionsAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
+    {
+        $session        = $request->getSession();
+        $campaignId     = InputHelper::clean($request->query->get('campaignId'));
+        $canvasSettings = $request->request->all()['canvasSettings'] ?? [];
+        if (empty($campaignId)) {
+            $dataArray = ['success' => 0];
+        } else {
+            $session->set('mautic.campaign.'.$campaignId.'.events.canvassettings', $canvasSettings);
+            $dataArray = ['success' => 1];
+        }
+        return $this->sendJsonResponse($dataArray);
+    }
+    public function updateScheduledCampaignEventAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
+    {
+        $eventId      = (int) $request->request->get('eventId');
+        $contactId    = (int) $request->request->get('contactId');
+        $newDate      = InputHelper::clean($request->request->get('date'));
+        $originalDate = InputHelper::clean($request->request->get('originalDate'));
+        $dataArray = ['success' => 0, 'date' => $originalDate];
+        if (!empty($eventId) && !empty($contactId) && !empty($newDate)) {
+            if ($log = $this->getContactEventLog($eventId, $contactId)) {
+                $newDate = new \DateTime($newDate);
+                if ($newDate >= new \DateTime()) {
+                    $log->setTriggerDate($newDate);
+                    /** @var EventLogModel $logModel */
+                    $logModel = $this->getModel('campaign.event_log');
+                    $logModel->saveEntity($log);
+                    $dataArray = [
+                        'success' => 1,
+                        'date'    => $newDate->format('Y-m-d H:i:s'),
+                    ];
+                }
+            }
+        }
+        $dataArray['formattedDate'] = $this->dateHelper->toFull($dataArray['date']);
+        return $this->sendJsonResponse($dataArray);
+    }
+    public function cancelScheduledCampaignEventAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
+    {
+        $dataArray = ['success' => 0];
+        $eventId   = (int) $request->request->get('eventId');
+        $contactId = (int) $request->request->get('contactId');
+        if (!empty($eventId) && !empty($contactId)) {
+            if ($log = $this->getContactEventLog($eventId, $contactId)) {
+                $log->setIsScheduled(false);
+                /** @var EventLogModel $logModel */
+                $logModel           = $this->getModel('campaign.event_log');
+                $metadata           = $log->getMetadata();
+                $metadata['errors'] = $this->translator->trans(
+                    'mautic.campaign.event.cancelled.time',
+                    ['%date%' => $log->getTriggerDate()->format('Y-m-d H:i:s')]
+                );
+                $log->setMetadata($metadata);
+                $logModel->getRepository()->saveEntity($log);
+                $dataArray = ['success' => 1];
+            }
+        }
+        return $this->sendJsonResponse($dataArray);
+    }
+    /**
+     * @return LeadEventLog|null
+     */
+    protected function getContactEventLog($eventId, $contactId)
+    {
+        $contact = $this->getModel('lead')->getEntity($contactId);
+        if ($contact) {
+            if ($this->security->hasEntityAccess('lead:leads:editown', 'lead:leads:editother', $contact->getPermissionUser())) {
+                /** @var EventLogModel $logModel */
+                $logModel = $this->getModel('campaign.event_log');
+                /** @var LeadEventLog $log */
+                $log = $logModel->getRepository()
+                                ->findOneBy(
+                                    [
+                                        'lead'  => $contactId,
+                                        'event' => $eventId,
+                                    ],
+                                    ['dateTriggered' => 'desc']
+                                );
+                if ($log && ($log->getTriggerDate() > new \DateTime())) {
+                    return $log;
+                }
+            }
+        }
+        return null;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/Api/CampaignApiController.php
@@ -0,0 +1,296 @@
+<?php
+namespace Mautic\CampaignBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Controller\CommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Membership\MembershipManager;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Controller\LeadAccessTrait;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Component\Validator\ConstraintViolationInterface;
+use Symfony\Component\Validator\ConstraintViolationListInterface;
+use Symfony\Component\Validator\Validator\ValidatorInterface;
+/**
+ * @extends CommonApiController<Campaign>
+ */
+class CampaignApiController extends CommonApiController
+{
+    use LeadAccessTrait;
+    /**
+     * @var CampaignModel|null
+     */
+    protected $model;
+    public function __construct(
+        CorePermissions $security,
+        Translator $translator,
+        EntityResultHelper $entityResultHelper,
+        RouterInterface $router,
+        FormFactoryInterface $formFactory,
+        AppVersion $appVersion,
+        private RequestStack $requestStack,
+        private MembershipManager $membershipManager,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        EventDispatcherInterface $dispatcher,
+        CoreParametersHelper $coreParametersHelper,
+        private ValidatorInterface $validator,
+        private EventModel $eventModel,
+    ) {
+        $campaignModel = $modelFactory->getModel('campaign');
+        \assert($campaignModel instanceof CampaignModel);
+        $this->model             = $campaignModel;
+        $this->entityClass       = Campaign::class;
+        $this->entityNameOne     = 'campaign';
+        $this->entityNameMulti   = 'campaigns';
+        $this->permissionBase    = 'campaign:campaigns';
+        $this->serializerGroups  = ['campaignDetails', 'campaignEventDetails', 'categoryList', 'publishDetails', 'leadListList', 'formList'];
+        parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * Adds a lead to a campaign.
+     *
+     * @param int $id     Campaign ID
+     * @param int $leadId Lead ID
+     *
+     * @return Response
+     *
+     * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
+     */
+    public function addLeadAction($id, $leadId)
+    {
+        $entity = $this->model->getEntity($id);
+        if (null !== $entity) {
+            $leadModel = $this->getModel('lead');
+            $lead      = $leadModel->getEntity($leadId);
+            if (null == $lead) {
+                return $this->notFound();
+            } elseif (!$this->security->hasEntityAccess('lead:leads:editown', 'lead:leads:editother', $lead->getOwner())) {
+                return $this->accessDenied();
+            }
+            $this->membershipManager->addContact($lead, $entity);
+            $view = $this->view(['success' => 1], Response::HTTP_OK);
+            return $this->handleView($view);
+        }
+        return $this->notFound();
+    }
+    /**
+     * Removes given lead from a campaign.
+     *
+     * @param int $id     Campaign ID
+     * @param int $leadId Lead ID
+     *
+     * @return Response
+     *
+     * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
+     */
+    public function removeLeadAction($id, $leadId)
+    {
+        $entity = $this->model->getEntity($id);
+        if (null !== $entity) {
+            $lead = $this->checkLeadAccess($leadId, 'edit');
+            if ($lead instanceof Response) {
+                return $lead;
+            }
+            $this->membershipManager->removeContact($lead, $entity);
+            $view = $this->view(['success' => 1], Response::HTTP_OK);
+            return $this->handleView($view);
+        }
+        return $this->notFound();
+    }
+    /**
+     * @param Campaign &$entity
+     * @param string   $action
+     */
+    protected function preSaveEntity(&$entity, $form, $parameters, $action = 'edit')
+    {
+        $method = $this->requestStack->getCurrentRequest()->getMethod();
+        if ('POST' === $method || 'PUT' === $method) {
+            if (empty($parameters['events'])) {
+                $msg = $this->translator->trans('mautic.campaign.form.events.notempty', [], 'validators');
+                return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
+            } elseif (empty($parameters['lists']) && empty($parameters['forms'])) {
+                $msg = $this->translator->trans('mautic.campaign.form.sources.notempty', [], 'validators');
+                return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
+            }
+        }
+        $deletedSources = ['lists' => [], 'forms' => []];
+        $deletedEvents  = [];
+        $currentSources = [
+            'lists' => isset($parameters['lists']) ? $this->modifyCampaignEventArray($parameters['lists']) : [],
+            'forms' => isset($parameters['forms']) ? $this->modifyCampaignEventArray($parameters['forms']) : [],
+        ];
+        if ('PUT' === $method) {
+            $requestEventIds   = [];
+            $requestSegmentIds = [];
+            $requestFormIds    = [];
+            foreach ($parameters['events'] as $key => $requestEvent) {
+                if (!isset($requestEvent['id'])) {
+                    return $this->returnError('$campaign[events]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
+                }
+                $requestEventIds[] = $requestEvent['id'];
+            }
+            foreach ($entity->getEvents() as $currentEvent) {
+                if (!in_array($currentEvent->getId(), $requestEventIds)) {
+                    $deletedEvents[] = $currentEvent->getId();
+                }
+            }
+            if (isset($parameters['lists'])) {
+                foreach ($parameters['lists'] as $requestSegment) {
+                    if (!isset($requestSegment['id'])) {
+                        return $this->returnError('$campaign[lists]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
+                    }
+                    $requestSegmentIds[] = $requestSegment['id'];
+                }
+            }
+            foreach ($entity->getLists() as $currentSegment) {
+                if (!in_array($currentSegment->getId(), $requestSegmentIds)) {
+                    $deletedSources['lists'][$currentSegment->getId()] = 'ignore';
+                }
+            }
+            if (isset($parameters['forms'])) {
+                foreach ($parameters['forms'] as $requestForm) {
+                    if (!isset($requestForm['id'])) {
+                        return $this->returnError('$campaign[forms]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
+                    }
+                    $requestFormIds[] = $requestForm['id'];
+                }
+            }
+            foreach ($entity->getForms() as $currentForm) {
+                if (!in_array($currentForm->getId(), $requestFormIds)) {
+                    $deletedSources['forms'][$currentForm->getId()] = 'ignore';
+                }
+            }
+        }
+        $this->model->setLeadSources($entity, $currentSources, $deletedSources);
+        if (isset($parameters['events']) && isset($parameters['canvasSettings'])) {
+            $this->model->setEvents($entity, $parameters['events'], $parameters['canvasSettings'], $deletedEvents);
+        }
+        /** @var array<ConstraintViolationListInterface<ConstraintViolationInterface>> $eventViolations */
+        $eventViolations = array_filter(
+            array_map(
+                fn (Event $event) => $this->validator->validate($event),
+                $entity->getEvents()->toArray()
+            ),
+            fn ($error) => $error->count() > 0
+        );
+        if (count($eventViolations) > 0) {
+            $errors = [];
+            foreach ($eventViolations as $violationList) {
+                foreach ($violationList as $violation) {
+                    \assert($violation instanceof ConstraintViolationInterface);
+                    $errors[] = [
+                        'code'    => $violation->getCode(),
+                        'message' => $violation->getMessage(),
+                        'details' => $violation->getPropertyPath(),
+                        'type'    => 'validation',
+                    ];
+                }
+            }
+            $view = $this->view(['errors' => $errors], Response::HTTP_UNPROCESSABLE_ENTITY);
+            return $this->handleView($view);
+        }
+        $this->model->saveEntity($entity);
+        if (isset($parameters['canvasSettings'])) {
+            $this->model->setCanvasSettings($entity, $parameters['canvasSettings']);
+        }
+        if (Request::METHOD_PUT === $method && !empty($deletedEvents)) {
+            $this->eventModel->deleteEvents($entity->getEvents()->toArray(), $deletedEvents);
+        }
+    }
+    /**
+     * Change the array structure.
+     *
+     * @param array $events
+     */
+    public function modifyCampaignEventArray($events): array
+    {
+        $updatedEvents = [];
+        if ($events && is_array($events)) {
+            foreach ($events as $event) {
+                if (!empty($event['id'])) {
+                    $updatedEvents[$event['id']] = 'ignore';
+                }
+            }
+        }
+        return $updatedEvents;
+    }
+    /**
+     * Obtains a list of campaign contacts.
+     *
+     * @return Response
+     */
+    public function getContactsAction(Request $request, $id)
+    {
+        $entity = $this->model->getEntity($id);
+        if (null === $entity) {
+            return $this->notFound();
+        }
+        if (!$this->checkEntityAccess($entity)) {
+            return $this->accessDenied();
+        }
+        $where = InputHelper::clean($request->query->get('where') ?? []);
+        $order = InputHelper::clean($request->query->get('order') ?? []);
+        $start = (int) $request->query->get('start', 0);
+        $limit = (int) $request->query->get('limit', 100);
+        $where[] = [
+            'col'  => 'campaign_id',
+            'expr' => 'eq',
+            'val'  => $id,
+        ];
+        $where[] = [
+            'col'  => 'manually_removed',
+            'expr' => 'eq',
+            'val'  => 0,
+        ];
+        return $this->forward(
+            'Mautic\CoreBundle\Controller\Api\StatsApiController::listAction',
+            [
+                'table'     => 'campaign_leads',
+                'itemsName' => 'contacts',
+                'order'     => $order,
+                'where'     => $where,
+                'start'     => $start,
+                'limit'     => $limit,
+            ]
+        );
+    }
+    public function cloneCampaignAction($campaignId)
+    {
+        if (empty($campaignId) || false == intval($campaignId)) {
+            return $this->notFound();
+        }
+        $original = $this->model->getEntity($campaignId);
+        if (empty($original)) {
+            return $this->notFound();
+        }
+        $entity = clone $original;
+        if (!$this->checkEntityAccess($entity, 'create')) {
+            return $this->accessDenied();
+        }
+        $this->model->saveEntity($entity);
+        $headers = [];
+        $route               = 'mautic_api_campaigns_getone';
+        $headers['Location'] = $this->generateUrl(
+            $route,
+            array_merge(['id' => $entity->getId()], $this->routeParams),
+            true
+        );
+        $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK, $headers);
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/Api/EventApiController.php
@@ -0,0 +1,48 @@
+<?php
+namespace Mautic\CampaignBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Controller\CommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\ApiBundle\Serializer\Exclusion\FieldExclusionStrategy;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Model\EventModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Controller\LeadAccessTrait;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\Routing\RouterInterface;
+/**
+ * @extends CommonApiController<Event>
+ */
+class EventApiController extends CommonApiController
+{
+    use LeadAccessTrait;
+    public function __construct(CorePermissions $security, Translator $translator, EntityResultHelper $entityResultHelper, RouterInterface $router, FormFactoryInterface $formFactory, AppVersion $appVersion, RequestStack $requestStack, ManagerRegistry $doctrine, ModelFactory $modelFactory, EventDispatcherInterface $dispatcher, CoreParametersHelper $coreParametersHelper)
+    {
+        $campaignEventModel = $modelFactory->getModel('campaign.event');
+        \assert($campaignEventModel instanceof EventModel);
+        $this->model                    = $campaignEventModel;
+        $this->entityClass              = Event::class;
+        $this->entityNameOne            = 'event';
+        $this->entityNameMulti          = 'events';
+        $this->serializerGroups         = ['campaignEventStandaloneDetails', 'campaignList'];
+        $this->parentChildrenLevelDepth = 1;
+        $this->addExclusionStrategy(new FieldExclusionStrategy(['campaign'], 1));
+        parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * @param Event  $entity
+     * @param string $action
+     *
+     * @return bool|mixed
+     */
+    protected function checkEntityAccess($entity, $action = 'view')
+    {
+        return parent::checkEntityAccess($entity->getCampaign(), $action);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/Api/EventLogApiController.php
@@ -0,0 +1,224 @@
+<?php
+namespace Mautic\CampaignBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use FOS\RestBundle\View\View;
+use Mautic\ApiBundle\Controller\FetchCommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\ApiBundle\Serializer\Exclusion\FieldInclusionStrategy;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Model\EventLogModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Controller\LeadAccessTrait;
+use Mautic\LeadBundle\Entity\Lead;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+/**
+ * @extends FetchCommonApiController<LeadEventLog>
+ */
+class EventLogApiController extends FetchCommonApiController
+{
+    use LeadAccessTrait;
+    private const LOG_SERIALIZATION = 30;
+    /**
+     * @var Campaign
+     */
+    protected $campaign;
+    /**
+     * @var Lead
+     */
+    protected $contact;
+    /**
+     * @var EventLogModel|null
+     */
+    protected $model;
+    public function __construct(
+        CorePermissions $security,
+        Translator $translator,
+        EntityResultHelper $entityResultHelper,
+        AppVersion $appVersion,
+        RequestStack $requestStack,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        EventDispatcherInterface $dispatcher,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        $campaignEventLogModel = $modelFactory->getModel('campaign.event_log');
+        \assert($campaignEventLogModel instanceof EventLogModel);
+        $this->model                    = $campaignEventLogModel;
+        $this->entityClass              = LeadEventLog::class;
+        $this->entityNameOne            = 'event';
+        $this->entityNameMulti          = 'events';
+        $this->parentChildrenLevelDepth = 1;
+        $this->serializerGroups         = [
+            'campaignList',
+            'ipAddressList',
+            self::LOG_SERIALIZATION => 'campaignEventLogDetails',
+        ];
+        $this->addExclusionStrategy(new FieldInclusionStrategy(['id'], 1, 'parent'));
+        parent::__construct($security, $translator, $entityResultHelper, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * @return Response
+     */
+    public function getEntitiesAction(Request $request, UserHelper $userHelper)
+    {
+        $this->serializerGroups[self::LOG_SERIALIZATION] = 'campaignEventStandaloneLogDetails';
+        $this->serializerGroups[]                        = 'campaignEventStandaloneList';
+        $this->serializerGroups[]                        = 'leadBasicList';
+        return parent::getEntitiesAction($request, $userHelper);
+    }
+    /**
+     * Get a list of events.
+     *
+     * @return Response
+     */
+    public function getContactEventsAction(Request $request, UserHelper $userHelper, $contactId, $campaignId = null)
+    {
+        $contact = $this->checkLeadAccess($contactId, 'view');
+        if ($contact instanceof Response) {
+            return $contact;
+        }
+        if (!empty($campaignId)) {
+            $campaign = $this->getModel('campaign')->getEntity($campaignId);
+            if (null == $campaign || !$campaign->getId()) {
+                return $this->notFound();
+            }
+            if (!$this->checkEntityAccess($campaign)) {
+                return $this->accessDenied();
+            }
+            $membership = $campaign->getContactMembership($contact);
+            if (0 === count($membership)) {
+                return $this->returnError(
+                    $this->translator->trans(
+                        'mautic.campaign.error.contact_not_in_campaign',
+                        ['%campaign%' => $campaignId, '%contact%' => $contactId]
+                    ),
+                    Response::HTTP_CONFLICT
+                );
+            }
+            $this->campaign           = $campaign;
+            $this->serializerGroups[] = 'campaignEventWithLogsList';
+            $this->serializerGroups[] = 'campaignLeadList';
+        } else {
+            unset($this->serializerGroups[self::LOG_SERIALIZATION]);
+            $this->serializerGroups[] = 'campaignEventStandaloneList';
+            $this->serializerGroups[] = 'campaignEventStandaloneLogDetails';
+        }
+        $this->contact                   = $contact;
+        $this->extraGetEntitiesArguments = [
+            'contact_id'  => $contactId,
+            'campaign_id' => $campaignId,
+        ];
+        return $this->getEntitiesAction($request, $userHelper);
+    }
+    /**
+     * @return Response
+     */
+    public function editContactEventAction(Request $request, $eventId, $contactId)
+    {
+        $parameters = $request->request->all();
+        $contact = $this->checkLeadAccess($contactId, 'edit');
+        if ($contact instanceof Response) {
+            return $contact;
+        }
+        /** @var EventModel $eventModel */
+        $eventModel = $this->getModel('campaign.event');
+        /** @var Event $event */
+        $event = $eventModel->getEntity($eventId);
+        if (null === $event || !$event->getId()) {
+            return $this->notFound();
+        }
+        $campaign = $event->getCampaign();
+        if (!$this->checkEntityAccess($campaign, 'edit')) {
+            return $this->accessDenied();
+        }
+        $result = $this->model->updateContactEvent($event, $contact, $parameters);
+        if (is_string($result)) {
+            return $this->returnError($result, Response::HTTP_CONFLICT);
+        } else {
+            [$log, $created] = $result;
+        }
+        $event->addContactLog($log);
+        $view = $this->view(
+            [
+                $this->entityNameOne => $event,
+            ],
+            ($created) ? Response::HTTP_CREATED : Response::HTTP_OK
+        );
+        $this->serializerGroups[] = 'campaignEventWithLogsDetails';
+        $this->serializerGroups[] = 'campaignBasicList';
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    /**
+     * @return array|Response
+     */
+    public function editEventsAction(Request $request)
+    {
+        $parameters = $request->request->all();
+        $valid = $this->validateBatchPayload($parameters);
+        if ($valid instanceof Response) {
+            return $valid;
+        }
+        $events   = $this->getBatchEntities($parameters, $errors, false, 'eventId', $this->getModel('campaign.event'), false);
+        $contacts = $this->getBatchEntities($parameters, $errors, false, 'contactId', $this->getModel('lead'), false);
+        $this->inBatchMode = true;
+        $errors            = [];
+        foreach ($parameters as $key => $params) {
+            if (!isset($params['eventId']) || !isset($params['contactId']) || !isset($events[$params['eventId']])
+                || !isset($contacts[$params['contactId']])
+            ) {
+                $errors[$key] = $this->notFound('mautic.campaign.error.edit_events.request_invalid');
+                continue;
+            }
+            $event = $events[$params['eventId']];
+            $contact = $this->checkLeadAccess($contacts[$params['contactId']], 'edit');
+            if ($contact instanceof Response) {
+                $errors[$key] = $contact->getContent();
+                continue;
+            }
+            $campaign = $event->getCampaign();
+            if (!$this->checkEntityAccess($campaign, 'edit')) {
+                $errors[$key] = $this->accessDenied();
+                continue;
+            }
+            $result = $this->model->updateContactEvent($event, $contact, $params);
+            if (is_string($result)) {
+                $errors[$key] = $this->returnError($result, Response::HTTP_CONFLICT);
+            } else {
+                [$log, $created] = $result;
+                $event->addContactLog($log);
+            }
+        }
+        $payload = [
+            $this->entityNameMulti => $events,
+        ];
+        if (!empty($errors)) {
+            $payload['errors'] = $errors;
+        }
+        $view                     = $this->view($payload, Response::HTTP_OK);
+        $this->serializerGroups[] = 'campaignEventWithLogsList';
+        $this->setSerializationContext($view);
+        return $this->handleView($view);
+    }
+    protected function view($data = null, ?int $statusCode = null, array $headers = []): View
+    {
+        if ($this->campaign) {
+            $data['campaign'] = $this->campaign;
+            if ($this->contact) {
+                [$data['membership'], $ignore] = $this->prepareEntitiesForView($this->campaign->getContactMembership($this->contact));
+            }
+        }
+        return parent::view($data, $statusCode, $headers);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/CampaignController.php
@@ -0,0 +1,998 @@
+<?php
+namespace Mautic\CampaignBundle\Controller;
+use Doctrine\DBAL\Cache\CacheException;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Entity\Summary;
+use Mautic\CampaignBundle\Entity\SummaryRepository;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\EventListener\CampaignActionJumpToEventSubscriber;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Mautic\CoreBundle\Controller\AbstractStandardFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
+use Mautic\CoreBundle\Form\Type\DateRangeType;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\CoreBundle\Twig\Helper\DateHelper;
+use Mautic\FormBundle\Helper\FormFieldHelper;
+use Mautic\LeadBundle\Controller\EntityContactsTrait;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\Form;
+use Symfony\Component\Form\FormError;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\RedirectResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\HttpFoundation\Session\Session;
+class CampaignController extends AbstractStandardFormController
+{
+    use EntityContactsTrait;
+    /**
+     * @var array
+     */
+    protected $addedSources = [];
+    /**
+     * @var array
+     */
+    protected $campaignEvents = [];
+    /**
+     * @var array
+     */
+    protected $campaignSources = [];
+    /**
+     * @var array
+     */
+    protected $connections = [];
+    /**
+     * @var array
+     */
+    protected $deletedEvents = [];
+    /**
+     * @var array
+     */
+    protected $deletedSources = [];
+    /**
+     * @var array
+     */
+    protected $listFilters = [];
+    /**
+     * @var array
+     */
+    protected $modifiedEvents = [];
+    protected $sessionId;
+    public function __construct(
+        FormFactoryInterface $formFactory,
+        FormFieldHelper $fieldHelper,
+        private EventCollector $eventCollector,
+        private DateHelper $dateHelper,
+        ManagerRegistry $managerRegistry,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        private RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($formFactory, $fieldHelper, $managerRegistry, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    protected function getPermissions(): array
+    {
+        return (array) $this->security->isGranted(
+            [
+                'campaign:campaigns:viewown',
+                'campaign:campaigns:viewother',
+                'campaign:campaigns:create',
+                'campaign:campaigns:editown',
+                'campaign:campaigns:editother',
+                'campaign:campaigns:cloneown',
+                'campaign:campaigns:cloneother',
+                'campaign:campaigns:deleteown',
+                'campaign:campaigns:deleteother',
+                'campaign:campaigns:publishown',
+                'campaign:campaigns:publishother',
+            ],
+            'RETURN_ARRAY'
+        );
+    }
+    /**
+     * Deletes a group of entities.
+     *
+     * @return JsonResponse|RedirectResponse
+     */
+    public function batchDeleteAction(Request $request)
+    {
+        return $this->batchDeleteStandard($request);
+    }
+    /**
+     * Clone an entity.
+     *
+     * @return JsonResponse|RedirectResponse|Response
+     */
+    public function cloneAction(Request $request, $objectId)
+    {
+        return $this->cloneStandard($request, $objectId);
+    }
+    /**
+     * @param string|int $objectId
+     * @param int        $page
+     * @param int|null   $count
+     *
+     * @return JsonResponse|RedirectResponse|Response
+     */
+    public function contactsAction(
+        Request $request,
+        PageHelperFactoryInterface $pageHelperFactory,
+        $objectId,
+        $page = 1,
+        $count = null,
+        \DateTimeInterface $dateFrom = null,
+        \DateTimeInterface $dateTo = null,
+    ) {
+        $session = $request->getSession();
+        $session->set('mautic.campaign.contact.page', $page);
+        $permissions = [
+            'campaign:campaigns:view',
+            'lead:leads:viewown',
+            'lead:leads:viewother',
+        ];
+        return $this->generateContactsGrid(
+            $request,
+            $pageHelperFactory,
+            $objectId,
+            $page,
+            $permissions,
+            'campaign',
+            'campaign_leads',
+            null,
+            'campaign_id',
+            ['manually_removed' => 0],
+            null,
+            null,
+            [],
+            null,
+            'entity.lead_id',
+            'DESC',
+            $count,
+            $dateFrom,
+            $dateTo
+        );
+    }
+    /**
+     * Deletes the entity.
+     *
+     * @return JsonResponse|RedirectResponse
+     */
+    public function deleteAction(Request $request, $objectId)
+    {
+        return $this->deleteStandard($request, $objectId);
+    }
+    /**
+     * @param bool $ignorePost
+     *
+     * @return JsonResponse|RedirectResponse|Response
+     */
+    public function editAction(Request $request, $objectId, $ignorePost = false)
+    {
+        return $this->editStandard($request, $objectId, $ignorePost);
+    }
+    /**
+     * @param int $page
+     *
+     * @return JsonResponse|Response
+     */
+    public function indexAction(Request $request, $page = null)
+    {
+        $permissions = $this->security->isGranted(
+            [
+                'campaign:campaigns:view',
+                'campaign:campaigns:viewown',
+                'campaign:campaigns:viewother',
+                'campaign:campaigns:create',
+                'campaign:campaigns:edit',
+                'campaign:campaigns:editown',
+                'campaign:campaigns:editother',
+                'campaign:campaigns:delete',
+                'campaign:campaigns:deleteown',
+                'campaign:campaigns:deleteother',
+                'campaign:campaigns:publish',
+                'campaign:campaigns:publishown',
+                'campaign:campaigns:publishother',
+            ],
+            'RETURN_ARRAY',
+            null,
+            true
+        );
+        if (!$permissions['campaign:campaigns:view']) {
+            return $this->accessDenied();
+        }
+        $this->setListFilters();
+        $session = $request->getSession();
+        if (empty($page)) {
+            $page = $session->get('mautic.campaign.page', 1);
+        }
+        $limit = $session->get('mautic.campaign.limit', $this->coreParametersHelper->get('default_pagelimit'));
+        $start = (1 === $page) ? 0 : (($page - 1) * $limit);
+        if ($start < 0) {
+            $start = 0;
+        }
+        $search = $request->get('search', $session->get('mautic.campaign.filter', ''));
+        $session->set('mautic.campaign.filter', $search);
+        $filter = ['string' => $search, 'force' => []];
+        $model = $this->getModel('campaign');
+        if (!$permissions[$this->getPermissionBase().':viewother']) {
+            $filter['force'][] = ['column' => 'c.createdBy', 'expr' => 'eq', 'value' => $this->user->getId()];
+        }
+        $orderBy    = $session->get('mautic.campaign.orderby', 'c.dateModified');
+        $orderByDir = $session->get('mautic.campaign.orderbydir', $this->getDefaultOrderDirection());
+        [$count, $items] = $this->getIndexItems($start, $limit, $filter, $orderBy, $orderByDir);
+        if ($count && $count < ($start + 1)) {
+            $lastPage = (1 === $count) ? 1 : (((ceil($count / $limit)) ?: 1) ?: 1);
+            $session->set('mautic.campaign.page', $lastPage);
+            $returnUrl = $this->generateUrl('mautic_campaign_index', ['page' => $lastPage]);
+            return $this->postActionRedirect(
+                $this->getPostActionRedirectArguments(
+                    [
+                        'returnUrl'       => $returnUrl,
+                        'viewParameters'  => ['page' => $lastPage],
+                        'contentTemplate' => 'Mautic\CampaignBundle\Controller\CampaignController::indexAction',
+                        'passthroughVars' => [
+                            'mauticContent' => 'campaign',
+                        ],
+                    ],
+                    'index'
+                )
+            );
+        }
+        $session->set('mautic.campaign.page', $page);
+        $viewParameters = [
+            'permissionBase'  => $this->getPermissionBase(),
+            'mauticContent'   => $this->getJsLoadMethodPrefix(),
+            'sessionVar'      => $this->getSessionBase(),
+            'actionRoute'     => $this->getActionRoute(),
+            'indexRoute'      => $this->getIndexRoute(),
+            'tablePrefix'     => $model->getRepository()->getTableAlias(),
+            'modelName'       => $this->getModelName(),
+            'translationBase' => $this->getTranslationBase(),
+            'searchValue'     => $search,
+            'items'           => $items,
+            'totalItems'      => $count,
+            'page'            => $page,
+            'limit'           => $limit,
+            'permissions'     => $permissions,
+            'tmpl'            => $request->get('tmpl', 'index'),
+        ];
+        return $this->delegateView(
+            $this->getViewArguments(
+                [
+                    'viewParameters'  => $viewParameters,
+                    'contentTemplate' => '@MauticCampaign/Campaign/list.html.twig',
+                    'passthroughVars' => [
+                        'mauticContent' => $this->getJsLoadMethodPrefix(),
+                        'route'         => $this->generateUrl($this->getIndexRoute(), ['page' => $page]),
+                    ],
+                ],
+                'index'
+            )
+        );
+    }
+    /**
+     * Generates new form and processes post data.
+     *
+     * @return RedirectResponse|Response
+     */
+    public function newAction(Request $request)
+    {
+        /** @var CampaignModel $model */
+        $model    = $this->getModel('campaign');
+        $campaign = $model->getEntity();
+        if (!$this->security->isGranted('campaign:campaigns:create')) {
+            return $this->accessDenied();
+        }
+        $page = $request->getSession()->get('mautic.campaign.page', 1);
+        $options = $this->getEntityFormOptions();
+        $action  = $this->generateUrl('mautic_campaign_action', ['objectAction' => 'new']);
+        $form    = $model->createForm($campaign, $this->formFactory, $action, $options);
+        $isPost = 'POST' === $request->getMethod();
+        $this->beforeFormProcessed($campaign, $form, 'new', $isPost);
+        if ($isPost) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    if ($valid = $this->beforeEntitySave($campaign, $form, 'new')) {
+                        $campaign->setDateModified(new \DateTime());
+                        $model->saveEntity($campaign);
+                        $this->afterEntitySave($campaign, $form, 'new', $valid);
+                        if (method_exists($this, 'viewAction')) {
+                            $viewParameters = ['objectId' => $campaign->getId(), 'objectAction' => 'view'];
+                            $returnUrl      = $this->generateUrl('mautic_campaign_action', $viewParameters);
+                            $template       = 'Mautic\CampaignBundle\Controller\CampaignController::viewAction';
+                        } else {
+                            $viewParameters = ['page' => $page];
+                            $returnUrl      = $this->generateUrl('mautic_campaign_index', $viewParameters);
+                            $template       = 'Mautic\CampaignBundle\Controller\CampaignController::indexAction';
+                        }
+                    }
+                }
+                $this->afterFormProcessed($valid, $campaign, $form, 'new');
+            } else {
+                $viewParameters = ['page' => $page];
+                $returnUrl      = $this->generateUrl($this->getIndexRoute(), $viewParameters);
+                $template       = 'Mautic\CampaignBundle\Controller\CampaignController::indexAction';
+            }
+            $passthrough = [
+                'mauticContent' => 'cammpaign',
+            ];
+            if ($isInPopup = isset($form['updateSelect'])) {
+                $template    = false;
+                $passthrough = array_merge(
+                    $passthrough,
+                    $this->getUpdateSelectParams($form['updateSelect']->getData(), $campaign)
+                );
+            }
+            if ($cancelled || ($valid && !$this->isFormApplied($form))) {
+                if ($isInPopup) {
+                    $passthrough['closeModal'] = true;
+                }
+                return $this->postActionRedirect(
+                    $this->getPostActionRedirectArguments(
+                        [
+                            'returnUrl'       => $returnUrl,
+                            'viewParameters'  => $viewParameters,
+                            'contentTemplate' => $template,
+                            'passthroughVars' => $passthrough,
+                            'entity'          => $campaign,
+                        ],
+                        'new'
+                    )
+                );
+            } elseif ($valid && $this->isFormApplied($form)) {
+                return $this->editAction($request, $campaign->getId(), true);
+            }
+        }
+        $delegateArgs = [
+            'viewParameters' => [
+                'permissionBase'  => $model->getPermissionBase(),
+                'mauticContent'   => 'campaign',
+                'actionRoute'     => 'mautic_campaign_action',
+                'indexRoute'      => 'mautic_campaign_index',
+                'tablePrefix'     => 'c',
+                'modelName'       => 'campaign',
+                'translationBase' => $this->getTranslationBase(),
+                'tmpl'            => $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index',
+                'entity'          => $campaign,
+                'form'            => $this->getFormView($form, 'new'),
+            ],
+            'contentTemplate' => '@MauticCampaign/Campaign/form.html.twig',
+            'passthroughVars' => [
+                'mauticContent' => 'campaign',
+                'route'         => $this->generateUrl(
+                    'mautic_campaign_action',
+                    [
+                        'objectAction' => (!empty($valid) ? 'edit' : 'new'), // valid means a new form was applied
+                        'objectId'     => ($campaign) ? $campaign->getId() : 0,
+                    ]
+                ),
+                'validationError' => $this->getFormErrorForBuilder($form),
+            ],
+            'entity' => $campaign,
+            'form'   => $form,
+        ];
+        return $this->delegateView(
+            $this->getViewArguments($delegateArgs, 'new')
+        );
+    }
+    /**
+     * View a specific campaign.
+     *
+     * @return JsonResponse|Response
+     */
+    public function viewAction(Request $request, $objectId)
+    {
+        return $this->viewStandard($request, $objectId, $this->getModelName(), null, null, 'campaign');
+    }
+    /**
+     * @param Campaign $campaign
+     * @param Campaign $oldCampaign
+     */
+    protected function afterEntityClone($campaign, $oldCampaign)
+    {
+        $tempId   = 'mautic_'.sha1(uniqid(mt_rand(), true));
+        $objectId = $oldCampaign->getId();
+        $events = $oldCampaign->getEvents()->toArray();
+        $campaign->setIsPublished(false);
+        /** @var Event $event */
+        foreach ($events as $event) {
+            $tempEventId = 'new'.$event->getId();
+            $clone = clone $event;
+            $clone->nullId();
+            $clone->setCampaign($campaign);
+            $clone->setTempId($tempEventId);
+            $clone->setParent(null);
+            if (CampaignActionJumpToEventSubscriber::EVENT_NAME === $clone->getType()) {
+                $properties                = $clone->getProperties();
+                $properties['jumpToEvent'] = 'new'.$properties['jumpToEvent'];
+                $clone->setProperties($properties);
+            }
+            $campaign->addEvent($tempEventId, $clone);
+        }
+        $canvasSettings = $campaign->getCanvasSettings();
+        if (isset($canvasSettings['nodes'])) {
+            foreach ($canvasSettings['nodes'] as &$node) {
+                if (is_numeric($node['id'])) {
+                    $node['id'] = 'new'.$node['id'];
+                }
+            }
+        }
+        if (isset($canvasSettings['connections'])) {
+            foreach ($canvasSettings['connections'] as &$c) {
+                if (is_numeric($c['sourceId'])) {
+                    $c['sourceId'] = 'new'.$c['sourceId'];
+                }
+                if (is_numeric($c['targetId'])) {
+                    $c['targetId'] = 'new'.$c['targetId'];
+                }
+            }
+        }
+        $campaign->setCanvasSettings($canvasSettings);
+        $this->setSessionCanvasSettings($tempId, $canvasSettings);
+        $tempId = $this->getCampaignSessionId($campaign, 'clone', $tempId);
+        $campaignSources = $this->getCampaignModel()->getLeadSources($objectId);
+        $this->prepareCampaignSourcesForEdit($tempId, $campaignSources);
+    }
+    /**
+     * @param object    $entity
+     * @param string    $action
+     * @param bool|null $persistConnections
+     */
+    protected function afterEntitySave($entity, FormInterface $form, $action, $persistConnections = null)
+    {
+        if ($persistConnections) {
+            $this->connections = $this->getCampaignModel()->setCanvasSettings($entity, $this->connections);
+        } else {
+            $this->connections = $this->getCampaignModel()->setCanvasSettings($entity, $this->connections, false, $this->modifiedEvents);
+        }
+    }
+    /**
+     * @param bool $isClone
+     */
+    protected function afterFormProcessed($isValid, $entity, FormInterface $form, $action, $isClone = false)
+    {
+        if (!$isValid) {
+            $this->afterEntitySave($entity, $form, $action, false);
+        } else {
+            $this->clearSessionComponents($this->sessionId);
+            $this->sessionId = $entity->getId();
+        }
+    }
+    /**
+     * @param bool $isClone
+     */
+    protected function beforeFormProcessed($entity, FormInterface $form, $action, $isPost, $objectId = null, $isClone = false)
+    {
+        $sessionId = $this->getCampaignSessionId($entity, $action, $objectId);
+        [$this->modifiedEvents, $this->deletedEvents, $this->campaignEvents] = $this->getSessionEvents($sessionId);
+        [$this->addedSources, $this->deletedSources, $campaignSources]     = $this->getSessionSources($sessionId, $isClone);
+        $this->connections                                                 = $this->getSessionCanvasSettings($sessionId);
+        if ($isPost) {
+            $this->getCampaignModel()->setCanvasSettings($entity, $this->connections, false, $this->modifiedEvents);
+            $this->prepareCampaignSourcesForEdit($sessionId, $campaignSources, true);
+        } else {
+            if (!$isClone) {
+                $this->clearSessionComponents($sessionId);
+                $this->modifiedEvents = $this->campaignSources = [];
+                if ($entity->getId()) {
+                    $campaignSources = $this->getCampaignModel()->getLeadSources($entity->getId());
+                    $this->prepareCampaignSourcesForEdit($sessionId, $campaignSources);
+                    $this->setSessionCanvasSettings($sessionId, $entity->getCanvasSettings());
+                }
+            }
+            $this->deletedEvents = [];
+            $form->get('sessionId')->setData($sessionId);
+            $this->prepareCampaignEventsForEdit($entity, $sessionId, $isClone);
+        }
+    }
+    /**
+     * @param Campaign $entity
+     * @param bool     $isClone
+     */
+    protected function beforeEntitySave($entity, FormInterface $form, $action, $objectId = null, $isClone = false): bool
+    {
+        if (empty($this->campaignEvents)) {
+            $form->addError(
+                new FormError(
+                    $this->translator->trans('mautic.campaign.form.events.notempty', [], 'validators')
+                )
+            );
+            return false;
+        }
+        if (empty($this->campaignSources['lists']) && empty($this->campaignSources['forms'])) {
+            $form->addError(
+                new FormError(
+                    $this->translator->trans('mautic.campaign.form.sources.notempty', [], 'validators')
+                )
+            );
+            return false;
+        }
+        if ($isClone) {
+            [$this->addedSources, $this->deletedSources, $campaignSources] = $this->getSessionSources($objectId, $isClone);
+            $this->getCampaignModel()->setLeadSources($entity, $campaignSources, []);
+            $this->getCampaignModel()->getRepository()->saveEntity($entity);
+            $entity->setNew();
+            $this->sessionId = $entity->getId();
+        }
+        $this->getCampaignModel()->setLeadSources($entity, $this->addedSources, $this->deletedSources);
+        $this->getCampaignModel()->setEvents($entity, $this->campaignEvents, $this->connections, $this->deletedEvents);
+        if ('edit' === $action && null !== $this->connections) {
+            if (!empty($this->deletedEvents)) {
+                /** @var EventModel $eventModel */
+                $eventModel = $this->getModel('campaign.event');
+                $eventModel->deleteEvents($entity->getEvents()->toArray(), $this->deletedEvents);
+            }
+        }
+        return true;
+    }
+    /**
+     * Clear field and events from the session.
+     */
+    protected function clearSessionComponents($id)
+    {
+        $session = $this->getCurrentRequest()->getSession();
+        $session->remove('mautic.campaign.'.$id.'.events.modified');
+        $session->remove('mautic.campaign.'.$id.'.events.deleted');
+        $session->remove('mautic.campaign.'.$id.'.events.canvassettings');
+        $session->remove('mautic.campaign.'.$id.'.leadsources.current');
+        $session->remove('mautic.campaign.'.$id.'.leadsources.modified');
+        $session->remove('mautic.campaign.'.$id.'.leadsources.deleted');
+    }
+    /**
+     * @return CampaignModel
+     */
+    protected function getCampaignModel()
+    {
+        /** @var CampaignModel $model */
+        $model = $this->getModel($this->getModelName());
+        return $model;
+    }
+    /**
+     * @return int|string|null
+     */
+    protected function getCampaignSessionId(Campaign $campaign, $action, $objectId = null)
+    {
+        if (isset($this->sessionId)) {
+            return $this->sessionId;
+        }
+        if ($objectId) {
+            $sessionId = $objectId;
+        } elseif ('new' === $action && empty($sessionId)) {
+            $sessionId = 'mautic_'.sha1(uniqid(mt_rand(), true));
+            if ($this->requestStack->getCurrentRequest()->request->has('campaign')) {
+                $campaign  = $this->requestStack->getCurrentRequest()->request->all()['campaign'] ?? [];
+                $sessionId = $campaign['sessionId'] ?? $sessionId;
+            }
+        } elseif ('edit' === $action) {
+            $sessionId = $campaign->getId();
+        }
+        $this->sessionId = $sessionId;
+        return $sessionId;
+    }
+    protected function getTemplateBase(): string
+    {
+        return '@MauticCampaign/Campaign';
+    }
+    protected function getIndexItems($start, $limit, $filter, $orderBy, $orderByDir, array $args = [])
+    {
+        $session        = $this->getCurrentRequest()->getSession();
+        $currentFilters = $session->get('mautic.campaign.list_filters', []);
+        $updatedFilters = $this->requestStack->getCurrentRequest()->get('filters', false);
+        $sourceLists = $this->getCampaignModel()->getSourceLists();
+        $listFilters = [
+            'filters' => [
+                'placeholder' => $this->translator->trans('mautic.campaign.filter.placeholder'),
+                'multiple'    => true,
+                'groups'      => [
+                    'mautic.campaign.leadsource.form' => [
+                        'options' => $sourceLists['forms'],
+                        'prefix'  => 'form',
+                    ],
+                    'mautic.campaign.leadsource.list' => [
+                        'options' => $sourceLists['lists'],
+                        'prefix'  => 'list',
+                    ],
+                ],
+            ],
+        ];
+        if ($updatedFilters) {
+            $newFilters     = [];
+            $updatedFilters = json_decode($updatedFilters, true);
+            if ($updatedFilters) {
+                foreach ($updatedFilters as $updatedFilter) {
+                    [$clmn, $fltr] = explode(':', $updatedFilter);
+                    $newFilters[$clmn][] = $fltr;
+                }
+                $currentFilters = $newFilters;
+            } else {
+                $currentFilters = [];
+            }
+        }
+        $session->set('mautic.campaign.list_filters', $currentFilters);
+        $joinLists = $joinForms = false;
+        if (!empty($currentFilters)) {
+            $listIds = $catIds = [];
+            foreach ($currentFilters as $type => $typeFilters) {
+                $listFilters['filters']['groups']['mautic.campaign.leadsource.'.$type]['values'] = $typeFilters;
+                foreach ($typeFilters as $fltr) {
+                    if ('list' == $type) {
+                        $listIds[] = (int) $fltr;
+                    } else {
+                        $formIds[] = (int) $fltr;
+                    }
+                }
+            }
+            if (!empty($listIds)) {
+                $joinLists         = true;
+                $filter['force'][] = ['column' => 'l.id', 'expr' => 'in', 'value' => $listIds];
+            }
+            if (!empty($formIds)) {
+                $joinForms         = true;
+                $filter['force'][] = ['column' => 'f.id', 'expr' => 'in', 'value' => $formIds];
+            }
+        }
+        $this->listFilters = $listFilters;
+        return parent::getIndexItems(
+            $start,
+            $limit,
+            $filter,
+            $orderBy,
+            $orderByDir,
+            [
+                'joinLists' => $joinLists,
+                'joinForms' => $joinForms,
+            ]
+        );
+    }
+    protected function getModelName(): string
+    {
+        return 'campaign';
+    }
+    /**
+     * @return mixed[]
+     */
+    protected function getPostActionRedirectArguments(array $args, $action): array
+    {
+        switch ($action) {
+            case 'new':
+            case 'edit':
+                if (!empty($args['entity'])) {
+                    $sessionId = $this->getCampaignSessionId($args['entity'], $action);
+                    $this->clearSessionComponents($sessionId);
+                }
+                break;
+        }
+        return $args;
+    }
+    /**
+     * Get events from session.
+     */
+    protected function getSessionEvents($id): array
+    {
+        $session = $this->getCurrentRequest()->getSession();
+        $modifiedEvents = $session->get('mautic.campaign.'.$id.'.events.modified', []);
+        $deletedEvents  = $session->get('mautic.campaign.'.$id.'.events.deleted', []);
+        $events = array_diff_key($modifiedEvents, array_flip($deletedEvents));
+        return [$modifiedEvents, $deletedEvents, $events];
+    }
+    /**
+     * Get events from session.
+     */
+    protected function getSessionSources($id, $isClone = false): array
+    {
+        $session = $this->getCurrentRequest()->getSession();
+        $campaignSources = $session->get('mautic.campaign.'.$id.'.leadsources.current', []);
+        $modifiedSources = $session->get('mautic.campaign.'.$id.'.leadsources.modified', []);
+        if ($campaignSources === $modifiedSources) {
+            if ($isClone) {
+                return [$campaignSources, [], $campaignSources];
+            } else {
+                return [[], [], $campaignSources];
+            }
+        }
+        $deletedSources = [];
+        foreach ($campaignSources as $type => $sources) {
+            if (isset($modifiedSources[$type])) {
+                $deletedSources[$type] = array_diff_key($sources, $modifiedSources[$type]);
+            } else {
+                $deletedSources[$type] = $sources;
+            }
+        }
+        $addedSources = [];
+        foreach ($modifiedSources as $type => $sources) {
+            if (isset($campaignSources[$type])) {
+                $addedSources[$type] = array_diff_key($sources, $campaignSources[$type]);
+            } else {
+                $addedSources[$type] = $sources;
+            }
+        }
+        return [$addedSources, $deletedSources, $modifiedSources];
+    }
+    /**
+     * @param string $action
+     *
+     * @throws CacheException
+     */
+    protected function getViewArguments(array $args, $action): array
+    {
+        switch ($action) {
+            case 'index':
+                $args['viewParameters']['filters'] = $this->listFilters;
+                break;
+            case 'view':
+                /** @var Campaign $entity */
+                $entity   = $args['entity'];
+                $objectId = $args['objectId'];
+                $dateRangeValues = $this->requestStack->getCurrentRequest()->get('daterange', []);
+                $action          = $this->generateUrl('mautic_campaign_action', ['objectAction' => 'view', 'objectId' => $objectId]);
+                $dateRangeForm   = $this->formFactory->create(DateRangeType::class, $dateRangeValues, ['action' => $action]);
+                $events          = $this->getCampaignModel()->getEventRepository()->getCampaignEvents($entity->getId());
+                $dateFrom        = null;
+                $dateTo          = null;
+                $dateToPlusOne   = null;
+                if ($this->coreParametersHelper->get('campaign_by_range')) {
+                    $dateFrom      = new \DateTimeImmutable($dateRangeForm->get('date_from')->getData());
+                    $dateTo        = new \DateTimeImmutable($dateRangeForm->get('date_to')->getData());
+                    $dateToPlusOne = $dateTo->modify('+1 day');
+                }
+                $leadCount = $this->getCampaignModel()->getRepository()->getCampaignLeadCount($entity->getId());
+                $logCounts = $this->processCampaignLogCounts($entity->getId(), $dateFrom, $dateToPlusOne);
+                $campaignLogCounts          = $logCounts['campaignLogCounts'] ?? [];
+                $campaignLogCountsProcessed = $logCounts['campaignLogCountsProcessed'] ?? [];
+                $this->processCampaignEvents($events, $leadCount, $campaignLogCounts, $campaignLogCountsProcessed);
+                $sortedEvents = $this->processCampaignEventsFromParentCondition($events);
+                $stats = $this->getCampaignModel()->getCampaignMetricsLineChartData(
+                    null,
+                    new \DateTime($dateRangeForm->get('date_from')->getData()),
+                    new \DateTime($dateRangeForm->get('date_to')->getData()),
+                    null,
+                    ['campaign_id' => $objectId]
+                );
+                $sourcesList = $this->getCampaignModel()->getSourceLists();
+                $this->prepareCampaignSourcesForEdit($objectId, $sourcesList, true);
+                $this->prepareCampaignEventsForEdit($entity, $objectId, true);
+                $isEmailStatsEnabled = (bool) $this->coreParametersHelper->get('campaign_email_stats_enabled', true);
+                $showEmailStats      = $isEmailStatsEnabled && $entity->isEmailCampaign();
+                $args['viewParameters'] = array_merge(
+                    $args['viewParameters'],
+                    [
+                        'campaign'        => $entity,
+                        'stats'           => $stats,
+                        'events'          => $sortedEvents,
+                        'eventSettings'   => $this->eventCollector->getEventsArray(),
+                        'sources'         => $this->getCampaignModel()->getLeadSources($entity),
+                        'dateRangeForm'   => $dateRangeForm->createView(),
+                        'campaignSources' => $this->campaignSources,
+                        'campaignEvents'  => $events,
+                        'showEmailStats'  => $showEmailStats,
+                    ]
+                );
+                break;
+            case 'new':
+            case 'edit':
+                $session                = $this->getCurrentRequest()->getSession();
+                $args['viewParameters'] = array_merge(
+                    $args['viewParameters'],
+                    [
+                        'eventSettings'   => $this->eventCollector->getEventsArray(),
+                        'campaignEvents'  => $this->campaignEvents,
+                        'campaignSources' => $this->campaignSources,
+                        'deletedEvents'   => $this->deletedEvents,
+                        'hasEventClone'   => $session->has('mautic.campaign.events.clone.storage'),
+                    ]
+                );
+                break;
+        }
+        return $args;
+    }
+    /**
+     * @param bool $isClone
+     *
+     * @return array
+     */
+    protected function prepareCampaignEventsForEdit($entity, $objectId, $isClone = false)
+    {
+        $campaignEvents = [];
+        $existingEvents = $entity->getEvents()->toArray();
+        $translator     = $this->translator;
+        foreach ($existingEvents as $e) {
+            $event = $e->convertToArray();
+            if ($isClone) {
+                $id          = $e->getTempId();
+                $event['id'] = $id;
+            } else {
+                $id = $e->getId();
+            }
+            unset($event['campaign']);
+            unset($event['children']);
+            unset($event['parent']);
+            unset($event['log']);
+            $label = false;
+            switch ($event['triggerMode']) {
+                case 'interval':
+                    $label = $translator->trans(
+                        'mautic.campaign.connection.trigger.interval.label'.('no' == $event['decisionPath'] ? '_inaction' : ''),
+                        [
+                            '%number%' => $event['triggerInterval'],
+                            '%unit%'   => $translator->trans(
+                                'mautic.campaign.event.intervalunit.'.$event['triggerIntervalUnit'],
+                                ['%count%' => $event['triggerInterval']]
+                            ),
+                        ]
+                    );
+                    break;
+                case 'date':
+                    $label = $translator->trans(
+                        'mautic.campaign.connection.trigger.date.label'.('no' == $event['decisionPath'] ? '_inaction' : ''),
+                        [
+                            '%full%' => $this->dateHelper->toFull($event['triggerDate']),
+                            '%time%' => $this->dateHelper->toTime($event['triggerDate']),
+                            '%date%' => $this->dateHelper->toShort($event['triggerDate']),
+                        ]
+                    );
+                    break;
+            }
+            if ($label) {
+                $event['label'] = $label;
+            }
+            $campaignEvents[$id] = $event;
+        }
+        $this->modifiedEvents = $this->campaignEvents = $campaignEvents;
+        $this->getCurrentRequest()->getSession()->set('mautic.campaign.'.$objectId.'.events.modified', $campaignEvents);
+    }
+    protected function prepareCampaignSourcesForEdit($objectId, $campaignSources, $isPost = false)
+    {
+        $this->campaignSources = [];
+        if (is_array($campaignSources)) {
+            foreach ($campaignSources as $type => $sources) {
+                if (!empty($sources)) {
+                    $campaignModel = $this->getModel('campaign');
+                    \assert($campaignModel instanceof CampaignModel);
+                    $sourceList                   = $campaignModel->getSourceLists($type);
+                    $this->campaignSources[$type] = [
+                        'sourceType' => $type,
+                        'campaignId' => $objectId,
+                        'names'      => implode(', ', array_intersect_key($sourceList, $sources)),
+                    ];
+                }
+            }
+        }
+        if (!$isPost) {
+            $session = $this->getCurrentRequest()->getSession();
+            $session->set('mautic.campaign.'.$objectId.'.leadsources.current', $campaignSources);
+            $session->set('mautic.campaign.'.$objectId.'.leadsources.modified', $campaignSources);
+        }
+    }
+    protected function setSessionCanvasSettings($sessionId, $canvasSettings)
+    {
+        $this->getCurrentRequest()->getSession()->set('mautic.campaign.'.$sessionId.'.events.canvassettings', $canvasSettings);
+    }
+    protected function getSessionCanvasSettings($sessionId): mixed
+    {
+        return $this->getCurrentRequest()->getSession()->get('mautic.campaign.'.$sessionId.'.events.canvassettings');
+    }
+    /**
+     * @return array<string, array<int|string, array<int|string, int|string>>>
+     *
+     * @throws CacheException
+     */
+    private function processCampaignLogCounts(int $id, ?\DateTimeImmutable $dateFrom, ?\DateTimeImmutable $dateToPlusOne): array
+    {
+        if ($this->coreParametersHelper->get('campaign_use_summary')) {
+            /** @var SummaryRepository $summaryRepo */
+            $summaryRepo                = $this->doctrine->getManager()->getRepository(Summary::class);
+            $campaignLogCounts          = $summaryRepo->getCampaignLogCounts($id, $dateFrom, $dateToPlusOne);
+            $campaignLogCountsProcessed = $this->getCampaignLogCountsProcessed($campaignLogCounts);
+        } else {
+            /** @var LeadEventLogRepository $eventLogRepo */
+            $eventLogRepo               = $this->doctrine->getManager()->getRepository(LeadEventLog::class);
+            $campaignLogCounts          = $eventLogRepo->getCampaignLogCounts($id, false, false, true, $dateFrom, $dateToPlusOne);
+            $campaignLogCountsProcessed = $eventLogRepo->getCampaignLogCounts($id, false, false, false, $dateFrom, $dateToPlusOne);
+        }
+        return [
+            'campaignLogCounts'          => $campaignLogCounts,
+            'campaignLogCountsProcessed' => $campaignLogCountsProcessed,
+        ];
+    }
+    /**
+     * @param array<int, array<int|string, int|string>>        $events
+     * @param array<int|string, array<int|string, int|string>> $campaignLogCounts
+     * @param array<int|string, array<int|string, int|string>> $campaignLogCountsProcessed
+     */
+    private function processCampaignEvents(
+        array &$events,
+        int $leadCount,
+        array $campaignLogCounts,
+        array $campaignLogCountsProcessed,
+    ): void {
+        foreach ($events as &$event) {
+            $event['logCountForPending'] =
+            $event['logCountProcessed']  =
+            $event['percent']            =
+            $event['yesPercent']         =
+            $event['noPercent']          = 0;
+            if (isset($campaignLogCounts[$event['id']])) {
+                $loggedCount                 = array_sum($campaignLogCounts[$event['id']]);
+                $logCountsProcessed          = isset($campaignLogCountsProcessed[$event['id']]) ? array_sum($campaignLogCountsProcessed[$event['id']]) : 0;
+                $pending                     = $loggedCount - $logCountsProcessed;
+                $event['logCountForPending'] = $pending;
+                $event['logCountProcessed']  = $logCountsProcessed;
+                [$totalNo, $totalYes]        = $campaignLogCounts[$event['id']];
+                $total                       = $totalYes + $totalNo;
+                if ($leadCount) {
+                    $event['percent']    = min(100, max(0, round(($loggedCount / $total) * 100, 1)));
+                    $event['yesPercent'] = min(100, max(0, round(($totalYes / $total) * 100, 1)));
+                    $event['noPercent']  = min(100, max(0, round(($totalNo / $total) * 100, 1)));
+                }
+            }
+        }
+    }
+    /**
+     * @param array<int, array<int|string, int|string>> $events
+     *
+     * @return array<string, array<int, array<int|string, int|string>>>
+     */
+    private function processCampaignEventsFromParentCondition(array &$events): array
+    {
+        $sortedEvents = [
+            'decision'  => [],
+            'action'    => [],
+            'condition' => [],
+        ];
+        foreach ($events as &$event) {
+            if (!empty($event['decisionPath'])
+                && !empty($event['parent_id'])
+                && isset($events[$event['parent_id']])
+                && 'condition' !== $event['eventType']) {
+                $parentEvent                 = $events[$event['parent_id']];
+                $event['percent']            = $parentEvent['percent'];
+                $event['yesPercent']         = $parentEvent['yesPercent'];
+                $event['noPercent']          = $parentEvent['noPercent'];
+                if ('yes' === $event['decisionPath']) {
+                    $event['noPercent'] = 0;
+                } else {
+                    $event['yesPercent'] = 0;
+                }
+            }
+            $sortedEvents[$event['eventType']][] = $event;
+        }
+        return $sortedEvents;
+    }
+    /**
+     * @param array<int, array<int, string>> $campaignLogCounts
+     *
+     * @return array<int, array<int, string>>
+     */
+    private function getCampaignLogCountsProcessed(array &$campaignLogCounts): array
+    {
+        $campaignLogCountsProcessed = [];
+        foreach ($campaignLogCounts as $eventId => $campaignLogCount) {
+            $campaignLogCountsProcessed[$eventId][] = $campaignLogCount[2];
+            unset($campaignLogCounts[$eventId][2]);
+        }
+        return $campaignLogCountsProcessed;
+    }
+    protected function getDefaultOrderDirection(): string
+    {
+        return 'DESC';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/CampaignMapStatsController.php
@@ -0,0 +1,92 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Controller;
+use Doctrine\DBAL\Exception;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\Helper\MapHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
+class CampaignMapStatsController extends AbstractController
+{
+    public const MAP_OPTIONS = [
+        'contacts' => [
+            'label' => 'mautic.lead.leads',
+            'unit'  => 'Contact',
+        ],
+        'read_count' => [
+            'label' => 'mautic.email.read',
+            'unit'  => 'Read',
+        ],
+        'clicked_through_count'=> [
+            'label' => 'mautic.email.click',
+            'unit'  => 'Click',
+        ],
+    ];
+    public const LEGEND_TEXT = 'Total: %total (%withCountry with country)';
+    public function __construct(private CampaignModel $model)
+    {
+    }
+    /**
+     * @return array<string, array<int, array<string, int|string>>>
+     *
+     * @throws Exception
+     */
+    public function getData(Campaign $entity, \DateTimeImmutable $dateFromObject, \DateTimeImmutable $dateToObject): array
+    {
+        return $this->model->getCountryStats($entity, $dateFromObject, $dateToObject);
+    }
+    public function hasAccess(CorePermissions $security, Campaign $entity): bool
+    {
+        return $security->hasEntityAccess(
+            'email:emails:viewown',
+            'email:emails:viewother',
+            $entity->getCreatedBy()
+        );
+    }
+    /**
+     * @return array<string,array<string, string>>
+     */
+    public function getMapOptions(Campaign $entity): array
+    {
+        if ($entity->isEmailCampaign()) {
+            return self::MAP_OPTIONS;
+        }
+        $key = array_key_first(self::MAP_OPTIONS);
+        return [$key => self::MAP_OPTIONS[$key]];
+    }
+    public function getMapOptionsTitle(): string
+    {
+        return '';
+    }
+    /**
+     * @throws \Exception
+     */
+    public function viewAction(
+        CorePermissions $security,
+        int $objectId,
+        string $dateFrom = '',
+        string $dateTo = '',
+    ): Response {
+        $entity = $this->model->getEntity($objectId);
+        if (empty($entity) || !$this->hasAccess($security, $entity)) {
+            throw new AccessDeniedHttpException();
+        }
+        $statsCountries = $this->getData($entity, new \DateTimeImmutable($dateFrom), new \DateTimeImmutable($dateTo));
+        $mapData        = MapHelper::buildMapData($statsCountries, $this->getMapOptions($entity), self::LEGEND_TEXT);
+        return $this->render(
+            '@MauticCore/Helper/map.html.twig',
+            [
+                'data'           => $mapData[0]['data'],
+                'height'         => 315,
+                'optionsEnabled' => true,
+                'optionsTitle'   => $this->getMapOptionsTitle(),
+                'options'        => $mapData,
+                'legendEnabled'  => true,
+                'statUnit'       => $mapData[0]['unit'],
+            ]
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/CampaignMetricsController.php
@@ -0,0 +1,89 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Controller;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\Helper\Chart\BarChart;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\DateTimeHelper;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\EmailBundle\Stats\EmailPeriodMetrics;
+use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
+use Symfony\Component\HttpFoundation\Response;
+class CampaignMetricsController extends AbstractController
+{
+    public function __construct(
+        private Translator $translator,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    public function emailWeekdaysAction(
+        EmailPeriodMetrics $emailPeriodMetrics,
+        CampaignModel $model,
+        int $objectId,
+        string $dateFrom = '',
+        string $dateTo = '',
+    ): Response {
+        $entity               = $model->getEntity($objectId);
+        $eventsIds            = $entity->getEmailSendEvents()->getKeys();
+        $dateFromObject       = new \DateTimeImmutable($dateFrom);
+        $dateToObject         = new \DateTimeImmutable($dateTo);
+        $dateTimeHelper        = new DateTimeHelper();
+        $defaultTimezoneOffset = $dateTimeHelper->getLocalDateTime()->format('Z');
+        $stats                 = $emailPeriodMetrics->emailMetricsPerWeekdayByCampaignEvents($eventsIds, $dateFromObject, $dateToObject, $defaultTimezoneOffset);
+        $chart  = new BarChart([
+            $this->translator->trans('mautic.core.date.monday'),
+            $this->translator->trans('mautic.core.date.tuesday'),
+            $this->translator->trans('mautic.core.date.wednesday'),
+            $this->translator->trans('mautic.core.date.thursday'),
+            $this->translator->trans('mautic.core.date.friday'),
+            $this->translator->trans('mautic.core.date.saturday'),
+            $this->translator->trans('mautic.core.date.sunday'),
+        ]);
+        $chart->setDataset($this->translator->trans('mautic.email.sent'), array_column($stats, 'sent_count'));
+        $chart->setDataset($this->translator->trans('mautic.email.read'), array_column($stats, 'read_count'));
+        $chart->setDataset($this->translator->trans('mautic.email.click'), array_column($stats, 'hit_count'));
+        return $this->render(
+            '@MauticCore/Helper/chart.html.twig',
+            [
+                'chartData'   => $chart->render(),
+                'chartType'   => 'bar',
+                'chartHeight' => 300,
+            ]
+        );
+    }
+    public function emailHoursAction(
+        EmailPeriodMetrics $emailPeriodMetrics,
+        CampaignModel $model,
+        int $objectId,
+        string $dateFrom = '',
+        string $dateTo = '',
+    ): Response {
+        $entity               = $model->getEntity($objectId);
+        $eventsIds            = $entity->getEmailSendEvents()->getKeys();
+        $dateFromObject       = new \DateTimeImmutable($dateFrom);
+        $dateToObject         = new \DateTimeImmutable($dateTo);
+        $dateTimeHelper        = new DateTimeHelper();
+        $defaultTimezoneOffset = $dateTimeHelper->getLocalDateTime()->format('Z');
+        $stats = $emailPeriodMetrics->emailMetricsPerHourByCampaignEvents($eventsIds, $dateFromObject, $dateToObject, $defaultTimezoneOffset);
+        $hoursRange = range(0, 23);
+        $labels     = [];
+        $timeFormat = $this->coreParametersHelper->get('date_format_timeonly');
+        foreach ($hoursRange as $hour) {
+            $startTime = (new \DateTime())->setTime($hour, 0);
+            $endTime   = (new \DateTime())->setTime(($hour + 1) % 24, 0);
+            $labels[] = $startTime->format($timeFormat).' - '.$endTime->format($timeFormat);
+        }
+        $chart  = new BarChart($labels);
+        $chart->setDataset($this->translator->trans('mautic.email.sent'), array_column($stats, 'sent_count'));
+        $chart->setDataset($this->translator->trans('mautic.email.read'), array_column($stats, 'read_count'));
+        $chart->setDataset($this->translator->trans('mautic.email.click'), array_column($stats, 'hit_count'));
+        return $this->render(
+            '@MauticCore/Helper/chart.html.twig',
+            [
+                'chartData'   => $chart->render(),
+                'chartType'   => 'hour',
+                'chartHeight' => 300,
+            ]
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Controller/EventController.php
@@ -0,0 +1,506 @@
+<?php
+namespace Mautic\CampaignBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\Form\Type\EventType;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\Controller\FormController as CommonFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\DateTimeHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\CoreBundle\Twig\Helper\DateHelper;
+use Mautic\FormBundle\Helper\FormFieldHelper;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+class EventController extends CommonFormController
+{
+    /**
+     * @var string[]
+     */
+    private array $supportedEventTypes = [
+        Event::TYPE_DECISION,
+        Event::TYPE_ACTION,
+        Event::TYPE_CONDITION,
+    ];
+    public function __construct(
+        FormFactoryInterface $formFactory,
+        FormFieldHelper $fieldHelper,
+        private EventCollector $eventCollector,
+        private DateHelper $dateHelper,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+        private CampaignModel $campaignModel,
+    ) {
+        parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * Generates new form and processes post data.
+     *
+     * @return \Symfony\Component\HttpFoundation\RedirectResponse|\Symfony\Component\HttpFoundation\Response
+     */
+    public function newAction(Request $request)
+    {
+        $success = 0;
+        $valid   = $cancelled   = false;
+        $method  = $request->getMethod();
+        $session = $request->getSession();
+        if ('POST' === $method) {
+            $event                = $request->request->all()['campaignevent'] ?? [];
+            $type                 = $event['type'];
+            $eventType            = $event['eventType'];
+            $campaignId           = $event['campaignId'];
+            $event['triggerDate'] = (!empty($event['triggerDate'])) ? (new DateTimeHelper($event['triggerDate']))->getDateTime() : null;
+        } else {
+            $type       = $request->query->get('type');
+            $eventType  = $request->query->get('eventType');
+            $campaignId = $request->query->get('campaignId');
+            $anchorName = $request->query->get('anchor', '');
+            $event      = [
+                'type'            => $type,
+                'eventType'       => $eventType,
+                'campaignId'      => $campaignId,
+                'anchor'          => $anchorName,
+                'anchorEventType' => $request->query->get('anchorEventType', ''),
+            ];
+        }
+        if (!in_array($eventType, $this->supportedEventTypes)) {
+            return $this->modalAccessDenied();
+        }
+        if (!$type
+            || !$request->isXmlHttpRequest()
+            || !$this->security->isGranted(
+                [
+                    'campaign:campaigns:edit',
+                    'campaign:campaigns:create',
+                ],
+                'MATCH_ONE'
+            )
+        ) {
+            return $this->modalAccessDenied();
+        }
+        $events = $this->eventCollector->getEventsArray();
+        $form   = $this->formFactory->create(
+            EventType::class,
+            $event,
+            [
+                'action'   => $this->generateUrl('mautic_campaignevent_action', ['objectAction' => 'new']),
+                'settings' => $events[$eventType][$type],
+            ]
+        );
+        $event['settings'] = $events[$eventType][$type];
+        $form->get('campaignId')->setData($campaignId);
+        if ('POST' == $method) {
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $success = 1;
+                    $keyId = 'new'.hash('sha1', uniqid((string) mt_rand()));
+                    $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified');
+                    $formData       = $form->getData();
+                    $event          = array_merge($event, $formData);
+                    $event['id']    = $event['tempId']    = $keyId;
+                    if (empty($event['name'])) {
+                        $event['name'] = $this->translator->trans($event['settings']['label']);
+                    }
+                    $modifiedEvents[$keyId] = $event;
+                    $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
+                } else {
+                    $success = 0;
+                }
+            }
+        }
+        $viewParams = ['type' => $type];
+        if ($cancelled || $valid) {
+            $closeModal = true;
+        } else {
+            $closeModal = false;
+            if (isset($event['settings']['formTheme'])) {
+                $viewParams['formTheme'] = $event['settings']['formTheme'];
+            }
+            $viewParams['form']             = $form->createView();
+            $viewParams['eventHeader']      = $this->translator->trans($event['settings']['label']);
+            $viewParams['eventDescription'] = (!empty($event['settings']['description'])) ? $this->translator->trans(
+                $event['settings']['description']
+            ) : '';
+        }
+        $viewParams['hideTriggerMode'] = isset($event['settings']['hideTriggerMode']) && $event['settings']['hideTriggerMode'];
+        $passthroughVars = [
+            'mauticContent' => 'campaignEvent',
+            'success'       => $success,
+            'route'         => false,
+        ];
+        if (!empty($keyId)) {
+            $passthroughVars = array_merge($passthroughVars, $this->eventViewVars($event, $campaignId, 'new'));
+        }
+        if ($closeModal) {
+            $passthroughVars['closeModal'] = 1;
+            return new JsonResponse($passthroughVars);
+        } else {
+            return $this->ajaxAction(
+                $request,
+                [
+                    'contentTemplate' => '@MauticCampaign/Event/form.html.twig',
+                    'viewParameters'  => $viewParams,
+                    'passthroughVars' => $passthroughVars,
+                ]
+            );
+        }
+    }
+    /**
+     * Generates edit form and processes post data.
+     *
+     * @return \Symfony\Component\HttpFoundation\RedirectResponse|\Symfony\Component\HttpFoundation\Response
+     */
+    public function editAction(Request $request, $objectId)
+    {
+        $session       = $request->getSession();
+        $valid         = $cancelled = false;
+        $method        = $request->getMethod();
+        $campaignEvent = $request->request->all()['campaignevent'] ?? [];
+        $campaignId    = 'POST' === $method
+            ? ($campaignEvent['campaignId'] ?? '')
+            : $request->query->get('campaignId');
+        $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
+        $event          = array_key_exists($objectId, $modifiedEvents) ? $modifiedEvents[$objectId] : [];
+        if ('POST' === $method) {
+            $event = array_merge($event, [
+                'anchor'          => $campaignEvent['anchor'] ?? '',
+                'anchorEventType' => $campaignEvent['anchorEventType'] ?? '',
+            ]);
+        } else {
+            if (!isset($event['anchor']) && !empty($event['decisionPath'])) {
+                $event['anchor'] = $event['decisionPath'];
+            }
+            if ($request->query->has('anchor')) {
+                $event['anchor'] = $request->get('anchor');
+            }
+            if ($request->query->has('anchorEventType')) {
+                $event['anchorEventType'] = $request->get('anchorEventType');
+            }
+        }
+        /*
+         * If we don't have an event, don't support the event type, this is not an
+         * AJAX request, or we are not granted campaign edit/create, deny access.
+         */
+        if (empty($event)
+            || empty($event['eventType'])
+            || !in_array($event['eventType'], $this->supportedEventTypes)
+            || !isset($event['type'])
+            || !$request->isXmlHttpRequest()
+            || !$this->security->isGranted(
+                [
+                    'campaign:campaigns:edit',
+                    'campaign:campaigns:create',
+                ],
+                'MATCH_ONE'
+            )
+        ) {
+            return $this->modalAccessDenied();
+        }
+        /**
+         * Fire the CampaignBuilderEvent event to get all events.
+         *
+         * We can directly dereference the return value here to get
+         * the supported events for this type because we already made
+         * sure that we're accessing a supported event type above.
+         *
+         * Method getEventsArray() returns translated labels & descriptions
+         */
+        $supportedEvents = $this->eventCollector->getEventsArray()[$event['eventType']];
+        $form            = $this->formFactory->create(
+            EventType::class,
+            $event,
+            [
+                'action'   => $this->generateUrl('mautic_campaignevent_action', ['objectAction' => 'edit', 'objectId' => $objectId]),
+                'settings' => $supportedEvents[$event['type']],
+            ]
+        );
+        $event['settings'] = $supportedEvents[$event['type']];
+        $form->get('campaignId')->setData($campaignId);
+        if ('POST' === $method) {
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $formData = $form->getData();
+                    $event    = array_merge($event, $formData);
+                    if (empty($event['name'])) {
+                        $event['name'] = $event['settings']['label'];
+                    }
+                    $modifiedEvents[$objectId] = $event;
+                    $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
+                }
+            }
+        }
+        $viewParams = [
+            'type'            => $event['type'],
+            'hideTriggerMode' => isset($event['settings']['hideTriggerMode']) && $event['settings']['hideTriggerMode'],
+        ];
+        $passthroughVars = [
+            'mauticContent' => 'campaignEvent',
+            'success'       => !$cancelled && $valid,
+            'route'         => false,
+        ];
+        if (!$cancelled && !$valid) {
+            if (isset($event['settings']['formTheme'])) {
+                $viewParams['formTheme'] = $event['settings']['formTheme'];
+            }
+            $viewParams = array_merge($viewParams, [
+                'form'             => $form->createView(),
+                'eventHeader'      => $event['settings']['label'],
+                'eventDescription' => $event['settings']['description'],
+            ]);
+            return $this->ajaxAction(
+                $request,
+                [
+                    'contentTemplate' => '@MauticCampaign/Event/form.html.twig',
+                    'viewParameters'  => $viewParams,
+                    'passthroughVars' => $passthroughVars,
+                ]
+            );
+        }
+        if (!$cancelled && $valid) {
+            $passthroughVars = array_merge($passthroughVars, $this->eventViewVars($event, $campaignId, 'edit'));
+        }
+        $passthroughVars['closeModal'] = 1;
+        return new JsonResponse($passthroughVars);
+    }
+    /**
+     * Deletes the entity.
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function deleteAction(Request $request, $objectId)
+    {
+        $campaignId     = $request->query->get('campaignId');
+        $session        = $request->getSession();
+        $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
+        $deletedEvents  = $session->get('mautic.campaign.'.$campaignId.'.events.deleted', []);
+        if (!$request->isXmlHttpRequest()
+            || !$this->security->isGranted(
+                [
+                    'campaign:campaigns:edit',
+                    'campaign:campaigns:create',
+                ],
+                'MATCH_ONE'
+            )
+        ) {
+            return $this->accessDenied();
+        }
+        $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
+        if ('POST' == $request->getMethod() && null !== $event) {
+            $events            = $this->eventCollector->getEventsArray();
+            $event['settings'] = $events[$event['eventType']][$event['type']];
+            if (!in_array($objectId, $deletedEvents)) {
+                if (!str_contains($objectId, 'new')) {
+                    $deletedEvents[] = $objectId;
+                    $session->set('mautic.campaign.'.$campaignId.'.events.deleted', $deletedEvents);
+                }
+                if (isset($modifiedEvents[$objectId])) {
+                    unset($modifiedEvents[$objectId]);
+                    $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
+                }
+            }
+            $dataArray = [
+                'mauticContent' => 'campaignEvent',
+                'success'       => 1,
+                'route'         => false,
+                'eventId'       => $objectId,
+                'deleted'       => 1,
+                'event'         => $event,
+            ];
+        } else {
+            $dataArray = ['success' => 0];
+        }
+        return new JsonResponse($dataArray);
+    }
+    /**
+     * Undeletes the entity.
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function undeleteAction(Request $request, $objectId)
+    {
+        $campaignId     = $request->query->get('campaignId');
+        $session        = $request->getSession();
+        $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
+        $deletedEvents  = $session->get('mautic.campaign.'.$campaignId.'.events.deleted', []);
+        if (!$request->isXmlHttpRequest()
+            || !$this->security->isGranted(
+                [
+                    'campaign:campaigns:edit',
+                    'campaign:campaigns:create',
+                ],
+                'MATCH_ONE'
+            )
+        ) {
+            return $this->accessDenied();
+        }
+        $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
+        if ('POST' == $request->getMethod() && null !== $event) {
+            $events            = $this->eventCollector->getEventsArray();
+            $event['settings'] = $events[$event['eventType']][$event['type']];
+            if (in_array($objectId, $deletedEvents)) {
+                $key = array_search($objectId, $deletedEvents);
+                unset($deletedEvents[$key]);
+                $session->set('mautic.campaign.'.$campaignId.'.events.deleted', $deletedEvents);
+            }
+            $template = (empty($event['settings']['template'])) ? '@MauticCampaign/Event/_generic.html.twig'
+                : $event['settings']['template'];
+            $entity = new Event();
+            $blank  = $entity->convertToArray();
+            $event  = array_merge($blank, $event);
+            $dataArray = [
+                'mauticContent' => 'campaignEvent',
+                'success'       => 1,
+                'route'         => false,
+                'eventId'       => $objectId,
+                'eventHtml'     => $this->renderView(
+                    $template,
+                    [
+                        'event'      => $event,
+                        'id'         => $objectId,
+                        'campaignId' => $campaignId,
+                    ]
+                ),
+            ];
+        } else {
+            $dataArray = ['success' => 0];
+        }
+        return new JsonResponse($dataArray);
+    }
+    public function cloneAction(Request $request, string $objectId): JsonResponse
+    {
+        $campaignId     = $request->query->get('campaignId');
+        $session        = $request->getSession();
+        $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
+        $campaign       = $this->campaignModel->getEntity($campaignId);
+        if (!$request->isXmlHttpRequest()
+            || !$this->security->isGranted(
+                [
+                    'campaign:campaigns:edit',
+                    'campaign:campaigns:create',
+                ],
+                'MATCH_ONE'
+            )
+        ) {
+            return $this->accessDenied();
+        }
+        $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
+        if ('POST' == $request->getMethod() && null !== $event) {
+            $keyId          = 'new'.hash('sha1', uniqid((string) mt_rand()));
+            $event['id']    = $event['tempId']    = $keyId;
+            $session->set('mautic.campaign.events.clone.storage', $event);
+            $dataArray = [
+                'success'       => 1,
+                'mauticContent' => 'campaignEventClone',
+                'route'         => false,
+                'eventId'       => $objectId,
+                'eventName'     => $event['name'],
+                'eventType'     => $event['eventType'],
+                'type'          => $event['type'],
+                'campaignId'    => $campaign ? $campaign->getId() : $campaignId,
+                'campaignName'  => $campaign ? $campaign->getName() : $this->translator->trans('mautic.campaign.event.clone.new.campaign'),
+            ];
+        } else {
+            $dataArray = ['success' => 0];
+        }
+        return new JsonResponse($dataArray);
+    }
+    public function insertAction(Request $request): JsonResponse
+    {
+        $campaignId     = $request->query->get('campaignId');
+        $session        = $request->getSession();
+        $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
+        $event          = $session->get('mautic.campaign.events.clone.storage');
+        if (empty($event)) {
+            return new JsonResponse([
+                'error' => $this->translator->trans('mautic.campaign.event.clone.request.missing'),
+            ], 400);
+        }
+        $session->remove('mautic.campaign.events.clone.storage');
+        $keyId          = 'new'.hash('sha1', uniqid((string) mt_rand()));
+        $event['id']    = $event['tempId'] = $keyId;
+        $modifiedEvents[$keyId] = $event;
+        $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
+        $passThroughVars               = [
+            'mauticContent'     => 'campaignEvent',
+            'clearCloneStorage' => true,
+            'success'           => 1,
+            'route'             => false,
+        ];
+        $passThroughVars = array_merge($passThroughVars, $this->eventViewVars($event, $campaignId, 'insert'));
+        return new JsonResponse($passThroughVars);
+    }
+    /**
+     * @param array<string, mixed> $event
+     *
+     * @return array<string, mixed>
+     */
+    private function eventViewVars(
+        array $event,
+        string $campaignId,
+        string $action,
+    ): array {
+        $event = array_merge((new Event())->convertToArray(), $event);
+        $template = $event['settings']['template'] ?? '@MauticCampaign/Event/_generic.html.twig';
+        $templateVars = [
+            'event'      => $event,
+            'id'         => $event['id'],
+            'campaignId' => $campaignId,
+        ];
+        if ('edit' === $action) {
+            $templateVars['update']        = true;
+        }
+        $passThroughKey                   = ('edit' === $action) ? 'updateHtml' : 'eventHtml';
+        $passThroughVars[$passThroughKey] = $this->renderView($template, $templateVars);
+        $passThroughVars += [
+            'event'     => $event,
+            'eventId'   => $event['id'],
+            'eventType' => $event['eventType'],
+        ];
+        if (Event::TRIGGER_MODE_INTERVAL === $event['triggerMode']) {
+            $label = 'mautic.campaign.connection.trigger.interval.label';
+            if (Event::PATH_INACTION === $event['anchor']) {
+                $label .= '_inaction';
+            }
+            $passThroughVars['label'] = $this->translator->trans(
+                $label,
+                [
+                    '%number%' => $event['triggerInterval'],
+                    '%unit%'   => $this->translator->trans(
+                        'mautic.campaign.event.intervalunit.'.$event['triggerIntervalUnit'],
+                        ['%count%' => $event['triggerInterval']]
+                    ),
+                ]
+            );
+        }
+        if (Event::TRIGGER_MODE_DATE === $event['triggerMode']) {
+            $label = 'mautic.campaign.connection.trigger.date.label';
+            if (Event::PATH_INACTION === $event['anchor']) {
+                $label .= '_inaction';
+            }
+            $passThroughVars['label'] = $this->translator->trans(
+                $label,
+                [
+                    '%full%' => $this->dateHelper->toFull($event['triggerDate']),
+                    '%time%' => $this->dateHelper->toTime($event['triggerDate']),
+                    '%date%' => $this->dateHelper->toShort($event['triggerDate']),
+                ]
+            );
+        }
+        return $passThroughVars;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Entity/Campaign.php
@@ -0,0 +1,594 @@
+<?php
+namespace Mautic\CampaignBundle\Entity;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Criteria;
+use Doctrine\Common\Collections\Order;
+use Doctrine\ORM\Mapping as ORM;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\FormEntity;
+use Mautic\CoreBundle\Entity\OptimisticLockInterface;
+use Mautic\CoreBundle\Entity\OptimisticLockTrait;
+use Mautic\CoreBundle\Entity\PublishStatusIconAttributesInterface;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Mautic\FormBundle\Entity\Form;
+use Mautic\LeadBundle\Entity\Lead as Contact;
+use Mautic\LeadBundle\Entity\LeadList;
+use Symfony\Component\Validator\Constraints as Assert;
+use Symfony\Component\Validator\Mapping\ClassMetadata;
+/**
+ * @ApiResource(
+ *   attributes={
+ *     "security"="false",
+ *     "normalization_context"={
+ *       "groups"={
+ *         "campaign:read"
+ *        },
+ *       "swagger_definition_name"="Read",
+ *       "api_included"={"category", "events", "lists", "forms", "fields", "actions"}
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "campaign:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Campaign extends FormEntity implements PublishStatusIconAttributesInterface, OptimisticLockInterface, UuidInterface
+{
+    use UuidTrait;
+    use OptimisticLockTrait;
+    public const TABLE_NAME = 'campaigns';
+    /**
+     * @var int
+     */
+    private $id;
+    /**
+     * @var string
+     */
+    private $name;
+    /**
+     * @var string|null
+     */
+    private $description;
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $publishUp;
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $publishDown;
+    public ?\DateTimeInterface $deleted = null;
+    /**
+     * @var \Mautic\CategoryBundle\Entity\Category|null
+     **/
+    private $category;
+    /**
+     * @var ArrayCollection<int, Event>
+     */
+    private $events;
+    /**
+     * @var ArrayCollection<int, Lead>
+     */
+    private $leads;
+    /**
+     * @var ArrayCollection<int, LeadList>
+     */
+    private $lists;
+    /**
+     * @var ArrayCollection<int, Form>
+     */
+    private $forms;
+    /**
+     * @var array
+     */
+    private $canvasSettings = [];
+    private bool $allowRestart = false;
+    public function __construct()
+    {
+        $this->events = new ArrayCollection();
+        $this->leads  = new ArrayCollection();
+        $this->lists  = new ArrayCollection();
+        $this->forms  = new ArrayCollection();
+    }
+    public function __clone()
+    {
+        $this->leads  = new ArrayCollection();
+        $this->events = new ArrayCollection();
+        $this->lists  = new ArrayCollection();
+        $this->forms  = new ArrayCollection();
+        $this->id     = null;
+        parent::__clone();
+    }
+    public static function loadMetadata(ORM\ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable(self::TABLE_NAME)
+            ->setCustomRepositoryClass(CampaignRepository::class);
+        $builder->addIdColumns();
+        $builder->addPublishDates();
+        $builder->addCategory();
+        $builder->createOneToMany('events', Event::class)
+            ->setIndexBy('id')
+            ->setOrderBy(['order' => 'ASC'])
+            ->mappedBy('campaign')
+            ->cascadeAll()
+            ->fetchExtraLazy()
+            ->build();
+        $builder->createOneToMany('leads', Lead::class)
+            ->mappedBy('campaign')
+            ->fetchExtraLazy()
+            ->build();
+        $builder->createManyToMany('lists', LeadList::class)
+            ->setJoinTable('campaign_leadlist_xref')
+            ->setIndexBy('id')
+            ->addInverseJoinColumn('leadlist_id', 'id', false, false, 'CASCADE')
+            ->addJoinColumn('campaign_id', 'id', true, false, 'CASCADE')
+            ->build();
+        $builder->createManyToMany('forms', Form::class)
+            ->setJoinTable('campaign_form_xref')
+            ->setIndexBy('id')
+            ->addInverseJoinColumn('form_id', 'id', false, false, 'CASCADE')
+            ->addJoinColumn('campaign_id', 'id', true, false, 'CASCADE')
+            ->build();
+        $builder->createField('canvasSettings', 'array')
+            ->columnName('canvas_settings')
+            ->nullable()
+            ->build();
+        $builder->addNamedField('allowRestart', 'boolean', 'allow_restart');
+        $builder->addNullableField('deleted', 'datetime');
+        self::addVersionField($builder);
+        static::addUuidField($builder);
+    }
+    public static function loadValidatorMetadata(ClassMetadata $metadata): void
+    {
+        $metadata->addPropertyConstraint(
+            'name',
+            new Assert\NotBlank(
+                [
+                    'message' => 'mautic.core.name.required',
+                ]
+            )
+        );
+    }
+    /**
+     * Prepares the metadata for API usage.
+     */
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('campaign')
+            ->addListProperties(
+                [
+                    'id',
+                    'name',
+                    'category',
+                    'description',
+                ]
+            )
+            ->addProperties(
+                [
+                    'allowRestart',
+                    'publishUp',
+                    'publishDown',
+                    'events',
+                    'forms',
+                    'lists', // @deprecated, will be renamed to 'segments' in 3.0.0
+                    'canvasSettings',
+                ]
+            )
+            ->setGroupPrefix('campaignBasic')
+            ->addListProperties(
+                [
+                    'id',
+                    'name',
+                    'description',
+                    'allowRestart',
+                    'events',
+                    'publishUp',
+                    'publishDown',
+                    'deleted',
+                ]
+            )
+            ->build();
+    }
+    public function convertToArray(): array
+    {
+        return get_object_vars($this);
+    }
+    /**
+     * @param string $prop
+     * @param mixed  $val
+     */
+    protected function isChanged($prop, $val)
+    {
+        $getter  = 'get'.ucfirst($prop);
+        $current = $this->$getter();
+        if ('category' == $prop) {
+            $currentId = ($current) ? $current->getId() : '';
+            $newId     = ($val) ? $val->getId() : null;
+            if ($currentId != $newId) {
+                $this->changes[$prop] = [$currentId, $newId];
+            }
+        } else {
+            parent::isChanged($prop, $val);
+        }
+    }
+    /**
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * Set description.
+     *
+     * @param string $description
+     *
+     * @return Campaign
+     */
+    public function setDescription($description)
+    {
+        $this->isChanged('description', $description);
+        $this->description = $description;
+        return $this;
+    }
+    /**
+     * Get description.
+     *
+     * @return string
+     */
+    public function getDescription()
+    {
+        return $this->description;
+    }
+    /**
+     * Set name.
+     *
+     * @param string $name
+     *
+     * @return Campaign
+     */
+    public function setName($name)
+    {
+        $this->isChanged('name', $name);
+        $this->name = $name;
+        return $this;
+    }
+    /**
+     * Get name.
+     *
+     * @return string
+     */
+    public function getName()
+    {
+        return $this->name;
+    }
+    /**
+     * Calls $this->addEvent on every item in the collection.
+     *
+     * @return Campaign
+     */
+    public function addEvents(array $events)
+    {
+        foreach ($events as $id => $event) {
+            $this->addEvent($id, $event);
+        }
+        return $this;
+    }
+    /**
+     * Add events.
+     *
+     * @return Campaign
+     */
+    public function addEvent($key, Event $event)
+    {
+        if ($changes = $event->getChanges()) {
+            $this->changes['events']['added'][$key] = [$key, $changes];
+        }
+        $this->events[$key] = $event;
+        return $this;
+    }
+    /**
+     * Remove events.
+     */
+    public function removeEvent(Event $event): void
+    {
+        $this->changes['events']['removed'][$event->getId()] = $event->getName();
+        $this->events->removeElement($event);
+    }
+    /**
+     * Get events.
+     *
+     * @return ArrayCollection
+     */
+    public function getEvents()
+    {
+        return $this->events;
+    }
+    public function getRootEvents(): ArrayCollection
+    {
+        $criteria = Criteria::create()->where(
+            Criteria::expr()->andX(
+                Criteria::expr()->isNull('parent'),
+                Criteria::expr()->isNull('deleted')
+            )
+        );
+        $events   = $this->getEvents()->matching($criteria);
+        $keyedArrayCollection = new ArrayCollection();
+        /** @var Event $event */
+        foreach ($events as $event) {
+            $keyedArrayCollection->set($event->getId(), $event);
+        }
+        unset($events);
+        return $keyedArrayCollection;
+    }
+    public function getInactionBasedEvents(): ArrayCollection
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', Event::PATH_INACTION));
+        $events   = $this->getEvents()->matching($criteria);
+        $keyedArrayCollection = new ArrayCollection();
+        /** @var Event $event */
+        foreach ($events as $event) {
+            $keyedArrayCollection->set($event->getId(), $event);
+        }
+        unset($events);
+        return $keyedArrayCollection;
+    }
+    /**
+     * @param string $type
+     *
+     * @return ArrayCollection<int,Event>
+     */
+    public function getEventsByType($type): ArrayCollection
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('eventType', $type));
+        $events   = $this->getEvents()->matching($criteria);
+        $keyedArrayCollection = new ArrayCollection();
+        /** @var Event $event */
+        foreach ($events as $event) {
+            $keyedArrayCollection->set($event->getId(), $event);
+        }
+        unset($events);
+        return $keyedArrayCollection;
+    }
+    /**
+     * @return ArrayCollection<int, Event>
+     */
+    public function getEmailSendEvents(): ArrayCollection
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('type', 'email.send'));
+        $events   = $this->getEvents()->matching($criteria);
+        $keyedArrayCollection = new ArrayCollection();
+        /** @var Event $event */
+        foreach ($events as $event) {
+            $keyedArrayCollection->set($event->getId(), $event);
+        }
+        return $keyedArrayCollection;
+    }
+    public function isEmailCampaign(): bool
+    {
+        $criteria     = Criteria::create()->where(Criteria::expr()->eq('type', 'email.send'))->setMaxResults(1);
+        $emailEvent   = $this->getEvents()->matching($criteria);
+        return !$emailEvent->isEmpty();
+    }
+    /**
+     * Set publishUp.
+     *
+     * @param ?\DateTime $publishUp
+     *
+     * @return Campaign
+     */
+    public function setPublishUp($publishUp)
+    {
+        $this->isChanged('publishUp', $publishUp);
+        $this->publishUp = $publishUp;
+        return $this;
+    }
+    /**
+     * Get publishUp.
+     *
+     * @return \DateTimeInterface
+     */
+    public function getPublishUp()
+    {
+        return $this->publishUp;
+    }
+    /**
+     * Set publishDown.
+     *
+     * @param ?\DateTime $publishDown
+     *
+     * @return Campaign
+     */
+    public function setPublishDown($publishDown)
+    {
+        $this->isChanged('publishDown', $publishDown);
+        $this->publishDown = $publishDown;
+        return $this;
+    }
+    /**
+     * Get publishDown.
+     *
+     * @return \DateTimeInterface
+     */
+    public function getPublishDown()
+    {
+        return $this->publishDown;
+    }
+    /**
+     * @return mixed
+     */
+    public function getCategory()
+    {
+        return $this->category;
+    }
+    /**
+     * @param mixed $category
+     */
+    public function setCategory($category): void
+    {
+        $this->isChanged('category', $category);
+        $this->category = $category;
+    }
+    /**
+     * Add lead.
+     *
+     * @return Campaign
+     */
+    public function addLead($key, Lead $lead)
+    {
+        $action     = ($this->leads->contains($lead)) ? 'updated' : 'added';
+        $leadEntity = $lead->getLead();
+        $this->changes['leads'][$action][$leadEntity->getId()] = $leadEntity->getPrimaryIdentifier();
+        $this->leads[$key]                                     = $lead;
+        return $this;
+    }
+    /**
+     * Remove lead.
+     */
+    public function removeLead(Lead $lead): void
+    {
+        $leadEntity                                              = $lead->getLead();
+        $this->changes['leads']['removed'][$leadEntity->getId()] = $leadEntity->getPrimaryIdentifier();
+        $this->leads->removeElement($lead);
+    }
+    /**
+     * Get leads.
+     *
+     * @return Lead[]|\Doctrine\Common\Collections\Collection
+     */
+    public function getLeads()
+    {
+        return $this->leads;
+    }
+    /**
+     * @return ArrayCollection
+     */
+    public function getLists()
+    {
+        return $this->lists;
+    }
+    /**
+     * Add list.
+     *
+     * @return Campaign
+     */
+    public function addList(LeadList $list)
+    {
+        $this->lists[$list->getId()] = $list;
+        $this->changes['lists']['added'][$list->getId()] = $list->getName();
+        return $this;
+    }
+    /**
+     * Remove list.
+     */
+    public function removeList(LeadList $list): void
+    {
+        $this->changes['lists']['removed'][$list->getId()] = $list->getName();
+        $this->lists->removeElement($list);
+    }
+    /**
+     * @return ArrayCollection
+     */
+    public function getForms()
+    {
+        return $this->forms;
+    }
+    /**
+     * Add form.
+     *
+     * @return Campaign
+     */
+    public function addForm(Form $form)
+    {
+        $this->forms[$form->getId()] = $form;
+        $this->changes['forms']['added'][$form->getId()] = $form->getName();
+        return $this;
+    }
+    /**
+     * Remove form.
+     */
+    public function removeForm(Form $form): void
+    {
+        $this->changes['forms']['removed'][$form->getId()] = $form->getName();
+        $this->forms->removeElement($form);
+    }
+    /**
+     * @return mixed
+     */
+    public function getCanvasSettings()
+    {
+        return $this->canvasSettings;
+    }
+    public function setCanvasSettings(array $canvasSettings): void
+    {
+        $this->canvasSettings = $canvasSettings;
+    }
+    public function getAllowRestart(): bool
+    {
+        return (bool) $this->allowRestart;
+    }
+    public function allowRestart(): bool
+    {
+        return $this->getAllowRestart();
+    }
+    /**
+     * @param bool $allowRestart
+     *
+     * @return Campaign
+     */
+    public function setAllowRestart($allowRestart)
+    {
+        $allowRestart = (bool) $allowRestart;
+        $this->isChanged('allowRestart', $allowRestart);
+        $this->allowRestart = $allowRestart;
+        return $this;
+    }
+    public function setDeleted(?\DateTimeInterface $deleted): void
+    {
+        $this->isChanged('deleted', $deleted);
+        $this->deleted = $deleted;
+    }
+    public function isDeleted(): bool
+    {
+        return !is_null($this->deleted);
+    }
+    /**
+     * Get contact membership.
+     *
+     * @return \Doctrine\Common\Collections\Collection
+     */
+    public function getContactMembership(Contact $contact)
+    {
+        return $this->leads->matching(
+            Criteria::create()
+                ->where(Criteria::expr()->eq('lead', $contact))
+                ->orderBy(['dateAdded' => Order::Descending->value])
+        );
+    }
+    public function getOnclickMethod(): string
+    {
+        return 'Mautic.confirmationCampaignPublishStatus(mQuery(this));';
+    }
+    public function getDataAttributes(): array
+    {
+        return [
+            'data-toggle'           => 'confirmation',
+            'data-confirm-callback' => 'confirmCallbackCampaignPublishStatus',
+            'data-cancel-callback'  => 'dismissConfirmation',
+        ];
+    }
+    public function getTranslationKeysDataAttributes(): array
+    {
+        return [
+            'data-message'      => 'mautic.campaign.form.confirmation.message',
+            'data-confirm-text' => 'mautic.campaign.form.confirmation.confirm_text',
+            'data-cancel-text'  => 'mautic.campaign.form.confirmation.cancel_text',
+        ];
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Entity/Event.php
@@ -0,0 +1,938 @@
+<?php
+namespace Mautic\CampaignBundle\Entity;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Collection;
+use Doctrine\Common\Collections\Criteria;
+use Doctrine\ORM\Mapping as ORM;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Mautic\CoreBundle\Validator\EntityEvent;
+use Mautic\LeadBundle\Entity\Lead as Contact;
+use Symfony\Component\Validator\Mapping\ClassMetadata;
+/**
+ * @ApiResource(
+ *   attributes={
+ *     "security"="false",
+ *     "normalization_context"={
+ *       "groups"={
+ *         "event:read"
+ *        },
+ *       "swagger_definition_name"="Read"
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "event:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Event implements ChannelInterface, UuidInterface
+{
+    use UuidTrait;
+    public const TABLE_NAME = 'campaign_events';
+    public const TYPE_DECISION  = 'decision';
+    public const TYPE_ACTION    = 'action';
+    public const TYPE_CONDITION = 'condition';
+    public const PATH_INACTION = 'no';
+    public const PATH_ACTION   = 'yes';
+    public const TRIGGER_MODE_DATE      = 'date';
+    public const TRIGGER_MODE_INTERVAL  = 'interval';
+    public const TRIGGER_MODE_IMMEDIATE = 'immediate';
+    public const TRIGGER_MODE_OPTIMIZED = 'optimized';
+    public const CHANNEL_EMAIL = 'email';
+    /**
+     * @var int
+     */
+    private $id;
+    /**
+     * @var string
+     */
+    private $name;
+    /**
+     * @var string|null
+     */
+    private $description;
+    /**
+     * @var string
+     */
+    private $type;
+    /**
+     * @var string
+     */
+    private $eventType;
+    /**
+     * @var int
+     */
+    private $order = 0;
+    /**
+     * @var array
+     */
+    private $properties = [];
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $triggerDate;
+    /**
+     * @var int|null
+     */
+    private $triggerInterval = 0;
+    /**
+     * @var string|null
+     */
+    private $triggerIntervalUnit;
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $triggerHour;
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $triggerRestrictedStartHour;
+    /**
+     * @var \DateTimeInterface|null
+     */
+    private $triggerRestrictedStopHour;
+    /**
+     * @var array|null
+     */
+    private $triggerRestrictedDaysOfWeek = [];
+    private ?int $triggerWindow;
+    /**
+     * @var string|null
+     */
+    private $triggerMode;
+    /**
+     * @var Campaign
+     */
+    private $campaign;
+    /**
+     * @var ArrayCollection<int, Event>
+     **/
+    private $children;
+    /**
+     * @var Event|null
+     **/
+    private $parent;
+    /**
+     * @var string|null
+     **/
+    private $decisionPath;
+    /**
+     * @var string|null
+     **/
+    private $tempId;
+    /**
+     * @var ArrayCollection<int, LeadEventLog>
+     */
+    private $log;
+    /**
+     * Used by API to house contact specific logs.
+     *
+     * @var array
+     */
+    private $contactLog = [];
+    /**
+     * @var string|null
+     */
+    private $channel;
+    /**
+     * @var int|null
+     */
+    private $channelId;
+    /**
+     * @var array
+     */
+    private $changes = [];
+    private ?\DateTimeInterface $deleted = null;
+    private int $failedCount = 0;
+    public function __construct()
+    {
+        $this->log      = new ArrayCollection();
+        $this->children = new ArrayCollection();
+    }
+    /**
+     * Clean up after clone.
+     */
+    public function __clone()
+    {
+        $this->tempId    = null;
+        $this->campaign  = null;
+        $this->channel   = null;
+        $this->channelId = null;
+    }
+    public static function loadMetadata(ORM\ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable(self::TABLE_NAME)
+            ->setCustomRepositoryClass(EventRepository::class)
+            ->addIndex(['type', 'event_type'], 'campaign_event_search')
+            ->addIndex(['event_type'], 'campaign_event_type')
+            ->addIndex(['channel', 'channel_id'], 'campaign_event_channel');
+        $builder->addIdColumns();
+        $builder->createField('type', 'string')
+            ->length(50)
+            ->build();
+        $builder->createField('eventType', 'string')
+            ->columnName('event_type')
+            ->length(50)
+            ->build();
+        $builder->createField('order', 'integer')
+            ->columnName('event_order')
+            ->build();
+        $builder->addField('properties', 'array');
+        $builder->addNullableField('deleted', 'datetime');
+        $builder->createField('triggerDate', 'datetime')
+            ->columnName('trigger_date')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerInterval', 'integer')
+            ->columnName('trigger_interval')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerIntervalUnit', 'string')
+            ->columnName('trigger_interval_unit')
+            ->length(1)
+            ->nullable()
+            ->build();
+        $builder->createField('triggerHour', 'time')
+            ->columnName('trigger_hour')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerRestrictedStartHour', 'time')
+            ->columnName('trigger_restricted_start_hour')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerRestrictedStopHour', 'time')
+            ->columnName('trigger_restricted_stop_hour')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerRestrictedDaysOfWeek', 'array')
+            ->columnName('trigger_restricted_dow')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerWindow', 'integer')
+            ->columnName('trigger_window')
+            ->nullable()
+            ->build();
+        $builder->createField('triggerMode', 'string')
+            ->columnName('trigger_mode')
+            ->length(10)
+            ->nullable()
+            ->build();
+        $builder->createManyToOne('campaign', 'Campaign')
+            ->inversedBy('events')
+            ->addJoinColumn('campaign_id', 'id', false, false, 'CASCADE')
+            ->build();
+        $builder->createOneToMany('children', 'Event')
+            ->setIndexBy('id')
+            ->setOrderBy(['order' => 'ASC'])
+            ->mappedBy('parent')
+            ->build();
+        $builder->createManyToOne('parent', 'Event')
+            ->inversedBy('children')
+            ->cascadePersist()
+            ->addJoinColumn('parent_id', 'id')
+            ->build();
+        $builder->createField('decisionPath', 'string')
+            ->columnName('decision_path')
+            ->nullable()
+            ->build();
+        $builder->createField('tempId', 'string')
+            ->columnName('temp_id')
+            ->nullable()
+            ->build();
+        $builder->createOneToMany('log', 'LeadEventLog')
+            ->mappedBy('event')
+            ->cascadePersist()
+            ->fetchExtraLazy()
+            ->build();
+        $builder->createField('channel', 'string')
+            ->nullable()
+            ->build();
+        $builder->createField('channelId', 'integer')
+            ->columnName('channel_id')
+            ->nullable()
+            ->build();
+        $builder->createField('failedCount', 'integer')
+            ->columnName('failed_count')
+            ->build();
+        static::addUuidField($builder);
+    }
+    /**
+     * Prepares the metadata for API usage.
+     */
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('campaignEvent')
+            ->addListProperties(
+                [
+                    'id',
+                    'name',
+                    'description',
+                    'type',
+                    'eventType',
+                    'channel',
+                    'channelId',
+                ]
+            )
+            ->addProperties(
+                [
+                    'order',
+                    'properties',
+                    'triggerDate',
+                    'triggerInterval',
+                    'triggerIntervalUnit',
+                    'triggerHour',
+                    'triggerRestrictedStartHour',
+                    'triggerRestrictedStopHour',
+                    'triggerRestrictedDaysOfWeek',
+                    'triggerMode',
+                    'decisionPath',
+                    'channel',
+                    'channelId',
+                    'parent',
+                    'children',
+                ]
+            )
+            ->setMaxDepth(1, 'parent')
+            ->setMaxDepth(1, 'children')
+            ->setGroupPrefix('campaignEventStandalone')
+             ->addListProperties(
+                 [
+                     'id',
+                     'name',
+                     'description',
+                     'type',
+                     'eventType',
+                     'channel',
+                     'channelId',
+                 ]
+             )
+             ->addProperties(
+                 [
+                     'campaign',
+                     'order',
+                     'properties',
+                     'triggerDate',
+                     'triggerInterval',
+                     'triggerIntervalUnit',
+                     'triggerHour',
+                     'triggerRestrictedStartHour',
+                     'triggerRestrictedStopHour',
+                     'triggerRestrictedDaysOfWeek',
+                     'triggerMode',
+                     'children',
+                     'parent',
+                     'decisionPath',
+                 ]
+             )
+            ->setGroupPrefix('campaignEventWithLogs')
+            ->addListProperties(
+                [
+                    'id',
+                    'name',
+                    'description',
+                    'type',
+                    'eventType',
+                    'contactLog',
+                    'triggerDate',
+                    'triggerInterval',
+                    'triggerIntervalUnit',
+                    'triggerHour',
+                    'triggerRestrictedStartHour',
+                    'triggerRestrictedStopHour',
+                    'triggerRestrictedDaysOfWeek',
+                    'triggerMode',
+                    'decisionPath',
+                    'order',
+                    'parent',
+                    'channel',
+                    'channelId',
+                ]
+            )
+            ->addProperties(
+                [
+                    'campaign',
+                ]
+            )
+             ->build();
+    }
+    public static function loadValidatorMetadata(ClassMetadata $metadata): void
+    {
+        $metadata->addConstraint(new EntityEvent());
+    }
+    /**
+     * @param string $prop
+     * @param mixed  $val
+     */
+    private function isChanged($prop, $val): void
+    {
+        $getter  = 'get'.ucfirst($prop);
+        $current = $this->$getter();
+        if ('category' == $prop || 'parent' == $prop) {
+            $currentId = ($current) ? $current->getId() : '';
+            $newId     = ($val) ? $val->getId() : null;
+            if ($currentId != $newId) {
+                $this->changes[$prop] = [$currentId, $newId];
+            }
+        } elseif ($this->$prop != $val) {
+            $this->changes[$prop] = [$this->$prop, $val];
+        }
+    }
+    /**
+     * @return array
+     */
+    public function getChanges()
+    {
+        return $this->changes;
+    }
+    /**
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    public function nullId(): void
+    {
+        $this->id = null;
+    }
+    /**
+     * @param int $order
+     *
+     * @return Event
+     */
+    public function setOrder($order)
+    {
+        $this->isChanged('order', $order);
+        $this->order = $order;
+        return $this;
+    }
+    /**
+     * @return int
+     */
+    public function getOrder()
+    {
+        return $this->order;
+    }
+    /**
+     * @param array $properties
+     *
+     * @return Event
+     */
+    public function setProperties($properties)
+    {
+        $this->isChanged('properties', $properties);
+        $this->properties = $properties;
+        return $this;
+    }
+    /**
+     * @return array
+     */
+    public function getProperties()
+    {
+        return $this->properties;
+    }
+    /**
+     * @return Event
+     */
+    public function setCampaign(Campaign $campaign)
+    {
+        $this->campaign = $campaign;
+        return $this;
+    }
+    /**
+     * @return Campaign
+     */
+    public function getCampaign()
+    {
+        return $this->campaign;
+    }
+    /**
+     * @param string $type
+     *
+     * @return Event
+     */
+    public function setType($type)
+    {
+        $this->isChanged('type', $type);
+        $this->type = $type;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getType()
+    {
+        return $this->type;
+    }
+    public function convertToArray(): array
+    {
+        return get_object_vars($this);
+    }
+    /**
+     * @param string $description
+     *
+     * @return Event
+     */
+    public function setDescription($description)
+    {
+        $this->isChanged('description', $description);
+        $this->description = $description;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getDescription()
+    {
+        return $this->description;
+    }
+    /**
+     * @param string $name
+     *
+     * @return Event
+     */
+    public function setName($name)
+    {
+        $this->isChanged('name', $name);
+        $this->name = $name;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getName()
+    {
+        return $this->name;
+    }
+    /**
+     * @return Event
+     */
+    public function addLog(LeadEventLog $log)
+    {
+        $this->log[] = $log;
+        return $this;
+    }
+    /**
+     * Remove log.
+     */
+    public function removeLog(LeadEventLog $log): void
+    {
+        $this->log->removeElement($log);
+    }
+    /**
+     * @return Collection
+     */
+    public function getLog()
+    {
+        return $this->log;
+    }
+    /**
+     * Get log for a contact and a rotation.
+     *
+     * @return LeadEventLog|null
+     */
+    public function getLogByContactAndRotation(Contact $contact, $rotation)
+    {
+        $criteria = Criteria::create()
+            ->where(Criteria::expr()->eq('lead', $contact))
+            ->andWhere(Criteria::expr()->eq('rotation', $rotation))
+            ->setMaxResults(1);
+        $log = $this->getLog()->matching($criteria);
+        if (count($log)) {
+            return $log->first();
+        }
+        return null;
+    }
+    /**
+     * Add children.
+     *
+     * @return Event
+     */
+    public function addChild(Event $children)
+    {
+        $this->children[] = $children;
+        return $this;
+    }
+    /**
+     * Remove children.
+     */
+    public function removeChild(Event $children): void
+    {
+        $this->children->removeElement($children);
+    }
+    /**
+     * @return ArrayCollection<int,Event>|Collection<(int|string), mixed>
+     */
+    public function getChildren()
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->isNull('deleted'));
+        return $this->children->matching($criteria);
+    }
+    /**
+     * @return ArrayCollection<int,Event>
+     */
+    public function getPositiveChildren()
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', self::PATH_ACTION));
+        return $this->getChildren()->matching($criteria);
+    }
+    /**
+     * @return ArrayCollection<int,Event>
+     */
+    public function getNegativeChildren()
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', self::PATH_INACTION));
+        return $this->getChildren()->matching($criteria);
+    }
+    /**
+     * @param string $type
+     *
+     * @return ArrayCollection<int,Event>
+     */
+    public function getChildrenByType($type)
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('type', $type));
+        return $this->getChildren()->matching($criteria);
+    }
+    /**
+     * @param string $type
+     *
+     * @return ArrayCollection<int,Event>
+     */
+    public function getChildrenByEventType($type)
+    {
+        $criteria = Criteria::create()->where(Criteria::expr()->eq('eventType', $type));
+        return $this->getChildren()->matching($criteria);
+    }
+    /**
+     * Set parent.
+     *
+     * @return Event
+     */
+    public function setParent(Event $parent = null)
+    {
+        $this->isChanged('parent', $parent);
+        $this->parent = $parent;
+        return $this;
+    }
+    /**
+     * Remove parent.
+     */
+    public function removeParent(): void
+    {
+        $this->isChanged('parent', '');
+        $this->parent = null;
+    }
+    /**
+     * @return ?Event
+     */
+    public function getParent()
+    {
+        return $this->parent;
+    }
+    /**
+     * @return mixed
+     */
+    public function getTriggerDate()
+    {
+        return $this->triggerDate;
+    }
+    /**
+     * @param \DateTime|null $triggerDate
+     */
+    public function setTriggerDate($triggerDate): void
+    {
+        $this->isChanged('triggerDate', $triggerDate);
+        $this->triggerDate = $triggerDate;
+    }
+    /**
+     * @return int
+     */
+    public function getTriggerInterval()
+    {
+        return $this->triggerInterval;
+    }
+    /**
+     * @param int $triggerInterval
+     */
+    public function setTriggerInterval($triggerInterval): void
+    {
+        $this->isChanged('triggerInterval', $triggerInterval);
+        $this->triggerInterval = $triggerInterval;
+    }
+    /**
+     * @return \DateTimeInterface|null
+     */
+    public function getTriggerHour()
+    {
+        return $this->triggerHour;
+    }
+    /**
+     * @param string $triggerHour
+     *
+     * @return Event
+     */
+    public function setTriggerHour($triggerHour)
+    {
+        if (empty($triggerHour)) {
+            $triggerHour = null;
+        } elseif (!$triggerHour instanceof \DateTime) {
+            $triggerHour = new \DateTime($triggerHour);
+        }
+        $this->isChanged('triggerHour', $triggerHour ? $triggerHour->format('H:i') : $triggerHour);
+        $this->triggerHour = $triggerHour;
+        return $this;
+    }
+    /**
+     * @return mixed
+     */
+    public function getTriggerIntervalUnit()
+    {
+        return $this->triggerIntervalUnit;
+    }
+    /**
+     * @param mixed $triggerIntervalUnit
+     */
+    public function setTriggerIntervalUnit($triggerIntervalUnit): void
+    {
+        $this->isChanged('triggerIntervalUnit', $triggerIntervalUnit);
+        $this->triggerIntervalUnit = $triggerIntervalUnit;
+    }
+    /**
+     * @return mixed
+     */
+    public function getEventType()
+    {
+        return $this->eventType;
+    }
+    /**
+     * @return $this
+     */
+    public function setEventType($eventType)
+    {
+        $this->isChanged('eventType', $eventType);
+        $this->eventType = $eventType;
+        return $this;
+    }
+    public function getTriggerWindow(): ?int
+    {
+        return $this->triggerWindow;
+    }
+    public function setTriggerWindow(?int $triggerWindow): Event
+    {
+        $this->triggerWindow = $triggerWindow;
+        return $this;
+    }
+    /**
+     * @return mixed
+     */
+    public function getTriggerMode()
+    {
+        return $this->triggerMode;
+    }
+    /**
+     * @param mixed $triggerMode
+     */
+    public function setTriggerMode($triggerMode): void
+    {
+        $this->isChanged('triggerMode', $triggerMode);
+        $this->triggerMode = $triggerMode;
+    }
+    /**
+     * @return mixed
+     */
+    public function getDecisionPath()
+    {
+        return $this->decisionPath;
+    }
+    /**
+     * @param mixed $decisionPath
+     */
+    public function setDecisionPath($decisionPath): void
+    {
+        $this->isChanged('decisionPath', $decisionPath);
+        $this->decisionPath = $decisionPath;
+    }
+    /**
+     * @return mixed
+     */
+    public function getTempId()
+    {
+        return $this->tempId;
+    }
+    /**
+     * @param mixed $tempId
+     */
+    public function setTempId($tempId): void
+    {
+        $this->isChanged('tempId', $tempId);
+        $this->tempId = $tempId;
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannel()
+    {
+        return $this->channel;
+    }
+    /**
+     * @param mixed $channel
+     */
+    public function setChannel($channel): void
+    {
+        $this->isChanged('channel', $channel);
+        $this->channel = $channel;
+    }
+    /**
+     * @return int
+     */
+    public function getChannelId()
+    {
+        return $this->channelId;
+    }
+    /**
+     * @param int $channelId
+     */
+    public function setChannelId($channelId): void
+    {
+        $this->isChanged('channelId', $channelId);
+        $this->channelId = (int) $channelId;
+    }
+    /**
+     * Used by the API.
+     *
+     * @return LeadEventLog[]|Collection|static
+     */
+    public function getContactLog(Contact $contact = null)
+    {
+        if ($this->contactLog) {
+            return $this->contactLog;
+        }
+        return $this->log->matching(
+            Criteria::create()
+                    ->where(
+                        Criteria::expr()->eq('lead', $contact)
+                    )
+        );
+    }
+    /**
+     * Used by the API.
+     *
+     * @param array $contactLog
+     *
+     * @return Event
+     */
+    public function setContactLog($contactLog)
+    {
+        $this->contactLog = $contactLog;
+        return $this;
+    }
+    /**
+     * Used by the API.
+     *
+     * @return Event
+     */
+    public function addContactLog($contactLog)
+    {
+        $this->contactLog[] = $contactLog;
+        return $this;
+    }
+    /**
+     * Get the value of triggerRestrictedStartHour.
+     *
+     * @return \DateTimeInterface|null
+     */
+    public function getTriggerRestrictedStartHour()
+    {
+        return $this->triggerRestrictedStartHour;
+    }
+    /**
+     * Set the value of triggerRestrictedStartHour.
+     *
+     * @param \DateTime|null $triggerRestrictedStartHour
+     *
+     * @return self
+     */
+    public function setTriggerRestrictedStartHour($triggerRestrictedStartHour)
+    {
+        if (empty($triggerRestrictedStartHour)) {
+            $triggerRestrictedStartHour = null;
+        } elseif (!$triggerRestrictedStartHour instanceof \DateTime) {
+            $triggerRestrictedStartHour = new \DateTime($triggerRestrictedStartHour);
+        }
+        $this->isChanged('triggerRestrictedStartHour', $triggerRestrictedStartHour ? $triggerRestrictedStartHour->format('H:i') : $triggerRestrictedStartHour);
+        $this->triggerRestrictedStartHour = $triggerRestrictedStartHour;
+        return $this;
+    }
+    /**
+     * Get the value of triggerRestrictedStopHour.
+     *
+     * @return \DateTimeInterface|null
+     */
+    public function getTriggerRestrictedStopHour()
+    {
+        return $this->triggerRestrictedStopHour;
+    }
+    /**
+     * Set the value of triggerRestrictedStopHour.
+     *
+     * @param \DateTime|null $triggerRestrictedStopHour
+     *
+     * @return self
+     */
+    public function setTriggerRestrictedStopHour($triggerRestrictedStopHour)
+    {
+        if (empty($triggerRestrictedStopHour)) {
+            $triggerRestrictedStopHour = null;
+        } elseif (!$triggerRestrictedStopHour instanceof \DateTime) {
+            $triggerRestrictedStopHour = new \DateTime($triggerRestrictedStopHour);
+        }
+        $this->isChanged('triggerRestrictedStopHour', $triggerRestrictedStopHour ? $triggerRestrictedStopHour->format('H:i') : $triggerRestrictedStopHour);
+        $this->triggerRestrictedStopHour = $triggerRestrictedStopHour;
+        return $this;
+    }
+    /**
+     * Get the value of triggerRestrictedDaysOfWeek.
+     *
+     * @return array
+     */
+    public function getTriggerRestrictedDaysOfWeek()
+    {
+        return (array) $this->triggerRestrictedDaysOfWeek;
+    }
+    /**
+     * Set the value of triggerRestrictedDaysOfWeek.
+     *
+     * @return self
+     */
+    public function setTriggerRestrictedDaysOfWeek(array $triggerRestrictedDaysOfWeek = null)
+    {
+        $this->triggerRestrictedDaysOfWeek = $triggerRestrictedDaysOfWeek;
+        $this->isChanged('triggerRestrictedDaysOfWeek', $triggerRestrictedDaysOfWeek);
+        return $this;
+    }
+    public function setDeleted(?\DateTimeInterface $deleted): Event
+    {
+        $this->isChanged('deleted', $deleted);
+        $this->deleted = $deleted;
+        return $this;
+    }
+    public function getDeleted(): ?\DateTimeInterface
+    {
+        return $this->deleted;
+    }
+    public function isDeleted(): bool
+    {
+        return !is_null($this->deleted);
+    }
+    public function getFailedCount(): int
+    {
+        return $this->failedCount;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Entity/EventRepository.php
@@ -0,0 +1,377 @@
+<?php
+namespace Mautic\CampaignBundle\Entity;
+use Doctrine\Common\Collections\Order;
+use Doctrine\DBAL\ArrayParameterType;
+use Mautic\CoreBundle\Entity\CommonRepository;
+/**
+ * @extends CommonRepository<Event>
+ */
+class EventRepository extends CommonRepository
+{
+    /**
+     * Get a list of entities.
+     *
+     * @param mixed[] $args
+     *
+     * @return \Doctrine\ORM\Tools\Pagination\Paginator<object>|object[]|mixed[]
+     */
+    public function getEntities(array $args = [])
+    {
+        $select = 'e';
+        $q      = $this
+            ->createQueryBuilder('e')
+            ->join('e.campaign', 'c');
+        if (!empty($args['campaign_id'])) {
+            $q->andWhere(
+                $q->expr()->eq('IDENTITY(e.campaign)', (int) $args['campaign_id'])
+            );
+        }
+        if (empty($args['ignore_children'])) {
+            $select .= ', ec, ep';
+            $q->leftJoin('e.children', 'ec')
+                ->leftJoin('e.parent', 'ep');
+        }
+        $q->select($select);
+        $args['qb'] = $q;
+        return parent::getEntities($args);
+    }
+    /**
+     * @param int    $contactId
+     * @param string $type
+     *
+     * @return array
+     */
+    public function getContactPendingEvents($contactId, $type)
+    {
+        $eventQb = $this->getEntityManager()->createQueryBuilder();
+        $eventQb->select('IDENTITY(log_event.event)')
+            ->from(LeadEventLog::class, 'log_event')
+            ->where(
+                $eventQb->expr()->andX(
+                    $eventQb->expr()->eq('log_event.event', 'e'),
+                    $eventQb->expr()->eq('log_event.lead', 'l.lead'),
+                    $eventQb->expr()->eq('log_event.rotation', 'l.rotation')
+                )
+            );
+        $parentQb = $this->getEntityManager()->createQueryBuilder();
+        $parentQb->select('parent_log_event.id')
+            ->from(LeadEventLog::class, 'parent_log_event')
+            ->where(
+                $parentQb->expr()->eq('parent_log_event.event', 'e.parent'),
+                $parentQb->expr()->eq('parent_log_event.lead', 'l.lead'),
+                $parentQb->expr()->eq('parent_log_event.rotation', 'l.rotation'),
+                $parentQb->expr()->eq('parent_log_event.isScheduled', 0)
+            );
+        $q = $this->createQueryBuilder('e', 'e.id');
+        $q->select('e,c')
+            ->innerJoin('e.campaign', 'c')
+            ->innerJoin('c.leads', 'l')
+            ->where(
+                $q->expr()->andX(
+                    $q->expr()->eq('c.isPublished', 1),
+                    $q->expr()->orX(
+                        $q->expr()->isNull('c.publishUp'),
+                        $q->expr()->lt('c.publishUp', 'CURRENT_TIMESTAMP()'),
+                    ),
+                    $q->expr()->orX(
+                        $q->expr()->isNull('c.publishDown'),
+                        $q->expr()->gt('c.publishDown', 'CURRENT_TIMESTAMP()'),
+                    ),
+                    $q->expr()->isNull('c.deleted'),
+                    $q->expr()->eq('e.type', ':type'),
+                    $q->expr()->isNull('e.deleted'),
+                    $q->expr()->eq('IDENTITY(l.lead)', ':contactId'),
+                    $q->expr()->eq('l.manuallyRemoved', 0),
+                    $q->expr()->notIn('e.id', $eventQb->getDQL()),
+                    $q->expr()->orX(
+                        $q->expr()->isNull('e.parent'),
+                        $q->expr()->exists($parentQb->getDQL())
+                    )
+                )
+            )
+            ->setParameter('type', $type)
+            ->setParameter('contactId', (int) $contactId);
+        return $q->getQuery()->getResult();
+    }
+    /**
+     * Get array of events by parent.
+     *
+     * @param int         $parentId
+     * @param string|null $decisionPath
+     * @param string|null $eventType
+     *
+     * @return array
+     */
+    public function getEventsByParent($parentId, $decisionPath = null, $eventType = null)
+    {
+        $q = $this->getEntityManager()->createQueryBuilder();
+        $q->select('e')
+            ->from(Event::class, 'e', 'e.id')
+            ->where(
+                $q->expr()->eq('IDENTITY(e.parent)', (int) $parentId)
+            );
+        if (null !== $decisionPath) {
+            $q->andWhere(
+                $q->expr()->eq('e.decisionPath', ':decisionPath')
+            )
+                ->setParameter('decisionPath', $decisionPath);
+        }
+        if (null !== $eventType) {
+            $q->andWhere(
+                $q->expr()->eq('e.eventType', ':eventType')
+            )
+              ->setParameter('eventType', $eventType);
+        }
+        return $q->getQuery()->getArrayResult();
+    }
+    /**
+     * @param int  $campaignId
+     * @param bool $ignoreDeleted
+     *
+     * @return array<int,mixed[]>
+     */
+    public function getCampaignEvents($campaignId, $ignoreDeleted = true): array
+    {
+        $q = $this->getEntityManager()->createQueryBuilder();
+        $q->select('e, IDENTITY(e.parent)')
+            ->from(Event::class, 'e', 'e.id')
+            ->where(
+                $q->expr()->eq('IDENTITY(e.campaign)', (int) $campaignId)
+            )
+            ->orderBy('e.order', Order::Ascending->value);
+        if ($ignoreDeleted) {
+            $q->andWhere($q->expr()->isNull('e.deleted'));
+        }
+        $results = $q->getQuery()->getArrayResult();
+        $events = [];
+        foreach ($results as $id => $r) {
+            $r[0]['parent_id'] = $r[1];
+            $events[$id]       = $r[0];
+        }
+        unset($results);
+        return $events;
+    }
+    /**
+     * @return string[]
+     */
+    public function getCampaignEventIds(int $campaignId): array
+    {
+        $q = $this->getEntityManager()->getConnection()->createQueryBuilder();
+        $q->select('e.id')
+            ->from(MAUTIC_TABLE_PREFIX.Event::TABLE_NAME, 'e')
+            ->where($q->expr()->eq('e.campaign_id', $campaignId));
+        return array_column($q->executeQuery()->fetchAllAssociative(), 'id');
+    }
+    /**
+     * Get array of events with stats.
+     *
+     * @param array $args
+     *
+     * @return array
+     */
+    public function getEvents($args = [])
+    {
+        $q = $this->createQueryBuilder('e')
+            ->select('e, ec, ep')
+            ->join('e.campaign', 'c')
+            ->leftJoin('e.children', 'ec')
+            ->leftJoin('e.parent', 'ep')
+            ->orderBy('e.order');
+        if (!empty($args['campaigns'])) {
+            $q->andWhere($q->expr()->in('e.campaign', ':campaigns'))
+                ->setParameter('campaigns', $args['campaigns']);
+        }
+        if (isset($args['positivePathOnly'])) {
+            $q->andWhere(
+                $q->expr()->orX(
+                    $q->expr()->neq(
+                        'e.decisionPath',
+                        $q->expr()->literal('no')
+                    ),
+                    $q->expr()->isNull('e.decisionPath')
+                )
+            );
+        }
+        return $q->getQuery()->getArrayResult();
+    }
+    /**
+     * Null event parents in preparation for deleI'lting a campaign.
+     *
+     * @param int $campaignId
+     */
+    public function nullEventParents($campaignId): void
+    {
+        $this->getEntityManager()->getConnection()->update(
+            MAUTIC_TABLE_PREFIX.'campaign_events',
+            ['parent_id'   => null],
+            ['campaign_id' => (int) $campaignId]
+        );
+    }
+    /**
+     * Null event parents in preparation for deleting events from a campaign.
+     *
+     * @param string[] $events
+     */
+    public function nullEventRelationships($events): void
+    {
+        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
+        $qb->update(MAUTIC_TABLE_PREFIX.'campaign_events')
+            ->set('parent_id', ':null')
+            ->setParameter('null', null)
+            ->where(
+                $qb->expr()->in('parent_id', $events)
+            )
+            ->executeStatement();
+    }
+    /**
+     * @param string[] $eventIds
+     */
+    public function deleteEvents(array $eventIds): void
+    {
+        $qb = $this->getEntityManager()->createQueryBuilder();
+        $qb->delete(Event::class, 'e')
+            ->where($qb->expr()->in('e.id', ':event_ids'))
+            ->setParameter('event_ids', $eventIds, ArrayParameterType::INTEGER)
+            ->getQuery()
+            ->execute();
+    }
+    /**
+     * @param string[] $eventIds
+     */
+    public function setEventsAsDeleted(array $eventIds): void
+    {
+        $dateTime = (new \DateTime())->format('Y-m-d H:i:s');
+        $qb       = $this->getEntityManager()->getConnection()->createQueryBuilder();
+        $qb->update(MAUTIC_TABLE_PREFIX.Event::TABLE_NAME)
+            ->set('deleted', ':deleted')
+            ->setParameter('deleted', $dateTime)
+            ->where(
+                $qb->expr()->in('id', $eventIds)
+            )
+            ->executeStatement();
+    }
+    public function getTableAlias(): string
+    {
+        return 'e';
+    }
+    /**
+     * For the API.
+     *
+     * @return string[]
+     */
+    public function getSearchCommands(): array
+    {
+        return $this->getStandardSearchCommands();
+    }
+    /**
+     * Get an array of events that have been triggered by this lead.
+     */
+    public function getLeadTriggeredEvents($leadId): array
+    {
+        $q = $this->getEntityManager()->createQueryBuilder()
+            ->select('e, c, l')
+            ->from(Event::class, 'e')
+            ->join('e.campaign', 'c')
+            ->join('e.log', 'l');
+        $q->where($q->expr()->eq('IDENTITY(l.lead)', (int) $leadId));
+        $results = $q->getQuery()->getArrayResult();
+        $return = [];
+        foreach ($results as $r) {
+            $return[$r['id']] = $r;
+        }
+        return $return;
+    }
+    /**
+     * {@inheritdoc}
+     *
+     * For the API
+     */
+    protected function addCatchAllWhereClause($q, $filter): array
+    {
+        return $this->addStandardCatchAllWhereClause(
+            $q,
+            $filter,
+            [
+                $this->getTableAlias().'.name',
+            ]
+        );
+    }
+    /**
+     * {@inheritdoc}
+     *
+     * For the API
+     */
+    protected function addSearchCommandWhereClause($q, $filter): array
+    {
+        return $this->addStandardSearchCommandWhereClause($q, $filter);
+    }
+    /**
+     * Update the failed count using DBAL to avoid
+     * race conditions and deadlocks.
+     */
+    public function incrementFailedCount(Event $event): int
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
+            ->set('failed_count', 'failed_count + 1')
+            ->where($q->expr()->eq('id', ':id'))
+            ->setParameter('id', $event->getId());
+        $q->executeStatement();
+        return $this->getFailedCount($event);
+    }
+    /**
+     * Update the failed count using DBAL to avoid
+     * race conditions and deadlocks.
+     */
+    public function decreaseFailedCount(Event $event): void
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
+            ->set('failed_count', 'failed_count - 1')
+            ->where($q->expr()->eq('id', ':id'))
+            ->andWhere($q->expr()->gt('failed_count', 0))
+            ->setParameter('id', $event->getId());
+        $q->executeStatement();
+    }
+    /**
+     * Get the up to date failed count
+     * for the given Event.
+     */
+    public function getFailedCount(Event $event): int
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->select('failed_count')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_events')
+            ->where($q->expr()->eq('id', ':id'))
+            ->setParameter('id', $event->getId());
+        return (int) $q->executeQuery()->fetchOne();
+    }
+    /**
+     * Reset the failed_count's for all events
+     * within the given Campaign.
+     */
+    public function resetFailedCountsForEventsInCampaign(Campaign $campaign): void
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
+            ->set('failed_count', ':failedCount')
+            ->where($q->expr()->eq('campaign_id', ':campaignId'))
+            ->setParameter('failedCount', 0)
+            ->setParameter('campaignId', $campaign->getId());
+        $q->executeStatement();
+    }
+    /**
+     * Get the count of failed event for Lead/Event.
+     */
+    public function getFailedCountLeadEvent(int $leadId, int $eventId): int
+    {
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->select('count(le.id)')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'le')
+            ->innerJoin('le', MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fle', 'le.id = fle.log_id')
+            ->where('le.lead_id = :leadId')
+            ->andWhere('le.event_id = :eventId')
+            ->setParameters(['leadId' => $leadId, 'eventId' => $eventId]);
+        return (int) $q->executeQuery()->fetchOne();
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Entity/LeadEventLogRepository.php
@@ -0,0 +1,567 @@
+<?php
+namespace Mautic\CampaignBundle\Entity;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\DBAL\ArrayParameterType;
+use Doctrine\DBAL\Cache\QueryCacheProfile;
+use Doctrine\DBAL\Types\Types;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CoreBundle\Entity\CommonRepository;
+use Mautic\CoreBundle\Helper\Chart\ChartQuery;
+use Mautic\LeadBundle\Entity\TimelineTrait;
+/**
+ * @extends CommonRepository<LeadEventLog>
+ */
+class LeadEventLogRepository extends CommonRepository
+{
+    use TimelineTrait;
+    use ContactLimiterTrait;
+    use ReplicaConnectionTrait;
+    public const LOG_DELETE_BATCH_SIZE = 5000;
+    public function getEntities(array $args = [])
+    {
+        $alias = $this->getTableAlias();
+        $q     = $this
+            ->createQueryBuilder($alias)
+            ->join($alias.'.ipAddress', 'i');
+        if (empty($args['campaign_id'])) {
+            $q->join($alias.'.event', 'e')
+                ->join($alias.'.campaign', 'c');
+        } else {
+            $q->andWhere(
+                $q->expr()->eq('IDENTITY('.$this->getTableAlias().'.campaign)', (int) $args['campaign_id'])
+            );
+        }
+        if (!empty($args['contact_id'])) {
+            $q->andWhere(
+                $q->expr()->eq('IDENTITY('.$this->getTableAlias().'.lead)', (int) $args['contact_id'])
+            );
+        }
+        $args['qb'] = $q;
+        return parent::getEntities($args);
+    }
+    public function getTableAlias(): string
+    {
+        return 'll';
+    }
+    /**
+     * Get a lead's page event log.
+     *
+     * @param int|null $leadId
+     *
+     * @return array
+     */
+    public function getLeadLogs($leadId = null, array $options = [])
+    {
+        $query = $this->getEntityManager()
+                      ->getConnection()
+                      ->createQueryBuilder()
+                      ->select('ll.id as log_id,
+                    ll.event_id,
+                    ll.campaign_id,
+                    ll.date_triggered as dateTriggered,
+                    e.name AS event_name,
+                    e.description AS event_description,
+                    e.parent_id AS parent_id,
+                    e.decision_path AS decision_path,
+                    c.name AS campaign_name,
+                    c.description AS campaign_description,
+                    ll.metadata,
+                    e.type,
+                    ll.is_scheduled as isScheduled,
+                    ll.trigger_date as triggerDate,
+                    ll.channel,
+                    ll.channel_id as channel_id,
+                    ll.lead_id,
+                    fl.reason as fail_reason
+                    '
+                      )
+                        ->add('from', [
+                            'table' => MAUTIC_TABLE_PREFIX.'campaign_lead_event_log',
+                            'alias' => 'll',
+                            'hint'  => 'USE INDEX ('.MAUTIC_TABLE_PREFIX.'campaign_date_triggered)',
+                        ], true)
+                        ->join('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'll.event_id = e.id')
+                        ->join('ll', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'll.campaign_id = c.id')
+                        ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fl', 'fl.log_id = ll.id')
+                        ->andWhere('e.event_type != :eventType')
+                        ->setParameter('eventType', 'decision');
+        if ($leadId) {
+            $query->where('ll.lead_id = '.(int) $leadId);
+        }
+        if (isset($options['scheduledState'])) {
+            if ($options['scheduledState']) {
+                $query->andWhere(
+                    $query->expr()->or(
+                        $query->expr()->eq('ll.is_scheduled', ':scheduled'),
+                        $query->expr()->and(
+                            $query->expr()->eq('ll.is_scheduled', 0),
+                            $query->expr()->isNull('ll.date_triggered')
+                        )
+                    )
+                );
+            } else {
+                $query->andWhere(
+                    $query->expr()->eq('ll.is_scheduled', ':scheduled')
+                );
+            }
+            $query->setParameter('scheduled', $options['scheduledState'], 'boolean');
+        }
+        if (isset($options['search']) && $options['search']) {
+            $query->andWhere(
+                $query->expr()->or(
+                    $query->expr()->like('e.name', $query->expr()->literal('%'.$options['search'].'%')),
+                    $query->expr()->like('e.description', $query->expr()->literal('%'.$options['search'].'%')),
+                    $query->expr()->like('c.name', $query->expr()->literal('%'.$options['search'].'%')),
+                    $query->expr()->like('c.description', $query->expr()->literal('%'.$options['search'].'%'))
+                )
+            );
+        }
+        return $this->getTimelineResults($query, $options, 'e.name', 'll.date_triggered', ['metadata'], ['dateTriggered', 'triggerDate'], null, 'll.id');
+    }
+    /**
+     * Get a lead's upcoming events.
+     */
+    public function getUpcomingEvents(array $options = null): array
+    {
+        $leadIps = [];
+        $query = $this->_em->getConnection()->createQueryBuilder();
+        $query->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'll')
+            ->select('ll.event_id,
+                    ll.campaign_id,
+                    ll.trigger_date,
+                    ll.lead_id,
+                    e.name AS event_name,
+                    e.description AS event_description,
+                    c.name AS campaign_name,
+                    c.description AS campaign_description,
+                    ll.metadata,
+                    CONCAT(CONCAT(l.firstname, \' \'), l.lastname) AS lead_name')
+            ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = ll.event_id')
+            ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = e.campaign_id')
+            ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'leads', 'l', 'l.id = ll.lead_id')
+            ->where($query->expr()->eq('ll.is_scheduled', 1));
+        if (isset($options['lead'])) {
+            /** @var \Mautic\CoreBundle\Entity\IpAddress $ip */
+            foreach ($options['lead']->getIpAddresses() as $ip) {
+                $leadIps[] = $ip->getId();
+            }
+            $query->andWhere('ll.lead_id = :leadId')
+                ->setParameter('leadId', $options['lead']->getId());
+        }
+        if (isset($options['type'])) {
+            $query->andwhere('e.type = :type')
+                  ->setParameter('type', $options['type']);
+        }
+        if (isset($options['eventType'])) {
+            if (is_array($options['eventType'])) {
+                $query->andWhere(
+                    $query->expr()->in('e.event_type', array_map([$query->expr(), 'literal'], $options['eventType']))
+                );
+            } else {
+                $query->andwhere('e.event_type = :eventTypes')
+                    ->setParameter('eventTypes', $options['eventType']);
+            }
+        }
+        if (isset($options['limit'])) {
+            $query->setMaxResults($options['limit']);
+        } else {
+            $query->setMaxResults(10);
+        }
+        $query->orderBy('ll.trigger_date');
+        if (empty($options['canViewOthers']) && isset($this->currentUser)) {
+            $query->andWhere('c.created_by = :userId')
+                ->setParameter('userId', $this->currentUser->getId());
+        }
+        return $query->executeQuery()->fetchAllAssociative();
+    }
+    /**
+     * @param int  $campaignId
+     * @param bool $excludeScheduled
+     * @param bool $excludeNegative
+     * @param bool $all
+     *
+     * @throws \Doctrine\DBAL\Cache\CacheException
+     */
+    public function getCampaignLogCounts(
+        $campaignId,
+        $excludeScheduled = false,
+        $excludeNegative = true,
+        $all = false,
+        \DateTimeInterface $dateFrom = null,
+        \DateTimeInterface $dateTo = null,
+        int $eventId = null,
+    ): array {
+        $join = $all ? 'leftJoin' : 'innerJoin';
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'o');
+        $q->$join(
+            'o',
+            MAUTIC_TABLE_PREFIX.'campaign_leads',
+            'l',
+            'l.campaign_id = '.(int) $campaignId.' and l.manually_removed = 0 and o.lead_id = l.lead_id and l.rotation = o.rotation'
+        );
+        $expr = $q->expr()->and(
+            $q->expr()->eq('o.campaign_id', (int) $campaignId)
+        );
+        if ($eventId) {
+            $expr = $expr->with(
+                $q->expr()->eq('o.event_id', $eventId)
+            );
+        }
+        $groupBy = 'o.event_id';
+        if ($excludeNegative) {
+            $q->select('o.event_id, count(o.lead_id) as lead_count');
+            $expr = $expr->with(
+                $q->expr()->or(
+                    $q->expr()->isNull('o.non_action_path_taken'),
+                    $q->expr()->eq('o.non_action_path_taken', ':false')
+                )
+            );
+        } else {
+            $q->select('o.event_id, count(o.lead_id) as lead_count, o.non_action_path_taken');
+            $groupBy .= ', o.non_action_path_taken';
+        }
+        if ($excludeScheduled) {
+            $expr = $expr->with(
+                $q->expr()->eq('o.is_scheduled', ':false')
+            );
+        }
+        $failedSq = $this->getReplicaConnection()->createQueryBuilder();
+        $failedSq->select('null')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fe')
+            ->where(
+                $failedSq->expr()->eq('fe.log_id', 'o.id')
+            );
+        if ($dateFrom && $dateTo) {
+            $failedSq->andWhere('fe.date_added BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
+                ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
+                ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
+        }
+        $expr = $expr->with(
+            sprintf('NOT EXISTS (%s)', $failedSq->getSQL())
+        );
+        $q->where($expr)
+          ->setParameter('false', false, 'boolean')
+          ->groupBy($groupBy);
+        if ($dateFrom && $dateTo) {
+            $q->andWhere('o.date_triggered BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
+                ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
+                ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
+        }
+        if ($this->_em->getConnection()->getConfiguration()->getResultCache()) {
+            $results = $this->_em->getConnection()->executeCacheQuery(
+                $q->getSQL(),
+                $q->getParameters(),
+                $q->getParameterTypes(),
+                new QueryCacheProfile(600)
+            )->fetchAllAssociative();
+        } else {
+            $results = $q->executeQuery()->fetchAllAssociative();
+        }
+        $return = [];
+        foreach ($results as $l) {
+            if (!$excludeNegative) {
+                if (!isset($return[$l['event_id']])) {
+                    $return[$l['event_id']] = [
+                        0 => 0,
+                        1 => 0,
+                    ];
+                }
+                $key                          = (int) $l['non_action_path_taken'] ? 0 : 1;
+                $return[$l['event_id']][$key] = (int) $l['lead_count'];
+            } else {
+                $return[$l['event_id']] = (int) $l['lead_count'];
+            }
+        }
+        return $return;
+    }
+    /**
+     * Updates lead ID (e.g. after a lead merge).
+     */
+    public function updateLead($fromLeadId, $toLeadId): void
+    {
+        $results = $this->_em->getConnection()->createQueryBuilder()
+            ->select('cl.event_id')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'cl')
+            ->where('cl.lead_id = '.$toLeadId)
+            ->executeQuery()
+            ->fetchAllAssociative();
+        $exists = [];
+        foreach ($results as $r) {
+            $exists[] = $r['event_id'];
+        }
+        $q = $this->_em->getConnection()->createQueryBuilder();
+        $q->update(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
+            ->set('lead_id', (int) $toLeadId)
+            ->where('lead_id = '.(int) $fromLeadId);
+        if (!empty($exists)) {
+            $q->andWhere(
+                $q->expr()->notIn('event_id', $exists)
+            )->executeStatement();
+            $this->_em->getConnection()->createQueryBuilder()
+                ->delete(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
+                ->where('lead_id = '.(int) $fromLeadId)
+                ->executeStatement();
+        } else {
+            $q->executeStatement();
+        }
+    }
+    public function getChartQuery($options): array
+    {
+        $chartQuery = new ChartQuery($this->getReplicaConnection(), $options['dateFrom'], $options['dateTo']);
+        $query = $this->getReplicaConnection()->createQueryBuilder();
+        $query->select('ll.id, ll.date_triggered')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'll')
+            ->join('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = ll.event_id');
+        if (isset($options['channel'])) {
+            $query->andwhere("e.channel = '".$options['channel']."'");
+        }
+        if (isset($options['channelId'])) {
+            $query->andwhere('e.channel_id = '.(int) $options['channelId']);
+        }
+        if (isset($options['type'])) {
+            $query->andwhere("e.type = '".$options['type']."'");
+        }
+        if (isset($options['logChannel'])) {
+            $query->andwhere("ll.channel = '".$options['logChannel']."'");
+        }
+        if (isset($options['logChannelId'])) {
+            $query->andwhere('ll.channel_id = '.(int) $options['logChannelId']);
+        }
+        if (!isset($options['is_scheduled'])) {
+            $query->andWhere($query->expr()->eq('ll.is_scheduled', 0));
+        } else {
+            $query->andWhere($query->expr()->eq('ll.is_scheduled', 1));
+        }
+        return $chartQuery->fetchTimeData('('.$query.')', 'date_triggered');
+    }
+    /**
+     * @param int $eventId
+     *
+     * @return ArrayCollection
+     *
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    public function getScheduled($eventId, \DateTime $now, ContactLimiter $limiter)
+    {
+        if ($limiter->hasCampaignLimit() && 0 === $limiter->getCampaignLimitRemaining()) {
+            return new ArrayCollection();
+        }
+        $this->getReplicaConnection($limiter);
+        $q = $this->createQueryBuilder('o');
+        $q->select('o, e, c')
+            ->indexBy('o', 'o.id')
+            ->innerJoin('o.event', 'e')
+            ->innerJoin('e.campaign', 'c')
+            ->where(
+                $q->expr()->andX(
+                    $q->expr()->eq('IDENTITY(o.event)', ':eventId'),
+                    $q->expr()->eq('o.isScheduled', ':true'),
+                    $q->expr()->lte('o.triggerDate', ':now'),
+                    $q->expr()->eq('c.isPublished', 1)
+                )
+            )
+            ->setParameter('eventId', (int) $eventId)
+            ->setParameter('now', $now)
+            ->setParameter('true', true, Types::BOOLEAN);
+        $this->updateOrmQueryFromContactLimiter('o', $q, $limiter);
+        if ($limiter->hasCampaignLimit() && $limiter->getCampaignLimitRemaining() < $limiter->getBatchLimit()) {
+            $q->setMaxResults($limiter->getCampaignLimitRemaining());
+        }
+        $result = new ArrayCollection($q->getQuery()->getResult());
+        if ($limiter->hasCampaignLimit()) {
+            $limiter->reduceCampaignLimitRemaining($result->count());
+        }
+        return $result;
+    }
+    /**
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    public function getScheduledByIds(array $ids): ArrayCollection
+    {
+        $this->getReplicaConnection();
+        $q = $this->createQueryBuilder('o');
+        $q->select('o, e, c')
+            ->indexBy('o', 'o.id')
+            ->innerJoin('o.event', 'e')
+            ->innerJoin('e.campaign', 'c')
+            ->where(
+                $q->expr()->andX(
+                    $q->expr()->in('o.id', $ids),
+                    $q->expr()->eq('o.isScheduled', 1),
+                    $q->expr()->eq('c.isPublished', 1),
+                    $q->expr()->isNull('c.deleted'),
+                    $q->expr()->isNull('e.deleted')
+                )
+            );
+        return new ArrayCollection($q->getQuery()->getResult());
+    }
+    /**
+     * @param int $campaignId
+     */
+    public function getScheduledCounts($campaignId, \DateTime $date, ContactLimiter $limiter): array
+    {
+        $now = clone $date;
+        $now->setTimezone(new \DateTimeZone('UTC'));
+        $q = $this->getReplicaConnection($limiter)->createQueryBuilder();
+        $expr = $q->expr()->and(
+            $q->expr()->eq('l.campaign_id', ':campaignId'),
+            $q->expr()->eq('l.is_scheduled', ':true'),
+            $q->expr()->lte('l.trigger_date', ':now'),
+            $q->expr()->eq('c.is_published', 1)
+        );
+        $this->updateQueryFromContactLimiter('l', $q, $limiter, true);
+        $results = $q->select('COUNT(*) as event_count, l.event_id')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'l')
+            ->join('l', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'l.campaign_id = c.id')
+            ->where($expr)
+            ->setParameter('campaignId', (int) $campaignId)
+            ->setParameter('now', $now->format('Y-m-d H:i:s'))
+            ->setParameter('true', true, \PDO::PARAM_BOOL)
+            ->groupBy('l.event_id')
+            ->executeQuery()
+            ->fetchAllAssociative();
+        $events = [];
+        foreach ($results as $result) {
+            $events[$result['event_id']] = (int) $result['event_count'];
+        }
+        return $events;
+    }
+    public function getDatesExecuted($eventId, array $contactIds): array
+    {
+        $qb = $this->getReplicaConnection()->createQueryBuilder();
+        $qb->select('log.lead_id, log.date_triggered, log.is_scheduled')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
+            ->where(
+                $qb->expr()->and(
+                    $qb->expr()->eq('log.event_id', $eventId),
+                    $qb->expr()->in('log.lead_id', $contactIds)
+                )
+            );
+        $results = $qb->executeQuery()->fetchAllAssociative();
+        $dates = [];
+        foreach ($results as $result) {
+            $dates[$result['lead_id']] = new \DateTime($result['date_triggered'], new \DateTimeZone('UTC'));
+            if (1 === (int) $result['is_scheduled']) {
+                unset($dates[$result['lead_id']]);
+            }
+        }
+        return $dates;
+    }
+    public function getOldestTriggeredDate(): ?\DateTime
+    {
+        $qb = $this->getReplicaConnection()->createQueryBuilder();
+        $qb->select('log.date_triggered')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
+            ->orderBy('log.date_triggered', 'ASC')
+            ->setMaxResults(1);
+        $results = $qb->executeQuery()->fetchAllAssociative();
+        return isset($results[0]['date_triggered']) ? new \DateTime($results[0]['date_triggered']) : null;
+    }
+    /**
+     * @param int $contactId
+     * @param int $campaignId
+     * @param int $rotation
+     */
+    public function hasBeenInCampaignRotation($contactId, $campaignId, $rotation): bool
+    {
+        $qb = $this->getReplicaConnection()->createQueryBuilder();
+        $qb->select('log.rotation')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
+            ->where(
+                $qb->expr()->and(
+                    $qb->expr()->eq('log.lead_id', ':contactId'),
+                    $qb->expr()->eq('log.campaign_id', ':campaignId'),
+                    $qb->expr()->in('log.rotation', ':rotation')
+                )
+            )
+            ->setParameter('contactId', (int) $contactId)
+            ->setParameter('campaignId', (int) $campaignId)
+            ->setParameter('rotation', (int) $rotation)
+            ->setMaxResults(1);
+        $results = $qb->executeQuery()->fetchAllAssociative();
+        return !empty($results);
+    }
+    /**
+     * @param string $message
+     *
+     * @throws \Doctrine\DBAL\Exception
+     */
+    public function unscheduleEvents(Lead $campaignMember, $message): void
+    {
+        $contactId  = $campaignMember->getLead()->getId();
+        $campaignId = $campaignMember->getCampaign()->getId();
+        $rotation   = $campaignMember->getRotation();
+        $dateAdded  = (new \DateTime('now', new \DateTimeZone('UTC')))->format('Y-m-d H:i:s');
+        $prefix = MAUTIC_TABLE_PREFIX;
+        $sql    = <<<SQL
+REPLACE INTO {$prefix}campaign_lead_event_failed_log( `log_id`, `date_added`, `reason`)
+SELECT id, :dateAdded as date_added, :message as reason from {$prefix}campaign_lead_event_log
+WHERE is_scheduled = 1 AND lead_id = :contactId AND campaign_id = :campaignId AND rotation = :rotation
+SQL;
+        $connection = $this->getEntityManager()->getConnection();
+        $stmt       = $connection->prepare($sql);
+        $stmt->bindValue('dateAdded', $dateAdded, \PDO::PARAM_STR);
+        $stmt->bindValue('message', $message, \PDO::PARAM_STR);
+        $stmt->bindValue('contactId', $contactId, \PDO::PARAM_INT);
+        $stmt->bindValue('campaignId', $campaignId, \PDO::PARAM_INT);
+        $stmt->bindValue('rotation', $rotation, \PDO::PARAM_INT);
+        $stmt->executeStatement();
+        $qb = $connection->createQueryBuilder();
+        $qb->update(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
+            ->set('is_scheduled', 0)
+            ->where(
+                $qb->expr()->and(
+                    $qb->expr()->eq('is_scheduled', 1),
+                    $qb->expr()->eq('lead_id', ':contactId'),
+                    $qb->expr()->eq('campaign_id', ':campaignId'),
+                    $qb->expr()->eq('rotation', ':rotation')
+                )
+            )
+            ->setParameters(
+                [
+                    'contactId'     => (int) $contactId,
+                    'campaignId'    => (int) $campaignId,
+                    'rotation'      => (int) $rotation,
+                ]
+            )
+            ->executeStatement();
+    }
+    public function removeEventLogsByCampaignId(int $campaignId): void
+    {
+        $table_name    = $this->getTableName();
+        $sql           = "DELETE FROM {$table_name} WHERE campaign_id = (?) LIMIT ".self::LOG_DELETE_BATCH_SIZE;
+        $conn          = $this->getEntityManager()->getConnection();
+        $deleteEntries = true;
+        while ($deleteEntries) {
+            $deleteEntries = $conn->executeQuery($sql, [$campaignId], [Types::INTEGER])->rowCount();
+        }
+    }
+    /**
+     * @param string[] $eventIds
+     */
+    public function removeEventLogs(array $eventIds): void
+    {
+        $table_name    = $this->getTableName();
+        $sql           = "DELETE FROM {$table_name} WHERE event_id IN (?) ORDER BY event_id ASC LIMIT ".self::LOG_DELETE_BATCH_SIZE;
+        $conn          = $this->getEntityManager()->getConnection();
+        $deleteEntries = true;
+        while ($deleteEntries) {
+            $deleteEntries = $conn->executeQuery($sql, [$eventIds], [ArrayParameterType::INTEGER])->rowCount();
+        }
+    }
+    /**
+     * Check if last lead/event failed.
+     *
+     * @throws \Doctrine\ORM\NonUniqueResultException
+     */
+    public function isLastFailed(int $leadId, int $eventId): bool
+    {
+        /** @var LeadEventLog $log */
+        $log = $this->findOneBy(['lead' => $leadId, 'event' => $eventId], ['dateTriggered' => 'DESC']);
+        if (null !== $log && null !== $log->getFailedLog()) {
+            return true;
+        }
+        return false;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Entity/SummaryRepository.php
@@ -0,0 +1,121 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Entity;
+use Mautic\CoreBundle\Entity\CommonRepository;
+use Mautic\LeadBundle\Entity\TimelineTrait;
+/**
+ * @extends CommonRepository<Summary>
+ */
+class SummaryRepository extends CommonRepository
+{
+    use TimelineTrait;
+    use ContactLimiterTrait;
+    public function getTableAlias(): string
+    {
+        return 's';
+    }
+    /**
+     * @return array<int|string, array<int|string, int|string>>
+     */
+    public function getCampaignLogCounts(
+        int $campaignId,
+        \DateTimeInterface $dateFrom = null,
+        \DateTimeInterface $dateTo = null,
+    ): array {
+        $q = $this->_em->getConnection()->createQueryBuilder()
+            ->select(
+                [
+                    'cs.event_id',
+                    'SUM(cs.scheduled_count) as scheduled_count',
+                    'SUM(cs.triggered_count) as triggered_count',
+                    'SUM(cs.non_action_path_taken_count) as non_action_path_taken_count',
+                    'SUM(cs.failed_count) as failed_count',
+                    'SUM(cs.log_counts_processed) as log_counts_processed',
+                ]
+            )
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_summary', 'cs')
+            ->where('cs.campaign_id = '.(int) $campaignId)
+            ->groupBy('cs.event_id');
+        if ($dateFrom && $dateTo) {
+            $q->andWhere('cs.date_triggered BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
+                ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
+                ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
+        }
+        $results = $q->executeQuery()->fetchAllAssociative();
+        $return = [];
+        foreach ($results as $row) {
+            $return[$row['event_id']] = [
+                0 => (int) $row['non_action_path_taken_count'],
+                1 => (int) $row['triggered_count'] + (int) $row['scheduled_count'],
+                2 => (int) $row['log_counts_processed'],
+            ];
+        }
+        return $return;
+    }
+    /**
+     * Get the oldest triggered time for back-filling historical data.
+     */
+    public function getOldestTriggeredDate(): ?\DateTimeInterface
+    {
+        $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
+        $qb->select('cs.date_triggered')
+            ->from(MAUTIC_TABLE_PREFIX.'campaign_summary', 'cs')
+            ->orderBy('cs.date_triggered', 'ASC')
+            ->setMaxResults(1);
+        $results = $qb->executeQuery()->fetchAllAssociative();
+        return isset($results[0]['date_triggered']) ? new \DateTime($results[0]['date_triggered']) : null;
+    }
+    /**
+     * Regenerate summary entries for a given time frame.
+     *
+     * @throws \Doctrine\DBAL\Exception
+     */
+    public function summarize(
+        \DateTimeInterface $dateFrom,
+        \DateTimeInterface $dateTo,
+        int $campaignId = null,
+        int $eventId = null,
+    ): void {
+        $dateFromTsActual = $dateFrom->getTimestamp();
+        $dateToTsActual   = $dateTo->getTimestamp();
+        $intervalInSeconds= 3600;
+        $dateFromStartWithZeroMinutes = $dateFromTsActual - ($dateFromTsActual % $intervalInSeconds);
+        $numberOfIntervals            = ceil(($dateToTsActual - $dateFromStartWithZeroMinutes) / $intervalInSeconds);
+        for ($interval = 0; $interval < $numberOfIntervals; ++$interval) {
+            $dateFromTs = date('Y-m-d H:i:s', $dateFromStartWithZeroMinutes + ($interval * $intervalInSeconds));
+            $dateToTs   = date('Y-m-d H:i:s', strtotime($dateFromTs) + ($intervalInSeconds - 1));
+            $sql = 'INSERT INTO '.MAUTIC_TABLE_PREFIX.'campaign_summary '.
+            ' (campaign_id, event_id, date_triggered, scheduled_count, non_action_path_taken_count, failed_count, triggered_count, log_counts_processed) '.
+            ' SELECT * FROM (SELECT '.
+            '       mclel.campaign_id AS campaign_id, '.
+            '       mclel.event_id AS event_id, '.
+            '       "'.$dateFromTs.'" AS date_triggered_i, '.
+            '       SUM(IF(mclel.is_scheduled = 1 AND mclel.trigger_date > NOW(), 1, 0)) AS scheduled_count_i, '.
+            '       SUM(IF(mclel.is_scheduled = 1 AND mclel.trigger_date > NOW(), 0, mclel.non_action_path_taken)) AS non_action_path_taken_count_i, '.
+            '       SUM(IF((mclel.is_scheduled = 1 AND mclel.trigger_date > NOW()) OR mclel.non_action_path_taken, 0, mclefl.log_id IS NOT NULL)) AS failed_count_i, '.
+            '       SUM(IF((mclel.is_scheduled = 1 AND mclel.trigger_date > NOW()) OR mclel.non_action_path_taken OR mclefl.log_id IS NOT NULL, 0, 1)) AS triggered_count_i, '.
+            '       COUNT((SELECT mcl.campaign_id FROM '.MAUTIC_TABLE_PREFIX.'campaign_leads mcl '.
+            '           WHERE mcl.campaign_id = mclel.campaign_id AND mcl.manually_removed = 0 '.
+            '           AND mclel.lead_id = mcl.lead_id AND mcl.rotation = mclel.rotation '.
+            '           AND NOT EXISTS(SELECT NULL FROM '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log mclefl2 '.
+            '               WHERE mclefl2.log_id = mclel.id AND mclefl2.date_added BETWEEN "'.$dateFromTs.'" AND "'.$dateToTs.'")'.
+            '       )) AS log_counts_processed_i '.
+            ' FROM '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_log mclel LEFT JOIN '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log mclefl ON mclefl.log_id = mclel.id '.
+            ' WHERE (mclel.date_triggered BETWEEN "'.$dateFromTs.'" AND "'.$dateToTs.'") ';
+            if ($campaignId) {
+                $sql .= ' AND mclel.campaign_id = '.$campaignId;
+            }
+            if ($eventId) {
+                $sql .= ' AND mclel.event_id = '.$eventId;
+            }
+            $sql .= ' GROUP BY mclel.campaign_id, mclel.event_id) AS `s` '.
+            ' ON DUPLICATE KEY UPDATE '.
+            ' scheduled_count = s.scheduled_count_i, '.
+            ' non_action_path_taken_count = s.non_action_path_taken_count_i, '.
+            ' failed_count = s.failed_count_i, '.
+            ' triggered_count = s.triggered_count_i, '.
+            ' log_counts_processed = s.log_counts_processed_i;';
+            $this->getEntityManager()->getConnection()->executeQuery($sql);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/AbstractLogCollectionEvent.php
@@ -0,0 +1,100 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\LeadBundle\Entity\Lead;
+abstract class AbstractLogCollectionEvent extends \Symfony\Contracts\EventDispatcher\Event
+{
+    /**
+     * @var ArrayCollection
+     */
+    protected $logs;
+    /**
+     * @var ArrayCollection|Lead[]
+     */
+    private ArrayCollection $contacts;
+    private array $logContactXref = [];
+    public function __construct(
+        protected AbstractEventAccessor $config,
+        protected Event $event,
+        ArrayCollection $logs,
+    ) {
+        $this->logs     = $logs;
+        $this->contacts = new ArrayCollection();
+        $this->extractContacts();
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getConfig()
+    {
+        return $this->config;
+    }
+    /**
+     * @return Event
+     */
+    public function getEvent()
+    {
+        return $this->event;
+    }
+    /**
+     * Return an array of Lead entities keyed by LeadEventLog ID.
+     *
+     * @return Lead[]|ArrayCollection
+     */
+    public function getContacts()
+    {
+        return $this->contacts;
+    }
+    /**
+     * @return ArrayCollection
+     */
+    public function getContactsKeyedById()
+    {
+        $contacts = new ArrayCollection();
+        /** @var Lead $contact */
+        foreach ($this->contacts as $contact) {
+            $contacts->set($contact->getId(), $contact);
+        }
+        return $contacts;
+    }
+    /**
+     * Get the IDs of all contacts affected by this event.
+     *
+     * @return array
+     */
+    public function getContactIds()
+    {
+        $contactIds = array_keys($this->logContactXref);
+        return array_combine($contactIds, $contactIds);
+    }
+    /**
+     * @param int $id
+     *
+     * @return LeadEventLog
+     *
+     * @throws NoContactsFoundException
+     */
+    public function findLogByContactId($id)
+    {
+        if (!isset($this->logContactXref[$id])) {
+            throw new NoContactsFoundException("$id not found");
+        }
+        if (!$this->logs->offsetExists($this->logContactXref[$id])) {
+            throw new NoContactsFoundException("$id was found in the xref table but no log was found");
+        }
+        return $this->logs->get($this->logContactXref[$id]);
+    }
+    private function extractContacts(): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($this->logs as $log) {
+            $contact                                 = $log->getLead();
+            $this->logContactXref[$contact->getId()] = $log->getId();
+            $this->contacts->set($log->getId(), $contact);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignBuilderEvent.php
@@ -0,0 +1,170 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Event\Exception\KeyAlreadyRegisteredException;
+use Mautic\CoreBundle\Event\ComponentValidationTrait;
+use Symfony\Contracts\EventDispatcher\Event;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class CampaignBuilderEvent extends Event
+{
+    use ComponentValidationTrait;
+    private array $decisions = [];
+    private array $conditions = [];
+    private array $actions = [];
+    /**
+     * Holds info if some property has been already sorted or not.
+     */
+    private array $sortCache = [];
+    public function __construct(
+        private TranslatorInterface $translator,
+    ) {
+    }
+    /**
+     * Add an lead decision to the list of available .
+     *
+     * @param string $key      a unique identifier; it is recommended that it be namespaced i.e. lead.mytrigger
+     * @param array  $decision can contain the following keys:
+     *                         $decision = [
+     *                         'label'                   => (required) what to display in the list
+     *                         'eventName'               => (required) The event name to fire when this event is triggered.
+     *                         'description'             => (optional) short description of event
+     *                         'formType'                => (optional) name of the form type SERVICE for the action
+     *                         'formTypeOptions'         => (optional) array of options to pass to the formType service
+     *                         'formTheme'               => (optional) form theme
+     *                         'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
+     *                         [
+     *                         'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
+     *                         'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
+     *                         'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
+     *                         ]
+     *                         ]
+     */
+    public function addDecision($key, array $decision): void
+    {
+        if (array_key_exists($key, $this->decisions)) {
+            throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another contact action. Please use a different key.");
+        }
+        $this->verifyComponent(
+            ['label', ['eventName', 'callback']],
+            $decision,
+            ['callback']
+        );
+        $decision['label']       = $this->translator->trans($decision['label']);
+        $decision['description'] = (isset($decision['description'])) ? $this->translator->trans($decision['description']) : '';
+        $this->decisions[$key] = $decision;
+    }
+    /**
+     * @return mixed
+     */
+    public function getDecisions()
+    {
+        return $this->sort('decisions');
+    }
+    /**
+     * Add an lead condition to the list of available conditions.
+     *
+     * @param string $key   a unique identifier; it is recommended that it be namespaced i.e. lead.mytrigger
+     * @param array  $event can contain the following keys:
+     *                      $condition = [
+     *                      'label'                   => (required) what to display in the list
+     *                      'eventName'               => (required) The event name to fire when this event is triggered.
+     *                      'description'             => (optional) short description of event
+     *                      'formType'                => (optional) name of the form type SERVICE for the action
+     *                      'formTypeOptions'         => (optional) array of options to pass to the formType service
+     *                      'formTheme'               => (optional) form theme
+     *                      'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
+     *                      [
+     *                      'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
+     *                      'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
+     *                      'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
+     *                      ]
+     *                      ]
+     */
+    public function addCondition($key, array $event): void
+    {
+        if (array_key_exists($key, $this->conditions)) {
+            throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another contact action. Please use a different key.");
+        }
+        $this->verifyComponent(
+            ['label', ['eventName', 'callback']],
+            $event,
+            ['callback']
+        );
+        $event['label']       = $this->translator->trans($event['label']);
+        $event['description'] = (isset($event['description'])) ? $this->translator->trans($event['description']) : '';
+        $this->conditions[$key] = $event;
+    }
+    /**
+     * Get lead conditions.
+     *
+     * @return array
+     */
+    public function getConditions()
+    {
+        return $this->sort('conditions');
+    }
+    /**
+     * Add an action to the list of available .
+     *
+     * @param string $key    a unique identifier; it is recommended that it be namespaced i.e. lead.action
+     * @param array  $action can contain the following keys:
+     *                       $action = [
+     *                       'label'               => (required) what to display in the list
+     *                       'eventName'           => (required) The event to fire when this event is triggered.
+     *                       'description'         => (optional) short description of event
+     *                       'formType'            => (optional) name of the form type SERVICE for the action
+     *                       'formTypeOptions'     => (optional) array of options to pass to the formType service
+     *                       'formTheme'           => (optional) form theme
+     *                       'timelineTemplate'    => (optional) custom template for the lead timeline
+     *                       'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
+     *                       [
+     *                       'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
+     *                       'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
+     *                       'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
+     *                       ]
+     *                       ]
+     */
+    public function addAction($key, array $action): void
+    {
+        if (array_key_exists($key, $this->actions)) {
+            throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another action. Please use a different key.");
+        }
+        $this->verifyComponent(
+            ['label', ['batchEventName', 'eventName', 'callback']],
+            $action,
+            ['callback']
+        );
+        $action['label']       = $this->translator->trans($action['label']);
+        $action['description'] = (isset($action['description'])) ? $this->translator->trans($action['description']) : '';
+        $this->actions[$key] = $action;
+    }
+    /**
+     * Get actions.
+     *
+     * @return array
+     */
+    public function getActions()
+    {
+        return $this->sort('actions');
+    }
+    /**
+     * Sort internal actions, decisions and conditions arrays.
+     *
+     * @param string $property name
+     *
+     * @return array
+     */
+    protected function sort($property)
+    {
+        if (empty($this->sortCache[$property])) {
+            uasort(
+                $this->{$property},
+                fn ($a, $b): int => strnatcasecmp(
+                    $a['label'],
+                    $b['label']
+                )
+            );
+            $this->sortCache[$property] = true;
+        }
+        return $this->{$property};
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignDecisionEvent.php
@@ -0,0 +1,98 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @deprecated 2.13.0; to be removed in 3.0
+ */
+class CampaignDecisionEvent extends Event
+{
+    protected $decisionTriggered = false;
+    /**
+     * @param LeadEventLog[] $logs
+     */
+    public function __construct(
+        protected $lead,
+        protected $decisionType,
+        protected $decisionEventDetails,
+        protected $events,
+        protected $eventSettings,
+        protected $isRootLevel = false,
+        protected $logs = [],
+    ) {
+    }
+    /**
+     * @return mixed
+     */
+    public function getLead()
+    {
+        return $this->lead;
+    }
+    /**
+     * @return mixed
+     */
+    public function getEvents()
+    {
+        return $this->events;
+    }
+    /**
+     * @return mixed
+     */
+    public function getDecisionType()
+    {
+        return $this->decisionType;
+    }
+    /**
+     * @return mixed
+     */
+    public function getDecisionEventDetails()
+    {
+        return $this->decisionEventDetails;
+    }
+    /**
+     * @return bool
+     */
+    public function getEventSettings($eventType = null, $type = null)
+    {
+        if ($type) {
+            return (!empty($this->eventSettings[$eventType][$type])) ? $this->eventSettings[$eventType][$type] : false;
+        } elseif ($eventType) {
+            return (!empty($this->eventSettings[$eventType])) ? $this->eventSettings[$eventType] : false;
+        }
+        return $this->eventSettings;
+    }
+    /**
+     * Is the decision used as a root level event?
+     *
+     * @return bool
+     */
+    public function isRootLevel()
+    {
+        return $this->isRootLevel;
+    }
+    /**
+     * Set if the decision has already been triggered and if so, child events will be executed.
+     *
+     * @param bool|true $triggered
+     */
+    public function setDecisionAlreadyTriggered($triggered = true): void
+    {
+        $this->decisionTriggered = $triggered;
+    }
+    /**
+     * Returns if the decision has already been triggered.
+     *
+     * @return mixed
+     */
+    public function wasDecisionTriggered()
+    {
+        return $this->decisionTriggered;
+    }
+    /**
+     * @return array|LeadEventLog[]
+     */
+    public function getLogs()
+    {
+        return $this->logs;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignExecutionEvent.php
@@ -0,0 +1,203 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\LeadBundle\Entity\Lead;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @deprecated 2.13.0; to be removed in 3.0
+ */
+class CampaignExecutionEvent extends Event
+{
+    use EventArrayTrait;
+    use ContextTrait;
+    /**
+     * @var Lead
+     */
+    protected $lead;
+    /**
+     * @var array
+     */
+    protected $event;
+    /**
+     * @var array
+     */
+    protected $eventDetails;
+    /**
+     * @var bool
+     */
+    protected $systemTriggered;
+    /**
+     * @var array
+     */
+    protected $eventSettings;
+    /**
+     * @var bool
+     */
+    protected $logUpdatedByListener = false;
+    /**
+     * @var string
+     */
+    protected $channel;
+    /**
+     * @var int
+     */
+    protected $channelId;
+    /**
+     * @param bool|mixed[]|string|null $result
+     */
+    public function __construct(
+        array $args,
+        protected $result,
+        protected ?LeadEventLog $log = null,
+    ) {
+        $this->lead            = $args['lead'];
+        $this->event           = $args['event'];
+        $this->eventDetails    = $args['eventDetails'];
+        $this->systemTriggered = $args['systemTriggered'];
+        $this->eventSettings   = $args['eventSettings'];
+    }
+    /**
+     * @return Lead
+     */
+    public function getLead()
+    {
+        return $this->lead;
+    }
+    /**
+     * Returns array with lead fields and owner ID if exist.
+     *
+     * @return array
+     */
+    public function getLeadFields()
+    {
+        $lead         = $this->getLead();
+        $isLeadEntity = $lead instanceof Lead;
+        if (!$isLeadEntity && !is_array($lead)) {
+            $lead = [];
+        }
+        $leadFields             = $isLeadEntity ? $lead->getProfileFields() : $lead;
+        $leadFields['owner_id'] = $isLeadEntity && ($owner = $lead->getOwner()) ? $owner->getId() : 0;
+        return $leadFields;
+    }
+    /**
+     * @return array
+     */
+    public function getEvent()
+    {
+        return ($this->event instanceof \Mautic\CampaignBundle\Entity\Event) ? $this->getEventArray($this->event) : $this->event;
+    }
+    /**
+     * @return array
+     */
+    public function getConfig()
+    {
+        return $this->getEvent()['properties'];
+    }
+    /**
+     * @return array
+     */
+    public function getEventDetails()
+    {
+        return $this->eventDetails;
+    }
+    /**
+     * @return bool
+     */
+    public function getSystemTriggered()
+    {
+        return $this->systemTriggered;
+    }
+    /**
+     * @return bool|mixed[]|string|null
+     */
+    public function getResult()
+    {
+        return $this->result;
+    }
+    /**
+     * @param bool|mixed[]|string|null $result
+     *
+     * @return $this
+     */
+    public function setResult($result)
+    {
+        $this->result = $result;
+        return $this;
+    }
+    /**
+     * Set the result to failed.
+     *
+     * @param string|null $reason
+     *
+     * @return $this
+     */
+    public function setFailed($reason = null)
+    {
+        $this->result = [
+            'failed' => 1,
+            'reason' => $reason,
+        ];
+        return $this;
+    }
+    /**
+     * @return mixed
+     */
+    public function getEventSettings()
+    {
+        return $this->eventSettings;
+    }
+    /**
+     * Set a custom log entry to override auto-handling of the log entry.
+     *
+     * @return $this
+     */
+    public function setLogEntry(LeadEventLog $log)
+    {
+        $this->logUpdatedByListener = true;
+        $this->log                  = $log;
+        return $this;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLogEntry()
+    {
+        return $this->log;
+    }
+    /**
+     * Returns if a listener updated the log entry.
+     *
+     * @return bool
+     */
+    public function wasLogUpdatedByListener()
+    {
+        return $this->logUpdatedByListener;
+    }
+    /**
+     * @param string          $channel
+     * @param string|int|null $channelId
+     */
+    public function setChannel($channel, $channelId = null): void
+    {
+        if (null !== $this->log) {
+            $this->log->setChannel($channel);
+            $this->log->setChannelId($channelId);
+        }
+        $this->channel   = $channel;
+        $this->channelId = $channelId;
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannel()
+    {
+        return $this->channel;
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannelId()
+    {
+        return $this->channelId;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignLeadChangeEvent.php
@@ -0,0 +1,81 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\LeadBundle\Entity\Lead;
+use Symfony\Contracts\EventDispatcher\Event;
+class CampaignLeadChangeEvent extends Event
+{
+    /**
+     * @var ?Lead
+     */
+    private $lead;
+    /**
+     * @var Lead[]
+     */
+    private array $leads = [];
+    /**
+     * @param Lead|Lead[] $leads
+     * @param ?string     $action
+     */
+    public function __construct(
+        private Campaign $campaign,
+        $leads,
+        private $action,
+    ) {
+        if (is_array($leads)) {
+            $this->leads = $leads;
+        } else {
+            $this->lead = $leads;
+        }
+    }
+    /**
+     * Returns the Campaign entity.
+     *
+     * @return Campaign
+     */
+    public function getCampaign()
+    {
+        return $this->campaign;
+    }
+    /**
+     * Returns the Lead entity.
+     *
+     * @return Lead|null
+     */
+    public function getLead()
+    {
+        return $this->lead;
+    }
+    /**
+     * If this is a batch event, return array of leads.
+     *
+     * @return Lead[]|null
+     */
+    public function getLeads()
+    {
+        return $this->leads;
+    }
+    /**
+     * Returns added or removed.
+     *
+     * @return string|null
+     */
+    public function getAction()
+    {
+        return $this->action;
+    }
+    /**
+     * Lead was removed from the campaign.
+     */
+    public function wasRemoved(): bool
+    {
+        return 'removed' === $this->action;
+    }
+    /**
+     * Lead was added to the campaign.
+     */
+    public function wasAdded(): bool
+    {
+        return 'added' === $this->action;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignScheduledEvent.php
@@ -0,0 +1,102 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @deprecated 2.13.0; to be removed in 3.0
+ */
+class CampaignScheduledEvent extends Event
+{
+    use EventArrayTrait;
+    /**
+     * @var \Mautic\LeadBundle\Entity\Lead
+     */
+    protected $lead;
+    /**
+     * @var array
+     */
+    protected $event;
+    /**
+     * @var array
+     */
+    protected $eventDetails;
+    /**
+     * @var bool
+     */
+    protected $systemTriggered;
+    /**
+     * @var \DateTimeInterface
+     */
+    protected $dateScheduled;
+    /**
+     * @var array
+     */
+    protected $eventSettings;
+    public function __construct(
+        array $args,
+        protected ?LeadEventLog $log = null,
+    ) {
+        $this->lead            = $args['lead'];
+        $this->event           = $args['event'];
+        $this->eventDetails    = $args['eventDetails'];
+        $this->systemTriggered = $args['systemTriggered'];
+        $this->dateScheduled   = $args['dateScheduled'];
+        $this->eventSettings   = $args['eventSettings'];
+    }
+    /**
+     * @return \Mautic\LeadBundle\Entity\Lead
+     */
+    public function getLead()
+    {
+        return $this->lead;
+    }
+    /**
+     * @return array
+     */
+    public function getEvent()
+    {
+        return ($this->event instanceof \Mautic\CampaignBundle\Entity\Event) ? $this->getEventArray($this->event) : $this->event;
+    }
+    /**
+     * @return array
+     */
+    public function getConfig()
+    {
+        return $this->getEvent()['properties'];
+    }
+    /**
+     * @return array
+     */
+    public function getEventDetails()
+    {
+        return $this->eventDetails;
+    }
+    /**
+     * @return bool
+     */
+    public function getSystemTriggered()
+    {
+        return $this->systemTriggered;
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    public function getDateScheduled()
+    {
+        return $this->dateScheduled;
+    }
+    /**
+     * @return mixed
+     */
+    public function getEventSettings()
+    {
+        return $this->eventSettings;
+    }
+    /**
+     * @return LeadEventLog|null
+     */
+    public function getLog()
+    {
+        return $this->log;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/CampaignTriggerEvent.php
@@ -0,0 +1,39 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Symfony\Contracts\EventDispatcher\Event;
+class CampaignTriggerEvent extends Event
+{
+    /**
+     * @var bool
+     */
+    protected $triggerCampaign = true;
+    public function __construct(
+        protected Campaign $campaign,
+    ) {
+    }
+    /**
+     * Returns the Campaign entity.
+     *
+     * @return Campaign
+     */
+    public function getCampaign()
+    {
+        return $this->campaign;
+    }
+    /**
+     * @return bool
+     */
+    public function shouldTrigger()
+    {
+        return $this->triggerCampaign;
+    }
+    /**
+     * Do not trigger this campaign.
+     */
+    public function doNotTrigger(): void
+    {
+        $this->triggerCampaign = false;
+        $this->stopPropagation();
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/ConditionEvent.php
@@ -0,0 +1,83 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class ConditionEvent extends CampaignExecutionEvent
+{
+    use ContextTrait;
+    private bool $passed = false;
+    public function __construct(
+        private AbstractEventAccessor $eventConfig,
+        private LeadEventLog $eventLog,
+    ) {
+        parent::__construct(
+            [
+                'eventSettings'   => $eventConfig->getConfig(),
+                'eventDetails'    => null,
+                'event'           => $eventLog->getEvent(),
+                'lead'            => $eventLog->getLead(),
+                'systemTriggered' => $eventLog->getSystemTriggered(),
+            ],
+            null,
+            $eventLog
+        );
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getEventConfig()
+    {
+        return $this->eventConfig;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLog()
+    {
+        return $this->eventLog;
+    }
+    /**
+     * Pass this condition.
+     */
+    public function pass(): void
+    {
+        $this->passed = true;
+    }
+    /**
+     * Fail this condition.
+     */
+    public function fail(): void
+    {
+        $this->passed = false;
+    }
+    public function wasConditionSatisfied(): bool
+    {
+        return $this->passed;
+    }
+    /**
+     * @param string   $channel
+     * @param int|null $channelId
+     */
+    public function setChannel($channel, $channelId = null): void
+    {
+        $this->log->setChannel($this->channel);
+        $this->log->setChannelId($this->channelId);
+    }
+    /**
+     * @deprecated 2.13.0 to be removed in 3.0; BC support
+     */
+    public function getResult(): bool
+    {
+        return $this->passed;
+    }
+    /**
+     * @deprecated 2.13.0 to be removed in 3.0; BC support
+     *
+     * @return $this
+     */
+    public function setResult($result)
+    {
+        $this->passed = (bool) $result;
+        return $this;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/DecisionEvent.php
@@ -0,0 +1,90 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class DecisionEvent extends CampaignExecutionEvent
+{
+    use ContextTrait;
+    private bool $applicable = false;
+    /**
+     * @param mixed $passthrough
+     */
+    public function __construct(
+        private AbstractEventAccessor $eventConfig,
+        private LeadEventLog $eventLog,
+        private $passthrough = null,
+    ) {
+        parent::__construct(
+            [
+                'eventSettings'   => $eventConfig->getConfig(),
+                'eventDetails'    => $passthrough,
+                'event'           => $eventLog->getEvent(),
+                'lead'            => $eventLog->getLead(),
+                'systemTriggered' => defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED'),
+                'dateScheduled'   => $eventLog->getTriggerDate(),
+            ],
+            null,
+            $eventLog
+        );
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getEventConfig()
+    {
+        return $this->eventConfig;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLog()
+    {
+        return $this->eventLog;
+    }
+    /**
+     * @return mixed
+     */
+    public function getPassthrough()
+    {
+        return $this->passthrough;
+    }
+    /**
+     * Note that this decision is a match and the child events should be executed.
+     */
+    public function setAsApplicable(): void
+    {
+        $this->applicable = true;
+    }
+    public function wasDecisionApplicable(): bool
+    {
+        return $this->applicable;
+    }
+    /**
+     * @param string   $channel
+     * @param int|null $channelId
+     */
+    public function setChannel($channel, $channelId = null): void
+    {
+        $this->log->setChannel($this->channel);
+        $this->log->setChannelId($this->channelId);
+    }
+    /**
+     * @deprecated 2.13.0 to be removed in 3.0; BC support
+     */
+    public function getResult(): bool
+    {
+        return $this->applicable;
+    }
+    /**
+     * @deprecated 2.13.0 to be removed in 3.0; BC support
+     *
+     * @param mixed $result
+     *
+     * @return $this
+     */
+    public function setResult($result)
+    {
+        $this->applicable = (bool) $result;
+        return $this;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/DecisionResultsEvent.php
@@ -0,0 +1,40 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
+use Symfony\Contracts\EventDispatcher\Event;
+class DecisionResultsEvent extends Event
+{
+    /**
+     * @param ArrayCollection<int, LeadEventLog> $eventLogs
+     */
+    public function __construct(
+        private AbstractEventAccessor $eventConfig,
+        private ArrayCollection $eventLogs,
+        private EvaluatedContacts $evaluatedContacts,
+    ) {
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getEventConfig()
+    {
+        return $this->eventConfig;
+    }
+    /**
+     * @return ArrayCollection|LeadEventLog[]
+     */
+    public function getLogs()
+    {
+        return $this->eventLogs;
+    }
+    /**
+     * @return EvaluatedContacts
+     */
+    public function getEvaluatedContacts()
+    {
+        return $this->evaluatedContacts;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/ExecutedEvent.php
@@ -0,0 +1,26 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class ExecutedEvent extends \Symfony\Contracts\EventDispatcher\Event
+{
+    public function __construct(
+        private AbstractEventAccessor $config,
+        private LeadEventLog $log,
+    ) {
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getConfig()
+    {
+        return $this->config;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLog()
+    {
+        return $this->log;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/FailedEvent.php
@@ -0,0 +1,26 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class FailedEvent extends \Symfony\Contracts\EventDispatcher\Event
+{
+    public function __construct(
+        private AbstractEventAccessor $config,
+        private LeadEventLog $log,
+    ) {
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getConfig()
+    {
+        return $this->config;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLog()
+    {
+        return $this->log;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/PendingEvent.php
@@ -0,0 +1,223 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\FailedLeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class PendingEvent extends AbstractLogCollectionEvent
+{
+    use ContextTrait;
+    private ArrayCollection $failures;
+    private ArrayCollection $successful;
+    /**
+     * @var string|null
+     */
+    private $channel;
+    /**
+     * @var int|null
+     */
+    private $channelId;
+    private \DateTimeInterface $now;
+    /**
+     * @throws \Exception
+     */
+    public function __construct(AbstractEventAccessor $config, Event $event, ArrayCollection $logs)
+    {
+        $this->failures   = new ArrayCollection();
+        $this->successful = new ArrayCollection();
+        $this->now        = new \DateTime();
+        parent::__construct($config, $event, $logs);
+    }
+    /**
+     * @return LeadEventLog[]|ArrayCollection
+     */
+    public function getPending()
+    {
+        return $this->logs;
+    }
+    /**
+     * @param string $reason
+     */
+    public function fail(LeadEventLog $log, $reason, \DateInterval $rescheduleInterval = null): void
+    {
+        if (!$failedLog = $log->getFailedLog()) {
+            $failedLog = new FailedLeadEventLog();
+        }
+        $log->setRescheduleInterval($rescheduleInterval);
+        $failedLog->setLog($log)
+            ->setDateAdded(new \DateTime())
+            ->setReason($reason);
+        $metadata = $log->getMetadata();
+        $metadata = array_merge(
+            $metadata,
+            [
+                'failed' => 1,
+                'reason' => $reason,
+            ]
+        );
+        $log->setMetadata($metadata);
+        $this->logChannel($log);
+        $this->failures->set($log->getId(), $log);
+    }
+    /**
+     * @param string $reason
+     */
+    public function failAll($reason): void
+    {
+        foreach ($this->logs as $log) {
+            $this->fail($log, $reason);
+        }
+    }
+    /**
+     * Fail all that have not passed yet.
+     *
+     * @param string $reason
+     */
+    public function failRemaining($reason): void
+    {
+        foreach ($this->logs as $log) {
+            if (!$this->successful->contains($log)) {
+                $this->fail($log, $reason);
+            }
+        }
+    }
+    /**
+     * Fail all that have not passed or failed yet.
+     *
+     * @param string $reason
+     */
+    public function failRemainingPending($reason): void
+    {
+        foreach ($this->logs as $log) {
+            if (!$this->failures->contains($log) && !$this->successful->contains($log)) {
+                $this->fail($log, $reason);
+            }
+        }
+    }
+    /**
+     * @param LeadEventLog[]|ArrayCollection $logs
+     * @param string                         $reason
+     */
+    public function failLogs(ArrayCollection $logs, $reason): void
+    {
+        foreach ($logs as $log) {
+            $this->fail($log, $reason);
+        }
+    }
+    public function pass(LeadEventLog $log): void
+    {
+        $metadata = $log->getMetadata();
+        unset($metadata['errors']);
+        if (isset($metadata['failed'])) {
+            unset($metadata['failed'], $metadata['reason']);
+        }
+        $log->setMetadata($metadata);
+        $this->passLog($log);
+    }
+    /**
+     * @param string $error
+     */
+    public function passWithError(LeadEventLog $log, $error): void
+    {
+        $log->appendToMetadata(
+            [
+                'failed' => 1,
+                'reason' => $error,
+            ]
+        );
+        $this->passLog($log);
+    }
+    /**
+     * @param string $error
+     */
+    public function passAllWithError($error): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($this->logs as $log) {
+            $this->passWithError($log, $error);
+        }
+    }
+    /**
+     * Pass all remainging logs that have not failed failed nor suceeded yet.
+     */
+    public function passRemainingWithError(string $error): void
+    {
+        foreach ($this->logs as $log) {
+            if (!$this->failures->contains($log) && !$this->successful->contains($log)) {
+                $this->passWithError($log, $error);
+            }
+        }
+    }
+    /**
+     * Pass all pending.
+     */
+    public function passAll(): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($this->logs as $log) {
+            $this->pass($log);
+        }
+    }
+    /**
+     * @param LeadEventLog[]|ArrayCollection $logs
+     */
+    public function passLogs(ArrayCollection $logs): void
+    {
+        foreach ($logs as $log) {
+            $this->pass($log);
+        }
+    }
+    /**
+     * Pass all that have not failed yet.
+     */
+    public function passRemaining(): void
+    {
+        foreach ($this->logs as $log) {
+            if (!$this->failures->contains($log)) {
+                $this->pass($log);
+            }
+        }
+    }
+    /**
+     * @return LeadEventLog[]|ArrayCollection
+     */
+    public function getFailures()
+    {
+        return $this->failures;
+    }
+    /**
+     * @return LeadEventLog[]|ArrayCollection
+     */
+    public function getSuccessful()
+    {
+        return $this->successful;
+    }
+    /**
+     * @param string   $channel
+     * @param int|null $channelId
+     */
+    public function setChannel($channel, $channelId = null): void
+    {
+        $this->channel   = $channel;
+        $this->channelId = $channelId;
+    }
+    private function passLog(LeadEventLog $log): void
+    {
+        if ($failedLog = $log->getFailedLog()) {
+            $failedLog->setLog(null);
+            $log->setFailedLog(null);
+        }
+        $this->logChannel($log);
+        $log->setIsScheduled(false)
+            ->setDateTriggered($this->now);
+        $this->successful->set($log->getId(), $log);
+    }
+    private function logChannel(LeadEventLog $log): void
+    {
+        if ($this->channel) {
+            $log->setChannel($this->channel);
+            $log->setChannelId($this->channelId);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/ScheduledBatchEvent.php
@@ -0,0 +1,33 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class ScheduledBatchEvent extends AbstractLogCollectionEvent
+{
+    /**
+     * @param bool $isReschedule
+     */
+    public function __construct(
+        AbstractEventAccessor $config,
+        Event $event,
+        ArrayCollection $logs,
+        private $isReschedule = false,
+    ) {
+        parent::__construct($config, $event, $logs);
+    }
+    /**
+     * @return ArrayCollection
+     */
+    public function getScheduled()
+    {
+        return $this->logs;
+    }
+    /**
+     * @return bool
+     */
+    public function isReschedule()
+    {
+        return $this->isReschedule;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Event/ScheduledEvent.php
@@ -0,0 +1,49 @@
+<?php
+namespace Mautic\CampaignBundle\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+class ScheduledEvent extends CampaignScheduledEvent
+{
+    use ContextTrait;
+    /**
+     * @param bool $isReschedule
+     */
+    public function __construct(
+        private AbstractEventAccessor $eventConfig,
+        private LeadEventLog $eventLog,
+        private $isReschedule = false,
+    ) {
+        parent::__construct(
+            [
+                'eventSettings'   => $eventConfig->getConfig(),
+                'eventDetails'    => null,
+                'event'           => $eventLog->getEvent(),
+                'lead'            => $eventLog->getLead(),
+                'systemTriggered' => true,
+                'dateScheduled'   => $eventLog->getTriggerDate(),
+            ],
+            $eventLog
+        );
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getEventConfig()
+    {
+        return $this->eventConfig;
+    }
+    /**
+     * @return LeadEventLog
+     */
+    public function getLog()
+    {
+        return $this->eventLog;
+    }
+    /**
+     * @return bool
+     */
+    public function isReschedule()
+    {
+        return $this->isReschedule;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventCollector/Accessor/Event/AbstractEventAccessor.php
@@ -0,0 +1,119 @@
+<?php
+namespace Mautic\CampaignBundle\EventCollector\Accessor\Event;
+abstract class AbstractEventAccessor
+{
+    /**
+     * @var array
+     */
+    protected $systemProperties = [
+        'label',
+        'description',
+        'formType',
+        'formTypeOptions',
+        'formTheme',
+        'timelineTemplate',
+        'connectionRestrictions',
+        'channel',
+        'channelIdField',
+    ];
+    private array $extraProperties = [];
+    public function __construct(
+        protected array $config,
+    ) {
+        $this->filterExtraProperties();
+    }
+    /**
+     * @return string
+     */
+    public function getLabel()
+    {
+        return $this->getProperty('label');
+    }
+    /**
+     * @return string
+     */
+    public function getDescription()
+    {
+        return $this->getProperty('description');
+    }
+    /**
+     * @return string
+     */
+    public function getFormType()
+    {
+        return $this->getProperty('formType');
+    }
+    /**
+     * @return array
+     */
+    public function getFormTypeOptions()
+    {
+        return $this->getProperty('formTypeOptions', []);
+    }
+    /**
+     * @return string
+     */
+    public function getFormTheme()
+    {
+        return $this->getProperty('formTheme');
+    }
+    /**
+     * @return string
+     */
+    public function getTimelineTemplate()
+    {
+        return $this->getProperty('timelineTemplate');
+    }
+    /**
+     * @return array
+     */
+    public function getConnectionRestrictions()
+    {
+        return $this->getProperty('connectionRestrictions', []);
+    }
+    /**
+     * @return array
+     */
+    public function getExtraProperties()
+    {
+        return $this->extraProperties;
+    }
+    /**
+     * @return string
+     */
+    public function getChannel()
+    {
+        return $this->getProperty('channel');
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannelIdField()
+    {
+        return $this->getProperty('channelIdField');
+    }
+    /**
+     * @deprecated pre 2.13.0 support; to be removed in 3.0
+     */
+    public function getConfig()
+    {
+        return $this->config;
+    }
+    /**
+     * @param string $property
+     * @param mixed  $default
+     *
+     * @return mixed
+     */
+    protected function getProperty($property, $default = null)
+    {
+        return $this->config[$property] ?? $default;
+    }
+    /**
+     * Calculate the difference in systemProperties and what was fed to the class.
+     */
+    private function filterExtraProperties(): void
+    {
+        $this->extraProperties = array_diff_key($this->config, array_flip($this->systemProperties));
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventCollector/Builder/ConnectionBuilder.php
@@ -0,0 +1,94 @@
+<?php
+namespace Mautic\CampaignBundle\EventCollector\Builder;
+use Mautic\CampaignBundle\Entity\Event;
+class ConnectionBuilder
+{
+    private static array $eventTypes = [];
+    private static array $connectionRestrictions = ['anchor' => []];
+    /**
+     * Used by JS/JsPlumb to restrict how events can be associated to each other in the UI.
+     *
+     * @return array
+     */
+    public static function buildRestrictionsArray(array $events)
+    {
+        self::$connectionRestrictions = ['anchor' => []];
+        self::$eventTypes = array_fill_keys(array_keys($events), []);
+        foreach ($events as $eventType => $typeEvents) {
+            foreach ($typeEvents as $key => $event) {
+                self::addTypeConnection($eventType, $key, $event);
+            }
+        }
+        return self::$connectionRestrictions;
+    }
+    /**
+     * @param string $eventType
+     * @param string $key
+     */
+    private static function addTypeConnection($eventType, $key, array $event): void
+    {
+        if (!isset(self::$connectionRestrictions[$key])) {
+            self::$connectionRestrictions[$key] = [
+                'source' => self::$eventTypes,
+                'target' => self::$eventTypes,
+            ];
+        }
+        if (!isset(self::$connectionRestrictions[$key])) {
+            self::$connectionRestrictions['anchor'][$key] = [];
+        }
+        if (isset($event['connectionRestrictions'])) {
+            foreach ($event['connectionRestrictions'] as $restrictionType => $restrictions) {
+                self::addRestriction($key, $restrictionType, $restrictions);
+            }
+        }
+        self::addDeprecatedAnchorRestrictions($eventType, $key, $event);
+    }
+    /**
+     * @param string $key
+     * @param string $restrictionType
+     */
+    private static function addRestriction($key, $restrictionType, array $restrictions): void
+    {
+        switch ($restrictionType) {
+            case 'source':
+            case 'target':
+                foreach ($restrictions as $groupType => $groupRestrictions) {
+                    self::$connectionRestrictions[$key][$restrictionType][$groupType] += $groupRestrictions;
+                }
+                break;
+            case 'anchor':
+                foreach ($restrictions as $anchor) {
+                    [$group, $anchor]                                               = explode('.', $anchor);
+                    self::$connectionRestrictions[$restrictionType][$group][$key][] = $anchor;
+                }
+                break;
+        }
+    }
+    /**
+     * @deprecated 2.6.0 to be removed in 3.0; BC support
+     *
+     * @param string $eventType
+     * @param string $key
+     */
+    private static function addDeprecatedAnchorRestrictions($eventType, $key, array $event): void
+    {
+        switch ($eventType) {
+            case Event::TYPE_DECISION:
+                if (isset($event['associatedActions'])) {
+                    self::$connectionRestrictions[$key]['target']['action'] += $event['associatedActions'];
+                }
+                break;
+            case Event::TYPE_ACTION:
+                if (isset($event['associatedDecisions'])) {
+                    self::$connectionRestrictions[$key]['source']['decision'] += $event['associatedDecisions'];
+                }
+                break;
+        }
+        if (isset($event['anchorRestrictions'])) {
+            foreach ($event['anchorRestrictions'] as $restriction) {
+                [$group, $anchor]                                       = explode('.', $restriction);
+                self::$connectionRestrictions['anchor'][$key][$group][] = $anchor;
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventCollector/EventCollector.php
@@ -0,0 +1,71 @@
+<?php
+namespace Mautic\CampaignBundle\EventCollector;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\Accessor\EventAccessor;
+use Mautic\CampaignBundle\EventCollector\Builder\ConnectionBuilder;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class EventCollector
+{
+    private array $eventsArray = [];
+    private ?EventAccessor $events = null;
+    public function __construct(
+        private TranslatorInterface $translator,
+        private EventDispatcherInterface $dispatcher,
+    ) {
+    }
+    /**
+     * @return EventAccessor
+     */
+    public function getEvents()
+    {
+        if (empty($this->eventsArray)) {
+            $this->buildEventList();
+        }
+        if (empty($this->events)) {
+            $this->events = new EventAccessor($this->eventsArray);
+        }
+        return $this->events;
+    }
+    /**
+     * @return AbstractEventAccessor
+     */
+    public function getEventConfig(Event $event)
+    {
+        return $this->getEvents()->getEvent($event->getEventType(), $event->getType());
+    }
+    /**
+     * Deprecated support for pre 2.13.
+     *
+     * @deprecated 2.13.0 to be removed in 3.0
+     *
+     * @param string|null $type
+     *
+     * @return array|mixed
+     */
+    public function getEventsArray($type = null)
+    {
+        if (empty($this->eventsArray)) {
+            $this->buildEventList();
+        }
+        if (null !== $type) {
+            if (!isset($this->events[$type])) {
+                throw new \InvalidArgumentException("$type not found as array key");
+            }
+            return $this->eventsArray[$type];
+        }
+        return $this->eventsArray;
+    }
+    private function buildEventList(): void
+    {
+        $event  = new CampaignBuilderEvent($this->translator);
+        $this->dispatcher->dispatch($event, CampaignEvents::CAMPAIGN_ON_BUILD);
+        $this->eventsArray[Event::TYPE_ACTION]    = $event->getActions();
+        $this->eventsArray[Event::TYPE_CONDITION] = $event->getConditions();
+        $this->eventsArray[Event::TYPE_DECISION]  = $event->getDecisions();
+        $this->eventsArray['connectionRestrictions'] = ConnectionBuilder::buildRestrictionsArray($this->eventsArray);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/CampaignActionChangeMembershipSubscriber.php
@@ -0,0 +1,114 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
+use Mautic\CampaignBundle\Event\PendingEvent;
+use Mautic\CampaignBundle\Form\Type\CampaignEventAddRemoveLeadType;
+use Mautic\CampaignBundle\Form\Validator\Constraints\InfiniteLoopValidator;
+use Mautic\CampaignBundle\Membership\MembershipManager;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\Event\EntityValidateEvent;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class CampaignActionChangeMembershipSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private MembershipManager $membershipManager,
+        private CampaignModel $campaignModel,
+        private InfiniteLoopValidator $infiniteLoopValidator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::CAMPAIGN_ON_BUILD                    => ['addAction', 0],
+            CampaignEvents::ON_CAMPAIGN_ACTION_CHANGE_MEMBERSHIP => ['changeMembership', 0],
+            EntityValidateEvent::class                           => ['validateInfiniteLoop', 0],
+        ];
+    }
+    /**
+     * Add change membership action.
+     */
+    public function addAction(CampaignBuilderEvent $event): void
+    {
+        $event->addAction(
+            'campaign.addremovelead',
+            [
+                'label'           => 'mautic.campaign.event.addremovelead',
+                'description'     => 'mautic.campaign.event.addremovelead_descr',
+                'formType'        => CampaignEventAddRemoveLeadType::class,
+                'formTypeOptions' => [
+                    'include_this' => true,
+                ],
+                'batchEventName'  => CampaignEvents::ON_CAMPAIGN_ACTION_CHANGE_MEMBERSHIP,
+            ]
+        );
+    }
+    public function changeMembership(PendingEvent $event): void
+    {
+        $properties          = $event->getEvent()->getProperties();
+        $contacts            = $event->getContactsKeyedById();
+        $executingCampaign   = $event->getEvent()->getCampaign();
+        if (!empty($properties['addTo'])) {
+            $campaigns = $this->getCampaigns($properties['addTo'], $executingCampaign);
+            /** @var Campaign $campaign */
+            foreach ($campaigns as $campaign) {
+                $this->membershipManager->addContacts(
+                    $contacts,
+                    $campaign,
+                    true
+                );
+            }
+        }
+        if (!empty($properties['removeFrom'])) {
+            $campaigns = $this->getCampaigns($properties['removeFrom'], $executingCampaign);
+            /** @var Campaign $campaign */
+            foreach ($campaigns as $campaign) {
+                $this->membershipManager->removeContacts(
+                    $event->getContactsKeyedById(),
+                    $campaign,
+                    true
+                );
+            }
+        }
+        $event->passAll();
+    }
+    public function validateInfiniteLoop(EntityValidateEvent $event): void
+    {
+        $campaignEvent = $event->getEntity();
+        if (!$campaignEvent instanceof Event) {
+            return;
+        }
+        if ('campaign.addremovelead' !== $campaignEvent->getType()) {
+            return;
+        }
+        $this->infiniteLoopValidator->validateEvent(
+            $event->getContext(),
+            $campaignEvent->getTriggerMode(),
+            $campaignEvent->getProperties()['addTo'],
+            $campaignEvent->getTriggerInterval(),
+            $campaignEvent->getTriggerIntervalUnit()
+        );
+    }
+    /**
+     * @return array
+     */
+    private function getCampaigns(array $campaigns, Campaign $executingCampaign)
+    {
+        $includeExecutingCampaign = false;
+        $key                      = array_search('this', $campaigns);
+        if (false !== $key) {
+            $includeExecutingCampaign = true;
+            unset($campaigns[$key]);
+        }
+        $campaignEntities = [];
+        if (!empty($campaigns)) {
+            $campaignEntities = $this->campaignModel->getEntities(['ids' => $campaigns, 'ignore_paginator' => true]);
+        }
+        if ($includeExecutingCampaign) {
+            $campaignEntities[] = $executingCampaign;
+        }
+        return $campaignEntities;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/CampaignActionJumpToEventSubscriber.php
@@ -0,0 +1,150 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\EventRepository;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
+use Mautic\CampaignBundle\Event\CampaignEvent;
+use Mautic\CampaignBundle\Event\PendingEvent;
+use Mautic\CampaignBundle\Executioner\EventExecutioner;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CampaignBundle\Form\Type\CampaignEventJumpToEventType;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class CampaignActionJumpToEventSubscriber implements EventSubscriberInterface
+{
+    public const EVENT_NAME = 'campaign.jump_to_event';
+    public function __construct(
+        private EventRepository $eventRepository,
+        private EventExecutioner $eventExecutioner,
+        private TranslatorInterface $translator,
+        private LeadRepository $leadRepository,
+        private EventScheduler $eventScheduler,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::CAMPAIGN_POST_SAVE     => ['processCampaignEventsAfterSave', 1],
+            CampaignEvents::CAMPAIGN_ON_BUILD      => ['onCampaignBuild', 0],
+            CampaignEvents::ON_EVENT_JUMP_TO_EVENT => ['onJumpToEvent', 0],
+        ];
+    }
+    /**
+     * Add event triggers and actions.
+     */
+    public function onCampaignBuild(CampaignBuilderEvent $event): void
+    {
+        $event->addAction(self::EVENT_NAME, [
+            'label'                  => 'mautic.campaign.event.jump_to_event',
+            'description'            => 'mautic.campaign.event.jump_to_event_descr',
+            'formType'               => CampaignEventJumpToEventType::class,
+            'template'               => '@MauticCampaign/Event/jump.html.twig',
+            'batchEventName'         => CampaignEvents::ON_EVENT_JUMP_TO_EVENT,
+            'connectionRestrictions' => [
+                'target' => [
+                    Event::TYPE_DECISION  => ['none'],
+                    Event::TYPE_ACTION    => ['none'],
+                    Event::TYPE_CONDITION => ['none'],
+                ],
+            ],
+        ]);
+    }
+    /**
+     * Process campaign.jump_to_event actions.
+     *
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    public function onJumpToEvent(PendingEvent $campaignEvent): void
+    {
+        $event      = $campaignEvent->getEvent();
+        $jumpTarget = $this->getJumpTargetForEvent($event, 'e.id');
+        if (null === $jumpTarget) {
+            $pending  = $campaignEvent->getPending();
+            $contacts = $campaignEvent->getContacts();
+            foreach ($contacts as $logId => $contact) {
+                $campaignEvent->passWithError(
+                    $pending->get($logId),
+                    $this->translator->trans('mautic.campaign.campaign.jump_to_event.target_not_exist')
+                );
+            }
+        } else {
+            $contacts = $campaignEvent->getContactsKeyedById();
+            $this->leadRepository->incrementCampaignRotationForContacts(
+                $contacts->getKeys(),
+                $event->getCampaign()->getId()
+            );
+            $executionDate       = $event->getTriggerDate() ?? new \DateTime();
+            $targetExecutionDate = $this->eventScheduler->getExecutionDateTime($jumpTarget, $executionDate);
+            if ($this->eventScheduler->shouldScheduleEvent($jumpTarget, $targetExecutionDate, $executionDate)) {
+                $this->eventScheduler->schedule($jumpTarget, $targetExecutionDate, $contacts);
+            } else {
+                $this->eventExecutioner->executeForContacts($jumpTarget, $contacts);
+            }
+            $campaignEvent->passRemaining();
+        }
+    }
+    /**
+     * Update campaign events.
+     *
+     * This block specifically handles the campaign.jump_to_event properties
+     * to ensure that it has the actual ID and not the temp_id as the
+     * target for the jump.
+     */
+    public function processCampaignEventsAfterSave(CampaignEvent $campaignEvent): void
+    {
+        $campaign = $campaignEvent->getCampaign();
+        $events   = $campaign->getEvents();
+        $toSave   = [];
+        foreach ($events as $event) {
+            if (self::EVENT_NAME !== $event->getType()) {
+                continue;
+            }
+            $jumpTarget = $this->getJumpTargetForEvent($event, 'e.tempId');
+            if (null !== $jumpTarget) {
+                $event->setProperties(array_merge(
+                    $event->getProperties(),
+                    [
+                        'jumpToEvent' => $jumpTarget->getId(),
+                    ]
+                ));
+                $toSave[] = $event;
+            }
+        }
+        if (count($toSave)) {
+            $this->eventRepository->saveEntities($toSave);
+        }
+    }
+    /**
+     * Inspect a jump event and get its target.
+     */
+    private function getJumpTargetForEvent(Event $event, string $column): ?Event
+    {
+        $properties  = $event->getProperties();
+        $jumpToEvent = $this->eventRepository->getEntities([
+            'ignore_paginator' => true,
+            'filter'           => [
+                'force' => [
+                    [
+                        'column' => $column,
+                        'value'  => $properties['jumpToEvent'],
+                        'expr'   => 'eq',
+                    ],
+                    [
+                        'column' => 'e.campaign',
+                        'value'  => $event->getCampaign(),
+                        'expr'   => 'eq',
+                    ],
+                ],
+            ],
+        ]);
+        if (count($jumpToEvent)) {
+            return $jumpToEvent[0];
+        }
+        return null;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/CampaignEventDeleteSubscriber.php
@@ -0,0 +1,47 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Event\DeleteCampaign;
+use Mautic\CampaignBundle\Event\DeleteEvent;
+use Mautic\CampaignBundle\Helper\CampaignConfig;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class CampaignEventDeleteSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private LeadEventLogRepository $leadEventLogRepository,
+        private CampaignConfig $campaignConfig,
+        private CampaignModel $campaignModel,
+        private EventModel $eventModel,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::ON_CAMPAIGN_DELETE => ['onCampaignDelete', 0],
+            CampaignEvents::ON_EVENT_DELETE    => ['onEventDelete', 0],
+        ];
+    }
+    public function onCampaignDelete(DeleteCampaign $event): void
+    {
+        if ($this->campaignConfig->shouldDeleteEventLogInBackground()) {
+            return;
+        }
+        $campaignId = $event->getCampaign()->getId();
+        $this->leadEventLogRepository->removeEventLogsByCampaignId($campaignId);
+        $this->eventModel->deleteEventsByCampaignId($campaignId);
+        $this->campaignModel->deleteCampaign($event->getCampaign());
+    }
+    public function onEventDelete(DeleteEvent $event): void
+    {
+        if ($this->campaignConfig->shouldDeleteEventLogInBackground()) {
+            return;
+        }
+        $eventIds   = $event->getEventIds();
+        $this->leadEventLogRepository->removeEventLogs($eventIds);
+        $this->eventModel->deleteEventsByEventIds($eventIds);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/CampaignEventSubscriber.php
@@ -0,0 +1,97 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\CampaignBundle\Entity\EventRepository;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Event\CampaignEvent;
+use Mautic\CampaignBundle\Event\ExecutedEvent;
+use Mautic\CampaignBundle\Event\FailedEvent;
+use Mautic\CampaignBundle\Executioner\Helper\NotificationHelper;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class CampaignEventSubscriber implements EventSubscriberInterface
+{
+    public const LOOPS_TO_FAIL = 100;
+    private float $disableCampaignThreshold = 0.35;
+    public function __construct(private EventRepository $eventRepository, private NotificationHelper $notificationHelper, private CampaignRepository $campaignRepository, private LeadEventLogRepository $leadEventLogRepository)
+    {
+    }
+    /**
+     * Get the subscribed events for this listener.
+     *
+     * @return array<string,mixed>
+     */
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::CAMPAIGN_PRE_SAVE => ['onCampaignPreSave', 0],
+            CampaignEvents::ON_EVENT_FAILED   => ['onEventFailed', 0],
+            CampaignEvents::ON_EVENT_EXECUTED => ['onEventExecuted', 0],
+        ];
+    }
+    /**
+     * Reset all campaign event failed_count's
+     * to 0 when the campaign is published.
+     */
+    public function onCampaignPreSave(CampaignEvent $event): void
+    {
+        $campaign = $event->getCampaign();
+        $changes  = $campaign->getChanges();
+        if (array_key_exists('isPublished', $changes)) {
+            list($actual, $inMemory) = $changes['isPublished'];
+            if (false === $actual && true === $inMemory) {
+                $this->eventRepository->resetFailedCountsForEventsInCampaign($campaign);
+            }
+        }
+    }
+    /**
+     * Process the FailedEvent event. Notifies users and checks
+     * failed thresholds to notify CS and/or disable the campaign.
+     *
+     * @throws \Doctrine\ORM\NonUniqueResultException
+     */
+    public function onEventFailed(FailedEvent $event): void
+    {
+        $log                  = $event->getLog();
+        $failedEvent          = $log->getEvent();
+        $campaign             = $failedEvent->getCampaign();
+        $lead                 = $log->getLead();
+        $countFailedLeadEvent = $this->eventRepository->getFailedCountLeadEvent($lead->getId(), $failedEvent->getId());
+        if ($countFailedLeadEvent < self::LOOPS_TO_FAIL) {
+            return;
+        } elseif ($countFailedLeadEvent > self::LOOPS_TO_FAIL
+            && $this->leadEventLogRepository->isLastFailed($lead->getId(), $failedEvent->getId())
+        ) {
+            return;
+        }
+        $failedCount   = $this->eventRepository->incrementFailedCount($failedEvent);
+        $contactCount  = $campaign->getLeads()->count();
+        $failedPercent = $contactCount ? ($failedCount / $contactCount) : 1;
+        $this->notificationHelper->notifyOfFailure($lead, $failedEvent);
+        if ($failedPercent >= $this->disableCampaignThreshold && $campaign->isPublished()) {
+            $this->notificationHelper->notifyOfUnpublish($failedEvent);
+            $campaign->setIsPublished(false);
+            $this->campaignRepository->saveEntity($campaign);
+        }
+    }
+    /**
+     * Check the fail log if the lead is recorded there. If yes it decrease the failed count. It prevents counting
+     * the same failure twice.
+     *
+     * @throws \Doctrine\ORM\NonUniqueResultException
+     */
+    public function onEventExecuted(ExecutedEvent $event): void
+    {
+        $log                  = $event->getLog();
+        $executedEvent        = $log->getEvent();
+        $lead                 = $log->getLead();
+        $leadId               = ($lead->getId() > 0) ? $lead->getId() : $lead->deletedId;
+        $countFailedLeadEvent = $this->eventRepository->getFailedCountLeadEvent($leadId, $executedEvent->getId());
+        if (!$this->leadEventLogRepository->isLastFailed($leadId, $executedEvent->getId())
+            || $countFailedLeadEvent < self::LOOPS_TO_FAIL
+        ) {
+            return;
+        }
+        $this->eventRepository->decreaseFailedCount($executedEvent);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/DashboardSubscriber.php
@@ -0,0 +1,86 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CampaignBundle\Model\EventModel;
+use Mautic\DashboardBundle\Event\WidgetDetailEvent;
+use Mautic\DashboardBundle\EventListener\DashboardSubscriber as MainDashboardSubscriber;
+class DashboardSubscriber extends MainDashboardSubscriber
+{
+    /**
+     * Define the name of the bundle/category of the widget(s).
+     *
+     * @var string
+     */
+    protected $bundle = 'campaign';
+    /**
+     * Define the widget(s).
+     *
+     * @var string
+     */
+    protected $types = [
+        'events.in.time'      => [],
+        'leads.added.in.time' => [],
+    ];
+    /**
+     * Define permissions to see those widgets.
+     *
+     * @var array
+     */
+    protected $permissions = [
+        'campaign:campaigns:viewown',
+        'campaign:campaigns:viewother',
+    ];
+    public function __construct(
+        protected CampaignModel $campaignModel,
+        protected EventModel $campaignEventModel,
+    ) {
+    }
+    /**
+     * Set a widget detail when needed.
+     */
+    public function onWidgetDetailGenerate(WidgetDetailEvent $event): void
+    {
+        $this->checkPermissions($event);
+        $canViewOthers = $event->hasPermission('campaign:campaigns:viewother');
+        if ('events.in.time' == $event->getType()) {
+            $widget = $event->getWidget();
+            $params = $widget->getParams();
+            if (!$event->isCached()) {
+                $event->setTemplateData([
+                    'chartType'   => 'line',
+                    'chartHeight' => $widget->getHeight() - 80,
+                    'chartData'   => $this->campaignEventModel->getEventLineChartData(
+                        $params['timeUnit'],
+                        $params['dateFrom'],
+                        $params['dateTo'],
+                        $params['dateFormat'],
+                        [],
+                        $canViewOthers
+                    ),
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/chart.html.twig');
+            $event->stopPropagation();
+        }
+        if ('leads.added.in.time' == $event->getType()) {
+            $widget = $event->getWidget();
+            $params = $widget->getParams();
+            if (!$event->isCached()) {
+                $event->setTemplateData([
+                    'chartType'   => 'line',
+                    'chartHeight' => $widget->getHeight() - 80,
+                    'chartData'   => $this->campaignModel->getLeadsAddedLineChartData(
+                        $params['timeUnit'],
+                        $params['dateFrom'],
+                        $params['dateTo'],
+                        $params['dateFormat'],
+                        [],
+                        $canViewOthers
+                    ),
+                ]);
+            }
+            $event->setTemplate('@MauticCore/Helper/chart.html.twig');
+            $event->stopPropagation();
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/LeadSubscriber.php
@@ -0,0 +1,155 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Doctrine\ORM\EntityManagerInterface;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\EventRepository;
+use Mautic\CampaignBundle\Entity\Lead as CampaignLead;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CoreBundle\Helper\ArrayHelper;
+use Mautic\LeadBundle\Event\LeadMergeEvent;
+use Mautic\LeadBundle\Event\LeadTimelineEvent;
+use Mautic\LeadBundle\LeadEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class LeadSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private EventCollector $eventCollector,
+        private TranslatorInterface $translator,
+        private EntityManagerInterface $entityManager,
+        private RouterInterface $router,
+        private EventRepository $eventRepository,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
+            LeadEvents::LEAD_POST_MERGE      => ['onLeadMerge', 0],
+        ];
+    }
+    /**
+     * Compile events for the lead timeline.
+     */
+    public function onTimelineGenerate(LeadTimelineEvent $event): void
+    {
+        $this->addTimelineEvents($event, 'campaign.event', $this->translator->trans('mautic.campaign.triggered'));
+        $this->addTimelineEvents($event, 'campaign.event.scheduled', $this->translator->trans('mautic.campaign.scheduled'));
+    }
+    /**
+     * Update records after lead merge.
+     */
+    public function onLeadMerge(LeadMergeEvent $event): void
+    {
+        /** @var LeadEventLogRepository $leadEventLogRepository */
+        $leadEventLogRepository = $this->entityManager->getRepository(LeadEventLog::class);
+        /** @var LeadRepository $campaignLeadRepository */
+        $campaignLeadRepository = $this->entityManager->getRepository(CampaignLead::class);
+        $leadEventLogRepository->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
+        $campaignLeadRepository->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
+    }
+    /**
+     * @param string $eventTypeKey
+     * @param string $eventTypeName
+     */
+    private function addTimelineEvents(LeadTimelineEvent $event, $eventTypeKey, $eventTypeName): void
+    {
+        $event->addEventType($eventTypeKey, $eventTypeName);
+        $event->addSerializerGroup('campaignList');
+        if (!$event->isApplicable($eventTypeKey)) {
+            return;
+        }
+        /** @var LeadEventLogRepository $leadEventLogRepository */
+        $leadEventLogRepository = $this->entityManager->getRepository(LeadEventLog::class);
+        $options                   = $event->getQueryOptions();
+        $options['scheduledState'] = ('campaign.event' === $eventTypeKey) ? false : true;
+        $logs                      = $leadEventLogRepository->getLeadLogs($event->getLeadId(), $options);
+        $eventSettings             = $this->eventCollector->getEventsArray();
+        $event->addToCounter($eventTypeKey, $logs);
+        if (!$event->isEngagementCount()) {
+            foreach ($logs['results'] as $log) {
+                $template = (!empty($eventSettings['action'][$log['type']]['timelineTemplate']))
+                    ? $eventSettings['action'][$log['type']]['timelineTemplate'] : '@MauticCampaign/SubscribedEvents/Timeline/index.html.twig';
+                $label = $log['event_name'].' / '.$log['campaign_name'];
+                if (empty($log['isScheduled']) && empty($log['dateTriggered'])) {
+                    $label .= ' <i data-toggle="tooltip" title="'.$this->translator->trans('mautic.campaign.event.cancelled')
+                        .'" class="ri-calendar-close-fill text-warning timeline-campaign-event-cancelled-'.$log['event_id'].'"></i>';
+                }
+                if ((!empty($log['metadata']['errors']) && empty($log['dateTriggered'])) || !empty($log['metadata']['failed']) || !empty($log['fail_reason'])) {
+                    $label .= ' <i data-toggle="tooltip" title="'.$this->translator->trans('mautic.campaign.event.has_last_attempt_error')
+                        .'" class="ri-alert-line text-danger"></i>';
+                }
+                $extra = [
+                    'log' => $log,
+                ];
+                if (!empty($log['parent_id'])) {
+                    $parentEvent = $this->getParentEvent($log['parent_id']);
+                    if ($parentEvent) {
+                        $extra['parentDetails'] = $this->getParentDetails($parentEvent, $log);
+                        $toolTipClass = 'yes' === $log['decision_path'] ? 'text-success' : 'text-danger';
+                        $toolTip      = $this->translator->trans('mautic.campaign.event.path.tooltip', ['%path%' => ucfirst($log['decision_path'])]);
+                        $label .= sprintf(' <i class="ri-node-tree %s" data-toggle="tooltip" title="%s"></i>', $toolTipClass, $toolTip);
+                    }
+                }
+                if ($event->isForTimeline()) {
+                    $extra['campaignEventSettings'] = $eventSettings;
+                }
+                $event->addEvent(
+                    [
+                        'event'      => $eventTypeKey,
+                        'eventId'    => $eventTypeKey.$log['log_id'],
+                        'eventLabel' => [
+                            'label' => $label,
+                            'href'  => $this->router->generate(
+                                'mautic_campaign_action',
+                                ['objectAction' => 'view', 'objectId' => $log['campaign_id']]
+                            ),
+                        ],
+                        'eventType'       => $eventTypeName,
+                        'timestamp'       => $log['dateTriggered'],
+                        'extra'           => $extra,
+                        'contentTemplate' => $template,
+                        'icon'            => 'ri-time-line',
+                        'contactId'       => $log['lead_id'],
+                    ]
+                );
+            }
+        }
+    }
+    /**
+     * Fetch the parent event if exists.
+     */
+    private function getParentEvent(int $parentId): ?Event
+    {
+        $entities = $this->eventRepository->findBy([
+            'id'        => $parentId,
+            'eventType' => [Event::TYPE_CONDITION, Event::TYPE_DECISION],
+        ]);
+        return $entities[0] ?? null;
+    }
+    /**
+     * Get details for the parent event.
+     *
+     * @param array<string, mixed> $log
+     *
+     * @return array<string, mixed>
+     */
+    private function getParentDetails(Event $parentEvent, array $log): array
+    {
+        $properties = ArrayHelper::removeEmptyValues($parentEvent->getProperties());
+        $keysToRemove = ['canvasSettings', 'anchor', 'type', 'eventType', 'campaignId', '_token', 'buttons', 'anchorEventType', 'tempId', 'id', 'order', 'contactLog', 'changes', 'failedCount', 'properties'];
+        foreach ($keysToRemove as $key) {
+            unset($properties[$key]);
+        }
+        return [
+            'name'       => $parentEvent->getName(),
+            'type'       => $parentEvent->getEventType(),
+            'path'       => $log['decision_path'],
+            'properties' => $properties,
+        ];
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/ReportSubscriber.php
@@ -0,0 +1,196 @@
+<?php
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CoreBundle\Helper\Chart\ChartQuery;
+use Mautic\LeadBundle\Model\CompanyReportData;
+use Mautic\ReportBundle\Event\ReportBuilderEvent;
+use Mautic\ReportBundle\Event\ReportGeneratorEvent;
+use Mautic\ReportBundle\Event\ReportGraphEvent;
+use Mautic\ReportBundle\ReportEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class ReportSubscriber implements EventSubscriberInterface
+{
+    public const CONTEXT_CAMPAIGN_LEAD_EVENT_LOG = 'campaign_lead_event_log';
+    public function __construct(
+        private CompanyReportData $companyReportData,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ReportEvents::REPORT_ON_BUILD          => ['onReportBuilder', 0],
+            ReportEvents::REPORT_ON_GENERATE       => ['onReportGenerate', 0],
+            ReportEvents::REPORT_ON_GRAPH_GENERATE => ['onReportGraphGenerate', 0],
+        ];
+    }
+    /**
+     * Add available tables and columns to the report builder lookup.
+     */
+    public function onReportBuilder(ReportBuilderEvent $event): void
+    {
+        if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
+            return;
+        }
+        $prefix           = 'log.';
+        $aliasPrefix      = 'log_';
+        $campaignPrefix   = 'c.';
+        $eventPrefix      = 'e.';
+        $eventAliasPrefix = 'e_';
+        $catPrefix        = 'cat.';
+        $leadPrefix       = 'l.';
+        $columns = [
+            $prefix.'date_triggered' => [
+                'label'          => 'mautic.report.campaign.log.date_triggered',
+                'type'           => 'datetime',
+                'alias'          => $aliasPrefix.'date_triggered',
+                'groupByFormula' => 'DATE('.$prefix.'date_triggered)',
+            ],
+            $prefix.'is_scheduled' => [
+                'label' => 'mautic.report.campaign.log.is_scheduled',
+                'type'  => 'boolean',
+                'alias' => $aliasPrefix.'is_scheduled',
+            ],
+            $prefix.'trigger_date' => [
+                'label'          => 'mautic.report.campaign.log.trigger_date',
+                'type'           => 'datetime',
+                'alias'          => $aliasPrefix.'trigger_date',
+                'groupByFormula' => 'DATE('.$prefix.'trigger_date)',
+            ],
+            $prefix.'system_triggered' => [
+                'label' => 'mautic.report.campaign.log.system_triggered',
+                'type'  => 'boolean',
+                'alias' => $aliasPrefix.'system_triggered',
+            ],
+            $prefix.'non_action_path_taken' => [
+                'label' => 'mautic.report.campaign.log.non_action_path_taken',
+                'type'  => 'boolean',
+                'alias' => $aliasPrefix.'non_action_path_taken',
+            ],
+            $prefix.'channel' => [
+                'label' => 'mautic.report.campaign.log.channel',
+                'type'  => 'string',
+                'alias' => $aliasPrefix.'channel',
+            ],
+            $prefix.'channel_id' => [
+                'label' => 'mautic.report.campaign.log.channel_id',
+                'type'  => 'int',
+                'alias' => $aliasPrefix.'channel_id',
+            ],
+            $prefix.'rotation' => [
+                'label' => 'mautic.report.campaign.event.rotation',
+                'type'  => 'int',
+                'alias' => $eventAliasPrefix.'rotation',
+            ],
+            $eventPrefix.'name' => [
+                'label' => 'mautic.report.campaign.event.name',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'name',
+            ],
+            $eventPrefix.'description' => [
+                'label' => 'mautic.report.campaign.event.description',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'description',
+            ],
+            $eventPrefix.'type' => [
+                'label' => 'mautic.report.campaign.event.type',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'type',
+            ],
+            $eventPrefix.'event_type' => [
+                'label' => 'mautic.report.campaign.event.event_type',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'event_type',
+            ],
+            $eventPrefix.'trigger_date' => [
+                'label'          => 'mautic.report.campaign.event.trigger_date',
+                'type'           => 'datetime',
+                'alias'          => $eventAliasPrefix.'trigger_date',
+                'groupByFormula' => 'DATE('.$eventPrefix.'trigger_date)',
+            ],
+            $eventPrefix.'trigger_mode' => [
+                'label' => 'mautic.report.campaign.event.trigger_mode',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'trigger_mode',
+            ],
+            $eventPrefix.'channel' => [
+                'label' => 'mautic.report.campaign.event.channel',
+                'type'  => 'string',
+                'alias' => $eventAliasPrefix.'channel',
+            ],
+            $eventPrefix.'channel_id' => [
+                'label' => 'mautic.report.campaign.event.channel_id',
+                'type'  => 'int',
+                'alias' => $eventAliasPrefix.'channel_id',
+            ],
+        ];
+        $companyColumns = $this->companyReportData->getCompanyData();
+        $columns = array_merge(
+            $columns,
+            $event->getStandardColumns($campaignPrefix, [], 'mautic_campaign_action'),
+            $event->getCategoryColumns($catPrefix),
+            $event->getLeadColumns($leadPrefix),
+            $event->getIpColumn(),
+            $event->getChannelColumns(),
+            $companyColumns
+        );
+        $data = [
+            'display_name' => 'mautic.campaign.events',
+            'columns'      => $columns,
+        ];
+        $event->addTable(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG, $data);
+    }
+    /**
+     * Initialize the QueryBuilder object to generate reports from.
+     */
+    public function onReportGenerate(ReportGeneratorEvent $event): void
+    {
+        if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
+            return;
+        }
+        $qb = $event->getQueryBuilder();
+        $qb->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
+            ->leftJoin('log', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = log.campaign_id')
+            ->leftJoin('log', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = log.event_id');
+        $event
+            ->addLeadLeftJoin($qb, 'log')
+            ->addIpAddressLeftJoin($qb, 'log')
+            ->addCategoryLeftJoin($qb, 'c', 'cat')
+            ->addChannelLeftJoins($qb, 'log');
+        if ($this->companyReportData->eventHasCompanyColumns($event)) {
+            $event->addCompanyLeftJoin($qb);
+        }
+        $event->applyDateFilters($qb, 'date_triggered', 'log');
+        $event->setQueryBuilder($qb);
+    }
+    /**
+     * Initialize the QueryBuilder object to generate reports from.
+     */
+    public function onReportGraphGenerate(ReportGraphEvent $event): void
+    {
+        if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
+            return;
+        }
+        $graphs = $event->getRequestedGraphs();
+        $qb     = $event->getQueryBuilder();
+        foreach ($graphs as $g) {
+            $options      = $event->getOptions($g);
+            $queryBuilder = clone $qb;
+            /** @var ChartQuery $chartQuery */
+            $chartQuery = clone $options['chartQuery'];
+            $chartQuery->applyDateFilters($queryBuilder, 'date_triggered', 'log');
+            switch ($g) {
+                /*
+                case 'mautic.page.graph.line.hits':
+                    $chart = new LineChart(null, $options['dateFrom'], $options['dateTo']);
+                    $chartQuery->modifyTimeDataQuery($queryBuilder, 'date_hit', 'ph');
+                    $hits = $chartQuery->loadAndBuildTimeData($queryBuilder);
+                    $chart->setDataset($options['translator']->trans($g), $hits);
+                    $data         = $chart->render();
+                    $data['name'] = $g;
+                    $event->setGraph($g, $data);
+                    break;
+                */
+            }
+            unset($queryBuilder);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/EventListener/SearchSubscriber.php
@@ -0,0 +1,48 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\EventListener;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
+use Mautic\CoreBundle\Event as MauticEvents;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\GlobalSearch;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class SearchSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private CampaignModel $campaignModel,
+        private CorePermissions $security,
+        private GlobalSearch $globalSearch,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
+            CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
+        ];
+    }
+    public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
+    {
+        $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
+        $results   = $this->globalSearch->performSearch(
+            $filterDTO,
+            $this->campaignModel,
+            '@MauticCampaign/SubscribedEvents/Search/global.html.twig'
+        );
+        if (!empty($results)) {
+            $event->addResults('mautic.campaign.campaigns', $results);
+        }
+    }
+    public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
+    {
+        $security = $this->security;
+        if ($security->isGranted('campaign:campaigns:view')) {
+            $event->addCommands(
+                'mautic.campaign.campaigns',
+                $this->campaignModel->getCommandList()
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/ContactFinder/InactiveContactFinder.php
@@ -0,0 +1,78 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\ContactFinder;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Collection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadRepository as CampaignLeadRepository;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Entity\LeadRepository;
+use Psr\Log\LoggerInterface;
+class InactiveContactFinder
+{
+    /**
+     * @var array<string, \DateTimeInterface>|null
+     */
+    private ?array $campaignMemberDatesAdded = null;
+    public function __construct(
+        private LeadRepository $leadRepository,
+        private CampaignLeadRepository $campaignLeadRepository,
+        private LoggerInterface $logger,
+    ) {
+    }
+    /**
+     * @param int $campaignId
+     *
+     * @return ArrayCollection
+     *
+     * @throws NoContactsFoundException
+     */
+    public function getContacts($campaignId, Event $decisionEvent, ContactLimiter $limiter)
+    {
+        if ($limiter->hasCampaignLimit() && 0 === $limiter->getCampaignLimitRemaining()) {
+            return new ArrayCollection();
+        }
+        $decisionParentEvent            = $decisionEvent->getParent();
+        $this->campaignMemberDatesAdded = $this->campaignLeadRepository->getInactiveContacts(
+            $campaignId,
+            $decisionEvent->getId(),
+            ($decisionParentEvent) ? $decisionParentEvent->getId() : null,
+            $limiter
+        );
+        if (empty($this->campaignMemberDatesAdded)) {
+            throw new NoContactsFoundException();
+        }
+        $campaignContacts = array_keys($this->campaignMemberDatesAdded);
+        $this->logger->debug('CAMPAIGN: Processing the following contacts: '.implode(', ', $campaignContacts));
+        $contacts = $this->leadRepository->getContactCollection($campaignContacts);
+        if (!count($contacts)) {
+            $this->logger->debug('CAMPAIGN: No contact entities found.');
+            throw new NoContactsFoundException();
+        }
+        return $contacts;
+    }
+    /**
+     * @return array<string, \DateTimeInterface>|null
+     */
+    public function getDatesAdded(): ?array
+    {
+        return $this->campaignMemberDatesAdded;
+    }
+    /**
+     * @param int $campaignId
+     */
+    public function getContactCount($campaignId, array $decisionEvents, ContactLimiter $limiter): int
+    {
+        return $this->campaignLeadRepository->getInactiveContactCount($campaignId, $decisionEvents, $limiter);
+    }
+    /**
+     * Clear Lead entities from memory.
+     *
+     * @param Collection<int, Lead> $contacts
+     */
+    public function clear(Collection $contacts): void
+    {
+        $this->leadRepository->detachEntities($contacts->toArray());
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/ContactFinder/KickoffContactFinder.php
@@ -0,0 +1,57 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\ContactFinder;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Collection;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Entity\LeadRepository;
+use Psr\Log\LoggerInterface;
+class KickoffContactFinder
+{
+    public function __construct(
+        private LeadRepository $leadRepository,
+        private CampaignRepository $campaignRepository,
+        private LoggerInterface $logger,
+    ) {
+    }
+    /**
+     * @param int $campaignId
+     *
+     * @return ArrayCollection
+     *
+     * @throws NoContactsFoundException
+     */
+    public function getContacts($campaignId, ContactLimiter $limiter)
+    {
+        $campaignContacts = $this->campaignRepository->getPendingContactIds($campaignId, $limiter);
+        if (empty($campaignContacts)) {
+            throw new NoContactsFoundException();
+        }
+        $this->logger->debug('CAMPAIGN: Processing the following contacts: '.implode(', ', $campaignContacts));
+        $contacts = $this->leadRepository->getContactCollection($campaignContacts);
+        if (!count($contacts)) {
+            $this->logger->debug('CAMPAIGN: No contact entities found.');
+            throw new NoContactsFoundException();
+        }
+        return $contacts;
+    }
+    /**
+     * @param int $campaignId
+     */
+    public function getContactCount($campaignId, array $eventIds, ContactLimiter $limiter): int
+    {
+        $countResult = $this->campaignRepository->getCountsForPendingContacts($campaignId, $eventIds, $limiter);
+        return $countResult->getCount();
+    }
+    /**
+     * Clear Lead entities from memory.
+     *
+     * @param Collection<int, Lead> $contacts
+     */
+    public function clear(Collection $contacts): void
+    {
+        $this->leadRepository->detachEntities($contacts->toArray());
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/ContactFinder/Limiter/ContactLimiter.php
@@ -0,0 +1,171 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\ContactFinder\Limiter;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+class ContactLimiter
+{
+    private int $batchLimit;
+    private ?int $contactId;
+    private ?int $minContactId;
+    private ?int $batchMinContactId = null;
+    private ?int $maxContactId;
+    private ?int $threadId = null;
+    private ?int $maxThreads = null;
+    /**
+     * @var int|null
+     */
+    private $campaignLimit;
+    private ?int $campaignLimitUsed = null;
+    /**
+     * @param int      $batchLimit
+     * @param int|null $contactId
+     * @param int|null $minContactId
+     * @param int|null $maxContactId
+     * @param int|null $threadId
+     * @param int|null $maxThreads
+     * @param int|null $campaignLimit
+     */
+    public function __construct(
+        $batchLimit,
+        $contactId = null,
+        $minContactId = null,
+        $maxContactId = null,
+        private array $contactIdList = [],
+        $threadId = null,
+        $maxThreads = null,
+        $campaignLimit = null,
+    ) {
+        $this->batchLimit    = ($batchLimit) ? (int) $batchLimit : 100;
+        $this->contactId     = ($contactId) ? (int) $contactId : null;
+        $this->minContactId  = ($minContactId) ? (int) $minContactId : null;
+        $this->maxContactId  = ($maxContactId) ? (int) $maxContactId : null;
+        if ($threadId && $maxThreads) {
+            $this->threadId     = (int) $threadId;
+            $this->maxThreads   = (int) $maxThreads;
+            if ($threadId > $maxThreads) {
+                throw new \InvalidArgumentException('$threadId cannot be larger than $maxThreads');
+            }
+        }
+        if ($campaignLimit) {
+            $this->campaignLimit     = $campaignLimit;
+            $this->campaignLimitUsed = 0;
+        }
+    }
+    public function getBatchLimit(): int
+    {
+        return $this->batchLimit;
+    }
+    /**
+     * @return int|null
+     */
+    public function getContactId()
+    {
+        return $this->contactId;
+    }
+    public function getMinContactId(): ?int
+    {
+        return $this->batchMinContactId ?: $this->minContactId;
+    }
+    /**
+     * @return int|null
+     */
+    public function getMaxContactId()
+    {
+        return $this->maxContactId;
+    }
+    /**
+     * @return array
+     */
+    public function getContactIdList()
+    {
+        return $this->contactIdList;
+    }
+    /**
+     * @param int $id
+     *
+     * @return $this
+     *
+     * @throws NoContactsFoundException
+     */
+    public function setBatchMinContactId($id)
+    {
+        if ($this->minContactId && $this->minContactId > (int) $id) {
+            throw new NoContactsFoundException();
+        }
+        if ($this->maxContactId && $this->maxContactId < (int) $id) {
+            throw new NoContactsFoundException();
+        }
+        if ($this->batchMinContactId && $this->batchMinContactId >= $id) {
+            throw new NoContactsFoundException();
+        }
+        $this->batchMinContactId = (int) $id;
+        return $this;
+    }
+    /**
+     * @return $this
+     */
+    public function resetBatchMinContactId()
+    {
+        $this->batchMinContactId =  null;
+        return $this;
+    }
+    /**
+     * @return int|null
+     */
+    public function getMaxThreads()
+    {
+        return $this->maxThreads;
+    }
+    /**
+     * @return int|null
+     */
+    public function getThreadId()
+    {
+        return $this->threadId;
+    }
+    /**
+     * @return int|null
+     */
+    public function getCampaignLimit()
+    {
+        return $this->campaignLimit;
+    }
+    public function hasCampaignLimit(): bool
+    {
+        return null !== $this->campaignLimit;
+    }
+    /**
+     * @return int
+     *
+     * @throws \Exception
+     */
+    public function getCampaignLimitRemaining()
+    {
+        if (!$this->hasCampaignLimit()) {
+            throw new \Exception('Campaign Limit was not set');
+        }
+        return $this->campaignLimit - $this->campaignLimitUsed;
+    }
+    /**
+     * @return $this
+     *
+     * @throws \Exception
+     */
+    public function reduceCampaignLimitRemaining($reduction)
+    {
+        if (!$this->hasCampaignLimit()) {
+            throw new \Exception('Campaign Limit was not set');
+        } elseif ($this->campaignLimit < ($this->campaignLimitUsed + $reduction)) {
+            throw new \Exception('Campaign Limit exceeded');
+        }
+        $this->campaignLimitUsed += $reduction;
+        return $this;
+    }
+    /**
+     * @return $this
+     */
+    public function resetCampaignLimitRemaining()
+    {
+        $this->campaignLimitUsed = 0;
+        return $this;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/ContactFinder/ScheduledContactFinder.php
@@ -0,0 +1,53 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\ContactFinder;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\Common\Collections\Collection;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Entity\LeadRepository;
+use Psr\Log\LoggerInterface;
+class ScheduledContactFinder
+{
+    public function __construct(
+        private LeadRepository $leadRepository,
+        private LoggerInterface $logger,
+    ) {
+    }
+    /**
+     * Hydrate contacts with custom field value, companies, etc.
+     *
+     * @return Collection<int, Lead>
+     */
+    public function hydrateContacts(ArrayCollection $logs): Collection
+    {
+        $contactIds = [];
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $contactIds[] = $log->getLead()->getId();
+        }
+        if (!count($contactIds)) {
+            $this->logger->debug('CAMPAIGN: No contact entities found.');
+            throw new NoContactsFoundException();
+        }
+        $contacts = $this->leadRepository->getContactCollection($contactIds);
+        foreach ($logs as $key => $log) {
+            $contactId = $log->getLead()->getId();
+            if (!$contact = $contacts->get($contactId)) {
+                $logs->remove($key);
+                continue;
+            }
+            $log->setLead($contact);
+        }
+        return $contacts;
+    }
+    /**
+     * Clear Lead entities from memory.
+     *
+     * @param Collection<int, Lead> $contacts
+     */
+    public function clear(Collection $contacts): void
+    {
+        $this->leadRepository->detachEntities($contacts->toArray());
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Dispatcher/ActionDispatcher.php
@@ -0,0 +1,100 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Dispatcher;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\ExecutedBatchEvent;
+use Mautic\CampaignBundle\Event\ExecutedEvent;
+use Mautic\CampaignBundle\Event\FailedEvent;
+use Mautic\CampaignBundle\Event\PendingEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
+use Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException;
+use Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class ActionDispatcher
+{
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+        private LoggerInterface $logger,
+        private EventScheduler $scheduler,
+        private LegacyEventDispatcher $legacyDispatcher,
+    ) {
+    }
+    /**
+     * @throws LogNotProcessedException
+     * @throws LogPassedAndFailedException
+     */
+    public function dispatchEvent(ActionAccessor $config, Event $event, ArrayCollection $logs, PendingEvent $pendingEvent = null): PendingEvent
+    {
+        if (!$pendingEvent) {
+            $pendingEvent = new PendingEvent($config, $event, $logs);
+        }
+        if ($customEvent = $config->getBatchEventName()) {
+            $this->dispatcher->dispatch($pendingEvent, $customEvent);
+            $success = $pendingEvent->getSuccessful();
+            $failed  = $pendingEvent->getFailures();
+            $this->validateProcessedLogs($logs, $success, $failed);
+            if ($success) {
+                $this->dispatchExecutedEvent($config, $event, $success);
+            }
+            if ($failed) {
+                $this->dispatchFailedEvent($config, $failed);
+            }
+            $this->legacyDispatcher->dispatchExecutionEvents($config, $success, $failed);
+        }
+        $this->legacyDispatcher->dispatchCustomEvent($config, $logs, $customEvent, $pendingEvent);
+        return $pendingEvent;
+    }
+    private function dispatchExecutedEvent(AbstractEventAccessor $config, Event $event, ArrayCollection $logs): void
+    {
+        if (!$logs->count()) {
+            return;
+        }
+        foreach ($logs as $log) {
+            $this->dispatcher->dispatch(
+                new ExecutedEvent($config, $log),
+                CampaignEvents::ON_EVENT_EXECUTED
+            );
+        }
+        $this->dispatcher->dispatch(
+            new ExecutedBatchEvent($config, $event, $logs),
+            CampaignEvents::ON_EVENT_EXECUTED_BATCH
+        );
+    }
+    private function dispatchFailedEvent(AbstractEventAccessor $config, ArrayCollection $logs): void
+    {
+        if (!$logs->count()) {
+            return;
+        }
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $this->logger->debug(
+                'CAMPAIGN: '.ucfirst($log->getEvent()->getEventType() ?? 'unknown event').' ID# '.$log->getEvent()->getId().' for contact ID# '.$log->getLead()->getId()
+            );
+            $this->dispatcher->dispatch(
+                new FailedEvent($config, $log),
+                CampaignEvents::ON_EVENT_FAILED
+            );
+        }
+        $this->scheduler->rescheduleFailures($logs);
+    }
+    /**
+     * @throws LogNotProcessedException
+     * @throws LogPassedAndFailedException
+     */
+    private function validateProcessedLogs(ArrayCollection $pending, ArrayCollection $success, ArrayCollection $failed): void
+    {
+        foreach ($pending as $log) {
+            if (!$success->contains($log) && !$failed->contains($log)) {
+                throw new LogNotProcessedException($log);
+            }
+            if ($success->contains($log) && $failed->contains($log)) {
+                throw new LogPassedAndFailedException($log);
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Dispatcher/ConditionDispatcher.php
@@ -0,0 +1,21 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Dispatcher;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\ConditionEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\ConditionAccessor;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class ConditionDispatcher
+{
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+    ) {
+    }
+    public function dispatchEvent(ConditionAccessor $config, LeadEventLog $log): ConditionEvent
+    {
+        $event = new ConditionEvent($config, $log);
+        $this->dispatcher->dispatch($event, $config->getEventName());
+        $this->dispatcher->dispatch($event, CampaignEvents::ON_EVENT_CONDITION_EVALUATION);
+        return $event;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Dispatcher/DecisionDispatcher.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Dispatcher;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\DecisionEvent;
+use Mautic\CampaignBundle\Event\DecisionResultsEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
+use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class DecisionDispatcher
+{
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+        private LegacyEventDispatcher $legacyDispatcher,
+    ) {
+    }
+    /**
+     * @param mixed $passthrough
+     */
+    public function dispatchRealTimeEvent(DecisionAccessor $config, LeadEventLog $log, $passthrough): DecisionEvent
+    {
+        $event = new DecisionEvent($config, $log, $passthrough);
+        $this->dispatcher->dispatch($event, $config->getEventName());
+        return $event;
+    }
+    public function dispatchEvaluationEvent(DecisionAccessor $config, LeadEventLog $log): DecisionEvent
+    {
+        $event = new DecisionEvent($config, $log);
+        $this->dispatcher->dispatch($event, CampaignEvents::ON_EVENT_DECISION_EVALUATION);
+        $this->legacyDispatcher->dispatchDecisionEvent($event);
+        return $event;
+    }
+    public function dispatchDecisionResultsEvent(DecisionAccessor $config, ArrayCollection $logs, EvaluatedContacts $evaluatedContacts): void
+    {
+        if (!$logs->count()) {
+            return;
+        }
+        $this->dispatcher->dispatch(
+            new DecisionResultsEvent($config, $logs, $evaluatedContacts),
+            CampaignEvents::ON_EVENT_DECISION_EVALUATION_RESULTS
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Dispatcher/LegacyEventDispatcher.php
@@ -0,0 +1,233 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Dispatcher;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\CampaignDecisionEvent;
+use Mautic\CampaignBundle\Event\CampaignExecutionEvent;
+use Mautic\CampaignBundle\Event\DecisionEvent;
+use Mautic\CampaignBundle\Event\EventArrayTrait;
+use Mautic\CampaignBundle\Event\ExecutedBatchEvent;
+use Mautic\CampaignBundle\Event\ExecutedEvent;
+use Mautic\CampaignBundle\Event\FailedEvent;
+use Mautic\CampaignBundle\Event\PendingEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+/**
+ * @deprecated 2.13.0 to be removed in 3.0; BC support for old listeners
+ */
+class LegacyEventDispatcher
+{
+    use EventArrayTrait;
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+        private EventScheduler $scheduler,
+        private LoggerInterface $logger,
+        private ContactTracker $contactTracker,
+    ) {
+    }
+    public function dispatchCustomEvent(
+        AbstractEventAccessor $config,
+        ArrayCollection $logs,
+        $wasBatchProcessed,
+        PendingEvent $pendingEvent,
+    ): void {
+        $settings = $config->getConfig();
+        if (!isset($settings['eventName']) && !isset($settings['callback'])) {
+            if (!$wasBatchProcessed) {
+                $pendingEvent->failAll('Invalid event configuration');
+            }
+            return;
+        }
+        $rescheduleFailures = new ArrayCollection();
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $this->contactTracker->setSystemContact($log->getLead());
+            if (isset($settings['eventName'])) {
+                $event  = $this->dispatchEventName($settings['eventName'], $settings, $log);
+                $result = $event->getResult();
+            } else {
+                if (!is_callable($settings['callback'])) {
+                    break;
+                }
+                $result = $this->dispatchCallback($settings, $log);
+            }
+            if (!$wasBatchProcessed) {
+                $this->dispatchExecutionEvent($config, $log, $result);
+                if (!is_bool($result)) {
+                    $log->appendToMetadata($result);
+                }
+                if ($this->isFailed($result)) {
+                    $this->processFailedLog($log, $pendingEvent);
+                    $rescheduleFailures->set($log->getId(), $log);
+                    $this->dispatchFailedEvent($config, $log);
+                    continue;
+                }
+                if (is_array($result) && !empty($result['failed']) && isset($result['reason'])) {
+                    $pendingEvent->passWithError($log, (string) $result['reason']);
+                } else {
+                    $pendingEvent->pass($log);
+                }
+                $this->dispatchExecutedEvent($config, $log);
+            }
+        }
+        if ($rescheduleFailures->count()) {
+            $this->scheduler->rescheduleFailures($rescheduleFailures);
+        }
+        $this->contactTracker->setSystemContact(null);
+    }
+    /**
+     * Execute the new ON_EVENT_FAILED and ON_EVENT_EXECUTED events for logs processed by BC code.
+     */
+    public function dispatchExecutionEvents(AbstractEventAccessor $config, ArrayCollection $success, ArrayCollection $failures): void
+    {
+        foreach ($success as $log) {
+            $this->dispatchExecutionEvent($config, $log, true);
+        }
+        foreach ($failures as $log) {
+            $this->dispatchExecutionEvent($config, $log, false);
+        }
+    }
+    public function dispatchDecisionEvent(DecisionEvent $decisionEvent): void
+    {
+        if ($this->dispatcher->hasListeners(CampaignEvents::ON_EVENT_DECISION_TRIGGER)) {
+            $log   = $decisionEvent->getLog();
+            $event = $log->getEvent();
+            $legacyDecisionEvent = $this->dispatcher->dispatch(
+                new CampaignDecisionEvent(
+                    $log->getLead(),
+                    $event->getType(),
+                    $decisionEvent->getEventConfig()->getConfig(),
+                    $this->getLegacyEventsArray($log),
+                    $this->getLegacyEventsConfigArray($event, $decisionEvent->getEventConfig()),
+                    0 === $event->getOrder(),
+                    [$log]
+                ),
+                CampaignEvents::ON_EVENT_DECISION_TRIGGER
+            );
+            if ($legacyDecisionEvent->wasDecisionTriggered()) {
+                $decisionEvent->setAsApplicable();
+            }
+        }
+    }
+    private function dispatchEventName($eventName, array $settings, LeadEventLog $log): CampaignExecutionEvent
+    {
+        @trigger_error('eventName is deprecated. Convert to using batchEventName.', E_USER_DEPRECATED);
+        $campaignEvent = new CampaignExecutionEvent(
+            [
+                'eventSettings'   => $settings,
+                'eventDetails'    => null,
+                'event'           => $log->getEvent(),
+                'lead'            => $log->getLead(),
+                'systemTriggered' => $log->getSystemTriggered(),
+            ],
+            null,
+            $log
+        );
+        $this->dispatcher->dispatch($campaignEvent, $eventName);
+        if ($channel = $campaignEvent->getChannel()) {
+            $log->setChannel($channel);
+            $log->setChannelId($campaignEvent->getChannelId());
+        }
+        return $campaignEvent;
+    }
+    /**
+     * @return mixed
+     */
+    private function dispatchCallback(array $settings, LeadEventLog $log)
+    {
+        @trigger_error('callback is deprecated. Convert to using batchEventName.', E_USER_DEPRECATED);
+        $eventArray = $this->getEventArray($log->getEvent());
+        $args       = [
+            'eventSettings'   => $settings,
+            'eventDetails'    => null, // @todo fix when procesing decisions,
+            'event'           => $eventArray,
+            'lead'            => $log->getLead(),
+            'systemTriggered' => $log->getSystemTriggered(),
+            'config'          => $eventArray['properties'],
+        ];
+        try {
+            if (is_array($settings['callback'])) {
+                $reflection = new \ReflectionMethod($settings['callback'][0], $settings['callback'][1]);
+            } elseif (str_contains($settings['callback'], '::')) {
+                $parts      = explode('::', $settings['callback']);
+                $reflection = new \ReflectionMethod($parts[0], $parts[1]);
+            } else {
+                $reflection = new \ReflectionMethod(null, $settings['callback']);
+            }
+            $pass = [];
+            foreach ($reflection->getParameters() as $param) {
+                if (isset($args[$param->getName()])) {
+                    $pass[] = $args[$param->getName()];
+                } else {
+                    $pass[] = null;
+                }
+            }
+            return $reflection->invokeArgs($this, $pass);
+        } catch (\ReflectionException) {
+            return false;
+        }
+    }
+    private function dispatchExecutionEvent(AbstractEventAccessor $config, LeadEventLog $log, $result): void
+    {
+        $eventArray = $this->getEventArray($log->getEvent());
+        $this->dispatcher->dispatch(
+            new CampaignExecutionEvent(
+                [
+                    'eventSettings'   => $config->getConfig(),
+                    'eventDetails'    => null, // @todo fix when procesing decisions,
+                    'event'           => $eventArray,
+                    'lead'            => $log->getLead(),
+                    'systemTriggered' => $log->getSystemTriggered(),
+                    'config'          => $eventArray['properties'],
+                ],
+                $result,
+                $log
+            ),
+            CampaignEvents::ON_EVENT_EXECUTION
+        );
+    }
+    private function dispatchExecutedEvent(AbstractEventAccessor $config, LeadEventLog $log): void
+    {
+        $this->dispatcher->dispatch(
+            new ExecutedEvent($config, $log),
+            CampaignEvents::ON_EVENT_EXECUTED
+        );
+        $collection = new ArrayCollection();
+        $collection->set($log->getId(), $log);
+        $this->dispatcher->dispatch(
+            new ExecutedBatchEvent($config, $log->getEvent(), $collection),
+            CampaignEvents::ON_EVENT_EXECUTED_BATCH
+        );
+    }
+    private function dispatchFailedEvent(AbstractEventAccessor $config, LeadEventLog $log): void
+    {
+        $this->dispatcher->dispatch(
+            new FailedEvent($config, $log),
+            CampaignEvents::ON_EVENT_FAILED
+        );
+    }
+    private function isFailed($result): bool
+    {
+        return
+            false === $result
+            || (is_array($result) && isset($result['result']) && false === $result['result']);
+    }
+    private function processFailedLog(LeadEventLog $log, PendingEvent $pendingEvent): void
+    {
+        $this->logger->debug(
+            'CAMPAIGN: '.ucfirst($log->getEvent()->getEventType() ?? 'unknown event').' ID# '.$log->getEvent()->getId().' for contact ID# '.$log->getLead()->getId()
+        );
+        $metadata = $log->getMetadata();
+        $reason = null;
+        if (isset($metadata['errors'])) {
+            $reason = (is_array($metadata['errors'])) ? implode('<br />', $metadata['errors']) : $metadata['errors'];
+        } elseif (isset($metadata['reason'])) {
+            $reason = $metadata['reason'];
+        }
+        $pendingEvent->fail($log, $reason);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Event/ActionExecutioner.php
@@ -0,0 +1,41 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
+use Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher;
+use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
+use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
+use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
+class ActionExecutioner implements EventInterface
+{
+    public const TYPE = 'action';
+    public function __construct(
+        private ActionDispatcher $dispatcher,
+        private EventLogger $eventLogger,
+    ) {
+    }
+    /**
+     * @throws CannotProcessEventException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     */
+    public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
+    {
+        \assert($config instanceof ActionAccessor);
+        /** @var LeadEventLog $firstLog */
+        if (!$firstLog = $logs->first()) {
+            return new EvaluatedContacts();
+        }
+        $event = $firstLog->getEvent();
+        if (Event::TYPE_ACTION !== $event->getEventType()) {
+            throw new CannotProcessEventException('Cannot process event ID '.$event->getId().' as an action.');
+        }
+        $pendingEvent = $this->dispatcher->dispatchEvent($config, $event, $logs);
+        $passed = $this->eventLogger->extractContactsFromLogs($pendingEvent->getSuccessful());
+        $failed = $this->eventLogger->extractContactsFromLogs($pendingEvent->getFailures());
+        return new EvaluatedContacts($passed, $failed);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Event/ConditionExecutioner.php
@@ -0,0 +1,54 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\ConditionAccessor;
+use Mautic\CampaignBundle\Executioner\Dispatcher\ConditionDispatcher;
+use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
+use Mautic\CampaignBundle\Executioner\Exception\ConditionFailedException;
+use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
+class ConditionExecutioner implements EventInterface
+{
+    public const TYPE = 'condition';
+    public function __construct(
+        private ConditionDispatcher $dispatcher,
+    ) {
+    }
+    /**
+     * @throws CannotProcessEventException
+     */
+    public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
+    {
+        \assert($config instanceof ConditionAccessor);
+        $evaluatedContacts = new EvaluatedContacts();
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            try {
+                /* @var ConditionAccessor $config */
+                $this->dispatchEvent($config, $log);
+                $evaluatedContacts->pass($log->getLead());
+            } catch (ConditionFailedException) {
+                $evaluatedContacts->fail($log->getLead());
+                $log->setNonActionPathTaken(true);
+            }
+            $log->setDateTriggered(new \DateTime());
+        }
+        return $evaluatedContacts;
+    }
+    /**
+     * @throws CannotProcessEventException
+     * @throws ConditionFailedException
+     */
+    private function dispatchEvent(ConditionAccessor $config, LeadEventLog $log): void
+    {
+        if (Event::TYPE_CONDITION !== $log->getEvent()->getEventType()) {
+            throw new CannotProcessEventException('Cannot process event ID '.$log->getEvent()->getId().' as a condition.');
+        }
+        $conditionEvent = $this->dispatcher->dispatchEvent($config, $log);
+        if (!$conditionEvent->wasConditionSatisfied()) {
+            throw new ConditionFailedException('evaluation failed');
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Event/DecisionExecutioner.php
@@ -0,0 +1,83 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Event;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
+use Mautic\CampaignBundle\Executioner\Dispatcher\DecisionDispatcher;
+use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
+use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
+use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
+use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
+use Mautic\LeadBundle\Entity\Lead;
+class DecisionExecutioner implements EventInterface
+{
+    public const TYPE = 'decision';
+    public function __construct(
+        private EventLogger $eventLogger,
+        private DecisionDispatcher $dispatcher,
+    ) {
+    }
+    /**
+     * @param mixed       $passthrough
+     * @param string|null $channel
+     * @param int|null    $channelId
+     *
+     * @throws CannotProcessEventException
+     * @throws DecisionNotApplicableException
+     */
+    public function evaluateForContact(DecisionAccessor $config, Event $event, Lead $contact, $passthrough = null, $channel = null, $channelId = null): void
+    {
+        if (Event::TYPE_DECISION !== $event->getEventType()) {
+            throw new CannotProcessEventException('Cannot process event ID '.$event->getId().' as a decision.');
+        }
+        $log = $this->eventLogger->buildLogEntry($event, $contact);
+        $log->setChannel($channel);
+        $log->setChannelId($channelId);
+        $decisionEvent = $this->dispatcher->dispatchRealTimeEvent($config, $log, $passthrough);
+        if (!$decisionEvent->wasDecisionApplicable()) {
+            throw new DecisionNotApplicableException('evaluation failed');
+        }
+        $this->eventLogger->persistLog($log);
+    }
+    /**
+     * @throws CannotProcessEventException
+     */
+    public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
+    {
+        \assert($config instanceof DecisionAccessor);
+        $evaluatedContacts = new EvaluatedContacts();
+        $failedLogs        = [];
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            if (Event::TYPE_DECISION !== $log->getEvent()->getEventType()) {
+                throw new CannotProcessEventException('Event ID '.$log->getEvent()->getId().' is not a decision');
+            }
+            try {
+                /* @var DecisionAccessor $config */
+                $this->dispatchEvent($config, $log);
+                $evaluatedContacts->pass($log->getLead());
+                $log->setDateTriggered(new \DateTime());
+            } catch (DecisionNotApplicableException) {
+                $failedLogs[] = $log;
+                $evaluatedContacts->fail($log->getLead());
+            }
+        }
+        $this->dispatcher->dispatchDecisionResultsEvent($config, $logs, $evaluatedContacts);
+        foreach ($failedLogs as $log) {
+            $logs->removeElement($log);
+        }
+        return $evaluatedContacts;
+    }
+    /**
+     * @throws DecisionNotApplicableException
+     */
+    private function dispatchEvent(DecisionAccessor $config, LeadEventLog $log): void
+    {
+        $decisionEvent = $this->dispatcher->dispatchEvaluationEvent($config, $log);
+        if (!$decisionEvent->wasDecisionApplicable()) {
+            throw new DecisionNotApplicableException('evaluation failed');
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Helper/DecisionHelper.php
@@ -0,0 +1,49 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Executioner\Helper;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
+use Mautic\LeadBundle\Entity\Lead;
+class DecisionHelper
+{
+    public function __construct(
+        private LeadRepository $leadRepository,
+    ) {
+    }
+    /**
+     * @throws DecisionNotApplicableException
+     */
+    public function checkIsDecisionApplicableForContact(Event $event, Lead $contact, ?string $channel = null, ?int $channelId = null): void
+    {
+        if (Event::TYPE_DECISION !== $event->getEventType()) {
+            @trigger_error(
+                "{$event->getType()} is not assigned to a decision and no longer supported. ".
+                'Check that you are executing RealTimeExecutioner::execute for an event registered as a decision.',
+                E_USER_DEPRECATED
+            );
+            throw new DecisionNotApplicableException("Event {$event->getId()} is not a decision.");
+        }
+        if ($channel && $event->getChannel() && !str_contains($channel, $event->getChannel())) {
+            throw new DecisionNotApplicableException("Channels, $channel and {$event->getChannel()}, do not match.");
+        }
+        if ($channel && $channelId && $event->getChannelId() && $channelId !== $event->getChannelId()) {
+            throw new DecisionNotApplicableException("Channel IDs, $channelId and {$event->getChannelId()}, do not match for $channel.");
+        }
+        $parentEvent = $event->getParent();
+        if (null !== $parentEvent && !$parentEvent->isDeleted() && null !== $event->getDecisionPath()) {
+            $rotation      = $this->leadRepository->getContactRotations([$contact->getId()], $event->getCampaign()->getId());
+            $rotationValue = isset($rotation[$contact->getId()]) ? $rotation[$contact->getId()]['rotation'] : null;
+            $log           = $parentEvent->getLogByContactAndRotation($contact, $rotationValue);
+            if (null === $log) {
+                throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} has not been fired, event {$event->getId()} should not be fired.");
+            }
+            $pathTaken   = (int) $log->getNonActionPathTaken();
+            if (1 === $pathTaken && !$parentEvent->getNegativeChildren()->contains($event)) {
+                throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} take negative path, event {$event->getId()} is on positive path.");
+            } elseif (0 === $pathTaken && !$parentEvent->getPositiveChildren()->contains($event)) {
+                throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} take positive path, event {$event->getId()} is on negative path.");
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Helper/InactiveHelper.php
@@ -0,0 +1,125 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Helper;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\EventRepository;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder;
+use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Psr\Log\LoggerInterface;
+class InactiveHelper
+{
+    private ?\DateTimeInterface $earliestInactiveDate = null;
+    public function __construct(
+        private EventScheduler $scheduler,
+        private InactiveContactFinder $inactiveContactFinder,
+        private LeadEventLogRepository $eventLogRepository,
+        private EventRepository $eventRepository,
+        private LoggerInterface $logger,
+        private DecisionHelper $decisionHelper,
+    ) {
+    }
+    /**
+     * @param ArrayCollection<int, Event> $decisions
+     */
+    public function removeDecisionsWithoutNegativeChildren(ArrayCollection $decisions): void
+    {
+        /**
+         * @var int   $key
+         * @var Event $decision
+         */
+        foreach ($decisions as $key => $decision) {
+            $negativeChildren = $decision->getNegativeChildren();
+            if (!$negativeChildren->count()) {
+                $decisions->remove($key);
+            }
+        }
+    }
+    /**
+     * @param int $lastActiveEventId
+     *
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    public function removeContactsThatAreNotApplicable(
+        \DateTime $now,
+        ArrayCollection $contacts,
+        $lastActiveEventId,
+        ArrayCollection $negativeChildren,
+        Event $event,
+    ): void {
+        $contactIds                 = $contacts->getKeys();
+        $lastActiveDates            = $this->getLastActiveDates($lastActiveEventId, $contactIds);
+        $this->earliestInactiveDate = $now;
+        foreach ($contactIds as $contactId) {
+            try {
+                $this->decisionHelper->checkIsDecisionApplicableForContact($event, $contacts->get($contactId));
+            } catch (DecisionNotApplicableException $e) {
+                $this->logger->debug($e->getMessage());
+                $contacts->remove($contactId);
+                continue;
+            }
+            if (!isset($lastActiveDates[$contactId])) {
+                $contacts->remove($contactId);
+                $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' does not have a last active date ('.$lastActiveEventId.')');
+                continue;
+            }
+            $earliestContactInactiveDate = $this->getEarliestInactiveDate($negativeChildren, $lastActiveDates[$contactId]);
+            $this->logger->debug(
+                'CAMPAIGN: Earliest date for inactivity for contact ID# '.$contactId.' is '.
+                $earliestContactInactiveDate->format('Y-m-d H:i:s T').' based on last active date of '.
+                $lastActiveDates[$contactId]->format('Y-m-d H:i:s T')
+            );
+            if ($this->earliestInactiveDate < $earliestContactInactiveDate) {
+                $this->earliestInactiveDate = $earliestContactInactiveDate;
+            }
+            if ($earliestContactInactiveDate > $now) {
+                $contacts->remove($contactId);
+                $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' has been active and thus not applicable');
+                continue;
+            }
+            $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' has not been active');
+        }
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    public function getEarliestInactiveDateTime()
+    {
+        return $this->earliestInactiveDate;
+    }
+    public function getCollectionByDecisionId($decisionId): ArrayCollection
+    {
+        $collection = new ArrayCollection();
+        /** @var Event|null $decision */
+        $decision = $this->eventRepository->find($decisionId);
+        if ($decision && !$decision->isDeleted()) {
+            $collection->set($decision->getId(), $decision);
+        }
+        return $collection;
+    }
+    /**
+     * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
+     */
+    public function getEarliestInactiveDate(ArrayCollection $negativeChildren, \DateTimeInterface $lastActiveDate): ?\DateTimeInterface
+    {
+        $earliestDate = null;
+        foreach ($negativeChildren as $event) {
+            $executionDate = $this->scheduler->getExecutionDateTime($event, $lastActiveDate);
+            if (!$earliestDate || $executionDate < $earliestDate) {
+                $earliestDate = $executionDate;
+            }
+        }
+        return $earliestDate;
+    }
+    /**
+     * @return array<string, \DateTimeInterface>|null
+     */
+    private function getLastActiveDates($lastActiveEventId, array $contactIds): ?array
+    {
+        if ($lastActiveEventId) {
+            return $this->eventLogRepository->getDatesExecuted($lastActiveEventId, $contactIds);
+        }
+        return $this->inactiveContactFinder->getDatesAdded();
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Helper/NotificationHelper.php
@@ -0,0 +1,121 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Helper;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Model\NotificationModel;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\UserBundle\Entity\User;
+use Mautic\UserBundle\Model\UserModel;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Component\Routing\Router;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class NotificationHelper
+{
+    public function __construct(
+        private UserModel $userModel,
+        private NotificationModel $notificationModel,
+        private TranslatorInterface $translator,
+        private Router $router,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    public function notifyOfFailure(Lead $contact, Event $event): void
+    {
+        $user = $this->getUser($contact, $event);
+        if (!$user || !$user->getId()) {
+            return;
+        }
+        $this->notificationModel->addNotification(
+            $event->getCampaign()->getName().' / '.$event->getName(),
+            'error',
+            false,
+            $this->translator->trans(
+                'mautic.campaign.event.failed',
+                [
+                    '%contact%' => '<a href="'.$this->router->generate(
+                        'mautic_contact_action',
+                        ['objectAction' => 'view', 'objectId' => $contact->getId()]
+                    ).'" data-toggle="ajax">'.$contact->getPrimaryIdentifier().'</a>',
+                ]
+            ),
+            null,
+            null,
+            $user
+        );
+    }
+    public function notifyOfUnpublish(Event $event): void
+    {
+        /**
+         * Pass a fake lead so we can just get the campaign creator.
+         */
+        $user = $this->getUser(new Lead(), $event);
+        if (!$user || !$user->getId()) {
+            return;
+        }
+        $campaign = $event->getCampaign();
+        $this->notificationModel->addNotification(
+            $campaign->getName().' / '.$event->getName(),
+            'error',
+            false,
+            $this->translator->trans(
+                'mautic.campaign.event.failed.campaign.unpublished',
+                [
+                    '%campaign%' => '<a href="'.$this->router->generate(
+                        'mautic_campaign_action',
+                        [
+                            'objectAction' => 'view',
+                            'objectId'     => $campaign->getId(),
+                        ],
+                        UrlGeneratorInterface::ABSOLUTE_URL
+                    ).'" data-toggle="ajax">'.$campaign->getName().'</a>',
+                    '%event%' => $event->getName(),
+                ]
+            ),
+            null,
+            null,
+            $user
+        );
+        $subject = $this->translator->trans(
+            'mautic.campaign.event.campaign_unpublished',
+            [
+                '%title%' => $campaign->getName(),
+            ]
+        );
+        $content = $this->translator->trans(
+            'mautic.campaign.event.failed.campaign.unpublished',
+            [
+                '%campaign%' => '<a href="'.$this->router->generate(
+                    'mautic_campaign_action',
+                    [
+                        'objectAction' => 'view',
+                        'objectId'     => $campaign->getId(),
+                    ],
+                    UrlGeneratorInterface::ABSOLUTE_URL
+                ).'" data-toggle="ajax">'.$campaign->getName().'</a>',
+                '%event%' => $event->getName(),
+            ]
+        );
+        $sendToAuthor = $this->coreParametersHelper->get('campaign_send_notification_to_author', 1);
+        if ($sendToAuthor) {
+            $this->userModel->emailUser($user, $subject, $content);
+        } else {
+            $emailAddresses =  array_map('trim', explode(',', $this->coreParametersHelper->get('campaign_notification_email_addresses')));
+            $this->userModel->sendMailToEmailAddresses($emailAddresses, $subject, $content);
+        }
+    }
+    /**
+     * @return User|null
+     */
+    private function getUser(Lead $contact, Event $event)
+    {
+        if ($owner = $contact->getOwner()) {
+            return $owner;
+        }
+        if ($campaignCreator = $event->getCampaign()->getCreatedBy()) {
+            if ($owner = $this->userModel->getEntity($campaignCreator)) {
+                return $owner;
+            }
+        }
+        return $this->userModel->getSystemAdministrator();
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/InactiveExecutioner.php
@@ -0,0 +1,230 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
+use Mautic\CampaignBundle\Executioner\Helper\InactiveHelper;
+use Mautic\CampaignBundle\Executioner\Result\Counter;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CoreBundle\Helper\ProgressBarHelper;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Output\NullOutput;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class InactiveExecutioner implements ExecutionerInterface
+{
+    /**
+     * @var Campaign
+     */
+    private $campaign;
+    private ?ContactLimiter $limiter = null;
+    private ?OutputInterface $output = null;
+    private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
+    private ?Counter $counter = null;
+    private ?ArrayCollection $decisions = null;
+    protected ?\DateTime $now = null;
+    public function __construct(
+        private InactiveContactFinder $inactiveContactFinder,
+        private LoggerInterface $logger,
+        private TranslatorInterface $translator,
+        private EventScheduler $scheduler,
+        private InactiveHelper $helper,
+        private EventExecutioner $executioner,
+    ) {
+    }
+    /**
+     * @return Counter
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
+    {
+        $this->campaign = $campaign;
+        $this->limiter  = $limiter;
+        $this->output   = $output ?: new NullOutput();
+        $this->counter  = new Counter();
+        try {
+            $this->decisions = $this->campaign->getEventsByType(Event::TYPE_DECISION);
+            $this->prepareForExecution();
+            $this->executeEvents();
+        } catch (NoContactsFoundException) {
+            $this->logger->debug('CAMPAIGN: No more contacts to process');
+        } catch (NoEventsFoundException) {
+            $this->logger->debug('CAMPAIGN: No events to process');
+        } finally {
+            if ($this->progressBar) {
+                $this->progressBar->finish();
+            }
+        }
+        return $this->counter;
+    }
+    /**
+     * @param int $decisionId
+     *
+     * @return Counter
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    public function validate($decisionId, ContactLimiter $limiter, OutputInterface $output = null)
+    {
+        $this->limiter = $limiter;
+        $this->output  = $output ?: new NullOutput();
+        $this->counter = new Counter();
+        try {
+            $this->decisions = $this->helper->getCollectionByDecisionId($decisionId);
+            $this->checkCampaignIsPublished();
+            $this->prepareForExecution();
+            $this->executeEvents();
+        } catch (NoContactsFoundException) {
+            $this->logger->debug('CAMPAIGN: No more contacts to process');
+        } catch (NoEventsFoundException) {
+            $this->logger->debug('CAMPAIGN: No events to process');
+        } finally {
+            if ($this->progressBar) {
+                $this->progressBar->finish();
+            }
+        }
+        return $this->counter;
+    }
+    /**
+     * @throws NoEventsFoundException
+     */
+    private function checkCampaignIsPublished(): void
+    {
+        if (!$this->decisions->count()) {
+            throw new NoEventsFoundException();
+        }
+        $this->campaign = $this->decisions->first()->getCampaign();
+        if (!$this->campaign->isPublished()) {
+            throw new NoEventsFoundException();
+        }
+        if ($this->campaign->isDeleted()) {
+            throw new NoEventsFoundException();
+        }
+    }
+    /**
+     * @throws NoContactsFoundException
+     * @throws NoEventsFoundException
+     */
+    private function prepareForExecution(): void
+    {
+        $this->logger->debug('CAMPAIGN: Triggering inaction events');
+        $this->helper->removeDecisionsWithoutNegativeChildren($this->decisions);
+        $totalDecisions = $this->decisions->count();
+        if (!$totalDecisions) {
+            throw new NoEventsFoundException();
+        }
+        $totalContacts = 0;
+        if (!($this->output instanceof NullOutput)) {
+            $totalContacts = $this->inactiveContactFinder->getContactCount($this->campaign->getId(), $this->decisions->getKeys(), $this->limiter);
+            $this->output->writeln(
+                $this->translator->trans(
+                    'mautic.campaign.trigger.decision_count_analyzed',
+                    [
+                        '%decisions%' => $totalDecisions,
+                        '%leads%'     => $totalContacts,
+                        '%batch%'     => $this->limiter->getBatchLimit(),
+                    ]
+                )
+            );
+            if (!$totalContacts) {
+                throw new NoContactsFoundException();
+            }
+        }
+        $this->progressBar = ProgressBarHelper::init($this->output, $totalContacts * $totalDecisions);
+        $this->progressBar->start();
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    private function executeEvents(): void
+    {
+        $now = $this->now ?? new \DateTime();
+        /** @var Event $decisionEvent */
+        foreach ($this->decisions as $decisionEvent) {
+            try {
+                $parentEvent   = $decisionEvent->getParent();
+                $parentEventId = $parentEvent && !$parentEvent->isDeleted() ? $parentEvent->getId() : null;
+                $contacts = $this->inactiveContactFinder->getContacts($this->campaign->getId(), $decisionEvent, $this->limiter);
+                while ($contacts->count()) {
+                    $batchMinContactId = max($contacts->getKeys()) + 1;
+                    $this->progressBar->advance($contacts->count());
+                    $this->counter->advanceEvaluated($contacts->count());
+                    $inactiveEvents = $decisionEvent->getNegativeChildren();
+                    $this->helper->removeContactsThatAreNotApplicable($now, $contacts, $parentEventId, $inactiveEvents, $decisionEvent);
+                    $earliestLastActiveDateTime = $this->helper->getEarliestInactiveDateTime();
+                    $this->logger->debug(
+                        'CAMPAIGN: ('.$decisionEvent->getId().') Earliest date for inactivity for this batch of contacts is '.
+                        $earliestLastActiveDateTime->format('Y-m-d H:i:s T')
+                    );
+                    if ($contacts->count()) {
+                        $this->executioner->recordLogsAsExecutedForEvent($decisionEvent, $contacts, true);
+                        $this->executeLogsForInactiveEvents($inactiveEvents, $contacts, $this->counter, $earliestLastActiveDateTime);
+                    }
+                    $this->inactiveContactFinder->clear($contacts);
+                    if ($this->limiter->getContactId()) {
+                        break;
+                    }
+                    $this->logger->debug('CAMPAIGN: Fetching the next batch of inactive contacts starting with contact ID '.$batchMinContactId);
+                    $this->limiter->setBatchMinContactId($batchMinContactId);
+                    $contacts = $this->inactiveContactFinder->getContacts($this->campaign->getId(), $decisionEvent, $this->limiter);
+                }
+            } catch (NoContactsFoundException) {
+                $this->logger->debug('CAMPAIGN: No more contacts to process for decision ID #'.$decisionEvent->getId());
+            }
+            $this->limiter->resetBatchMinContactId();
+        }
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    private function executeLogsForInactiveEvents(ArrayCollection $events, ArrayCollection $contacts, Counter $childrenCounter, \DateTimeInterface $earliestLastActiveDateTime): void
+    {
+        $events              = clone $events;
+        $eventExecutionDates = $this->scheduler->getSortedExecutionDates($events, $earliestLastActiveDateTime);
+        /** @var \DateTime $earliestExecutionDate */
+        $earliestExecutionDate = reset($eventExecutionDates);
+        $executionDate = $this->executioner->getExecutionDate();
+        foreach ($events as $key => $event) {
+            if (Event::TYPE_DECISION == $event->getEventType()) {
+                $this->logger->debug('CAMPAIGN: Ignoring child event ID '.$event->getId().' as a decision');
+                $events->remove($key);
+                continue;
+            }
+            $eventExecutionDate = $this->scheduler->getExecutionDateForInactivity(
+                $eventExecutionDates[$event->getId()],
+                $earliestExecutionDate,
+                $executionDate
+            );
+            $this->logger->debug(
+                'CAMPAIGN: Event ID# '.$event->getId().
+                ' to be executed on '.$eventExecutionDate->format('Y-m-d H:i:s e')
+            );
+            if ($this->scheduler->shouldScheduleEvent($event, $eventExecutionDate, $executionDate)) {
+                $childrenCounter->advanceTotalScheduled($contacts->count());
+                $this->scheduler->schedule($event, $eventExecutionDate, $contacts, true);
+                $events->remove($key);
+                continue;
+            }
+        }
+        if ($events->count()) {
+            $this->executioner->executeEventsForContacts($events, $contacts, $childrenCounter, true);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/KickoffExecutioner.php
@@ -0,0 +1,139 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Executioner\ContactFinder\KickoffContactFinder;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
+use Mautic\CampaignBundle\Executioner\Result\Counter;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
+use Mautic\CoreBundle\Helper\ProgressBarHelper;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Output\NullOutput;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class KickoffExecutioner implements ExecutionerInterface
+{
+    private ?ContactLimiter $limiter = null;
+    private ?Campaign $campaign = null;
+    private ?OutputInterface $output = null;
+    private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
+    private ?\Doctrine\Common\Collections\ArrayCollection $rootEvents = null;
+    private ?Counter $counter = null;
+    public function __construct(
+        private LoggerInterface $logger,
+        private KickoffContactFinder $kickoffContactFinder,
+        private TranslatorInterface $translator,
+        private EventExecutioner $executioner,
+        private EventScheduler $scheduler,
+    ) {
+    }
+    /**
+     * @return Counter
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws NotSchedulableException
+     */
+    public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
+    {
+        $this->campaign = $campaign;
+        $this->limiter  = $limiter;
+        $this->output   = $output ?: new NullOutput();
+        $this->counter  = new Counter();
+        try {
+            $this->prepareForExecution();
+            $this->executeOrScheduleEvent();
+        } catch (NoContactsFoundException) {
+            $this->logger->debug('CAMPAIGN: No more contacts to process');
+        } catch (NoEventsFoundException) {
+            $this->logger->debug('CAMPAIGN: No events to process');
+        } finally {
+            if ($this->progressBar) {
+                $this->progressBar->finish();
+            }
+            $this->executioner->persistSummaries();
+        }
+        return $this->counter;
+    }
+    /**
+     * @throws NoEventsFoundException
+     */
+    private function prepareForExecution(): void
+    {
+        $this->logger->debug('CAMPAIGN: Triggering kickoff events');
+        $this->rootEvents = $this->campaign->getRootEvents();
+        $totalRootEvents  = $this->rootEvents->count();
+        if (!$totalRootEvents) {
+            throw new NoEventsFoundException();
+        }
+        $this->logger->debug('CAMPAIGN: Processing the following events: '.implode(', ', $this->rootEvents->getKeys()));
+        $totalKickoffEvents = 0;
+        if (!($this->output instanceof NullOutput)) {
+            $totalContacts      = $this->kickoffContactFinder->getContactCount($this->campaign->getId(), $this->rootEvents->getKeys(), $this->limiter);
+            $totalKickoffEvents = $totalRootEvents * $totalContacts;
+            $this->output->writeln(
+                $this->translator->trans(
+                    'mautic.campaign.trigger.event_count',
+                    [
+                        '%events%' => $totalKickoffEvents,
+                        '%batch%'  => $this->limiter->getBatchLimit(),
+                    ]
+                )
+            );
+            if (!$totalKickoffEvents) {
+                throw new NoEventsFoundException();
+            }
+        }
+        $this->progressBar = ProgressBarHelper::init($this->output, $totalKickoffEvents);
+        $this->progressBar->start();
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws NoContactsFoundException
+     * @throws NotSchedulableException
+     */
+    private function executeOrScheduleEvent(): void
+    {
+        $now = new \DateTime();
+        $this->counter->advanceEventCount($this->rootEvents->count());
+        $contacts = $this->kickoffContactFinder->getContacts($this->campaign->getId(), $this->limiter);
+        while ($contacts && $contacts->count()) {
+            $batchMinContactId = max($contacts->getKeys()) + 1;
+            $rootEvents        = clone $this->rootEvents;
+            /** @var Event $event */
+            foreach ($rootEvents as $key => $event) {
+                $this->progressBar->advance($contacts->count());
+                $this->counter->advanceEvaluated($contacts->count());
+                try {
+                    $executionDate = $this->scheduler->getExecutionDateTime($event, $now);
+                    $this->logger->debug(
+                        'CAMPAIGN: Event ID# '.$event->getId().
+                        ' to be executed on '.$executionDate->format('Y-m-d H:i:s e').
+                        ' compared to '.$now->format('Y-m-d H:i:s e')
+                    );
+                    $this->scheduler->validateAndScheduleEventForContacts($event, $executionDate, $contacts, $now);
+                    $this->counter->advanceTotalScheduled($contacts->count());
+                    $rootEvents->remove($key);
+                    continue;
+                } catch (NotSchedulableException) {
+                }
+            }
+            if ($rootEvents->count()) {
+                $this->executioner->executeEventsForContacts($rootEvents, $contacts, $this->counter);
+            }
+            $this->kickoffContactFinder->clear($contacts);
+            if ($this->limiter->getContactId()) {
+                break;
+            }
+            $this->logger->debug('CAMPAIGN: Fetching the next batch of kickoff contacts starting with contact ID '.$batchMinContactId);
+            $this->limiter->setBatchMinContactId($batchMinContactId);
+            $contacts = $this->kickoffContactFinder->getContacts($this->campaign->getId(), $this->limiter);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Logger/EventLogger.php
@@ -0,0 +1,168 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Logger;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\Helper\ChannelExtractor;
+use Mautic\CampaignBundle\Model\SummaryModel;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+class EventLogger
+{
+    private ArrayCollection $persistQueue;
+    private ArrayCollection $logs;
+    private array $contactRotations = [];
+    /**
+     * @var int
+     */
+    private $lastUsedCampaignIdToFetchRotation;
+    public function __construct(
+        private IpLookupHelper $ipLookupHelper,
+        private ContactTracker $contactTracker,
+        private LeadEventLogRepository $leadEventLogRepository,
+        private LeadRepository $leadRepository,
+        private SummaryModel $summaryModel,
+    ) {
+        $this->persistQueue = new ArrayCollection();
+        $this->logs         = new ArrayCollection();
+    }
+    public function queueToPersist(LeadEventLog $log): void
+    {
+        $this->persistQueue->add($log);
+        if ($this->persistQueue->count() >= 20) {
+            $this->persistPendingAndInsertIntoLogStack();
+        }
+    }
+    public function persistLog(LeadEventLog $log): void
+    {
+        $this->leadEventLogRepository->saveEntity($log);
+        $this->summaryModel->updateSummary([$log]);
+    }
+    /**
+     * @param bool $isInactiveEvent
+     */
+    public function buildLogEntry(Event $event, Lead $contact = null, $isInactiveEvent = false): LeadEventLog
+    {
+        $log = new LeadEventLog();
+        if (!defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED')) {
+            $log->setIpAddress($this->ipLookupHelper->getIpAddress());
+        }
+        $log->setEvent($event);
+        $log->setCampaign($event->getCampaign());
+        if (null === $contact) {
+            $contact = $this->contactTracker->getContact();
+        }
+        $log->setLead($contact);
+        if ($isInactiveEvent) {
+            $log->setNonActionPathTaken(true);
+        }
+        $log->setDateTriggered(new \DateTime());
+        $log->setSystemTriggered(defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED'));
+        if (isset($this->contactRotations[$contact->getId()]) && ($this->lastUsedCampaignIdToFetchRotation === $event->getCampaign()->getId())) {
+            $log->setRotation($this->contactRotations[$contact->getId()]['rotation']);
+        } else {
+            $rotations   = $this->leadRepository->getContactRotations([$contact->getId()], $event->getCampaign()->getId());
+            $rotationVal = isset($rotations[$contact->getId()]) ? $rotations[$contact->getId()]['rotation'] : 1;
+            $log->setRotation($rotationVal);
+        }
+        return $log;
+    }
+    /**
+     * Persist the queue, clear the entities from memory, and reset the queue.
+     *
+     * @return ArrayCollection
+     */
+    public function persistQueuedLogs()
+    {
+        $this->persistPendingAndInsertIntoLogStack();
+        $logs = clone $this->logs;
+        $this->logs->clear();
+        return $logs;
+    }
+    public function persistCollection(ArrayCollection $collection): self
+    {
+        if (!$collection->count()) {
+            return $this;
+        }
+        $this->leadEventLogRepository->saveEntities($collection->getValues());
+        $this->summaryModel->updateSummary($collection->getValues());
+        return $this;
+    }
+    public function clearCollection(ArrayCollection $collection): self
+    {
+        $this->leadEventLogRepository->detachEntities($collection->getValues());
+        return $this;
+    }
+    public function extractContactsFromLogs(ArrayCollection $logs): ArrayCollection
+    {
+        $contacts = new ArrayCollection();
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $contact = $log->getLead();
+            $contacts->set($contact->getId(), $contact);
+        }
+        return $contacts;
+    }
+    /**
+     * @param bool $isInactiveEntry
+     *
+     * @return ArrayCollection
+     */
+    public function fetchRotationAndGenerateLogsFromContacts(Event $event, AbstractEventAccessor $config, ArrayCollection $contacts, $isInactiveEntry = false)
+    {
+        $this->hydrateContactRotationsForNewLogs($contacts->getKeys(), $event->getCampaign()->getId());
+        return $this->generateLogsFromContacts($event, $config, $contacts, $isInactiveEntry);
+    }
+    /**
+     * @param bool $isInactiveEntry
+     *
+     * @return ArrayCollection
+     */
+    public function generateLogsFromContacts(Event $event, AbstractEventAccessor $config, ArrayCollection $contacts, $isInactiveEntry)
+    {
+        $isDecision = Event::TYPE_DECISION === $event->getEventType();
+        foreach ($contacts as $contact) {
+            if (isset($this->contactRotations[$contact->getId()]) && $this->contactRotations[$contact->getId()]['manually_removed']) {
+                continue;
+            }
+            $log = $this->buildLogEntry($event, $contact, $isInactiveEntry);
+            $log->setIsScheduled(false);
+            $log->setDateTriggered(new \DateTime());
+            ChannelExtractor::setChannel($log, $event, $config);
+            if ($isDecision) {
+                $this->logs->add($log);
+            } else {
+                $this->queueToPersist($log);
+            }
+        }
+        return $this->persistQueuedLogs();
+    }
+    /**
+     * @param int $campaignId
+     */
+    public function hydrateContactRotationsForNewLogs(array $contactIds, $campaignId): void
+    {
+        $this->contactRotations                  = $this->leadRepository->getContactRotations($contactIds, $campaignId);
+        $this->lastUsedCampaignIdToFetchRotation = $campaignId;
+    }
+    private function persistPendingAndInsertIntoLogStack(): void
+    {
+        if (!$this->persistQueue->count()) {
+            return;
+        }
+        $this->leadEventLogRepository->saveEntities($this->persistQueue->getValues());
+        /** @var LeadEventLog $log */
+        foreach ($this->persistQueue as $log) {
+            $this->logs->set($log->getId(), $log);
+        }
+        $this->persistQueue->clear();
+    }
+    public function getSummaryModel(): SummaryModel
+    {
+        return $this->summaryModel;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/RealTimeExecutioner.php
@@ -0,0 +1,162 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\EventRepository;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\Executioner\Event\DecisionExecutioner as Executioner;
+use Mautic\CampaignBundle\Executioner\Exception\CampaignNotExecutableException;
+use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
+use Mautic\CampaignBundle\Executioner\Helper\DecisionHelper;
+use Mautic\CampaignBundle\Executioner\Result\Responses;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CampaignBundle\Helper\ChannelExtractor;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\LeadModel;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+use Psr\Log\LoggerInterface;
+class RealTimeExecutioner
+{
+    /**
+     * @var Lead
+     */
+    private $contact;
+    /**
+     * @var array
+     */
+    private $events;
+    private ?Responses $responses = null;
+    public function __construct(
+        private LoggerInterface $logger,
+        private LeadModel $leadModel,
+        private EventRepository $eventRepository,
+        private EventExecutioner $executioner,
+        private Executioner $decisionExecutioner,
+        private EventCollector $collector,
+        private EventScheduler $scheduler,
+        private ContactTracker $contactTracker,
+        private DecisionHelper $decisionHelper,
+    ) {
+    }
+    /**
+     * @param string      $type
+     * @param mixed       $passthrough
+     * @param string|null $channel
+     * @param int|null    $channelId
+     *
+     * @return Responses
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    public function execute($type, $passthrough = null, $channel = null, $channelId = null)
+    {
+        $this->responses = new Responses();
+        $now             = new \DateTime();
+        $this->logger->debug('CAMPAIGN: Campaign triggered for event type '.$type.'('.$channel.' / '.$channelId.')');
+        defined('MAUTIC_CAMPAIGN_NOT_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_NOT_SYSTEM_TRIGGERED', 1);
+        try {
+            $this->fetchCurrentContact();
+        } catch (CampaignNotExecutableException $exception) {
+            $this->logger->debug('CAMPAIGN: '.$exception->getMessage());
+            return $this->responses;
+        }
+        try {
+            $this->fetchCampaignData($type);
+        } catch (CampaignNotExecutableException $exception) {
+            $this->logger->debug('CAMPAIGN: '.$exception->getMessage());
+            return $this->responses;
+        }
+        /** @var Event $event */
+        foreach ($this->events as $event) {
+            try {
+                $this->evaluateDecisionForContact($event, $passthrough, $channel, $channelId);
+            } catch (DecisionNotApplicableException $exception) {
+                $this->logger->debug('CAMPAIGN: Event ID '.$event->getId().' is not applicable ('.$exception->getMessage().')');
+                continue;
+            }
+            $children = $event->getPositiveChildren();
+            if (!$children->count()) {
+                $this->logger->debug('CAMPAIGN: Event ID '.$event->getId().' has no positive children');
+                continue;
+            }
+            $this->executeAssociatedEvents($children, $now);
+        }
+        if ($this->contact->getChanges()) {
+            $this->leadModel->saveEntity($this->contact, false);
+        }
+        return $this->responses;
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    private function executeAssociatedEvents(ArrayCollection $children, \DateTime $now): void
+    {
+        $children = clone $children;
+        /** @var Event $child */
+        foreach ($children as $key => $child) {
+            $executionDate = $this->scheduler->getExecutionDateTime($child, $now);
+            $this->logger->debug(
+                'CAMPAIGN: Event ID# '.$child->getId().
+                ' to be executed on '.$executionDate->format('Y-m-d H:i:s e')
+            );
+            if ($this->scheduler->shouldSchedule($executionDate, $now)) {
+                $this->scheduler->scheduleForContact($child, $executionDate, $this->contact);
+                $children->remove($key);
+            }
+        }
+        if ($children->count()) {
+            $this->executioner->executeEventsForContact($children, $this->contact, $this->responses);
+        }
+    }
+    /**
+     * @param mixed       $passthrough
+     * @param string|null $channel
+     * @param int|null    $channelId
+     *
+     * @throws DecisionNotApplicableException
+     * @throws Exception\CannotProcessEventException
+     */
+    private function evaluateDecisionForContact(Event $event, $passthrough = null, $channel = null, $channelId = null): void
+    {
+        $this->logger->debug('CAMPAIGN: Executing '.$event->getType().' ID '.$event->getId().' for contact ID '.$this->contact->getId());
+        $this->decisionHelper->checkIsDecisionApplicableForContact($event, $this->contact, $channel, $channelId);
+        /** @var DecisionAccessor $config */
+        $config = $this->collector->getEventConfig($event);
+        $this->decisionExecutioner->evaluateForContact($config, $event, $this->contact, $passthrough, $channel, $channelId);
+    }
+    /**
+     * @throws CampaignNotExecutableException
+     */
+    private function fetchCurrentContact(): void
+    {
+        $this->contact = $this->contactTracker->getContact();
+        if (!$this->contact instanceof Lead || !$this->contact->getId()) {
+            throw new CampaignNotExecutableException('Unidentifiable contact');
+        }
+        $this->logger->debug('CAMPAIGN: Current contact ID# '.$this->contact->getId());
+    }
+    /**
+     * @throws CampaignNotExecutableException
+     */
+    private function fetchCampaignData($type): void
+    {
+        if (!$this->events = $this->eventRepository->getContactPendingEvents($this->contact->getId(), $type)) {
+            throw new CampaignNotExecutableException('Contact does not have any applicable '.$type.' associations.');
+        }
+        /** @var Event $event */
+        foreach ($this->events as $event) {
+            if (1 === $event->getChannelId()) {
+                ChannelExtractor::setChannel($event, $event, $this->collector->getEventConfig($event));
+                $this->eventRepository->saveEntity($event);
+            }
+        }
+        $this->logger->debug('CAMPAIGN: Found '.count($this->events).' events to analyze for contact ID '.$this->contact->getId());
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Result/Counter.php
@@ -0,0 +1,112 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Result;
+class Counter
+{
+    /**
+     * @param int $eventCount
+     * @param int $evaluated
+     * @param int $executed
+     * @param int $totalEvaluated
+     * @param int $totalExecuted
+     * @param int $totalScheduled
+     */
+    public function __construct(
+        private $eventCount = 0,
+        private $evaluated = 0,
+        private $executed = 0,
+        private $totalEvaluated = 0,
+        private $totalExecuted = 0,
+        private $totalScheduled = 0,
+    ) {
+    }
+    /**
+     * @return int
+     */
+    public function getEventCount()
+    {
+        return $this->eventCount;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceEventCount($step = 1): void
+    {
+        $this->eventCount += $step;
+    }
+    /**
+     * @return int
+     */
+    public function getEvaluated()
+    {
+        return $this->evaluated;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceEvaluated($step = 1): void
+    {
+        $this->evaluated += $step;
+        $this->totalEvaluated += $step;
+    }
+    /**
+     * @return int
+     */
+    public function getExecuted()
+    {
+        return $this->executed;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceExecuted($step = 1): void
+    {
+        $this->executed += $step;
+        $this->totalExecuted += $step;
+    }
+    /**
+     * Includes all child events (conditions, etc) evaluated.
+     *
+     * @return int
+     */
+    public function getTotalEvaluated()
+    {
+        return $this->totalEvaluated;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceTotalEvaluated($step = 1): void
+    {
+        $this->totalEvaluated += $step;
+    }
+    /**
+     * Includes all child events (conditions, etc) executed.
+     *
+     * @return int
+     */
+    public function getTotalExecuted()
+    {
+        return $this->totalExecuted;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceTotalExecuted($step = 1): void
+    {
+        $this->totalExecuted += $step;
+    }
+    /**
+     * @return int
+     */
+    public function getTotalScheduled()
+    {
+        return $this->totalScheduled;
+    }
+    /**
+     * @param int $step
+     */
+    public function advanceTotalScheduled($step = 1): void
+    {
+        $this->totalScheduled += $step;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/ScheduledExecutioner.php
@@ -0,0 +1,250 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\EventListener\CampaignActionJumpToEventSubscriber;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Executioner\ContactFinder\ScheduledContactFinder;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
+use Mautic\CampaignBundle\Executioner\Result\Counter;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CoreBundle\Helper\ProgressBarHelper;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Output\NullOutput;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Service\ResetInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ScheduledExecutioner implements ExecutionerInterface, ResetInterface
+{
+    private ?Campaign $campaign = null;
+    private ?ContactLimiter $limiter = null;
+    private ?OutputInterface $output = null;
+    private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
+    private ?array $scheduledEvents = null;
+    private ?Counter $counter = null;
+    protected ?\DateTime $now = null;
+    public function __construct(
+        private LeadEventLogRepository $repo,
+        private LoggerInterface $logger,
+        private TranslatorInterface $translator,
+        private EventExecutioner $executioner,
+        private EventScheduler $scheduler,
+        private ScheduledContactFinder $scheduledContactFinder,
+    ) {
+    }
+    /**
+     * @return Counter|mixed
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
+    {
+        $this->campaign   = $campaign;
+        $this->limiter    = $limiter;
+        $this->output     = $output ?: new NullOutput();
+        $this->counter    = new Counter();
+        $this->logger->debug('CAMPAIGN: Triggering scheduled events');
+        try {
+            $this->prepareForExecution();
+            $this->executeOrRescheduleEvent();
+        } catch (NoEventsFoundException) {
+            $this->logger->debug('CAMPAIGN: No events to process');
+        } finally {
+            if ($this->progressBar) {
+                $this->progressBar->finish();
+            }
+        }
+        return $this->counter;
+    }
+    /**
+     * @return Counter
+     *
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    public function executeByIds(array $logIds, OutputInterface $output = null, ?\DateTime $now = null)
+    {
+        $now           = $now ?? $this->now ?? new \DateTime();
+        $this->output  = $output ?: new NullOutput();
+        $this->counter = new Counter();
+        if (!$logIds) {
+            return $this->counter;
+        }
+        $logs           = $this->repo->getScheduledByIds($logIds);
+        $totalLogsFound = $logs->count();
+        $this->counter->advanceEvaluated($totalLogsFound);
+        $this->logger->debug('CAMPAIGN: '.$logs->count().' events scheduled to execute.');
+        $this->output->writeln(
+            $this->translator->trans(
+                'mautic.campaign.trigger.event_count',
+                [
+                    '%events%' => $totalLogsFound,
+                    '%batch%'  => 'n/a',
+                ]
+            )
+        );
+        if (!$logs->count()) {
+            return $this->counter;
+        }
+        $this->progressBar = ProgressBarHelper::init($this->output, $totalLogsFound);
+        $this->progressBar->start();
+        $scheduledLogCount = $totalLogsFound - $logs->count();
+        $this->progressBar->advance($scheduledLogCount);
+        $organized = $this->organizeByEvent($logs);
+        foreach ($organized as $organizedLogs) {
+            /** @var Event $event */
+            $event = $organizedLogs->first()->getEvent();
+            $this->validateSchedule($organizedLogs, $now, true);
+            if ($event->getCampaign()->isPublished()) {
+                try {
+                    $this->scheduledContactFinder->hydrateContacts($organizedLogs);
+                    $this->executioner->executeLogs($event, $organizedLogs, $this->counter);
+                } catch (NoContactsFoundException) {
+                }
+            }
+            $this->progressBar->advance($organizedLogs->count());
+        }
+        $this->progressBar->finish();
+        return $this->counter;
+    }
+    public function reset(): void
+    {
+        $this->now = null;
+    }
+    /**
+     * @throws NoEventsFoundException
+     */
+    private function prepareForExecution(): void
+    {
+        $this->now ??= new \DateTime();
+        $scheduledEvents       = $this->repo->getScheduledCounts($this->campaign->getId(), $this->now, $this->limiter);
+        $totalScheduledCount   = $scheduledEvents ? array_sum($scheduledEvents) : 0;
+        $this->scheduledEvents = array_keys($scheduledEvents);
+        $this->logger->debug('CAMPAIGN: '.$totalScheduledCount.' events scheduled to execute.');
+        $this->output->writeln(
+            $this->translator->trans(
+                'mautic.campaign.trigger.event_count',
+                [
+                    '%events%' => $totalScheduledCount,
+                    '%batch%'  => $this->limiter->getBatchLimit(),
+                ]
+            )
+        );
+        if (!$totalScheduledCount) {
+            throw new NoEventsFoundException();
+        }
+        $this->progressBar = ProgressBarHelper::init($this->output, $totalScheduledCount);
+        $this->progressBar->start();
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    private function executeOrRescheduleEvent(): void
+    {
+        $now = $this->now ?? new \DateTime();
+        foreach ($this->scheduledEvents as $eventId) {
+            $this->counter->advanceEventCount();
+            $this->executeScheduled($eventId, $now);
+        }
+    }
+    /**
+     * @throws Dispatcher\Exception\LogNotProcessedException
+     * @throws Dispatcher\Exception\LogPassedAndFailedException
+     * @throws Exception\CannotProcessEventException
+     * @throws Scheduler\Exception\NotSchedulableException
+     * @throws \Doctrine\ORM\Query\QueryException
+     */
+    private function executeScheduled($eventId, \DateTime $now): void
+    {
+        $logs = $this->repo->getScheduled($eventId, $this->now, $this->limiter);
+        while ($logs->count()) {
+            try {
+                $fetchedContacts = $this->scheduledContactFinder->hydrateContacts($logs);
+            } catch (NoContactsFoundException) {
+                break;
+            }
+            $event = $logs->first()->getEvent();
+            $this->progressBar->advance($logs->count());
+            $this->counter->advanceEvaluated($logs->count());
+            $this->validateSchedule($logs, $now);
+            $this->executioner->executeLogs($event, $logs, $this->counter);
+            $this->scheduledContactFinder->clear($fetchedContacts);
+            $logs = $this->repo->getScheduled($eventId, $this->now, $this->limiter);
+        }
+    }
+    /**
+     * @param bool $scheduleTogether
+     *
+     * @throws Scheduler\Exception\NotSchedulableException
+     */
+    private function validateSchedule(ArrayCollection $logs, \DateTime $now, $scheduleTogether = false): void
+    {
+        $toBeRescheduled     = new ArrayCollection();
+        $latestExecutionDate = $now;
+        /** @var LeadEventLog $log */
+        foreach ($logs as $key => $log) {
+            $executionDate = $this->scheduler->validateExecutionDateTime($log, $now);
+            $this->logger->debug(
+                'CAMPAIGN: Log ID #'.$log->getID().
+                ' to be executed on '.$executionDate->format('Y-m-d H:i:s e').
+                ' compared to '.$now->format('Y-m-d H:i:s e')
+            );
+            if ($this->scheduler->shouldSchedule($executionDate, $now)) {
+                $this->counter->advanceTotalScheduled();
+                if ($scheduleTogether) {
+                    $toBeRescheduled->set($key, $log);
+                    if ($executionDate > $latestExecutionDate) {
+                        $latestExecutionDate = $executionDate;
+                    }
+                } else {
+                    $this->scheduler->reschedule($log, $executionDate);
+                }
+                $logs->remove($key);
+                continue;
+            }
+        }
+        if ($toBeRescheduled->count()) {
+            $this->scheduler->rescheduleLogs($toBeRescheduled, $latestExecutionDate);
+        }
+    }
+    /**
+     * @return ArrayCollection[]
+     */
+    private function organizeByEvent(ArrayCollection $logs): array
+    {
+        $jumpTo = [];
+        $other  = [];
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $event     = $log->getEvent();
+            $eventType = $event->getType();
+            if (CampaignActionJumpToEventSubscriber::EVENT_NAME === $eventType) {
+                if (!isset($jumpTo[$event->getId()])) {
+                    $jumpTo[$event->getId()] = new ArrayCollection();
+                }
+                $jumpTo[$event->getId()]->set($log->getId(), $log);
+            } else {
+                if (!isset($other[$event->getId()])) {
+                    $other[$event->getId()] = new ArrayCollection();
+                }
+                $other[$event->getId()]->set($log->getId(), $log);
+            }
+        }
+        return array_merge($other, $jumpTo);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Scheduler/EventScheduler.php
@@ -0,0 +1,296 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Scheduler;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\ScheduledBatchEvent;
+use Mautic\CampaignBundle\Event\ScheduledEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\Executioner\Exception\IntervalNotConfiguredException;
+use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
+use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
+use Mautic\CampaignBundle\Executioner\Scheduler\Mode\DateTime as DateTimeScheduler;
+use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Interval as IntervalScheduler;
+use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized as OptimizedScheduler;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\LeadBundle\Entity\Lead;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class EventScheduler
+{
+    public function __construct(
+        private LoggerInterface $logger,
+        private EventLogger $eventLogger,
+        private IntervalScheduler $intervalScheduler,
+        private DateTimeScheduler $dateTimeScheduler,
+        private OptimizedScheduler $optimizedScheduler,
+        private EventCollector $collector,
+        private EventDispatcherInterface $dispatcher,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    public function scheduleForContact(Event $event, \DateTimeInterface $executionDate, Lead $contact): void
+    {
+        $contacts = new ArrayCollection([$contact]);
+        $this->schedule($event, $executionDate, $contacts);
+    }
+    /**
+     * @param bool $isInactiveEvent
+     */
+    public function schedule(Event $event, \DateTimeInterface $executionDate, ArrayCollection $contacts, $isInactiveEvent = false): void
+    {
+        $config = $this->collector->getEventConfig($event);
+        $this->eventLogger->hydrateContactRotationsForNewLogs($contacts->getKeys(), $event->getCampaign()->getId());
+        if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
+            $groupedExecutionDates = $this->intervalScheduler->groupContactsByDate($event, $contacts, $executionDate);
+            foreach ($groupedExecutionDates as $groupExecutionDateDAO) {
+                $this->scheduleEventForContacts(
+                    $event,
+                    $config,
+                    $groupExecutionDateDAO->getExecutionDate(),
+                    $groupExecutionDateDAO->getContacts(),
+                    $isInactiveEvent
+                );
+            }
+            return;
+        }
+        $this->scheduleEventForContacts($event, $config, $executionDate, $contacts, $isInactiveEvent);
+    }
+    public function reschedule(LeadEventLog $log, \DateTimeInterface $toBeExecutedOn): void
+    {
+        $log->setTriggerDate($toBeExecutedOn);
+        $this->eventLogger->persistLog($log);
+        $event  = $log->getEvent();
+        $config = $this->collector->getEventConfig($event);
+        $this->dispatchScheduledEvent($config, $log, true);
+    }
+    /**
+     * @param ArrayCollection|LeadEventLog[] $logs
+     */
+    public function rescheduleLogs(ArrayCollection $logs, \DateTimeInterface $toBeExecutedOn): void
+    {
+        foreach ($logs as $log) {
+            $log->setTriggerDate($toBeExecutedOn);
+        }
+        $this->eventLogger->persistCollection($logs);
+        $event  = $logs->first()->getEvent();
+        $config = $this->collector->getEventConfig($event);
+        $this->dispatchBatchScheduledEvent($config, $event, $logs, true);
+    }
+    /**
+     * @deprecated since Mautic 3. To be removed in Mautic 4. Use rescheduleFailures instead.
+     */
+    public function rescheduleFailure(LeadEventLog $log): void
+    {
+        try {
+            $this->reschedule($log, $this->getRescheduleDate($log));
+        } catch (IntervalNotConfiguredException) {
+        }
+    }
+    public function rescheduleFailures(ArrayCollection $logs): void
+    {
+        if (!$logs->count()) {
+            return;
+        }
+        foreach ($logs as $log) {
+            try {
+                $this->reschedule($log, $this->getRescheduleDate($log));
+            } catch (IntervalNotConfiguredException) {
+            }
+        }
+        $event  = $logs->first()->getEvent();
+        $config = $this->collector->getEventConfig($event);
+        $this->dispatchBatchScheduledEvent($config, $event, $logs, true);
+    }
+    /**
+     * @throws NotSchedulableException
+     */
+    public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime = null, \DateTime $comparedToDateTime = null): \DateTimeInterface
+    {
+        if (null === $compareFromDateTime) {
+            $compareFromDateTime = new \DateTime();
+        } else {
+            $compareFromDateTime = clone $compareFromDateTime;
+        }
+        if (null === $comparedToDateTime) {
+            $comparedToDateTime = clone $compareFromDateTime;
+        } else {
+            $comparedToDateTime = clone $comparedToDateTime;
+        }
+        switch ($event->getTriggerMode()) {
+            case Event::TRIGGER_MODE_IMMEDIATE:
+            case Event::TRIGGER_MODE_OPTIMIZED:
+            case null: // decision
+                $this->logger->debug('CAMPAIGN: ('.$event->getId().') Executing immediately');
+                return $compareFromDateTime;
+            case Event::TRIGGER_MODE_INTERVAL:
+                return $this->intervalScheduler->getExecutionDateTime($event, $compareFromDateTime, $comparedToDateTime);
+            case Event::TRIGGER_MODE_DATE:
+                return $this->dateTimeScheduler->getExecutionDateTime($event, $compareFromDateTime, $comparedToDateTime);
+        }
+        throw new NotSchedulableException();
+    }
+    /**
+     * @return \DateTimeInterface
+     *
+     * @throws NotSchedulableException
+     */
+    public function validateExecutionDateTime(LeadEventLog $log, \DateTime $currentDateTime)
+    {
+        if (!$scheduledDateTime = $log->getTriggerDate()) {
+            throw new NotSchedulableException();
+        }
+        $event = $log->getEvent();
+        switch ($event->getTriggerMode()) {
+            case Event::TRIGGER_MODE_IMMEDIATE:
+            case Event::TRIGGER_MODE_OPTIMIZED:
+            case null: // decision
+                $this->logger->debug('CAMPAIGN: ('.$event->getId().') Executing immediately');
+                return $currentDateTime;
+            case Event::TRIGGER_MODE_INTERVAL:
+                return $this->intervalScheduler->validateExecutionDateTime($log, $currentDateTime);
+            case Event::TRIGGER_MODE_DATE:
+                return $this->dateTimeScheduler->getExecutionDateTime($event, $currentDateTime, $scheduledDateTime);
+        }
+        throw new NotSchedulableException();
+    }
+    /**
+     * @param ArrayCollection|Event[] $events
+     *
+     * @throws NotSchedulableException
+     */
+    public function getSortedExecutionDates(ArrayCollection $events, \DateTimeInterface $lastActiveDate): array
+    {
+        $eventExecutionDates = [];
+        /** @var Event $child */
+        foreach ($events as $child) {
+            $eventExecutionDates[$child->getId()] = $this->getExecutionDateTime($child, $lastActiveDate);
+        }
+        uasort(
+            $eventExecutionDates,
+            fn (\DateTimeInterface $a, \DateTimeInterface $b): int => $a <=> $b
+        );
+        return $eventExecutionDates;
+    }
+    public function getExecutionDateForInactivity(\DateTimeInterface $eventExecutionDate, \DateTimeInterface $earliestExecutionDate, \DateTimeInterface $now): \DateTimeInterface
+    {
+        if ($eventExecutionDate->getTimestamp() === $earliestExecutionDate->getTimestamp()) {
+            return clone $now;
+        }
+        return $eventExecutionDate;
+    }
+    public function shouldSchedule(\DateTimeInterface $executionDate, \DateTimeInterface $now): bool
+    {
+        if (false === (bool) getenv('CAMPAIGN_EXECUTIONER_SCHEDULER_ACKNOWLEDGE_SECONDS')) {
+            $executionDate = new \DateTime($executionDate->format('Y-m-d H:i'), $executionDate->getTimezone());
+            $now           = new \DateTime($now->format('Y-m-d H:i'), $now->getTimezone());
+        }
+        return $executionDate > $now;
+    }
+    public function shouldScheduleEvent(Event $event, \DateTimeInterface $executionDate, \DateTimeInterface $now): bool
+    {
+        if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
+            return true;
+        }
+        return $this->shouldSchedule($executionDate, $now);
+    }
+    /**
+     * @throws NotSchedulableException
+     */
+    public function validateAndScheduleEventForContacts(Event $event, \DateTimeInterface $executionDateTime, ArrayCollection $contacts, \DateTimeInterface $comparedFromDateTime): void
+    {
+        if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
+            $this->logger->debug(
+                'CAMPAIGN: Event ID# '.$event->getId().
+                ' has to be scheduled based on contact specific parameters '.
+                ' compared to '.$executionDateTime->format('Y-m-d H:i:s')
+            );
+            $groupedExecutionDates = $this->intervalScheduler->groupContactsByDate($event, $contacts, $executionDateTime);
+            $config                = $this->collector->getEventConfig($event);
+            foreach ($groupedExecutionDates as $groupExecutionDateDAO) {
+                $this->scheduleEventForContacts(
+                    $event,
+                    $config,
+                    $groupExecutionDateDAO->getExecutionDate(),
+                    $groupExecutionDateDAO->getContacts()
+                );
+            }
+            return;
+        }
+        if ($this->shouldSchedule($executionDateTime, $comparedFromDateTime)) {
+            $this->schedule($event, $executionDateTime, $contacts);
+            return;
+        }
+        throw new NotSchedulableException();
+    }
+    /**
+     * @param bool $isReschedule
+     */
+    private function dispatchScheduledEvent(AbstractEventAccessor $config, LeadEventLog $log, $isReschedule = false): void
+    {
+        $this->dispatcher->dispatch(
+            new ScheduledEvent($config, $log, $isReschedule),
+            CampaignEvents::ON_EVENT_SCHEDULED
+        );
+    }
+    /**
+     * @param bool $isReschedule
+     */
+    private function dispatchBatchScheduledEvent(AbstractEventAccessor $config, Event $event, ArrayCollection $logs, $isReschedule = false): void
+    {
+        if (!$logs->count()) {
+            return;
+        }
+        $this->dispatcher->dispatch(
+            new ScheduledBatchEvent($config, $event, $logs, $isReschedule),
+            CampaignEvents::ON_EVENT_SCHEDULED_BATCH
+        );
+    }
+    /**
+     * @param bool $isInactiveEvent
+     */
+    private function scheduleEventForContacts(Event $event, AbstractEventAccessor $config, \DateTimeInterface $executionDate, ArrayCollection $contacts, $isInactiveEvent = false): void
+    {
+        foreach ($contacts as $contact) {
+            $log = $this->eventLogger->buildLogEntry($event, $contact, $isInactiveEvent);
+            if (Event::TRIGGER_MODE_OPTIMIZED === $event->getTriggerMode()) {
+                $optimizedExecutionDate = $this->optimizedScheduler->getExecutionDateTimeForContact($event, $contact);
+                $log->setTriggerDate($optimizedExecutionDate);
+            } else {
+                $log->setTriggerDate($executionDate);
+            }
+            $this->eventLogger->queueToPersist($log);
+            $this->logger->debug(
+                'CAMPAIGN: '.ucfirst($event->getEventType()).' ID# '.$event->getId().' for contact ID# '.$contact->getId()
+                .' has timing that is not appropriate and thus scheduled for '.$executionDate->format('Y-m-d H:i:s T')
+            );
+            $this->dispatchScheduledEvent($config, $log);
+        }
+        $logs = $this->eventLogger->persistQueuedLogs();
+        $this->dispatchBatchScheduledEvent($config, $event, $logs);
+        $this->eventLogger->persistCollection($logs)
+            ->clearCollection($logs);
+    }
+    /**
+     * @throws IntervalNotConfiguredException
+     */
+    private function getRescheduleDate(LeadEventLog $leadEventLog): \DateTimeInterface
+    {
+        $rescheduleDate = new \DateTime();
+        $logInterval    = $leadEventLog->getRescheduleInterval();
+        if ($logInterval) {
+            return $rescheduleDate->add($logInterval);
+        }
+        $defaultIntervalString = $this->coreParametersHelper->get('campaign_time_wait_on_event_false');
+        if (!$defaultIntervalString) {
+            throw new IntervalNotConfiguredException('No Interval has been set on the lead event log nor as campaign_time_wait_on_event_false config value.');
+        }
+        try {
+            return $rescheduleDate->add(new \DateInterval($defaultIntervalString));
+        } catch (\Exception) {
+            throw new IntervalNotConfiguredException("'{$defaultIntervalString}' is not valid interval string for campaign_time_wait_on_event_false config key.");
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Scheduler/Mode/DAO/GroupExecutionDateDAO.php
@@ -0,0 +1,31 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode\DAO;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\LeadBundle\Entity\Lead;
+class GroupExecutionDateDAO
+{
+    private ArrayCollection $contacts;
+    public function __construct(
+        private \DateTimeInterface $executionDate,
+    ) {
+        $this->contacts      = new ArrayCollection();
+    }
+    public function addContact(Lead $contact): void
+    {
+        $this->contacts->set($contact->getId(), $contact);
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    public function getExecutionDate()
+    {
+        return $this->executionDate;
+    }
+    /**
+     * @return ArrayCollection
+     */
+    public function getContacts()
+    {
+        return $this->contacts;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Scheduler/Mode/DateTime.php
@@ -0,0 +1,27 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
+use Mautic\CampaignBundle\Entity\Event;
+use Psr\Log\LoggerInterface;
+class DateTime implements ScheduleModeInterface
+{
+    public function __construct(
+        private LoggerInterface $logger,
+    ) {
+    }
+    public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
+    {
+        $triggerDate = $event->getTriggerDate();
+        if (null === $triggerDate) {
+            $this->logger->debug('CAMPAIGN: Trigger date is null');
+            return $compareFromDateTime;
+        }
+        if ($compareFromDateTime >= $triggerDate) {
+            $this->logger->debug(
+                'CAMPAIGN: ('.$event->getId().') Date to execute ('.$triggerDate->format('Y-m-d H:i:s T').') compared to now ('
+                .$compareFromDateTime->format('Y-m-d H:i:s T').') and is thus overdue'
+            );
+            return $compareFromDateTime;
+        }
+        return $triggerDate;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Scheduler/Mode/Interval.php
@@ -0,0 +1,289 @@
+<?php
+namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
+use Mautic\CampaignBundle\Executioner\Scheduler\Mode\DAO\GroupExecutionDateDAO;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\DateTimeHelper;
+use Mautic\LeadBundle\Entity\Lead;
+use Psr\Log\LoggerInterface;
+class Interval implements ScheduleModeInterface
+{
+    public const LOG_DATE_FORMAT = 'Y-m-d H:i:s T';
+    private ?\DateTimeZone $defaultTimezone = null;
+    public function __construct(
+        private LoggerInterface $logger,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    /**
+     * @throws NotSchedulableException
+     */
+    public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
+    {
+        $interval = $event->getTriggerInterval();
+        $unit     = $event->getTriggerIntervalUnit();
+        try {
+            $this->logger->debug(
+                'CAMPAIGN: ('.$event->getId().') Adding interval of '.$interval.$unit.' to '.$comparedToDateTime->format(self::LOG_DATE_FORMAT)
+            );
+            /** @var \DateTime $comparedToDateTime */
+            $comparedToDateTime->add((new DateTimeHelper())->buildInterval($interval, $unit));
+        } catch (\Exception $exception) {
+            $this->logger->error('CAMPAIGN: Determining interval scheduled failed with "'.$exception->getMessage().'"');
+            throw new NotSchedulableException($exception->getMessage());
+        }
+        if ($comparedToDateTime > $compareFromDateTime) {
+            $this->logger->debug(
+                'CAMPAIGN: ('.$event->getId().') '.$comparedToDateTime->format(self::LOG_DATE_FORMAT).' is later than '
+                .$compareFromDateTime->format(self::LOG_DATE_FORMAT).' and thus returning '.$comparedToDateTime->format(self::LOG_DATE_FORMAT)
+            );
+            return $comparedToDateTime;
+        }
+        $this->logger->debug(
+            'CAMPAIGN: ('.$event->getId().') '.$comparedToDateTime->format(self::LOG_DATE_FORMAT).' is earlier than '
+            .$compareFromDateTime->format(self::LOG_DATE_FORMAT).' and thus returning '.$compareFromDateTime->format(self::LOG_DATE_FORMAT)
+        );
+        return $compareFromDateTime;
+    }
+    /**
+     * @return \DateTimeInterface
+     *
+     * @throws NotSchedulableException
+     */
+    public function validateExecutionDateTime(LeadEventLog $log, \DateTimeInterface $compareFromDateTime)
+    {
+        $event         = $log->getEvent();
+        $dateTriggered = clone $log->getDateTriggered();
+        if (!$this->isContactSpecificExecutionDateRequired($event)) {
+            return $this->getExecutionDateTime($event, $compareFromDateTime, $dateTriggered);
+        }
+        $interval      = $event->getTriggerInterval();
+        $unit          = $event->getTriggerIntervalUnit();
+        if ($interval && $unit) {
+            /** @var \DateTime $dateTriggered */
+            $dateTriggered->add((new DateTimeHelper())->buildInterval($interval, $unit));
+        }
+        if ($dateTriggered < $compareFromDateTime) {
+            $this->logger->debug(
+                sprintf('CAMPAIGN: (%s) %s is earlier than %s and thus setting %s', $event->getId(), $dateTriggered->format(self::LOG_DATE_FORMAT), $compareFromDateTime->format(self::LOG_DATE_FORMAT), $compareFromDateTime->format(self::LOG_DATE_FORMAT))
+            );
+            $dateTriggered = clone $compareFromDateTime;
+        }
+        $hour      = $event->getTriggerHour();
+        $startTime = $event->getTriggerRestrictedStartHour();
+        $endTime   = $event->getTriggerRestrictedStopHour();
+        $dow       = $event->getTriggerRestrictedDaysOfWeek();
+        return $this->getGroupExecutionDateTime($event->getId(), $log->getLead(), $dateTriggered, $hour, $startTime, $endTime, $dow);
+    }
+    /**
+     * @return GroupExecutionDateDAO[]
+     */
+    public function groupContactsByDate(Event $event, ArrayCollection $contacts, \DateTimeInterface $executionDate, \DateTimeInterface $compareFromDateTime = null): array
+    {
+        $groupedExecutionDates = [];
+        $hour                  = $event->getTriggerHour();
+        $startTime             = $event->getTriggerRestrictedStartHour();
+        $endTime               = $event->getTriggerRestrictedStopHour();
+        $daysOfWeek            = $event->getTriggerRestrictedDaysOfWeek();
+        /** @var Lead $contact */
+        foreach ($contacts as $contact) {
+            $groupExecutionDate = $this->getGroupExecutionDateTime(
+                $event->getId(),
+                $contact,
+                $executionDate,
+                $hour,
+                $startTime,
+                $endTime,
+                $daysOfWeek
+            );
+            $key = $groupExecutionDate->format(DateTimeHelper::FORMAT_DB);
+            if (!isset($groupedExecutionDates[$key])) {
+                $groupedExecutionDates[$key] = new GroupExecutionDateDAO($groupExecutionDate);
+            }
+            $groupedExecutionDates[$key]->addContact($contact);
+        }
+        return $groupedExecutionDates;
+    }
+    /**
+     * Checks if an event has a relative time configured.
+     */
+    public function isContactSpecificExecutionDateRequired(Event $event): bool
+    {
+        if ($this->isTriggerModeOptimized($event)) {
+            return true;
+        }
+        if (!$this->isTriggerModeInterval($event) || $this->isRestrictedToDailyScheduling($event) || $this->hasTimeRelatedRestrictions($event) || $this->isNegativePath($event)) {
+            return false;
+        }
+        return true;
+    }
+    private function isTriggerModeInterval(Event $event): bool
+    {
+        return Event::TRIGGER_MODE_INTERVAL === $event->getTriggerMode();
+    }
+    private function isTriggerModeOptimized(Event $event): bool
+    {
+        return Event::TRIGGER_MODE_OPTIMIZED === $event->getTriggerMode();
+    }
+    private function isRestrictedToDailyScheduling(Event $event): bool
+    {
+        return !in_array($event->getTriggerIntervalUnit(), ['i', 'h', 'd', 'm', 'y'])
+            && empty($event->getTriggerRestrictedDaysOfWeek());
+    }
+    private function hasTimeRelatedRestrictions(Event $event): bool
+    {
+        return null === $event->getTriggerHour()
+            && (null === $event->getTriggerRestrictedStartHour() || null === $event->getTriggerRestrictedStopHour())
+            && empty($event->getTriggerRestrictedDaysOfWeek());
+    }
+    private function isNegativePath(Event $event): bool
+    {
+        if ($event->getParent()) {
+            return Event::TYPE_DECISION === $event->getParent()->getEventType() && Event::TYPE_ACTION === $event->getEventType() && Event::PATH_INACTION === $event->getDecisionPath();
+        }
+        return false;
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    private function getGroupExecutionDateTime(
+        $eventId,
+        Lead $contact,
+        \DateTimeInterface $compareFromDateTime,
+        \DateTimeInterface $hour = null,
+        \DateTimeInterface $startTime = null,
+        \DateTimeInterface $endTime = null,
+        array $daysOfWeek = [],
+    ) {
+        $this->logger->debug(
+            sprintf('CAMPAIGN: Comparing calculated executed time for event ID %s and contact ID %s with %s', $eventId, $contact->getId(), $compareFromDateTime->format('Y-m-d H:i:s e'))
+        );
+        if ($hour) {
+            $this->logger->debug(
+                sprintf('CAMPAIGN: Scheduling event ID %s for contact ID %s based on hour of %s', $eventId, $contact->getId(), $hour->format('H:i e'))
+            );
+            $groupDateTime = $this->getExecutionDateTimeFromHour($contact, $hour, $eventId, $compareFromDateTime);
+        } elseif ($startTime && $endTime) {
+            $this->logger->debug(
+                sprintf(
+                    'CAMPAIGN: Scheduling event ID %s for contact ID %s based on hour range of %s to %s',
+                    $eventId,
+                    $contact->getId(),
+                    $startTime->format('H:i e'),
+                    $endTime->format('H:i e')
+                )
+            );
+            $groupDateTime = $this->getExecutionDateTimeBetweenHours($contact, $startTime, $endTime, $eventId, $compareFromDateTime);
+        } else {
+            $this->logger->debug(
+                sprintf('CAMPAIGN: Scheduling event ID %s for contact ID %s without hour restrictions.', $eventId, $contact->getId())
+            );
+            $groupDateTime = clone $compareFromDateTime;
+        }
+        if ([] !== $daysOfWeek) {
+            $this->logger->debug(
+                sprintf(
+                    'CAMPAIGN: Scheduling event ID %s for contact ID %s based on DOW restrictions of %s',
+                    $eventId,
+                    $contact->getId(),
+                    implode(',', $daysOfWeek)
+                )
+            );
+            if (in_array(7, $daysOfWeek, true) || in_array('7', $daysOfWeek, true)) {
+                throw new \LogicException('The Mautic accepts only 0-6 as day of week (0 is Sunday).');
+            }
+            while (!in_array((int) $groupDateTime->format('w'), $daysOfWeek)) {
+                /** @var \DateTime $groupDateTime */
+                $groupDateTime->modify('+1 day');
+            }
+        }
+        return $groupDateTime;
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    private function getExecutionDateTimeFromHour(Lead $contact, \DateTimeInterface $hour, $eventId, \DateTimeInterface $compareFromDateTime)
+    {
+        /** @var \DateTime $groupHour */
+        $groupHour = clone $hour;
+        /** @var \DateTime $groupExecutionDate */
+        $groupExecutionDate = $this->getGroupExecutionDateWithTimeZone($contact, $eventId, $compareFromDateTime);
+        $groupExecutionDate->setTime((int) $groupExecutionDate->format('H'), (int) $groupExecutionDate->format('i'));
+        $testGroupHour = clone $groupExecutionDate;
+        $testGroupHour->setTime($groupHour->format('H'), $groupHour->format('i'));
+        if ($groupExecutionDate <= $testGroupHour) {
+            return $testGroupHour;
+        }
+        return $groupExecutionDate;
+    }
+    /**
+     * @return \DateTimeInterface
+     */
+    private function getExecutionDateTimeBetweenHours(
+        Lead $contact,
+        \DateTimeInterface $startTime,
+        \DateTimeInterface $endTime,
+        $eventId,
+        \DateTimeInterface $compareFromDateTime,
+    ) {
+        /* @var \DateTime $startTime */
+        $startTime = clone $startTime;
+        /* @var \DateTime $endTime */
+        $endTime   = clone $endTime;
+        if ($endTime < $startTime) {
+            $tempStartTime = clone $startTime;
+            $startTime     = clone $endTime;
+            $endTime       = clone $tempStartTime;
+            unset($tempStartTime);
+        }
+        /** @var \DateTime $groupExecutionDate */
+        $groupExecutionDate = $this->getGroupExecutionDateWithTimeZone($contact, $eventId, $compareFromDateTime);
+        $testStartDateTime = clone $groupExecutionDate;
+        $testStartDateTime->setTime($startTime->format('H'), $startTime->format('i'));
+        $testStopDateTime = clone $groupExecutionDate;
+        $testStopDateTime->setTime($endTime->format('H'), $endTime->format('i'));
+        if ($groupExecutionDate < $testStartDateTime) {
+            return $testStartDateTime;
+        }
+        if ($groupExecutionDate >= $testStopDateTime) {
+            $groupExecutionDate->modify('+1 day')->setTime((int) $startTime->format('H'), (int) $startTime->format('i'));
+        }
+        return $groupExecutionDate;
+    }
+    /**
+     * @return \DateTimeZone
+     */
+    private function getDefaultTimezone()
+    {
+        if ($this->defaultTimezone) {
+            return $this->defaultTimezone;
+        }
+        $this->defaultTimezone = new \DateTimeZone(
+            $this->coreParametersHelper->get('default_timezone', 'UTC')
+        );
+        return $this->defaultTimezone;
+    }
+    private function getGroupExecutionDateWithTimeZone(Lead $contact, int $eventId, \DateTimeInterface $compareFromDateTime): \DateTimeInterface
+    {
+        /** @var \DateTime $groupExecutionDate */
+        $groupExecutionDate = clone $compareFromDateTime;
+        $contactTimezone    = $this->getDefaultTimezone();
+        if ($timezone = $contact->getTimezone()) {
+            try {
+                $contactTimezone = new \DateTimeZone($timezone);
+                $this->logger->debug(
+                    'CAMPAIGN: ('.$eventId.') Setting '.$timezone.' for contact '.$contact->getId()
+                );
+            } catch (\Exception) {
+                $this->logger->debug(
+                    'CAMPAIGN: ('.$eventId.') '.$timezone.' for contact '.$contact->getId().' is not recognized'
+                );
+            }
+        }
+        $groupExecutionDate->setTimezone($contactTimezone);
+        return $groupExecutionDate;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Executioner/Scheduler/Mode/Optimized.php
@@ -0,0 +1,29 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Services\PeakInteractionTimer;
+class Optimized implements ScheduleModeInterface
+{
+    public const OPTIMIZED_TIME         = 0;
+    public const OPTIMIZED_DAY_AND_TIME = 1;
+    /** @var string[] */
+    public const AVAILABLE_FOR_EVENTS = ['email.send', 'message.send', 'plugin.leadpush', 'campaign.sendwebhook'];
+    public function __construct(
+        private PeakInteractionTimer $peakInteractionTimer,
+    ) {
+    }
+    public function getExecutionDateTime(Event $event, \DateTimeInterface $now, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
+    {
+        return $now;
+    }
+    public function getExecutionDateTimeForContact(Event $event, Lead $contact): \DateTimeInterface
+    {
+        if (self::OPTIMIZED_DAY_AND_TIME === $event->getTriggerWindow()) {
+            return $this->peakInteractionTimer->getOptimalTimeAndDay($contact);
+        } else {
+            return $this->peakInteractionTimer->getOptimalTime($contact);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignEventAddRemoveLeadType.php
@@ -0,0 +1,45 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CampaignBundle\Form\Validator\Constraints\InfiniteLoop;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CampaignEventAddRemoveLeadType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add('addTo', CampaignListType::class, [
+            'label'      => 'mautic.campaign.form.addtocampaigns',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => [
+                'class' => 'form-control',
+            ],
+            'required'         => false,
+            'include_this'     => $options['include_this'],
+            'this_translation' => 'mautic.campaign.form.thiscampaign_restart',
+            'constraints'      => [new InfiniteLoop()],
+        ]);
+        $builder->add('removeFrom', CampaignListType::class, [
+            'label'      => 'mautic.campaign.form.removefromcampaigns',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => [
+                'class' => 'form-control',
+            ],
+            'required'     => false,
+            'include_this' => $options['include_this'],
+        ]);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent_addremovelead';
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'include_this' => false,
+        ]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignEventJumpToEventType.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints\NotBlank;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CampaignEventJumpToEventType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $jumpProps = $builder->getData();
+        $selected  = $jumpProps['jumpToEvent'] ?? null;
+        $builder->add(
+            'jumpToEvent',
+            ChoiceType::class,
+            [
+                'choices'    => [],
+                'multiple'   => false,
+                'label'      => 'mautic.campaign.form.jump_to_event',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'                => 'form-control',
+                    'data-onload-callback' => 'updateJumpToEventOptions',
+                    'data-selected'        => $selected,
+                ],
+                'constraints' => [
+                    new NotBlank(
+                        [
+                            'message' => 'mautic.core.value.required',
+                        ]
+                    ),
+                ],
+            ]
+        );
+        $builder->get('jumpToEvent')->resetViewTransformers();
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent_jump_to_event';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignEventLeadChangeType.php
@@ -0,0 +1,43 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CoreBundle\Form\Type\ButtonGroupType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+/**
+ * @deprecated since Mautic 5.0, to be removed in 6.0 with no replacement.
+ *
+ * @extends AbstractType<mixed>
+ */
+class CampaignEventLeadChangeType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $data = $options['data']['action'] ?? 'added';
+        $builder->add('action', ButtonGroupType::class, [
+            'choices' => [
+                'mautic.campaign.form.trigger_leadchanged_added'   => 'added',
+                'mautic.campaign.form.trigger_leadchanged_removed' => 'removed',
+            ],
+            'expanded'          => true,
+            'multiple'          => false,
+            'label_attr'        => ['class' => 'control-label'],
+            'label'             => 'mautic.campaign.form.trigger_leadchanged',
+            'placeholder'       => false,
+            'required'          => false,
+            'data'              => $data,
+        ]);
+        $builder->add('campaigns', CampaignListType::class, [
+            'label'      => 'mautic.campaign.form.limittocampaigns',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => [
+                'class'   => 'form-control',
+                'tooltip' => 'mautic.campaign.form.limittocampaigns_descr',
+            ],
+            'required' => false,
+        ]);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent_leadchange';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignLeadSourceType.php
@@ -0,0 +1,97 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Validator\Constraints\NotBlank;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CampaignLeadSourceType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $sourceType    = $options['data']['sourceType'];
+        $sourceChoices = $options['source_choices'] ?? [];
+        foreach ($sourceChoices as $key => $val) {
+            $sourceChoices[$key] = $val.' ('.$key.')';
+        }
+        switch ($sourceType) {
+            case 'lists':
+                $builder->add(
+                    'lists',
+                    ChoiceType::class,
+                    [
+                        'choices'           => array_flip($sourceChoices),
+                        'multiple'          => true,
+                        'label'             => 'mautic.campaign.leadsource.lists',
+                        'label_attr'        => ['class' => 'control-label'],
+                        'attr'              => [
+                            'class' => 'form-control',
+                        ],
+                        'constraints' => [
+                            new NotBlank(
+                                [
+                                    'message' => 'mautic.core.value.required',
+                                ]
+                            ),
+                        ],
+                    ]
+                );
+                break;
+            case 'forms':
+                $builder->add(
+                    'forms',
+                    ChoiceType::class,
+                    [
+                        'choices'           => array_flip($sourceChoices),
+                        'multiple'          => true,
+                        'label'             => 'mautic.campaign.leadsource.forms',
+                        'label_attr'        => ['class' => 'control-label'],
+                        'attr'              => [
+                            'class' => 'form-control',
+                        ],
+                        'constraints' => [
+                            new NotBlank(
+                                [
+                                    'message' => 'mautic.core.value.required',
+                                ]
+                            ),
+                        ],
+                    ]
+                );
+                break;
+            default:
+                break;
+        }
+        $builder->add('sourceType', HiddenType::class);
+        $builder->add('droppedX', HiddenType::class);
+        $builder->add('droppedY', HiddenType::class);
+        $update = !empty($options['data'][$sourceType]);
+        if (!empty($update)) {
+            $btnValue = 'mautic.core.form.update';
+            $btnIcon  = 'ri-edit-line';
+        } else {
+            $btnValue = 'mautic.core.form.add';
+            $btnIcon  = 'ri-add-line';
+        }
+        $builder->add('buttons', FormButtonsType::class, [
+            'save_text'       => $btnValue,
+            'save_icon'       => $btnIcon,
+            'save_onclick'    => 'Mautic.submitCampaignSource(event)',
+            'apply_text'      => false,
+            'container_class' => 'bottom-form-buttons',
+        ]);
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setRequired(['source_choices']);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaign_leadsource';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignListType.php
@@ -0,0 +1,55 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\OptionsResolver\Options;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CampaignListType extends AbstractType
+{
+    /**
+     * @var bool
+     */
+    private $canViewOther = false;
+    public function __construct(
+        private CampaignModel $model,
+        protected TranslatorInterface $translator,
+        CorePermissions $security,
+    ) {
+        $this->canViewOther = $security->isGranted('campaign:campaigns:viewother');
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(
+            [
+                'choices'      => function (Options $options): array {
+                    $choices   = [];
+                    $campaigns = $this->model->getRepository()->getPublishedCampaigns(null, null, true, $this->canViewOther);
+                    foreach ($campaigns as $campaign) {
+                        $choices[$campaign['name']] = $campaign['id'];
+                    }
+                    ksort($choices);
+                    if ($options['include_this']) {
+                        $choices = [$options['this_translation'] => 'this'] + $choices;
+                    }
+                    return $choices;
+                },
+                'placeholder'       => false,
+                'expanded'          => false,
+                'multiple'          => true,
+                'required'          => false,
+                'include_this'      => false,
+                'this_translation'  => 'mautic.campaign.form.thiscampaign',
+            ]
+        );
+    }
+    public function getParent(): ?string
+    {
+        return ChoiceType::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/CampaignType.php
@@ -0,0 +1,113 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CategoryBundle\Form\Type\CategoryListType;
+use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
+use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Mautic\CoreBundle\Form\Type\PublishDownDateType;
+use Mautic\CoreBundle\Form\Type\PublishUpDateType;
+use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\Extension\Core\Type\TextareaType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<Campaign>
+ */
+class CampaignType extends AbstractType
+{
+    public function __construct(
+        private CorePermissions $security,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->addEventSubscriber(new CleanFormSubscriber(['description' => 'html']));
+        $builder->addEventSubscriber(new FormExitSubscriber('campaign', $options));
+        $builder->add('name', TextType::class, [
+            'label'      => 'mautic.core.name',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => ['class' => 'form-control'],
+        ]);
+        $builder->add('description', TextareaType::class, [
+            'label'      => 'mautic.core.description',
+            'label_attr' => ['class' => 'control-label'],
+            'attr'       => ['class' => 'form-control editor'],
+            'required'   => false,
+        ]);
+        $builder->add('allowRestart',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.campaign.allow_restart',
+                'attr'  => [
+                    'tooltip' => 'mautic.campaign.allow_restart.tooltip',
+                ],
+            ]
+        );
+        $builder->add('category', CategoryListType::class, [
+            'bundle' => 'campaign',
+        ]);
+        $attr = [];
+        if (!empty($options['data']) && $options['data']->getId()) {
+            $readonly = !$this->security->isGranted('campaign:campaigns:publish');
+            $data     = $options['data']->isPublished(false);
+            $attr     = [
+                'onchange'              => 'Mautic.showCampaignConfirmation(mQuery(this));',
+                'data-toggle'           => 'confirmation',
+                'data-message'          => $this->translator->trans('mautic.campaign.form.confirmation.message'),
+                'data-confirm-text'     => $this->translator->trans('mautic.campaign.form.confirmation.confirm_text'),
+                'data-confirm-callback' => 'dismissConfirmation',
+                'data-cancel-text'      => $this->translator->trans('mautic.campaign.form.confirmation.cancel_text'),
+                'data-cancel-callback'  => 'setPublishedButtonToYes',
+                'class'                 => 'btn btn-ghost',
+            ];
+        } elseif (!$this->security->isGranted('campaign:campaigns:publish')) {
+            $readonly = true;
+            $data     = false;
+        } else {
+            $readonly = false;
+            $data     = false;
+        }
+        $attr['readonly'] = $readonly;
+        $builder->add('isPublished', YesNoButtonGroupType::class, [
+            'data' => $data,
+            'attr' => $attr,
+        ]);
+        $builder->add('publishUp', PublishUpDateType::class);
+        $builder->add('publishDown', PublishDownDateType::class);
+        $builder->add('sessionId', HiddenType::class, [
+            'mapped' => false,
+        ]);
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+        $builder->add('buttons', FormButtonsType::class, [
+            'pre_extra_buttons' => [
+                [
+                    'name'  => 'builder',
+                    'label' => 'mautic.campaign.campaign.launch.builder',
+                    'attr'  => [
+                        'class'   => 'btn btn-ghost btn-dnd',
+                        'icon'    => 'ri-organization-chart',
+                        'onclick' => 'Mautic.launchCampaignEditor();',
+                    ],
+                ],
+            ],
+        ]);
+        $builder->add('version', HiddenType::class, [
+            'mapped' => false,
+        ]);
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'data_class' => Campaign::class,
+        ]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/ConfigType.php
@@ -0,0 +1,227 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\Extension\Core\Type\NumberType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints\Callback;
+use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
+use Symfony\Component\Validator\Constraints\Range;
+use Symfony\Component\Validator\Context\ExecutionContextInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class ConfigType extends AbstractType
+{
+    public function __construct(
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'campaign_time_wait_on_event_false',
+            ChoiceType::class,
+            [
+                'label'      => 'mautic.campaignconfig.campaign_time_wait_on_event_false',
+                'label_attr' => ['class' => 'control-label'],
+                'help'       => 'mautic.campaignconfig.campaign_time_wait_on_event_false_help',
+                'data'       => $options['data']['campaign_time_wait_on_event_false'],
+                'choices'    => [
+                    'mautic.core.never' => 'null',
+                    '15 mn'             => 'PT15M',
+                    '30 mn'             => 'PT30M',
+                    '45 mn'             => 'PT45M',
+                    '1 h'               => 'PT1H',
+                    '2 h'               => 'PT2H',
+                    '4 h'               => 'PT4H',
+                    '8 h'               => 'PT8H',
+                    '12 h'              => 'PT12H',
+                    '24 h'              => 'PT1D',
+                    '3 days'            => 'PT3D',
+                    '5 days'            => 'PT5D',
+                    '1 week'            => 'PT14D',
+                    '3 months'          => 'P3M',
+                ],
+                'attr'              => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.campaignconfig.campaign_time_wait_on_event_false_tooltip',
+                ],
+                'required' => false,
+            ]
+        );
+        $builder->add(
+            'campaign_by_range',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.campaignconfig.campaign_by_range',
+                'attr'  => [
+                    'tooltip' => 'mautic.campaignconfig.campaign_by_range.tooltip',
+                ],
+                'data'  => (bool) ($options['data']['campaign_by_range'] ?? false),
+            ]
+        );
+        $builder->add(
+            'campaign_use_summary',
+            YesNoButtonGroupType::class,
+            [
+                'label' => 'mautic.campaignconfig.use_summary',
+                'attr'  => [
+                    'tooltip' => 'mautic.campaignconfig.use_summary.tooltip',
+                ],
+                'data'  => (bool) ($options['data']['campaign_use_summary'] ?? false),
+            ]
+        );
+        $builder->add(
+            'campaign_email_stats_enabled',
+            YesNoButtonGroupType::class,
+            [
+                'label'      => 'mautic.campaignconfig.campaign_email_stats_enabled',
+                'label_attr' => ['class' => 'control-label'],
+                'data'       => $options['data']['campaign_email_stats_enabled'] ?? true,
+                'required'   => false,
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.campaignconfig.campaign_email_stats_enabled.tooltip',
+                ],
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_best_default_hour_start',
+            NumberType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.best_default_hour_start',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.best_default_hour_start.tooltip',
+                ],
+                'data'        => $options['data']['peak_interaction_timer_best_default_hour_start'] ?? 9,
+                'constraints' => [
+                    new Range([
+                        'min' => 0,
+                        'max' => 23,
+                    ]),
+                ],
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_best_default_hour_end',
+            NumberType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.best_default_hour_end',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.best_default_hour_end.tooltip',
+                ],
+                'data'        => $options['data']['peak_interaction_timer_best_default_hour_end'] ?? 12,
+                'constraints' => [
+                    new Range([
+                        'min' => 0,
+                        'max' => 23,
+                    ]),
+                    new Callback(
+                        function ($hourEnd, ExecutionContextInterface $context): void {
+                            $data      = $context->getRoot()->getData();
+                            $hourStart = $data['campaignconfig']['peak_interaction_timer_best_default_hour_start'] ?? null;
+                            if (null !== $hourStart && null !== $hourEnd && $hourStart >= $hourEnd) {
+                                $context->buildViolation('mautic.config.peak_interaction_timer.best_default_hour.validation.range')->addViolation();
+                            }
+                        }
+                    ),
+                ],
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_best_default_days',
+            ChoiceType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.best_default_days',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.best_default_days.tooltip',
+                ],
+                'choices' => [
+                    'mautic.core.date.monday'    => 1,
+                    'mautic.core.date.tuesday'   => 2,
+                    'mautic.core.date.wednesday' => 3,
+                    'mautic.core.date.thursday'  => 4,
+                    'mautic.core.date.friday'    => 5,
+                    'mautic.core.date.saturday'  => 6,
+                    'mautic.core.date.sunday'    => 7,
+                ],
+                'data'     => $options['data']['peak_interaction_timer_best_default_days'] ?? [2, 3, 4],
+                'multiple' => true,
+                'required' => true,
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_cache_timeout',
+            ChoiceType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.cache_timeout',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.cache_timeout.tooltip',
+                ],
+                'choices' => [
+                    'mautic.config.peak_interaction_timer.cache.off'                                        => 0,
+                    '1 '.$this->translator->trans('mautic.campaign.event.intervalunit.d', ['%count%' => 1]) => 1440,
+                    '7 '.$this->translator->trans('mautic.campaign.event.intervalunit.d', ['%count%' => 7]) => 10080,
+                    '1 '.$this->translator->trans('mautic.campaign.event.intervalunit.m', ['%count%' => 1]) => 43800,
+                ],
+                'data'        => $options['data']['peak_interaction_timer_cache_timeout'] ?? 43800,
+                'constraints' => [
+                    new GreaterThanOrEqual([
+                        'value' => 0,
+                    ]),
+                ],
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_fetch_interactions_from',
+            ChoiceType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.fetch_interactions_from',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.fetch_interactions_from.tooltip',
+                ],
+                'choices' => [
+                    'mautic.config.peak_interaction_timer.fetch.from_30_days' => '-30 days',
+                    'mautic.config.peak_interaction_timer.fetch.from_60_days' => '-60 days',
+                    'mautic.config.peak_interaction_timer.fetch.from_90_days' => '-90 days',
+                ],
+                'data' => $options['data']['peak_interaction_timer_fetch_interactions_from'] ?? '-60 days',
+            ]
+        );
+        $builder->add(
+            'peak_interaction_timer_fetch_limit',
+            NumberType::class,
+            [
+                'label'      => 'mautic.config.peak_interaction_timer.fetch_limit',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.config.peak_interaction_timer.fetch_limit.tooltip',
+                ],
+                'data'        => $options['data']['peak_interaction_timer_fetch_limit'] ?? 50,
+                'constraints' => [
+                    new GreaterThanOrEqual([
+                        'value' => 10,
+                    ]),
+                ],
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignconfig';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/EventCanvasSettingsType.php
@@ -0,0 +1,20 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\FormBuilderInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class EventCanvasSettingsType extends AbstractType
+{
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add('droppedX', HiddenType::class);
+        $builder->add('droppedY', HiddenType::class);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent_canvassettings';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Type/EventType.php
@@ -0,0 +1,299 @@
+<?php
+namespace Mautic\CampaignBundle\Form\Type;
+use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized as OptimizedScheduler;
+use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
+use Mautic\CoreBundle\Form\Type\ButtonGroupType;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Mautic\CoreBundle\Form\Type\PropertiesTrait;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\Extension\Core\Type\IntegerType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Form\FormEvent;
+use Symfony\Component\Form\FormEvents;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class EventType extends AbstractType
+{
+    use PropertiesTrait;
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $masks = [];
+        $builder->add(
+            'name',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.name',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+                'required'   => false,
+            ]
+        );
+        $builder->add(
+            'anchor',
+            HiddenType::class,
+            [
+                'label' => false,
+            ]
+        );
+        if (in_array($options['data']['eventType'], ['action', 'condition'])) {
+            $label = 'mautic.campaign.form.type';
+            $choices = [
+                'immediate' => 'mautic.campaign.form.type.immediate',
+                'interval'  => 'mautic.campaign.form.type.interval',
+                'date'      => 'mautic.campaign.form.type.date',
+            ];
+            if (in_array($options['data']['type'], OptimizedScheduler::AVAILABLE_FOR_EVENTS)) {
+                $choices['optimized'] = 'mautic.campaign.form.type.optimized';
+            }
+            if ('no' == $options['data']['anchor'] && 'condition' != $options['data']['anchorEventType']
+                && 'condition' != $options['data']['eventType']
+            ) {
+                $label .= '_inaction';
+                unset($choices['immediate']);
+                $choices['interval'] = $choices['interval'].'_inaction';
+                $choices['date']     = $choices['date'].'_inaction';
+            }
+            $default = array_key_first($choices);
+            $triggerMode = (empty($options['data']['triggerMode'])) ? $default : $options['data']['triggerMode'];
+            $builder->add(
+                'triggerMode',
+                ButtonGroupType::class,
+                [
+                    'choices'           => array_flip($choices),
+                    'expanded'          => true,
+                    'multiple'          => false,
+                    'label_attr'        => ['class' => 'control-label'],
+                    'label'             => $label,
+                    'placeholder'       => false,
+                    'required'          => false,
+                    'attr'              => [
+                        'onchange' => 'Mautic.campaignToggleTimeframes();',
+                        'tooltip'  => 'mautic.campaign.form.type.help',
+                    ],
+                    'data'        => $triggerMode,
+                ]
+            );
+            $builder->add(
+                'triggerDate',
+                DateTimeType::class,
+                [
+                    'label'  => false,
+                    'attr'   => [
+                        'class'       => 'form-control',
+                        'preaddon'    => 'ri-calendar-line',
+                        'data-toggle' => 'datetime',
+                    ],
+                    'widget' => 'single_text',
+                    'html5'  => false,
+                    'format' => 'yyyy-MM-dd HH:mm',
+                ]
+            );
+            $data = (!isset($options['data']['triggerInterval']) || '' === $options['data']['triggerInterval']
+                || null === $options['data']['triggerInterval']) ? 1 : (int) $options['data']['triggerInterval'];
+            $builder->add(
+                'triggerInterval',
+                IntegerType::class,
+                [
+                    'label' => false,
+                    'attr'  => [
+                        'class'    => 'form-control',
+                        'preaddon' => 'symbol-hashtag',
+                    ],
+                    'data'  => $data,
+                ]
+            );
+            $data = (!empty($options['data']['triggerIntervalUnit'])) ? $options['data']['triggerIntervalUnit'] : 'd';
+            $builder->add(
+                'triggerIntervalUnit',
+                ChoiceType::class,
+                [
+                    'choices'     => [
+                        'mautic.campaign.event.intervalunit.choice.i' => 'i',
+                        'mautic.campaign.event.intervalunit.choice.h' => 'h',
+                        'mautic.campaign.event.intervalunit.choice.d' => 'd',
+                        'mautic.campaign.event.intervalunit.choice.m' => 'm',
+                        'mautic.campaign.event.intervalunit.choice.y' => 'y',
+                    ],
+                    'multiple'          => false,
+                    'label_attr'        => ['class' => 'control-label'],
+                    'label'             => false,
+                    'attr'              => [
+                        'class' => 'form-control',
+                    ],
+                    'placeholder' => false,
+                    'required'    => false,
+                    'data'        => $data,
+                ]
+            );
+            $data = $this->getTimeValue($options['data'], 'triggerHour');
+            $builder->add(
+                'triggerHour',
+                TextType::class,
+                [
+                    'label' => false,
+                    'attr'  => [
+                        'class'        => 'form-control',
+                        'data-toggle'  => 'time',
+                        'data-format'  => 'H:i',
+                        'autocomplete' => 'off',
+                    ],
+                    'data'  => ($data) ? $data->format('H:i') : $data,
+                ]
+            );
+            $data = $this->getTimeValue($options['data'], 'triggerRestrictedStartHour');
+            $builder->add(
+                'triggerRestrictedStartHour',
+                TextType::class,
+                [
+                    'label' => false,
+                    'attr'  => [
+                        'class'        => 'form-control',
+                        'data-toggle'  => 'time',
+                        'data-format'  => 'H:i',
+                        'autocomplete' => 'off',
+                    ],
+                    'data'  => ($data) ? $data->format('H:i') : $data,
+                ]
+            );
+            $data = $this->getTimeValue($options['data'], 'triggerRestrictedStopHour');
+            $builder->add(
+                'triggerRestrictedStopHour',
+                TextType::class,
+                [
+                    'label' => false,
+                    'attr'  => [
+                        'class'        => 'form-control',
+                        'data-toggle'  => 'time',
+                        'data-format'  => 'H:i',
+                        'autocomplete' => 'off',
+                    ],
+                    'data'  => ($data) ? $data->format('H:i') : $data,
+                ]
+            );
+            $builder->add(
+                'triggerRestrictedDaysOfWeek',
+                ChoiceType::class,
+                [
+                    'label'    => true,
+                    'attr'     => [
+                        'data-toggle' => 'time',
+                        'data-format' => 'H:i',
+                    ],
+                    'choices'  => [
+                        'mautic.report.schedule.day.monday'     => 1,
+                        'mautic.report.schedule.day.tuesday'    => 2,
+                        'mautic.report.schedule.day.wednesday'  => 3,
+                        'mautic.report.schedule.day.thursday'   => 4,
+                        'mautic.report.schedule.day.friday'     => 5,
+                        'mautic.report.schedule.day.saturday'   => 6,
+                        'mautic.report.schedule.day.sunday'     => 0,
+                        'mautic.report.schedule.day.week_days'  => -1,
+                    ],
+                    'expanded'          => true,
+                    'multiple'          => true,
+                    'required'          => false,
+                ]
+            );
+            $builder->add(
+                'triggerWindow',
+                ChoiceType::class,
+                [
+                    'label'    => false,
+                    'choices'  => [
+                        'mautic.campaign.form.type.trigger_window_day'   => OptimizedScheduler::OPTIMIZED_TIME,
+                        'mautic.campaign.form.type.trigger_window_week'  => OptimizedScheduler::OPTIMIZED_DAY_AND_TIME,
+                    ],
+                    'data'              => $options['data']['triggerWindow'] ?? 0,
+                    'required'          => false,
+                    'expanded'          => true,
+                    'placeholder'       => false,
+                ]
+            );
+            $builder->addEventListener(FormEvents::PRE_SUBMIT, function (FormEvent $event): void {
+                $data        = $event->getData();
+                $triggerMode = $data['triggerMode'] ?? 'immediate';
+                if ('optimized' !== $triggerMode) {
+                    $data['triggerWindow'] = null;
+                    $event->setData($data);
+                }
+            });
+        }
+        if (!empty($options['settings']['formType'])) {
+            $this->addPropertiesType($builder, $options, $masks);
+        }
+        $builder->add('type', HiddenType::class);
+        $builder->add('eventType', HiddenType::class);
+        $builder->add(
+            'anchorEventType',
+            HiddenType::class,
+            [
+                'mapped' => false,
+                'data'   => $options['data']['anchorEventType'] ?? '',
+            ]
+        );
+        $builder->add(
+            'canvasSettings',
+            EventCanvasSettingsType::class,
+            [
+                'label' => false,
+            ]
+        );
+        $update = !empty($options['data']['properties']);
+        if (!empty($update)) {
+            $btnValue = 'mautic.core.form.update';
+            $btnIcon  = 'ri-edit-line';
+        } else {
+            $btnValue = 'mautic.core.form.add';
+            $btnIcon  = 'ri-add-line';
+        }
+        $builder->add(
+            'buttons',
+            FormButtonsType::class,
+            [
+                'save_text'       => $btnValue,
+                'save_icon'       => $btnIcon,
+                'save_onclick'    => 'Mautic.submitCampaignEvent(event)',
+                'apply_text'      => false,
+                'container_class' => 'bottom-form-buttons',
+            ]
+        );
+        $builder->add(
+            'campaignId',
+            HiddenType::class,
+            [
+                'mapped' => false,
+            ]
+        );
+        $builder->addEventSubscriber(new CleanFormSubscriber($masks));
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setRequired(['settings']);
+    }
+    /**
+     * @return \DateTime|mixed|null
+     */
+    private function getTimeValue(array $data, $name)
+    {
+        if (empty($data[$name])) {
+            return null;
+        }
+        if ($data[$name] instanceof \DateTime) {
+            return $data[$name];
+        }
+        return new \DateTime($data[$name]);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'campaignevent';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Form/Validator/Constraints/InfiniteLoopValidator.php
@@ -0,0 +1,36 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CampaignBundle\Form\Validator\Constraints;
+use Symfony\Component\Validator\Constraint;
+use Symfony\Component\Validator\ConstraintValidator;
+use Symfony\Component\Validator\Context\ExecutionContextInterface;
+use Symfony\Component\Validator\Exception\UnexpectedTypeException;
+final class InfiniteLoopValidator extends ConstraintValidator
+{
+    public function validate(mixed $value, Constraint $constraint): void
+    {
+        if (!$constraint instanceof InfiniteLoop) {
+            throw new UnexpectedTypeException($constraint, InfiniteLoop::class);
+        }
+        $data = $this->context->getRoot()->getData();
+        $this->validateEvent($this->context, $data['triggerMode'] ?? '', $value, (int) ($data['triggerInterval'] ?? 0), $data['triggerIntervalUnit'] ?? '');
+    }
+    /**
+     * @param string[] $addTo
+     */
+    public function validateEvent(ExecutionContextInterface $context, string $triggerMode, array $addTo, int $triggerInterval, string $triggerIntervalUnit): void
+    {
+        if (!in_array('this', $addTo)) {
+            return;
+        }
+        if ('immediate' === $triggerMode) {
+            $context->buildViolation('mautic.campaign.infiniteloop.immediate')->addViolation();
+            return;
+        }
+        if ('interval' === $triggerMode && 'i' === $triggerIntervalUnit && $triggerInterval < 30) {
+            $context->buildViolation('mautic.campaign.infiniteloop.interval')
+                ->setParameter('%count%', (string) $triggerInterval)
+                ->addViolation();
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Membership/Action/Adder.php
@@ -0,0 +1,59 @@
+<?php
+namespace Mautic\CampaignBundle\Membership\Action;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\Membership\Exception\ContactCannotBeAddedToCampaignException;
+use Mautic\LeadBundle\Entity\Lead;
+class Adder
+{
+    public const NAME = 'added';
+    public function __construct(
+        private LeadRepository $leadRepository,
+        private LeadEventLogRepository $leadEventLogRepository,
+    ) {
+    }
+    public function createNewMembership(Lead $contact, Campaign $campaign, $isManualAction): CampaignMember
+    {
+        $rotation = 1;
+        if ($this->leadEventLogRepository->hasBeenInCampaignRotation($contact->getId(), $campaign->getId(), 1)) {
+            $rotation = 2;
+        }
+        $campaignMember = new CampaignMember();
+        $campaignMember->setLead($contact);
+        $campaignMember->setCampaign($campaign);
+        $campaignMember->setManuallyAdded($isManualAction);
+        $campaignMember->setDateAdded(new \DateTime());
+        $campaignMember->setRotation($rotation);
+        $this->saveCampaignMember($campaignMember);
+        return $campaignMember;
+    }
+    /**
+     * @param bool $isManualAction
+     *
+     * @throws ContactCannotBeAddedToCampaignException
+     */
+    public function updateExistingMembership(CampaignMember $campaignMember, $isManualAction): void
+    {
+        $wasRemoved = $campaignMember->wasManuallyRemoved();
+        if (!($wasRemoved && $isManualAction) && !$campaignMember->getCampaign()->allowRestart()) {
+            throw new ContactCannotBeAddedToCampaignException('Contacts cannot restart the campaign');
+        }
+        if ($wasRemoved && !$isManualAction && null === $campaignMember->getDateLastExited()) {
+            throw new ContactCannotBeAddedToCampaignException('Contact was manually removed');
+        }
+        if ($wasRemoved && $isManualAction) {
+            $campaignMember->setManuallyAdded($isManualAction);
+        }
+        $campaignMember->setManuallyRemoved(false);
+        $campaignMember->setDateLastExited(null);
+        $campaignMember->startNewRotation();
+        $this->saveCampaignMember($campaignMember);
+    }
+    private function saveCampaignMember($campaignMember): void
+    {
+        $this->leadRepository->saveEntity($campaignMember);
+        $this->leadRepository->detachEntity($campaignMember);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Membership/Action/Remover.php
@@ -0,0 +1,48 @@
+<?php
+namespace Mautic\CampaignBundle\Membership\Action;
+use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\Membership\Exception\ContactAlreadyRemovedFromCampaignException;
+use Mautic\CoreBundle\Twig\Helper\DateHelper;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class Remover
+{
+    public const NAME = 'removed';
+    private string $unscheduledMessage;
+    public function __construct(
+        private LeadRepository $leadRepository,
+        private LeadEventLogRepository $leadEventLogRepository,
+        TranslatorInterface $translator,
+        DateHelper $dateHelper,
+    ) {
+        $dateRemoved              = $dateHelper->toFull(new \DateTime());
+        $this->unscheduledMessage = $translator->trans('mautic.campaign.member.removed', ['%date%' => $dateRemoved]);
+    }
+    /**
+     * @param bool $isExit
+     *
+     * @throws ContactAlreadyRemovedFromCampaignException
+     */
+    public function updateExistingMembership(CampaignMember $campaignMember, $isExit): void
+    {
+        if ($isExit) {
+            $campaignMember->setDateLastExited(new \DateTime());
+        } else {
+            $campaignMember->setDateLastExited(null);
+        }
+        if ($campaignMember->wasManuallyRemoved()) {
+            $this->saveCampaignMember($campaignMember);
+            throw new ContactAlreadyRemovedFromCampaignException();
+        }
+        $this->leadEventLogRepository->unscheduleEvents($campaignMember, $this->unscheduledMessage);
+        $campaignMember->setManuallyRemoved(true);
+        $campaignMember->setManuallyAdded(false);
+        $this->saveCampaignMember($campaignMember);
+    }
+    private function saveCampaignMember($campaignMember): void
+    {
+        $this->leadRepository->saveEntity($campaignMember);
+        $this->leadRepository->detachEntity($campaignMember);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Membership/EventDispatcher.php
@@ -0,0 +1,31 @@
+<?php
+namespace Mautic\CampaignBundle\Membership;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Event\CampaignLeadChangeEvent;
+use Mautic\LeadBundle\Entity\Lead;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class EventDispatcher
+{
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+    ) {
+    }
+    /**
+     * @param string $action
+     */
+    public function dispatchMembershipChange(Lead $contact, Campaign $campaign, $action): void
+    {
+        $this->dispatcher->dispatch(
+            new CampaignLeadChangeEvent($campaign, $contact, $action),
+            CampaignEvents::CAMPAIGN_ON_LEADCHANGE
+        );
+    }
+    public function dispatchBatchMembershipChange(array $contacts, Campaign $campaign, $action): void
+    {
+        $this->dispatcher->dispatch(
+            new CampaignLeadChangeEvent($campaign, $contacts, $action),
+            CampaignEvents::LEAD_CAMPAIGN_BATCH_CHANGE
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Membership/MembershipBuilder.php
@@ -0,0 +1,154 @@
+<?php
+namespace Mautic\CampaignBundle\Membership;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\LeadRepository as CampaignLeadRepository;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Membership\Exception\RunLimitReachedException;
+use Mautic\CoreBundle\Helper\ProgressBarHelper;
+use Mautic\LeadBundle\Entity\LeadRepository;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class MembershipBuilder
+{
+    private ?Campaign $campaign = null;
+    private ?ContactLimiter $contactLimiter = null;
+    private ?int $runLimit = null;
+    private ?OutputInterface $output = null;
+    private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
+    public function __construct(
+        private MembershipManager $manager,
+        private CampaignLeadRepository $campaignLeadRepository,
+        private LeadRepository $leadRepository,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    /**
+     * @param int $runLimit
+     */
+    public function build(Campaign $campaign, ContactLimiter $contactLimiter, $runLimit, OutputInterface $output = null): int
+    {
+        defined('MAUTIC_REBUILDING_CAMPAIGNS') or define('MAUTIC_REBUILDING_CAMPAIGNS', 1);
+        $this->campaign       = $campaign;
+        $this->contactLimiter = $contactLimiter;
+        $this->runLimit       = (int) $runLimit;
+        $this->output         = $output;
+        $contactsProcessed = 0;
+        try {
+            $contactsProcessed += $this->addNewlyQualifiedMembers($contactsProcessed);
+        } catch (RunLimitReachedException $exception) {
+            return $exception->getContactsProcessed();
+        }
+        try {
+            $contactsProcessed += $this->removeUnqualifiedMembers($contactsProcessed);
+        } catch (RunLimitReachedException $exception) {
+            return $exception->getContactsProcessed();
+        }
+        return $contactsProcessed;
+    }
+    /**
+     * Add contacts to a campaign.
+     *
+     * @throws RunLimitReachedException
+     */
+    private function addNewlyQualifiedMembers(int $totalContactsProcessed): int
+    {
+        $contactsProcessed = 0;
+        if ($this->output) {
+            $countResult = $this->campaignLeadRepository->getCountsForCampaignContactsBySegment(
+                $this->campaign->getId(),
+                $this->contactLimiter,
+                $this->campaign->allowRestart()
+            );
+            $this->output->writeln(
+                $this->translator->trans(
+                    'mautic.campaign.rebuild.to_be_added',
+                    ['%leads%' => $countResult->getCount(), '%batch%' => $this->contactLimiter->getBatchLimit()]
+                )
+            );
+            if (0 === $countResult->getCount()) {
+                return 0;
+            }
+            $this->startProgressBar($countResult->getCount());
+        }
+        $contacts = $this->campaignLeadRepository->getCampaignContactsBySegments(
+            $this->campaign->getId(),
+            $this->contactLimiter,
+            $this->campaign->allowRestart()
+        );
+        while (count($contacts)) {
+            $contactCollection = $this->leadRepository->getContactCollection($contacts);
+            if ($contactCollection->count() <= 0) {
+                break;
+            }
+            $contactsProcessed += $contactCollection->count();
+            $this->manager->addContacts($contactCollection, $this->campaign, false);
+            $this->leadRepository->detachEntities($contactCollection->toArray());
+            if ($this->runLimit && $contactsProcessed >= $this->runLimit) {
+                $this->finishProgressBar();
+                throw new RunLimitReachedException($contactsProcessed + $totalContactsProcessed);
+            }
+            $contacts = $this->campaignLeadRepository->getCampaignContactsBySegments(
+                $this->campaign->getId(),
+                $this->contactLimiter,
+                $this->campaign->allowRestart()
+            );
+        }
+        $this->finishProgressBar();
+        return $contactsProcessed;
+    }
+    /**
+     * @throws RunLimitReachedException
+     */
+    private function removeUnqualifiedMembers(int $totalContactsProcessed): int
+    {
+        $contactsProcessed = 0;
+        if ($this->output) {
+            $countResult = $this->campaignLeadRepository->getCountsForOrphanedContactsBySegments($this->campaign->getId(), $this->contactLimiter);
+            $this->output->writeln(
+                $this->translator->trans(
+                    'mautic.lead.list.rebuild.to_be_removed',
+                    ['%leads%' => $countResult->getCount(), '%batch%' => $this->contactLimiter->getBatchLimit()]
+                )
+            );
+            if (0 === $countResult->getCount()) {
+                return 0;
+            }
+            $this->startProgressBar($countResult->getCount());
+        }
+        $contacts = $this->campaignLeadRepository->getOrphanedContacts($this->campaign->getId(), $this->contactLimiter);
+        while (count($contacts)) {
+            $contactCollection = $this->leadRepository->getContactCollection($contacts);
+            if (!$contactCollection->count()) {
+                break;
+            }
+            $contactsProcessed += $contactCollection->count();
+            $this->manager->removeContacts($contactCollection, $this->campaign, true);
+            $this->leadRepository->detachEntities($contactCollection->toArray());
+            if ($this->runLimit && $contactsProcessed >= $this->runLimit) {
+                $this->finishProgressBar();
+                throw new RunLimitReachedException($contactsProcessed + $totalContactsProcessed);
+            }
+            $contacts = $this->campaignLeadRepository->getOrphanedContacts($this->campaign->getId(), $this->contactLimiter);
+        }
+        $this->finishProgressBar();
+        return $contactsProcessed;
+    }
+    private function startProgressBar(int $total): void
+    {
+        if (!$this->output) {
+            $this->progressBar = null;
+            $this->manager->setProgressBar($this->progressBar);
+            return;
+        }
+        $this->progressBar = ProgressBarHelper::init($this->output, $total);
+        $this->progressBar->start();
+        $this->manager->setProgressBar($this->progressBar);
+    }
+    private function finishProgressBar(): void
+    {
+        if ($this->progressBar) {
+            $this->progressBar->finish();
+            $this->output->writeln('');
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Membership/MembershipManager.php
@@ -0,0 +1,171 @@
+<?php
+namespace Mautic\CampaignBundle\Membership;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
+use Mautic\CampaignBundle\Entity\LeadRepository;
+use Mautic\CampaignBundle\Membership\Action\Adder;
+use Mautic\CampaignBundle\Membership\Action\Remover;
+use Mautic\CampaignBundle\Membership\Exception\ContactAlreadyRemovedFromCampaignException;
+use Mautic\CampaignBundle\Membership\Exception\ContactCannotBeAddedToCampaignException;
+use Mautic\LeadBundle\Entity\Lead;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Helper\ProgressBar;
+class MembershipManager
+{
+    public const ACTION_ADDED   = 'added';
+    public const ACTION_REMOVED = 'removed';
+    private ?ProgressBar $progressBar = null;
+    public function __construct(
+        private Adder $adder,
+        private Remover $remover,
+        private EventDispatcher $eventDispatcher,
+        private LeadRepository $leadRepository,
+        private LoggerInterface $logger,
+    ) {
+    }
+    /**
+     * @param bool $isManualAction
+     */
+    public function addContact(Lead $contact, Campaign $campaign, $isManualAction = true): void
+    {
+        /** @var CampaignMember $campaignMember */
+        $campaignMember = $this->leadRepository->findOneBy(
+            [
+                'lead'     => $contact,
+                'campaign' => $campaign,
+            ]
+        );
+        if ($campaignMember) {
+            try {
+                $this->adder->updateExistingMembership($campaignMember, $isManualAction);
+                $this->logger->debug(
+                    "CAMPAIGN: Membership for contact ID {$contact->getId()} in campaign ID {$campaign->getId()} was updated to be included."
+                );
+                $this->eventDispatcher->dispatchMembershipChange($campaignMember->getLead(), $campaignMember->getCampaign(), Adder::NAME);
+            } catch (ContactCannotBeAddedToCampaignException $exception) {
+                $this->logger->debug(
+                    "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
+                    $exception->toArray()
+                );
+            }
+            return;
+        }
+        try {
+            $this->adder->createNewMembership($contact, $campaign, $isManualAction);
+        } catch (ContactCannotBeAddedToCampaignException $exception) {
+            $this->logger->debug(
+                "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
+                $exception->toArray()
+            );
+            return;
+        }
+        $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was added to campaign ID {$campaign->getId()} as a new member.");
+        $this->eventDispatcher->dispatchMembershipChange($contact, $campaign, Adder::NAME);
+    }
+    /**
+     * @param ArrayCollection<int, Lead> $contacts
+     * @param bool                       $isManualAction
+     */
+    public function addContacts(ArrayCollection $contacts, Campaign $campaign, $isManualAction = true): void
+    {
+        $campaignMembers = $this->leadRepository->getCampaignMembers($contacts->getKeys(), $campaign);
+        foreach ($contacts as $contact) {
+            $this->advanceProgressBar();
+            $this->logger->debug(
+                'CAMPAIGN: Contacts: '.count($contacts),
+                array_map(fn ($item) => $item->getId(), $contacts->toArray())
+            );
+            if (isset($campaignMembers[$contact->getId()])) {
+                try {
+                    $this->adder->updateExistingMembership($campaignMembers[$contact->getId()], $isManualAction);
+                    $this->logger->debug(
+                        "CAMPAIGN: Membership for contact ID {$contact->getId()} in campaign ID {$campaign->getId()} was updated to be included."
+                    );
+                } catch (ContactCannotBeAddedToCampaignException $exception) {
+                    $contacts->remove($contact->getId());
+                    $this->logger->debug(
+                        "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
+                        $exception->toArray()
+                    );
+                }
+                continue;
+            }
+            $this->adder->createNewMembership($contact, $campaign, $isManualAction);
+            $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was added to campaign ID {$campaign->getId()} as a new member.");
+        }
+        if ($contacts->count()) {
+            $this->eventDispatcher->dispatchBatchMembershipChange($contacts->toArray(), $campaign, Adder::NAME);
+        }
+        $this->leadRepository->detachEntities($campaignMembers);
+    }
+    /**
+     * @param bool $isExit
+     */
+    public function removeContact(Lead $contact, Campaign $campaign, $isExit = false): void
+    {
+        /** @var CampaignMember $campaignMember */
+        $campaignMember = $this->leadRepository->findOneBy(
+            [
+                'lead'     => $contact,
+                'campaign' => $campaign,
+            ]
+        );
+        if (!$campaignMember) {
+            $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} is not in campaign ID {$campaign->getId()}.");
+            return;
+        }
+        try {
+            $this->remover->updateExistingMembership($campaignMember, $isExit);
+            $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was removed from campaign ID {$campaign->getId()}.");
+            $this->eventDispatcher->dispatchMembershipChange($contact, $campaign, Remover::NAME);
+        } catch (ContactAlreadyRemovedFromCampaignException $exception) {
+            $this->logger->debug(
+                "CAMPAIGN: Contact ID {$contact->getId()} was already removed from campaign ID {$campaign->getId()}.",
+                $exception->toArray()
+            );
+        }
+    }
+    /**
+     * @param ArrayCollection<int, Lead> $contacts
+     * @param bool                       $isExit   If true, the contact can be added by a segment/source. If false, the contact can only be added back
+     *                                             by a manual process.
+     */
+    public function removeContacts(ArrayCollection $contacts, Campaign $campaign, $isExit = false): void
+    {
+        $campaignMembers = $this->leadRepository->getCampaignMembers($contacts->getKeys(), $campaign);
+        foreach ($contacts as $contact) {
+            $this->advanceProgressBar();
+            if (!isset($campaignMembers[$contact->getId()])) {
+                $contacts->remove($contact->getId());
+                continue;
+            }
+            /** @var CampaignMember $campaignMember */
+            $campaignMember = $campaignMembers[$contact->getId()];
+            try {
+                $this->remover->updateExistingMembership($campaignMember, $isExit);
+                $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was removed from campaign ID {$campaign->getId()}.");
+            } catch (ContactAlreadyRemovedFromCampaignException $exception) {
+                $contacts->remove($contact->getId());
+                $this->logger->debug(
+                    "CAMPAIGN: Contact ID {$contact->getId()} was already removed from campaign ID {$campaign->getId()}.",
+                    $exception->toArray()
+                );
+            }
+        }
+        if ($contacts->count()) {
+            $this->eventDispatcher->dispatchBatchMembershipChange($contacts->toArray(), $campaign, Remover::NAME);
+        }
+        $this->leadRepository->detachEntities($campaignMembers);
+    }
+    public function setProgressBar(ProgressBar $progressBar = null): void
+    {
+        $this->progressBar = $progressBar;
+    }
+    private function advanceProgressBar(): void
+    {
+        if ($this->progressBar) {
+            $this->progressBar->advance();
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Model/CampaignModel.php
@@ -0,0 +1,710 @@
+<?php
+namespace Mautic\CampaignBundle\Model;
+use Doctrine\DBAL\Exception;
+use Doctrine\ORM\EntityManager;
+use Doctrine\ORM\PersistentCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\Lead as CampaignLead;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Event as Events;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
+use Mautic\CampaignBundle\Form\Type\CampaignType;
+use Mautic\CampaignBundle\Helper\ChannelExtractor;
+use Mautic\CampaignBundle\Membership\MembershipBuilder;
+use Mautic\CoreBundle\Helper\Chart\ChartQuery;
+use Mautic\CoreBundle\Helper\Chart\LineChart;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\FormModel as CommonFormModel;
+use Mautic\CoreBundle\Model\GlobalSearchInterface;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\EmailBundle\Entity\Stat;
+use Mautic\EmailBundle\Entity\StatRepository;
+use Mautic\FormBundle\Entity\Form;
+use Mautic\FormBundle\Model\FormModel;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\ListModel;
+use Mautic\LeadBundle\Tracker\ContactTracker;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+/**
+ * @extends CommonFormModel<Campaign>
+ */
+class CampaignModel extends CommonFormModel implements GlobalSearchInterface
+{
+    public function __construct(
+        protected ListModel $leadListModel,
+        protected FormModel $formModel,
+        private EventCollector $eventCollector,
+        private MembershipBuilder $membershipBuilder,
+        private ContactTracker $contactTracker,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    /**
+     * @return \Mautic\CampaignBundle\Entity\CampaignRepository
+     */
+    public function getRepository()
+    {
+        $repo = $this->em->getRepository(Campaign::class);
+        $repo->setCurrentUser($this->userHelper->getUser());
+        return $repo;
+    }
+    /**
+     * @return \Mautic\CampaignBundle\Entity\EventRepository
+     */
+    public function getEventRepository()
+    {
+        return $this->em->getRepository(Event::class);
+    }
+    /**
+     * @return \Mautic\CampaignBundle\Entity\LeadRepository
+     */
+    public function getCampaignLeadRepository()
+    {
+        return $this->em->getRepository(CampaignLead::class);
+    }
+    /**
+     * @return LeadEventLogRepository
+     */
+    public function getCampaignLeadEventLogRepository()
+    {
+        return $this->em->getRepository(\Mautic\CampaignBundle\Entity\LeadEventLog::class);
+    }
+    public function getPermissionBase(): string
+    {
+        return 'campaign:campaigns';
+    }
+    /**
+     * @param object      $entity
+     * @param string|null $action
+     * @param array       $options
+     */
+    public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
+    {
+        if (!$entity instanceof Campaign) {
+            throw new MethodNotAllowedHttpException(['Campaign']);
+        }
+        if (!empty($action)) {
+            $options['action'] = $action;
+        }
+        return $formFactory->create(CampaignType::class, $entity, $options);
+    }
+    /**
+     * Get a specific entity or generate a new one if id is empty.
+     */
+    public function getEntity($id = null): ?Campaign
+    {
+        if (null === $id) {
+            return new Campaign();
+        }
+        return parent::getEntity($id);
+    }
+    /**
+     * Delete an array of campaigns.
+     *
+     * @param int[] $campaignIds
+     *
+     * @return array<int,Campaign>
+     */
+    public function deleteEntities($campaignIds): array
+    {
+        $entities = [];
+        foreach ($campaignIds as $campaignId) {
+            $campaign = $this->getEntity($campaignId);
+            if ($campaign) {
+                $entities[$campaignId] = $campaign;
+                $this->deleteEntity($campaign);
+            }
+        }
+        return $entities;
+    }
+    public function deleteEntity($entity): void
+    {
+        $this->getEventRepository()->nullEventParents($entity->getId());
+        $this->dispatchEvent('pre_delete', $entity);
+        $this->getRepository()->setCampaignAsDeleted($entity->getId());
+        $this->dispatcher->dispatch(new Events\DeleteCampaign($entity), CampaignEvents::ON_CAMPAIGN_DELETE);
+    }
+    public function deleteCampaign(Campaign $campaign): void
+    {
+        $campaign->deletedId = $campaign->getId();
+        $this->getRepository()->deleteEntity($campaign);
+        $this->dispatchEvent('post_delete', $campaign);
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, \Symfony\Contracts\EventDispatcher\Event $event = null): ?\Symfony\Contracts\EventDispatcher\Event
+    {
+        if ($entity instanceof CampaignLead) {
+            return null;
+        }
+        if (!$entity instanceof Campaign) {
+            throw new MethodNotAllowedHttpException(['Campaign']);
+        }
+        switch ($action) {
+            case 'pre_save':
+                $name = CampaignEvents::CAMPAIGN_PRE_SAVE;
+                break;
+            case 'post_save':
+                $name = CampaignEvents::CAMPAIGN_POST_SAVE;
+                break;
+            case 'pre_delete':
+                $name = CampaignEvents::CAMPAIGN_PRE_DELETE;
+                break;
+            case 'post_delete':
+                $name = CampaignEvents::CAMPAIGN_POST_DELETE;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new Events\CampaignEvent($entity, $isNew);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        } else {
+            return null;
+        }
+    }
+    public function setEvents(Campaign $entity, $sessionEvents, $sessionConnections, $deletedEvents): array
+    {
+        $existingEvents = $entity->getEvents()->toArray();
+        $events         = [];
+        $hierarchy      = [];
+        foreach ($sessionEvents as $properties) {
+            $isNew = (!empty($properties['id']) && isset($existingEvents[$properties['id']])) ? false : true;
+            $event = !$isNew ? $existingEvents[$properties['id']] : new Event();
+            foreach ($properties as $f => $v) {
+                if ('id' == $f && str_starts_with($v, 'new')) {
+                    $event->setTempId($v);
+                }
+                if (in_array($f, ['id', 'parent'])) {
+                    continue;
+                }
+                $func = 'set'.ucfirst($f);
+                if (method_exists($event, $func)) {
+                    $event->$func($v);
+                }
+            }
+            ChannelExtractor::setChannel($event, $event, $this->eventCollector->getEventConfig($event));
+            $event->setCampaign($entity);
+            $events[$properties['id']] = $event;
+        }
+        foreach ($deletedEvents as $deleteMe) {
+            if (isset($existingEvents[$deleteMe])) {
+                $parent = $existingEvents[$deleteMe]->getParent();
+                if ($parent) {
+                    $parent->removeChild($existingEvents[$deleteMe]);
+                    $existingEvents[$deleteMe]->removeParent();
+                }
+                $entity->removeEvent($existingEvents[$deleteMe]);
+                unset($events[$deleteMe]);
+            }
+        }
+        $relationships = [];
+        if (isset($sessionConnections['connections'])) {
+            foreach ($sessionConnections['connections'] as $connection) {
+                $source = $connection['sourceId'];
+                $target = $connection['targetId'];
+                if (in_array($source, ['lists', 'forms'])) {
+                    continue;
+                }
+                if (isset($connection['anchors']['source'])) {
+                    $sourceDecision = $connection['anchors']['source'];
+                } else {
+                    $sourceDecision = (!empty($connection['anchors'][0])) ? $connection['anchors'][0]['endpoint'] : null;
+                }
+                if ('leadsource' == $sourceDecision) {
+                    continue;
+                }
+                $relationships[$target] = [
+                    'parent'   => $source,
+                    'decision' => $sourceDecision,
+                ];
+            }
+        }
+        foreach ($events as $id => $e) {
+            if (isset($relationships[$id])) {
+                $anchor = in_array($relationships[$id]['decision'], ['yes', 'no']) ? $relationships[$id]['decision'] : null;
+                $events[$id]->setDecisionPath($anchor);
+                $parentId = $relationships[$id]['parent'];
+                $events[$id]->setParent($events[$parentId]);
+                $hierarchy[$id] = $parentId;
+            } elseif ($events[$id]->getParent()) {
+                $events[$id]->setDecisionPath(null);
+                $parent = $events[$id]->getParent();
+                $parent->removeChild($events[$id]);
+                $events[$id]->removeParent();
+                $hierarchy[$id] = 'null';
+            } else {
+                $hierarchy[$id] = 'null';
+                $events[$id]->setDecisionPath(null);
+            }
+        }
+        $entity->addEvents($events);
+        $this->buildOrder($hierarchy, $events, $entity);
+        uasort(
+            $events,
+            function ($a, $b): int {
+                $aOrder = $a->getOrder();
+                $bOrder = $b->getOrder();
+                return $aOrder <=> $bOrder;
+            }
+        );
+        if ($entity->getId()) {
+            $this->getEventRepository()->saveEntities($events);
+        }
+        return $events;
+    }
+    /**
+     * @param bool $persist
+     *
+     * @return array
+     */
+    public function setCanvasSettings($entity, $settings, $persist = true, $events = null)
+    {
+        if (null === $events) {
+            $events = $entity->getEvents();
+        }
+        $tempIds = [];
+        foreach ($events as $e) {
+            if ($e instanceof Event) {
+                $tempIds[$e->getTempId()] = $e->getId();
+            } else {
+                $tempIds[$e['tempId']] = $e['id'];
+            }
+        }
+        if (!isset($settings['nodes'])) {
+            $settings['nodes'] = [];
+        }
+        foreach ($settings['nodes'] as &$node) {
+            if (str_contains($node['id'], 'new')) {
+                $node['id'] = str_replace($node['id'], $tempIds[$node['id']], $node['id']);
+            }
+        }
+        if (!isset($settings['connections'])) {
+            $settings['connections'] = [];
+        }
+        foreach ($settings['connections'] as &$connection) {
+            if (str_contains($connection['sourceId'], 'new')) {
+                $connection['sourceId'] = str_replace($connection['sourceId'], $tempIds[$connection['sourceId']], $connection['sourceId']);
+            }
+            if (str_contains($connection['targetId'], 'new')) {
+                $connection['targetId'] = str_replace($connection['targetId'], $tempIds[$connection['targetId']], $connection['targetId']);
+            }
+            if (!isset($connection['anchors']['source'])) {
+                $anchors = [];
+                foreach ($connection['anchors'] as $k => $anchor) {
+                    $type           = (0 === $k) ? 'source' : 'target';
+                    $anchors[$type] = $anchor['endpoint'];
+                }
+                $connection['anchors'] = $anchors;
+            }
+        }
+        $entity->setCanvasSettings($settings);
+        if ($persist) {
+            $this->getRepository()->saveEntity($entity);
+        }
+        return $settings;
+    }
+    /**
+     * Get list of sources for a campaign.
+     */
+    public function getLeadSources($campaign): array
+    {
+        $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
+        $sources = [];
+        $sources['lists'] = $this->getRepository()->getCampaignListSources($campaignId);
+        $sources['forms'] = $this->getRepository()->getCampaignFormSources($campaignId);
+        return $sources;
+    }
+    /**
+     * Add and/or delete lead sources from a campaign.
+     */
+    public function setLeadSources(Campaign $entity, $addedSources, $deletedSources): void
+    {
+        foreach ($addedSources as $type => $sources) {
+            foreach ($sources as $id => $label) {
+                switch ($type) {
+                    case 'lists':
+                        $entity->addList($this->em->getReference(\Mautic\LeadBundle\Entity\LeadList::class, $id));
+                        break;
+                    case 'forms':
+                        $entity->addForm($this->em->getReference(Form::class, $id));
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        foreach ($deletedSources as $type => $sources) {
+            foreach ($sources as $id => $label) {
+                switch ($type) {
+                    case 'lists':
+                        $entity->removeList($this->em->getReference(\Mautic\LeadBundle\Entity\LeadList::class, $id));
+                        break;
+                    case 'forms':
+                        $entity->removeForm($this->em->getReference(Form::class, $id));
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+    }
+    /**
+     * Get a list of source choices.
+     *
+     * @param string $sourceType
+     * @param bool   $globalOnly
+     */
+    public function getSourceLists($sourceType = null, $globalOnly = false): array
+    {
+        $choices = [];
+        switch ($sourceType) {
+            case 'lists':
+            case null:
+                $choices['lists'] = [];
+                $lists            = $globalOnly ? $this->leadListModel->getGlobalLists() : $this->leadListModel->getUserLists();
+                if ($lists) {
+                    foreach ($lists as $list) {
+                        $choices['lists'][$list['id']] = $list['name'];
+                    }
+                }
+            case 'forms':
+            case null:
+                $choices['forms'] = [];
+                $viewOther        = $this->security->isGranted('form:forms:viewother');
+                $repo             = $this->formModel->getRepository();
+                $repo->setCurrentUser($this->userHelper->getUser());
+                $forms = $repo->getFormList('', 0, 0, $viewOther, 'campaign');
+                foreach ($forms as $form) {
+                    $choices['forms'][$form['id']] = $form['name'];
+                }
+        }
+        foreach ($choices as &$typeChoices) {
+            asort($typeChoices);
+        }
+        return (null == $sourceType) ? $choices : $choices[$sourceType];
+    }
+    /**
+     * @param mixed $form
+     *
+     * @return array
+     */
+    public function getCampaignsByForm($form)
+    {
+        $formId = ($form instanceof Form) ? $form->getId() : $form;
+        return $this->getRepository()->findByFormId($formId);
+    }
+    /**
+     * Gets the campaigns a specific lead is part of.
+     *
+     * @param bool $forList
+     *
+     * @return mixed
+     */
+    public function getLeadCampaigns(Lead $lead = null, $forList = false)
+    {
+        static $campaigns = [];
+        if (null === $lead) {
+            $lead = $this->contactTracker->getContact();
+        }
+        if (!isset($campaigns[$lead->getId()])) {
+            $repo   = $this->getRepository();
+            $leadId = $lead->getId();
+            $campaigns[$leadId] = $repo->getPublishedCampaigns(
+                null,
+                $lead->getId(),
+                $forList,
+                $this->security->isGranted($this->getPermissionBase().':viewother')
+            );
+        }
+        return $campaigns[$lead->getId()];
+    }
+    /**
+     * Gets a list of published campaigns.
+     *
+     * @return array
+     */
+    public function getPublishedCampaigns(bool $forList = false)
+    {
+        static $campaigns = [];
+        if (empty($campaigns)) {
+            $campaigns = $this->getRepository()->getPublishedCampaigns(
+                null,
+                null,
+                $forList,
+                $this->security->isGranted($this->getPermissionBase().':viewother')
+            );
+        }
+        return $campaigns;
+    }
+    /**
+     * Saves a campaign lead, logs the error if saving fails.
+     */
+    public function saveCampaignLead(CampaignLead $campaignLead): bool
+    {
+        try {
+            $this->getCampaignLeadRepository()->saveEntity($campaignLead);
+            return true;
+        } catch (\Exception $exception) {
+            $this->logger->log('error', $exception->getMessage(), ['exception' => $exception]);
+            return false;
+        }
+    }
+    /**
+     * Get details of leads in a campaign.
+     *
+     * @return mixed
+     */
+    public function getLeadDetails($campaign, $leads = null)
+    {
+        $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
+        if ($leads instanceof PersistentCollection) {
+            $leads = array_keys($leads->toArray());
+        }
+        return $this->em->getRepository(CampaignLead::class)->getLeadDetails($campaignId, $leads);
+    }
+    /**
+     * Get leads for a campaign.  If $event is passed in, only leads who have not triggered the event are returned.
+     *
+     * @param Campaign $campaign
+     * @param array    $event
+     *
+     * @return mixed
+     */
+    public function getCampaignLeads($campaign, $event = null)
+    {
+        $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
+        $eventId    = (is_array($event) && isset($event['id'])) ? $event['id'] : $event;
+        return $this->em->getRepository(CampaignLead::class)->getLeads($campaignId, $eventId);
+    }
+    public function getCampaignListIds($id): array
+    {
+        return $this->getRepository()->getCampaignListIds((int) $id);
+    }
+    /**
+     * Get line chart data of leads added to campaigns.
+     *
+     * @param string $unit          {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
+     * @param string $dateFormat
+     * @param array  $filter
+     * @param bool   $canViewOthers
+     */
+    public function getLeadsAddedLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = [], $canViewOthers = true): array
+    {
+        $chart = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
+        $query = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $q     = $query->prepareTimeDataQuery('campaign_leads', 'date_added', $filter);
+        if (!$canViewOthers) {
+            $q->join('t', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = c.campaign_id')
+                ->andWhere('c.created_by = :userId')
+                ->setParameter('userId', $this->userHelper->getUser()->getId());
+        }
+        $data = $query->loadAndBuildTimeData($q);
+        $chart->setDataset($this->translator->trans('mautic.campaign.campaign.leads'), $data);
+        return $chart->render();
+    }
+    /**
+     * Get line chart data of hits.
+     *
+     * @param string|null $unit       {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
+     * @param string      $dateFormat
+     * @param array       $filter
+     */
+    public function getCampaignMetricsLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = []): array
+    {
+        $events = [];
+        $chart  = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
+        $query  = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
+        $contacts = $query->fetchTimeData('campaign_leads', 'date_added', $filter);
+        $chart->setDataset($this->translator->trans('mautic.campaign.campaign.leads'), $contacts);
+        if (isset($filter['campaign_id'])) {
+            $rawEvents = $this->getEventRepository()->getCampaignEvents($filter['campaign_id']);
+            foreach ($rawEvents as $event) {
+                if (isset($events[$event['type']])) {
+                    $events[$event['type']][] = $event['id'];
+                } else {
+                    $events[$event['type']] = [$event['id']];
+                }
+            }
+            if ($events) {
+                foreach ($events as $type => $eventIds) {
+                    $filter['event_id'] = $eventIds;
+                    if ($this->coreParametersHelper->get('campaign_use_summary')) {
+                        $q       = $query->prepareTimeDataQuery('campaign_summary', 'date_triggered', $filter, 'triggered_count + non_action_path_taken_count', 'sum');
+                        $rawData = $q->executeQuery()->fetchAllAssociative();
+                    } else {
+                        $failedSq = $this->em->getConnection()->createQueryBuilder();
+                        $failedSq->select('null')
+                            ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fe')
+                            ->where(
+                                $failedSq->expr()->eq('fe.log_id', 't.id')
+                            );
+                        $filter['failed_events'] = [
+                            'subquery' => sprintf('NOT EXISTS (%s)', $failedSq->getSQL()),
+                        ];
+                        $q       = $query->prepareTimeDataQuery('campaign_lead_event_log', 'date_triggered', $filter);
+                        $rawData = $q->executeQuery()->fetchAllAssociative();
+                    }
+                    if (!empty($rawData)) {
+                        $triggers = $query->completeTimeData($rawData);
+                        $chart->setDataset($this->translator->trans('mautic.campaign.'.$type), $triggers);
+                    }
+                }
+                unset($filter['event_id']);
+            }
+        }
+        return $chart->render();
+    }
+    /**
+     * @param Campaign $entity
+     * @param string   $root
+     * @param int      $order
+     */
+    protected function buildOrder($hierarchy, &$events, $entity, $root = 'null', $order = 1)
+    {
+        $count = count($hierarchy);
+        if (1 === $count && 'null' === array_unique(array_values($hierarchy))[0]) {
+            return;
+        } else {
+            foreach ($hierarchy as $eventId => $parent) {
+                if ($parent == $root || 1 === $count) {
+                    $events[$eventId]->setOrder($order);
+                    unset($hierarchy[$eventId]);
+                    if (count($hierarchy)) {
+                        $this->buildOrder($hierarchy, $events, $entity, $eventId, $order + 1);
+                    }
+                }
+            }
+        }
+    }
+    /**
+     * @param int  $limit
+     * @param bool $maxLeads
+     */
+    public function rebuildCampaignLeads(Campaign $campaign, $limit = 1000, $maxLeads = false, OutputInterface $output = null): int
+    {
+        $contactLimiter = new ContactLimiter($limit);
+        return $this->membershipBuilder->build($campaign, $contactLimiter, $maxLeads, $output);
+    }
+    public function getCampaignIdsWithDependenciesOnSegment($segmentId): array
+    {
+        $entities = $this->getRepository()->getEntities(
+            [
+                'filter'    => [
+                    'force' => [
+                        [
+                            'column' => 'l.id',
+                            'expr'   => 'eq',
+                            'value'  => $segmentId,
+                        ],
+                    ],
+                ],
+                'joinLists' => true,
+            ]
+        );
+        $ids = [];
+        foreach ($entities as $entity) {
+            $ids[] = $entity->getId();
+        }
+        return $ids;
+    }
+    /**
+     * @return array<int, int>
+     */
+    public function getCampaignIdsWithDependenciesOnEmail(int $emailId): array
+    {
+        return $this->getRepository()->getCampaignIdsWithDependenciesOnEmail($emailId);
+    }
+    /**
+     * @return array<int, int>
+     */
+    public function getCampaignIdsWithDependenciesOnTagName(string $tagName): array
+    {
+        $entities = $this->getEventRepository()->getEntities(
+            [
+                'filter' => [
+                    'force'  => [
+                        [
+                            'column' => 'e.type',
+                            'expr'   => 'IN',
+                            'value'  => ['lead.changetags', 'lead.tags'],
+                        ],
+                    ],
+                ],
+            ]
+        );
+        $dependents = [];
+        /** @var Event $entity */
+        foreach ($entities as $entity) {
+            $type       = $entity->getType();
+            $properties = $entity->getProperties();
+            if ('lead.changetags' === $type) {
+                $eventTags = array_merge([], $properties['add_tags'], $properties['remove_tags']);
+            }
+            if ('lead.tags' === $type) {
+                $eventTags = $properties['tags'];
+            }
+            if (in_array($tagName, $eventTags)) {
+                $dependents[] = $entity->getCampaign()->getId();
+            }
+        }
+        return array_unique($dependents);
+    }
+    /**
+     * @return array<string, array<int, array<string, int|string>>>
+     *
+     * @throws Exception
+     */
+    public function getCountryStats(Campaign $entity, \DateTimeImmutable $dateFrom, \DateTimeImmutable $dateTo): array
+    {
+        /** @var StatRepository $statRepo */
+        $statRepo            = $this->em->getRepository(Stat::class);
+        $results['contacts'] =  $this->getCampaignMembersGroupByCountry($entity, $dateFrom, $dateTo);
+        if ($entity->isEmailCampaign()) {
+            $eventsEmailsSend     = $entity->getEmailSendEvents();
+            $eventsIds            = $eventsEmailsSend->getKeys();
+            $emailIds             = [];
+            foreach ($eventsEmailsSend as $event) {
+                $emailIds[] = $event->getChannelId();
+            }
+            $emailStats            = $statRepo->getStatsSummaryByCountry($dateFrom, $dateTo, $emailIds, 'campaign', $eventsIds);
+            $results['read_count'] = $results['clicked_through_count'] = [];
+            foreach ($emailStats as $e) {
+                $results['read_count'][]            = array_intersect_key($e, array_flip(['country', 'read_count']));
+                $results['clicked_through_count'][] = array_intersect_key($e, array_flip(['country', 'clicked_through_count']));
+            }
+        }
+        return $results;
+    }
+    /**
+     * Get leads in a campaign grouped by country.
+     *
+     * @return array{}|array<int, array<string, string|null>>
+     */
+    public function getCampaignMembersGroupByCountry(Campaign $campaign, \DateTimeImmutable $dateFromObject, \DateTimeImmutable $dateToObject): array
+    {
+        return $this->em->getRepository(CampaignLead::class)->getCampaignMembersGroupByCountry($campaign, $dateFromObject, $dateToObject);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Model/EventLogModel.php
@@ -0,0 +1,191 @@
+<?php
+namespace Mautic\CampaignBundle\Model;
+use Doctrine\ORM\EntityManager;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
+use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\InputHelper;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\AbstractCommonModel;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Entity\Lead;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+/**
+ * @extends AbstractCommonModel<LeadEventLog>
+ */
+class EventLogModel extends AbstractCommonModel
+{
+    public function __construct(
+        protected EventModel $eventModel,
+        protected CampaignModel $campaignModel,
+        protected IpLookupHelper $ipLookupHelper,
+        protected EventScheduler $eventScheduler,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    public function getRepository(): LeadEventLogRepository
+    {
+        return $this->em->getRepository(LeadEventLog::class);
+    }
+    public function getPermissionBase(): string
+    {
+        return 'campaign:campaigns';
+    }
+    public function getEntities(array $args = [])
+    {
+        /** @var LeadEventLog[] $logs */
+        $logs = parent::getEntities($args);
+        if (!empty($args['campaign_id']) && !empty($args['contact_id'])) {
+            /** @var Event[] $events */
+            $events = $this->eventModel->getEntities(
+                [
+                    'campaign_id'      => $args['campaign_id'],
+                    'ignore_children'  => true,
+                    'index_by'         => 'id',
+                    'ignore_paginator' => true,
+                ]
+            );
+            foreach ($logs as $log) {
+                $event = $log->getEvent()->getId();
+                $events[$event]->addContactLog($log);
+            }
+            return array_values($events);
+        }
+        return $logs;
+    }
+    /**
+     * @return string|mixed[]
+     */
+    public function updateContactEvent(Event $event, Lead $contact, array $parameters): string|array
+    {
+        $campaign = $event->getCampaign();
+        $membership = $campaign->getContactMembership($contact);
+        if (0 === count($membership)) {
+            return $this->translator->trans(
+                'mautic.campaign.error.contact_not_in_campaign',
+                ['%campaign%' => $campaign->getId(), '%contact%' => $contact->getId()],
+                'flashes'
+            );
+        }
+        /** @var \Mautic\CampaignBundle\Entity\Lead $m */
+        foreach ($membership as $m) {
+            if ($m->getManuallyRemoved()) {
+                return $this->translator->trans(
+                    'mautic.campaign.error.contact_not_in_campaign',
+                    ['%campaign%' => $campaign->getId(), '%contact%' => $contact->getId()],
+                    'flashes'
+                );
+            }
+        }
+        $logs    = $event->getContactLog($contact);
+        $created = false;
+        if (count($logs)) {
+            $log = $logs[0];
+            if ($log->getDateTriggered()) {
+                return $this->translator->trans(
+                    'mautic.campaign.error.event_already_executed',
+                    [
+                        '%campaign%'      => $campaign->getId(),
+                        '%event%'         => $event->getId(),
+                        '%contact%'       => $contact->getId(),
+                        '%dateTriggered%' => $log->getDateTriggered()->format(\DateTimeInterface::ATOM),
+                    ],
+                    'flashes'
+                );
+            }
+        } else {
+            if (!isset($parameters['triggerDate']) && !isset($parameters['dateTriggered'])) {
+                return $this->translator->trans(
+                    'mautic.campaign.error.event_must_be_scheduled',
+                    [
+                        '%campaign%' => $campaign->getId(),
+                        '%event%'    => $event->getId(),
+                        '%contact%'  => $contact->getId(),
+                    ],
+                    'flashes'
+                );
+            }
+            $log = (new LeadEventLog())
+                ->setLead($contact)
+                ->setEvent($event);
+            $created = true;
+        }
+        foreach ($parameters as $property => $value) {
+            switch ($property) {
+                case 'dateTriggered':
+                    $log->setDateTriggered(
+                        new \DateTime($value)
+                    );
+                    break;
+                case 'triggerDate':
+                    if (Event::TYPE_DECISION === $event->getEventType()) {
+                        return $this->translator->trans(
+                            'mautic.campaign.error.decision_cannot_be_scheduled',
+                            [
+                                '%campaign%' => $campaign->getId(),
+                                '%event%'    => $event->getId(),
+                                '%contact%'  => $contact->getId(),
+                            ],
+                            'flashes'
+                        );
+                    }
+                    $log->setTriggerDate(
+                        new \DateTime($value)
+                    );
+                    break;
+                case 'ipAddress':
+                    if (!defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED')) {
+                        $log->setIpAddress(
+                            $this->ipLookupHelper->getIpAddress($value)
+                        );
+                    }
+                    break;
+                case 'metadata':
+                    $metadata = $log->getMetadata();
+                    if (is_array($value)) {
+                        $newMetadata = $value;
+                    } elseif ($jsonDecoded = json_decode($value, true)) {
+                        $newMetadata = $jsonDecoded;
+                    } else {
+                        $newMetadata = (array) $value;
+                    }
+                    $newMetadata = InputHelper::cleanArray($newMetadata);
+                    $log->setMetadata(array_merge($metadata, $newMetadata));
+                    break;
+                case 'nonActionPathTaken':
+                    $log->setNonActionPathTaken((bool) $value);
+                    break;
+                case 'channel':
+                    $log->setChannel(InputHelper::clean($value));
+                    break;
+                case 'channelId':
+                    $log->setChannel(intval($value));
+                    break;
+            }
+        }
+        $this->saveEntity($log);
+        return [$log, $created];
+    }
+    public function saveEntity(LeadEventLog $entity): void
+    {
+        $triggerDate = $entity->getTriggerDate();
+        if (null === $triggerDate) {
+            $triggerDate = new \DateTime();
+        }
+        $this->eventScheduler->reschedule($entity, $triggerDate);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Service/Campaign.php
@@ -0,0 +1,28 @@
+<?php
+namespace Mautic\CampaignBundle\Service;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\EmailBundle\Entity\EmailRepository;
+/**
+ * @deprecated to be removed in 6.0; use CampaignAuditService instead
+ */
+class Campaign
+{
+    public function __construct(
+        private CampaignRepository $campaignRepository,
+        private EmailRepository $emailRepository,
+    ) {
+    }
+    /**
+     * Has campaign at least one unpublished e-mail?
+     *
+     * @param int $id
+     */
+    public function hasUnpublishedEmail($id): bool
+    {
+        $emailIds = $this->campaignRepository->fetchEmailIdsById($id);
+        if (!$emailIds) {
+            return false;
+        }
+        return $this->emailRepository->isOneUnpublished($emailIds);
+    }
+}

--- a//dev/null
+++ b/app/bundles/CampaignBundle/Service/CampaignAuditService.php
@@ -0,0 +1,43 @@
+<?php
+namespace Mautic\CampaignBundle\Service;
+use Mautic\CampaignBundle\Entity\Campaign;
+use Mautic\CampaignBundle\Entity\CampaignRepository;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\EmailBundle\Entity\Email;
+use Mautic\EmailBundle\Entity\EmailRepository;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+class CampaignAuditService
+{
+    public function __construct(
+        private FlashBag $flashBag,
+        private UrlGeneratorInterface $urlGenerator,
+        private CampaignRepository $campaignRepository,
+        private EmailRepository $emailRepository,
+    ) {
+    }
+    public function addWarningForUnpublishedEmails(Campaign $campaign): void
+    {
+        $emailIds = $this->campaignRepository->fetchEmailIdsById($campaign->getId());
+        $emails   = $this->emailRepository->findBy(['id' => $emailIds]);
+        foreach ($emails as $email) {
+            if (!$email->isPublished()) {
+                $this->setEmailWarningFlashMessage($email);
+            }
+        }
+    }
+    private function setEmailWarningFlashMessage(Email $email): void
+    {
+        $this->flashBag->add(
+            'mautic.core.notice.campaign.unpublished.email',
+            [
+                '%name%'      => $email->getName(),
+                '%menu_link%' => 'mautic_email_index',
+                '%url%'       => $this->urlGenerator->generate('mautic_email_action', [
+                    'objectAction' => 'edit',
+                    'objectId'     => $email->getId(),
+                ]),
+            ],
+            FlashBag::LEVEL_WARNING,
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Controller/Api/CategoryApiController.php
@@ -0,0 +1,64 @@
+<?php
+namespace Mautic\CategoryBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Controller\CommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\CategoryBundle\Entity\Category;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\Routing\RouterInterface;
+/**
+ * @extends CommonApiController<Category>
+ */
+class CategoryApiController extends CommonApiController
+{
+    public function __construct(CorePermissions $security, Translator $translator, EntityResultHelper $entityResultHelper, RouterInterface $router, FormFactoryInterface $formFactory, AppVersion $appVersion, RequestStack $requestStack, ManagerRegistry $doctrine, ModelFactory $modelFactory, EventDispatcherInterface $dispatcher, CoreParametersHelper $coreParametersHelper)
+    {
+        $categoryModel = $modelFactory->getModel('category');
+        \assert($categoryModel instanceof CategoryModel);
+        $this->model            = $categoryModel;
+        $this->entityClass      = Category::class;
+        $this->entityNameOne    = 'category';
+        $this->entityNameMulti  = 'categories';
+        $this->serializerGroups = ['categoryDetails'];
+        parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    /**
+     * Checks if user has permission to access retrieved entity.
+     *
+     * @param Category $entity
+     * @param string   $action view|create|edit|publish|delete
+     *
+     * @return bool
+     */
+    protected function checkEntityAccess($entity, $action = 'view')
+    {
+        if (!$bundle = $entity->getBundle()) {
+            $bundle = 'category';
+        }
+        $permissionBase = $this->permissionBase;
+        if ($this->security->checkPermissionExists($bundle.':categories:'.$action)) {
+            $permissionBase = $bundle.':categories';
+        }
+        if ('create' != $action) {
+            $ownPerm   = "$permissionBase:{$action}own";
+            $otherPerm = "$permissionBase:{$action}other";
+            return $this->security->hasEntityAccess($ownPerm, $otherPerm, $entity->getCreatedBy());
+        }
+        return $this->security->isGranted("$permissionBase:create");
+    }
+    /**
+     * @return array<string, mixed>
+     */
+    protected function getEntityFormOptions(): array
+    {
+        return ['show_bundle_select' => true];
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Controller/BatchContactController.php
@@ -0,0 +1,91 @@
+<?php
+namespace Mautic\CategoryBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CategoryBundle\Model\ContactActionModel;
+use Mautic\CoreBundle\Controller\AbstractFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Form\Type\BatchType;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+class BatchContactController extends AbstractFormController
+{
+    public function __construct(
+        private ContactActionModel $actionModel,
+        private CategoryModel $categoryModel,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * Adds or removes categories to multiple contacts defined by contact ID.
+     */
+    public function execAction(Request $request): JsonResponse
+    {
+        $params = $request->get('lead_batch');
+        $ids    = empty($params['ids']) ? [] : json_decode($params['ids']);
+        if ($ids && is_array($ids)) {
+            $categoriesToAdd    = $params['add'] ?? [];
+            $categoriesToRemove = $params['remove'] ?? [];
+            $contactIds         = json_decode($params['ids']);
+            $this->actionModel->addContactsToCategories($contactIds, $categoriesToAdd);
+            $this->actionModel->removeContactsFromCategories($contactIds, $categoriesToRemove);
+            $this->addFlashMessage('mautic.lead.batch_leads_affected', [
+                '%count%'     => count($ids),
+            ]);
+        } else {
+            $this->addFlashMessage('mautic.core.error.ids.missing');
+        }
+        return new JsonResponse([
+            'closeModal' => true,
+            'flashes'    => $this->getFlashContent(),
+        ]);
+    }
+    /**
+     * View the modal form for adding contacts into categories in batches.
+     */
+    public function indexAction(): \Symfony\Component\HttpFoundation\Response
+    {
+        $route = $this->generateUrl('mautic_category_batch_contact_set');
+        $rows  = $this->categoryModel->getLookupResults('global', '', 300);
+        $items = [];
+        foreach ($rows as $category) {
+            $items[$category['title']] = $category['id'];
+        }
+        return $this->delegateView(
+            [
+                'viewParameters' => [
+                    'form' => $this->createForm(
+                        BatchType::class,
+                        [],
+                        [
+                            'items'  => $items,
+                            'action' => $route,
+                        ]
+                    )->createView(),
+                ],
+                'contentTemplate' => '@MauticLead/Batch/form.html.twig',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_contact_index',
+                    'mauticContent' => 'leadBatch',
+                    'route'         => $route,
+                ],
+            ]
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Controller/CategoryController.php
@@ -0,0 +1,531 @@
+<?php
+namespace Mautic\CategoryBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\CategoryBundle\CategoryEvents;
+use Mautic\CategoryBundle\Event\CategoryTypesEvent;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CoreBundle\Controller\AbstractFormController;
+use Mautic\CoreBundle\Exception\RecordCanNotBeDeletedException;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\Form\SubmitButton;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+class CategoryController extends AbstractFormController
+{
+    public function __construct(
+        private FormFactoryInterface $formFactory,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * @param int    $objectId
+     * @param string $objectModel
+     */
+    public function executeCategoryAction(Request $request, $bundle, $objectAction, $objectId = 0, $objectModel = ''): Response
+    {
+        if (method_exists($this, $objectAction.'Action')) {
+            return $this->forward(
+                static::class.'::'.$objectAction.'Action',
+                [
+                    'bundle'      => $bundle,
+                    'objectId'    => $objectId,
+                    'objectModel' => $objectModel,
+                ],
+                $request->query->all()
+            );
+        }
+        return $this->accessDenied();
+    }
+    /**
+     * @param int $page
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function indexAction(Request $request, $bundle, $page = 1)
+    {
+        $session = $request->getSession();
+        $search = $request->query->get('search', $session->get('mautic.category.filter', ''));
+        $bundle = $request->query->get('bundle', $session->get('mautic.category.type', $bundle));
+        if ($bundle) {
+            $session->set('mautic.category.type', $bundle);
+        }
+        if ('all' == $bundle) {
+            $bundle = 'category';
+        }
+        $session->set('mautic.category.filter', $search);
+        $categoryModel  = $this->getModel('category');
+        \assert($categoryModel instanceof CategoryModel);
+        $permissionBase = $categoryModel->getPermissionBase($bundle);
+        $permissions    = $this->security->isGranted(
+            [
+                $permissionBase.':view',
+                $permissionBase.':create',
+                $permissionBase.':edit',
+                $permissionBase.':delete',
+            ],
+            'RETURN_ARRAY'
+        );
+        if (!$permissions[$permissionBase.':view']) {
+            return $this->accessDenied();
+        }
+        $this->setListFilters();
+        $viewParams = [
+            'page'   => $page,
+            'bundle' => $bundle,
+        ];
+        $limit = $session->get('mautic.category.limit', $this->coreParametersHelper->get('default_pagelimit'));
+        $start = (1 === $page) ? 0 : (($page - 1) * $limit);
+        if ($start < 0) {
+            $start = 0;
+        }
+        $filter = ['string' => $search];
+        if ('category' != $bundle) {
+            $filter['force'] = [
+                [
+                    'column' => 'c.bundle',
+                    'expr'   => 'eq',
+                    'value'  => $bundle,
+                ],
+            ];
+        }
+        $orderBy    = $request->getSession()->get('mautic.category.orderby', 'c.title');
+        $orderByDir = $request->getSession()->get('mautic.category.orderbydir', 'DESC');
+        $entities = $categoryModel->getEntities(
+            [
+                'start'      => $start,
+                'limit'      => $limit,
+                'filter'     => $filter,
+                'orderBy'    => $orderBy,
+                'orderByDir' => $orderByDir,
+            ]
+        );
+        $count = count($entities);
+        if ($count && $count < ($start + 1)) {
+            if (1 === $count) {
+                $lastPage = 1;
+            } else {
+                $lastPage = (ceil($count / $limit)) ?: 1;
+            }
+            $viewParams['page'] = $lastPage;
+            $session->set('mautic.category.page', $lastPage);
+            $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
+            return $this->postActionRedirect(
+                [
+                    'returnUrl'       => $returnUrl,
+                    'viewParameters'  => ['page' => $lastPage],
+                    'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+                    'passthroughVars' => [
+                        'activeLink'    => '#mautic_'.$bundle.'category_index',
+                        'mauticContent' => 'category',
+                    ],
+                ]
+            );
+        }
+        $categoryTypes = ['category' => $this->translator->trans('mautic.core.select')];
+        $dispatcher = $this->dispatcher;
+        if ($dispatcher->hasListeners(CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD)) {
+            $event = new CategoryTypesEvent();
+            $dispatcher->dispatch($event, CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD);
+            $categoryTypes = array_merge($categoryTypes, $event->getCategoryTypes());
+        }
+        $session->set('mautic.category.page', $page);
+        $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
+        return $this->delegateView(
+            [
+                'returnUrl'      => $this->generateUrl('mautic_category_index', $viewParams),
+                'viewParameters' => [
+                    'bundle'         => $bundle,
+                    'permissionBase' => $permissionBase,
+                    'searchValue'    => $search,
+                    'items'          => $entities,
+                    'page'           => $page,
+                    'limit'          => $limit,
+                    'permissions'    => $permissions,
+                    'tmpl'           => $tmpl,
+                    'categoryTypes'  => $categoryTypes,
+                ],
+                'contentTemplate' => '@MauticCategory/Category/list.html.twig',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_'.$bundle.'category_index',
+                    'mauticContent' => 'category',
+                    'route'         => $this->generateUrl('mautic_category_index', $viewParams),
+                ],
+            ]
+        );
+    }
+    /**
+     * Generates new form and processes post data.
+     *
+     * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function newAction(Request $request, $bundle)
+    {
+        $model = $this->getModel('category');
+        \assert($model instanceof CategoryModel);
+        $session    = $request->getSession();
+        $entity     = $model->getEntity();
+        $success    = 0;
+        $cancelled  = $valid  = false;
+        $method     = $request->getMethod();
+        $inForm     = $this->getInFormValue($request, $method);
+        $showSelect = $request->get('show_bundle_select', false);
+        if (!$this->security->isGranted($model->getPermissionBase($bundle).':create')) {
+            return $this->modalAccessDenied();
+        }
+        $action = $this->generateUrl('mautic_category_action', [
+            'objectAction' => 'new',
+            'bundle'       => $bundle,
+        ]);
+        $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle, 'show_bundle_select' => $showSelect]);
+        $form['inForm']->setData($inForm);
+        if (Request::METHOD_POST === $method) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $success = 1;
+                    $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
+                    $this->addFlashMessage('mautic.category.notice.created', [
+                        '%name%' => $entity->getTitle(),
+                    ]);
+                }
+            } else {
+                $success = 1;
+            }
+        }
+        $closeModal = ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked()));
+        if ($closeModal) {
+            if ($inForm) {
+                return new JsonResponse([
+                    'mauticContent' => 'category',
+                    'closeModal'    => 1,
+                    'inForm'        => 1,
+                    'categoryName'  => $entity->getTitle(),
+                    'categoryId'    => $entity->getId(),
+                ]);
+            }
+            $viewParameters = [
+                'page'   => $session->get('mautic.category.page'),
+                'bundle' => $bundle,
+            ];
+            return $this->postActionRedirect([
+                'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParameters),
+                'viewParameters'  => $viewParameters,
+                'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_'.$bundle.'category_index',
+                    'mauticContent' => 'category',
+                    'closeModal'    => 1,
+                ],
+            ]);
+        } elseif (!empty($valid)) {
+            return $this->editAction($request, $bundle, $entity->getId(), true);
+        } else {
+            return $this->ajaxAction(
+                $request,
+                [
+                    'contentTemplate' => '@MauticCategory/Category/form.html.twig',
+                    'viewParameters'  => [
+                        'form'           => $form->createView(),
+                        'activeCategory' => $entity,
+                        'bundle'         => $bundle,
+                    ],
+                    'passthroughVars' => [
+                        'mauticContent' => 'category',
+                        'success'       => $success,
+                        'route'         => false,
+                    ],
+                ]
+            );
+        }
+    }
+    /**
+     * Generates edit form and processes post data.
+     *
+     * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function editAction(Request $request, $bundle, $objectId, $ignorePost = false)
+    {
+        $session = $request->getSession();
+        $model   = $this->getModel('category');
+        \assert($model instanceof CategoryModel);
+        $entity    = $model->getEntity($objectId);
+        $success   = $closeModal   = 0;
+        $cancelled = $valid = false;
+        $method    = $request->getMethod();
+        $inForm    = $this->getInFormValue($request, $method);
+        if (null === $entity) {
+            $closeModal = true;
+        } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':view')) {
+            return $this->modalAccessDenied();
+        } elseif ($model->isLocked($entity)) {
+            $viewParams = [
+                'page'   => $session->get('mautic.category.page', 1),
+                'bundle' => $bundle,
+            ];
+            $postActionVars = [
+                'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParams),
+                'viewParameters'  => $viewParams,
+                'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+                'passthroughVars' => [
+                    'activeLink'    => 'mautic_'.$bundle.'category_index',
+                    'mauticContent' => 'category',
+                    'closeModal'    => 1,
+                ],
+            ];
+            return $this->isLocked($postActionVars, $entity, 'category.category');
+        }
+        $action = $this->generateUrl(
+            'mautic_category_action',
+            [
+                'objectAction' => 'edit',
+                'objectId'     => $objectId,
+                'bundle'       => $bundle,
+            ]
+        );
+        $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle]);
+        $form['inForm']->setData($inForm);
+        if (!$ignorePost && 'POST' == $method) {
+            $valid = false;
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                if ($valid = $this->isFormValid($form)) {
+                    $success = 1;
+                    $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
+                    $this->addFlashMessage(
+                        'mautic.category.notice.updated',
+                        [
+                            '%name%' => $entity->getTitle(),
+                        ]
+                    );
+                    /** @var SubmitButton $applySubmitButton */
+                    $applySubmitButton = $form->get('buttons')->get('apply');
+                    if ($applySubmitButton->isClicked()) {
+                        $action = $this->generateUrl(
+                            'mautic_category_action',
+                            [
+                                'objectAction' => 'edit',
+                                'objectId'     => $entity->getId(),
+                                'bundle'       => $bundle,
+                            ]
+                        );
+                        $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle]);
+                    }
+                }
+            } else {
+                $success = 1;
+                $model->unlockEntity($entity);
+            }
+        } else {
+            $model->lockEntity($entity);
+        }
+        $closeModal = ($closeModal || $cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked()));
+        if ($closeModal) {
+            if ($inForm) {
+                return new JsonResponse(
+                    [
+                        'mauticContent' => 'category',
+                        'closeModal'    => 1,
+                        'inForm'        => 1,
+                        'categoryName'  => $entity->getTitle(),
+                        'categoryId'    => $entity->getId(),
+                    ]
+                );
+            }
+            $viewParameters = [
+                'page'   => $session->get('mautic.category.page'),
+                'bundle' => $bundle,
+            ];
+            return $this->postActionRedirect(
+                [
+                    'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParameters),
+                    'viewParameters'  => $viewParameters,
+                    'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+                    'passthroughVars' => [
+                        'activeLink'    => '#mautic_'.$bundle.'category_index',
+                        'mauticContent' => 'category',
+                        'closeModal'    => 1,
+                    ],
+                ]
+            );
+        } else {
+            return $this->ajaxAction(
+                $request,
+                [
+                    'contentTemplate' => '@MauticCategory/Category/form.html.twig',
+                    'viewParameters'  => [
+                        'form'           => $form->createView(),
+                        'activeCategory' => $entity,
+                        'bundle'         => $bundle,
+                    ],
+                    'passthroughVars' => [
+                        'mauticContent' => 'category',
+                        'success'       => $success,
+                        'route'         => false,
+                    ],
+                ]
+            );
+        }
+    }
+    /**
+     * Deletes the entity.
+     *
+     * @return Response
+     */
+    public function deleteAction(Request $request, $bundle, $objectId)
+    {
+        $session    = $request->getSession();
+        $page       = $session->get('mautic.category.page', 1);
+        $viewParams = [
+            'page'   => $page,
+            'bundle' => $bundle,
+        ];
+        $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
+        $flashes   = [];
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'viewParameters'  => $viewParams,
+            'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => 'mautic_'.$bundle.'category_index',
+                'mauticContent' => 'category',
+            ],
+        ];
+        if (Request::METHOD_POST === $request->getMethod()) {
+            $model  = $this->getModel('category');
+            \assert($model instanceof CategoryModel);
+            $entity = $model->getEntity($objectId);
+            if (null === $entity) {
+                $flashes[] = [
+                    'type'    => 'error',
+                    'msg'     => 'mautic.category.error.notfound',
+                    'msgVars' => ['%id%' => $objectId],
+                ];
+            } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':delete')) {
+                return $this->accessDenied();
+            } elseif ($model->isLocked($entity)) {
+                return $this->isLocked($postActionVars, $entity, 'category.category');
+            }
+            try {
+                $model->deleteEntity($entity);
+                $flashes[] = [
+                    'type'    => 'notice',
+                    'msg'     => 'mautic.core.notice.deleted',
+                    'msgVars' => [
+                        '%name%' => $entity->getTitle(),
+                        '%id%'   => $objectId,
+                    ],
+                ];
+            } catch (RecordCanNotBeDeletedException $exception) {
+                $postActionVars['responseCode'] = Response::HTTP_UNPROCESSABLE_ENTITY;
+                $flashes[]                      = [
+                    'type' => 'notice',
+                    'msg'  => $exception->getMessage(),
+                ];
+            }
+        } // else don't do anything
+        return $this->postActionRedirect(
+            array_merge($postActionVars, [
+                'flashes' => $flashes,
+            ])
+        );
+    }
+    /**
+     * Deletes a group of entities.
+     *
+     * @param string $bundle
+     */
+    public function batchDeleteAction(Request $request, $bundle): Response
+    {
+        $session    = $request->getSession();
+        $page       = $session->get('mautic.category.page', 1);
+        $viewParams = [
+            'page'   => $page,
+            'bundle' => $bundle,
+        ];
+        $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
+        $flashes   = [];
+        $postActionVars = [
+            'returnUrl'       => $returnUrl,
+            'viewParameters'  => $viewParams,
+            'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
+            'passthroughVars' => [
+                'activeLink'    => 'mautic_'.$bundle.'category_index',
+                'mauticContent' => 'category',
+            ],
+        ];
+        if (Request::METHOD_POST === $request->getMethod()) {
+            $model = $this->getModel('category');
+            \assert($model instanceof CategoryModel);
+            $ids       = json_decode($request->query->get('ids', '{}'));
+            $deleteIds = [];
+            $deletedExceptions = [];
+            foreach ($ids as $objectId) {
+                $entity = $model->getEntity($objectId);
+                if (null === $entity) {
+                    $flashes[] = [
+                        'type'    => 'error',
+                        'msg'     => 'mautic.category.error.notfound',
+                        'msgVars' => ['%id%' => $objectId],
+                    ];
+                } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':delete')) {
+                    $flashes[] = $this->accessDenied(true);
+                } elseif ($model->isLocked($entity)) {
+                    $flashes[] = $this->isLocked($postActionVars, $entity, 'category', true);
+                } else {
+                    try {
+                        $model->deleteEntity($entity);
+                        $deleteIds[] = $objectId;
+                    } catch (RecordCanNotBeDeletedException $exception) {
+                        $deletedExceptions[] = $exception;
+                    }
+                }
+            }
+            if (!empty($deleteIds)) {
+                $flashes[] = [
+                    'type'    => 'notice',
+                    'msg'     => 'mautic.category.notice.batch_deleted',
+                    'msgVars' => [
+                        '%count%' => count($deleteIds),
+                    ],
+                ];
+            }
+            foreach ($deletedExceptions as $deletedException) {
+                $flashes[] = [
+                    'type' => 'notice',
+                    'msg'  => $deletedException->getMessage(),
+                ];
+            }
+        } // else don't do anything
+        return $this->postActionRedirect(
+            array_merge($postActionVars, [
+                'flashes' => $flashes,
+            ])
+        );
+    }
+    private function getInFormValue(Request $request, string $method): int
+    {
+        $inForm = $request->get('inForm', 0);
+        if (Request::METHOD_POST == $method) {
+            $category_form = $request->request->all()['category_form'] ?? [];
+            $inForm        = $category_form['inForm'] ?? 0;
+        }
+        return (int) $inForm;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Entity/Category.php
@@ -0,0 +1,237 @@
+<?php
+namespace Mautic\CategoryBundle\Entity;
+use Doctrine\ORM\Mapping as ORM;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\FormEntity;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Symfony\Component\Serializer\Annotation\Groups;
+use Symfony\Component\Validator\Constraints\NotBlank;
+use Symfony\Component\Validator\Mapping\ClassMetadata;
+/**
+ * @ApiResource(
+ *   collectionOperations={
+ *     "get",
+ *     "post"={"security"="'category:categories:create'"}
+ *   },
+ *   itemOperations={
+ *     "get"={"security"="'category:categories:view'"},
+ *     "put"={"security"="'category:categories:edit'"},
+ *     "patch"={"security"="'category:categories:edit'"},
+ *     "delete"={"security"="'category:categories:delete'"},
+ *   },
+ *   attributes={
+ *     "normalization_context"={
+ *       "groups"={
+ *         "category:read"
+ *        },
+ *       "swagger_definition_name"="Read"
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "category:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Category extends FormEntity implements UuidInterface
+{
+    use UuidTrait;
+    /**
+     * @var int
+     */
+    private $id;
+    /**
+     * @var string
+     */
+    private $title;
+    /**
+     * @var string|null
+     */
+    private $description;
+    /**
+     * @var string
+     */
+    private $alias;
+    /**
+     * @var string|null
+     */
+    private $color;
+    /**
+     * @var string
+     */
+    private $bundle;
+    public static function loadMetadata(ORM\ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable('categories')
+            ->setCustomRepositoryClass(CategoryRepository::class)
+            ->addIndex(['alias'], 'category_alias_search');
+        $builder->addIdColumns('title');
+        $builder->addField('alias', 'string');
+        $builder->createField('color', 'string')
+            ->nullable()
+            ->length(7)
+            ->build();
+        $builder->createField('bundle', 'string')
+            ->length(50)
+            ->build();
+        static::addUuidField($builder);
+    }
+    public static function loadValidatorMetadata(ClassMetadata $metadata): void
+    {
+        $metadata->addPropertyConstraint(
+            'title',
+            new NotBlank(
+                [
+                    'message' => 'mautic.core.title.required',
+                ]
+            )
+        );
+        $metadata->addPropertyConstraint(
+            'bundle',
+            new NotBlank(
+                [
+                    'message' => 'mautic.core.value.required',
+                ]
+            )
+        );
+    }
+    /**
+     * Prepares the metadata for API usage.
+     */
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('category')
+            ->addListProperties(
+                [
+                    'id',
+                    'title',
+                    'alias',
+                    'description',
+                    'color',
+                    'bundle',
+                ]
+            )
+            ->build();
+    }
+    public function __clone()
+    {
+        $this->id = null;
+        parent::__clone();
+    }
+    /**
+     * Get id.
+     *
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * Set title.
+     *
+     * @param string $title
+     *
+     * @return Category
+     */
+    public function setTitle($title)
+    {
+        $this->isChanged('title', $title);
+        $this->title = $title;
+        return $this;
+    }
+    /**
+     * Get title.
+     *
+     * @return string
+     */
+    public function getTitle()
+    {
+        return $this->title;
+    }
+    /**
+     * Set alias.
+     *
+     * @param string $alias
+     *
+     * @return Category
+     */
+    public function setAlias($alias)
+    {
+        $this->isChanged('alias', $alias);
+        $this->alias = $alias;
+        return $this;
+    }
+    /**
+     * Get alias.
+     *
+     * @return string
+     */
+    public function getAlias()
+    {
+        return $this->alias;
+    }
+    /**
+     * Set description.
+     *
+     * @param string $description
+     *
+     * @return Category
+     */
+    public function setDescription($description)
+    {
+        $this->isChanged('description', $description);
+        $this->description = $description;
+        return $this;
+    }
+    /**
+     * Get description.
+     *
+     * @return string
+     */
+    public function getDescription()
+    {
+        return $this->description;
+    }
+    /**
+     * @param string $color
+     */
+    public function setColor($color): void
+    {
+        $this->isChanged('color', $color);
+        $this->color = $color;
+    }
+    /**
+     * Get color.
+     *
+     * @return string
+     */
+    public function getColor()
+    {
+        return $this->color;
+    }
+    /**
+     * Set bundle.
+     *
+     * @param string $bundle
+     */
+    public function setBundle($bundle): void
+    {
+        $this->isChanged('bundle', $bundle);
+        $this->bundle = $bundle;
+    }
+    /**
+     * Get bundle.
+     *
+     * @return string
+     */
+    public function getBundle()
+    {
+        return $this->bundle;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Event/CategoryTypeEntityEvent.php
@@ -0,0 +1,35 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\CategoryBundle\Event;
+use Mautic\CoreBundle\Event\CommonEvent;
+final class CategoryTypeEntityEvent extends CommonEvent
+{
+    /**
+     * @var array<mixed>
+     */
+    protected array $types = [];
+    /**
+     * Returns the array of Category Type Entity.
+     *
+     * @return array<class-string[]>
+     */
+    public function getCategoryTypeEntity(string $type): array
+    {
+        if ('global' === $type) {
+            return $this->types;
+        }
+        return [$this->types[$type]];
+    }
+    /**
+     * @param array<mixed>|null $data
+     */
+    public function addCategoryTypeEntity(string $type, ?array $data): void
+    {
+        if (!empty($data)) {
+            if (!isset($data['label'])) {
+                $data['label'] = 'mautic.'.$type.'.'.$type;
+            }
+            $this->types[$type] = $data;
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/EventListener/ButtonSubscriber.php
@@ -0,0 +1,41 @@
+<?php
+namespace Mautic\CategoryBundle\EventListener;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\Event\CustomButtonEvent;
+use Mautic\CoreBundle\Twig\Helper\ButtonHelper;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ButtonSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private RouterInterface $router,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::VIEW_INJECT_CUSTOM_BUTTONS => ['injectContactBulkButtons', 0],
+        ];
+    }
+    public function injectContactBulkButtons(CustomButtonEvent $event): void
+    {
+        if (str_starts_with($event->getRoute(), 'mautic_contact_')) {
+            $event->addButton(
+                [
+                    'attr' => [
+                        'class'       => 'btn btn-ghost btn-sm btn-nospin',
+                        'data-toggle' => 'ajaxmodal',
+                        'data-target' => '#MauticSharedModal',
+                        'href'        => $this->router->generate('mautic_category_batch_contact_view'),
+                        'data-header' => $this->translator->trans('mautic.lead.batch.categories'),
+                    ],
+                    'btnText'   => $this->translator->trans('mautic.lead.batch.categories'),
+                    'iconClass' => 'ri-folder-line',
+                ],
+                ButtonHelper::LOCATION_BULK_ACTIONS
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/EventListener/CategorySubscriber.php
@@ -0,0 +1,106 @@
+<?php
+namespace Mautic\CategoryBundle\EventListener;
+use Mautic\CategoryBundle\CategoryEvents;
+use Mautic\CategoryBundle\Event\CategoryEvent;
+use Mautic\CategoryBundle\Event\CategoryTypeEntityEvent;
+use Mautic\CategoryBundle\Event\CategoryTypesEvent;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CoreBundle\Exception\RecordCanNotBeDeletedException;
+use Mautic\CoreBundle\Helper\BundleHelper;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class CategorySubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private BundleHelper $bundleHelper,
+        private IpLookupHelper $ipLookupHelper,
+        private AuditLogModel $auditLogModel,
+        private CategoryModel $categoryModel,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD => ['onCategoryBundleListBuild', 0],
+            CategoryEvents::CATEGORY_POST_SAVE            => ['onCategoryPostSave', 0],
+            CategoryEvents::CATEGORY_POST_DELETE          => ['onCategoryDelete', 0],
+            CategoryEvents::CATEGORY_PRE_DELETE           => ['onCategoryPreDelete', 0],
+            CategoryTypeEntityEvent::class                => ['onCategoryTypeEntity', 0],
+        ];
+    }
+    /**
+     * Add bundle to the category.
+     */
+    public function onCategoryBundleListBuild(CategoryTypesEvent $event): void
+    {
+        $bundles = $this->bundleHelper->getMauticBundles(true);
+        foreach ($bundles as $bundle) {
+            if (!empty($bundle['config']['categories'])) {
+                foreach ($bundle['config']['categories'] as $type => $data) {
+                    $event->addCategoryType($type, $data['label'] ?? null);
+                }
+            }
+        }
+    }
+    /**
+     * Add an entry to the audit log.
+     */
+    public function onCategoryPostSave(CategoryEvent $event): void
+    {
+        $category = $event->getCategory();
+        if ($details = $event->getChanges()) {
+            $log = [
+                'bundle'    => 'category',
+                'object'    => 'category',
+                'objectId'  => $category->getId(),
+                'action'    => ($event->isNew()) ? 'create' : 'update',
+                'details'   => $details,
+                'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+            ];
+            $this->auditLogModel->writeToLog($log);
+        }
+    }
+    /**
+     * Add a delete entry to the audit log.
+     */
+    public function onCategoryDelete(CategoryEvent $event): void
+    {
+        $category = $event->getCategory();
+        $log      = [
+            'bundle'    => 'category',
+            'object'    => 'category',
+            'objectId'  => $category->deletedId,
+            'action'    => 'delete',
+            'details'   => ['name' => $category->getTitle()],
+            'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+        ];
+        $this->auditLogModel->writeToLog($log);
+    }
+    public function onCategoryPreDelete(CategoryEvent $event): void
+    {
+        if ($usage = $this->categoryModel->getUsage($event->getCategory())) {
+            $message = $this->translator->trans(
+                'mautic.category.is_in_use.delete',
+                [
+                    '%entities%'     => implode(', ', array_map(fn ($entity): string => $this->translator->trans($entity['label']).' Id: '.$entity['id'], $usage)),
+                    '%categoryName%' => $event->getCategory()->getTitle(),
+                ],
+                'validators');
+            throw new RecordCanNotBeDeletedException($message);
+        }
+    }
+    public function onCategoryTypeEntity(CategoryTypeEntityEvent $event): void
+    {
+        $bundles = $this->bundleHelper->getMauticBundles(true);
+        foreach ($bundles as $bundle) {
+            if (!empty($bundle['config']['categories'])) {
+                foreach ($bundle['config']['categories'] as $type => $data) {
+                    $event->addCategoryTypeEntity($type, $data);
+                }
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Form/Type/CategoryBundlesType.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\CategoryBundle\Form\Type;
+use Mautic\CategoryBundle\CategoryEvents;
+use Mautic\CategoryBundle\Event\CategoryTypesEvent;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\OptionsResolver\Options;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CategoryBundlesType extends AbstractType
+{
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+    ) {
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'choices' => function (Options $options): array {
+                if ($this->dispatcher->hasListeners(CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD)) {
+                    $event = $this->dispatcher->dispatch(new CategoryTypesEvent(), CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD);
+                    $types = $event->getCategoryTypes();
+                } else {
+                    $types = [];
+                }
+                return array_flip($types);
+            },
+            'expanded'          => false,
+            'multiple'          => false,
+            'required'          => false,
+        ]);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'category_bundles_form';
+    }
+    public function getParent(): ?string
+    {
+        return ChoiceType::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Form/Type/CategoryListType.php
@@ -0,0 +1,74 @@
+<?php
+namespace Mautic\CategoryBundle\Form\Type;
+use Doctrine\ORM\EntityManager;
+use Mautic\CategoryBundle\Model\CategoryModel;
+use Mautic\CoreBundle\Form\DataTransformer\IdToEntityModelTransformer;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\Options;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * @extends AbstractType<mixed>
+ */
+class CategoryListType extends AbstractType
+{
+    public function __construct(
+        private EntityManager $em,
+        private TranslatorInterface $translator,
+        private CategoryModel $model,
+        private RouterInterface $router,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        if (true === $options['return_entity']) {
+            $transformer = new IdToEntityModelTransformer($this->em, \Mautic\CategoryBundle\Entity\Category::class, 'id');
+            $builder->addModelTransformer($transformer);
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'choices' => function (Options $options): array {
+                $createNew  = $this->translator->trans('mautic.category.createnew');
+                $categories = $this->model->getLookupResults($options['bundle'], '', 0);
+                $choices    = [];
+                foreach ($categories as $l) {
+                    $choices[$l['title']] = $l['id'];
+                }
+                $choices[$createNew] = 'new';
+                return $choices;
+            },
+            'label'             => 'mautic.core.category',
+            'label_attr'        => ['class' => 'control-label'],
+            'multiple'          => false,
+            'placeholder'       => 'mautic.core.form.uncategorized',
+            'attr'              => function (Options $options): array {
+                $modalHeader = $this->translator->trans('mautic.category.header.new');
+                $newUrl      = $this->router->generate('mautic_category_action', [
+                    'objectAction' => 'new',
+                    'bundle'       => $options['bundle'],
+                    'inForm'       => 1,
+                ]);
+                return [
+                    'class'    => 'form-control category-select',
+                    'onchange' => "Mautic.loadAjaxModalBySelectValue(this, 'new', '{$newUrl}', '{$modalHeader}');",
+                ];
+            },
+            'required'      => false,
+            'return_entity' => true,
+        ]);
+        $resolver->setRequired(['bundle']);
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'category';
+    }
+    public function getParent(): ?string
+    {
+        return ChoiceType::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Form/Type/CategoryType.php
@@ -0,0 +1,134 @@
+<?php
+namespace Mautic\CategoryBundle\Form\Type;
+use Mautic\CategoryBundle\Entity\Category;
+use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
+use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\HiddenType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\OptionsResolver\Options;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<Category>
+ */
+class CategoryType extends AbstractType
+{
+    public function __construct(
+        private RequestStack $requestStack,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->addEventSubscriber(new CleanFormSubscriber([]));
+        $builder->addEventSubscriber(new FormExitSubscriber('category.category', $options));
+        if (!$options['data']->getId()) {
+            if (true == $options['show_bundle_select']) {
+                $selected = $this->requestStack->getSession()->get('mautic.category.type', 'category');
+                $builder->add(
+                    'bundle',
+                    CategoryBundlesType::class,
+                    [
+                        'label'      => 'mautic.core.type',
+                        'label_attr' => ['class' => 'control-label'],
+                        'attr'       => ['class' => 'form-control'],
+                        'required'   => true,
+                        'data'       => $selected,
+                    ]
+                );
+            } else {
+                $builder->add(
+                    'bundle',
+                    HiddenType::class,
+                    [
+                        'data' => $options['bundle'],
+                    ]
+                );
+            }
+        }
+        $builder->add(
+            'title',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.title',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+            ]
+        );
+        $builder->add(
+            'description',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.description',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => ['class' => 'form-control'],
+                'required'   => false,
+            ]
+        );
+        $builder->add(
+            'alias',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.alias',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'   => 'form-control',
+                    'tooltip' => 'mautic.category.form.alias.help',
+                ],
+                'required' => false,
+            ]
+        );
+        $builder->add(
+            'color',
+            TextType::class,
+            [
+                'label'      => 'mautic.core.color',
+                'label_attr' => ['class' => 'control-label'],
+                'attr'       => [
+                    'class'       => 'form-control',
+                    'data-toggle' => 'color',
+                ],
+                'required' => false,
+            ]
+        );
+        $builder->add('isPublished', YesNoButtonGroupType::class, [
+            'label' => 'mautic.core.form.available',
+        ]);
+        $builder->add(
+            'inForm',
+            HiddenType::class,
+            [
+                'mapped' => false,
+            ]
+        );
+        $builder->add('buttons', FormButtonsType::class,
+            [
+                'apply_text' => false,
+            ]);
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(
+            [
+                'data_class'         => Category::class,
+                'show_bundle_select' => false,
+                'bundle'             => function (Options $options) {
+                    if (!$bundle = $options['data']->getBundle()) {
+                        $bundle = 'category';
+                    }
+                    return $bundle;
+                },
+            ]
+        );
+    }
+    public function getBlockPrefix(): string
+    {
+        return 'category_form';
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Model/CategoryModel.php
@@ -0,0 +1,188 @@
+<?php
+namespace Mautic\CategoryBundle\Model;
+use Doctrine\ORM\EntityManager;
+use Mautic\CategoryBundle\CategoryEvents;
+use Mautic\CategoryBundle\Entity\Category;
+use Mautic\CategoryBundle\Entity\CategoryRepository;
+use Mautic\CategoryBundle\Event\CategoryEvent;
+use Mautic\CategoryBundle\Event\CategoryTypeEntityEvent;
+use Mautic\CategoryBundle\Form\Type\CategoryType;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @extends FormModel<Category>
+ */
+class CategoryModel extends FormModel
+{
+    /**
+     * @var array<string,mixed[]>
+     */
+    private array $categoriesByBundleCache = [];
+    public function __construct(
+        protected RequestStack $requestStack,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    public function getRepository(): CategoryRepository
+    {
+        $repository = $this->em->getRepository(Category::class);
+        \assert($repository instanceof CategoryRepository);
+        return $repository;
+    }
+    public function getNameGetter(): string
+    {
+        return 'getTitle';
+    }
+    public function getPermissionBase(string $bundle = null): string
+    {
+        if (null === $bundle) {
+            $bundle = $this->requestStack->getCurrentRequest()->get('bundle');
+        }
+        if ('global' === $bundle || empty($bundle)) {
+            $bundle = 'category';
+        }
+        return $bundle.':categories';
+    }
+    public function saveEntity($entity, $unlock = true): void
+    {
+        $alias = $entity->getAlias();
+        if (empty($alias)) {
+            $alias = $entity->getTitle();
+        }
+        $alias = $this->cleanAlias($alias, '', 0, '-');
+        $repo      = $this->getRepository();
+        $testAlias = $alias;
+        $bundle    = $entity->getBundle();
+        $count     = $repo->checkUniqueCategoryAlias($bundle, $testAlias, $entity);
+        $aliasTag  = $count;
+        while ($count) {
+            $testAlias = $alias.$aliasTag;
+            $count     = $repo->checkUniqueCategoryAlias($bundle, $testAlias, $entity);
+            ++$aliasTag;
+        }
+        if ($testAlias != $alias) {
+            $alias = $testAlias;
+        }
+        $entity->setAlias($alias);
+        parent::saveEntity($entity, $unlock);
+    }
+    /**
+     * @param string|null $action
+     * @param array       $options
+     */
+    public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
+    {
+        if (!$entity instanceof Category) {
+            throw new MethodNotAllowedHttpException(['Category']);
+        }
+        if (!empty($action)) {
+            $options['action'] = $action;
+        }
+        return $formFactory->create(CategoryType::class, $entity, $options);
+    }
+    /**
+     * Get a specific entity or generate a new one if id is empty.
+     */
+    public function getEntity($id = null): ?Category
+    {
+        if (null === $id) {
+            return new Category();
+        }
+        return parent::getEntity($id);
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
+    {
+        if (!$entity instanceof Category) {
+            throw new MethodNotAllowedHttpException(['Category']);
+        }
+        switch ($action) {
+            case 'pre_save':
+                $name = CategoryEvents::CATEGORY_PRE_SAVE;
+                break;
+            case 'post_save':
+                $name = CategoryEvents::CATEGORY_POST_SAVE;
+                break;
+            case 'pre_delete':
+                $name = CategoryEvents::CATEGORY_PRE_DELETE;
+                break;
+            case 'post_delete':
+                $name = CategoryEvents::CATEGORY_POST_DELETE;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new CategoryEvent($entity, $isNew);
+                $event->setEntityManager($this->em);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        } else {
+            return null;
+        }
+    }
+    /**
+     * Get list of entities for autopopulate fields.
+     *
+     * @param string $bundle
+     * @param string $filter
+     * @param int    $limit
+     *
+     * @return mixed[]
+     */
+    public function getLookupResults($bundle, $filter = '', $limit = 10): array
+    {
+        $key = $bundle.$filter.$limit;
+        if (!empty($this->categoriesByBundleCache[$key])) {
+            return $this->categoriesByBundleCache[$key];
+        }
+        return $this->categoriesByBundleCache[$key] = $this->getRepository()->getCategoryList($bundle, $filter, $limit, 0);
+    }
+    /**
+     * @return array<mixed>
+     */
+    public function getUsage(Category $category): array
+    {
+        $bundle = $category->getBundle();
+        $types = [];
+        if ($this->dispatcher->hasListeners(CategoryTypeEntityEvent::class)) {
+            $event = $this->dispatcher->dispatch(new CategoryTypeEntityEvent());
+            $types = $event->getCategoryTypeEntity($bundle);
+        }
+        $data = [];
+        foreach ($types as $type) {
+            $class     = $type['class'];
+            $resources = $this->em->getRepository($class)->findBy(['category' => $category->getId()]);
+            if (!$resources) {
+                continue;
+            }
+            $data = array_merge(array_map(fn ($resource): array => [
+                'label' => $type['label'],
+                'id'    => $resource->getId(),
+            ], $resources), $data);
+        }
+        return $data;
+    }
+}

--- a//dev/null
+++ b/app/bundles/CategoryBundle/Model/ContactActionModel.php
@@ -0,0 +1,32 @@
+<?php
+namespace Mautic\CategoryBundle\Model;
+use Mautic\LeadBundle\Model\LeadModel;
+class ContactActionModel
+{
+    public function __construct(
+        private LeadModel $contactModel,
+    ) {
+    }
+    public function addContactsToCategories(array $contactIds, array $categoryIds): void
+    {
+        $contacts = $this->contactModel->getLeadsByIds($contactIds);
+        foreach ($contacts as $contact) {
+            if (!$this->contactModel->canEditContact($contact)) {
+                continue;
+            }
+            $this->contactModel->addToCategory($contact, $categoryIds);
+        }
+    }
+    public function removeContactsFromCategories(array $contactIds, array $categoryIds): void
+    {
+        $contacts = $this->contactModel->getLeadsByIds($contactIds);
+        foreach ($contacts as $contact) {
+            if (!$this->contactModel->canEditContact($contact)) {
+                continue;
+            }
+            $contactCategoryRelations = $this->contactModel->getLeadCategories($contact);
+            $relationsToDelete        = array_intersect($contactCategoryRelations, $categoryIds);
+            $this->contactModel->removeFromCategories($relationsToDelete);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Command/ProcessMarketingMessagesQueueCommand.php
@@ -0,0 +1,65 @@
+<?php
+namespace Mautic\ChannelBundle\Command;
+use Mautic\ChannelBundle\Model\MessageQueueModel;
+use Mautic\CoreBundle\Command\ModeratedCommand;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ProcessMarketingMessagesQueueCommand extends ModeratedCommand
+{
+    public function __construct(
+        private TranslatorInterface $translator,
+        private MessageQueueModel $messageQueueModel,
+        PathsHelper $pathsHelper,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($pathsHelper, $coreParametersHelper);
+    }
+    protected function configure()
+    {
+        $this
+            ->setName('mautic:messages:send')
+            ->setAliases(
+                [
+                    'mautic:campaigns:messagequeue',
+                    'mautic:campaigns:messages',
+                ]
+            )
+            ->addOption(
+                '--channel',
+                '-c',
+                InputOption::VALUE_OPTIONAL,
+                'Channel to use for sending messages i.e. email, sms.',
+                null
+            )
+            ->addOption('--channel-id', '-i', InputOption::VALUE_REQUIRED, 'The ID of the message i.e. email ID, sms ID.')
+            ->addOption('--message-id', '-m', InputOption::VALUE_REQUIRED, 'ID of a specific queued message');
+        parent::configure();
+    }
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        $processed  = 0;
+        $channel    = $input->getOption('channel');
+        $channelId  = $input->getOption('channel-id');
+        $messageId  = $input->getOption('message-id');
+        $key        = $channel.$channelId.$messageId;
+        if (!$this->checkRunStatus($input, $output, $key)) {
+            return \Symfony\Component\Console\Command\Command::SUCCESS;
+        }
+        $output->writeln('<info>'.$this->translator->trans('mautic.campaign.command.process.messages').'</info>');
+        if ($messageId) {
+            if ($message = $this->messageQueueModel->getEntity($messageId)) {
+                $processed = intval($this->messageQueueModel->processMessageQueue($message));
+            }
+        } else {
+            $processed = intval($this->messageQueueModel->sendMessages($channel, $channelId));
+        }
+        $output->writeln('<comment>'.$this->translator->trans('mautic.campaign.command.messages.sent', ['%events%' => $processed]).'</comment>'."\n");
+        $this->completeRun();
+        return \Symfony\Component\Console\Command\Command::SUCCESS;
+    }
+    protected static $defaultDescription = 'Process sending of messages queue.';
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Command/SendChannelBroadcastCommand.php
@@ -0,0 +1,151 @@
+<?php
+namespace Mautic\ChannelBundle\Command;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Event\ChannelBroadcastEvent;
+use Mautic\CoreBundle\Command\ModeratedCommand;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Symfony\Component\Console\Helper\Table;
+use Symfony\Component\Console\Input\InputInterface;
+use Symfony\Component\Console\Input\InputOption;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+/**
+ * CLI Command to send a scheduled broadcast.
+ */
+class SendChannelBroadcastCommand extends ModeratedCommand
+{
+    public function __construct(
+        private TranslatorInterface $translator,
+        private EventDispatcherInterface $dispatcher,
+        PathsHelper $pathsHelper,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($pathsHelper, $coreParametersHelper);
+    }
+    protected function configure()
+    {
+        $this->setName('mautic:broadcasts:send')
+            ->setHelp(
+                <<<'EOT'
+                The <info>%command.name%</info> command is send a channel broadcast to pending contacts.
+<info>php %command.full_name% --channel=email --id=3</info>
+EOT
+            )
+            ->setDefinition(
+                [
+                    new InputOption(
+                        'channel', 'c', InputOption::VALUE_OPTIONAL,
+                        'A specific channel to process broadcasts for pending contacts.'
+                    ),
+                    new InputOption(
+                        'id', 'i', InputOption::VALUE_OPTIONAL,
+                        'The ID for a specifc channel to process broadcasts for pending contacts.'
+                    ),
+                    new InputOption(
+                        'min-contact-id', null, InputOption::VALUE_OPTIONAL,
+                        'Min contact ID to filter recipients.'
+                    ),
+                    new InputOption(
+                        'max-contact-id', null, InputOption::VALUE_OPTIONAL,
+                        'Max contact ID to filter recipients.'
+                    ),
+                    new InputOption(
+                        'limit', 'l', InputOption::VALUE_OPTIONAL,
+                        'Limit how many contacts to load from database to process.'
+                    ),
+                    new InputOption(
+                        'batch', 'b', InputOption::VALUE_OPTIONAL,
+                        'Limit how many messages to send at once.'
+                    ),
+                ]
+            )->addOption(
+                '--thread-id',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The number of this current process if running multiple in parallel.'
+            )
+            ->addOption(
+                '--max-threads',
+                null,
+                InputOption::VALUE_OPTIONAL,
+                'The maximum number of processes you intend to run in parallel.'
+            );
+        parent::configure();
+    }
+    protected function execute(InputInterface $input, OutputInterface $output): int
+    {
+        $channel       = $input->getOption('channel');
+        $channelId     = $input->getOption('id');
+        $limit         = $input->getOption('limit');
+        $batch         = $input->getOption('batch');
+        $minContactId  = $input->getOption('min-contact-id');
+        $maxContactId  = $input->getOption('max-contact-id');
+        $threadId      = $input->getOption('thread-id');
+        $maxThreads    = $input->getOption('max-threads');
+        $key           = sprintf('%s-%s-%s-%s', $channel, $channelId, $threadId, $maxThreads);
+        if (is_numeric($limit)) {
+            $limit = (int) $limit;
+        }
+        if (is_numeric($batch)) {
+            $batch = (int) $batch;
+        }
+        if (is_numeric($minContactId)) {
+            $minContactId = (int) $minContactId;
+        }
+        if (is_numeric($maxContactId)) {
+            $maxContactId = (int) $maxContactId;
+        }
+        if (is_numeric($threadId)) {
+            $threadId = (int) $threadId;
+        }
+        if (is_numeric($maxThreads)) {
+            $maxThreads = (int) $maxThreads;
+        }
+        if ($threadId && $maxThreads) {
+            if ((int) $threadId > (int) $maxThreads) {
+                $output->writeln('--thread-id cannot be larger than --max-thread');
+                return \Symfony\Component\Console\Command\Command::FAILURE;
+            }
+        }
+        if (!$this->checkRunStatus($input, $output, $key)) {
+            return \Symfony\Component\Console\Command\Command::SUCCESS;
+        }
+        $event = new ChannelBroadcastEvent($channel, $channelId, $output);
+        if ($limit) {
+            $event->setLimit((int) $limit);
+        }
+        if ($batch) {
+            $event->setBatch((int) $batch);
+        }
+        if ($minContactId) {
+            $event->setMinContactIdFilter((int) $minContactId);
+        }
+        if ($maxContactId) {
+            $event->setMaxContactIdFilter((int) $maxContactId);
+        }
+        if ($threadId) {
+            $event->setThreadId((int) $threadId);
+        }
+        if ($maxThreads) {
+            $event->setMaxThreads((int) $maxThreads);
+        }
+        $this->dispatcher->dispatch($event, ChannelEvents::CHANNEL_BROADCAST);
+        $results = $event->getResults();
+        $rows = [];
+        foreach ($results as $channel => $counts) {
+            $rows[] = [$channel, $counts['success'], $counts['failed']];
+        }
+        $output->writeln('');
+        $output->writeln('');
+        $table = new Table($output);
+        $table
+            ->setHeaders([$this->translator->trans('mautic.core.channel'), $this->translator->trans('mautic.core.channel.broadcast_success_count'), $this->translator->trans('mautic.core.channel.broadcast_failed_count')])
+            ->setRows($rows);
+        $table->render();
+        $this->completeRun();
+        return \Symfony\Component\Console\Command\Command::SUCCESS;
+    }
+    protected static $defaultDescription = 'Process contacts pending to receive a channel broadcast.';
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Config/config.php
@@ -0,0 +1,72 @@
+<?php
+return [
+    'routes' => [
+        'main' => [
+            'mautic_message_index' => [
+                'path'       => '/messages/{page}',
+                'controller' => 'Mautic\ChannelBundle\Controller\MessageController::indexAction',
+            ],
+            'mautic_message_contacts' => [
+                'path'       => '/messages/contacts/{objectId}/{channel}/{page}',
+                'controller' => 'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
+            ],
+            'mautic_message_action' => [
+                'path'       => '/messages/{objectAction}/{objectId}',
+                'controller' => 'Mautic\ChannelBundle\Controller\MessageController::executeAction',
+            ],
+            'mautic_channel_batch_contact_set' => [
+                'path'       => '/channels/batch/contact/set',
+                'controller' => 'Mautic\ChannelBundle\Controller\BatchContactController::setAction',
+            ],
+            'mautic_channel_batch_contact_view' => [
+                'path'       => '/channels/batch/contact/view',
+                'controller' => 'Mautic\ChannelBundle\Controller\BatchContactController::indexAction',
+            ],
+        ],
+        'api' => [
+            'mautic_api_messagetandard' => [
+                'standard_entity' => true,
+                'name'            => 'messages',
+                'path'            => '/messages',
+                'controller'      => Mautic\ChannelBundle\Controller\Api\MessageApiController::class,
+            ],
+        ],
+        'public' => [
+        ],
+    ],
+    'menu' => [
+        'main' => [
+            'mautic.channel.messages' => [
+                'route'    => 'mautic_message_index',
+                'access'   => ['channel:messages:viewown', 'channel:messages:viewother'],
+                'parent'   => 'mautic.core.channels',
+                'priority' => 110,
+            ],
+        ],
+        'admin' => [
+        ],
+        'profile' => [
+        ],
+        'extra' => [
+        ],
+    ],
+    'categories' => [
+        'messages' => [
+            'class' => Mautic\ChannelBundle\Entity\Message::class,
+        ],
+    ],
+    'services' => [
+        'helpers' => [
+            'mautic.channel.helper.channel_list' => [
+                'class'     => Mautic\ChannelBundle\Helper\ChannelListHelper::class,
+                'arguments' => [
+                    'event_dispatcher',
+                    'translator',
+                ],
+                'alias' => 'channel',
+            ],
+        ],
+    ],
+    'parameters' => [
+    ],
+];

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Controller/Api/MessageApiController.php
@@ -0,0 +1,82 @@
+<?php
+namespace Mautic\ChannelBundle\Controller\Api;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ApiBundle\Controller\CommonApiController;
+use Mautic\ApiBundle\Helper\EntityResultHelper;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Entity\Message;
+use Mautic\ChannelBundle\Event\ChannelEvent;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\AppVersion;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\Routing\RouterInterface;
+/**
+ * @extends CommonApiController<Message>
+ */
+class MessageApiController extends CommonApiController
+{
+    /**
+     * @var MessageModel|null
+     */
+    protected $model;
+    public function __construct(
+        CorePermissions $security,
+        Translator $translator,
+        EntityResultHelper $entityResultHelper,
+        RouterInterface $router,
+        FormFactoryInterface $formFactory,
+        AppVersion $appVersion,
+        private RequestStack $requestStack,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        EventDispatcherInterface $dispatcher,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        $messageModel = $modelFactory->getModel('channel.message');
+        \assert($messageModel instanceof MessageModel);
+        $this->model            = $messageModel;
+        $this->entityClass      = Message::class;
+        $this->entityNameOne    = 'message';
+        $this->entityNameMulti  = 'messages';
+        $this->serializerGroups = ['messageDetails', 'messageChannelList', 'categoryList', 'publishDetails'];
+        parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
+    }
+    protected function prepareParametersFromRequest(FormInterface $form, array &$params, object $entity = null, array $masks = [], array $fields = []): void
+    {
+        parent::prepareParametersFromRequest($form, $params, $entity, $masks);
+        if ('PATCH' === $this->requestStack->getCurrentRequest()->getMethod() && !isset($params['channels'])) {
+            return;
+        } elseif (!isset($params['channels'])) {
+            $params['channels'] = [];
+        }
+        $channels = $this->model->getChannels();
+        foreach ($channels as $channelType => $channel) {
+            if (!isset($params['channels'][$channelType])) {
+                $params['channels'][$channelType] = ['isEnabled' => 0];
+            } else {
+                $params['channels'][$channelType]['isEnabled'] = (int) $params['channels'][$channelType]['isEnabled'];
+            }
+            $params['channels'][$channelType]['channel'] = $channelType;
+        }
+    }
+    /**
+     * Load and set channel names to the response.
+     */
+    protected function preSerializeEntity(object $entity, string $action = 'view'): void
+    {
+        $event = $this->dispatcher->dispatch(new ChannelEvent(), ChannelEvents::ADD_CHANNEL);
+        foreach ($entity->getChannels() as $channel) {
+            $repository = $event->getRepositoryName($channel->getChannel());
+            $nameColumn = $event->getNameColumn($channel->getChannel());
+            $name       = $this->model->getChannelName($channel->getChannelId(), $repository, $nameColumn);
+            $channel->setChannelName($name);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Controller/BatchContactController.php
@@ -0,0 +1,83 @@
+<?php
+namespace Mautic\ChannelBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ChannelBundle\Model\ChannelActionModel;
+use Mautic\ChannelBundle\Model\FrequencyActionModel;
+use Mautic\CoreBundle\Controller\AbstractFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Form\Type\ContactChannelsType;
+use Mautic\LeadBundle\Model\LeadModel;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+class BatchContactController extends AbstractFormController
+{
+    public function __construct(
+        private ChannelActionModel $channelActionModel,
+        private FrequencyActionModel $frequencyActionModel,
+        private LeadModel $contactModel,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * Execute the batch action.
+     */
+    public function setAction(Request $request): JsonResponse
+    {
+        $params = $request->get('contact_channels', []);
+        $ids    = empty($params['ids']) ? [] : json_decode($params['ids']);
+        if ($ids && is_array($ids)) {
+            $subscribedChannels = $params['subscribed_channels'] ?? [];
+            $preferredChannel   = $params['preferred_channel'] ?? null;
+            $this->channelActionModel->update($ids, $subscribedChannels);
+            $this->frequencyActionModel->update($ids, $params, $preferredChannel);
+            $this->addFlashMessage('mautic.lead.batch_leads_affected', [
+                '%count%'     => count($ids),
+            ]);
+        } else {
+            $this->addFlashMessage('mautic.core.error.ids.missing');
+        }
+        return new JsonResponse([
+            'closeModal' => true,
+            'flashes'    => $this->getFlashContent(),
+        ]);
+    }
+    /**
+     * View for batch action.
+     */
+    public function indexAction(): \Symfony\Component\HttpFoundation\Response
+    {
+        $route = $this->generateUrl('mautic_channel_batch_contact_set');
+        return $this->delegateView([
+            'viewParameters' => [
+                'form'         => $this->createForm(ContactChannelsType::class, [], [
+                    'action'        => $route,
+                    'channels'      => $this->contactModel->getPreferenceChannels(),
+                    'public_view'   => false,
+                    'save_button'   => true,
+                ])->createView(),
+            ],
+            'contentTemplate' => '@MauticLead/Batch/channel.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_contact_index',
+                'mauticContent' => 'leadBatch',
+                'route'         => $route,
+            ],
+        ]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Controller/MessageController.php
@@ -0,0 +1,273 @@
+<?php
+namespace Mautic\ChannelBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ChannelBundle\Entity\Channel;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Mautic\CoreBundle\Controller\AbstractStandardFormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
+use Mautic\CoreBundle\Helper\Chart\LineChart;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\FormBundle\Helper\FormFieldHelper;
+use Mautic\LeadBundle\Controller\EntityContactsTrait;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\Form;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Component\Form\FormView;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\RequestStack;
+use Symfony\Component\HttpFoundation\Response;
+class MessageController extends AbstractStandardFormController
+{
+    use EntityContactsTrait;
+    public function __construct(
+        FormFactoryInterface $formFactory,
+        FormFieldHelper $fieldHelper,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        private RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * @return \Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function batchDeleteAction(Request $request)
+    {
+        return $this->batchDeleteStandard($request);
+    }
+    /**
+     * @return \Mautic\CoreBundle\Controller\Response|\Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function cloneAction(Request $request, $objectId)
+    {
+        return $this->cloneStandard($request, $objectId);
+    }
+    /**
+     * @param bool $ignorePost
+     *
+     * @return \Mautic\CoreBundle\Controller\Response|\Symfony\Component\HttpFoundation\JsonResponse
+     */
+    public function editAction(Request $request, $objectId, $ignorePost = false)
+    {
+        return $this->editStandard($request, $objectId, $ignorePost);
+    }
+    /**
+     * @param int $page
+     */
+    public function indexAction(Request $request, $page = 1): Response
+    {
+        return $this->indexStandard($request, $page);
+    }
+    public function newAction(Request $request): Response
+    {
+        return $this->newStandard($request);
+    }
+    /**
+     * @return array|\Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function viewAction(Request $request, $objectId)
+    {
+        return $this->viewStandard($request, $objectId, 'message', 'channel');
+    }
+    /**
+     * @return mixed[]
+     */
+    protected function getViewArguments(array $args, $action): array
+    {
+        /** @var MessageModel $model */
+        $model          = $this->getModel($this->getModelName());
+        $viewParameters = [];
+        switch ($action) {
+            case 'index':
+                $viewParameters = [
+                    'headerTitle' => $this->translator->trans('mautic.channel.messages'),
+                    'listHeaders' => [
+                        [
+                            'text'  => 'mautic.core.channels',
+                            'class' => 'visible-md visible-lg',
+                        ],
+                    ],
+                    'listItemTemplate'  => '@MauticChannel/Message/list_item.html.twig',
+                    'enableCloneButton' => true,
+                ];
+                break;
+            case 'view':
+                $message = $args['viewParameters']['item'];
+                $returnUrl = $this->generateUrl(
+                    'mautic_message_action',
+                    [
+                        'objectAction' => 'view',
+                        'objectId'     => $message->getId(),
+                    ]
+                );
+                [$dateFrom, $dateTo]     = $this->getViewDateRange($this->requestStack->getCurrentRequest(), $message->getId(), $returnUrl, 'local', $dateRangeForm);
+                $chart                   = new LineChart(null, $dateFrom, $dateTo);
+                /** @var Channel[] $channels */
+                $channels        = $model->getChannels();
+                $messageChannels = $message->getChannels();
+                $chart->setDataset(
+                    $this->translator->trans('mautic.core.all'),
+                    $model->getLeadStatsPost($message->getId(), $dateFrom, $dateTo)
+                );
+                $messagedLeads = [
+                    'all' => $this->forward(
+                        'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
+                        [
+                            'objectId'   => $message->getId(),
+                            'page'       => $this->requestStack->getCurrentRequest()->getSession()->get('mautic.'.$this->getSessionBase('all').'.contact.page', 1),
+                            'ignoreAjax' => true,
+                            'channel'    => 'all',
+                        ]
+                    )->getContent(),
+                ];
+                foreach ($messageChannels as $channel) {
+                    if ($channel->isEnabled() && isset($channels[$channel->getChannel()])) {
+                        $chart->setDataset(
+                            $channels[$channel->getChannel()]['label'],
+                            $model->getLeadStatsPost($message->getId(), $dateFrom, $dateTo, $channel->getChannel())
+                        );
+                        $messagedLeads[$channel->getChannel()] = $this->forward(
+                            'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
+                            [
+                                'objectId' => $message->getId(),
+                                'page'     => $this->requestStack->getCurrentRequest()->getSession()->get(
+                                    'mautic.'.$this->getSessionBase($channel->getChannel()).'.contact.page',
+                                    1
+                                ),
+                                'ignoreAjax' => true,
+                                'channel'    => $channel->getChannel(),
+                            ]
+                        )->getContent();
+                    }
+                }
+                $viewParameters = [
+                    'channels'        => $channels,
+                    'channelContents' => $model->getMessageChannels($message->getId()),
+                    'dateRangeForm'   => $dateRangeForm->createView(),
+                    'eventCounts'     => $chart->render(),
+                    'messagedLeads'   => $messagedLeads,
+                ];
+                break;
+            case 'new':
+            case 'edit':
+                $viewParameters = [
+                    'channels' => $model->getChannels(),
+                ];
+                break;
+        }
+        $args['viewParameters'] = array_merge($args['viewParameters'], $viewParameters);
+        return $args;
+    }
+    /**
+     * @return \Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
+     */
+    public function deleteAction(Request $request, $objectId)
+    {
+        return $this->deleteStandard($request, $objectId);
+    }
+    protected function getTemplateBase(): string
+    {
+        return '@MauticChannel/Message';
+    }
+    protected function getFormView(FormInterface $form, $view): FormView
+    {
+        return $form->createView();
+    }
+    protected function getJsLoadMethodPrefix(): string
+    {
+        return 'messages';
+    }
+    protected function getModelName(): string
+    {
+        return 'channel.message';
+    }
+    protected function getRouteBase(): string
+    {
+        return 'message';
+    }
+    /***
+     *
+     * @return string
+     */
+    protected function getSessionBase($objectId = null): string
+    {
+        return 'message'.(($objectId) ? '.'.$objectId : '');
+    }
+    protected function getTranslationBase(): string
+    {
+        return 'mautic.channel.message';
+    }
+    /**
+     * @param int $page
+     *
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function contactsAction(
+        Request $request,
+        PageHelperFactoryInterface $pageHelperFactory,
+        $objectId,
+        $channel,
+        $page = 1,
+    ) {
+        $filter = [];
+        if ('all' !== $channel) {
+            $returnUrl = $this->generateUrl(
+                'mautic_message_action',
+                [
+                    'objectAction' => 'view',
+                    'objectId'     => $objectId,
+                ]
+            );
+            [$dateFrom, $dateTo] = $this->getViewDateRange($request, $objectId, $returnUrl, 'UTC');
+            $filter = [
+                'channel' => $channel,
+                [
+                    'col'  => 'entity.date_triggered',
+                    'expr' => 'between',
+                    'val'  => [
+                        $dateFrom->format('Y-m-d H:i:s'),
+                        $dateTo->format('Y-m-d H:i:s'),
+                    ],
+                ],
+            ];
+        }
+        return $this->generateContactsGrid(
+            $request,
+            $pageHelperFactory,
+            $objectId,
+            $page,
+            'channel:messages:view',
+            'message.'.$channel,
+            'campaign_lead_event_log',
+            $channel,
+            null,
+            $filter,
+            [
+                [
+                    'type'       => 'join',
+                    'from_alias' => 'entity',
+                    'table'      => 'campaign_events',
+                    'alias'      => 'event',
+                    'condition'  => "entity.event_id = event.id and event.channel = 'channel.message' and event.channel_id = ".(int) $objectId,
+                ],
+            ],
+            null,
+            [
+                'channel' => $channel ?: 'all',
+            ],
+            '.message-'.$channel
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Entity/Channel.php
@@ -0,0 +1,214 @@
+<?php
+namespace Mautic\ChannelBundle\Entity;
+use Doctrine\DBAL\Types\Types;
+use Doctrine\ORM\Mapping\ClassMetadata;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\CommonEntity;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Symfony\Component\Serializer\Annotation\Groups;
+/**
+ * @ApiResource(
+ *   attributes={
+ *     "security"="false",
+ *     "normalization_context"={
+ *       "groups"={
+ *         "channel:read"
+ *        },
+ *       "swagger_definition_name"="Read",
+ *       "api_included"={"message"}
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "channel:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Channel extends CommonEntity implements UuidInterface
+{
+    use UuidTrait;
+    /**
+     * @var int
+     */
+    private $id;
+    /**
+     * @var string
+     */
+    private $channel;
+    /**
+     * @var int|null
+     */
+    private $channelId;
+    /**
+     * @var string
+     */
+    private $channelName;
+    /**
+     * @var Message
+     */
+    private $message;
+    /**
+     * @var array
+     */
+    private $properties = [];
+    /**
+     * @var bool
+     */
+    private $isEnabled = false;
+    public static function loadMetadata(ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable('message_channels')
+                ->addIndex(['channel', 'channel_id'], 'channel_entity_index')
+                ->addIndex(['channel', 'is_enabled'], 'channel_enabled_index')
+                ->addUniqueConstraint(['message_id', 'channel'], 'channel_index');
+        $builder
+            ->addId()
+            ->addField('channel', 'string')
+            ->addNamedField('channelId', 'integer', 'channel_id', true)
+            ->addField('properties', Types::JSON)
+            ->createField('isEnabled', 'boolean')
+                ->columnName('is_enabled')
+                ->build();
+        $builder->createManyToOne('message', Message::class)
+                ->addJoinColumn('message_id', 'id', false, false, 'CASCADE')
+                ->inversedBy('channels')
+                ->build();
+        static::addUuidField($builder);
+    }
+    /**
+     * Prepares the metadata for API usage.
+     */
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('messageChannel')
+            ->addListProperties(
+                [
+                    'id',
+                    'channel',
+                    'channelId',
+                    'channelName',
+                    'isEnabled',
+                ]
+            )
+            ->addProperties(
+                [
+                    'properties',
+                    'message',
+                ]
+            )
+            ->build();
+    }
+    /**
+     * @return int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * @return string
+     */
+    public function getChannel()
+    {
+        return $this->channel;
+    }
+    /**
+     * @param string $channel
+     *
+     * @return Channel
+     */
+    public function setChannel($channel)
+    {
+        $this->channel = $channel;
+        return $this;
+    }
+    /**
+     * @return int
+     */
+    public function getChannelId()
+    {
+        return $this->channelId;
+    }
+    /**
+     * @param int $channelId
+     *
+     * @return Channel
+     */
+    public function setChannelId($channelId)
+    {
+        if (empty($channelId)) {
+            $channelId = null;
+        }
+        $this->channelId = $channelId;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getChannelName()
+    {
+        return $this->channelName;
+    }
+    /**
+     * @param string $channelName
+     *
+     * @return Channel
+     */
+    public function setChannelName($channelName)
+    {
+        $this->channelName = $channelName;
+        return $this;
+    }
+    /**
+     * @return Message
+     */
+    public function getMessage()
+    {
+        return $this->message;
+    }
+    /**
+     * @return Channel
+     */
+    public function setMessage(Message $message)
+    {
+        $this->message = $message;
+        return $this;
+    }
+    /**
+     * @return array
+     */
+    public function getProperties()
+    {
+        return $this->properties;
+    }
+    /**
+     * @return Channel
+     */
+    public function setProperties(array $properties)
+    {
+        $this->properties = $properties;
+        return $this;
+    }
+    /**
+     * @return bool
+     */
+    public function isEnabled()
+    {
+        return $this->isEnabled;
+    }
+    /**
+     * @param bool $isEnabled
+     *
+     * @return Channel
+     */
+    public function setIsEnabled($isEnabled)
+    {
+        $this->isEnabled = $isEnabled;
+        return $this;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Entity/Message.php
@@ -0,0 +1,249 @@
+<?php
+namespace Mautic\ChannelBundle\Entity;
+use Doctrine\Common\Collections\ArrayCollection;
+use Doctrine\ORM\Mapping\ClassMetadata;
+use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
+use Mautic\CategoryBundle\Entity\Category;
+use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
+use Mautic\CoreBundle\Entity\FormEntity;
+use Mautic\CoreBundle\Entity\UuidInterface;
+use Mautic\CoreBundle\Entity\UuidTrait;
+use Symfony\Component\Serializer\Annotation\Groups;
+use Symfony\Component\Validator\Constraints\NotBlank;
+use Symfony\Component\Validator\Mapping\ClassMetadata as ValidationClassMetadata;
+/**
+ * @ApiResource(
+ *   attributes={
+ *     "security"="false",
+ *     "normalization_context"={
+ *       "groups"={
+ *         "message:read"
+ *        },
+ *       "swagger_definition_name"="Read",
+ *       "api_included"={"category", "channels"}
+ *     },
+ *     "denormalization_context"={
+ *       "groups"={
+ *         "message:write"
+ *       },
+ *       "swagger_definition_name"="Write"
+ *     }
+ *   }
+ * )
+ */
+class Message extends FormEntity implements UuidInterface
+{
+    use UuidTrait;
+    /**
+     * @var ?int
+     */
+    private $id;
+    /**
+     * @var string
+     */
+    private $name;
+    /**
+     * @var ?string
+     */
+    private $description;
+    /**
+     * @var ?\DateTimeInterface
+     */
+    private $publishUp;
+    /**
+     * @var ?\DateTimeInterface
+     */
+    private $publishDown;
+    /**
+     * @var ?Category
+     */
+    private $category;
+    /**
+     * @var ArrayCollection<int,Channel>
+     */
+    private $channels;
+    public function __clone()
+    {
+        $this->id = null;
+    }
+    public static function loadMetadata(ClassMetadata $metadata): void
+    {
+        $builder = new ClassMetadataBuilder($metadata);
+        $builder->setTable('messages')
+                ->setCustomRepositoryClass(MessageRepository::class)
+                ->addIndex(['date_added'], 'date_message_added');
+        $builder
+            ->addIdColumns()
+            ->addPublishDates()
+            ->addCategory();
+        $builder->createOneToMany('channels', Channel::class)
+            ->setIndexBy('channel')
+            ->orphanRemoval()
+            ->mappedBy('message')
+            ->cascadeMerge()
+            ->cascadePersist()
+            ->cascadeDetach()
+            ->build();
+        static::addUuidField($builder);
+    }
+    public static function loadValidatorMetadata(ValidationClassMetadata $metadata): void
+    {
+        $metadata->addPropertyConstraint('name', new NotBlank([
+            'message' => 'mautic.core.name.required',
+        ]));
+    }
+    public static function loadApiMetadata(ApiMetadataDriver $metadata): void
+    {
+        $metadata->setGroupPrefix('message')
+            ->addListProperties(
+                [
+                    'id',
+                    'name',
+                    'description',
+                ]
+            )
+            ->addProperties(
+                [
+                    'publishUp',
+                    'publishDown',
+                    'channels',
+                    'category',
+                ]
+            )
+            ->build();
+    }
+    public function __construct()
+    {
+        $this->channels = new ArrayCollection();
+    }
+    /**
+     * @return ?int
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * @return ?string
+     */
+    public function getName()
+    {
+        return $this->name;
+    }
+    /**
+     * @param ?string $name
+     *
+     * @return Message
+     */
+    public function setName($name)
+    {
+        $this->isChanged('name', $name);
+        $this->name = $name;
+        return $this;
+    }
+    /**
+     * @return ?string
+     */
+    public function getDescription()
+    {
+        return $this->description;
+    }
+    /**
+     * @param ?string $description
+     *
+     * @return Message
+     */
+    public function setDescription($description)
+    {
+        $this->isChanged('description', $description);
+        $this->description = $description;
+        return $this;
+    }
+    /**
+     * @return ?\DateTimeInterface
+     */
+    public function getPublishUp()
+    {
+        return $this->publishUp;
+    }
+    /**
+     * @param ?\DateTime $publishUp
+     *
+     * @return Message
+     */
+    public function setPublishUp($publishUp)
+    {
+        $this->isChanged('publishUp', $publishUp);
+        $this->publishUp = $publishUp;
+        return $this;
+    }
+    /**
+     * @return ?\DateTimeInterface
+     */
+    public function getPublishDown()
+    {
+        return $this->publishDown;
+    }
+    /**
+     * @param ?\DateTime $publishDown
+     *
+     * @return Message
+     */
+    public function setPublishDown($publishDown)
+    {
+        $this->isChanged('publishDown', $publishDown);
+        $this->publishDown = $publishDown;
+        return $this;
+    }
+    /**
+     * @return ?Category
+     */
+    public function getCategory()
+    {
+        return $this->category;
+    }
+    /**
+     * @param ?Category $category
+     *
+     * @return Message
+     */
+    public function setCategory($category)
+    {
+        $this->isChanged('category', $category);
+        $this->category = $category;
+        return $this;
+    }
+    /**
+     * @return ArrayCollection<int,Channel>
+     */
+    public function getChannels()
+    {
+        return $this->channels;
+    }
+    /**
+     * @param ArrayCollection<int,Channel> $channels
+     *
+     * @return Message
+     */
+    public function setChannels($channels)
+    {
+        $this->isChanged('channels', $channels);
+        $this->channels = $channels;
+        return $this;
+    }
+    public function addChannel(Channel $channel): void
+    {
+        if (!$this->channels->contains($channel)) {
+            $channel->setMessage($this);
+            $this->isChanged('channels', $channel);
+            $this->channels[$channel->getChannel()] = $channel;
+        }
+    }
+    public function removeChannel(Channel $channel): void
+    {
+        if ($channel->getId()) {
+            $this->isChanged('channels', $channel->getId());
+        }
+        $this->channels->removeElement($channel);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Entity/MessageQueueRepository.php
@@ -0,0 +1,97 @@
+<?php
+namespace Mautic\ChannelBundle\Entity;
+use Doctrine\Common\Collections\Order;
+use Doctrine\DBAL\ArrayParameterType;
+use Mautic\CoreBundle\Entity\CommonRepository;
+use Mautic\LeadBundle\Entity\TimelineTrait;
+/**
+ * @extends CommonRepository<MessageQueue>
+ */
+class MessageQueueRepository extends CommonRepository
+{
+    use TimelineTrait;
+    public function findMessage($channel, $channelId, $leadId)
+    {
+        $results = $this->createQueryBuilder('mq')
+            ->where('IDENTITY(mq.lead) = :leadId')
+            ->andWhere('mq.channel = :channel')
+            ->andWhere('mq.channelId = :channelId')
+            ->setParameter('leadId', $leadId)
+            ->setParameter('channel', $channel)
+            ->setParameter('channelId', $channelId)
+            ->getQuery()
+            ->getResult();
+        return ($results) ? $results[0] : null;
+    }
+    /**
+     * @return array<int, MessageQueue>
+     */
+    public function getQueuedMessages($limit, $processStarted, $channel = null, $channelId = null)
+    {
+        $q = $this->createQueryBuilder('mq');
+        $q->where($q->expr()->eq('mq.success', ':success'))
+            ->andWhere($q->expr()->lt('mq.attempts', 'mq.maxAttempts'))
+            ->andWhere('mq.lastAttempt is null or mq.lastAttempt < :processStarted')
+            ->andWhere('mq.scheduledDate <= :processStarted')
+            ->setParameter('success', false, 'boolean')
+            ->setParameter('processStarted', $processStarted)
+            ->indexBy('mq', 'mq.id');
+        $q->orderBy('mq.priority, mq.scheduledDate', Order::Ascending->value);
+        if ($limit) {
+            $q->setMaxResults((int) $limit);
+        }
+        if ($channel) {
+            $q->andWhere($q->expr()->eq('mq.channel', ':channel'))
+                ->setParameter('channel', $channel);
+            if ($channelId) {
+                $q->andWhere($q->expr()->eq('mq.channelId', (int) $channelId));
+            }
+        }
+        return $q->getQuery()->getResult();
+    }
+    public function getQueuedChannelCount($channel, array $ids = null): int
+    {
+        $q = $this->getEntityManager()->getConnection()->createQueryBuilder();
+        $expr = $q->expr()->and(
+            $q->expr()->eq($this->getTableAlias().'.channel', ':channel'),
+            $q->expr()->neq($this->getTableAlias().'.status', ':status')
+        );
+        if (!empty($ids)) {
+            $expr = $expr->with(
+                $q->expr()->in($this->getTableAlias().'.channel_id', $ids)
+            );
+        }
+        return (int) $q->select('count(*)')
+            ->from(MAUTIC_TABLE_PREFIX.'message_queue', $this->getTableAlias())
+            ->where($expr)
+            ->setParameter('channel', $channel)
+            ->setParameter('status', MessageQueue::STATUS_SENT)
+            ->setParameter('ids', $ids, ArrayParameterType::INTEGER)
+            ->executeQuery()
+            ->fetchOne();
+    }
+    /**
+     * Get a lead's point log.
+     *
+     * @param int|null $leadId
+     *
+     * @return array
+     */
+    public function getLeadTimelineEvents($leadId = null, array $options = [])
+    {
+        $query = $this->getEntityManager()->getConnection()->createQueryBuilder()
+            ->from(MAUTIC_TABLE_PREFIX.'message_queue', 'mq')
+            ->select('mq.id, mq.lead_id, mq.channel as channelName, mq.channel_id as channelId,
+            mq.priority as priority, mq.attempts, mq.success, mq.status, mq.date_published as dateAdded,
+            mq.scheduled_date as scheduledDate, mq.last_attempt as lastAttempt, mq.date_sent as dateSent');
+        if ($leadId) {
+            $query->where('mq.lead_id = '.(int) $leadId);
+        }
+        if (isset($options['search']) && $options['search']) {
+            $query->andWhere($query->expr()->or(
+                $query->expr()->like('mq.channel', $query->expr()->literal('%'.$options['search'].'%'))
+            ));
+        }
+        return $this->getTimelineResults($query, $options, 'mq.channel', 'mq.date_published', [], ['dateAdded'], null, 'mq.id');
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Event/ChannelBroadcastEvent.php
@@ -0,0 +1,161 @@
+<?php
+namespace Mautic\ChannelBundle\Event;
+use Symfony\Component\Console\Output\OutputInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+class ChannelBroadcastEvent extends Event
+{
+    /**
+     * Number of contacts successfully processed and/or failed per channel.
+     *
+     * @var array
+     */
+    protected $results = [];
+    /**
+     * Min contact ID filter can be used for process parallelization.
+     *
+     * @var int
+     */
+    private $minContactIdFilter;
+    /**
+     * Max contact ID filter can be used for process parallelization.
+     *
+     * @var int
+     */
+    private $maxContactIdFilter;
+    /**
+     * How many contacts to load from the database.
+     */
+    private int $limit = 100;
+    /**
+     * How big batches to use to actually send.
+     */
+    private int $batch = 50;
+    private ?int $maxThreads = null;
+    private ?int $threadId = null;
+    public function __construct(
+        /**
+         * Specific channel.
+         */
+        protected ?string $channel,
+        /**
+         * Specific ID of a specific channel.
+         */
+        protected string|int|null $id,
+        protected OutputInterface $output,
+    ) {
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannel()
+    {
+        return $this->channel;
+    }
+    /**
+     * @return mixed
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+    /**
+     * @param string $channelLabel
+     * @param int    $successCount
+     * @param int    $failedCount
+     */
+    public function setResults($channelLabel, $successCount, $failedCount = 0, array $failedRecipientsByList = []): void
+    {
+        $this->results[$channelLabel] = [
+            'success'                => (int) $successCount,
+            'failed'                 => (int) $failedCount,
+            'failedRecipientsByList' => $failedRecipientsByList,
+        ];
+    }
+    /**
+     * @return array
+     */
+    public function getResults()
+    {
+        return $this->results;
+    }
+    public function checkContext($channel): bool
+    {
+        if ($this->channel && $this->channel !== $channel) {
+            return false;
+        }
+        return true;
+    }
+    /**
+     * @return OutputInterface
+     */
+    public function getOutput()
+    {
+        return $this->output;
+    }
+    /**
+     * @param int $minContactIdFilter
+     */
+    public function setMinContactIdFilter($minContactIdFilter): void
+    {
+        $this->minContactIdFilter = $minContactIdFilter;
+    }
+    /**
+     * @return int|null
+     */
+    public function getMinContactIdFilter()
+    {
+        return $this->minContactIdFilter;
+    }
+    /**
+     * @param int $maxContactIdFilter
+     */
+    public function setMaxContactIdFilter($maxContactIdFilter): void
+    {
+        $this->maxContactIdFilter = $maxContactIdFilter;
+    }
+    /**
+     * @return int|null
+     */
+    public function getMaxContactIdFilter()
+    {
+        return $this->maxContactIdFilter;
+    }
+    /**
+     * @param int $limit
+     */
+    public function setLimit($limit): void
+    {
+        $this->limit = $limit;
+    }
+    public function getLimit(): int
+    {
+        return $this->limit;
+    }
+    /**
+     * @param int $batch
+     */
+    public function setBatch($batch): void
+    {
+        $this->batch = $batch;
+    }
+    public function getBatch(): int
+    {
+        return $this->batch;
+    }
+    public function getMaxThreads(): ?int
+    {
+        return $this->maxThreads;
+    }
+    public function setMaxThreads(?int $maxThreads): void
+    {
+        $this->maxThreads = $maxThreads;
+    }
+    public function getThreadId(): ?int
+    {
+        return $this->threadId;
+    }
+    public function setThreadId(?int $threadId): void
+    {
+        $this->threadId = $threadId;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Event/MessageQueueBatchProcessEvent.php
@@ -0,0 +1,41 @@
+<?php
+namespace Mautic\ChannelBundle\Event;
+use Mautic\ChannelBundle\Entity\MessageQueue;
+use Symfony\Contracts\EventDispatcher\Event;
+class MessageQueueBatchProcessEvent extends Event
+{
+    /**
+     * @param MessageQueue[] $messages
+     */
+    public function __construct(
+        private array $messages,
+        private $channel,
+        private $channelId,
+    ) {
+    }
+    public function checkContext($channel): bool
+    {
+        return $channel === $this->channel;
+    }
+    /**
+     * @return array
+     */
+    public function getMessages()
+    {
+        return $this->messages;
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannel()
+    {
+        return $this->channel;
+    }
+    /**
+     * @return mixed
+     */
+    public function getChannelId()
+    {
+        return $this->channelId;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/ButtonSubscriber.php
@@ -0,0 +1,41 @@
+<?php
+namespace Mautic\ChannelBundle\EventListener;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\Event\CustomButtonEvent;
+use Mautic\CoreBundle\Twig\Helper\ButtonHelper;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ButtonSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private RouterInterface $router,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::VIEW_INJECT_CUSTOM_BUTTONS => ['injectContactBulkButtons', 0],
+        ];
+    }
+    public function injectContactBulkButtons(CustomButtonEvent $event): void
+    {
+        if (str_starts_with($event->getRoute(), 'mautic_contact_')) {
+            $event->addButton(
+                [
+                    'attr' => [
+                        'class'       => 'btn btn-ghost btn-sm btn-nospin',
+                        'data-toggle' => 'ajaxmodal',
+                        'data-target' => '#MauticSharedModal',
+                        'href'        => $this->router->generate('mautic_channel_batch_contact_view'),
+                        'data-header' => $this->translator->trans('mautic.lead.batch.channels'),
+                    ],
+                    'btnText'   => $this->translator->trans('mautic.lead.batch.channels'),
+                    'iconClass' => 'ri-remote-control-line',
+                ],
+                ButtonHelper::LOCATION_BULK_ACTIONS
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/CampaignSubscriber.php
@@ -0,0 +1,186 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ChannelBundle\EventListener;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\CampaignEvents;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
+use Mautic\CampaignBundle\Event\PendingEvent;
+use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
+use Mautic\CampaignBundle\EventCollector\EventCollector;
+use Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher;
+use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Form\Type\MessageSendType;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Mautic\ChannelBundle\PreferenceBuilder\PreferenceBuilder;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class CampaignSubscriber implements EventSubscriberInterface
+{
+    private ?Event $pseudoEvent = null;
+    private ?ArrayCollection $mmLogs = null;
+    /**
+     * @var mixed[]
+     */
+    private array $messageChannels = [];
+    public function __construct(
+        private MessageModel $messageModel,
+        private ActionDispatcher $actionDispatcher,
+        private EventCollector $eventCollector,
+        private LoggerInterface $logger,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CampaignEvents::CAMPAIGN_ON_BUILD       => ['onCampaignBuild', 0],
+            ChannelEvents::ON_CAMPAIGN_BATCH_ACTION => ['onCampaignTriggerAction', 0],
+        ];
+    }
+    public function onCampaignBuild(CampaignBuilderEvent $event): void
+    {
+        $channels  = $this->messageModel->getChannels();
+        $decisions = [];
+        foreach ($channels as $channel) {
+            if (isset($channel['campaignDecisionsSupported'])) {
+                $decisions = $decisions + $channel['campaignDecisionsSupported'];
+            }
+        }
+        $action = [
+            'label'                  => 'mautic.channel.message.send.marketing.message',
+            'description'            => 'mautic.channel.message.send.marketing.message.descr',
+            'batchEventName'         => ChannelEvents::ON_CAMPAIGN_BATCH_ACTION,
+            'formType'               => MessageSendType::class,
+            'channel'                => 'channel.message',
+            'channelIdField'         => 'marketingMessage',
+            'connectionRestrictions' => [
+                'target' => [
+                    'decision' => $decisions,
+                ],
+            ],
+            'timelineTemplate'       => '@MauticChannel/SubscribedEvents/Timeline/index.html.twig',
+            'timelineTemplateVars'   => [
+                'messageSettings' => $channels,
+            ],
+        ];
+        $event->addAction('message.send', $action);
+    }
+    /**
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \ReflectionException
+     */
+    public function onCampaignTriggerAction(PendingEvent $pendingEvent): void
+    {
+        $this->pseudoEvent = clone $pendingEvent->getEvent();
+        $this->pseudoEvent->setCampaign($pendingEvent->getEvent()->getCampaign());
+        $this->mmLogs    = $pendingEvent->getPending();
+        $campaignEvent   = $pendingEvent->getEvent();
+        $properties      = $campaignEvent->getProperties();
+        $messageSettings = $this->messageModel->getChannels();
+        $id              = (int) $properties['marketingMessage'];
+        $pendingEvent->setChannel('channel.message', $id);
+        if (!isset($this->messageChannels[$id])) {
+            $this->messageChannels[$id] = $this->messageModel->getMessageChannels($id);
+        }
+        $preferenceBuilder = new PreferenceBuilder($this->mmLogs, $this->pseudoEvent, $this->messageChannels[$id], $this->logger);
+        $priority           = 1;
+        $channelPreferences = $preferenceBuilder->getChannelPreferences();
+        while ($priority <= count($this->messageChannels[$id])) {
+            foreach ($channelPreferences as $channel => $preferences) {
+                if (!isset($messageSettings[$channel]['campaignAction'])) {
+                    continue;
+                }
+                $channelLogs = $preferences->getLogsByPriority($priority);
+                if (!$channelLogs->count()) {
+                    continue;
+                }
+                $this->pseudoEvent->setEventType(Event::TYPE_ACTION)
+                    ->setType($messageSettings[$channel]['campaignAction']);
+                $successfullyExecuted = $this->sendChannelMessage($channelLogs, $channel, $this->messageChannels[$id][$channel]);
+                $this->passExecutedLogs($pendingEvent, $successfullyExecuted, $preferenceBuilder);
+            }
+            ++$priority;
+        }
+        $this->removeSuccessfulFromFailures($pendingEvent);
+        $pendingEvent->failRemainingPending($this->translator->trans('mautic.channel.message.failed'));
+    }
+    /**
+     * @param string $channel
+     *
+     * @return bool|ArrayCollection
+     *
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
+     * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
+     * @throws \ReflectionException
+     */
+    private function sendChannelMessage(ArrayCollection $logs, $channel, array $messageChannel)
+    {
+        /** @var ActionAccessor $config */
+        $config = $this->eventCollector->getEventConfig($this->pseudoEvent);
+        if ($channelIdField = $config->getChannelIdField()) {
+            $messageChannel['properties'][$channelIdField] = $messageChannel['channel_id'];
+        }
+        $this->pseudoEvent->setProperties($messageChannel['properties']);
+        $pendingEvent = new PendingEvent($config, $this->pseudoEvent, $logs);
+        $pendingEvent->setChannel('campaign.event', $messageChannel['channel_id']);
+        $this->actionDispatcher->dispatchEvent(
+            $config,
+            $this->pseudoEvent,
+            $logs,
+            $pendingEvent
+        );
+        $this->recordChannelMetadata($pendingEvent, $channel);
+        $success = $pendingEvent->getSuccessful();
+        $this->removePsuedoFailures($success);
+        unset($pendingEvent);
+        return $success;
+    }
+    private function passExecutedLogs(PendingEvent $pendingEvent, ArrayCollection $logs, PreferenceBuilder $channelPreferences): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $channelPreferences->removeLogFromAllChannels($log);
+            $mmLog = $pendingEvent->findLogByContactId($log->getLead()->getId());
+            $pendingEvent->pass($mmLog);
+        }
+    }
+    /**
+     * @param ArrayCollection<int,LeadEventLog> $success
+     */
+    private function removePsuedoFailures(ArrayCollection $success): void
+    {
+        foreach ($success as $key => $log) {
+            if (!empty($log->getMetadata()['failed'])) {
+                $success->remove($key);
+            }
+        }
+    }
+    private function removeSuccessfulFromFailures(PendingEvent $pendingEvent): void
+    {
+        $successfulKeys = $pendingEvent->getSuccessful()->getKeys();
+        foreach ($successfulKeys as $key) {
+            if ($pendingEvent->getFailures()->containsKey($key)) {
+                $pendingEvent->getFailures()->remove($key);
+            }
+        }
+    }
+    private function recordChannelMetadata(PendingEvent $pendingEvent, string $channel): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($this->mmLogs as $log) {
+            try {
+                $channelLog = $pendingEvent->findLogByContactId($log->getLead()->getId());
+                if ($metadata = $channelLog->getMetadata()) {
+                    $log->appendToMetadata([$channel => $metadata]);
+                }
+            } catch (NoContactsFoundException) {
+                continue;
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/LeadSubscriber.php
@@ -0,0 +1,62 @@
+<?php
+namespace Mautic\ChannelBundle\EventListener;
+use Mautic\ChannelBundle\Entity\MessageQueueRepository;
+use Mautic\LeadBundle\Event\LeadTimelineEvent;
+use Mautic\LeadBundle\LeadEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class LeadSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private TranslatorInterface $translator,
+        private RouterInterface $router,
+        private MessageQueueRepository $messageQueueRepository,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
+        ];
+    }
+    /**
+     * Compile events for the lead timeline.
+     */
+    public function onTimelineGenerate(LeadTimelineEvent $event): void
+    {
+        $eventTypeKey  = 'message.queue';
+        $eventTypeName = $this->translator->trans('mautic.message.queue');
+        $event->addEventType($eventTypeKey, $eventTypeName);
+        $event->addSerializerGroup('messageQueueList');
+        $label = $this->translator->trans('mautic.queued.channel');
+        if (!$event->isApplicable($eventTypeKey)) {
+            return;
+        }
+        $logs = $this->messageQueueRepository->getLeadTimelineEvents($event->getLeadId(), $event->getQueryOptions());
+        $event->addToCounter($eventTypeKey, $logs);
+        if (!$event->isEngagementCount()) {
+            foreach ($logs['results'] as $log) {
+                $eventName = [
+                    'label' => $label.$log['channelName'].' '.$log['channelId'],
+                    'href'  => $this->router->generate('mautic_'.$log['channelName'].'_action', ['objectAction' => 'view', 'objectId' => $log['channelId']]),
+                ];
+                $event->addEvent(
+                    [
+                        'eventId'    => $eventTypeKey.$log['id'],
+                        'event'      => $eventTypeKey,
+                        'eventLabel' => $eventName,
+                        'eventType'  => $eventTypeName,
+                        'timestamp'  => $log['dateAdded'],
+                        'extra'      => [
+                            'log' => $log,
+                        ],
+                        'contentTemplate' => '@MauticChannel/SubscribedEvents/Timeline/queued_messages.html.twig',
+                        'icon'            => 'ri-question-answer-line',
+                        'contactId'       => $log['lead_id'],
+                    ]
+                );
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/MessageSubscriber.php
@@ -0,0 +1,52 @@
+<?php
+namespace Mautic\ChannelBundle\EventListener;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Event\MessageEvent;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class MessageSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private AuditLogModel $auditLogModel,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ChannelEvents::MESSAGE_POST_SAVE   => ['onPostSave', 0],
+            ChannelEvents::MESSAGE_POST_DELETE => ['onDelete', 0],
+        ];
+    }
+    /**
+     * Add an entry to the audit log.
+     */
+    public function onPostSave(MessageEvent $event): void
+    {
+        $entity = $event->getMessage();
+        if ($details = $event->getChanges()) {
+            $log = [
+                'bundle'   => 'channel',
+                'object'   => 'message',
+                'objectId' => $entity->getId(),
+                'action'   => ($event->isNew()) ? 'create' : 'update',
+                'details'  => $details,
+            ];
+            $this->auditLogModel->writeToLog($log);
+        }
+    }
+    /**
+     * Add a delete entry to the audit log.
+     */
+    public function onDelete(MessageEvent $event): void
+    {
+        $entity = $event->getMessage();
+        $log    = [
+            'bundle'   => 'channel',
+            'object'   => 'message',
+            'objectId' => $entity->deletedId,
+            'action'   => 'delete',
+            'details'  => ['name' => $entity->getName()],
+        ];
+        $this->auditLogModel->writeToLog($log);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/ReportSubscriber.php
@@ -0,0 +1,128 @@
+<?php
+namespace Mautic\ChannelBundle\EventListener;
+use Mautic\LeadBundle\Model\CompanyReportData;
+use Mautic\ReportBundle\Event\ReportBuilderEvent;
+use Mautic\ReportBundle\Event\ReportDataEvent;
+use Mautic\ReportBundle\Event\ReportGeneratorEvent;
+use Mautic\ReportBundle\ReportEvents;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\Routing\RouterInterface;
+class ReportSubscriber implements EventSubscriberInterface
+{
+    public const CONTEXT_MESSAGE_CHANNEL = 'message.channel';
+    public function __construct(
+        private CompanyReportData $companyReportData,
+        private RouterInterface $router,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ReportEvents::REPORT_ON_BUILD    => ['onReportBuilder', 0],
+            ReportEvents::REPORT_ON_GENERATE => ['onReportGenerate', 0],
+            ReportEvents::REPORT_ON_DISPLAY  => ['onReportDisplay', 0],
+        ];
+    }
+    /**
+     * Add available tables and columns to the report builder lookup.
+     */
+    public function onReportBuilder(ReportBuilderEvent $event): void
+    {
+        if (!$event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
+            return;
+        }
+        $prefix  = 'mq.';
+        $columns = [
+            $prefix.'channel' => [
+                'label' => 'mautic.message.queue.report.channel',
+                'type'  => 'html',
+            ],
+            $prefix.'channel_id' => [
+                'label' => 'mautic.message.queue.report.channel_id',
+                'type'  => 'int',
+            ],
+            $prefix.'priority' => [
+                'label' => 'mautic.message.queue.report.priority',
+                'type'  => 'string',
+            ],
+            $prefix.'max_attempts' => [
+                'label' => 'mautic.message.queue.report.max_attempts',
+                'type'  => 'int',
+            ],
+            $prefix.'attempts' => [
+                'label' => 'mautic.message.queue.report.attempts',
+                'type'  => 'int',
+            ],
+            $prefix.'success' => [
+                'label' => 'mautic.message.queue.report.success',
+                'type'  => 'boolean',
+            ],
+            $prefix.'status' => [
+                'label' => 'mautic.message.queue.report.status',
+                'type'  => 'string',
+            ],
+            $prefix.'last_attempt' => [
+                'label' => 'mautic.message.queue.report.last_attempt',
+                'type'  => 'datetime',
+            ],
+            $prefix.'date_sent' => [
+                'label' => 'mautic.message.queue.report.date_sent',
+                'type'  => 'datetime',
+            ],
+            $prefix.'scheduled_date' => [
+                'label' => 'mautic.message.queue.report.scheduled_date',
+                'type'  => 'datetime',
+            ],
+            $prefix.'date_published' => [
+                'label' => 'mautic.message.queue.report.date_published',
+                'type'  => 'datetime',
+            ],
+        ];
+        $companyColumns = $this->companyReportData->getCompanyData();
+        $columns = array_merge(
+            $columns,
+            $event->getLeadColumns(),
+            $companyColumns
+        );
+        $event->addTable(
+            self::CONTEXT_MESSAGE_CHANNEL,
+            [
+                'display_name' => 'mautic.message.queue',
+                'columns'      => $columns,
+            ]
+        );
+    }
+    /**
+     * Initialize the QueryBuilder object to generate reports from.
+     */
+    public function onReportGenerate(ReportGeneratorEvent $event): void
+    {
+        if (!$event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
+            return;
+        }
+        $queryBuilder = $event->getQueryBuilder();
+        $queryBuilder->from(MAUTIC_TABLE_PREFIX.'message_queue', 'mq')
+            ->leftJoin('mq', MAUTIC_TABLE_PREFIX.'leads', 'l', 'l.id = mq.lead_id');
+        if ($this->companyReportData->eventHasCompanyColumns($event)) {
+            $event->addCompanyLeftJoin($queryBuilder);
+        }
+        $event->setQueryBuilder($queryBuilder);
+    }
+    public function onReportDisplay(ReportDataEvent $event): void
+    {
+        $data = $event->getData();
+        if ($event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
+            if (isset($data[0]['channel']) && isset($data[0]['channel_id'])) {
+                foreach ($data as &$row) {
+                    $href = $this->router->generate('mautic_'.$row['channel'].'_action', ['objectAction' => 'view', 'objectId' => $row['channel_id']]);
+                    if (isset($row['channel'])) {
+                        $row['channel'] = '<a href="'.$href.'">'.$row['channel'].'</a>';
+                    }
+                    unset($row);
+                }
+            }
+        }
+        $event->setData($data);
+        unset($data);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/EventListener/SearchSubscriber.php
@@ -0,0 +1,34 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ChannelBundle\EventListener;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Mautic\CoreBundle\CoreEvents;
+use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
+use Mautic\CoreBundle\Event\GlobalSearchEvent;
+use Mautic\CoreBundle\Service\GlobalSearch;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class SearchSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private MessageModel $model,
+        private GlobalSearch $globalSearch,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            CoreEvents::GLOBAL_SEARCH => ['onGlobalSearch', 0],
+        ];
+    }
+    public function onGlobalSearch(GlobalSearchEvent $event): void
+    {
+        $results = $this->globalSearch->performSearch(
+            new GlobalSearchFilterDTO($event->getSearchString()),
+            $this->model,
+            '@MauticChannel/SubscribedEvents/Search/global.html.twig'
+        );
+        if (!empty($results)) {
+            $event->addResults('mautic.messages.header', $results);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Form/Type/MessageListType.php
@@ -0,0 +1,44 @@
+<?php
+namespace Mautic\ChannelBundle\Form\Type;
+use Mautic\CoreBundle\Form\Type\EntityLookupType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\OptionsResolver\Options;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class MessageListType extends AbstractType
+{
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(
+            [
+                'required'           => false,
+                'modal_route'        => 'mautic_message_action',
+                'model'              => 'channel.message',
+                'multiple'           => true,
+                'ajax_lookup_action' => function (Options $options): string {
+                    $query = [
+                        'is_published' => $options['is_published'],
+                    ];
+                    return 'channel:getLookupChoiceList&'.http_build_query($query);
+                },
+                'model_lookup_method' => 'getLookupResults',
+                'lookup_arguments'    => fn (Options $options): array => [
+                    'type'    => 'channel.message',
+                    'filter'  => '$data',
+                    'limit'   => 0,
+                    'start'   => 0,
+                    'options' => [
+                        'is_published' => $options['is_published'],
+                    ],
+                ],
+                'is_published' => true,
+            ]
+        );
+    }
+    public function getParent(): ?string
+    {
+        return EntityLookupType::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Form/Type/MessageSendType.php
@@ -0,0 +1,86 @@
+<?php
+namespace Mautic\ChannelBundle\Form\Type;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\ButtonType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Routing\RouterInterface;
+use Symfony\Component\Validator\Constraints\NotBlank;
+/**
+ * @extends AbstractType<mixed>
+ */
+class MessageSendType extends AbstractType
+{
+    public function __construct(
+        protected RouterInterface $router,
+        protected MessageModel $messageModel,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $builder->add(
+            'marketingMessage',
+            MessageListType::class,
+            [
+                'label'       => 'mautic.channel.send.selectmessages',
+                'label_attr'  => ['class' => 'control-label'],
+                'multiple'    => false,
+                'required'    => true,
+                'constraints' => [
+                    new NotBlank(
+                        ['message' => 'mautic.channel.choosemessage.notblank']
+                    ),
+                ],
+            ]
+        );
+        if (!empty($options['update_select'])) {
+            $windowUrl = $this->router->generate(
+                'mautic_message_action',
+                [
+                    'objectAction' => 'new',
+                    'contentOnly'  => 1,
+                    'updateSelect' => $options['update_select'],
+                ]
+            );
+            $builder->add(
+                'newMarketingMessageButton',
+                ButtonType::class,
+                [
+                    'attr' => [
+                        'class'   => 'btn btn-primary btn-nospin',
+                        'onclick' => 'Mautic.loadNewWindow({windowUrl: \''.$windowUrl.'\'})',
+                        'icon'    => 'ri-add-line',
+                    ],
+                    'label' => 'mautic.channel.create.new.message',
+                ]
+            );
+            $windowUrlEdit = $this->router->generate(
+                'mautic_message_action',
+                [
+                    'objectAction' => 'edit',
+                    'objectId'     => 'messageId',
+                    'contentOnly'  => 1,
+                    'updateSelect' => $options['update_select'],
+                ]
+            );
+            $builder->add(
+                'editMessageButton',
+                ButtonType::class,
+                [
+                    'attr' => [
+                        'class'    => 'btn btn-primary btn-nospin',
+                        'onclick'  => 'Mautic.loadNewWindow({windowUrl: \''.$windowUrlEdit.'\'})',
+                        'disabled' => !isset($options['data']['message']),
+                        'icon'     => 'ri-edit-line',
+                    ],
+                    'label' => 'mautic.channel.send.edit.message',
+                ]
+            );
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefined(['update_select']);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Form/Type/MessageType.php
@@ -0,0 +1,65 @@
+<?php
+namespace Mautic\ChannelBundle\Form\Type;
+use Mautic\ChannelBundle\Entity\Channel;
+use Mautic\ChannelBundle\Entity\Message;
+use Mautic\ChannelBundle\Model\MessageModel;
+use Mautic\CoreBundle\Form\Type\AbstractFormStandardType;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Symfony\Component\Form\Extension\Core\Type\CollectionType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+use Symfony\Component\Validator\Constraints\Valid;
+class MessageType extends AbstractFormStandardType
+{
+    public function __construct(
+        protected MessageModel $model,
+        CorePermissions $security,
+    ) {
+        $this->security = $security;
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $options = array_merge($options, ['model_name' => 'channel.message', 'permission_base' => 'channel:messages']);
+        parent::buildForm($builder, $options);
+        /** @var Message $message */
+        $message         = $options['data'];
+        $channels        = $this->model->getChannels();
+        $messageChannels = $message->getChannels();
+        foreach ($channels as $channelType => $channel) {
+            if (!isset($messageChannels[$channelType])) {
+                $message->addChannel(
+                    (new Channel())
+                        ->setChannel($channelType)
+                        ->setMessage($message)
+                );
+            }
+        }
+        $builder->add(
+            'channels',
+            CollectionType::class,
+            [
+                'label'         => false,
+                'allow_add'     => true,
+                'allow_delete'  => false,
+                'prototype'     => false,
+                'entry_type'    => ChannelType::class,
+                'by_reference'  => false,
+                'entry_options' => [
+                    'channels' => $channels,
+                ],
+                'constraints' => [
+                    new Valid(),
+                ],
+            ]
+        );
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(
+            [
+                'data_class'      => Message::class,
+                'category_bundle' => 'messages',
+            ]
+        );
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Helper/ChannelListHelper.php
@@ -0,0 +1,100 @@
+<?php
+namespace Mautic\ChannelBundle\Helper;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Event\ChannelEvent;
+use Mautic\CoreBundle\Translation\Translator;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+class ChannelListHelper
+{
+    /**
+     * @var array<string,string>
+     */
+    private array $channels = [];
+    /**
+     * @var array<string,string[]>
+     */
+    private array $featureChannels = [];
+    public function __construct(
+        private EventDispatcherInterface $dispatcher,
+        private Translator $translator,
+    ) {
+    }
+    /**
+     * Get contact channels.
+     */
+    public function getChannelList(): array
+    {
+        $channels = [];
+        foreach ($this->getChannels() as $channel => $details) {
+            $channelName            = isset($details['label']) ? $this->translator->trans($details['label']) : $this->getChannelLabel($channel);
+            $channels[$channelName] = $channel;
+        }
+        return $channels;
+    }
+    /**
+     * @param bool $listOnly
+     */
+    public function getFeatureChannels($features, $listOnly = false): array
+    {
+        $this->setupChannels();
+        if (!is_array($features)) {
+            $features = [$features];
+        }
+        $channels = [];
+        foreach ($features as $feature) {
+            $featureChannels = $this->featureChannels[$feature] ?? [];
+            $returnChannels  = [];
+            foreach ($featureChannels as $channel => $details) {
+                if (!isset($details['label'])) {
+                    $featureChannels[$channel]['label'] = $this->getChannelLabel($channel);
+                }
+                if ($listOnly) {
+                    $returnChannels[$featureChannels[$channel]['label']] = $channel;
+                } else {
+                    $returnChannels[$channel] = $featureChannels[$channel];
+                }
+            }
+            unset($featureChannels);
+            $channels[$feature] = $returnChannels;
+        }
+        if (1 === count($features)) {
+            $channels = $channels[$features[0]];
+        }
+        return $channels;
+    }
+    /**
+     * @return array
+     */
+    public function getChannels()
+    {
+        $this->setupChannels();
+        return $this->channels;
+    }
+    public function getChannelLabel($channel): string
+    {
+        return match (true) {
+            $this->translator->hasId('mautic.channel.'.$channel)      => $this->translator->trans('mautic.channel.'.$channel),
+            $this->translator->hasId('mautic.'.$channel.'.'.$channel) => $this->translator->trans('mautic.'.$channel.'.'.$channel),
+            default                                                   => ucfirst($channel),
+        };
+    }
+    public function getName(): string
+    {
+        return 'chanel';
+    }
+    /**
+     * Setup channels.
+     *
+     * Done this way to avoid a circular dependency error with LeadModel
+     */
+    private function setupChannels(): void
+    {
+        if (!empty($this->channels)) {
+            return;
+        }
+        $event                 = $this->dispatcher->dispatch(new ChannelEvent(), ChannelEvents::ADD_CHANNEL);
+        $this->channels        = $event->getChannelConfigs();
+        $this->featureChannels = $event->getFeatureChannels();
+        unset($event);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Model/ChannelActionModel.php
@@ -0,0 +1,62 @@
+<?php
+namespace Mautic\ChannelBundle\Model;
+use Mautic\LeadBundle\Entity\DoNotContact as DNC;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\DoNotContact;
+use Mautic\LeadBundle\Model\LeadModel;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class ChannelActionModel
+{
+    public function __construct(
+        private LeadModel $contactModel,
+        private DoNotContact $doNotContact,
+        private TranslatorInterface $translator,
+    ) {
+    }
+    /**
+     * Update channels and frequency rules.
+     */
+    public function update(array $contactIds, array $subscribedChannels): void
+    {
+        $contacts = $this->contactModel->getLeadsByIds($contactIds);
+        foreach ($contacts as $contact) {
+            if (!$this->contactModel->canEditContact($contact)) {
+                continue;
+            }
+            $this->addChannels($contact, $subscribedChannels);
+            $this->removeChannels($contact, $subscribedChannels);
+        }
+    }
+    /**
+     * Add contact's channels.
+     * Only resubscribe if the contact did not opt out themselves.
+     */
+    private function addChannels(Lead $contact, array $subscribedChannels): void
+    {
+        $contactChannels = $this->contactModel->getContactChannels($contact);
+        foreach ($subscribedChannels as $subscribedChannel) {
+            if (!array_key_exists($subscribedChannel, $contactChannels)) {
+                $contactable = $this->doNotContact->isContactable($contact, $subscribedChannel);
+                if (DNC::UNSUBSCRIBED !== $contactable) {
+                    $this->doNotContact->removeDncForContact($contact->getId(), $subscribedChannel);
+                }
+            }
+        }
+    }
+    /**
+     * Remove contact's channels.
+     */
+    private function removeChannels(Lead $contact, array $subscribedChannels): void
+    {
+        $allChannels = $this->contactModel->getPreferenceChannels();
+        $dncChannels = array_diff($allChannels, $subscribedChannels);
+        foreach ($dncChannels as $channel) {
+            $this->doNotContact->addDncForContact(
+                $contact->getId(),
+                $channel,
+                DNC::MANUAL,
+                $this->translator->trans('mautic.lead.event.donotcontact_manual')
+            );
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Model/FrequencyActionModel.php
@@ -0,0 +1,64 @@
+<?php
+namespace Mautic\ChannelBundle\Model;
+use Mautic\LeadBundle\Entity\FrequencyRule;
+use Mautic\LeadBundle\Entity\FrequencyRuleRepository;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\LeadModel;
+class FrequencyActionModel
+{
+    public function __construct(
+        private LeadModel $contactModel,
+        private FrequencyRuleRepository $frequencyRuleRepository,
+    ) {
+    }
+    /**
+     * Update channels.
+     *
+     * @param string $preferredChannel
+     */
+    public function update(array $contactIds, array $params, $preferredChannel): void
+    {
+        $contacts = $this->contactModel->getLeadsByIds($contactIds);
+        foreach ($contacts as $contact) {
+            if (!$this->contactModel->canEditContact($contact)) {
+                continue;
+            }
+            $this->updateFrequencyRules($contact, $params, $preferredChannel);
+        }
+    }
+    /**
+     * @param string $preferredChannel
+     */
+    private function updateFrequencyRules(Lead $contact, array $params, $preferredChannel): void
+    {
+        $frequencyRules = $contact->getFrequencyRules()->toArray();
+        $channels       = $this->contactModel->getPreferenceChannels();
+        foreach ($channels as $channel) {
+            if (is_null($preferredChannel)) {
+                $preferredChannel = $channel;
+            }
+            $frequencyRule = $frequencyRules[$channel] ?? new FrequencyRule();
+            $frequencyRule->setChannel($channel);
+            $frequencyRule->setLead($contact);
+            if (!$frequencyRule->getDateAdded()) {
+                $frequencyRule->setDateAdded(new \DateTime());
+            }
+            if (!empty($params['frequency_number_'.$channel]) && !empty($params['frequency_time_'.$channel])) {
+                $frequencyRule->setFrequencyNumber($params['frequency_number_'.$channel]);
+                $frequencyRule->setFrequencyTime($params['frequency_time_'.$channel]);
+            } else {
+                $frequencyRule->setFrequencyNumber(null);
+                $frequencyRule->setFrequencyTime(null);
+            }
+            if (!empty($params['contact_pause_start_date_'.$channel])) {
+                $frequencyRule->setPauseFromDate(new \DateTime($params['contact_pause_start_date_'.$channel]));
+            }
+            if (!empty($params['contact_pause_end_date_'.$channel])) {
+                $frequencyRule->setPauseToDate(new \DateTime($params['contact_pause_end_date_'.$channel]));
+            }
+            $frequencyRule->setPreferredChannel($preferredChannel === $channel);
+            $contact->addFrequencyRule($frequencyRule);
+            $this->frequencyRuleRepository->saveEntity($frequencyRule);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Model/MessageModel.php
@@ -0,0 +1,231 @@
+<?php
+namespace Mautic\ChannelBundle\Model;
+use Doctrine\ORM\EntityManager;
+use Mautic\CampaignBundle\Model\CampaignModel;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Entity\Message;
+use Mautic\ChannelBundle\Entity\MessageRepository;
+use Mautic\ChannelBundle\Event\MessageEvent;
+use Mautic\ChannelBundle\Form\Type\MessageType;
+use Mautic\ChannelBundle\Helper\ChannelListHelper;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\AjaxLookupModelInterface;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Model\GlobalSearchInterface;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @extends FormModel<Message>
+ *
+ * @implements AjaxLookupModelInterface<Message>
+ */
+class MessageModel extends FormModel implements AjaxLookupModelInterface, GlobalSearchInterface
+{
+    public const CHANNEL_FEATURE = 'marketing_messages';
+    protected static $channels;
+    public function __construct(
+        protected ChannelListHelper $channelListHelper,
+        protected CampaignModel $campaignModel,
+        EntityManager $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+        CoreParametersHelper $coreParametersHelper,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    /**
+     * @param Message $entity
+     * @param bool    $unlock
+     */
+    public function saveEntity($entity, $unlock = true): void
+    {
+        $isNew = $entity->isNew();
+        parent::saveEntity($entity, $unlock);
+        if (!$isNew) {
+            $channels = $entity->getChannels();
+            foreach ($channels as $channel) {
+                $channel->setMessage($entity);
+            }
+            $this->getRepository()->saveEntities($channels);
+        }
+    }
+    public function getPermissionBase(): string
+    {
+        return 'channel:messages';
+    }
+    public function getRepository(): ?MessageRepository
+    {
+        return $this->em->getRepository(Message::class);
+    }
+    public function getEntity($id = null): ?Message
+    {
+        if (null === $id) {
+            return new Message();
+        }
+        return parent::getEntity($id);
+    }
+    /**
+     * @param object $entity
+     * @param array  $options
+     *
+     * @return \Symfony\Component\Form\FormInterface<mixed>
+     */
+    public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
+    {
+        if (!empty($action)) {
+            $options['action'] = $action;
+        }
+        return $formFactory->create(MessageType::class, $entity, $options);
+    }
+    /**
+     * @return array
+     */
+    public function getChannels()
+    {
+        if (!self::$channels) {
+            $channels = $this->channelListHelper->getFeatureChannels(self::CHANNEL_FEATURE);
+            foreach ($channels as $channel => $config) {
+                if (!isset($config['lookupFormType']) && !isset($config['propertiesFormType'])) {
+                    throw new \InvalidArgumentException('lookupFormType and/or propertiesFormType are required for channel '.$channel);
+                }
+                $label = match (true) {
+                    $this->translator->hasId('mautic.channel.'.$channel)      => $this->translator->trans('mautic.channel.'.$channel),
+                    $this->translator->hasId('mautic.'.$channel)              => $this->translator->trans('mautic.'.$channel),
+                    $this->translator->hasId('mautic.'.$channel.'.'.$channel) => $this->translator->trans('mautic.'.$channel.'.'.$channel),
+                    default                                                   => ucfirst($channel),
+                };
+                $config['label'] = $label;
+                $channels[$channel] = $config;
+            }
+            self::$channels = $channels;
+        }
+        return self::$channels;
+    }
+    /**
+     * @param string $filter
+     * @param int    $limit
+     * @param int    $start
+     * @param array  $options
+     */
+    public function getLookupResults($type, $filter = '', $limit = 10, $start = 0, $options = []): array
+    {
+        $results = [];
+        switch ($type) {
+            case 'channel.message':
+                $entities = $this->getRepository()->getMessageList(
+                    $filter,
+                    $limit,
+                    $start
+                );
+                foreach ($entities as $entity) {
+                    $results[] = [
+                        'label' => $entity['name'],
+                        'value' => $entity['id'],
+                    ];
+                }
+                break;
+        }
+        return $results;
+    }
+    public function getMessageChannels($messageId): array
+    {
+        return $this->getRepository()->getMessageChannels($messageId);
+    }
+    /**
+     * @return array
+     */
+    public function getChannelMessageByChannelId($channelId)
+    {
+        return $this->getRepository()->getChannelMessageByChannelId($channelId);
+    }
+    public function getLeadStatsPost($messageId, $dateFrom = null, $dateTo = null, $channel = null): array
+    {
+        $eventLog = $this->campaignModel->getCampaignLeadEventLogRepository();
+        return $eventLog->getChartQuery(
+            [
+                'type'       => 'message.send',
+                'dateFrom'   => $dateFrom,
+                'dateTo'     => $dateTo,
+                'channel'    => 'channel.message',
+                'channelId'  => $messageId,
+                'logChannel' => $channel,
+            ]
+        );
+    }
+    /**
+     * @return mixed
+     */
+    public function getMarketingMessagesEventLogs($messageId, $dateFrom = null, $dateTo = null)
+    {
+        $eventLog = $this->campaignModel->getCampaignLeadEventLogRepository();
+        return $eventLog->getEventLogs(['type' => 'message.send', 'dateFrom' => $dateFrom, 'dateTo' => $dateTo, 'channel' => 'message', 'channelId' => $messageId]);
+    }
+    /**
+     * Get the channel name from the database.
+     *
+     * @template T of object
+     *
+     * @param int             $id
+     * @param class-string<T> $entityName
+     * @param string          $nameColumn
+     *
+     * @return string|null
+     */
+    public function getChannelName($id, $entityName, $nameColumn = 'name')
+    {
+        if (!$id || !$entityName || !$nameColumn) {
+            return null;
+        }
+        $repo = $this->em->getRepository($entityName);
+        $qb   = $repo->createQueryBuilder('e')
+            ->select('e.'.$nameColumn)
+            ->where('e.id = :id')
+            ->setParameter('id', (int) $id);
+        $result = $qb->getQuery()->getOneOrNullResult();
+        return $result[$nameColumn] ?? null;
+    }
+    /**
+     * @throws MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
+    {
+        if (!$entity instanceof Message) {
+            throw new MethodNotAllowedHttpException(['Message']);
+        }
+        switch ($action) {
+            case 'pre_save':
+                $name = ChannelEvents::MESSAGE_PRE_SAVE;
+                break;
+            case 'post_save':
+                $name = ChannelEvents::MESSAGE_POST_SAVE;
+                break;
+            case 'pre_delete':
+                $name = ChannelEvents::MESSAGE_PRE_DELETE;
+                break;
+            case 'post_delete':
+                $name = ChannelEvents::MESSAGE_POST_DELETE;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new MessageEvent($entity, $isNew);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        }
+        return null;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Model/MessageQueueModel.php
@@ -0,0 +1,312 @@
+<?php
+namespace Mautic\ChannelBundle\Model;
+use Doctrine\ORM\EntityManagerInterface;
+use Mautic\ChannelBundle\ChannelEvents;
+use Mautic\ChannelBundle\Entity\MessageQueue;
+use Mautic\ChannelBundle\Event\MessageQueueBatchProcessEvent;
+use Mautic\ChannelBundle\Event\MessageQueueEvent;
+use Mautic\ChannelBundle\Event\MessageQueueProcessEvent;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Model\FormModel;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\LeadBundle\Entity\Lead;
+use Mautic\LeadBundle\Model\CompanyModel;
+use Mautic\LeadBundle\Model\LeadModel;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+use Symfony\Contracts\EventDispatcher\Event;
+/**
+ * @extends FormModel<MessageQueue>
+ */
+class MessageQueueModel extends FormModel
+{
+    /**
+     * @var string A default message reschedule interval
+     */
+    public const DEFAULT_RESCHEDULE_INTERVAL = 'PT15M';
+    public function __construct(
+        protected LeadModel $leadModel,
+        protected CompanyModel $companyModel,
+        CoreParametersHelper $coreParametersHelper,
+        EntityManagerInterface $em,
+        CorePermissions $security,
+        EventDispatcherInterface $dispatcher,
+        UrlGeneratorInterface $router,
+        Translator $translator,
+        UserHelper $userHelper,
+        LoggerInterface $mauticLogger,
+    ) {
+        parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
+    }
+    /**
+     * @return \Mautic\ChannelBundle\Entity\MessageQueueRepository
+     */
+    public function getRepository()
+    {
+        return $this->em->getRepository(MessageQueue::class);
+    }
+    /**
+     * @param int    $attempts
+     * @param int    $priority
+     * @param mixed  $messageQueue
+     * @param string $statTableName
+     * @param string $statContactColumn
+     * @param string $statSentColumn
+     */
+    public function processFrequencyRules(
+        array &$leads,
+        $channel,
+        $channelId,
+        $campaignEventId = null,
+        $attempts = 3,
+        $priority = MessageQueue::PRIORITY_NORMAL,
+        $messageQueue = null,
+        $statTableName = 'email_stats',
+        $statContactColumn = 'lead_id',
+        $statSentColumn = 'date_sent',
+    ): array {
+        $leadIds = array_keys($leads);
+        $leadIds = array_combine($leadIds, $leadIds);
+        /** @var \Mautic\LeadBundle\Entity\FrequencyRuleRepository $frequencyRulesRepo */
+        $frequencyRulesRepo     = $this->em->getRepository(\Mautic\LeadBundle\Entity\FrequencyRule::class);
+        $defaultFrequencyNumber = $this->coreParametersHelper->get($channel.'_frequency_number');
+        $defaultFrequencyTime   = $this->coreParametersHelper->get($channel.'_frequency_time');
+        $dontSendTo = $frequencyRulesRepo->getAppliedFrequencyRules(
+            $channel,
+            $leadIds,
+            $defaultFrequencyNumber,
+            $defaultFrequencyTime,
+            $statTableName,
+            $statContactColumn,
+            $statSentColumn
+        );
+        $queuedContacts = [];
+        foreach ($dontSendTo as $frequencyRuleMet) {
+            $scheduleInterval = new \DateInterval('P1'.substr($frequencyRuleMet['frequency_time'], 0, 1));
+            if ($messageQueue && isset($messageQueue[$frequencyRuleMet['lead_id']])) {
+                $this->reschedule($messageQueue[$frequencyRuleMet['lead_id']], $scheduleInterval);
+            } else {
+                $this->queue(
+                    [$leads[$frequencyRuleMet['lead_id']]],
+                    $channel,
+                    $channelId,
+                    $scheduleInterval,
+                    $attempts,
+                    $priority,
+                    $campaignEventId
+                );
+            }
+            $queuedContacts[$frequencyRuleMet['lead_id']] = $frequencyRuleMet['lead_id'];
+            unset($leads[$frequencyRuleMet['lead_id']]);
+        }
+        return $queuedContacts;
+    }
+    /**
+     * Adds messages to the queue.
+     *
+     * @param array    $leads
+     * @param string   $channel
+     * @param int      $channelId
+     * @param int      $maxAttempts
+     * @param int      $priority
+     * @param int|null $campaignEventId
+     * @param array    $options
+     */
+    public function queue(
+        $leads,
+        $channel,
+        $channelId,
+        \DateInterval $scheduledInterval,
+        $maxAttempts = 1,
+        $priority = 1,
+        $campaignEventId = null,
+        $options = [],
+    ): bool {
+        $messageQueues = [];
+        $scheduledDate = (new \DateTime())->add($scheduledInterval);
+        foreach ($leads as $lead) {
+            $leadId = (is_array($lead)) ? $lead['id'] : $lead->getId();
+            if (!empty($this->getRepository()->findMessage($channel, $channelId, $leadId))) {
+                continue;
+            }
+            $messageQueue = new MessageQueue();
+            if ($campaignEventId) {
+                $messageQueue->setEvent($this->em->getReference(\Mautic\CampaignBundle\Entity\Event::class, $campaignEventId));
+            }
+            $messageQueue->setChannel($channel);
+            $messageQueue->setChannelId($channelId);
+            $messageQueue->setDatePublished(new \DateTime());
+            $messageQueue->setMaxAttempts($maxAttempts);
+            $messageQueue->setLead(
+                ($lead instanceof Lead) ? $lead : $this->em->getReference(Lead::class, $leadId)
+            );
+            $messageQueue->setPriority($priority);
+            $messageQueue->setScheduledDate($scheduledDate);
+            $messageQueue->setOptions($options);
+            $messageQueues[] = $messageQueue;
+        }
+        if ($messageQueues) {
+            $this->saveEntities($messageQueues);
+            $messageQueueRepository = $this->getRepository();
+            $messageQueueRepository->detachEntities($messageQueues);
+        }
+        return true;
+    }
+    public function sendMessages($channel = null, $channelId = null): int
+    {
+        $processStarted = new \DateTime();
+        $limit          = 50;
+        $counter        = 0;
+        foreach ($this->getRepository()->getQueuedMessages($limit, $processStarted, $channel, $channelId) as $queue) {
+            $counter += $this->processMessageQueue($queue);
+            $event   = $queue->getEvent();
+            if ($event) {
+                $this->em->detach($event);
+            }
+            $this->em->detach($queue);
+        }
+        return $counter;
+    }
+    public function processMessageQueue($queue): int
+    {
+        if (!is_array($queue)) {
+            if (!$queue instanceof MessageQueue) {
+                throw new \InvalidArgumentException('$queue must be an instance of '.MessageQueue::class);
+            }
+            $queue = [$queue->getId() => $queue];
+        }
+        $counter   = 0;
+        $contacts  = [];
+        $byChannel = [];
+        /** @var MessageQueue $message */
+        foreach ($queue as $message) {
+            if ($message->getLead()) {
+                $contacts[$message->getId()] = $message->getLead()->getId();
+            }
+        }
+        if (!empty($contacts)) {
+            $contactData = $this->leadModel->getRepository()->getContacts($contacts);
+            foreach ($contacts as $messageId => $contactId) {
+                $queue[$messageId]->getLead()->setFields($contactData[$contactId]);
+            }
+        }
+        foreach ($queue as $key => $message) {
+            if (MessageQueue::STATUS_SENT == $message->getStatus()) {
+                unset($queue[$key]);
+                continue;
+            }
+            $messageChannel   = $message->getChannel();
+            $messageChannelId = $message->getChannelId();
+            if (!$messageChannelId) {
+                $messageChannelId = 0;
+            }
+            if (!isset($byChannel[$messageChannel])) {
+                $byChannel[$messageChannel] = [];
+            }
+            if (!isset($byChannel[$messageChannel][$messageChannelId])) {
+                $byChannel[$messageChannel][$messageChannelId] = [];
+            }
+            $byChannel[$messageChannel][$messageChannelId][] = $message;
+        }
+        foreach ($byChannel as $messageChannel => $channelMessages) {
+            foreach ($channelMessages as $messageChannelId => $messages) {
+                $event  = new MessageQueueBatchProcessEvent($messages, $messageChannel, $messageChannelId);
+                $ignore = null;
+                $this->dispatchEvent('process_batch_message_queue', $ignore, false, $event);
+            }
+        }
+        unset($byChannel);
+        foreach ($queue as $message) {
+            if (!$message->isProcessed()) {
+                $event = new MessageQueueProcessEvent($message);
+                $this->dispatchEvent('process_message_queue', $message, false, $event);
+            }
+            if ($message->isSuccess()) {
+                ++$counter;
+                $message->setSuccess();
+                $message->setLastAttempt(new \DateTime());
+                $message->setDateSent(new \DateTime());
+                $message->setStatus(MessageQueue::STATUS_SENT);
+            } elseif ($message->isFailed()) {
+                $this->reschedule($message, new \DateInterval(self::DEFAULT_RESCHEDULE_INTERVAL));
+            } // otherwise assume the listener did something such as rescheduling the message
+        }
+        $this->saveEntities($queue);
+        return $counter;
+    }
+    /**
+     * @param bool $persist
+     */
+    public function reschedule($message, \DateInterval $rescheduleInterval, $leadId = null, $channel = null, $channelId = null, $persist = false): void
+    {
+        if (!$message instanceof MessageQueue && $leadId && $channel && $channelId) {
+            $message = $this->getRepository()->findMessage($channel, $channelId, $leadId);
+            $persist = true;
+        }
+        if (!$message) {
+            return;
+        }
+        $message->setAttempts($message->getAttempts() + 1);
+        $message->setLastAttempt(new \DateTime());
+        $rescheduleTo = clone $message->getScheduledDate();
+        $rescheduleTo->add($rescheduleInterval);
+        $message->setScheduledDate($rescheduleTo);
+        $message->setStatus(MessageQueue::STATUS_RESCHEDULED);
+        if ($persist) {
+            $this->saveEntity($message);
+        }
+        $message->setProcessed();
+    }
+    /**
+     * @deprecated to be removed in 3.0; use reschedule method instead
+     *
+     * @param string $rescheduleInterval
+     * @param bool   $persist
+     */
+    public function rescheduleMessage($message, $rescheduleInterval = null, $leadId = null, $channel = null, $channelId = null, $persist = false): void
+    {
+        $rescheduleInterval = null == $rescheduleInterval ? self::DEFAULT_RESCHEDULE_INTERVAL : ('P'.$rescheduleInterval);
+        $this->reschedule($message, new \DateInterval($rescheduleInterval), $leadId, $channel, $channelId, $persist);
+    }
+    /**
+     * @param array $channelIds
+     */
+    public function getQueuedChannelCount($channel, $channelIds = []): int
+    {
+        return $this->getRepository()->getQueuedChannelCount($channel, $channelIds);
+    }
+    /**
+     * @param ?object $entity
+     *
+     * @throws \Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException
+     */
+    protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
+    {
+        switch ($action) {
+            case 'process_message_queue':
+                $name = ChannelEvents::PROCESS_MESSAGE_QUEUE;
+                break;
+            case 'process_batch_message_queue':
+                $name = ChannelEvents::PROCESS_MESSAGE_QUEUE_BATCH;
+                break;
+            case 'post_save':
+                $name = ChannelEvents::MESSAGE_QUEUED;
+                break;
+            default:
+                return null;
+        }
+        if ($this->dispatcher->hasListeners($name)) {
+            if (empty($event)) {
+                $event = new MessageQueueEvent($entity, $isNew);
+                $event->setEntityManager($this->em);
+            }
+            $this->dispatcher->dispatch($event, $name);
+            return $event;
+        } else {
+            return null;
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/PreferenceBuilder/ChannelPreferences.php
@@ -0,0 +1,66 @@
+<?php
+namespace Mautic\ChannelBundle\PreferenceBuilder;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+class ChannelPreferences
+{
+    /**
+     * @var ArrayCollection[]
+     */
+    private array $organizedByPriority = [];
+    public function __construct(
+        private Event $event,
+    ) {
+    }
+    /**
+     * @param int $priority
+     *
+     * @return $this
+     */
+    public function addPriority($priority)
+    {
+        $priority = (int) $priority;
+        if (!isset($this->organizedByPriority[$priority])) {
+            $this->organizedByPriority[$priority] = new ArrayCollection();
+        }
+        return $this;
+    }
+    /**
+     * @param int $priority
+     *
+     * @return $this
+     */
+    public function addLog(LeadEventLog $log, $priority)
+    {
+        $priority = (int) $priority;
+        $this->addPriority($priority);
+        $log = clone $log;
+        $log->setEvent($this->event);
+        $this->organizedByPriority[$priority]->set($log->getId(), $log);
+        return $this;
+    }
+    /**
+     * Removes a log from all prioritized groups.
+     *
+     * @return $this
+     */
+    public function removeLog(LeadEventLog $log)
+    {
+        foreach ($this->organizedByPriority as $logs) {
+            /** @var ArrayCollection<int, LeadEventLog> $logs */
+            $logs->remove($log->getId());
+        }
+        return $this;
+    }
+    /**
+     * @param int $priority
+     *
+     * @return ArrayCollection|LeadEventLog[]
+     */
+    public function getLogsByPriority($priority)
+    {
+        $priority = (int) $priority;
+        return $this->organizedByPriority[$priority] ?? new ArrayCollection();
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/PreferenceBuilder/PreferenceBuilder.php
@@ -0,0 +1,87 @@
+<?php
+namespace Mautic\ChannelBundle\PreferenceBuilder;
+use Doctrine\Common\Collections\ArrayCollection;
+use Mautic\CampaignBundle\Entity\Event;
+use Mautic\CampaignBundle\Entity\LeadEventLog;
+use Mautic\LeadBundle\Entity\DoNotContact;
+use Psr\Log\LoggerInterface;
+class PreferenceBuilder
+{
+    /**
+     * @var ChannelPreferences[]
+     */
+    private array $channels = [];
+    public function __construct(
+        ArrayCollection $logs,
+        private Event $event,
+        array $channels,
+        private LoggerInterface $logger,
+    ) {
+        $this->buildRules($logs, $channels);
+    }
+    /**
+     * @return ChannelPreferences[]
+     */
+    public function getChannelPreferences()
+    {
+        return $this->channels;
+    }
+    public function removeLogFromAllChannels(LeadEventLog $log): void
+    {
+        foreach ($this->channels as $channelPreferences) {
+            $channelPreferences->removeLog($log);
+        }
+    }
+    /**
+     * @param string $channel
+     * @param int    $priority
+     */
+    private function addChannelRule($channel, array $rule, LeadEventLog $log, $priority): void
+    {
+        $channelPreferences = $this->getChannelPreferenceObject($channel, $priority);
+        if (DoNotContact::IS_CONTACTABLE !== $rule['dnc']) {
+            $log->appendToMetadata(
+                [
+                    $channel => [
+                        'failed' => 1,
+                        'dnc'    => $rule['dnc'],
+                    ],
+                ]
+            );
+            return;
+        }
+        $this->logger->debug("MARKETING MESSAGE: Set $channel as priority $priority for contact ID #".$log->getLead()->getId());
+        $channelPreferences->addLog($log, $priority);
+    }
+    /**
+     * @param string $channel
+     *
+     * @return ChannelPreferences
+     */
+    private function getChannelPreferenceObject($channel, $priority)
+    {
+        if (!isset($this->channels[$channel])) {
+            $this->channels[$channel] = new ChannelPreferences($this->event);
+        }
+        $this->channels[$channel]->addPriority($priority);
+        return $this->channels[$channel];
+    }
+    private function buildRules(ArrayCollection $logs, array $channels): void
+    {
+        /** @var LeadEventLog $log */
+        foreach ($logs as $log) {
+            $channelRules = $log->getLead()->getChannelRules();
+            $allChannels  = $channels;
+            $priority     = 1;
+            foreach ($channelRules as $channel => $rule) {
+                $this->addChannelRule($channel, $rule, $log, $priority);
+                ++$priority;
+                unset($allChannels[$channel]);
+            }
+            foreach ($allChannels as $channel => $messageSettings) {
+                $this->addChannelRule($channel, ['dnc' => DoNotContact::IS_CONTACTABLE], $log, $priority);
+                ++$priority;
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ChannelBundle/Twig/ChannelExtension.php
@@ -0,0 +1,38 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ChannelBundle\Twig;
+use Mautic\ChannelBundle\Helper\ChannelListHelper;
+use Mautic\LeadBundle\Exception\UnknownDncReasonException;
+use Mautic\LeadBundle\Twig\Helper\DncReasonHelper;
+use Twig\Extension\AbstractExtension;
+use Twig\TwigFunction;
+class ChannelExtension extends AbstractExtension
+{
+    public function __construct(
+        private DncReasonHelper $dncReasonHelper,
+        private ChannelListHelper $channelListHelper,
+    ) {
+    }
+    /**
+     * @return TwigFunction[]
+     */
+    public function getFunctions(): array
+    {
+        return [
+            new TwigFunction('getChannelDncText', [$this, 'getChannelDncText']),
+            new TwigFunction('getChannelLabel', [$this, 'getChannelLabel']),
+        ];
+    }
+    public function getChannelDncText(int $reasonId): string
+    {
+        try {
+            return $this->dncReasonHelper->toText($reasonId);
+        } catch (UnknownDncReasonException $e) {
+            return $e->getMessage();
+        }
+    }
+    public function getChannelLabel(string $channel): string
+    {
+        return $this->channelListHelper->getChannelLabel($channel);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Assets/js/config.js
@@ -0,0 +1,89 @@
+Mautic.removeConfigValue = function(action, el) {
+    Mautic.executeAction(action, function(response) {
+    	if (response.success) {
+            mQuery(el).parent().addClass('hide');
+        }
+	});
+};
+/**
+ *
+ * @returns string|false
+ */
+Mautic.parseQuery = function (query) {
+    var vars = query.split('&');
+    var queryString = {};
+    for (var i = 0; i < vars.length; i++) {
+        var pair = vars[i].split('=');
+        var key = decodeURIComponent(pair[0]);
+        var value = decodeURIComponent(pair[1]);
+        if (typeof queryString[key] === 'undefined') {
+            queryString[key] = decodeURIComponent(value);
+        } else if (typeof queryString[key] === 'string') {
+            var arr = [queryString[key], decodeURIComponent(value)];
+            queryString[key] = arr;
+        } else {
+            queryString[key].push(decodeURIComponent(value));
+        }
+    }
+    return queryString;
+}
+Mautic.parseUrlHashParameter = function(url) {
+    var url = url.split('#');
+    if ('undefined' != typeof url[1]) {
+        return url[1];
+    }
+    return false;
+}
+Mautic.observeConfigTabs = function() {
+    if (!mQuery('#config_coreconfig_last_shown_tab').length) {
+        return;
+    }
+    var parameters = Mautic.parseQuery(window.location.search.substr(1));
+    if ('undefined' != typeof parameters['tab']) {
+        mQuery('#config_coreconfig_last_shown_tab').val(parameters['tab']);
+        mQuery('a[data-toggle="tab"]').each(function (i, tab) {
+            if (mQuery(tab).attr('href') == ('#' + parameters['tab'])) {
+                mQuery(tab).tab('show');
+            }
+        });
+    }
+    mQuery('a[data-toggle="tab"]').on('show.bs.tab', function (e) {
+        var tab = Mautic.parseUrlHashParameter(e.target.href);
+        if (tab) {
+            mQuery('#config_coreconfig_last_shown_tab').val(tab);
+        }
+    });
+}
+Mautic.resetEmailsToNotification = function(obj) {
+    const send_to_owner = obj.value;
+    if (parseInt(send_to_owner, 10) === 1)
+    {
+        mQuery(obj).closest('.panel-body').find('.notification_email_addresses').val('');
+    }
+};
+Mautic.configDsnTestExecute = function(element, action, key) {
+    const $button = mQuery(element),
+        $container = $button.closest('.config-dsn-container');
+    $container.find('.ri-loader-3-line').removeClass('hide');
+    Mautic.ajaxActionRequest(action, {key: key}, function(response) {
+        const theClass = (response.success) ? 'has-success' : 'has-error',
+            theMessage = response.message;
+        $container.find('.config-dsn-test-container').removeClass('has-success has-error').addClass(theClass);
+        $container.find('.help-block .status-msg').html(theMessage);
+        $container.find('.ri-loader-3-line').addClass('hide');
+    });
+};
+Mautic.configDsnTestDisable = function(element) {
+    const $container = mQuery(element).closest('.config-dsn-container');
+    $container.find('.help-block .status-msg').html('');
+    $container.find('.help-block .save-config-msg').removeClass('hide');
+    $container.find('.config-dsn-test-button').prop('disabled', true).addClass('disabled');
+};
+Mautic.showAnonymizeWarningMessage = function(anonymize_ip) {
+    if (mQuery(anonymize_ip).siblings('.toggle__label').attr('aria-checked') === 'true') {
+        mQuery('.anonymize_ip_address').addClass('hide');
+    } else {
+        mQuery('.anonymize_ip_address').removeClass('hide');
+    }
+};
+mQuery(Mautic.observeConfigTabs);

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Controller/ConfigController.php
@@ -0,0 +1,237 @@
+<?php
+namespace Mautic\ConfigBundle\Controller;
+use Mautic\ConfigBundle\ConfigEvents;
+use Mautic\ConfigBundle\Event\ConfigBuilderEvent;
+use Mautic\ConfigBundle\Event\ConfigEvent;
+use Mautic\ConfigBundle\Form\Type\ConfigType;
+use Mautic\ConfigBundle\Mapper\ConfigMapper;
+use Mautic\CoreBundle\Configurator\Configurator;
+use Mautic\CoreBundle\Controller\FormController;
+use Mautic\CoreBundle\Helper\BundleHelper;
+use Mautic\CoreBundle\Helper\CacheHelper;
+use Mautic\CoreBundle\Helper\EncryptionHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Mautic\UserBundle\Entity\User;
+use Symfony\Component\Form\FormError;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
+class ConfigController extends FormController
+{
+    /**
+     * Controller action for editing the application configuration.
+     *
+     * @return JsonResponse|Response
+     */
+    public function editAction(Request $request, BundleHelper $bundleHelper, Configurator $configurator, CacheHelper $cacheHelper, PathsHelper $pathsHelper, ConfigMapper $configMapper, TokenStorageInterface $tokenStorage)
+    {
+        if (!$this->user->isAdmin()) {
+            return $this->accessDenied();
+        }
+        $event      = new ConfigBuilderEvent($bundleHelper);
+        $dispatcher = $this->dispatcher;
+        $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
+        $fileFields = $event->getFileFields();
+        $formThemes = $event->getFormThemes();
+        $formConfigs = $configMapper->bindFormConfigsWithRealValues($event->getForms());
+        $this->mergeParamsWithLocal($formConfigs, $pathsHelper);
+        $action = $this->generateUrl('mautic_config_action', ['objectAction' => 'edit']);
+        $form   = $this->formFactory->create(
+            ConfigType::class,
+            $formConfigs,
+            [
+                'action'     => $action,
+                'fileFields' => $fileFields,
+            ]
+        );
+        $originalNormData = $form->getNormData();
+        $isWritable = $configurator->isFileWritable();
+        $openTab    = null;
+        if ('POST' == $request->getMethod()) {
+            if (!$cancelled = $this->isFormCancelled($form)) {
+                $isValid = false;
+                if ($isWritable && $isValid = $this->isFormValid($form)) {
+                    $post     = $request->request;
+                    /** @var mixed[] $formData */
+                    $formData = $form->getData();
+                    $configEvent = new ConfigEvent($formData, $post);
+                    $configEvent
+                        ->setOriginalNormData($originalNormData)
+                        ->setNormData($form->getNormData());
+                    $dispatcher->dispatch($configEvent, ConfigEvents::CONFIG_PRE_SAVE);
+                    $formValues = $configEvent->getConfig();
+                    $errors      = $configEvent->getErrors();
+                    $fieldErrors = $configEvent->getFieldErrors();
+                    if ($errors || $fieldErrors) {
+                        foreach ($errors as $message => $messageVars) {
+                            $form->addError(
+                                new FormError($this->translator->trans($message, $messageVars, 'validators'))
+                            );
+                        }
+                        foreach ($fieldErrors as $key => $fields) {
+                            foreach ($fields as $field => $fieldError) {
+                                $form[$key][$field]->addError(
+                                    new FormError($this->translator->trans($fieldError[0], $fieldError[1], 'validators'))
+                                );
+                            }
+                        }
+                        $isValid = false;
+                    } else {
+                        $unsetIfEmpty = $configEvent->getPreservedFields();
+                        $unsetIfEmpty = array_merge($unsetIfEmpty, $fileFields);
+                        foreach ($formValues as $object) {
+                            $checkThese = array_intersect(array_keys($object), $unsetIfEmpty);
+                            foreach ($checkThese as $checkMe) {
+                                if (empty($object[$checkMe])) {
+                                    unset($object[$checkMe]);
+                                }
+                            }
+                            $configurator->mergeParameters($object);
+                        }
+                        try {
+                            $params = $configurator->getParameters();
+                            if (empty($params['secret_key'])) {
+                                $configurator->mergeParameters(['secret_key' => EncryptionHelper::generateKey()]);
+                            }
+                            $configurator->write();
+                            $dispatcher->dispatch($configEvent, ConfigEvents::CONFIG_POST_SAVE);
+                            $this->addFlashMessage('mautic.config.config.notice.updated');
+                            $cacheHelper->refreshConfig();
+                            if (!empty($formData['coreconfig']['last_shown_tab'])) {
+                                $openTab = $formData['coreconfig']['last_shown_tab'];
+                            }
+                        } catch (\RuntimeException $exception) {
+                            $this->addFlashMessage('mautic.config.config.error.not.updated', ['%exception%' => $exception->getMessage()], 'error');
+                        }
+                        $this->setLocale($request, $tokenStorage, $params);
+                    }
+                } elseif (!$isWritable) {
+                    $form->addError(
+                        new FormError(
+                            $this->translator->trans('mautic.config.notwritable')
+                        )
+                    );
+                }
+            }
+            if ($cancelled || $isValid) {
+                if (!$cancelled && $this->isFormApplied($form)) {
+                    $redirectParameters = ['objectAction' => 'edit'];
+                    if ($openTab) {
+                        $redirectParameters['tab'] = $openTab;
+                    }
+                    return $this->delegateRedirect($this->generateUrl('mautic_config_action', $redirectParameters));
+                } else {
+                    return $this->delegateRedirect($this->generateUrl('mautic_dashboard_index'));
+                }
+            }
+        }
+        $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
+        return $this->delegateView(
+            [
+                'viewParameters' => [
+                    'tmpl'        => $tmpl,
+                    'security'    => $this->security,
+                    'form'        => $form->createView(),
+                    'formThemes'  => $formThemes,
+                    'formConfigs' => $formConfigs,
+                    'isWritable'  => $isWritable,
+                ],
+                'contentTemplate' => '@MauticConfig/Config/form.html.twig',
+                'passthroughVars' => [
+                    'activeLink'    => '#mautic_config_index',
+                    'mauticContent' => 'config',
+                    'route'         => $this->generateUrl('mautic_config_action', ['objectAction' => 'edit']),
+                ],
+            ]
+        );
+    }
+    /**
+     * @return array|JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function downloadAction(Request $request, BundleHelper $bundleHelper, $objectId)
+    {
+        if (!$this->user->isAdmin()) {
+            return $this->accessDenied();
+        }
+        $event      = new ConfigBuilderEvent($bundleHelper);
+        $dispatcher = $this->dispatcher;
+        $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
+        $fileFields = $event->getFileFields();
+        if (!in_array($objectId, $fileFields)) {
+            return $this->accessDenied();
+        }
+        $content  = $this->coreParametersHelper->get($objectId);
+        $filename = $request->get('filename', $objectId);
+        if ($decoded = base64_decode($content)) {
+            $response = new Response($decoded);
+            $response->headers->set('Content-Type', 'application/force-download');
+            $response->headers->set('Content-Type', 'application/octet-stream');
+            $response->headers->set('Content-Disposition', 'attachment; filename="'.$filename);
+            $response->headers->set('Expires', '0');
+            $response->headers->set('Cache-Control', 'must-revalidate');
+            $response->headers->set('Pragma', 'public');
+            return $response;
+        }
+        return $this->notFound();
+    }
+    /**
+     * @return array|JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
+     */
+    public function removeAction(BundleHelper $bundleHelper, Configurator $configurator, CacheHelper $cacheHelper, $objectId)
+    {
+        if (!$this->user->isAdmin()) {
+            return $this->accessDenied();
+        }
+        $success    = 0;
+        $event      = new ConfigBuilderEvent($bundleHelper);
+        $dispatcher = $this->dispatcher;
+        $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
+        $fileFields = $event->getFileFields();
+        if (in_array($objectId, $fileFields)) {
+            $configurator->mergeParameters([$objectId => null]);
+            try {
+                $configurator->write();
+                $cacheHelper->refreshConfig();
+                $success = 1;
+            } catch (\Exception) {
+            }
+        }
+        return new JsonResponse(['success' => $success]);
+    }
+    /**
+     * Merges default parameters from each subscribed bundle with the local (real) params.
+     */
+    private function mergeParamsWithLocal(array &$forms, PathsHelper $pathsHelper): void
+    {
+        $doNotChange     = $this->coreParametersHelper->get('mautic.security.restrictedConfigFields');
+        $localConfigFile = $pathsHelper->getLocalConfigurationFile();
+        $parameters = [];
+        include $localConfigFile;
+        /** @var mixed[] $parameters */
+        $localParams = $parameters;
+        foreach ($forms as &$form) {
+            foreach ($form['parameters'] as $key => $value) {
+                if (in_array($key, $doNotChange)) {
+                    unset($form['parameters'][$key]);
+                } elseif (array_key_exists($key, $localParams)) {// @phpstan-ignore function.impossibleType (Not sure what this is about)
+                    $paramValue               = $localParams[$key];
+                    $form['parameters'][$key] = $paramValue;
+                }
+            }
+        }
+    }
+    /**
+     * @param array<string, string> $params
+     */
+    private function setLocale(Request $request, TokenStorageInterface $tokenStorage, array $params): void
+    {
+        $me = $tokenStorage->getToken()->getUser();
+        assert($me instanceof User);
+        $locale = $me->getLocale();
+        if (empty($locale)) {
+            $locale = $params['locale'] ?? $this->coreParametersHelper->get('locale');
+        }
+        $request->getSession()->set('_locale', $locale);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Controller/SysinfoController.php
@@ -0,0 +1,60 @@
+<?php
+namespace Mautic\ConfigBundle\Controller;
+use Doctrine\Persistence\ManagerRegistry;
+use Mautic\ConfigBundle\Model\SysinfoModel;
+use Mautic\CoreBundle\Controller\FormController;
+use Mautic\CoreBundle\Factory\ModelFactory;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\UserHelper;
+use Mautic\CoreBundle\Security\Permissions\CorePermissions;
+use Mautic\CoreBundle\Service\FlashBag;
+use Mautic\CoreBundle\Translation\Translator;
+use Mautic\FormBundle\Helper\FormFieldHelper;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+use Symfony\Component\Form\FormFactoryInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\RequestStack;
+class SysinfoController extends FormController
+{
+    public function __construct(
+        FormFactoryInterface $formFactory,
+        FormFieldHelper $fieldHelper,
+        private SysinfoModel $sysinfoModel,
+        ManagerRegistry $doctrine,
+        ModelFactory $modelFactory,
+        UserHelper $userHelper,
+        CoreParametersHelper $coreParametersHelper,
+        EventDispatcherInterface $dispatcher,
+        Translator $translator,
+        FlashBag $flashBag,
+        RequestStack $requestStack,
+        CorePermissions $security,
+    ) {
+        parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
+    }
+    /**
+     * @return JsonResponse|\Symfony\Component\HttpFoundation\Response
+     */
+    public function indexAction()
+    {
+        if (!$this->user->isAdmin() || $this->coreParametersHelper->get('sysinfo_disabled')) {
+            return $this->accessDenied();
+        }
+        return $this->delegateView([
+            'viewParameters' => [
+                'phpInfo'         => $this->sysinfoModel->getPhpInfo(),
+                'requirements'    => $this->sysinfoModel->getRequirements(),
+                'recommendations' => $this->sysinfoModel->getRecommendations(),
+                'folders'         => $this->sysinfoModel->getFolders(),
+                'log'             => $this->sysinfoModel->getLogTail(200),
+                'dbInfo'          => $this->sysinfoModel->getDbInfo(),
+            ],
+            'contentTemplate' => '@MauticConfig/Sysinfo/index.html.twig',
+            'passthroughVars' => [
+                'activeLink'    => '#mautic_sysinfo_index',
+                'mauticContent' => 'sysinfo',
+                'route'         => $this->generateUrl('mautic_sysinfo_index'),
+            ],
+        ]);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Event/ConfigBuilderEvent.php
@@ -0,0 +1,102 @@
+<?php
+namespace Mautic\ConfigBundle\Event;
+use Mautic\CoreBundle\Helper\BundleHelper;
+use Symfony\Contracts\EventDispatcher\Event;
+class ConfigBuilderEvent extends Event
+{
+    /**
+     * @var mixed[]
+     */
+    private array $forms = [];
+    /**
+     * @var string[]
+     */
+    private array $formThemes = [
+        '@MauticConfig/FormTheme/_config_file_row.html.twig',
+        '@MauticConfig/FormTheme/dsn_row.html.twig',
+    ];
+    /**
+     * @var string[]
+     */
+    protected array $encodedFields = [];
+    public function __construct(
+        private BundleHelper $bundleHelper,
+    ) {
+    }
+    /**
+     * Set new form to the forms array.
+     *
+     * @return $this
+     */
+    public function addForm(array $form)
+    {
+        if (isset($form['formTheme'])) {
+            $this->formThemes[] = $form['formTheme'];
+        }
+        $this->forms[$form['formAlias']] = $form;
+        return $this;
+    }
+    /**
+     * Remove a form to the forms array.
+     *
+     * @param string $formAlias
+     */
+    public function removeForm($formAlias): bool
+    {
+        if (isset($this->forms[$formAlias])) {
+            unset($this->forms[$formAlias]);
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Returns the forms array.
+     *
+     * @return array
+     */
+    public function getForms()
+    {
+        return $this->forms;
+    }
+    /**
+     * Returns the formThemes array.
+     *
+     * @return array
+     */
+    public function getFormThemes()
+    {
+        return $this->formThemes;
+    }
+    /**
+     * Get default parameters from config defined in bundles.
+     *
+     * @return array
+     */
+    public function getParametersFromConfig($bundle)
+    {
+        static $allBundles;
+        if (empty($allBundles)) {
+            $allBundles = $this->bundleHelper->getMauticBundles(true);
+        }
+        if (isset($allBundles[$bundle]) && $allBundles[$bundle]['config']['parameters']) {
+            return $allBundles[$bundle]['config']['parameters'];
+        } else {
+            return [];
+        }
+    }
+    /**
+     * @return $this
+     */
+    public function addFileFields($fields)
+    {
+        $this->encodedFields = array_merge($this->encodedFields, (array) $fields);
+        return $this;
+    }
+    /**
+     * @return array
+     */
+    public function getFileFields()
+    {
+        return $this->encodedFields;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Event/ConfigEvent.php
@@ -0,0 +1,173 @@
+<?php
+namespace Mautic\ConfigBundle\Event;
+use Mautic\CoreBundle\Event\CommonEvent;
+use Symfony\Component\HttpFoundation\File\UploadedFile;
+use Symfony\Component\HttpFoundation\ParameterBag;
+class ConfigEvent extends CommonEvent
+{
+    /**
+     * @var mixed[]
+     */
+    private array $preserve = [];
+    /**
+     * @var mixed[]
+     */
+    private array $errors = [];
+    /**
+     * @var mixed[]
+     */
+    private array $fieldErrors = [];
+    /**
+     * Data got from build form before update.
+     */
+    private ?array $originalNormData = null;
+    /**
+     * Data got from build form after update.
+     *
+     * @var array
+     */
+    private $normData;
+    /**
+     * @param mixed[]|null $config
+     */
+    public function __construct(
+        private ?array $config,
+        private ParameterBag $post,
+    ) {
+    }
+    /**
+     * Returns the config array.
+     *
+     * @param string $key
+     *
+     * @return array
+     */
+    public function getConfig($key = null)
+    {
+        if ($key) {
+            return $this->config[$key] ?? [];
+        }
+        return $this->config;
+    }
+    /**
+     * Sets the config array.
+     *
+     * @param string $key
+     */
+    public function setConfig(array $config, $key = null): void
+    {
+        if ($key) {
+            $this->config[$key] = $config;
+        } else {
+            $this->config = $config;
+        }
+    }
+    public function getPost(): ParameterBag
+    {
+        return $this->post;
+    }
+    /**
+     * Set fields such as passwords that will not overwrite existing values
+     * if the current is empty.
+     *
+     * @param array|string $fields
+     */
+    public function unsetIfEmpty($fields): void
+    {
+        if (!is_array($fields)) {
+            $fields = [$fields];
+        }
+        $this->preserve = array_merge($this->preserve, $fields);
+    }
+    /**
+     * Return array of fields to unset if empty so that existing values are not
+     * overwritten if empty.
+     *
+     * @return array
+     */
+    public function getPreservedFields()
+    {
+        return $this->preserve;
+    }
+    /**
+     * Set error message.
+     *
+     * @param string      $message     (untranslated)
+     * @param array       $messageVars for translation
+     * @param string|null $key
+     * @param string|null $field
+     *
+     * @return ConfigEvent
+     */
+    public function setError($message, $messageVars = [], $key = null, $field = null)
+    {
+        if (!empty($key) && !empty($field)) {
+            if (!isset($this->errors[$key])) {
+                $this->fieldErrors[$key] = [];
+            }
+            $this->fieldErrors[$key][$field] = [
+                $message,
+                $messageVars,
+            ];
+            return $this;
+        }
+        $this->errors[$message] = $messageVars;
+        return $this;
+    }
+    /**
+     * Get error messages.
+     *
+     * @return array
+     */
+    public function getErrors()
+    {
+        return $this->errors;
+    }
+    /**
+     * @return array
+     */
+    public function getFieldErrors()
+    {
+        return $this->fieldErrors;
+    }
+    public function getFileContent(UploadedFile $file): string
+    {
+        $tmpFile = $file->getRealPath();
+        $content = trim(file_get_contents($tmpFile));
+        @unlink($tmpFile);
+        return $content;
+    }
+    public function encodeFileContents($content): string
+    {
+        return base64_encode($content);
+    }
+    /**
+     * @return array
+     */
+    public function getOriginalNormData()
+    {
+        return $this->originalNormData;
+    }
+    /**
+     * @return ConfigEvent
+     */
+    public function setOriginalNormData(array $normData)
+    {
+        $this->originalNormData = $normData;
+        return $this;
+    }
+    /**
+     * @return array
+     */
+    public function getNormData()
+    {
+        return $this->normData;
+    }
+    /**
+     * @param array $normData
+     */
+    public function setNormData($normData): void
+    {
+        $this->normData = $normData;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/EventListener/ConfigSubscriber.php
@@ -0,0 +1,43 @@
+<?php
+namespace Mautic\ConfigBundle\EventListener;
+use Mautic\ConfigBundle\ConfigEvents;
+use Mautic\ConfigBundle\Event\ConfigEvent;
+use Mautic\ConfigBundle\Service\ConfigChangeLogger;
+use Mautic\CoreBundle\Entity\AuditLogRepository;
+use Mautic\CoreBundle\Entity\IpAddressRepository;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+class ConfigSubscriber implements EventSubscriberInterface
+{
+    public function __construct(
+        private ConfigChangeLogger $configChangeLogger,
+        private IpAddressRepository $ipAddressRepository,
+        private CoreParametersHelper $coreParametersHelper,
+        private AuditLogRepository $auditLogRepository,
+    ) {
+    }
+    public static function getSubscribedEvents(): array
+    {
+        return [
+            ConfigEvents::CONFIG_POST_SAVE => ['onConfigPostSave', 0],
+        ];
+    }
+    public function onConfigPostSave(ConfigEvent $event): void
+    {
+        if ($originalNormData = $event->getOriginalNormData()) {
+            $normData = $event->getNormData();
+            $this->configChangeLogger
+                ->setOriginalNormData($originalNormData)
+                ->log($normData);
+            if (!isset($originalNormData['trackingconfig']) && !isset($normData['trackingconfig'])) {
+                return;
+            }
+            $oldAnonymizeIp = $originalNormData['trackingconfig']['parameters']['anonymize_ip'];
+            $newAnonymizeIp = $normData['trackingconfig']['anonymize_ip'];
+            if ($oldAnonymizeIp !== $newAnonymizeIp && $newAnonymizeIp && !$this->coreParametersHelper->get('anonymize_ip_address_in_background', false)) {
+                $this->ipAddressRepository->anonymizeAllIpAddress();
+                $this->auditLogRepository->anonymizeAllIpAddress();
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/DataTransformer/DsnTransformer.php
@@ -0,0 +1,66 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ConfigBundle\Form\DataTransformer;
+use Mautic\ConfigBundle\Form\Type\EscapeTransformer;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\Dsn\Dsn;
+use Symfony\Component\Form\DataTransformerInterface;
+/**
+ * @implements DataTransformerInterface<string, array>
+ */
+class DsnTransformer implements DataTransformerInterface
+{
+    private const PASSWORD_MASK = '';
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+        private EscapeTransformer $escapeTransformer,
+        private string $configKey,
+        private bool $allowEmpty,
+    ) {
+    }
+    /**
+     * @return array<string, mixed>
+     */
+    public function transform($value): array
+    {
+        $value = $this->escapeTransformer->transform((string) $value);
+        try {
+            $dsn = Dsn::fromString($value);
+        } catch (\InvalidArgumentException) {
+            return [];
+        }
+        return [
+            'scheme'   => $dsn->getScheme(),
+            'host'     => $dsn->getHost(),
+            'user'     => $dsn->getUser(),
+            'password' => $dsn->getPassword() ? self::PASSWORD_MASK : null,
+            'port'     => $dsn->getPort(),
+            'path'     => $dsn->getPath(),
+            'options'  => $dsn->getOptions(),
+        ];
+    }
+    /**
+     * @param array<string, mixed> $value
+     */
+    public function reverseTransform($value): string
+    {
+        if ($this->allowEmpty && !array_filter($value)) {
+            return '';
+        }
+        $value = $this->escapeTransformer->transform($value);
+        $dsn = new Dsn(
+            (string) $value['scheme'],
+            (string) $value['host'],
+            $value['user'],
+            $value['password'],
+            $value['port'] ? (int) $value['port'] : null,
+            $value['path'],
+            $value['options'],
+        );
+        if (self::PASSWORD_MASK === $dsn->getPassword()) {
+            $previousDsn = Dsn::fromString($this->coreParametersHelper->get($this->configKey));
+            $dsn         = $dsn->setPassword($previousDsn->getPassword());
+        }
+        return $this->escapeTransformer->reverseTransform((string) $dsn);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/DataTransformer/DsnTransformerFactory.php
@@ -0,0 +1,17 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ConfigBundle\Form\DataTransformer;
+use Mautic\ConfigBundle\Form\Type\EscapeTransformer;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+class DsnTransformerFactory
+{
+    public function __construct(
+        private CoreParametersHelper $coreParametersHelper,
+        private EscapeTransformer $escapeTransformer,
+    ) {
+    }
+    public function create(string $configKey, bool $allowEmpty): DsnTransformer
+    {
+        return new DsnTransformer($this->coreParametersHelper, $this->escapeTransformer, $configKey, $allowEmpty);
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/Helper/RestrictionHelper.php
@@ -0,0 +1,71 @@
+<?php
+namespace Mautic\ConfigBundle\Form\Helper;
+use Mautic\ConfigBundle\Mapper\Helper\RestrictionHelper as FieldHelper;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class RestrictionHelper
+{
+    public const MODE_REMOVE = 'remove';
+    public const MODE_MASK   = 'mask';
+    /**
+     * @var string[]
+     */
+    private array $restrictedFields;
+    public function __construct(
+        private TranslatorInterface $translator,
+        array $restrictedFields,
+        private string $displayMode,
+    ) {
+        $this->restrictedFields = FieldHelper::prepareRestrictions($restrictedFields);
+    }
+    /**
+     * @param FormInterface<mixed> $childType
+     * @param FormInterface<mixed> $parentType
+     */
+    public function applyRestrictions(FormInterface $childType, FormInterface $parentType, array $restrictedFields = null): void
+    {
+        if (null === $restrictedFields) {
+            $restrictedFields = $this->restrictedFields;
+        }
+        $fieldName = $childType->getName();
+        if (array_key_exists($fieldName, $restrictedFields)) {
+            if (is_array($restrictedFields[$fieldName])) {
+                foreach ($childType as $grandchild) {
+                    $this->applyRestrictions($grandchild, $childType, $restrictedFields[$fieldName]);
+                }
+                return;
+            }
+            $this->restrictField($childType, $parentType);
+        }
+    }
+    /**
+     * @param FormInterface<mixed> $childType
+     * @param FormInterface<mixed> $parentType
+     */
+    private function restrictField(FormInterface $childType, FormInterface $parentType): void
+    {
+        switch ($this->displayMode) {
+            case self::MODE_MASK:
+                $parentType->add(
+                    $childType->getName(),
+                    $childType->getConfig()->getType()->getInnerType()::class,
+                    array_merge(
+                        $childType->getConfig()->getOptions(),
+                        [
+                            'required' => false,
+                            'mapped'   => false,
+                            'disabled' => true,
+                            'attr'     => array_merge($childType->getConfig()->getOptions()['attr'] ?? [], [
+                                'placeholder' => $this->translator->trans('mautic.config.restricted'),
+                                'readonly'    => true,
+                            ]),
+                        ]
+                    )
+                );
+                break;
+            case self::MODE_REMOVE:
+                $parentType->remove($childType->getName());
+                break;
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/Type/ConfigFileType.php
@@ -0,0 +1,14 @@
+<?php
+namespace Mautic\ConfigBundle\Form\Type;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\FileType;
+/**
+ * @extends AbstractType<mixed>
+ */
+class ConfigFileType extends AbstractType
+{
+    public function getParent(): ?string
+    {
+        return FileType::class;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/Type/ConfigType.php
@@ -0,0 +1,89 @@
+<?php
+namespace Mautic\ConfigBundle\Form\Type;
+use Mautic\ConfigBundle\Form\Helper\RestrictionHelper;
+use Mautic\CoreBundle\Form\Type\FormButtonsType;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Form\FormEvent;
+use Symfony\Component\Form\FormEvents;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<mixed>
+ */
+class ConfigType extends AbstractType
+{
+    public function __construct(
+        private RestrictionHelper $restrictionHelper,
+        private EscapeTransformer $escapeTransformer,
+    ) {
+    }
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        if (isset($options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime'])
+            && 3600 === $options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime']
+        ) {
+            $options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime'] = 60;
+        }
+        if (isset($options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime'])
+            && 1_209_600 === $options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime']
+        ) {
+            $options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime'] = 14;
+        }
+        foreach ($options['data'] as $config) {
+            if (isset($config['formAlias']) && !empty($config['parameters'])) {
+                $checkThese = array_intersect(array_keys($config['parameters']), $options['fileFields']);
+                foreach ($checkThese as $checkMe) {
+                    unset($config['parameters'][$checkMe]);
+                }
+                $builder->add(
+                    $config['formAlias'],
+                    $config['formType'],
+                    [
+                        'data' => $config['parameters'],
+                    ]
+                );
+                $this->addTransformers($builder->get($config['formAlias']));
+            }
+        }
+        $builder->addEventListener(
+            FormEvents::PRE_SET_DATA,
+            function (FormEvent $event): void {
+                $form = $event->getForm();
+                foreach ($form as $configForm) {
+                    foreach ($configForm as $child) {
+                        $this->restrictionHelper->applyRestrictions($child, $configForm);
+                    }
+                }
+            }
+        );
+        $builder->add(
+            'buttons',
+            FormButtonsType::class,
+            [
+                'apply_onclick' => 'Mautic.activateBackdrop()',
+                'save_onclick'  => 'Mautic.activateBackdrop()',
+            ]
+        );
+        if (!empty($options['action'])) {
+            $builder->setAction($options['action']);
+        }
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults(
+            [
+                'fileFields' => [],
+            ]
+        );
+    }
+    private function addTransformers(FormBuilderInterface $builder): void
+    {
+        if (0 === $builder->count()) {
+            $builder->addModelTransformer($this->escapeTransformer);
+            return;
+        }
+        foreach ($builder as $childBuilder) {
+            $this->addTransformers($childBuilder);
+        }
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Form/Type/DsnType.php
@@ -0,0 +1,156 @@
+<?php
+declare(strict_types=1);
+namespace Mautic\ConfigBundle\Form\Type;
+use Mautic\ConfigBundle\Form\DataTransformer\DsnTransformerFactory;
+use Mautic\CoreBundle\Form\Type\SortableListType;
+use Mautic\CoreBundle\Form\Type\StandAloneButtonType;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\Dsn\Dsn;
+use Symfony\Component\Form\AbstractType;
+use Symfony\Component\Form\Extension\Core\Type\NumberType;
+use Symfony\Component\Form\Extension\Core\Type\TextType;
+use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Form\FormInterface;
+use Symfony\Component\Form\FormView;
+use Symfony\Component\OptionsResolver\OptionsResolver;
+/**
+ * @extends AbstractType<array>
+ */
+class DsnType extends AbstractType
+{
+    public function __construct(
+        private DsnTransformerFactory $dsnTransformerFactory,
+        private CoreParametersHelper $coreParametersHelper,
+    ) {
+    }
+    /**
+     * @param FormBuilderInterface<array<mixed>|null> $builder
+     * @param array<string, mixed>                    $options
+     */
+    public function buildForm(FormBuilderInterface $builder, array $options): void
+    {
+        $name     = $builder->getName();
+        $onChange = 'Mautic.configDsnTestDisable(this)';
+        $attr     = [
+            'class'    => 'form-control',
+            'onchange' => $onChange,
+        ];
+        $builder->add(
+            'scheme',
+            TextType::class,
+            [
+                'label'    => 'mautic.config.dsn.scheme',
+                'required' => $options['required'],
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'host',
+            TextType::class,
+            [
+                'label'    => 'mautic.config.dsn.host',
+                'required' => false,
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'port',
+            NumberType::class,
+            [
+                'label'    => 'mautic.config.dsn.port',
+                'required' => false,
+                'html5'    => true,
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'user',
+            TextType::class,
+            [
+                'label'    => 'mautic.config.dsn.user',
+                'required' => false,
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'password',
+            TextType::class,
+            [
+                'label'    => 'mautic.config.dsn.password',
+                'required' => false,
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'path',
+            TextType::class,
+            [
+                'label'    => 'mautic.config.dsn.path',
+                'required' => false,
+                'attr'     => $attr,
+            ]
+        );
+        $builder->add(
+            'options',
+            SortableListType::class,
+            [
+                'required'        => false,
+                'label'           => 'mautic.config.dsn.options',
+                'attr'            => [
+                    'onchange' => $onChange,
+                ],
+                'option_required' => false,
+                'with_labels'     => true,
+                'key_value_pairs' => true,
+            ]
+        );
+        if ($options['test_button']['action'] && $this->getCurrentDsn($name)) {
+            $builder->add(
+                'test_button',
+                StandAloneButtonType::class,
+                [
+                    'label'    => $options['test_button']['label'],
+                    'required' => false,
+                    'attr'     => [
+                        'class'   => 'btn btn-tertiary btn-sm config-dsn-test-button',
+                        'onclick' => sprintf('Mautic.configDsnTestExecute(this, "%s", "%s")', $options['test_button']['action'], $name),
+                    ],
+                ]
+            );
+        }
+        $builder->addModelTransformer($this->dsnTransformerFactory->create($name, !$options['required']));
+    }
+    public function configureOptions(OptionsResolver $resolver): void
+    {
+        $resolver->setDefaults([
+            'label'         => false,
+            'error_mapping' => [
+                '.' => 'scheme',
+            ],
+            'test_button'  => [
+                'action'   => null,
+                'label'    => null,
+            ],
+        ]);
+    }
+    /**
+     * @phpstan-ignore-next-line
+     */
+    public function finishView(FormView $view, FormInterface $form, array $options): void
+    {
+        $view->vars['currentDsn'] = $this->getCurrentDsn($form->getName());
+    }
+    private function getCurrentDsn(string $name): ?Dsn
+    {
+        $dsn = (string) $this->coreParametersHelper->get($name);
+        try {
+            $dsn = Dsn::fromString($dsn);
+        } catch (\InvalidArgumentException) {
+            return null;
+        }
+        if ($dsn->getPassword()) {
+            $dsn = $dsn->setPassword('SECRET');
+        }
+        return $dsn;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Mapper/ConfigMapper.php
@@ -0,0 +1,52 @@
+<?php
+namespace Mautic\ConfigBundle\Mapper;
+use Mautic\ConfigBundle\Exception\BadFormConfigException;
+use Mautic\ConfigBundle\Mapper\Helper\ConfigHelper;
+use Mautic\ConfigBundle\Mapper\Helper\RestrictionHelper;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+class ConfigMapper
+{
+    /**
+     * @var mixed[]
+     */
+    private array $restrictedParameters;
+    public function __construct(
+        private CoreParametersHelper $parametersHelper,
+        array $restrictedParameters = [],
+    ) {
+        $this->restrictedParameters = RestrictionHelper::prepareRestrictions($restrictedParameters);
+    }
+    /**
+     * @throws BadFormConfigException
+     */
+    public function bindFormConfigsWithRealValues(array $forms): array
+    {
+        foreach ($forms as $bundle => $config) {
+            if (!isset($config['parameters'])) {
+                throw new BadFormConfigException();
+            }
+            $forms[$bundle]['parameters'] = $this->mergeWithLocalParameters($forms[$bundle]['parameters']);
+        }
+        return $forms;
+    }
+    /**
+     * Merges default parameters from each subscribed bundle with the local (real) params.
+     */
+    private function mergeWithLocalParameters(array $formParameters): array
+    {
+        $formParameters = RestrictionHelper::applyRestrictions($formParameters, $this->restrictedParameters);
+        foreach ($formParameters as $formKey => $defaultValue) {
+            $configValue = $this->parametersHelper->get($formKey);
+            if (null === $configValue) {
+                continue;
+            }
+            if (is_array($configValue)) {
+                $configValue = RestrictionHelper::applyRestrictions($configValue, $this->restrictedParameters, $formKey);
+                $formParameters[$formKey] = ConfigHelper::bindNestedConfigValues($configValue, $defaultValue);
+                continue;
+            }
+            $formParameters[$formKey] = $configValue;
+        }
+        return $formParameters;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Model/SysinfoModel.php
@@ -0,0 +1,151 @@
+<?php
+namespace Mautic\ConfigBundle\Model;
+use Doctrine\DBAL\Connection;
+use Mautic\CoreBundle\Helper\CoreParametersHelper;
+use Mautic\CoreBundle\Helper\PathsHelper;
+use Mautic\CoreBundle\Loader\ParameterLoader;
+use Mautic\InstallBundle\Configurator\Step\CheckStep;
+use Mautic\InstallBundle\Install\InstallService;
+use Symfony\Contracts\Translation\TranslatorInterface;
+class SysinfoModel
+{
+    /**
+     * @var string|null
+     */
+    protected $phpInfo;
+    /**
+     * @var array<string,bool>|null
+     */
+    protected $folders;
+    public function __construct(
+        protected PathsHelper $pathsHelper,
+        protected CoreParametersHelper $coreParametersHelper,
+        private TranslatorInterface $translator,
+        protected Connection $connection,
+        private InstallService $installService,
+        private CheckStep $checkStep,
+    ) {
+    }
+    /**
+     * Method to get the PHP info.
+     *
+     * @return string
+     */
+    public function getPhpInfo()
+    {
+        if (!is_null($this->phpInfo)) {
+            return $this->phpInfo;
+        }
+        if (function_exists('phpinfo') && 'cli' !== php_sapi_name()) {
+            ob_start();
+            $currentTz = date_default_timezone_get();
+            date_default_timezone_set('UTC');
+            phpinfo(INFO_GENERAL | INFO_CONFIGURATION | INFO_MODULES);
+            $phpInfo = ob_get_contents();
+            ob_end_clean();
+            preg_match_all('#<body[^>]*>(.*)</body>#siU', $phpInfo, $output);
+            $output        = preg_replace('#<table[^>]*>#', '<table class="table table-striped">', $output[1][0]);
+            $output        = preg_replace('#(\w),(\w)#', '\1, \2', $output);
+            $output        = preg_replace('#<hr />#', '', $output);
+            $output        = str_replace('<div class="center">', '', $output);
+            $output        = preg_replace('#<tr class="h">(.*)<\/tr>#', '<thead><tr class="h">$1</tr></thead><tbody>', $output);
+            $output        = str_replace('</table>', '</tbody></table>', $output);
+            $output        = str_replace('</div>', '', $output);
+            $this->phpInfo = $output;
+            date_default_timezone_set($currentTz);
+        } elseif (function_exists('phpversion')) {
+            $this->phpInfo = $this->translator->trans('mautic.sysinfo.phpinfo.phpversion', ['%phpversion%' => phpversion()]);
+        } else {
+            $this->phpInfo = $this->translator->trans('mautic.sysinfo.phpinfo.missing');
+        }
+        return $this->phpInfo;
+    }
+    /**
+     * @return string[]
+     */
+    public function getRecommendations(): array
+    {
+        return $this->installService->checkOptionalSettings($this->checkStep);
+    }
+    /**
+     * @return string[]
+     */
+    public function getRequirements(): array
+    {
+        return $this->installService->checkRequirements($this->checkStep);
+    }
+    /**
+     * Method to get important folders with a writable flag.
+     *
+     * @return array
+     */
+    public function getFolders()
+    {
+        if (!is_null($this->folders)) {
+            return $this->folders;
+        }
+        $importantFolders = [
+            ParameterLoader::getLocalConfigFile($this->pathsHelper->getSystemPath('root').'/app'),
+            $this->coreParametersHelper->get('cache_path'),
+            $this->coreParametersHelper->get('log_path'),
+            $this->coreParametersHelper->get('upload_dir'),
+            $this->pathsHelper->getSystemPath('images', true),
+            $this->pathsHelper->getSystemPath('translations', true),
+        ];
+        foreach ($importantFolders as $folder) {
+            $folderPath = realpath($folder);
+            $folderKey  = $folderPath ?: $folder;
+            $isWritable = $folderPath && is_writable($folderPath);
+            $this->folders[$folderKey] = $isWritable;
+        }
+        return $this->folders;
+    }
+    /**
+     * Method to tail (a few last rows) of a file.
+     *
+     * @param int $lines
+     */
+    public function getLogTail($lines = 10): ?string
+    {
+        $log = $this->coreParametersHelper->get('log_path').'/mautic_'.MAUTIC_ENV.'-'.date('Y-m-d').'.php';
+        if (!file_exists($log)) {
+            return null;
+        }
+        return $this->tail($log, $lines);
+    }
+    public function getDbInfo(): array
+    {
+        return [
+            'version'  => $this->connection->executeQuery('SELECT VERSION()')->fetchOne(),
+            'driver'   => $this->connection->getParams()['driver'],
+            'platform' => $this->connection->getDatabasePlatform()::class,
+        ];
+    }
+    /**
+     * Method to tail (a few last rows) of a file.
+     *
+     * @param int $lines
+     * @param int $buffer
+     */
+    public function tail($filename, $lines = 10, $buffer = 4096): string
+    {
+        $f      = fopen($filename, 'rb');
+        $output = '';
+        fseek($f, -1, SEEK_END);
+        if ("\n" != fread($f, 1)) {
+            --$lines;
+        }
+        while (ftell($f) > 0 && $lines >= 0) {
+            $seek = min(ftell($f), $buffer);
+            fseek($f, -$seek, SEEK_CUR);
+            $output = ($chunk = fread($f, $seek)).$output;
+            fseek($f, -mb_strlen($chunk, '8bit'), SEEK_CUR);
+            $lines -= substr_count($chunk, "\n");
+        }
+        while ($lines++ < 0) {
+            $output = substr($output, strpos($output, "\n") + 1);
+        }
+        fclose($f);
+        return $output;
+    }
+}

--- a//dev/null
+++ b/app/bundles/ConfigBundle/Service/ConfigChangeLogger.php
@@ -0,0 +1,98 @@
+<?php
+namespace Mautic\ConfigBundle\Service;
+use Mautic\CoreBundle\Helper\IpLookupHelper;
+use Mautic\CoreBundle\Model\AuditLogModel;
+use Symfony\Component\HttpFoundation\File\UploadedFile;
+/**
+ * Compare normalized for data and log changes.
+ */
+class ConfigChangeLogger
+{
+    /**
+     * Keys to remove from log.
+     *
+     * @var string[]
+     */
+    private array $filterKeys = [
+        'transifex_password',
+        'mailer_is_owner',
+    ];
+    /**
+     * @var mixed[]|null
+     */
+    private ?array $originalNormData = null;
+    public function __construct(
+        private IpLookupHelper $ipLookupHelper,
+        private AuditLogModel $auditLogModel,
+    ) {
+    }
+    /**
+     * @return ConfigChangeLogger
+     */
+    public function setOriginalNormData(array $originalNormData)
+    {
+        $this->originalNormData = $originalNormData;
+        return $this;
+    }
+    /**
+     * Log changes if something was changed.
+     * Diff is based on form normalized data before and after post.
+     *
+     * @see Form::getNormData()
+     */
+    public function log(array $postNormData): void
+    {
+        if (null === $this->originalNormData) {
+            throw new \RuntimeException('Set original normalized data at first');
+        }
+        $originalData = $this->normalizeData($this->originalNormData);
+        $postData     = $this->filterData($this->normalizeData($postNormData));
+        $diff = [];
+        foreach ($postData as $key => $value) {
+            if (array_key_exists($key, $originalData) && $originalData[$key] != $value) {
+                if ($value instanceof UploadedFile) {
+                    $value = $value->getFilename();
+                }
+                $diff[$key] = $value;
+            }
+        }
+        if (empty($diff)) {
+            return;
+        }
+        $log = [
+            'bundle'    => 'config',
+            'object'    => 'config',
+            'objectId'  => 0,
+            'action'    => 'update',
+            'details'   => $diff,
+            'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
+        ];
+        $this->auditLogModel->writeToLog($log);
+    }
+    /**
+     * Some form data (AssetBundle) has 'parameters' inside array too.
+     * Normalize all.
+     */
+    private function normalizeData(array $data): array
+    {
+        $key = 'parameters';
+        $normData = [];
+        foreach ($data as $values) {
+            if (array_key_exists($key, $values)) {
+                $normData = array_merge($normData, $values[$key]);
+            } else {
+                $normData = array_merge($normData, $values);
+            }
+        }
+        return $normData;
+    }
+    /**
+     * Filter unused keys from post data.
+     */
+    private function filterData(array $data): array
+    {
+        $keys = $this->filterKeys;
+        return array_filter($data, fn ($key): bool => !in_array($key, $keys),
+            ARRAY_FILTER_USE_KEY);
+    }
+}

--- a/app/bundles/CoreBundle/Form/Type/ConfigType.php
+++ b//dev/null
@@ -1,694 +0,0 @@
-<?php
-namespace Mautic\CoreBundle\Form\Type;
-use Mautic\CoreBundle\Factory\IpLookupFactory;
-use Mautic\CoreBundle\Form\DataTransformer\ArrayLinebreakTransformer;
-use Mautic\CoreBundle\Form\DataTransformer\ArrayStringTransformer;
-use Mautic\CoreBundle\Helper\CoreParametersHelper;
-use Mautic\CoreBundle\Helper\LanguageHelper;
-use Mautic\CoreBundle\IpLookup\AbstractLookup;
-use Mautic\CoreBundle\IpLookup\IpLookupFormInterface;
-use Mautic\CoreBundle\Shortener\Shortener;
-use Mautic\PageBundle\Form\Type\PageListType;
-use Symfony\Component\Form\AbstractType;
-use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
-use Symfony\Component\Form\Extension\Core\Type\HiddenType;
-use Symfony\Component\Form\Extension\Core\Type\IntegerType;
-use Symfony\Component\Form\Extension\Core\Type\NumberType;
-use Symfony\Component\Form\Extension\Core\Type\TextareaType;
-use Symfony\Component\Form\Extension\Core\Type\TextType;
-use Symfony\Component\Form\Extension\Core\Type\TimezoneType;
-use Symfony\Component\Form\Extension\Core\Type\UrlType;
-use Symfony\Component\Form\FormBuilderInterface;
-use Symfony\Component\Form\FormEvent;
-use Symfony\Component\Form\FormEvents;
-use Symfony\Component\Form\FormInterface;
-use Symfony\Component\Form\FormView;
-use Symfony\Component\Validator\Constraints\Callback;
-use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
-use Symfony\Component\Validator\Constraints\NotBlank;
-use Symfony\Component\Validator\Context\ExecutionContextInterface;
-use Symfony\Contracts\Translation\TranslatorInterface;
-/**
- * @extends AbstractType<mixed>
- */
-class ConfigType extends AbstractType
-{
-    public function __construct(private TranslatorInterface $translator, private LanguageHelper $langHelper, private IpLookupFactory $ipLookupFactory, private ?AbstractLookup $ipLookup, private Shortener $shortenerFactory, private CoreParametersHelper $coreParametersHelper)
-    {
-    }
-    public function buildForm(FormBuilderInterface $builder, array $options): void
-    {
-        $builder->add('last_shown_tab', HiddenType::class);
-        $builder->add(
-            'site_url',
-            UrlType::class,
-            [
-                'label'      => 'mautic.core.config.form.site.url',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.site.url.tooltip',
-                ],
-                'default_protocol' => 'https',
-                'constraints'      => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'webroot',
-            PageListType::class,
-            [
-                'label'      => 'mautic.core.config.form.webroot',
-                'label_attr' => ['class' => 'control-label'],
-                'help'       => 'mautic.core.config.form.webroot.help',
-                'attr'       => [
-                    'class'            => 'form-control',
-                    'tooltip'          => 'mautic.core.config.form.webroot.tooltip',
-                    'data-placeholder' => $this->translator->trans('mautic.core.config.form.webroot.dashboard'),
-                ],
-                'multiple'    => false,
-                'placeholder' => '',
-                'required'    => false,
-            ]
-        );
-        $builder->add(
-            '404_page',
-            PageListType::class,
-            [
-                'label'         => 'mautic.core.config.form.404_page',
-                'label_attr'    => ['class' => 'control-label'],
-                'help'          => 'mautic.core.config.form.404_page.help',
-                'attr'          => [
-                    'class'            => 'form-control',
-                    'tooltip'          => 'mautic.core.config.form.404_page.tooltip',
-                ],
-                'multiple'       => false,
-                'placeholder'    => '',
-                'published_only' => true,
-            ]
-        );
-        $builder->add(
-            'cache_path',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.cache.path',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.cache.path.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'log_path',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.log.path',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.log.path.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'image_path',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.image.path',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.image.path.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                    new Callback([$this, 'validateImagePath']),
-                ],
-            ]
-        );
-        $builder->add(
-            'composer_updates',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.form.update.composer',
-                'data'  => (array_key_exists('composer_updates', $options['data']) && !empty($options['data']['composer_updates'])),
-                'attr'  => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.update.composer.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'locale',
-            ChoiceType::class,
-            [
-                'choices'           => $this->langHelper->getLanguageChoices(),
-                'label'             => 'mautic.core.config.form.locale',
-                'required'          => false,
-                'attr'              => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.locale.tooltip',
-                ],
-                'help'              => 'mautic.core.config.form.locale.help',
-                'placeholder'       => false,
-            ]
-        );
-        $arrayStringTransformer = new ArrayStringTransformer();
-        $builder->add(
-            $builder->create(
-                'trusted_hosts',
-                TextType::class,
-                [
-                    'label'      => 'mautic.core.config.form.trusted.hosts',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'   => 'form-control',
-                        'tooltip' => 'mautic.core.config.form.trusted.hosts.tooltip',
-                    ],
-                    'help'       => 'mautic.core.config.form.trusted_hosts.help',
-                    'required'   => false,
-                ]
-            )->addViewTransformer($arrayStringTransformer)
-        );
-        $builder->add(
-            $builder->create(
-                'trusted_proxies',
-                TextType::class,
-                [
-                    'label'      => 'mautic.core.config.form.trusted.proxies',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'   => 'form-control',
-                        'tooltip' => 'mautic.core.config.form.trusted.proxies.tooltip',
-                    ],
-                    'required' => false,
-                ]
-            )->addViewTransformer($arrayStringTransformer)
-        );
-        $arrayLinebreakTransformer = new ArrayLinebreakTransformer();
-        $builder->add(
-            $builder->create(
-                'do_not_track_ips',
-                TextareaType::class,
-                [
-                    'label'      => 'mautic.core.config.form.do_not_track_ips',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'   => 'form-control',
-                        'tooltip' => 'mautic.core.config.form.do_not_track_ips.tooltip',
-                        'rows'    => 8,
-                    ],
-                    'required' => false,
-                ]
-            )->addViewTransformer($arrayLinebreakTransformer)
-        );
-        $builder->add(
-            $builder->create(
-                'do_not_track_bots',
-                TextareaType::class,
-                [
-                    'label'      => 'mautic.core.config.form.do_not_track_bots',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'   => 'form-control',
-                        'tooltip' => 'mautic.core.config.form.do_not_track_bots.tooltip',
-                        'rows'    => 8,
-                    ],
-                    'required' => false,
-                ]
-            )->addViewTransformer($arrayLinebreakTransformer)
-        );
-        $builder->add(
-            'default_pagelimit',
-            ChoiceType::class,
-            [
-                'choices'           => [
-                    'mautic.core.pagination.5'   => 5,
-                    'mautic.core.pagination.10'  => 10,
-                    'mautic.core.pagination.15'  => 15,
-                    'mautic.core.pagination.20'  => 20,
-                    'mautic.core.pagination.25'  => 25,
-                    'mautic.core.pagination.30'  => 30,
-                    'mautic.core.pagination.50'  => 50,
-                    'mautic.core.pagination.100' => 100,
-                ],
-                'expanded'          => false,
-                'multiple'          => false,
-                'label'             => 'mautic.core.config.form.default.pagelimit',
-                'label_attr'        => ['class' => 'control-label'],
-                'attr'              => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.default.pagelimit.tooltip',
-                ],
-                'required'          => false,
-                'placeholder'       => false,
-            ]
-        );
-        $builder->add(
-            'default_timezone',
-            TimezoneType::class,
-            [
-                'label'      => 'mautic.core.config.form.default.timezone',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.default.timezone.tooltip',
-                ],
-                'multiple'    => false,
-                'placeholder' => 'mautic.user.user.form.defaulttimezone',
-                'required'    => false,
-            ]
-        );
-        $builder->add(
-            'cached_data_timeout',
-            NumberType::class,
-            [
-                'label'      => 'mautic.core.config.form.cached.data.timeout',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'          => 'form-control',
-                    'tooltip'        => 'mautic.core.config.form.cached.data.timeout.tooltip',
-                    'postaddon'      => '',
-                    'postaddon_text' => $this->translator->trans('mautic.core.time.minutes'),
-                ],
-                'constraints' => [
-                    new NotBlank([
-                        'message' => 'mautic.core.value.required',
-                    ]),
-                    new GreaterThanOrEqual([
-                        'value' => 0,
-                    ]),
-                ],
-            ]
-        );
-        $builder->add(
-            'date_format_full',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.date.format.full',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.date.format.full.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'date_format_short',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.date.format.short',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.date.format.short.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'date_format_dateonly',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.date.format.dateonly',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.date.format.dateonly.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'date_format_timeonly',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.date.format.timeonly',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.date.format.timeonly.tooltip',
-                ],
-                'constraints' => [
-                    new NotBlank(
-                        [
-                            'message' => 'mautic.core.value.required',
-                        ]
-                    ),
-                ],
-            ]
-        );
-        $builder->add(
-            'default_daterange_filter',
-            ChoiceType::class,
-            [
-                'choices' => [
-                    'mautic.core.daterange.0days'                                                                 => 'midnight',
-                    'mautic.core.daterange.1days'                                                                 => '-24 hours',
-                    $this->translator->trans('mautic.core.daterange.week', ['%count%' => 1])                      => '-1 week',
-                    $this->translator->trans('mautic.core.daterange.week', ['%count%' => 2])                      => '-2 weeks',
-                    $this->translator->trans('mautic.core.daterange.week', ['%count%' => 3])                      => '-3 weeks',
-                    $this->translator->trans('mautic.core.daterange.month', ['%count%' => 1])                     => '-1 month',
-                    $this->translator->trans('mautic.core.daterange.month', ['%count%' => 2])                     => '-2 months',
-                    $this->translator->trans('mautic.core.daterange.month', ['%count%' => 3])                     => '-3 months',
-                    $this->translator->trans('mautic.core.daterange.year', ['%count%' => 1])                      => '-1 year',
-                    $this->translator->trans('mautic.core.daterange.year', ['%count%' => 2])                      => '-2 years',
-                ],
-                'expanded'          => false,
-                'multiple'          => false,
-                'label'             => 'mautic.core.config.form.default.daterange_default',
-                'label_attr'        => ['class' => 'control-label'],
-                'attr'              => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.default.daterange_default.tooltip',
-                ],
-                'required'          => false,
-                'placeholder'       => false,
-            ]
-        );
-        $builder->add(
-            'ip_lookup_service',
-            ChoiceType::class,
-            [
-                'choices'           => $this->getIpServicesChoices(),
-                'label'             => 'mautic.core.config.form.ip.lookup.service',
-                'label_attr'        => [
-                    'class' => 'control-label',
-                ],
-                'help'              => 'mautic.core.config.form.ip.lookup.service.help',
-                'required'          => false,
-                'attr'              => [
-                    'class'    => 'form-control',
-                    'tooltip'  => 'mautic.core.config.form.ip.lookup.service.tooltip',
-                    'onchange' => 'Mautic.getIpLookupFormConfig()',
-                ],
-            ]
-        );
-        $builder->add(
-            'ip_lookup_auth',
-            TextType::class,
-            [
-                'label'      => 'mautic.core.config.form.ip.lookup.auth',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.ip.lookup.auth.tooltip',
-                ],
-                'required' => false,
-            ]
-        );
-        $builder->add(
-            'ip_lookup_create_organization',
-            YesNoButtonGroupType::class,
-            [
-                'label'      => 'mautic.core.config.create.organization.from.ip.lookup',
-                'label_attr' => ['class' => 'control-label'],
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.create.organization.from.ip.lookup.tooltip',
-                ],
-                'data'     => isset($options['data']['ip_lookup_create_organization']) && (bool) $options['data']['ip_lookup_create_organization'],
-                'required' => false,
-            ]
-        );
-        $ipLookupFactory = $this->ipLookupFactory;
-        $formModifier    = function (FormEvent $event) use ($ipLookupFactory): void {
-            $data = $event->getData();
-            $form = $event->getForm();
-            $ipServiceName = $data['ip_lookup_service'] ?? null;
-            if ($ipServiceName && $lookupService = $ipLookupFactory->getService($ipServiceName)) {
-                if ($lookupService instanceof IpLookupFormInterface && $formType = $lookupService->getConfigFormService()) {
-                    $form->add(
-                        'ip_lookup_config',
-                        $formType,
-                        [
-                            'label'             => false,
-                            'ip_lookup_service' => $lookupService,
-                        ]
-                    );
-                }
-            }
-        };
-        $builder->addEventListener(
-            FormEvents::PRE_SET_DATA,
-            function (FormEvent $event) use ($formModifier): void {
-                $formModifier($event);
-            }
-        );
-        $builder->addEventListener(
-            FormEvents::PRE_SUBMIT,
-            function (FormEvent $event) use ($formModifier): void {
-                $formModifier($event);
-            }
-        );
-        $builder->add(
-            'update_stability',
-            ChoiceType::class,
-            [
-                'choices'           => [
-                    'mautic.core.config.update_stability.alpha'  => 'alpha',
-                    'mautic.core.config.update_stability.beta'   => 'beta',
-                    'mautic.core.config.update_stability.rc'     => 'rc',
-                    'mautic.core.config.update_stability.stable' => 'stable',
-                ],
-                'label'             => 'mautic.core.config.form.update.stability',
-                'required'          => false,
-                'attr'              => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.update.stability.tooltip',
-                ],
-                'placeholder'       => false,
-            ]
-        );
-        $enabledServices = $this->shortenerFactory->getEnabledServices();
-        $choices         = array_flip(array_map(fn ($enabledService) => $enabledService->getPublicName(), $enabledServices));
-        $builder->add(
-            Shortener::SHORTENER_SERVICE,
-            ChoiceType::class,
-            [
-                'choices'           => $choices,
-                'label'             => 'mautic.core.config.form.shortener',
-                'required'          => false,
-                'attr'              => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.shortener.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'shortener_email_enable',
-            YesNoButtonGroupType::class,
-            [
-                'label'      => 'mautic.core.config.form.shortener.enable_email',
-                'data'       => (array_key_exists('shortener_email_enable', $options['data']) && !empty($options['data']['shortener_email_enable'])),
-                'attr'       => [
-                    'class'        => 'form-control',
-                    'tooltip'      => 'mautic.core.config.form.shortener.enable_email.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'shortener_sms_enable',
-            YesNoButtonGroupType::class,
-            [
-                'label'      => 'mautic.core.config.form.shortener.enable_sms',
-                'data'       => (array_key_exists('shortener_sms_enable', $options['data']) && !empty($options['data']['shortener_sms_enable'])),
-                'attr'       => [
-                    'class'        => 'form-control',
-                    'tooltip'      => 'mautic.core.config.form.shortener.enable_sms.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'max_entity_lock_time',
-            NumberType::class,
-            [
-                'label'      => 'mautic.core.config.form.link.max_entity_lock_time',
-                'label_attr' => ['class' => 'control-label'],
-                'help'       => 'mautic.core.config.form.link.max_entity_lock_time.help',
-                'attr'       => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.link.max_entity_lock_time.tooltip',
-                ],
-                'required' => false,
-            ]
-        );
-        $builder->add(
-            'transliterate_page_title',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.form.transliterate.page.title',
-                'data'  => (array_key_exists('transliterate_page_title', $options['data']) && !empty($options['data']['transliterate_page_title'])),
-                'attr'  => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.form.transliterate.page.title.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'cors_restrict_domains',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.cors.restrict.domains',
-                'help'  => 'mautic.core.config.cors.restrict.domains.help',
-                'data'  => (array_key_exists('cors_restrict_domains', $options['data']) && !empty($options['data']['cors_restrict_domains'])),
-                'attr'  => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.cors.restrict.domains.tooltip',
-                ],
-            ]
-        );
-        $arrayLinebreakTransformer = new ArrayLinebreakTransformer();
-        $builder->add(
-            $builder->create(
-                'cors_valid_domains',
-                TextareaType::class,
-                [
-                    'label'      => 'mautic.core.config.cors.valid.domains',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'        => 'form-control',
-                        'tooltip'      => 'mautic.core.config.cors.valid.domains.tooltip',
-                        'data-show-on' => '{"config_coreconfig_cors_restrict_domains_1":"checked"}',
-                    ],
-                    'help'       => 'mautic.core.config.form.cors_valid_domains.help',
-                ]
-            )->addViewTransformer($arrayLinebreakTransformer)
-        );
-        $builder->add(
-            'headers_sts',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.response.headers.sts',
-                'data'  => (array_key_exists('headers_sts', $options['data']) && !empty($options['data']['headers_sts'])),
-                'attr'  => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.core.config.response.headers.sts.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            'headers_sts_expire_time',
-            IntegerType::class,
-            [
-                'label' => 'mautic.core.config.response.headers.sts.expire_time',
-                'data'  => $options['data']['headers_sts_expire_time'] ?? 60,
-                'attr'  => [
-                    'class'          => 'form-control',
-                    'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
-                    'min'            => 60,
-                ],
-            ]
-        );
-        $builder->add(
-            'headers_sts_subdomains',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.response.headers.sts.subdomains',
-                'data'  => (array_key_exists('headers_sts_subdomains', $options['data']) && !empty($options['data']['headers_sts_subdomains'])),
-                'attr'  => [
-                    'class'          => 'form-control',
-                    'tooltip'        => 'mautic.core.config.response.headers.sts.subdomains.tooltip',
-                    'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
-                ],
-            ]
-        );
-        $builder->add(
-            'headers_sts_preload',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.core.config.response.headers.sts.preload',
-                'data'  => (array_key_exists('headers_sts_preload', $options['data']) && !empty($options['data']['headers_sts_preload'])),
-                'attr'  => [
-                    'class'          => 'form-control',
-                    'tooltip'        => 'mautic.core.config.response.headers.sts.preload.tooltip',
-                    'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
-                ],
-            ]
-        );
-    }
-    public function validateImagePath(?string $value, ExecutionContextInterface $context): void
-    {
-        $isValid = true;
-        $normalizedValue = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $value);
-        if (
-            empty($normalizedValue)
-            || str_contains($normalizedValue, '..')
-            || str_contains($normalizedValue, '.'.DIRECTORY_SEPARATOR)
-            || DIRECTORY_SEPARATOR === $normalizedValue
-        ) {
-            $isValid = false;
-        }
-        $mediaFile = substr($value, 0, 6);
-        if ('media/' !== $mediaFile) {
-            $isValid = false;
-        }
-        if (!is_dir($value)) {
-            $isValid = false;
-        }
-        if (!$isValid) {
-            $context->buildViolation('mautic.core.config.form.image.path.invalid')->atPath('image_path')->addViolation();
-        }
-    }
-    public function buildView(FormView $view, FormInterface $form, array $options): void
-    {
-        $view->vars['ipLookupAttribution'] = (null !== $this->ipLookup) ? $this->ipLookup->getAttribution() : '';
-    }
-    public function getBlockPrefix(): string
-    {
-        return 'coreconfig';
-    }
-    private function getIpServicesChoices(): array
-    {
-        $choices          = [];
-        $ipLookupServices = $this->coreParametersHelper->get('ip_lookup_services') ?? [];
-        foreach ($ipLookupServices as $name => $service) {
-            $choices[$service['display_name']] = $name;
-        }
-        ksort($choices, SORT_FLAG_CASE | SORT_NATURAL);
-        return $choices;
-    }
-}

--- a/app/bundles/CoreBundle/Helper/PrivateAddressChecker.php
+++ b//dev/null
@@ -1,138 +0,0 @@
-<?php
-declare(strict_types=1);
-namespace Mautic\CoreBundle\Helper;
-class PrivateAddressChecker
-{
-    private const PRIVATE_IP_RANGES = [
-        '10.0.0.0/8',      // RFC1918
-        '172.16.0.0/12',   // RFC1918
-        '192.168.0.0/16',  // RFC1918
-        '127.0.0.0/8',     // Localhost
-        '169.254.0.0/16',  // Link-local
-        'fc00::/7',        // Unique local address
-        'fe80::/10',       // Link-local address
-        '::1/128',         // Localhost IPv6
-    ];
-    /** @var array<string> */
-    private array $allowedPrivateAddresses = [];
-    /**
-     * @param callable|null $dnsResolver
-     */
-    public function __construct(
-        private $dnsResolver = null,
-    ) {
-        $this->dnsResolver = $dnsResolver ?? 'gethostbynamel';
-    }
-    /**
-     * @param array<string> $allowedPrivateAddresses
-     */
-    public function setAllowedPrivateAddresses(array $allowedPrivateAddresses): PrivateAddressChecker
-    {
-        $this->allowedPrivateAddresses = $allowedPrivateAddresses;
-        return $this;
-    }
-    public function isPrivateUrl(string $url): bool
-    {
-        try {
-            $parsedUrl = parse_url($url);
-            if (!isset($parsedUrl['host'])) {
-                throw new \InvalidArgumentException('Invalid URL format');
-            }
-            $host = strtolower($parsedUrl['host']);
-            if ('localhost' === $host) {
-                return true;
-            }
-            if (str_starts_with($host, '[') && str_ends_with($host, ']')) {
-                $ip = substr($host, 1, -1); // Remove brackets
-                return $this->isPrivateIp($ip);
-            }
-            if (!filter_var($host, FILTER_VALIDATE_IP)) {
-                $ips = ($this->dnsResolver)($host);
-                if (false === $ips) {
-                    throw new \InvalidArgumentException('Could not resolve hostname');
-                }
-                foreach ($ips as $ip) {
-                    if ($this->isPrivateIp($ip)) {
-                        return true;
-                    }
-                }
-                return false;
-            }
-            return $this->isPrivateIp($host);
-        } catch (\Exception $e) {
-            throw new \InvalidArgumentException('URL validation failed: '.$e->getMessage());
-        }
-    }
-    public function isPrivateIp(string $ip): bool
-    {
-        if (($pos = strpos($ip, '%')) !== false) {
-            $ip = substr($ip, 0, $pos);
-        }
-        $binaryIp = @inet_pton($ip);
-        if (false === $binaryIp) {
-            return false;
-        }
-        foreach (self::PRIVATE_IP_RANGES as $range) {
-            [$networkIp, $netmask] = explode('/', $range);
-            $binaryNetwork = @inet_pton($networkIp);
-            if (false === $binaryNetwork) {
-                continue;
-            }
-            $maskLen  = (int) $netmask;
-            $numBytes = (int) ($maskLen / 8);
-            $numBits  = $maskLen % 8;
-            if (substr($binaryIp, 0, $numBytes) !== substr($binaryNetwork, 0, $numBytes)) {
-                continue;
-            }
-            if ($numBits > 0) {
-                $mask = 0xFF << (8 - $numBits);
-                if ((ord($binaryIp[$numBytes]) & $mask) !== (ord($binaryNetwork[$numBytes]) & $mask)) {
-                    continue;
-                }
-            }
-            return true;
-        }
-        return false;
-    }
-    /**
-     * Checks if the given URL is allowed based on the allowed private addresses list.
-     * Returns true if the URL is either public or in the allowed private addresses list.
-     */
-    public function isAllowedUrl(string $url): bool
-    {
-        try {
-            if (!$this->isPrivateUrl($url)) {
-                return true;
-            }
-            if (empty($this->allowedPrivateAddresses)) {
-                return false;
-            }
-            $parsedUrl = parse_url($url);
-            if (!isset($parsedUrl['host'])) {
-                throw new \InvalidArgumentException('Invalid URL format');
-            }
-            $host = strtolower($parsedUrl['host']);
-            if (in_array($host, $this->allowedPrivateAddresses, true)) {
-                return true;
-            }
-            if (str_starts_with($host, '[') && str_ends_with($host, ']')) {
-                $host = substr($host, 1, -1); // Remove brackets
-            }
-            if (filter_var($host, FILTER_VALIDATE_IP)) {
-                return in_array($host, $this->allowedPrivateAddresses, true);
-            }
-            $ips = ($this->dnsResolver)($host);
-            if (false === $ips) {
-                throw new \InvalidArgumentException('Could not resolve hostname');
-            }
-            foreach ($ips as $ip) {
-                if (in_array($ip, $this->allowedPrivateAddresses, true)) {
-                    return true;
-                }
-            }
-            return false;
-        } catch (\Exception $e) {
-            throw new \InvalidArgumentException('URL validation failed: '.$e->getMessage());
-        }
-    }
-}

--- a/app/bundles/EmailBundle/MonitoredEmail/Mailbox.php
+++ b//dev/null
@@ -1,956 +0,0 @@
-<?php
-namespace Mautic\EmailBundle\MonitoredEmail;
-use IMAP\Connection;
-use Mautic\CoreBundle\Helper\CoreParametersHelper;
-use Mautic\CoreBundle\Helper\PathsHelper;
-use Mautic\EmailBundle\Exception\MailboxException;
-use Mautic\EmailBundle\MonitoredEmail\Exception\NotConfiguredException;
-class Mailbox
-{
-    /**
-     * Return all mails matching the rest of the criteria.
-     */
-    public const CRITERIA_ALL = 'ALL';
-    /**
-     * Match mails with the \\ANSWERED flag set.
-     */
-    public const CRITERIA_ANSWERED = 'ANSWERED';
-    /**
-     * CRITERIA_BCC "string" - match mails with "string" in the Bcc: field.
-     */
-    public const CRITERIA_BCC = 'BCC';
-    /**
-     * CRITERIA_BEFORE "date" - match mails with Date: before "date".
-     */
-    public const CRITERIA_BEFORE = 'BEFORE';
-    /**
-     * CRITERIA_BODY "string" - match mails with "string" in the body of the mail.
-     */
-    public const CRITERIA_BODY = 'BODY';
-    /**
-     * CRITERIA_CC "string" - match mails with "string" in the Cc: field.
-     */
-    public const CRITERIA_CC = 'CC';
-    /**
-     * Match deleted mails.
-     */
-    public const CRITERIA_DELETED = 'DELETED';
-    /**
-     * Match mails with the \\FLAGGED (sometimes referred to as Important or Urgent) flag set.
-     */
-    public const CRITERIA_FLAGGED = 'FLAGGED';
-    /**
-     * CRITERIA_FROM "string" - match mails with "string" in the From: field.
-     */
-    public const CRITERIA_FROM = 'FROM';
-    /**
-     *  CRITERIA_KEYWORD "string" - match mails with "string" as a keyword.
-     */
-    public const CRITERIA_KEYWORD = 'KEYWORD';
-    /**
-     * Match new mails.
-     */
-    public const CRITERIA_NEW = 'NEW';
-    /**
-     * Match old mails.
-     */
-    public const CRITERIA_OLD = 'OLD';
-    /**
-     * CRITERIA_ON "date" - match mails with Date: matching "date".
-     */
-    public const CRITERIA_ON = 'ON';
-    /**
-     * Match mails with the \\RECENT flag set.
-     */
-    public const CRITERIA_RECENT = 'RECENT';
-    /**
-     * Match mails that have been read (the \\SEEN flag is set).
-     */
-    public const CRITERIA_SEEN = 'SEEN';
-    /**
-     * CRITERIA_SINCE "date" - match mails with Date: after "date".
-     */
-    public const CRITERIA_SINCE = 'SINCE';
-    /**
-     *  CRITERIA_SUBJECT "string" - match mails with "string" in the Subject:.
-     */
-    public const CRITERIA_SUBJECT = 'SUBJECT';
-    /**
-     * CRITERIA_TEXT "string" - match mails with text "string".
-     */
-    public const CRITERIA_TEXT = 'TEXT';
-    /**
-     * CRITERIA_TO "string" - match mails with "string" in the To:.
-     */
-    public const CRITERIA_TO = 'TO';
-    /**
-     *  Get messages since a specific UID. Eg. UID 2:* will return all messages with UID 2 and above (IMAP includes the given UID).
-     */
-    public const CRITERIA_UID = 'UID';
-    /**
-     *  Match mails that have not been answered.
-     */
-    public const CRITERIA_UNANSWERED = 'UNANSWERED';
-    /**
-     * Match mails that are not deleted.
-     */
-    public const CRITERIA_UNDELETED = 'UNDELETED';
-    /**
-     * Match mails that are not flagged.
-     */
-    public const CRITERIA_UNFLAGGED = 'UNFLAGGED';
-    /**
-     * CRITERIA_UNKEYWORD "string" - match mails that do not have the keyword "string".
-     */
-    public const CRITERIA_UNKEYWORD = 'UNKEYWORD';
-    /**
-     * Match mails which have not been read yet.
-     */
-    public const CRITERIA_UNSEEN = 'UNSEEN';
-    /**
-     * Match mails which have not been read yet - alias of CRITERIA_UNSEEN.
-     */
-    public const CRITERIA_UNREAD = 'UNSEEN';
-    protected $imapPath;
-    protected $imapFullPath;
-    protected $imapStream;
-    protected $imapFolder     = 'INBOX';
-    protected $imapOptions    = 0;
-    protected $imapRetriesNum = 0;
-    protected $imapParams     = [];
-    protected $serverEncoding = 'UTF-8';
-    protected $attachmentsDir;
-    protected $settings;
-    protected $isGmail = false;
-    protected $mailboxes;
-    /**
-     * @var mixed[]
-     */
-    private array $folders = [];
-    public function __construct(CoreParametersHelper $parametersHelper, PathsHelper $pathsHelper)
-    {
-        $this->mailboxes = $parametersHelper->get('monitored_email', []);
-        if (isset($this->mailboxes['general'])) {
-            $this->settings = $this->mailboxes['general'];
-        } else {
-            $this->settings = [
-                'host'            => '',
-                'port'            => '',
-                'password'        => '',
-                'user'            => '',
-                'encryption'      => '',
-                'use_attachments' => false,
-            ];
-        }
-        $this->createAttachmentsDir($pathsHelper);
-        if ('imap.gmail.com' == $this->settings['host']) {
-            $this->isGmail = true;
-        }
-    }
-    /**
-     * Returns if a mailbox is configured.
-     */
-    public function isConfigured($bundleKey = null, $folderKey = null): bool
-    {
-        if (null !== $bundleKey) {
-            try {
-                $this->switchMailbox($bundleKey, $folderKey);
-            } catch (MailboxException) {
-                return false;
-            }
-        }
-        return
-            !empty($this->settings['host']) && !empty($this->settings['port']) && !empty($this->settings['user'])
-            && !empty($this->settings['password']);
-    }
-    /**
-     * Switch to another configured monitored mailbox.
-     *
-     * @param string $mailbox
-     *
-     * @throws MailboxException
-     */
-    public function switchMailbox($bundle, $mailbox = ''): void
-    {
-        $key = $bundle.(!empty($mailbox) ? '_'.$mailbox : '');
-        if (isset($this->mailboxes[$key])) {
-            $this->settings           = (!empty($this->mailboxes[$key]['override_settings'])) ? $this->mailboxes[$key] : $this->mailboxes['general'];
-            $this->imapFolder         = $this->mailboxes[$key]['folder'];
-            $this->settings['folder'] = $this->mailboxes[$key]['folder'];
-            $this->disconnect();
-            $this->setImapPath();
-        } else {
-            throw new MailboxException($key.' not found');
-        }
-    }
-    /**
-     * Returns if this is a Gmail connection.
-     *
-     * @return mixed
-     */
-    public function isGmail()
-    {
-        return $this->isGmail();
-    }
-    /**
-     * Set imap path based on mailbox settings.
-     */
-    public function setImapPath($settings = null): void
-    {
-        if (null == $settings) {
-            $settings = $this->settings;
-        }
-        $paths              = $this->getImapPath($settings);
-        $this->imapPath     = $paths['path'];
-        $this->imapFullPath = $paths['full'];
-    }
-    public function getImapPath($settings): array
-    {
-        if (!isset($settings['encryption'])) {
-            $settings['encryption'] = (!empty($settings['ssl'])) ? '/ssl' : '';
-        }
-        $path     = "{{$settings['host']}:{$settings['port']}/imap{$settings['encryption']}}";
-        $fullPath = $path;
-        if (isset($settings['folder'])) {
-            $fullPath .= $settings['folder'];
-        }
-        return ['path' => $path, 'full' => $fullPath];
-    }
-    /**
-     * Override mailbox settings.
-     */
-    public function setMailboxSettings(array $settings): void
-    {
-        $this->settings = array_merge($this->settings, $settings);
-        $this->isGmail = ('imap.gmail.com' == $this->settings['host']);
-        $this->setImapPath();
-    }
-    /**
-     * Get settings.
-     *
-     * @param string $mailbox
-     *
-     * @return mixed
-     *
-     * @throws MailboxException
-     */
-    public function getMailboxSettings($bundle = null, $mailbox = '')
-    {
-        if (null == $bundle) {
-            return $this->settings;
-        }
-        $key = $bundle.(!empty($mailbox) ? '_'.$mailbox : '');
-        if (isset($this->mailboxes[$key])) {
-            $settings = (!empty($this->mailboxes[$key]['override_settings'])) ? $this->mailboxes[$key] : $this->mailboxes['general'];
-            $settings['folder'] = $this->mailboxes[$key]['folder'];
-            $this->setImapPath($settings);
-            $imapPath              = $this->getImapPath($settings);
-            $settings['imap_path'] = $imapPath['full'];
-        } else {
-            throw new MailboxException($key.' not found');
-        }
-        return $settings;
-    }
-    /**
-     * Set custom connection arguments of imap_open method. See http://php.net/imap_open.
-     *
-     * @param int $options
-     * @param int $retriesNum
-     */
-    public function setConnectionArgs($options = 0, $retriesNum = 0, array $params = null): void
-    {
-        $this->imapOptions    = $options;
-        $this->imapRetriesNum = $retriesNum;
-        $this->imapParams     = $params;
-    }
-    /**
-     * Switch to another box.
-     */
-    public function switchFolder($folder): void
-    {
-        if ($folder != $this->imapFolder) {
-            $this->imapFullPath = $this->imapPath.$folder;
-            $this->imapFolder   = $folder;
-        }
-        $this->getImapStream();
-    }
-    /**
-     * Get IMAP mailbox connection stream.
-     *
-     * @return Connection
-     */
-    public function getImapStream()
-    {
-        if (!$this->isConnected()) {
-            $this->imapStream = $this->initImapStream();
-        } else {
-            @imap_reopen($this->imapStream, $this->imapFullPath);
-        }
-        return $this->imapStream;
-    }
-    /**
-     * @return Connection
-     *
-     * @throws MailboxException
-     */
-    protected function initImapStream()
-    {
-        imap_timeout(IMAP_OPENTIMEOUT, 15);
-        imap_timeout(IMAP_CLOSETIMEOUT, 15);
-        imap_timeout(IMAP_READTIMEOUT, 15);
-        imap_timeout(IMAP_WRITETIMEOUT, 15);
-        $imapStream = @imap_open(
-            $this->imapFullPath,
-            $this->settings['user'],
-            $this->settings['password'],
-            $this->imapOptions,
-            $this->imapRetriesNum,
-            $this->imapParams
-        );
-        if (!$imapStream) {
-            throw new MailboxException();
-        }
-        return $imapStream;
-    }
-    /**
-     * Check if the stream is connected.
-     */
-    protected function isConnected(): bool
-    {
-        if (!$this->isConfigured() || !$this->imapStream) {
-            return false;
-        }
-        try {
-            return @imap_ping($this->imapStream);
-        } catch (\ValueError|\TypeError) {
-            return false;
-        }
-    }
-    /**
-     * Get information about the current mailbox.
-     *
-     * Returns the information in an object with following properties:
-     *  Date - current system time formatted according to RFC2822
-     *  Driver - protocol used to access this mailbox: POP3, IMAP, NNTP
-     *  Mailbox - the mailbox name
-     *  Nmsgs - number of mails in the mailbox
-     *  Recent - number of recent mails in the mailbox
-     *
-     * @return \stdClass
-     */
-    public function checkMailbox(): \stdClass|bool
-    {
-        return imap_check($this->getImapStream());
-    }
-    /**
-     * Creates a new mailbox specified by mailbox.
-     */
-    public function createMailbox(): bool
-    {
-        return imap_createmailbox($this->getImapStream(), imap_utf7_encode($this->imapFullPath));
-    }
-    /**
-     * Gets status information about the given mailbox.
-     *
-     * This function returns an object containing status information.
-     * The object has the following properties: messages, recent, unseen, uidnext, and uidvalidity.
-     *
-     * @return \stdClass if the box doesn't exist
-     */
-    public function statusMailbox(): \stdClass|bool
-    {
-        return imap_status($this->getImapStream(), $this->imapFullPath, SA_ALL);
-    }
-    /**
-     * Gets listing the folders.
-     *
-     * This function returns an object containing listing the folders.
-     * The object has the following properties: messages, recent, unseen, uidnext, and uidvalidity.
-     *
-     * @return array listing the folders
-     */
-    public function getListingFolders()
-    {
-        if (!$this->isConfigured()) {
-            throw new NotConfiguredException('mautic.email.config.monitored_email.not_configured');
-        }
-        if (!isset($this->folders[$this->imapFullPath])) {
-            $tempFolders = @imap_list($this->getImapStream(), $this->imapPath, '*');
-            if (!empty($tempFolders)) {
-                foreach ($tempFolders as $key => $folder) {
-                    $folder            = str_replace($this->imapPath, '', imap_utf8($folder));
-                    $tempFolders[$key] = $folder;
-                }
-            } else {
-                $tempFolders = [];
-            }
-            $this->folders[$this->imapFullPath] = $tempFolders;
-        }
-        return $this->folders[$this->imapFullPath];
-    }
-    public function fetchUnread($folder = null): array
-    {
-        if (null !== $folder) {
-            $this->switchFolder($folder);
-        }
-        return $this->searchMailBox(self::CRITERIA_UNSEEN);
-    }
-    /**
-     * This function performs a search on the mailbox currently opened in the given IMAP stream.
-     * For example, to match all unanswered mails sent by Mom, you'd use: "UNANSWERED FROM mom".
-     * Searches appear to be case insensitive. This list of criteria is from a reading of the UW
-     * c-client source code and may be incomplete or inaccurate (see also RFC2060, section 6.4.4).
-     *
-     * @param string $criteria String, delimited by spaces, in which the following keywords are allowed. Any multi-word arguments (e.g. FROM "joey
-     *                         smith") must be quoted. Results will match all criteria entries.
-     *                         ALL - return all mails matching the rest of the criteria
-     *                         ANSWERED - match mails with the \\ANSWERED flag set
-     *                         BCC "string" - match mails with "string" in the Bcc: field
-     *                         BEFORE "date" - match mails with Date: before "date"
-     *                         BODY "string" - match mails with "string" in the body of the mail
-     *                         CC "string" - match mails with "string" in the Cc: field
-     *                         DELETED - match deleted mails
-     *                         FLAGGED - match mails with the \\FLAGGED (sometimes referred to as Important or Urgent) flag set
-     *                         FROM "string" - match mails with "string" in the From: field
-     *                         KEYWORD "string" - match mails with "string" as a keyword
-     *                         NEW - match new mails
-     *                         OLD - match old mails
-     *                         ON "date" - match mails with Date: matching "date"
-     *                         RECENT - match mails with the \\RECENT flag set
-     *                         SEEN - match mails that have been read (the \\SEEN flag is set)
-     *                         SINCE "date" - match mails with Date: after "date"
-     *                         SUBJECT "string" - match mails with "string" in the Subject:
-     *                         TEXT "string" - match mails with text "string"
-     *                         TO "string" - match mails with "string" in the To:
-     *                         UNANSWERED - match mails that have not been answered
-     *                         UNDELETED - match mails that are not deleted
-     *                         UNFLAGGED - match mails that are not flagged
-     *                         UNKEYWORD "string" - match mails that do not have the keyword "string"
-     *                         UNSEEN - match mails which have not been read yet
-     *
-     * @return array Mails ids
-     */
-    public function searchMailbox($criteria = self::CRITERIA_ALL): array
-    {
-        if (preg_match('/'.self::CRITERIA_UID.' ((\d+):(\d+|\*))/', $criteria, $matches)) {
-            $messages = imap_fetch_overview($this->getImapStream(), $matches[1], FT_UID);
-            $mailIds = [];
-            foreach ($messages as $message) {
-                $mailIds[] = $message->uid;
-            }
-        } else {
-            $mailIds = imap_search($this->getImapStream(), $criteria, SE_UID);
-        }
-        return $mailIds ?: [];
-    }
-    /**
-     * Save mail body.
-     *
-     * @param string $filename
-     */
-    public function saveMail($mailId, $filename = 'email.eml'): bool
-    {
-        return imap_savebody($this->getImapStream(), $filename, $mailId, '', FT_UID);
-    }
-    /**
-     * Marks mails listed in mailId for deletion.
-     */
-    public function deleteMail($mailId): bool
-    {
-        return imap_delete($this->getImapStream(), $mailId, FT_UID);
-    }
-    /**
-     * Move mail to another box.
-     */
-    public function moveMail($mailId, $mailBox): bool
-    {
-        return imap_mail_move($this->getImapStream(), $mailId, $mailBox, CP_UID) && $this->expungeDeletedMails();
-    }
-    /**
-     * Deletes all the mails marked for deletion by imap_delete(), imap_mail_move(), or imap_setflag_full().
-     */
-    public function expungeDeletedMails(): bool
-    {
-        return imap_expunge($this->getImapStream());
-    }
-    /**
-     * Add the flag \Seen to a mail.
-     */
-    public function markMailAsRead($mailId): bool
-    {
-        return $this->setFlag([$mailId], '\\Seen');
-    }
-    /**
-     * Remove the flag \Seen from a mail.
-     */
-    public function markMailAsUnread($mailId): bool
-    {
-        return $this->clearFlag([$mailId], '\\Seen');
-    }
-    /**
-     * Add the flag \Flagged to a mail.
-     */
-    public function markMailAsImportant($mailId): bool
-    {
-        return $this->setFlag([$mailId], '\\Flagged');
-    }
-    /**
-     * Add the flag \Seen to a mails.
-     */
-    public function markMailsAsRead(array $mailIds): bool
-    {
-        return $this->setFlag($mailIds, '\\Seen');
-    }
-    /**
-     * Remove the flag \Seen from some mails.
-     */
-    public function markMailsAsUnread(array $mailIds): bool
-    {
-        return $this->clearFlag($mailIds, '\\Seen');
-    }
-    /**
-     * Add the flag \Flagged to some mails.
-     */
-    public function markMailsAsImportant(array $mailIds): bool
-    {
-        return $this->setFlag($mailIds, '\\Flagged');
-    }
-    /**
-     * Causes a store to add the specified flag to the flags set for the mails in the specified sequence.
-     *
-     * @param string $flag which you can set are \Seen, \Answered, \Flagged, \Deleted, and \Draft as defined by RFC2060
-     */
-    public function setFlag(array $mailsIds, $flag): bool
-    {
-        return imap_setflag_full($this->getImapStream(), implode(',', $mailsIds), $flag, ST_UID);
-    }
-    /**
-     * Cause a store to delete the specified flag to the flags set for the mails in the specified sequence.
-     *
-     * @param string $flag which you can set are \Seen, \Answered, \Flagged, \Deleted, and \Draft as defined by RFC2060
-     */
-    public function clearFlag(array $mailsIds, $flag): bool
-    {
-        return imap_clearflag_full($this->getImapStream(), implode(',', $mailsIds), $flag, ST_UID);
-    }
-    /**
-     * Fetch mail headers for listed mails ids.
-     *
-     * Returns an array of objects describing one mail header each. The object will only define a property if it exists. The possible properties are:
-     *  subject - the mails subject
-     *  from - who sent it
-     *  to - recipient
-     *  date - when was it sent
-     *  message_id - Mail-ID
-     *  references - is a reference to this mail id
-     *  in_reply_to - is a reply to this mail id
-     *  size - size in bytes
-     *  uid - UID the mail has in the mailbox
-     *  msgno - mail sequence number in the mailbox
-     *  recent - this mail is flagged as recent
-     *  flagged - this mail is flagged
-     *  answered - this mail is flagged as answered
-     *  deleted - this mail is flagged for deletion
-     *  seen - this mail is flagged as already read
-     *  draft - this mail is flagged as being a draft
-     *
-     * @return array
-     */
-    public function getMailsInfo(array $mailsIds)
-    {
-        $mails = imap_fetch_overview($this->getImapStream(), implode(',', $mailsIds), FT_UID);
-        if (is_array($mails) && count($mails)) {
-            foreach ($mails as &$mail) {
-                if (isset($mail->subject)) {
-                    $mail->subject = $this->decodeMimeStr($mail->subject, $this->serverEncoding);
-                }
-                if (isset($mail->from)) {
-                    $mail->from = $this->decodeMimeStr($mail->from, $this->serverEncoding);
-                }
-                if (isset($mail->to)) {
-                    $mail->to = $this->decodeMimeStr($mail->to, $this->serverEncoding);
-                }
-            }
-        }
-        return $mails;
-    }
-    /**
-     * Get information about the current mailbox.
-     *
-     * Returns an object with following properties:
-     *  Date - last change (current datetime)
-     *  Driver - driver
-     *  Mailbox - name of the mailbox
-     *  Nmsgs - number of messages
-     *  Recent - number of recent messages
-     *  Unread - number of unread messages
-     *  Deleted - number of deleted messages
-     *  Size - mailbox size
-     */
-    public function getMailboxInfo(): \stdClass
-    {
-        return imap_mailboxmsginfo($this->getImapStream());
-    }
-    /**
-     * Gets mails ids sorted by some criteria.
-     *
-     * Criteria can be one (and only one) of the following constants:
-     *  SORTDATE - mail Date
-     *  SORTARRIVAL - arrival date (default)
-     *  SORTFROM - mailbox in first From address
-     *  SORTSUBJECT - mail subject
-     *  SORTTO - mailbox in first To address
-     *  SORTCC - mailbox in first cc address
-     *  SORTSIZE - size of mail in octets
-     *
-     * @param int  $criteria
-     * @param bool $reverse
-     *
-     * @return array Mails ids
-     */
-    public function sortMails($criteria = SORTARRIVAL, $reverse = true): array|bool
-    {
-        return imap_sort($this->getImapStream(), $criteria, $reverse, SE_UID);
-    }
-    /**
-     * Get mails count in mail box.
-     */
-    public function countMails(): int|bool
-    {
-        return imap_num_msg($this->getImapStream());
-    }
-    /**
-     * Retrieve the quota settings per user.
-     *
-     * @return array - FALSE in the case of call failure
-     */
-    protected function getQuota(): array|bool
-    {
-        return imap_get_quotaroot($this->getImapStream(), 'INBOX');
-    }
-    /**
-     * Return quota limit in KB.
-     *
-     * @return int - FALSE in the case of call failure
-     */
-    public function getQuotaLimit()
-    {
-        $quota = $this->getQuota();
-        if (is_array($quota)) {
-            $quota = $quota['STORAGE']['limit'];
-        }
-        return $quota;
-    }
-    /**
-     * Return quota usage in KB.
-     *
-     * @return int - FALSE in the case of call failure
-     */
-    public function getQuotaUsage()
-    {
-        $quota = $this->getQuota();
-        if (is_array($quota)) {
-            $quota = $quota['STORAGE']['usage'];
-        }
-        return $quota;
-    }
-    /**
-     * Get mail data.
-     *
-     * @param bool $markAsSeen
-     */
-    public function getMail($mailId, $markAsSeen = true): Message
-    {
-        $header     = imap_fetchheader($this->getImapStream(), $mailId, FT_UID);
-        $headObject = imap_rfc822_parse_headers($header);
-        $mail           = new Message();
-        $mail->id       = $mailId;
-        $mail->date     = date('Y-m-d H:i:s', isset($headObject->date) ? strtotime(preg_replace('/\(.*?\)/', '', $headObject->date)) : time());
-        $mail->subject  = isset($headObject->subject) ? $this->decodeMimeStr($headObject->subject, $this->serverEncoding) : null;
-        $mail->fromName = isset($headObject->from[0]->personal) ? $this->decodeMimeStr($headObject->from[0]->personal, $this->serverEncoding)
-            : null;
-        $mail->fromAddress = strtolower($headObject->from[0]->mailbox.'@'.$headObject->from[0]->host);
-        if (isset($headObject->to)) {
-            $toStrings = [];
-            foreach ($headObject->to as $to) {
-                if (!empty($to->mailbox) && !empty($to->host)) {
-                    $toEmail            = strtolower($to->mailbox.'@'.$to->host);
-                    $toName             = isset($to->personal) ? $this->decodeMimeStr($to->personal, $this->serverEncoding) : null;
-                    $toStrings[]        = $toName ? "$toName <$toEmail>" : $toEmail;
-                    $mail->to[$toEmail] = $toName;
-                }
-            }
-            $mail->toString = implode(', ', $toStrings);
-        }
-        if (isset($headObject->cc)) {
-            foreach ($headObject->cc as $cc) {
-                $mail->cc[strtolower($cc->mailbox.'@'.$cc->host)] = isset($cc->personal) ? $this->decodeMimeStr($cc->personal, $this->serverEncoding)
-                    : null;
-            }
-        }
-        if (isset($headObject->reply_to)) {
-            foreach ($headObject->reply_to as $replyTo) {
-                $mail->replyTo[strtolower($replyTo->mailbox.'@'.$replyTo->host)] = isset($replyTo->personal) ? $this->decodeMimeStr(
-                    $replyTo->personal,
-                    $this->serverEncoding
-                ) : null;
-            }
-        }
-        if (isset($headObject->in_reply_to)) {
-            $mail->inReplyTo = $headObject->in_reply_to;
-        }
-        if (isset($headObject->return_path)) {
-            $mail->returnPath = $headObject->return_path;
-        }
-        if (isset($headObject->references)) {
-            $mail->references = explode("\n", $headObject->references);
-        }
-        $mailStructure = imap_fetchstructure($this->getImapStream(), $mailId, FT_UID);
-        if (empty($mailStructure->parts)) {
-            $this->initMailPart($mail, $mailStructure, 0, $markAsSeen);
-        } else {
-            foreach ($mailStructure->parts as $partNum => $partStructure) {
-                $this->initMailPart($mail, $partStructure, $partNum + 1, $markAsSeen);
-            }
-        }
-        $tempArray = explode("\n", $header);
-        $headers = [];
-        foreach ($tempArray as $line) {
-            if (preg_match('/^X-(.*?): (.*?)$/is', trim($line), $matches)) {
-                $headers['x-'.strtolower($matches[1])] = $matches[2];
-            }
-        }
-        $mail->xHeaders = $headers;
-        return $mail;
-    }
-    /**
-     * @param bool|true  $markAsSeen
-     * @param bool|false $isDsn
-     * @param bool|false $isFbl
-     */
-    protected function initMailPart(Message $mail, $partStructure, $partNum, $markAsSeen = true, $isDsn = false, $isFbl = false)
-    {
-        $options = FT_UID;
-        if (!$markAsSeen) {
-            $options |= FT_PEEK;
-        }
-        $data = $partNum
-            ? imap_fetchbody($this->getImapStream(), $mail->id, $partNum, $options)
-            : imap_body(
-                $this->getImapStream(),
-                $mail->id,
-                $options
-            );
-        if (1 == $partStructure->encoding) {
-            $data = imap_utf8($data);
-        } elseif (2 == $partStructure->encoding) {
-            $data = imap_binary($data);
-        } elseif (3 == $partStructure->encoding) {
-            $data = imap_base64($data);
-        } elseif (4 == $partStructure->encoding) {
-            $data = quoted_printable_decode($data);
-        }
-        $params = $this->getParameters($partStructure);
-        $attachmentId = $partStructure->ifid
-            ? trim($partStructure->id, ' <>')
-            : (isset($params['filename']) || isset($params['name']) ? mt_rand().mt_rand() : null);
-        if (!$partNum && TYPETEXT === $partStructure->type) {
-            $attachmentId = null;
-        }
-        if ($attachmentId) {
-            if (isset($this->settings['use_attachments']) && $this->settings['use_attachments']) {
-                if (empty($params['filename']) && empty($params['name'])) {
-                    $fileName = $attachmentId.'.'.strtolower($partStructure->subtype);
-                } else {
-                    $fileName = !empty($params['filename']) ? $params['filename'] : $params['name'];
-                    $fileName = $this->decodeMimeStr($fileName, $this->serverEncoding);
-                    $fileName = $this->decodeRFC2231($fileName, $this->serverEncoding);
-                }
-                $attachment       = new Attachment();
-                $attachment->id   = $attachmentId;
-                $attachment->name = $fileName;
-                if ($this->attachmentsDir) {
-                    $replace = [
-                        '/\s/'                   => '_',
-                        '/[^0-9a-z-_\.]/iu' => '',
-                        '/_+/'                   => '_',
-                        '/(^_)|(_$)/'            => '',
-                    ];
-                    $fileSysName = preg_replace(
-                        '~[\\\\/]~',
-                        '',
-                        $mail->id.'_'.$attachmentId.'_'.preg_replace(array_keys($replace), $replace, $fileName)
-                    );
-                    $attachment->filePath = $this->attachmentsDir.DIRECTORY_SEPARATOR.$fileSysName;
-                    file_put_contents($attachment->filePath, $data);
-                }
-                $mail->addAttachment($attachment);
-            }
-        } else {
-            if (!empty($params['charset'])) {
-                $data = $this->convertStringEncoding($data, $params['charset'], $this->serverEncoding);
-            }
-            if (!empty($data)) {
-                $subtype = !empty($partStructure->ifsubtype)
-                    ? strtolower($partStructure->subtype)
-                    : '';
-                switch ($partStructure->type) {
-                    case TYPETEXT:
-                        match ($subtype) {
-                            'plain' => $mail->textPlain .= $data,
-                            default => $mail->textHtml .= $data,
-                        };
-                        break;
-                    case TYPEMULTIPART:
-                        if (
-                            'report' != $subtype
-                            || empty($params['report-type'])
-                        ) {
-                            break;
-                        }
-                        $reportType = strtolower($params['report-type']);
-                        switch ($reportType) {
-                            case 'delivery-status':
-                                $mail->dsnMessage = trim($data);
-                                $isDsn            = true;
-                                break;
-                            case 'feedback-report':
-                                $mail->fblMessage = trim($data);
-                                $isFbl            = true;
-                                break;
-                            default:
-                        }
-                        break;
-                    case TYPEMESSAGE:
-                        if ($isDsn || ('delivery-status' == $subtype)) {
-                            $mail->dsnReport = $data;
-                        } elseif ($isFbl || ('feedback-report' == $subtype)) {
-                            $mail->fblReport = $data;
-                        } else {
-                            $mail->textPlain .= trim($data);
-                        }
-                        break;
-                    default:
-                }
-            }
-        }
-        if (!empty($partStructure->parts)) {
-            foreach ($partStructure->parts as $subPartNum => $subPartStructure) {
-                if (2 == $partStructure->type && 'RFC822' == $partStructure->subtype) {
-                    $this->initMailPart($mail, $subPartStructure, $partNum, $markAsSeen, $isDsn, $isFbl);
-                } else {
-                    $this->initMailPart($mail, $subPartStructure, $partNum.'.'.($subPartNum + 1), $markAsSeen, $isDsn, $isFbl);
-                }
-            }
-        }
-    }
-    protected function getParameters($partStructure): array
-    {
-        $params = [];
-        if (!empty($partStructure->parameters)) {
-            foreach ($partStructure->parameters as $param) {
-                $params[strtolower($param->attribute)] = $param->value;
-            }
-        }
-        if (!empty($partStructure->dparameters)) {
-            foreach ($partStructure->dparameters as $param) {
-                $paramName = strtolower(preg_match('~^(.*?)\*~', $param->attribute, $matches) ? $matches[1] : $param->attribute);
-                if (isset($params[$paramName])) {
-                    $params[$paramName] .= $param->value;
-                } else {
-                    $params[$paramName] = $param->value;
-                }
-            }
-        }
-        return $params;
-    }
-    /**
-     * @param string $charset
-     */
-    protected function decodeMimeStr($string, $charset = 'utf-8'): string
-    {
-        $newString = '';
-        $elements  = imap_mime_header_decode($string);
-        for ($i = 0; $i < count($elements); ++$i) {
-            if ('default' == $elements[$i]->charset) {
-                $elements[$i]->charset = 'iso-8859-1';
-            }
-            $newString .= $this->convertStringEncoding($elements[$i]->text, $elements[$i]->charset, $charset);
-        }
-        return $newString;
-    }
-    protected function isUrlEncoded($string): bool
-    {
-        $hasInvalidChars = preg_match('#[^%a-zA-Z0-9\-_\.\+]#', $string);
-        $hasEscapedChars = preg_match('#%[a-zA-Z0-9]{2}#', $string);
-        return !$hasInvalidChars && $hasEscapedChars;
-    }
-    /**
-     * @param string $charset
-     *
-     * @return string
-     */
-    protected function decodeRFC2231($string, $charset = 'utf-8')
-    {
-        if (preg_match("/^(.*?)'.*?'(.*?)$/", $string, $matches)) {
-            $encoding = $matches[1];
-            $data     = $matches[2];
-            if ($this->isUrlEncoded($data)) {
-                $string = $this->convertStringEncoding(urldecode($data), $encoding, $charset);
-            }
-        }
-        return $string;
-    }
-    /**
-     * Converts a string from one encoding to another.
-     *
-     * @param string $string
-     * @param string $fromEncoding
-     * @param string $toEncoding
-     *
-     * @return string Converted string if conversion was successful, or the original string if not
-     */
-    protected function convertStringEncoding($string, $fromEncoding, $toEncoding)
-    {
-        $convertedString = null;
-        if ($string && $fromEncoding != $toEncoding) {
-            $convertedString = @iconv($fromEncoding, $toEncoding.'//IGNORE', $string);
-            if (!$convertedString && extension_loaded('mbstring')) {
-                $convertedString = @mb_convert_encoding($string, $toEncoding, $fromEncoding);
-            }
-        }
-        return $convertedString ?: $string;
-    }
-    /**
-     * Close IMAP connection.
-     */
-    protected function disconnect()
-    {
-        if ($this->isConnected()) {
-            imap_errors();
-            imap_alerts();
-            @imap_close($this->imapStream, CL_EXPUNGE);
-        }
-    }
-    private function createAttachmentsDir(PathsHelper $pathsHelper): void
-    {
-        if (!isset($this->settings['use_attachments']) || !$this->settings['use_attachments']) {
-            return;
-        }
-        $this->attachmentsDir = $pathsHelper->getSystemPath('tmp', true);
-        if (!file_exists($this->attachmentsDir)) {
-            mkdir($this->attachmentsDir);
-        }
-        $this->attachmentsDir .= '/attachments';
-        if (!file_exists($this->attachmentsDir)) {
-            mkdir($this->attachmentsDir);
-        }
-    }
-    /**
-     * Disconnect on destruct.
-     */
-    public function __destruct()
-    {
-        $this->disconnect();
-    }
-}

--- a/app/bundles/EmailBundle/Stats/Helper/BouncedHelper.php
+++ b//dev/null
@@ -1,34 +0,0 @@
-<?php
-namespace Mautic\EmailBundle\Stats\Helper;
-use Mautic\EmailBundle\Stats\FetchOptions\EmailStatOptions;
-use Mautic\LeadBundle\Entity\DoNotContact;
-use Mautic\StatsBundle\Aggregate\Collection\StatCollection;
-class BouncedHelper extends AbstractHelper
-{
-    public const NAME = 'email-bounced';
-    public function getName(): string
-    {
-        return self::NAME;
-    }
-    /**
-     * @throws \Exception
-     */
-    public function generateStats(\DateTime $fromDateTime, \DateTime $toDateTime, EmailStatOptions $options, StatCollection $statCollection): void
-    {
-        $query = $this->getQuery($fromDateTime, $toDateTime);
-        $q     = $query->prepareTimeDataQuery('lead_donotcontact', 'date_added');
-        $q->andWhere('t.channel = :channel')
-            ->setParameter('channel', 'email')
-            ->andWhere($q->expr()->eq('t.reason', ':reason'))
-            ->setParameter('reason', DoNotContact::BOUNCED);
-        $this->limitQueryToEmailIds($q, $options->getEmailIds(), 'channel_id', 't');
-        $q->join('t', MAUTIC_TABLE_PREFIX.'email_stats', 'es', 't.channel_id = es.email_id AND t.channel = \'email\' AND t.lead_id = es.lead_id');
-        if (!$options->canViewOthers()) {
-            $this->limitQueryToCreator($q, 'es.email_id');
-        }
-        $this->addCompanyFilter($q, $options->getCompanyId());
-        $this->addCampaignFilter($q, $options->getCampaignId(), 'es');
-        $this->addSegmentFilter($q, $options->getSegmentId(), 'es');
-        $this->fetchAndBindToCollection($q, $statCollection);
-    }
-}

--- a/app/bundles/EmailBundle/Stats/Helper/UnsubscribedHelper.php
+++ b//dev/null
@@ -1,34 +0,0 @@
-<?php
-namespace Mautic\EmailBundle\Stats\Helper;
-use Mautic\EmailBundle\Stats\FetchOptions\EmailStatOptions;
-use Mautic\LeadBundle\Entity\DoNotContact;
-use Mautic\StatsBundle\Aggregate\Collection\StatCollection;
-class UnsubscribedHelper extends AbstractHelper
-{
-    public const NAME = 'email-unsubscribed';
-    public function getName(): string
-    {
-        return self::NAME;
-    }
-    /**
-     * @throws \Exception
-     */
-    public function generateStats(\DateTime $fromDateTime, \DateTime $toDateTime, EmailStatOptions $options, StatCollection $statCollection): void
-    {
-        $query = $this->getQuery($fromDateTime, $toDateTime);
-        $q     = $query->prepareTimeDataQuery('lead_donotcontact', 'date_added');
-        $q->andWhere('t.channel = :channel')
-            ->setParameter('channel', 'email')
-            ->andWhere($q->expr()->eq('t.reason', ':reason'))
-            ->setParameter('reason', DoNotContact::UNSUBSCRIBED);
-        $this->limitQueryToEmailIds($q, $options->getEmailIds(), 'channel_id', 't');
-        $q->join('t', MAUTIC_TABLE_PREFIX.'email_stats', 'es', 't.channel_id = es.email_id AND t.channel = \'email\' AND t.lead_id = es.lead_id');
-        if (!$options->canViewOthers()) {
-            $this->limitQueryToCreator($q, 'es.email_id');
-        }
-        $this->addCompanyFilter($q, $options->getCompanyId());
-        $this->addCampaignFilter($q, $options->getCampaignId(), 'es');
-        $this->addSegmentFilter($q, $options->getSegmentId(), 'es');
-        $this->fetchAndBindToCollection($q, $statCollection);
-    }
-}

--- a/app/bundles/UserBundle/Config/services.php
+++ b//dev/null
@@ -1,66 +0,0 @@
-<?php
-declare(strict_types=1);
-use Mautic\CoreBundle\DependencyInjection\MauticCoreExtension;
-use Mautic\UserBundle\EventListener\ApiUserSubscriber;
-use Mautic\UserBundle\Security\Authentication\Token\Permissions\TokenPermissions;
-use Mautic\UserBundle\Security\Authenticator\PluginAuthenticator;
-use Mautic\UserBundle\Security\Authenticator\SsoAuthenticator;
-use Mautic\UserBundle\Security\EntryPoint\MainEntryPoint;
-use function Symfony\Component\DependencyInjection\Loader\Configurator\abstract_arg;
-use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
-use function Symfony\Component\DependencyInjection\Loader\Configurator\service;
-return function (ContainerConfigurator $configurator): void {
-    $services = $configurator->services()
-        ->defaults()
-        ->autowire()
-        ->autoconfigure()
-        ->public();
-    $excludes = [
-    ];
-    $services->load('Mautic\\UserBundle\\', '../')
-        ->exclude('../{'.implode(',', array_merge(MauticCoreExtension::DEFAULT_EXCLUDES, $excludes)).'}');
-    $services->load('Mautic\\UserBundle\\Entity\\', '../Entity/*Repository.php')
-        ->tag(Doctrine\Bundle\DoctrineBundle\DependencyInjection\Compiler\ServiceRepositoryCompilerPass::REPOSITORY_SERVICE_TAG);
-    $services->set('security.authenticator.mautic_sso', SsoAuthenticator::class)
-        ->abstract()
-        ->args([
-            '$httpUtils'      => service('security.http_utils'),
-            '$userProvider'   => abstract_arg('user provider'),
-            '$successHandler' => abstract_arg('authentication success handler'),
-            '$failureHandler' => abstract_arg('authentication failure handler'),
-            '$options'        => abstract_arg('options'),
-        ]);
-    $services->set('security.authenticator.mautic_api', PluginAuthenticator::class)
-        ->abstract()
-        ->args([
-            '$oAuth2' => service('fos_oauth_server.server'),
-        ]);
-    $services->set('security.token.permissions', TokenPermissions::class);
-    $services->load('Mautic\\UserBundle\\Security\\EntryPoint\\', '../Security/EntryPoint/*.php');
-    $services->load('Mautic\\UserBundle\\Security\\Authentication\\Token\\Permissions\\', '../Security/Authentication/Token/Permissions/*.php');
-    $services->alias(Mautic\UserBundle\Entity\UserTokenRepositoryInterface::class, Mautic\UserBundle\Entity\UserTokenRepository::class);
-    $services->alias('mautic.user.model.role', Mautic\UserBundle\Model\RoleModel::class);
-    $services->alias('mautic.user.model.user', Mautic\UserBundle\Model\UserModel::class);
-    $services->alias('mautic.user.repository.user_token', Mautic\UserBundle\Entity\UserTokenRepository::class);
-    $services->alias('mautic.user.repository', Mautic\UserBundle\Entity\UserRepository::class);
-    $services->alias('mautic.permission.repository', Mautic\UserBundle\Entity\PermissionRepository::class);
-    $services->alias('mautic.user.model.password_strength_estimator', Mautic\UserBundle\Model\PasswordStrengthEstimatorModel::class);
-    $services->get(Mautic\UserBundle\Form\Validator\Constraints\NotWeakValidator::class)->tag('validator.constraint_validator');
-    $services->load('Mautic\\UserBundle\\Security\\SAML\Store\\Request\\', '../Security/SAML/Store/Request/*.php');
-    $services->get(Mautic\UserBundle\Security\SAML\Store\Request\RequestStateStore::class)
-        ->arg('$prefix', '%lightsaml.store.request_session_prefix%')
-        ->arg('$suffix', '%lightsaml.store.request_session_sufix%');
-    $services->get(MainEntryPoint::class)->arg('$samlEnabled', '%env(MAUTIC_SAML_ENABLED)%');
-    $services->get(ApiUserSubscriber::class)->arg('$userProvider', service('security.user_providers'));
-    $services->alias(LightSaml\SymfonyBridgeBundle\Bridge\Container\BuildContainer::class, 'lightsaml.container.build');
-    $services->load('LightSaml\\SpBundle\\Controller\\', '%kernel.project_dir%/vendor/javer/sp-bundle/src/LightSaml/SpBundle/Controller/*.php')
-        ->tag('controller.service_arguments');
-    $services->set('mautic.security.authenticator.form_login.decorator', Mautic\UserBundle\Security\TimingSafeFormLoginAuthenticator::class)
-        ->decorate('security.authenticator.form_login.main')
-        ->args([
-            service('.inner'),
-            service('mautic.user.provider'),
-            service('security.password_hasher_factory'),
-            [], // This will be replaced by the compiler pass
-        ]);
-};

--- a/app/bundles/UserBundle/DependencyInjection/Compiler/FormLoginAuthenticatorOptionsPass.php
+++ b//dev/null
@@ -1,22 +0,0 @@
-<?php
-declare(strict_types=1);
-namespace Mautic\UserBundle\DependencyInjection\Compiler;
-use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
-use Symfony\Component\DependencyInjection\ContainerBuilder;
-class FormLoginAuthenticatorOptionsPass implements CompilerPassInterface
-{
-    public function process(ContainerBuilder $container): void
-    {
-        if (!$container->has('mautic.security.authenticator.form_login.decorator')) {
-            return;
-        }
-        $decoratedServiceId = 'mautic.security.authenticator.form_login.decorator.inner';
-        if (!$container->has($decoratedServiceId)) {
-            return;
-        }
-        $decoratedService = $container->getDefinition($decoratedServiceId);
-        $options          = $decoratedService->getArgument(4);
-        $decorator = $container->getDefinition('mautic.security.authenticator.form_login.decorator');
-        $decorator->replaceArgument(3, $options);
-    }
-}

--- a/app/bundles/UserBundle/MauticUserBundle.php
+++ b//dev/null
@@ -1,25 +0,0 @@
-<?php
-namespace Mautic\UserBundle;
-use Mautic\UserBundle\DependencyInjection\Compiler\FormLoginAuthenticatorOptionsPass;
-use Mautic\UserBundle\DependencyInjection\Compiler\OAuthReplacePass;
-use Mautic\UserBundle\DependencyInjection\Compiler\SsoAuthenticatorPass;
-use Mautic\UserBundle\DependencyInjection\Firewall\Factory\MauticSsoFactory;
-use Mautic\UserBundle\DependencyInjection\Firewall\Factory\PluginFactory;
-use Symfony\Bundle\SecurityBundle\DependencyInjection\SecurityExtension;
-use Symfony\Component\DependencyInjection\Compiler\PassConfig;
-use Symfony\Component\DependencyInjection\ContainerBuilder;
-use Symfony\Component\HttpKernel\Bundle\Bundle;
-class MauticUserBundle extends Bundle
-{
-    public function build(ContainerBuilder $container): void
-    {
-        parent::build($container);
-        $extension = $container->getExtension('security');
-        \assert($extension instanceof SecurityExtension);
-        $extension->addAuthenticatorFactory(new PluginFactory());
-        $extension->addAuthenticatorFactory(new MauticSsoFactory());
-        $container->addCompilerPass(new OAuthReplacePass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
-        $container->addCompilerPass(new SsoAuthenticatorPass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
-        $container->addCompilerPass(new FormLoginAuthenticatorOptionsPass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
-    }
-}

--- a/app/bundles/UserBundle/Security/TimingSafeFormLoginAuthenticator.php
+++ b//dev/null
@@ -1,125 +0,0 @@
-<?php
-declare(strict_types=1);
-namespace Mautic\UserBundle\Security;
-use Mautic\UserBundle\Entity\User;
-use Symfony\Component\HttpFoundation\Request;
-use Symfony\Component\HttpFoundation\Response;
-use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
-use Symfony\Component\PasswordHasher\Hasher\PasswordHasherFactoryInterface;
-use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
-use Symfony\Component\Security\Core\Exception\AuthenticationException;
-use Symfony\Component\Security\Core\Exception\UserNotFoundException;
-use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
-use Symfony\Component\Security\Core\User\UserInterface;
-use Symfony\Component\Security\Core\User\UserProviderInterface;
-use Symfony\Component\Security\Http\Authenticator\AuthenticatorInterface;
-use Symfony\Component\Security\Http\Authenticator\FormLoginAuthenticator;
-use Symfony\Component\Security\Http\Authenticator\InteractiveAuthenticatorInterface;
-use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
-use Symfony\Component\Security\Http\Authenticator\Passport\Badge\PasswordUpgradeBadge;
-use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
-use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
-use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
-use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
-use Symfony\Component\Security\Http\EntryPoint\AuthenticationEntryPointInterface;
-use Symfony\Component\Security\Http\SecurityRequestAttributes;
-class TimingSafeFormLoginAuthenticator implements AuthenticatorInterface, AuthenticationEntryPointInterface, InteractiveAuthenticatorInterface
-{
-    /**
-     * @var array<mixed>
-     */
-    private array $options;
-    /**
-     * @param array<mixed> $options
-     */
-    public function __construct(private FormLoginAuthenticator $authenticator, private UserProviderInterface $userProvider, private PasswordHasherFactoryInterface $passwordHasherFactory, array $options)
-    {
-        $this->authenticator         = $authenticator;
-        $this->userProvider          = $userProvider;
-        $this->passwordHasherFactory = $passwordHasherFactory;
-        $this->options               = array_merge([
-            'username_parameter' => '_username',
-            'password_parameter' => '_password',
-            'check_path'         => '/login_check',
-            'post_only'          => true,
-            'form_only'          => false,
-            'enable_csrf'        => false,
-            'csrf_parameter'     => '_csrf_token',
-            'csrf_token_id'      => 'authenticate',
-        ], $options);
-    }
-    public function supports(Request $request): ?bool
-    {
-        return $this->authenticator->supports($request);
-    }
-    public function authenticate(Request $request): Passport
-    {
-        $credentials           = $this->getCredentials($request);
-        $passwordHasherFactory = $this->passwordHasherFactory;
-        $userLoader            = function (string $identifier) use ($passwordHasherFactory, $credentials): UserInterface {
-            try {
-                return $this->userProvider->loadUserByIdentifier($identifier);
-            } catch (UserNotFoundException $e) {
-                $user = new User();
-                $passwordHasherFactory->getPasswordHasher($user)->verify('$2y$13$aAwXNyqA87lcXQQuk8Cp6eo2amRywLct29oG2uWZ8lYBeamFZ8UhK', $credentials['password']);
-                throw $e;
-            }
-        };
-        $userBadge = new UserBadge($credentials['username'], $userLoader);
-        $passport  = new Passport($userBadge, new PasswordCredentials($credentials['password']), [new RememberMeBadge()]);
-        if ($this->options['enable_csrf']) {
-            $passport->addBadge(new CsrfTokenBadge($this->options['csrf_token_id'], $credentials['csrf_token']));
-        }
-        if ($this->userProvider instanceof PasswordUpgraderInterface) {
-            $passport->addBadge(new PasswordUpgradeBadge($credentials['password'], $this->userProvider));
-        }
-        return $passport;
-    }
-    public function createToken(Passport $passport, string $firewallName): TokenInterface
-    {
-        return $this->authenticator->createToken($passport, $firewallName);
-    }
-    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
-    {
-        return $this->authenticator->onAuthenticationSuccess($request, $token, $firewallName);
-    }
-    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
-    {
-        return $this->authenticator->onAuthenticationFailure($request, $exception);
-    }
-    public function start(Request $request, ?AuthenticationException $authException = null): Response
-    {
-        return $this->authenticator->start($request, $authException);
-    }
-    public function isInteractive(): bool
-    {
-        return $this->authenticator->isInteractive();
-    }
-    /**
-     * @return array<mixed>
-     */
-    private function getCredentials(Request $request): array
-    {
-        $credentials               = [];
-        $credentials['csrf_token'] = $request->get($this->options['csrf_parameter']);
-        if ($this->options['post_only']) {
-            $credentials['username'] = $request->request->get($this->options['username_parameter']);
-            $credentials['password'] = $request->request->get($this->options['password_parameter'], '');
-        } else {
-            $credentials['username'] = $request->get($this->options['username_parameter']);
-            $credentials['password'] = $request->get($this->options['password_parameter'], '');
-        }
-        if (!\is_string($credentials['username']) && !$credentials['username'] instanceof \Stringable) {
-            throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['username_parameter'], \gettype($credentials['username'])));
-        }
-        $credentials['username'] = trim($credentials['username']);
-        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $credentials['username']);
-        if (!\is_string($credentials['password']) && (!\is_object($credentials['password']) || !method_exists($credentials['password'], '__toString'))) {
-            throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['password_parameter'], \gettype($credentials['password'])));
-        }
-        if (!\is_string($credentials['csrf_token'] ?? '') && (!\is_object($credentials['csrf_token']) || !method_exists($credentials['csrf_token'], '__toString'))) {
-            throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['csrf_parameter'], \gettype($credentials['csrf_token'])));
-        }
-        return $credentials;
-    }
-}

--- a/app/bundles/WebhookBundle/Assets/js/webhook.js
+++ b//dev/null
@@ -1,42 +0,0 @@
-Mautic.sendHookTest = function() {
-    var url = mQuery('#webhook_webhookUrl').val();
-    var secret = mQuery('#webhook_secret').val();
-    var eventTypes = mQuery("#event-types input[type='checkbox']");
-    var selectedTypes = [];
-    eventTypes.each(function() {
-        var item = mQuery(this);
-        if (item.is(':checked')) {
-            selectedTypes.push(item.val());
-        }
-    });
-    var data = {
-        action: 'webhook:sendHookTest',
-        url: url,
-        secret: secret,
-        types: selectedTypes
-    };
-    var spinner = mQuery('#spinner');
-    spinner.removeClass('hide');
-    mQuery.ajax({
-        url: mauticAjaxUrl,
-        data: data,
-        type: 'POST',
-        dataType: "json",
-        success: function(response) {
-            if (response.html) {
-                mQuery('#tester').html(response.html);
-            }
-        },
-        error: function (response, textStatus, errorThrown) {
-            console.log(response.responseJSON);
-            if (response.responseJSON.html) {
-                mQuery('#tester').html(response.responseJSON.html);
-            } else {
-                Mautic.processAjaxError(response, textStatus, errorThrown);
-            }
-        },
-        complete: function(response) {
-            spinner.addClass('hide');
-        }
-    })
-};

--- a/app/bundles/WebhookBundle/Config/config.php
+++ b//dev/null
@@ -1,75 +0,0 @@
-<?php
-return [
-    'routes' => [
-        'main' => [
-            'mautic_webhook_index' => [
-                'path'       => '/webhooks/{page}',
-                'controller' => 'Mautic\WebhookBundle\Controller\WebhookController::indexAction',
-            ],
-            'mautic_webhook_action' => [
-                'path'       => '/webhooks/{objectAction}/{objectId}',
-                'controller' => 'Mautic\WebhookBundle\Controller\WebhookController::executeAction',
-            ],
-        ],
-        'api' => [
-            'mautic_api_webhookstandard' => [
-                'standard_entity' => true,
-                'name'            => 'hooks',
-                'path'            => '/hooks',
-                'controller'      => Mautic\WebhookBundle\Controller\Api\WebhookApiController::class,
-            ],
-            'mautic_api_webhookevents' => [
-                'path'       => '/hooks/triggers',
-                'controller' => 'Mautic\WebhookBundle\Controller\Api\WebhookApiController::getTriggersAction',
-            ],
-        ],
-    ],
-    'menu' => [
-        'admin' => [
-            'items' => [
-                'mautic.webhook.webhooks' => [
-                    'id'        => 'mautic_webhook_root',
-                    'access'    => ['webhook:webhooks:viewown', 'webhook:webhooks:viewother'],
-                    'route'     => 'mautic_webhook_index',
-                    'parent'    => 'mautic.core.integrations',
-                    'iconClass' => 'ri-webhook-fill',
-                ],
-            ],
-        ],
-    ],
-    'services' => [
-        'others' => [
-            'mautic.webhook.notificator.webhookkillnotificator' => [
-                'class'     => Mautic\WebhookBundle\Notificator\WebhookKillNotificator::class,
-                'arguments' => [
-                    'translator',
-                    'router',
-                    'mautic.core.model.notification',
-                    'doctrine.orm.entity_manager',
-                    'mautic.helper.mailer',
-                    'mautic.helper.core_parameters',
-                ],
-            ],
-            'mautic.webhook.campaign.helper' => [
-                'class'     => Mautic\WebhookBundle\Helper\CampaignHelper::class,
-                'arguments' => [
-                    'mautic.http.client',
-                    'mautic.lead.model.company',
-                    'event_dispatcher',
-                ],
-            ],
-        ],
-    ],
-    'parameters' => [
-        'webhook_limit'                        => 10, // How many entities can be sent in one webhook
-        'webhook_time_limit'                   => 600, // How long the webhook processing can run in seconds
-        'webhook_log_max'                      => 1000, // How many recent logs to keep
-        'clean_webhook_logs_in_background'     => false,
-        'webhook_disable_limit'                => 100, // How many times the webhook response can fail until the webhook will be unpublished
-        'webhook_timeout'                      => 15, // How long the CURL request can wait for response before Mautic hangs up. In seconds
-        'queue_mode'                           => Mautic\WebhookBundle\Model\WebhookModel::IMMEDIATE_PROCESS, // Trigger the webhook immediately or queue it for faster response times
-        'events_orderby_dir'                   => Doctrine\Common\Collections\Order::Ascending->value, // Order the queued events chronologically or the other way around
-        'webhook_email_details'                => true, // If enabled, email related webhooks send detailed data
-        'webhook_allowed_private_addresses'    => [],
-    ],
-];

--- a/app/bundles/WebhookBundle/Controller/AjaxController.php
+++ b//dev/null
@@ -1,121 +0,0 @@
-<?php
-namespace Mautic\WebhookBundle\Controller;
-use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
-use Mautic\CoreBundle\Helper\InputHelper;
-use Mautic\CoreBundle\Helper\PathsHelper;
-use Mautic\WebhookBundle\Exception\PrivateAddressException;
-use Mautic\WebhookBundle\Http\Client;
-use Symfony\Component\HttpFoundation\JsonResponse;
-use Symfony\Component\HttpFoundation\Request;
-use Symfony\Component\HttpFoundation\Response;
-class AjaxController extends CommonAjaxController
-{
-    public function sendHookTestAction(Request $request, Client $client, PathsHelper $pathsHelper): JsonResponse
-    {
-        try {
-            return $this->processWebhookTest($request, $client, $pathsHelper);
-        } catch (PrivateAddressException) {
-            return $this->createErrorResponse(
-                'mautic.webhook.error.private_address'
-            );
-        } catch (\Exception) {
-            return $this->createErrorResponse(
-                'mautic.webhook.label.warning'
-            );
-        }
-    }
-    private function processWebhookTest(Request $request, Client $client, PathsHelper $pathsHelper): JsonResponse
-    {
-        $url = $this->validateUrl($request);
-        if (!$url) {
-            return $this->createErrorResponse('mautic.webhook.label.no.url');
-        }
-        $selectedTypes        = InputHelper::cleanArray($request->request->all()['types']) ?? [];
-        $payloadPaths         = $this->getPayloadPaths($selectedTypes, $pathsHelper);
-        $payload              = $this->loadPayloads($payloadPaths);
-        $payload['timestamp'] = (new \DateTimeImmutable())->format('c');
-        $secret               = InputHelper::string($request->request->get('secret'));
-        $response = $client->post($url, $payload, $secret);
-        return $this->createResponseFromStatusCode($response->getStatusCode());
-    }
-    private function validateUrl(Request $request): ?string
-    {
-        $url = InputHelper::url($request->request->get('url'));
-        return '' !== $url ? $url : null;
-    }
-    private function createResponseFromStatusCode(int $statusCode): JsonResponse
-    {
-        $isSuccess = str_starts_with((string) $statusCode, '2');
-        $message   = $isSuccess
-            ? 'mautic.webhook.label.success'
-            : 'mautic.webhook.label.warning';
-        $cssClass = $isSuccess ? 'has-success' : 'has-error';
-        return $this->createJsonResponse($message, $cssClass);
-    }
-    private function createErrorResponse(string $message): JsonResponse
-    {
-        return $this->createJsonResponse($message, 'has-error', Response::HTTP_BAD_REQUEST);
-    }
-    private function createJsonResponse(
-        string $message,
-        string $cssClass,
-        int $status = Response::HTTP_OK,
-    ): JsonResponse {
-        $html = sprintf(
-            '<div class="%s"><span class="help-block">%s</span></div>',
-            $cssClass,
-            $this->translator->trans($message)
-        );
-        return $this->sendJsonResponse(
-            ['html' => $html],
-            $status
-        );
-    }
-    /*
-     * Get an array of all the payload paths we need to load
-     *
-     * @param $types array
-     * @return array
-     */
-    /**
-     * @return non-falsy-string[]
-     */
-    public function getPayloadPaths($types, PathsHelper $pathsHelper): array
-    {
-        $payloadPaths = [];
-        foreach ($types as $type) {
-            $typePath = explode('_', $type);
-            $prefix = $typePath[0];
-            unset($typePath[0]);
-            $eventName = implode('_', $typePath);
-            $payloadPath = $pathsHelper->getSystemPath('bundles', true);
-            if (strpos('plugin.', $prefix)) {
-                $payloadPath = $pathsHelper->getSystemPath('plugins', true);
-            }
-            $prefixParts = explode('.', $prefix);
-            $bundleName = array_pop($prefixParts);
-            $payloadPath .= '/'.ucfirst($bundleName).'Bundle/Assets/WebhookPayload/'.$bundleName.'_'.$eventName.'.json';
-            $payloadPaths[$type] = $payloadPath;
-        }
-        return $payloadPaths;
-    }
-    /*
-     * Iterate through the paths and get the json payloads
-     *
-     * @param  $paths array
-     * @return $payload array
-     */
-    /**
-     * @return mixed[]
-     */
-    public function loadPayloads($paths): array
-    {
-        $payloads = [];
-        foreach ($paths as $key => $path) {
-            if (file_exists($path)) {
-                $payloads[$key] = json_decode(file_get_contents($path), true);
-            }
-        }
-        return $payloads;
-    }
-}

--- a/app/bundles/WebhookBundle/Exception/PrivateAddressException.php
+++ b//dev/null
@@ -1,11 +0,0 @@
-<?php
-declare(strict_types=1);
-namespace Mautic\WebhookBundle\Exception;
-class PrivateAddressException extends \Exception
-{
-    private const DEFAULT_MESSAGE = 'Access to private addresses is not allowed.';
-    public function __construct(string $message = self::DEFAULT_MESSAGE, int $code = 0, \Throwable $previous = null)
-    {
-        parent::__construct($message, $code, $previous);
-    }
-}

--- a/app/bundles/WebhookBundle/Form/Type/ConfigType.php
+++ b//dev/null
@@ -1,82 +0,0 @@
-<?php
-namespace Mautic\WebhookBundle\Form\Type;
-use Doctrine\Common\Collections\Order;
-use Mautic\CoreBundle\Form\DataTransformer\ArrayLinebreakTransformer;
-use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
-use Symfony\Component\Form\AbstractType;
-use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
-use Symfony\Component\Form\Extension\Core\Type\TextareaType;
-use Symfony\Component\Form\FormBuilderInterface;
-use Symfony\Component\Validator\Constraints\NotBlank;
-/**
- * @extends AbstractType<array<mixed>>
- */
-class ConfigType extends AbstractType
-{
-    public function buildForm(FormBuilderInterface $builder, array $options): void
-    {
-        $builder->add('queue_mode', ChoiceType::class, [
-            'choices' => [
-                'mautic.webhook.config.immediate_process' => 'immediate_process',
-                'mautic.webhook.config.cron_process'      => 'command_process',
-            ],
-            'label' => 'mautic.webhook.config.form.queue.mode',
-            'attr'  => [
-                'class'   => 'form-control',
-                'tooltip' => 'mautic.webhook.config.form.queue.mode.tooltip',
-            ],
-            'placeholder' => false,
-            'constraints' => [
-                new NotBlank(
-                    [
-                        'message' => 'mautic.core.value.required',
-                    ]
-                ),
-            ],
-        ]);
-        $builder->add('events_orderby_dir', ChoiceType::class, [
-            'choices' => [
-                'mautic.webhook.config.event.orderby.chronological'         => Order::Ascending->value,
-                'mautic.webhook.config.event.orderby.reverse.chronological' => Order::Descending->value,
-            ],
-            'label' => 'mautic.webhook.config.event.orderby',
-            'attr'  => [
-                'class'   => 'form-control',
-                'tooltip' => 'mautic.webhook.config.event.orderby.tooltip',
-            ],
-            'required'          => false,
-        ]);
-        $builder->add(
-            'webhook_email_details',
-            YesNoButtonGroupType::class,
-            [
-                'label' => 'mautic.webhook.config.email.details',
-                'data'  => (bool) ($options['data']['webhook_email_details'] ?? null),
-                'attr'  => [
-                    'class'   => 'form-control',
-                    'tooltip' => 'mautic.webhook.config.email.details.tooltip',
-                ],
-            ]
-        );
-        $builder->add(
-            $builder->create(
-                'webhook_allowed_private_addresses',
-                TextareaType::class,
-                [
-                    'label'      => 'mautic.webhook.config.allowed_private_addresses',
-                    'label_attr' => ['class' => 'control-label'],
-                    'attr'       => [
-                        'class'   => 'form-control',
-                        'tooltip' => 'mautic.webhook.config.allowed_private_addresses.tooltip',
-                        'rows'    => 8,
-                    ],
-                    'required' => false,
-                ]
-            )->addViewTransformer(new ArrayLinebreakTransformer())
-        );
-    }
-    public function getBlockPrefix(): string
-    {
-        return 'webhookconfig';
-    }
-}

--- a/app/bundles/WebhookBundle/Http/Client.php
+++ b//dev/null
@@ -1,36 +0,0 @@
-<?php
-namespace Mautic\WebhookBundle\Http;
-use GuzzleHttp\Client as GuzzleClient;
-use GuzzleHttp\Psr7\Request;
-use Mautic\CoreBundle\Helper\CoreParametersHelper;
-use Mautic\CoreBundle\Helper\PrivateAddressChecker;
-use Mautic\WebhookBundle\Exception\PrivateAddressException;
-use Psr\Http\Message\ResponseInterface;
-class Client
-{
-    public function __construct(
-        private CoreParametersHelper $coreParametersHelper,
-        private GuzzleClient $httpClient,
-        private PrivateAddressChecker $privateAddressChecker,
-    ) {
-    }
-    /**
-     * @throws \Http\Client\Exception
-     */
-    public function post($url, array $payload, string $secret = null): ResponseInterface
-    {
-        $jsonPayload = json_encode($payload);
-        $signature   = null === $secret ? null : base64_encode(hash_hmac('sha256', $jsonPayload, $secret, true));
-        $headers     = [
-            'Content-Type'      => 'application/json',
-            'X-Origin-Base-URL' => $this->coreParametersHelper->get('site_url'),
-            'Webhook-Signature' => $signature,
-        ];
-        $allowedPrivateAddresses = $this->coreParametersHelper->get('webhook_allowed_private_addresses');
-        $this->privateAddressChecker->setAllowedPrivateAddresses($allowedPrivateAddresses);
-        if (!$this->privateAddressChecker->isAllowedUrl($url)) {
-            throw new PrivateAddressException();
-        }
-        return $this->httpClient->sendRequest(new Request('POST', $url, $headers, $jsonPayload));
-    }
-}
