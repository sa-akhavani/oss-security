# ====================================================================
# FILE: app/bundles/CoreBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-694 ---
     1| <?php
     2| namespace Mautic\CoreBundle\Form\Type;
     3| use Mautic\CoreBundle\Factory\IpLookupFactory;
     4| use Mautic\CoreBundle\Form\DataTransformer\ArrayLinebreakTransformer;
     5| use Mautic\CoreBundle\Form\DataTransformer\ArrayStringTransformer;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| use Mautic\CoreBundle\Helper\LanguageHelper;
     8| use Mautic\CoreBundle\IpLookup\AbstractLookup;
     9| use Mautic\CoreBundle\IpLookup\IpLookupFormInterface;
    10| use Mautic\CoreBundle\Shortener\Shortener;
    11| use Mautic\PageBundle\Form\Type\PageListType;
    12| use Symfony\Component\Form\AbstractType;
    13| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
    14| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
    15| use Symfony\Component\Form\Extension\Core\Type\IntegerType;
    16| use Symfony\Component\Form\Extension\Core\Type\NumberType;
    17| use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    18| use Symfony\Component\Form\Extension\Core\Type\TextType;
    19| use Symfony\Component\Form\Extension\Core\Type\TimezoneType;
    20| use Symfony\Component\Form\Extension\Core\Type\UrlType;
    21| use Symfony\Component\Form\FormBuilderInterface;
    22| use Symfony\Component\Form\FormEvent;
    23| use Symfony\Component\Form\FormEvents;
    24| use Symfony\Component\Form\FormInterface;
    25| use Symfony\Component\Form\FormView;
    26| use Symfony\Component\Validator\Constraints\Callback;
    27| use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
    28| use Symfony\Component\Validator\Constraints\NotBlank;
    29| use Symfony\Component\Validator\Context\ExecutionContextInterface;
    30| use Symfony\Contracts\Translation\TranslatorInterface;
    31| /**
    32|  * @extends AbstractType<mixed>
    33|  */
    34| class ConfigType extends AbstractType
    35| {
    36|     public function __construct(private TranslatorInterface $translator, private LanguageHelper $langHelper, private IpLookupFactory $ipLookupFactory, private ?AbstractLookup $ipLookup, private Shortener $shortenerFactory, private CoreParametersHelper $coreParametersHelper)
    37|     {
    38|     }
    39|     public function buildForm(FormBuilderInterface $builder, array $options): void
    40|     {
    41|         $builder->add('last_shown_tab', HiddenType::class);
    42|         $builder->add(
    43|             'site_url',
    44|             UrlType::class,
    45|             [
    46|                 'label'      => 'mautic.core.config.form.site.url',
    47|                 'label_attr' => ['class' => 'control-label'],
    48|                 'attr'       => [
    49|                     'class'   => 'form-control',
    50|                     'tooltip' => 'mautic.core.config.form.site.url.tooltip',
    51|                 ],
    52|                 'default_protocol' => 'https',
    53|                 'constraints'      => [
    54|                     new NotBlank(
    55|                         [
    56|                             'message' => 'mautic.core.value.required',
    57|                         ]
    58|                     ),
    59|                 ],
    60|             ]
    61|         );
    62|         $builder->add(
    63|             'webroot',
    64|             PageListType::class,
    65|             [
    66|                 'label'      => 'mautic.core.config.form.webroot',
    67|                 'label_attr' => ['class' => 'control-label'],
    68|                 'help'       => 'mautic.core.config.form.webroot.help',
    69|                 'attr'       => [
    70|                     'class'            => 'form-control',
    71|                     'tooltip'          => 'mautic.core.config.form.webroot.tooltip',
    72|                     'data-placeholder' => $this->translator->trans('mautic.core.config.form.webroot.dashboard'),
    73|                 ],
    74|                 'multiple'    => false,
    75|                 'placeholder' => '',
    76|                 'required'    => false,
    77|             ]
    78|         );
    79|         $builder->add(
    80|             '404_page',
    81|             PageListType::class,
    82|             [
    83|                 'label'         => 'mautic.core.config.form.404_page',
    84|                 'label_attr'    => ['class' => 'control-label'],
    85|                 'help'          => 'mautic.core.config.form.404_page.help',
    86|                 'attr'          => [
    87|                     'class'            => 'form-control',
    88|                     'tooltip'          => 'mautic.core.config.form.404_page.tooltip',
    89|                 ],
    90|                 'multiple'       => false,
    91|                 'placeholder'    => '',
    92|                 'published_only' => true,
    93|             ]
    94|         );
    95|         $builder->add(
    96|             'cache_path',
    97|             TextType::class,
    98|             [
    99|                 'label'      => 'mautic.core.config.form.cache.path',
   100|                 'label_attr' => ['class' => 'control-label'],
   101|                 'attr'       => [
   102|                     'class'   => 'form-control',
   103|                     'tooltip' => 'mautic.core.config.form.cache.path.tooltip',
   104|                 ],
   105|                 'constraints' => [
   106|                     new NotBlank(
   107|                         [
   108|                             'message' => 'mautic.core.value.required',
   109|                         ]
   110|                     ),
   111|                 ],
   112|             ]
   113|         );
   114|         $builder->add(
   115|             'log_path',
   116|             TextType::class,
   117|             [
   118|                 'label'      => 'mautic.core.config.form.log.path',
   119|                 'label_attr' => ['class' => 'control-label'],
   120|                 'attr'       => [
   121|                     'class'   => 'form-control',
   122|                     'tooltip' => 'mautic.core.config.form.log.path.tooltip',
   123|                 ],
   124|                 'constraints' => [
   125|                     new NotBlank(
   126|                         [
   127|                             'message' => 'mautic.core.value.required',
   128|                         ]
   129|                     ),
   130|                 ],
   131|             ]
   132|         );
   133|         $builder->add(
   134|             'image_path',
   135|             TextType::class,
   136|             [
   137|                 'label'      => 'mautic.core.config.form.image.path',
   138|                 'label_attr' => ['class' => 'control-label'],
   139|                 'attr'       => [
   140|                     'class'   => 'form-control',
   141|                     'tooltip' => 'mautic.core.config.form.image.path.tooltip',
   142|                 ],
   143|                 'constraints' => [
   144|                     new NotBlank(
   145|                         [
   146|                             'message' => 'mautic.core.value.required',
   147|                         ]
   148|                     ),
   149|                     new Callback([$this, 'validateImagePath']),
   150|                 ],
   151|             ]
   152|         );
   153|         $builder->add(
   154|             'composer_updates',
   155|             YesNoButtonGroupType::class,
   156|             [
   157|                 'label' => 'mautic.core.config.form.update.composer',
   158|                 'data'  => (array_key_exists('composer_updates', $options['data']) && !empty($options['data']['composer_updates'])),
   159|                 'attr'  => [
   160|                     'class'   => 'form-control',
   161|                     'tooltip' => 'mautic.core.config.form.update.composer.tooltip',
   162|                 ],
   163|             ]
   164|         );
   165|         $builder->add(
   166|             'locale',
   167|             ChoiceType::class,
   168|             [
   169|                 'choices'           => $this->langHelper->getLanguageChoices(),
   170|                 'label'             => 'mautic.core.config.form.locale',
   171|                 'required'          => false,
   172|                 'attr'              => [
   173|                     'class'   => 'form-control',
   174|                     'tooltip' => 'mautic.core.config.form.locale.tooltip',
   175|                 ],
   176|                 'help'              => 'mautic.core.config.form.locale.help',
   177|                 'placeholder'       => false,
   178|             ]
   179|         );
   180|         $arrayStringTransformer = new ArrayStringTransformer();
   181|         $builder->add(
   182|             $builder->create(
   183|                 'trusted_hosts',
   184|                 TextType::class,
   185|                 [
   186|                     'label'      => 'mautic.core.config.form.trusted.hosts',
   187|                     'label_attr' => ['class' => 'control-label'],
   188|                     'attr'       => [
   189|                         'class'   => 'form-control',
   190|                         'tooltip' => 'mautic.core.config.form.trusted.hosts.tooltip',
   191|                     ],
   192|                     'help'       => 'mautic.core.config.form.trusted_hosts.help',
   193|                     'required'   => false,
   194|                 ]
   195|             )->addViewTransformer($arrayStringTransformer)
   196|         );
   197|         $builder->add(
   198|             $builder->create(
   199|                 'trusted_proxies',
   200|                 TextType::class,
   201|                 [
   202|                     'label'      => 'mautic.core.config.form.trusted.proxies',
   203|                     'label_attr' => ['class' => 'control-label'],
   204|                     'attr'       => [
   205|                         'class'   => 'form-control',
   206|                         'tooltip' => 'mautic.core.config.form.trusted.proxies.tooltip',
   207|                     ],
   208|                     'required' => false,
   209|                 ]
   210|             )->addViewTransformer($arrayStringTransformer)
   211|         );
   212|         $arrayLinebreakTransformer = new ArrayLinebreakTransformer();
   213|         $builder->add(
   214|             $builder->create(
   215|                 'do_not_track_ips',
   216|                 TextareaType::class,
   217|                 [
   218|                     'label'      => 'mautic.core.config.form.do_not_track_ips',
   219|                     'label_attr' => ['class' => 'control-label'],
   220|                     'attr'       => [
   221|                         'class'   => 'form-control',
   222|                         'tooltip' => 'mautic.core.config.form.do_not_track_ips.tooltip',
   223|                         'rows'    => 8,
   224|                     ],
   225|                     'required' => false,
   226|                 ]
   227|             )->addViewTransformer($arrayLinebreakTransformer)
   228|         );
   229|         $builder->add(
   230|             $builder->create(
   231|                 'do_not_track_bots',
   232|                 TextareaType::class,
   233|                 [
   234|                     'label'      => 'mautic.core.config.form.do_not_track_bots',
   235|                     'label_attr' => ['class' => 'control-label'],
   236|                     'attr'       => [
   237|                         'class'   => 'form-control',
   238|                         'tooltip' => 'mautic.core.config.form.do_not_track_bots.tooltip',
   239|                         'rows'    => 8,
   240|                     ],
   241|                     'required' => false,
   242|                 ]
   243|             )->addViewTransformer($arrayLinebreakTransformer)
   244|         );
   245|         $builder->add(
   246|             'default_pagelimit',
   247|             ChoiceType::class,
   248|             [
   249|                 'choices'           => [
   250|                     'mautic.core.pagination.5'   => 5,
   251|                     'mautic.core.pagination.10'  => 10,
   252|                     'mautic.core.pagination.15'  => 15,
   253|                     'mautic.core.pagination.20'  => 20,
   254|                     'mautic.core.pagination.25'  => 25,
   255|                     'mautic.core.pagination.30'  => 30,
   256|                     'mautic.core.pagination.50'  => 50,
   257|                     'mautic.core.pagination.100' => 100,
   258|                 ],
   259|                 'expanded'          => false,
   260|                 'multiple'          => false,
   261|                 'label'             => 'mautic.core.config.form.default.pagelimit',
   262|                 'label_attr'        => ['class' => 'control-label'],
   263|                 'attr'              => [
   264|                     'class'   => 'form-control',
   265|                     'tooltip' => 'mautic.core.config.form.default.pagelimit.tooltip',
   266|                 ],
   267|                 'required'          => false,
   268|                 'placeholder'       => false,
   269|             ]
   270|         );
   271|         $builder->add(
   272|             'default_timezone',
   273|             TimezoneType::class,
   274|             [
   275|                 'label'      => 'mautic.core.config.form.default.timezone',
   276|                 'label_attr' => ['class' => 'control-label'],
   277|                 'attr'       => [
   278|                     'class'   => 'form-control',
   279|                     'tooltip' => 'mautic.core.config.form.default.timezone.tooltip',
   280|                 ],
   281|                 'multiple'    => false,
   282|                 'placeholder' => 'mautic.user.user.form.defaulttimezone',
   283|                 'required'    => false,
   284|             ]
   285|         );
   286|         $builder->add(
   287|             'cached_data_timeout',
   288|             NumberType::class,
   289|             [
   290|                 'label'      => 'mautic.core.config.form.cached.data.timeout',
   291|                 'label_attr' => ['class' => 'control-label'],
   292|                 'attr'       => [
   293|                     'class'          => 'form-control',
   294|                     'tooltip'        => 'mautic.core.config.form.cached.data.timeout.tooltip',
   295|                     'postaddon'      => '',
   296|                     'postaddon_text' => $this->translator->trans('mautic.core.time.minutes'),
   297|                 ],
   298|                 'constraints' => [
   299|                     new NotBlank([
   300|                         'message' => 'mautic.core.value.required',
   301|                     ]),
   302|                     new GreaterThanOrEqual([
   303|                         'value' => 0,
   304|                     ]),
   305|                 ],
   306|             ]
   307|         );
   308|         $builder->add(
   309|             'date_format_full',
   310|             TextType::class,
   311|             [
   312|                 'label'      => 'mautic.core.config.form.date.format.full',
   313|                 'label_attr' => ['class' => 'control-label'],
   314|                 'attr'       => [
   315|                     'class'   => 'form-control',
   316|                     'tooltip' => 'mautic.core.config.form.date.format.full.tooltip',
   317|                 ],
   318|                 'constraints' => [
   319|                     new NotBlank(
   320|                         [
   321|                             'message' => 'mautic.core.value.required',
   322|                         ]
   323|                     ),
   324|                 ],
   325|             ]
   326|         );
   327|         $builder->add(
   328|             'date_format_short',
   329|             TextType::class,
   330|             [
   331|                 'label'      => 'mautic.core.config.form.date.format.short',
   332|                 'label_attr' => ['class' => 'control-label'],
   333|                 'attr'       => [
   334|                     'class'   => 'form-control',
   335|                     'tooltip' => 'mautic.core.config.form.date.format.short.tooltip',
   336|                 ],
   337|                 'constraints' => [
   338|                     new NotBlank(
   339|                         [
   340|                             'message' => 'mautic.core.value.required',
   341|                         ]
   342|                     ),
   343|                 ],
   344|             ]
   345|         );
   346|         $builder->add(
   347|             'date_format_dateonly',
   348|             TextType::class,
   349|             [
   350|                 'label'      => 'mautic.core.config.form.date.format.dateonly',
   351|                 'label_attr' => ['class' => 'control-label'],
   352|                 'attr'       => [
   353|                     'class'   => 'form-control',
   354|                     'tooltip' => 'mautic.core.config.form.date.format.dateonly.tooltip',
   355|                 ],
   356|                 'constraints' => [
   357|                     new NotBlank(
   358|                         [
   359|                             'message' => 'mautic.core.value.required',
   360|                         ]
   361|                     ),
   362|                 ],
   363|             ]
   364|         );
   365|         $builder->add(
   366|             'date_format_timeonly',
   367|             TextType::class,
   368|             [
   369|                 'label'      => 'mautic.core.config.form.date.format.timeonly',
   370|                 'label_attr' => ['class' => 'control-label'],
   371|                 'attr'       => [
   372|                     'class'   => 'form-control',
   373|                     'tooltip' => 'mautic.core.config.form.date.format.timeonly.tooltip',
   374|                 ],
   375|                 'constraints' => [
   376|                     new NotBlank(
   377|                         [
   378|                             'message' => 'mautic.core.value.required',
   379|                         ]
   380|                     ),
   381|                 ],
   382|             ]
   383|         );
   384|         $builder->add(
   385|             'default_daterange_filter',
   386|             ChoiceType::class,
   387|             [
   388|                 'choices' => [
   389|                     'mautic.core.daterange.0days'                                                                 => 'midnight',
   390|                     'mautic.core.daterange.1days'                                                                 => '-24 hours',
   391|                     $this->translator->trans('mautic.core.daterange.week', ['%count%' => 1])                      => '-1 week',
   392|                     $this->translator->trans('mautic.core.daterange.week', ['%count%' => 2])                      => '-2 weeks',
   393|                     $this->translator->trans('mautic.core.daterange.week', ['%count%' => 3])                      => '-3 weeks',
   394|                     $this->translator->trans('mautic.core.daterange.month', ['%count%' => 1])                     => '-1 month',
   395|                     $this->translator->trans('mautic.core.daterange.month', ['%count%' => 2])                     => '-2 months',
   396|                     $this->translator->trans('mautic.core.daterange.month', ['%count%' => 3])                     => '-3 months',
   397|                     $this->translator->trans('mautic.core.daterange.year', ['%count%' => 1])                      => '-1 year',
   398|                     $this->translator->trans('mautic.core.daterange.year', ['%count%' => 2])                      => '-2 years',
   399|                 ],
   400|                 'expanded'          => false,
   401|                 'multiple'          => false,
   402|                 'label'             => 'mautic.core.config.form.default.daterange_default',
   403|                 'label_attr'        => ['class' => 'control-label'],
   404|                 'attr'              => [
   405|                     'class'   => 'form-control',
   406|                     'tooltip' => 'mautic.core.config.form.default.daterange_default.tooltip',
   407|                 ],
   408|                 'required'          => false,
   409|                 'placeholder'       => false,
   410|             ]
   411|         );
   412|         $builder->add(
   413|             'ip_lookup_service',
   414|             ChoiceType::class,
   415|             [
   416|                 'choices'           => $this->getIpServicesChoices(),
   417|                 'label'             => 'mautic.core.config.form.ip.lookup.service',
   418|                 'label_attr'        => [
   419|                     'class' => 'control-label',
   420|                 ],
   421|                 'help'              => 'mautic.core.config.form.ip.lookup.service.help',
   422|                 'required'          => false,
   423|                 'attr'              => [
   424|                     'class'    => 'form-control',
   425|                     'tooltip'  => 'mautic.core.config.form.ip.lookup.service.tooltip',
   426|                     'onchange' => 'Mautic.getIpLookupFormConfig()',
   427|                 ],
   428|             ]
   429|         );
   430|         $builder->add(
   431|             'ip_lookup_auth',
   432|             TextType::class,
   433|             [
   434|                 'label'      => 'mautic.core.config.form.ip.lookup.auth',
   435|                 'label_attr' => ['class' => 'control-label'],
   436|                 'attr'       => [
   437|                     'class'   => 'form-control',
   438|                     'tooltip' => 'mautic.core.config.form.ip.lookup.auth.tooltip',
   439|                 ],
   440|                 'required' => false,
   441|             ]
   442|         );
   443|         $builder->add(
   444|             'ip_lookup_create_organization',
   445|             YesNoButtonGroupType::class,
   446|             [
   447|                 'label'      => 'mautic.core.config.create.organization.from.ip.lookup',
   448|                 'label_attr' => ['class' => 'control-label'],
   449|                 'attr'       => [
   450|                     'class'   => 'form-control',
   451|                     'tooltip' => 'mautic.core.config.create.organization.from.ip.lookup.tooltip',
   452|                 ],
   453|                 'data'     => isset($options['data']['ip_lookup_create_organization']) && (bool) $options['data']['ip_lookup_create_organization'],
   454|                 'required' => false,
   455|             ]
   456|         );
   457|         $ipLookupFactory = $this->ipLookupFactory;
   458|         $formModifier    = function (FormEvent $event) use ($ipLookupFactory): void {
   459|             $data = $event->getData();
   460|             $form = $event->getForm();
   461|             $ipServiceName = $data['ip_lookup_service'] ?? null;
   462|             if ($ipServiceName && $lookupService = $ipLookupFactory->getService($ipServiceName)) {
   463|                 if ($lookupService instanceof IpLookupFormInterface && $formType = $lookupService->getConfigFormService()) {
   464|                     $form->add(
   465|                         'ip_lookup_config',
   466|                         $formType,
   467|                         [
   468|                             'label'             => false,
   469|                             'ip_lookup_service' => $lookupService,
   470|                         ]
   471|                     );
   472|                 }
   473|             }
   474|         };
   475|         $builder->addEventListener(
   476|             FormEvents::PRE_SET_DATA,
   477|             function (FormEvent $event) use ($formModifier): void {
   478|                 $formModifier($event);
   479|             }
   480|         );
   481|         $builder->addEventListener(
   482|             FormEvents::PRE_SUBMIT,
   483|             function (FormEvent $event) use ($formModifier): void {
   484|                 $formModifier($event);
   485|             }
   486|         );
   487|         $builder->add(
   488|             'update_stability',
   489|             ChoiceType::class,
   490|             [
   491|                 'choices'           => [
   492|                     'mautic.core.config.update_stability.alpha'  => 'alpha',
   493|                     'mautic.core.config.update_stability.beta'   => 'beta',
   494|                     'mautic.core.config.update_stability.rc'     => 'rc',
   495|                     'mautic.core.config.update_stability.stable' => 'stable',
   496|                 ],
   497|                 'label'             => 'mautic.core.config.form.update.stability',
   498|                 'required'          => false,
   499|                 'attr'              => [
   500|                     'class'   => 'form-control',
   501|                     'tooltip' => 'mautic.core.config.form.update.stability.tooltip',
   502|                 ],
   503|                 'placeholder'       => false,
   504|             ]
   505|         );
   506|         $enabledServices = $this->shortenerFactory->getEnabledServices();
   507|         $choices         = array_flip(array_map(fn ($enabledService) => $enabledService->getPublicName(), $enabledServices));
   508|         $builder->add(
   509|             Shortener::SHORTENER_SERVICE,
   510|             ChoiceType::class,
   511|             [
   512|                 'choices'           => $choices,
   513|                 'label'             => 'mautic.core.config.form.shortener',
   514|                 'required'          => false,
   515|                 'attr'              => [
   516|                     'class'   => 'form-control',
   517|                     'tooltip' => 'mautic.core.config.form.shortener.tooltip',
   518|                 ],
   519|             ]
   520|         );
   521|         $builder->add(
   522|             'shortener_email_enable',
   523|             YesNoButtonGroupType::class,
   524|             [
   525|                 'label'      => 'mautic.core.config.form.shortener.enable_email',
   526|                 'data'       => (array_key_exists('shortener_email_enable', $options['data']) && !empty($options['data']['shortener_email_enable'])),
   527|                 'attr'       => [
   528|                     'class'        => 'form-control',
   529|                     'tooltip'      => 'mautic.core.config.form.shortener.enable_email.tooltip',
   530|                 ],
   531|             ]
   532|         );
   533|         $builder->add(
   534|             'shortener_sms_enable',
   535|             YesNoButtonGroupType::class,
   536|             [
   537|                 'label'      => 'mautic.core.config.form.shortener.enable_sms',
   538|                 'data'       => (array_key_exists('shortener_sms_enable', $options['data']) && !empty($options['data']['shortener_sms_enable'])),
   539|                 'attr'       => [
   540|                     'class'        => 'form-control',
   541|                     'tooltip'      => 'mautic.core.config.form.shortener.enable_sms.tooltip',
   542|                 ],
   543|             ]
   544|         );
   545|         $builder->add(
   546|             'max_entity_lock_time',
   547|             NumberType::class,
   548|             [
   549|                 'label'      => 'mautic.core.config.form.link.max_entity_lock_time',
   550|                 'label_attr' => ['class' => 'control-label'],
   551|                 'help'       => 'mautic.core.config.form.link.max_entity_lock_time.help',
   552|                 'attr'       => [
   553|                     'class'   => 'form-control',
   554|                     'tooltip' => 'mautic.core.config.form.link.max_entity_lock_time.tooltip',
   555|                 ],
   556|                 'required' => false,
   557|             ]
   558|         );
   559|         $builder->add(
   560|             'transliterate_page_title',
   561|             YesNoButtonGroupType::class,
   562|             [
   563|                 'label' => 'mautic.core.config.form.transliterate.page.title',
   564|                 'data'  => (array_key_exists('transliterate_page_title', $options['data']) && !empty($options['data']['transliterate_page_title'])),
   565|                 'attr'  => [
   566|                     'class'   => 'form-control',
   567|                     'tooltip' => 'mautic.core.config.form.transliterate.page.title.tooltip',
   568|                 ],
   569|             ]
   570|         );
   571|         $builder->add(
   572|             'cors_restrict_domains',
   573|             YesNoButtonGroupType::class,
   574|             [
   575|                 'label' => 'mautic.core.config.cors.restrict.domains',
   576|                 'help'  => 'mautic.core.config.cors.restrict.domains.help',
   577|                 'data'  => (array_key_exists('cors_restrict_domains', $options['data']) && !empty($options['data']['cors_restrict_domains'])),
   578|                 'attr'  => [
   579|                     'class'   => 'form-control',
   580|                     'tooltip' => 'mautic.core.config.cors.restrict.domains.tooltip',
   581|                 ],
   582|             ]
   583|         );
   584|         $arrayLinebreakTransformer = new ArrayLinebreakTransformer();
   585|         $builder->add(
   586|             $builder->create(
   587|                 'cors_valid_domains',
   588|                 TextareaType::class,
   589|                 [
   590|                     'label'      => 'mautic.core.config.cors.valid.domains',
   591|                     'label_attr' => ['class' => 'control-label'],
   592|                     'attr'       => [
   593|                         'class'        => 'form-control',
   594|                         'tooltip'      => 'mautic.core.config.cors.valid.domains.tooltip',
   595|                         'data-show-on' => '{"config_coreconfig_cors_restrict_domains_1":"checked"}',
   596|                     ],
   597|                     'help'       => 'mautic.core.config.form.cors_valid_domains.help',
   598|                 ]
   599|             )->addViewTransformer($arrayLinebreakTransformer)
   600|         );
   601|         $builder->add(
   602|             'headers_sts',
   603|             YesNoButtonGroupType::class,
   604|             [
   605|                 'label' => 'mautic.core.config.response.headers.sts',
   606|                 'data'  => (array_key_exists('headers_sts', $options['data']) && !empty($options['data']['headers_sts'])),
   607|                 'attr'  => [
   608|                     'class'   => 'form-control',
   609|                     'tooltip' => 'mautic.core.config.response.headers.sts.tooltip',
   610|                 ],
   611|             ]
   612|         );
   613|         $builder->add(
   614|             'headers_sts_expire_time',
   615|             IntegerType::class,
   616|             [
   617|                 'label' => 'mautic.core.config.response.headers.sts.expire_time',
   618|                 'data'  => $options['data']['headers_sts_expire_time'] ?? 60,
   619|                 'attr'  => [
   620|                     'class'          => 'form-control',
   621|                     'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
   622|                     'min'            => 60,
   623|                 ],
   624|             ]
   625|         );
   626|         $builder->add(
   627|             'headers_sts_subdomains',
   628|             YesNoButtonGroupType::class,
   629|             [
   630|                 'label' => 'mautic.core.config.response.headers.sts.subdomains',
   631|                 'data'  => (array_key_exists('headers_sts_subdomains', $options['data']) && !empty($options['data']['headers_sts_subdomains'])),
   632|                 'attr'  => [
   633|                     'class'          => 'form-control',
   634|                     'tooltip'        => 'mautic.core.config.response.headers.sts.subdomains.tooltip',
   635|                     'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
   636|                 ],
   637|             ]
   638|         );
   639|         $builder->add(
   640|             'headers_sts_preload',
   641|             YesNoButtonGroupType::class,
   642|             [
   643|                 'label' => 'mautic.core.config.response.headers.sts.preload',
   644|                 'data'  => (array_key_exists('headers_sts_preload', $options['data']) && !empty($options['data']['headers_sts_preload'])),
   645|                 'attr'  => [
   646|                     'class'          => 'form-control',
   647|                     'tooltip'        => 'mautic.core.config.response.headers.sts.preload.tooltip',
   648|                     'data-enable-on' => '{"config_coreconfig_headers_sts_1":"checked"}',
   649|                 ],
   650|             ]
   651|         );
   652|     }
   653|     public function validateImagePath(?string $value, ExecutionContextInterface $context): void
   654|     {
   655|         $isValid = true;
   656|         $normalizedValue = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $value);
   657|         if (
   658|             empty($normalizedValue)
   659|             || str_contains($normalizedValue, '..')
   660|             || str_contains($normalizedValue, '.'.DIRECTORY_SEPARATOR)
   661|             || DIRECTORY_SEPARATOR === $normalizedValue
   662|         ) {
   663|             $isValid = false;
   664|         }
   665|         $mediaFile = substr($value, 0, 6);
   666|         if ('media/' !== $mediaFile) {
   667|             $isValid = false;
   668|         }
   669|         if (!is_dir($value)) {
   670|             $isValid = false;
   671|         }
   672|         if (!$isValid) {
   673|             $context->buildViolation('mautic.core.config.form.image.path.invalid')->atPath('image_path')->addViolation();
   674|         }
   675|     }
   676|     public function buildView(FormView $view, FormInterface $form, array $options): void
   677|     {
   678|         $view->vars['ipLookupAttribution'] = (null !== $this->ipLookup) ? $this->ipLookup->getAttribution() : '';
   679|     }
   680|     public function getBlockPrefix(): string
   681|     {
   682|         return 'coreconfig';
   683|     }
   684|     private function getIpServicesChoices(): array
   685|     {
   686|         $choices          = [];
   687|         $ipLookupServices = $this->coreParametersHelper->get('ip_lookup_services') ?? [];
   688|         foreach ($ipLookupServices as $name => $service) {
   689|             $choices[$service['display_name']] = $name;
   690|         }
   691|         ksort($choices, SORT_FLAG_CASE | SORT_NATURAL);
   692|         return $choices;
   693|     }
   694| }


# ====================================================================
# FILE: app/bundles/CoreBundle/Helper/PrivateAddressChecker.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-138 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CoreBundle\Helper;
     4| class PrivateAddressChecker
     5| {
     6|     private const PRIVATE_IP_RANGES = [
     7|         '10.0.0.0/8',      // RFC1918
     8|         '172.16.0.0/12',   // RFC1918
     9|         '192.168.0.0/16',  // RFC1918
    10|         '127.0.0.0/8',     // Localhost
    11|         '169.254.0.0/16',  // Link-local
    12|         'fc00::/7',        // Unique local address
    13|         'fe80::/10',       // Link-local address
    14|         '::1/128',         // Localhost IPv6
    15|     ];
    16|     /** @var array<string> */
    17|     private array $allowedPrivateAddresses = [];
    18|     /**
    19|      * @param callable|null $dnsResolver
    20|      */
    21|     public function __construct(
    22|         private $dnsResolver = null,
    23|     ) {
    24|         $this->dnsResolver = $dnsResolver ?? 'gethostbynamel';
    25|     }
    26|     /**
    27|      * @param array<string> $allowedPrivateAddresses
    28|      */
    29|     public function setAllowedPrivateAddresses(array $allowedPrivateAddresses): PrivateAddressChecker
    30|     {
    31|         $this->allowedPrivateAddresses = $allowedPrivateAddresses;
    32|         return $this;
    33|     }
    34|     public function isPrivateUrl(string $url): bool
    35|     {
    36|         try {
    37|             $parsedUrl = parse_url($url);
    38|             if (!isset($parsedUrl['host'])) {
    39|                 throw new \InvalidArgumentException('Invalid URL format');
    40|             }
    41|             $host = strtolower($parsedUrl['host']);
    42|             if ('localhost' === $host) {
    43|                 return true;
    44|             }
    45|             if (str_starts_with($host, '[') && str_ends_with($host, ']')) {
    46|                 $ip = substr($host, 1, -1); // Remove brackets
    47|                 return $this->isPrivateIp($ip);
    48|             }
    49|             if (!filter_var($host, FILTER_VALIDATE_IP)) {
    50|                 $ips = ($this->dnsResolver)($host);
    51|                 if (false === $ips) {
    52|                     throw new \InvalidArgumentException('Could not resolve hostname');
    53|                 }
    54|                 foreach ($ips as $ip) {
    55|                     if ($this->isPrivateIp($ip)) {
    56|                         return true;
    57|                     }
    58|                 }
    59|                 return false;
    60|             }
    61|             return $this->isPrivateIp($host);
    62|         } catch (\Exception $e) {
    63|             throw new \InvalidArgumentException('URL validation failed: '.$e->getMessage());
    64|         }
    65|     }
    66|     public function isPrivateIp(string $ip): bool
    67|     {
    68|         if (($pos = strpos($ip, '%')) !== false) {
    69|             $ip = substr($ip, 0, $pos);
    70|         }
    71|         $binaryIp = @inet_pton($ip);
    72|         if (false === $binaryIp) {
    73|             return false;
    74|         }
    75|         foreach (self::PRIVATE_IP_RANGES as $range) {
    76|             [$networkIp, $netmask] = explode('/', $range);
    77|             $binaryNetwork = @inet_pton($networkIp);
    78|             if (false === $binaryNetwork) {
    79|                 continue;
    80|             }
    81|             $maskLen  = (int) $netmask;
    82|             $numBytes = (int) ($maskLen / 8);
    83|             $numBits  = $maskLen % 8;
    84|             if (substr($binaryIp, 0, $numBytes) !== substr($binaryNetwork, 0, $numBytes)) {
    85|                 continue;
    86|             }
    87|             if ($numBits > 0) {
    88|                 $mask = 0xFF << (8 - $numBits);
    89|                 if ((ord($binaryIp[$numBytes]) & $mask) !== (ord($binaryNetwork[$numBytes]) & $mask)) {
    90|                     continue;
    91|                 }
    92|             }
    93|             return true;
    94|         }
    95|         return false;
    96|     }
    97|     /**
    98|      * Checks if the given URL is allowed based on the allowed private addresses list.
    99|      * Returns true if the URL is either public or in the allowed private addresses list.
   100|      */
   101|     public function isAllowedUrl(string $url): bool
   102|     {
   103|         try {
   104|             if (!$this->isPrivateUrl($url)) {
   105|                 return true;
   106|             }
   107|             if (empty($this->allowedPrivateAddresses)) {
   108|                 return false;
   109|             }
   110|             $parsedUrl = parse_url($url);
   111|             if (!isset($parsedUrl['host'])) {
   112|                 throw new \InvalidArgumentException('Invalid URL format');
   113|             }
   114|             $host = strtolower($parsedUrl['host']);
   115|             if (in_array($host, $this->allowedPrivateAddresses, true)) {
   116|                 return true;
   117|             }
   118|             if (str_starts_with($host, '[') && str_ends_with($host, ']')) {
   119|                 $host = substr($host, 1, -1); // Remove brackets
   120|             }
   121|             if (filter_var($host, FILTER_VALIDATE_IP)) {
   122|                 return in_array($host, $this->allowedPrivateAddresses, true);
   123|             }
   124|             $ips = ($this->dnsResolver)($host);
   125|             if (false === $ips) {
   126|                 throw new \InvalidArgumentException('Could not resolve hostname');
   127|             }
   128|             foreach ($ips as $ip) {
   129|                 if (in_array($ip, $this->allowedPrivateAddresses, true)) {
   130|                     return true;
   131|                 }
   132|             }
   133|             return false;
   134|         } catch (\Exception $e) {
   135|             throw new \InvalidArgumentException('URL validation failed: '.$e->getMessage());
   136|         }
   137|     }
   138| }


# ====================================================================
# FILE: app/bundles/EmailBundle/MonitoredEmail/Mailbox.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-956 ---
     1| <?php
     2| namespace Mautic\EmailBundle\MonitoredEmail;
     3| use IMAP\Connection;
     4| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     5| use Mautic\CoreBundle\Helper\PathsHelper;
     6| use Mautic\EmailBundle\Exception\MailboxException;
     7| use Mautic\EmailBundle\MonitoredEmail\Exception\NotConfiguredException;
     8| class Mailbox
     9| {
    10|     /**
    11|      * Return all mails matching the rest of the criteria.
    12|      */
    13|     public const CRITERIA_ALL = 'ALL';
    14|     /**
    15|      * Match mails with the \\ANSWERED flag set.
    16|      */
    17|     public const CRITERIA_ANSWERED = 'ANSWERED';
    18|     /**
    19|      * CRITERIA_BCC "string" - match mails with "string" in the Bcc: field.
    20|      */
    21|     public const CRITERIA_BCC = 'BCC';
    22|     /**
    23|      * CRITERIA_BEFORE "date" - match mails with Date: before "date".
    24|      */
    25|     public const CRITERIA_BEFORE = 'BEFORE';
    26|     /**
    27|      * CRITERIA_BODY "string" - match mails with "string" in the body of the mail.
    28|      */
    29|     public const CRITERIA_BODY = 'BODY';
    30|     /**
    31|      * CRITERIA_CC "string" - match mails with "string" in the Cc: field.
    32|      */
    33|     public const CRITERIA_CC = 'CC';
    34|     /**
    35|      * Match deleted mails.
    36|      */
    37|     public const CRITERIA_DELETED = 'DELETED';
    38|     /**
    39|      * Match mails with the \\FLAGGED (sometimes referred to as Important or Urgent) flag set.
    40|      */
    41|     public const CRITERIA_FLAGGED = 'FLAGGED';
    42|     /**
    43|      * CRITERIA_FROM "string" - match mails with "string" in the From: field.
    44|      */
    45|     public const CRITERIA_FROM = 'FROM';
    46|     /**
    47|      *  CRITERIA_KEYWORD "string" - match mails with "string" as a keyword.
    48|      */
    49|     public const CRITERIA_KEYWORD = 'KEYWORD';
    50|     /**
    51|      * Match new mails.
    52|      */
    53|     public const CRITERIA_NEW = 'NEW';
    54|     /**
    55|      * Match old mails.
    56|      */
    57|     public const CRITERIA_OLD = 'OLD';
    58|     /**
    59|      * CRITERIA_ON "date" - match mails with Date: matching "date".
    60|      */
    61|     public const CRITERIA_ON = 'ON';
    62|     /**
    63|      * Match mails with the \\RECENT flag set.
    64|      */
    65|     public const CRITERIA_RECENT = 'RECENT';
    66|     /**
    67|      * Match mails that have been read (the \\SEEN flag is set).
    68|      */
    69|     public const CRITERIA_SEEN = 'SEEN';
    70|     /**
    71|      * CRITERIA_SINCE "date" - match mails with Date: after "date".
    72|      */
    73|     public const CRITERIA_SINCE = 'SINCE';
    74|     /**
    75|      *  CRITERIA_SUBJECT "string" - match mails with "string" in the Subject:.
    76|      */
    77|     public const CRITERIA_SUBJECT = 'SUBJECT';
    78|     /**
    79|      * CRITERIA_TEXT "string" - match mails with text "string".
    80|      */
    81|     public const CRITERIA_TEXT = 'TEXT';
    82|     /**
    83|      * CRITERIA_TO "string" - match mails with "string" in the To:.
    84|      */
    85|     public const CRITERIA_TO = 'TO';
    86|     /**
    87|      *  Get messages since a specific UID. Eg. UID 2:* will return all messages with UID 2 and above (IMAP includes the given UID).
    88|      */
    89|     public const CRITERIA_UID = 'UID';
    90|     /**
    91|      *  Match mails that have not been answered.
    92|      */
    93|     public const CRITERIA_UNANSWERED = 'UNANSWERED';
    94|     /**
    95|      * Match mails that are not deleted.
    96|      */
    97|     public const CRITERIA_UNDELETED = 'UNDELETED';
    98|     /**
    99|      * Match mails that are not flagged.
   100|      */
   101|     public const CRITERIA_UNFLAGGED = 'UNFLAGGED';
   102|     /**
   103|      * CRITERIA_UNKEYWORD "string" - match mails that do not have the keyword "string".
   104|      */
   105|     public const CRITERIA_UNKEYWORD = 'UNKEYWORD';
   106|     /**
   107|      * Match mails which have not been read yet.
   108|      */
   109|     public const CRITERIA_UNSEEN = 'UNSEEN';
   110|     /**
   111|      * Match mails which have not been read yet - alias of CRITERIA_UNSEEN.
   112|      */
   113|     public const CRITERIA_UNREAD = 'UNSEEN';
   114|     protected $imapPath;
   115|     protected $imapFullPath;
   116|     protected $imapStream;
   117|     protected $imapFolder     = 'INBOX';
   118|     protected $imapOptions    = 0;
   119|     protected $imapRetriesNum = 0;
   120|     protected $imapParams     = [];
   121|     protected $serverEncoding = 'UTF-8';
   122|     protected $attachmentsDir;
   123|     protected $settings;
   124|     protected $isGmail = false;
   125|     protected $mailboxes;
   126|     /**
   127|      * @var mixed[]
   128|      */
   129|     private array $folders = [];
   130|     public function __construct(CoreParametersHelper $parametersHelper, PathsHelper $pathsHelper)
   131|     {
   132|         $this->mailboxes = $parametersHelper->get('monitored_email', []);
   133|         if (isset($this->mailboxes['general'])) {
   134|             $this->settings = $this->mailboxes['general'];
   135|         } else {
   136|             $this->settings = [
   137|                 'host'            => '',
   138|                 'port'            => '',
   139|                 'password'        => '',
   140|                 'user'            => '',
   141|                 'encryption'      => '',
   142|                 'use_attachments' => false,
   143|             ];
   144|         }
   145|         $this->createAttachmentsDir($pathsHelper);
   146|         if ('imap.gmail.com' == $this->settings['host']) {
   147|             $this->isGmail = true;
   148|         }
   149|     }
   150|     /**
   151|      * Returns if a mailbox is configured.
   152|      */
   153|     public function isConfigured($bundleKey = null, $folderKey = null): bool
   154|     {
   155|         if (null !== $bundleKey) {
   156|             try {
   157|                 $this->switchMailbox($bundleKey, $folderKey);
   158|             } catch (MailboxException) {
   159|                 return false;
   160|             }
   161|         }
   162|         return
   163|             !empty($this->settings['host']) && !empty($this->settings['port']) && !empty($this->settings['user'])
   164|             && !empty($this->settings['password']);
   165|     }
   166|     /**
   167|      * Switch to another configured monitored mailbox.
   168|      *
   169|      * @param string $mailbox
   170|      *
   171|      * @throws MailboxException
   172|      */
   173|     public function switchMailbox($bundle, $mailbox = ''): void
   174|     {
   175|         $key = $bundle.(!empty($mailbox) ? '_'.$mailbox : '');
   176|         if (isset($this->mailboxes[$key])) {
   177|             $this->settings           = (!empty($this->mailboxes[$key]['override_settings'])) ? $this->mailboxes[$key] : $this->mailboxes['general'];
   178|             $this->imapFolder         = $this->mailboxes[$key]['folder'];
   179|             $this->settings['folder'] = $this->mailboxes[$key]['folder'];
   180|             $this->disconnect();
   181|             $this->setImapPath();
   182|         } else {
   183|             throw new MailboxException($key.' not found');
   184|         }
   185|     }
   186|     /**
   187|      * Returns if this is a Gmail connection.
   188|      *
   189|      * @return mixed
   190|      */
   191|     public function isGmail()
   192|     {
   193|         return $this->isGmail();
   194|     }
   195|     /**
   196|      * Set imap path based on mailbox settings.
   197|      */
   198|     public function setImapPath($settings = null): void
   199|     {
   200|         if (null == $settings) {
   201|             $settings = $this->settings;
   202|         }
   203|         $paths              = $this->getImapPath($settings);
   204|         $this->imapPath     = $paths['path'];
   205|         $this->imapFullPath = $paths['full'];
   206|     }
   207|     public function getImapPath($settings): array
   208|     {
   209|         if (!isset($settings['encryption'])) {
   210|             $settings['encryption'] = (!empty($settings['ssl'])) ? '/ssl' : '';
   211|         }
   212|         $path     = "{{$settings['host']}:{$settings['port']}/imap{$settings['encryption']}}";
   213|         $fullPath = $path;
   214|         if (isset($settings['folder'])) {
   215|             $fullPath .= $settings['folder'];
   216|         }
   217|         return ['path' => $path, 'full' => $fullPath];
   218|     }
   219|     /**
   220|      * Override mailbox settings.
   221|      */
   222|     public function setMailboxSettings(array $settings): void
   223|     {
   224|         $this->settings = array_merge($this->settings, $settings);
   225|         $this->isGmail = ('imap.gmail.com' == $this->settings['host']);
   226|         $this->setImapPath();
   227|     }
   228|     /**
   229|      * Get settings.
   230|      *
   231|      * @param string $mailbox
   232|      *
   233|      * @return mixed
   234|      *
   235|      * @throws MailboxException
   236|      */
   237|     public function getMailboxSettings($bundle = null, $mailbox = '')
   238|     {
   239|         if (null == $bundle) {
   240|             return $this->settings;
   241|         }
   242|         $key = $bundle.(!empty($mailbox) ? '_'.$mailbox : '');
   243|         if (isset($this->mailboxes[$key])) {
   244|             $settings = (!empty($this->mailboxes[$key]['override_settings'])) ? $this->mailboxes[$key] : $this->mailboxes['general'];
   245|             $settings['folder'] = $this->mailboxes[$key]['folder'];
   246|             $this->setImapPath($settings);
   247|             $imapPath              = $this->getImapPath($settings);
   248|             $settings['imap_path'] = $imapPath['full'];
   249|         } else {
   250|             throw new MailboxException($key.' not found');
   251|         }
   252|         return $settings;
   253|     }
   254|     /**
   255|      * Set custom connection arguments of imap_open method. See http://php.net/imap_open.
   256|      *
   257|      * @param int $options
   258|      * @param int $retriesNum
   259|      */
   260|     public function setConnectionArgs($options = 0, $retriesNum = 0, array $params = null): void
   261|     {
   262|         $this->imapOptions    = $options;
   263|         $this->imapRetriesNum = $retriesNum;
   264|         $this->imapParams     = $params;
   265|     }
   266|     /**
   267|      * Switch to another box.
   268|      */
   269|     public function switchFolder($folder): void
   270|     {
   271|         if ($folder != $this->imapFolder) {
   272|             $this->imapFullPath = $this->imapPath.$folder;
   273|             $this->imapFolder   = $folder;
   274|         }
   275|         $this->getImapStream();
   276|     }
   277|     /**
   278|      * Get IMAP mailbox connection stream.
   279|      *
   280|      * @return Connection
   281|      */
   282|     public function getImapStream()
   283|     {
   284|         if (!$this->isConnected()) {
   285|             $this->imapStream = $this->initImapStream();
   286|         } else {
   287|             @imap_reopen($this->imapStream, $this->imapFullPath);
   288|         }
   289|         return $this->imapStream;
   290|     }
   291|     /**
   292|      * @return Connection
   293|      *
   294|      * @throws MailboxException
   295|      */
   296|     protected function initImapStream()
   297|     {
   298|         imap_timeout(IMAP_OPENTIMEOUT, 15);
   299|         imap_timeout(IMAP_CLOSETIMEOUT, 15);
   300|         imap_timeout(IMAP_READTIMEOUT, 15);
   301|         imap_timeout(IMAP_WRITETIMEOUT, 15);
   302|         $imapStream = @imap_open(
   303|             $this->imapFullPath,
   304|             $this->settings['user'],
   305|             $this->settings['password'],
   306|             $this->imapOptions,
   307|             $this->imapRetriesNum,
   308|             $this->imapParams
   309|         );
   310|         if (!$imapStream) {
   311|             throw new MailboxException();
   312|         }
   313|         return $imapStream;
   314|     }
   315|     /**
   316|      * Check if the stream is connected.
   317|      */
   318|     protected function isConnected(): bool
   319|     {
   320|         if (!$this->isConfigured() || !$this->imapStream) {
   321|             return false;
   322|         }
   323|         try {
   324|             return @imap_ping($this->imapStream);
   325|         } catch (\ValueError|\TypeError) {
   326|             return false;
   327|         }
   328|     }
   329|     /**
   330|      * Get information about the current mailbox.
   331|      *
   332|      * Returns the information in an object with following properties:
   333|      *  Date - current system time formatted according to RFC2822
   334|      *  Driver - protocol used to access this mailbox: POP3, IMAP, NNTP
   335|      *  Mailbox - the mailbox name
   336|      *  Nmsgs - number of mails in the mailbox
   337|      *  Recent - number of recent mails in the mailbox
   338|      *
   339|      * @return \stdClass
   340|      */
   341|     public function checkMailbox(): \stdClass|bool
   342|     {
   343|         return imap_check($this->getImapStream());
   344|     }
   345|     /**
   346|      * Creates a new mailbox specified by mailbox.
   347|      */
   348|     public function createMailbox(): bool
   349|     {
   350|         return imap_createmailbox($this->getImapStream(), imap_utf7_encode($this->imapFullPath));
   351|     }
   352|     /**
   353|      * Gets status information about the given mailbox.
   354|      *
   355|      * This function returns an object containing status information.
   356|      * The object has the following properties: messages, recent, unseen, uidnext, and uidvalidity.
   357|      *
   358|      * @return \stdClass if the box doesn't exist
   359|      */
   360|     public function statusMailbox(): \stdClass|bool
   361|     {
   362|         return imap_status($this->getImapStream(), $this->imapFullPath, SA_ALL);
   363|     }
   364|     /**
   365|      * Gets listing the folders.
   366|      *
   367|      * This function returns an object containing listing the folders.
   368|      * The object has the following properties: messages, recent, unseen, uidnext, and uidvalidity.
   369|      *
   370|      * @return array listing the folders
   371|      */
   372|     public function getListingFolders()
   373|     {
   374|         if (!$this->isConfigured()) {
   375|             throw new NotConfiguredException('mautic.email.config.monitored_email.not_configured');
   376|         }
   377|         if (!isset($this->folders[$this->imapFullPath])) {
   378|             $tempFolders = @imap_list($this->getImapStream(), $this->imapPath, '*');
   379|             if (!empty($tempFolders)) {
   380|                 foreach ($tempFolders as $key => $folder) {
   381|                     $folder            = str_replace($this->imapPath, '', imap_utf8($folder));
   382|                     $tempFolders[$key] = $folder;
   383|                 }
   384|             } else {
   385|                 $tempFolders = [];
   386|             }
   387|             $this->folders[$this->imapFullPath] = $tempFolders;
   388|         }
   389|         return $this->folders[$this->imapFullPath];
   390|     }
   391|     public function fetchUnread($folder = null): array
   392|     {
   393|         if (null !== $folder) {
   394|             $this->switchFolder($folder);
   395|         }
   396|         return $this->searchMailBox(self::CRITERIA_UNSEEN);
   397|     }
   398|     /**
   399|      * This function performs a search on the mailbox currently opened in the given IMAP stream.
   400|      * For example, to match all unanswered mails sent by Mom, you'd use: "UNANSWERED FROM mom".
   401|      * Searches appear to be case insensitive. This list of criteria is from a reading of the UW
   402|      * c-client source code and may be incomplete or inaccurate (see also RFC2060, section 6.4.4).
   403|      *
   404|      * @param string $criteria String, delimited by spaces, in which the following keywords are allowed. Any multi-word arguments (e.g. FROM "joey
   405|      *                         smith") must be quoted. Results will match all criteria entries.
   406|      *                         ALL - return all mails matching the rest of the criteria
   407|      *                         ANSWERED - match mails with the \\ANSWERED flag set
   408|      *                         BCC "string" - match mails with "string" in the Bcc: field
   409|      *                         BEFORE "date" - match mails with Date: before "date"
   410|      *                         BODY "string" - match mails with "string" in the body of the mail
   411|      *                         CC "string" - match mails with "string" in the Cc: field
   412|      *                         DELETED - match deleted mails
   413|      *                         FLAGGED - match mails with the \\FLAGGED (sometimes referred to as Important or Urgent) flag set
   414|      *                         FROM "string" - match mails with "string" in the From: field
   415|      *                         KEYWORD "string" - match mails with "string" as a keyword
   416|      *                         NEW - match new mails
   417|      *                         OLD - match old mails
   418|      *                         ON "date" - match mails with Date: matching "date"
   419|      *                         RECENT - match mails with the \\RECENT flag set
   420|      *                         SEEN - match mails that have been read (the \\SEEN flag is set)
   421|      *                         SINCE "date" - match mails with Date: after "date"
   422|      *                         SUBJECT "string" - match mails with "string" in the Subject:
   423|      *                         TEXT "string" - match mails with text "string"
   424|      *                         TO "string" - match mails with "string" in the To:
   425|      *                         UNANSWERED - match mails that have not been answered
   426|      *                         UNDELETED - match mails that are not deleted
   427|      *                         UNFLAGGED - match mails that are not flagged
   428|      *                         UNKEYWORD "string" - match mails that do not have the keyword "string"
   429|      *                         UNSEEN - match mails which have not been read yet
   430|      *
   431|      * @return array Mails ids
   432|      */
   433|     public function searchMailbox($criteria = self::CRITERIA_ALL): array
   434|     {
   435|         if (preg_match('/'.self::CRITERIA_UID.' ((\d+):(\d+|\*))/', $criteria, $matches)) {
   436|             $messages = imap_fetch_overview($this->getImapStream(), $matches[1], FT_UID);
   437|             $mailIds = [];
   438|             foreach ($messages as $message) {
   439|                 $mailIds[] = $message->uid;
   440|             }
   441|         } else {
   442|             $mailIds = imap_search($this->getImapStream(), $criteria, SE_UID);
   443|         }
   444|         return $mailIds ?: [];
   445|     }
   446|     /**
   447|      * Save mail body.
   448|      *
   449|      * @param string $filename
   450|      */
   451|     public function saveMail($mailId, $filename = 'email.eml'): bool
   452|     {
   453|         return imap_savebody($this->getImapStream(), $filename, $mailId, '', FT_UID);
   454|     }
   455|     /**
   456|      * Marks mails listed in mailId for deletion.
   457|      */
   458|     public function deleteMail($mailId): bool
   459|     {
   460|         return imap_delete($this->getImapStream(), $mailId, FT_UID);
   461|     }
   462|     /**
   463|      * Move mail to another box.
   464|      */
   465|     public function moveMail($mailId, $mailBox): bool
   466|     {
   467|         return imap_mail_move($this->getImapStream(), $mailId, $mailBox, CP_UID) && $this->expungeDeletedMails();
   468|     }
   469|     /**
   470|      * Deletes all the mails marked for deletion by imap_delete(), imap_mail_move(), or imap_setflag_full().
   471|      */
   472|     public function expungeDeletedMails(): bool
   473|     {
   474|         return imap_expunge($this->getImapStream());
   475|     }
   476|     /**
   477|      * Add the flag \Seen to a mail.
   478|      */
   479|     public function markMailAsRead($mailId): bool
   480|     {
   481|         return $this->setFlag([$mailId], '\\Seen');
   482|     }
   483|     /**
   484|      * Remove the flag \Seen from a mail.
   485|      */
   486|     public function markMailAsUnread($mailId): bool
   487|     {
   488|         return $this->clearFlag([$mailId], '\\Seen');
   489|     }
   490|     /**
   491|      * Add the flag \Flagged to a mail.
   492|      */
   493|     public function markMailAsImportant($mailId): bool
   494|     {
   495|         return $this->setFlag([$mailId], '\\Flagged');
   496|     }
   497|     /**
   498|      * Add the flag \Seen to a mails.
   499|      */
   500|     public function markMailsAsRead(array $mailIds): bool
   501|     {
   502|         return $this->setFlag($mailIds, '\\Seen');
   503|     }
   504|     /**
   505|      * Remove the flag \Seen from some mails.
   506|      */
   507|     public function markMailsAsUnread(array $mailIds): bool
   508|     {
   509|         return $this->clearFlag($mailIds, '\\Seen');
   510|     }
   511|     /**
   512|      * Add the flag \Flagged to some mails.
   513|      */
   514|     public function markMailsAsImportant(array $mailIds): bool
   515|     {
   516|         return $this->setFlag($mailIds, '\\Flagged');
   517|     }
   518|     /**
   519|      * Causes a store to add the specified flag to the flags set for the mails in the specified sequence.
   520|      *
   521|      * @param string $flag which you can set are \Seen, \Answered, \Flagged, \Deleted, and \Draft as defined by RFC2060
   522|      */
   523|     public function setFlag(array $mailsIds, $flag): bool
   524|     {
   525|         return imap_setflag_full($this->getImapStream(), implode(',', $mailsIds), $flag, ST_UID);
   526|     }
   527|     /**
   528|      * Cause a store to delete the specified flag to the flags set for the mails in the specified sequence.
   529|      *
   530|      * @param string $flag which you can set are \Seen, \Answered, \Flagged, \Deleted, and \Draft as defined by RFC2060
   531|      */
   532|     public function clearFlag(array $mailsIds, $flag): bool
   533|     {
   534|         return imap_clearflag_full($this->getImapStream(), implode(',', $mailsIds), $flag, ST_UID);
   535|     }
   536|     /**
   537|      * Fetch mail headers for listed mails ids.
   538|      *
   539|      * Returns an array of objects describing one mail header each. The object will only define a property if it exists. The possible properties are:
   540|      *  subject - the mails subject
   541|      *  from - who sent it
   542|      *  to - recipient
   543|      *  date - when was it sent
   544|      *  message_id - Mail-ID
   545|      *  references - is a reference to this mail id
   546|      *  in_reply_to - is a reply to this mail id
   547|      *  size - size in bytes
   548|      *  uid - UID the mail has in the mailbox
   549|      *  msgno - mail sequence number in the mailbox
   550|      *  recent - this mail is flagged as recent
   551|      *  flagged - this mail is flagged
   552|      *  answered - this mail is flagged as answered
   553|      *  deleted - this mail is flagged for deletion
   554|      *  seen - this mail is flagged as already read
   555|      *  draft - this mail is flagged as being a draft
   556|      *
   557|      * @return array
   558|      */
   559|     public function getMailsInfo(array $mailsIds)
   560|     {
   561|         $mails = imap_fetch_overview($this->getImapStream(), implode(',', $mailsIds), FT_UID);
   562|         if (is_array($mails) && count($mails)) {
   563|             foreach ($mails as &$mail) {
   564|                 if (isset($mail->subject)) {
   565|                     $mail->subject = $this->decodeMimeStr($mail->subject, $this->serverEncoding);
   566|                 }
   567|                 if (isset($mail->from)) {
   568|                     $mail->from = $this->decodeMimeStr($mail->from, $this->serverEncoding);
   569|                 }
   570|                 if (isset($mail->to)) {
   571|                     $mail->to = $this->decodeMimeStr($mail->to, $this->serverEncoding);
   572|                 }
   573|             }
   574|         }
   575|         return $mails;
   576|     }
   577|     /**
   578|      * Get information about the current mailbox.
   579|      *
   580|      * Returns an object with following properties:
   581|      *  Date - last change (current datetime)
   582|      *  Driver - driver
   583|      *  Mailbox - name of the mailbox
   584|      *  Nmsgs - number of messages
   585|      *  Recent - number of recent messages
   586|      *  Unread - number of unread messages
   587|      *  Deleted - number of deleted messages
   588|      *  Size - mailbox size
   589|      */
   590|     public function getMailboxInfo(): \stdClass
   591|     {
   592|         return imap_mailboxmsginfo($this->getImapStream());
   593|     }
   594|     /**
   595|      * Gets mails ids sorted by some criteria.
   596|      *
   597|      * Criteria can be one (and only one) of the following constants:
   598|      *  SORTDATE - mail Date
   599|      *  SORTARRIVAL - arrival date (default)
   600|      *  SORTFROM - mailbox in first From address
   601|      *  SORTSUBJECT - mail subject
   602|      *  SORTTO - mailbox in first To address
   603|      *  SORTCC - mailbox in first cc address
   604|      *  SORTSIZE - size of mail in octets
   605|      *
   606|      * @param int  $criteria
   607|      * @param bool $reverse
   608|      *
   609|      * @return array Mails ids
   610|      */
   611|     public function sortMails($criteria = SORTARRIVAL, $reverse = true): array|bool
   612|     {
   613|         return imap_sort($this->getImapStream(), $criteria, $reverse, SE_UID);
   614|     }
   615|     /**
   616|      * Get mails count in mail box.
   617|      */
   618|     public function countMails(): int|bool
   619|     {
   620|         return imap_num_msg($this->getImapStream());
   621|     }
   622|     /**
   623|      * Retrieve the quota settings per user.
   624|      *
   625|      * @return array - FALSE in the case of call failure
   626|      */
   627|     protected function getQuota(): array|bool
   628|     {
   629|         return imap_get_quotaroot($this->getImapStream(), 'INBOX');
   630|     }
   631|     /**
   632|      * Return quota limit in KB.
   633|      *
   634|      * @return int - FALSE in the case of call failure
   635|      */
   636|     public function getQuotaLimit()
   637|     {
   638|         $quota = $this->getQuota();
   639|         if (is_array($quota)) {
   640|             $quota = $quota['STORAGE']['limit'];
   641|         }
   642|         return $quota;
   643|     }
   644|     /**
   645|      * Return quota usage in KB.
   646|      *
   647|      * @return int - FALSE in the case of call failure
   648|      */
   649|     public function getQuotaUsage()
   650|     {
   651|         $quota = $this->getQuota();
   652|         if (is_array($quota)) {
   653|             $quota = $quota['STORAGE']['usage'];
   654|         }
   655|         return $quota;
   656|     }
   657|     /**
   658|      * Get mail data.
   659|      *
   660|      * @param bool $markAsSeen
   661|      */
   662|     public function getMail($mailId, $markAsSeen = true): Message
   663|     {
   664|         $header     = imap_fetchheader($this->getImapStream(), $mailId, FT_UID);
   665|         $headObject = imap_rfc822_parse_headers($header);
   666|         $mail           = new Message();
   667|         $mail->id       = $mailId;
   668|         $mail->date     = date('Y-m-d H:i:s', isset($headObject->date) ? strtotime(preg_replace('/\(.*?\)/', '', $headObject->date)) : time());
   669|         $mail->subject  = isset($headObject->subject) ? $this->decodeMimeStr($headObject->subject, $this->serverEncoding) : null;
   670|         $mail->fromName = isset($headObject->from[0]->personal) ? $this->decodeMimeStr($headObject->from[0]->personal, $this->serverEncoding)
   671|             : null;
   672|         $mail->fromAddress = strtolower($headObject->from[0]->mailbox.'@'.$headObject->from[0]->host);
   673|         if (isset($headObject->to)) {
   674|             $toStrings = [];
   675|             foreach ($headObject->to as $to) {
   676|                 if (!empty($to->mailbox) && !empty($to->host)) {
   677|                     $toEmail            = strtolower($to->mailbox.'@'.$to->host);
   678|                     $toName             = isset($to->personal) ? $this->decodeMimeStr($to->personal, $this->serverEncoding) : null;
   679|                     $toStrings[]        = $toName ? "$toName <$toEmail>" : $toEmail;
   680|                     $mail->to[$toEmail] = $toName;
   681|                 }
   682|             }
   683|             $mail->toString = implode(', ', $toStrings);
   684|         }
   685|         if (isset($headObject->cc)) {
   686|             foreach ($headObject->cc as $cc) {
   687|                 $mail->cc[strtolower($cc->mailbox.'@'.$cc->host)] = isset($cc->personal) ? $this->decodeMimeStr($cc->personal, $this->serverEncoding)
   688|                     : null;
   689|             }
   690|         }
   691|         if (isset($headObject->reply_to)) {
   692|             foreach ($headObject->reply_to as $replyTo) {
   693|                 $mail->replyTo[strtolower($replyTo->mailbox.'@'.$replyTo->host)] = isset($replyTo->personal) ? $this->decodeMimeStr(
   694|                     $replyTo->personal,
   695|                     $this->serverEncoding
   696|                 ) : null;
   697|             }
   698|         }
   699|         if (isset($headObject->in_reply_to)) {
   700|             $mail->inReplyTo = $headObject->in_reply_to;
   701|         }
   702|         if (isset($headObject->return_path)) {
   703|             $mail->returnPath = $headObject->return_path;
   704|         }
   705|         if (isset($headObject->references)) {
   706|             $mail->references = explode("\n", $headObject->references);
   707|         }
   708|         $mailStructure = imap_fetchstructure($this->getImapStream(), $mailId, FT_UID);
   709|         if (empty($mailStructure->parts)) {
   710|             $this->initMailPart($mail, $mailStructure, 0, $markAsSeen);
   711|         } else {
   712|             foreach ($mailStructure->parts as $partNum => $partStructure) {
   713|                 $this->initMailPart($mail, $partStructure, $partNum + 1, $markAsSeen);
   714|             }
   715|         }
   716|         $tempArray = explode("\n", $header);
   717|         $headers = [];
   718|         foreach ($tempArray as $line) {
   719|             if (preg_match('/^X-(.*?): (.*?)$/is', trim($line), $matches)) {
   720|                 $headers['x-'.strtolower($matches[1])] = $matches[2];
   721|             }
   722|         }
   723|         $mail->xHeaders = $headers;
   724|         return $mail;
   725|     }
   726|     /**
   727|      * @param bool|true  $markAsSeen
   728|      * @param bool|false $isDsn
   729|      * @param bool|false $isFbl
   730|      */
   731|     protected function initMailPart(Message $mail, $partStructure, $partNum, $markAsSeen = true, $isDsn = false, $isFbl = false)
   732|     {
   733|         $options = FT_UID;
   734|         if (!$markAsSeen) {
   735|             $options |= FT_PEEK;
   736|         }
   737|         $data = $partNum
   738|             ? imap_fetchbody($this->getImapStream(), $mail->id, $partNum, $options)
   739|             : imap_body(
   740|                 $this->getImapStream(),
   741|                 $mail->id,
   742|                 $options
   743|             );
   744|         if (1 == $partStructure->encoding) {
   745|             $data = imap_utf8($data);
   746|         } elseif (2 == $partStructure->encoding) {
   747|             $data = imap_binary($data);
   748|         } elseif (3 == $partStructure->encoding) {
   749|             $data = imap_base64($data);
   750|         } elseif (4 == $partStructure->encoding) {
   751|             $data = quoted_printable_decode($data);
   752|         }
   753|         $params = $this->getParameters($partStructure);
   754|         $attachmentId = $partStructure->ifid
   755|             ? trim($partStructure->id, ' <>')
   756|             : (isset($params['filename']) || isset($params['name']) ? mt_rand().mt_rand() : null);
   757|         if (!$partNum && TYPETEXT === $partStructure->type) {
   758|             $attachmentId = null;
   759|         }
   760|         if ($attachmentId) {
   761|             if (isset($this->settings['use_attachments']) && $this->settings['use_attachments']) {
   762|                 if (empty($params['filename']) && empty($params['name'])) {
   763|                     $fileName = $attachmentId.'.'.strtolower($partStructure->subtype);
   764|                 } else {
   765|                     $fileName = !empty($params['filename']) ? $params['filename'] : $params['name'];
   766|                     $fileName = $this->decodeMimeStr($fileName, $this->serverEncoding);
   767|                     $fileName = $this->decodeRFC2231($fileName, $this->serverEncoding);
   768|                 }
   769|                 $attachment       = new Attachment();
   770|                 $attachment->id   = $attachmentId;
   771|                 $attachment->name = $fileName;
   772|                 if ($this->attachmentsDir) {
   773|                     $replace = [
   774|                         '/\s/'                   => '_',
   775|                         '/[^0-9a-z-_\.]/iu' => '',
   776|                         '/_+/'                   => '_',
   777|                         '/(^_)|(_$)/'            => '',
   778|                     ];
   779|                     $fileSysName = preg_replace(
   780|                         '~[\\\\/]~',
   781|                         '',
   782|                         $mail->id.'_'.$attachmentId.'_'.preg_replace(array_keys($replace), $replace, $fileName)
   783|                     );
   784|                     $attachment->filePath = $this->attachmentsDir.DIRECTORY_SEPARATOR.$fileSysName;
   785|                     file_put_contents($attachment->filePath, $data);
   786|                 }
   787|                 $mail->addAttachment($attachment);
   788|             }
   789|         } else {
   790|             if (!empty($params['charset'])) {
   791|                 $data = $this->convertStringEncoding($data, $params['charset'], $this->serverEncoding);
   792|             }
   793|             if (!empty($data)) {
   794|                 $subtype = !empty($partStructure->ifsubtype)
   795|                     ? strtolower($partStructure->subtype)
   796|                     : '';
   797|                 switch ($partStructure->type) {
   798|                     case TYPETEXT:
   799|                         match ($subtype) {
   800|                             'plain' => $mail->textPlain .= $data,
   801|                             default => $mail->textHtml .= $data,
   802|                         };
   803|                         break;
   804|                     case TYPEMULTIPART:
   805|                         if (
   806|                             'report' != $subtype
   807|                             || empty($params['report-type'])
   808|                         ) {
   809|                             break;
   810|                         }
   811|                         $reportType = strtolower($params['report-type']);
   812|                         switch ($reportType) {
   813|                             case 'delivery-status':
   814|                                 $mail->dsnMessage = trim($data);
   815|                                 $isDsn            = true;
   816|                                 break;
   817|                             case 'feedback-report':
   818|                                 $mail->fblMessage = trim($data);
   819|                                 $isFbl            = true;
   820|                                 break;
   821|                             default:
   822|                         }
   823|                         break;
   824|                     case TYPEMESSAGE:
   825|                         if ($isDsn || ('delivery-status' == $subtype)) {
   826|                             $mail->dsnReport = $data;
   827|                         } elseif ($isFbl || ('feedback-report' == $subtype)) {
   828|                             $mail->fblReport = $data;
   829|                         } else {
   830|                             $mail->textPlain .= trim($data);
   831|                         }
   832|                         break;
   833|                     default:
   834|                 }
   835|             }
   836|         }
   837|         if (!empty($partStructure->parts)) {
   838|             foreach ($partStructure->parts as $subPartNum => $subPartStructure) {
   839|                 if (2 == $partStructure->type && 'RFC822' == $partStructure->subtype) {
   840|                     $this->initMailPart($mail, $subPartStructure, $partNum, $markAsSeen, $isDsn, $isFbl);
   841|                 } else {
   842|                     $this->initMailPart($mail, $subPartStructure, $partNum.'.'.($subPartNum + 1), $markAsSeen, $isDsn, $isFbl);
   843|                 }
   844|             }
   845|         }
   846|     }
   847|     protected function getParameters($partStructure): array
   848|     {
   849|         $params = [];
   850|         if (!empty($partStructure->parameters)) {
   851|             foreach ($partStructure->parameters as $param) {
   852|                 $params[strtolower($param->attribute)] = $param->value;
   853|             }
   854|         }
   855|         if (!empty($partStructure->dparameters)) {
   856|             foreach ($partStructure->dparameters as $param) {
   857|                 $paramName = strtolower(preg_match('~^(.*?)\*~', $param->attribute, $matches) ? $matches[1] : $param->attribute);
   858|                 if (isset($params[$paramName])) {
   859|                     $params[$paramName] .= $param->value;
   860|                 } else {
   861|                     $params[$paramName] = $param->value;
   862|                 }
   863|             }
   864|         }
   865|         return $params;
   866|     }
   867|     /**
   868|      * @param string $charset
   869|      */
   870|     protected function decodeMimeStr($string, $charset = 'utf-8'): string
   871|     {
   872|         $newString = '';
   873|         $elements  = imap_mime_header_decode($string);
   874|         for ($i = 0; $i < count($elements); ++$i) {
   875|             if ('default' == $elements[$i]->charset) {
   876|                 $elements[$i]->charset = 'iso-8859-1';
   877|             }
   878|             $newString .= $this->convertStringEncoding($elements[$i]->text, $elements[$i]->charset, $charset);
   879|         }
   880|         return $newString;
   881|     }
   882|     protected function isUrlEncoded($string): bool
   883|     {
   884|         $hasInvalidChars = preg_match('#[^%a-zA-Z0-9\-_\.\+]#', $string);
   885|         $hasEscapedChars = preg_match('#%[a-zA-Z0-9]{2}#', $string);
   886|         return !$hasInvalidChars && $hasEscapedChars;
   887|     }
   888|     /**
   889|      * @param string $charset
   890|      *
   891|      * @return string
   892|      */
   893|     protected function decodeRFC2231($string, $charset = 'utf-8')
   894|     {
   895|         if (preg_match("/^(.*?)'.*?'(.*?)$/", $string, $matches)) {
   896|             $encoding = $matches[1];
   897|             $data     = $matches[2];
   898|             if ($this->isUrlEncoded($data)) {
   899|                 $string = $this->convertStringEncoding(urldecode($data), $encoding, $charset);
   900|             }
   901|         }
   902|         return $string;
   903|     }
   904|     /**
   905|      * Converts a string from one encoding to another.
   906|      *
   907|      * @param string $string
   908|      * @param string $fromEncoding
   909|      * @param string $toEncoding
   910|      *
   911|      * @return string Converted string if conversion was successful, or the original string if not
   912|      */
   913|     protected function convertStringEncoding($string, $fromEncoding, $toEncoding)
   914|     {
   915|         $convertedString = null;
   916|         if ($string && $fromEncoding != $toEncoding) {
   917|             $convertedString = @iconv($fromEncoding, $toEncoding.'//IGNORE', $string);
   918|             if (!$convertedString && extension_loaded('mbstring')) {
   919|                 $convertedString = @mb_convert_encoding($string, $toEncoding, $fromEncoding);
   920|             }
   921|         }
   922|         return $convertedString ?: $string;
   923|     }
   924|     /**
   925|      * Close IMAP connection.
   926|      */
   927|     protected function disconnect()
   928|     {
   929|         if ($this->isConnected()) {
   930|             imap_errors();
   931|             imap_alerts();
   932|             @imap_close($this->imapStream, CL_EXPUNGE);
   933|         }
   934|     }
   935|     private function createAttachmentsDir(PathsHelper $pathsHelper): void
   936|     {
   937|         if (!isset($this->settings['use_attachments']) || !$this->settings['use_attachments']) {
   938|             return;
   939|         }
   940|         $this->attachmentsDir = $pathsHelper->getSystemPath('tmp', true);
   941|         if (!file_exists($this->attachmentsDir)) {
   942|             mkdir($this->attachmentsDir);
   943|         }
   944|         $this->attachmentsDir .= '/attachments';
   945|         if (!file_exists($this->attachmentsDir)) {
   946|             mkdir($this->attachmentsDir);
   947|         }
   948|     }
   949|     /**
   950|      * Disconnect on destruct.
   951|      */
   952|     public function __destruct()
   953|     {
   954|         $this->disconnect();
   955|     }
   956| }


# ====================================================================
# FILE: app/bundles/EmailBundle/Stats/Helper/BouncedHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| <?php
     2| namespace Mautic\EmailBundle\Stats\Helper;
     3| use Mautic\EmailBundle\Stats\FetchOptions\EmailStatOptions;
     4| use Mautic\LeadBundle\Entity\DoNotContact;
     5| use Mautic\StatsBundle\Aggregate\Collection\StatCollection;
     6| class BouncedHelper extends AbstractHelper
     7| {
     8|     public const NAME = 'email-bounced';
     9|     public function getName(): string
    10|     {
    11|         return self::NAME;
    12|     }
    13|     /**
    14|      * @throws \Exception
    15|      */
    16|     public function generateStats(\DateTime $fromDateTime, \DateTime $toDateTime, EmailStatOptions $options, StatCollection $statCollection): void
    17|     {
    18|         $query = $this->getQuery($fromDateTime, $toDateTime);
    19|         $q     = $query->prepareTimeDataQuery('lead_donotcontact', 'date_added');
    20|         $q->andWhere('t.channel = :channel')
    21|             ->setParameter('channel', 'email')
    22|             ->andWhere($q->expr()->eq('t.reason', ':reason'))
    23|             ->setParameter('reason', DoNotContact::BOUNCED);
    24|         $this->limitQueryToEmailIds($q, $options->getEmailIds(), 'channel_id', 't');
    25|         $q->join('t', MAUTIC_TABLE_PREFIX.'email_stats', 'es', 't.channel_id = es.email_id AND t.channel = \'email\' AND t.lead_id = es.lead_id');
    26|         if (!$options->canViewOthers()) {
    27|             $this->limitQueryToCreator($q, 'es.email_id');
    28|         }
    29|         $this->addCompanyFilter($q, $options->getCompanyId());
    30|         $this->addCampaignFilter($q, $options->getCampaignId(), 'es');
    31|         $this->addSegmentFilter($q, $options->getSegmentId(), 'es');
    32|         $this->fetchAndBindToCollection($q, $statCollection);
    33|     }
    34| }


# ====================================================================
# FILE: app/bundles/EmailBundle/Stats/Helper/UnsubscribedHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| <?php
     2| namespace Mautic\EmailBundle\Stats\Helper;
     3| use Mautic\EmailBundle\Stats\FetchOptions\EmailStatOptions;
     4| use Mautic\LeadBundle\Entity\DoNotContact;
     5| use Mautic\StatsBundle\Aggregate\Collection\StatCollection;
     6| class UnsubscribedHelper extends AbstractHelper
     7| {
     8|     public const NAME = 'email-unsubscribed';
     9|     public function getName(): string
    10|     {
    11|         return self::NAME;
    12|     }
    13|     /**
    14|      * @throws \Exception
    15|      */
    16|     public function generateStats(\DateTime $fromDateTime, \DateTime $toDateTime, EmailStatOptions $options, StatCollection $statCollection): void
    17|     {
    18|         $query = $this->getQuery($fromDateTime, $toDateTime);
    19|         $q     = $query->prepareTimeDataQuery('lead_donotcontact', 'date_added');
    20|         $q->andWhere('t.channel = :channel')
    21|             ->setParameter('channel', 'email')
    22|             ->andWhere($q->expr()->eq('t.reason', ':reason'))
    23|             ->setParameter('reason', DoNotContact::UNSUBSCRIBED);
    24|         $this->limitQueryToEmailIds($q, $options->getEmailIds(), 'channel_id', 't');
    25|         $q->join('t', MAUTIC_TABLE_PREFIX.'email_stats', 'es', 't.channel_id = es.email_id AND t.channel = \'email\' AND t.lead_id = es.lead_id');
    26|         if (!$options->canViewOthers()) {
    27|             $this->limitQueryToCreator($q, 'es.email_id');
    28|         }
    29|         $this->addCompanyFilter($q, $options->getCompanyId());
    30|         $this->addCampaignFilter($q, $options->getCampaignId(), 'es');
    31|         $this->addSegmentFilter($q, $options->getSegmentId(), 'es');
    32|         $this->fetchAndBindToCollection($q, $statCollection);
    33|     }
    34| }


# ====================================================================
# FILE: app/bundles/UserBundle/Config/services.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| <?php
     2| declare(strict_types=1);
     3| use Mautic\CoreBundle\DependencyInjection\MauticCoreExtension;
     4| use Mautic\UserBundle\EventListener\ApiUserSubscriber;
     5| use Mautic\UserBundle\Security\Authentication\Token\Permissions\TokenPermissions;
     6| use Mautic\UserBundle\Security\Authenticator\PluginAuthenticator;
     7| use Mautic\UserBundle\Security\Authenticator\SsoAuthenticator;
     8| use Mautic\UserBundle\Security\EntryPoint\MainEntryPoint;
     9| use function Symfony\Component\DependencyInjection\Loader\Configurator\abstract_arg;
    10| use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
    11| use function Symfony\Component\DependencyInjection\Loader\Configurator\service;
    12| return function (ContainerConfigurator $configurator): void {
    13|     $services = $configurator->services()
    14|         ->defaults()
    15|         ->autowire()
    16|         ->autoconfigure()
    17|         ->public();
    18|     $excludes = [
    19|     ];
    20|     $services->load('Mautic\\UserBundle\\', '../')
    21|         ->exclude('../{'.implode(',', array_merge(MauticCoreExtension::DEFAULT_EXCLUDES, $excludes)).'}');
    22|     $services->load('Mautic\\UserBundle\\Entity\\', '../Entity/*Repository.php')
    23|         ->tag(Doctrine\Bundle\DoctrineBundle\DependencyInjection\Compiler\ServiceRepositoryCompilerPass::REPOSITORY_SERVICE_TAG);
    24|     $services->set('security.authenticator.mautic_sso', SsoAuthenticator::class)
    25|         ->abstract()
    26|         ->args([
    27|             '$httpUtils'      => service('security.http_utils'),
    28|             '$userProvider'   => abstract_arg('user provider'),
    29|             '$successHandler' => abstract_arg('authentication success handler'),
    30|             '$failureHandler' => abstract_arg('authentication failure handler'),
    31|             '$options'        => abstract_arg('options'),
    32|         ]);
    33|     $services->set('security.authenticator.mautic_api', PluginAuthenticator::class)
    34|         ->abstract()
    35|         ->args([
    36|             '$oAuth2' => service('fos_oauth_server.server'),
    37|         ]);
    38|     $services->set('security.token.permissions', TokenPermissions::class);
    39|     $services->load('Mautic\\UserBundle\\Security\\EntryPoint\\', '../Security/EntryPoint/*.php');
    40|     $services->load('Mautic\\UserBundle\\Security\\Authentication\\Token\\Permissions\\', '../Security/Authentication/Token/Permissions/*.php');
    41|     $services->alias(Mautic\UserBundle\Entity\UserTokenRepositoryInterface::class, Mautic\UserBundle\Entity\UserTokenRepository::class);
    42|     $services->alias('mautic.user.model.role', Mautic\UserBundle\Model\RoleModel::class);
    43|     $services->alias('mautic.user.model.user', Mautic\UserBundle\Model\UserModel::class);
    44|     $services->alias('mautic.user.repository.user_token', Mautic\UserBundle\Entity\UserTokenRepository::class);
    45|     $services->alias('mautic.user.repository', Mautic\UserBundle\Entity\UserRepository::class);
    46|     $services->alias('mautic.permission.repository', Mautic\UserBundle\Entity\PermissionRepository::class);
    47|     $services->alias('mautic.user.model.password_strength_estimator', Mautic\UserBundle\Model\PasswordStrengthEstimatorModel::class);
    48|     $services->get(Mautic\UserBundle\Form\Validator\Constraints\NotWeakValidator::class)->tag('validator.constraint_validator');
    49|     $services->load('Mautic\\UserBundle\\Security\\SAML\Store\\Request\\', '../Security/SAML/Store/Request/*.php');
    50|     $services->get(Mautic\UserBundle\Security\SAML\Store\Request\RequestStateStore::class)
    51|         ->arg('$prefix', '%lightsaml.store.request_session_prefix%')
    52|         ->arg('$suffix', '%lightsaml.store.request_session_sufix%');
    53|     $services->get(MainEntryPoint::class)->arg('$samlEnabled', '%env(MAUTIC_SAML_ENABLED)%');
    54|     $services->get(ApiUserSubscriber::class)->arg('$userProvider', service('security.user_providers'));
    55|     $services->alias(LightSaml\SymfonyBridgeBundle\Bridge\Container\BuildContainer::class, 'lightsaml.container.build');
    56|     $services->load('LightSaml\\SpBundle\\Controller\\', '%kernel.project_dir%/vendor/javer/sp-bundle/src/LightSaml/SpBundle/Controller/*.php')
    57|         ->tag('controller.service_arguments');
    58|     $services->set('mautic.security.authenticator.form_login.decorator', Mautic\UserBundle\Security\TimingSafeFormLoginAuthenticator::class)
    59|         ->decorate('security.authenticator.form_login.main')
    60|         ->args([
    61|             service('.inner'),
    62|             service('mautic.user.provider'),
    63|             service('security.password_hasher_factory'),
    64|             [], // This will be replaced by the compiler pass
    65|         ]);
    66| };


# ====================================================================
# FILE: app/bundles/UserBundle/DependencyInjection/Compiler/FormLoginAuthenticatorOptionsPass.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\UserBundle\DependencyInjection\Compiler;
     4| use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
     5| use Symfony\Component\DependencyInjection\ContainerBuilder;
     6| class FormLoginAuthenticatorOptionsPass implements CompilerPassInterface
     7| {
     8|     public function process(ContainerBuilder $container): void
     9|     {
    10|         if (!$container->has('mautic.security.authenticator.form_login.decorator')) {
    11|             return;
    12|         }
    13|         $decoratedServiceId = 'mautic.security.authenticator.form_login.decorator.inner';
    14|         if (!$container->has($decoratedServiceId)) {
    15|             return;
    16|         }
    17|         $decoratedService = $container->getDefinition($decoratedServiceId);
    18|         $options          = $decoratedService->getArgument(4);
    19|         $decorator = $container->getDefinition('mautic.security.authenticator.form_login.decorator');
    20|         $decorator->replaceArgument(3, $options);
    21|     }
    22| }


# ====================================================================
# FILE: app/bundles/UserBundle/MauticUserBundle.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| <?php
     2| namespace Mautic\UserBundle;
     3| use Mautic\UserBundle\DependencyInjection\Compiler\FormLoginAuthenticatorOptionsPass;
     4| use Mautic\UserBundle\DependencyInjection\Compiler\OAuthReplacePass;
     5| use Mautic\UserBundle\DependencyInjection\Compiler\SsoAuthenticatorPass;
     6| use Mautic\UserBundle\DependencyInjection\Firewall\Factory\MauticSsoFactory;
     7| use Mautic\UserBundle\DependencyInjection\Firewall\Factory\PluginFactory;
     8| use Symfony\Bundle\SecurityBundle\DependencyInjection\SecurityExtension;
     9| use Symfony\Component\DependencyInjection\Compiler\PassConfig;
    10| use Symfony\Component\DependencyInjection\ContainerBuilder;
    11| use Symfony\Component\HttpKernel\Bundle\Bundle;
    12| class MauticUserBundle extends Bundle
    13| {
    14|     public function build(ContainerBuilder $container): void
    15|     {
    16|         parent::build($container);
    17|         $extension = $container->getExtension('security');
    18|         \assert($extension instanceof SecurityExtension);
    19|         $extension->addAuthenticatorFactory(new PluginFactory());
    20|         $extension->addAuthenticatorFactory(new MauticSsoFactory());
    21|         $container->addCompilerPass(new OAuthReplacePass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
    22|         $container->addCompilerPass(new SsoAuthenticatorPass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
    23|         $container->addCompilerPass(new FormLoginAuthenticatorOptionsPass(), PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
    24|     }
    25| }


# ====================================================================
# FILE: app/bundles/UserBundle/Security/TimingSafeFormLoginAuthenticator.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-125 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\UserBundle\Security;
     4| use Mautic\UserBundle\Entity\User;
     5| use Symfony\Component\HttpFoundation\Request;
     6| use Symfony\Component\HttpFoundation\Response;
     7| use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
     8| use Symfony\Component\PasswordHasher\Hasher\PasswordHasherFactoryInterface;
     9| use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    10| use Symfony\Component\Security\Core\Exception\AuthenticationException;
    11| use Symfony\Component\Security\Core\Exception\UserNotFoundException;
    12| use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
    13| use Symfony\Component\Security\Core\User\UserInterface;
    14| use Symfony\Component\Security\Core\User\UserProviderInterface;
    15| use Symfony\Component\Security\Http\Authenticator\AuthenticatorInterface;
    16| use Symfony\Component\Security\Http\Authenticator\FormLoginAuthenticator;
    17| use Symfony\Component\Security\Http\Authenticator\InteractiveAuthenticatorInterface;
    18| use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
    19| use Symfony\Component\Security\Http\Authenticator\Passport\Badge\PasswordUpgradeBadge;
    20| use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
    21| use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
    22| use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
    23| use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
    24| use Symfony\Component\Security\Http\EntryPoint\AuthenticationEntryPointInterface;
    25| use Symfony\Component\Security\Http\SecurityRequestAttributes;
    26| class TimingSafeFormLoginAuthenticator implements AuthenticatorInterface, AuthenticationEntryPointInterface, InteractiveAuthenticatorInterface
    27| {
    28|     /**
    29|      * @var array<mixed>
    30|      */
    31|     private array $options;
    32|     /**
    33|      * @param array<mixed> $options
    34|      */
    35|     public function __construct(private FormLoginAuthenticator $authenticator, private UserProviderInterface $userProvider, private PasswordHasherFactoryInterface $passwordHasherFactory, array $options)
    36|     {
    37|         $this->authenticator         = $authenticator;
    38|         $this->userProvider          = $userProvider;
    39|         $this->passwordHasherFactory = $passwordHasherFactory;
    40|         $this->options               = array_merge([
    41|             'username_parameter' => '_username',
    42|             'password_parameter' => '_password',
    43|             'check_path'         => '/login_check',
    44|             'post_only'          => true,
    45|             'form_only'          => false,
    46|             'enable_csrf'        => false,
    47|             'csrf_parameter'     => '_csrf_token',
    48|             'csrf_token_id'      => 'authenticate',
    49|         ], $options);
    50|     }
    51|     public function supports(Request $request): ?bool
    52|     {
    53|         return $this->authenticator->supports($request);
    54|     }
    55|     public function authenticate(Request $request): Passport
    56|     {
    57|         $credentials           = $this->getCredentials($request);
    58|         $passwordHasherFactory = $this->passwordHasherFactory;
    59|         $userLoader            = function (string $identifier) use ($passwordHasherFactory, $credentials): UserInterface {
    60|             try {
    61|                 return $this->userProvider->loadUserByIdentifier($identifier);
    62|             } catch (UserNotFoundException $e) {
    63|                 $user = new User();
    64|                 $passwordHasherFactory->getPasswordHasher($user)->verify('$2y$13$aAwXNyqA87lcXQQuk8Cp6eo2amRywLct29oG2uWZ8lYBeamFZ8UhK', $credentials['password']);
    65|                 throw $e;
    66|             }
    67|         };
    68|         $userBadge = new UserBadge($credentials['username'], $userLoader);
    69|         $passport  = new Passport($userBadge, new PasswordCredentials($credentials['password']), [new RememberMeBadge()]);
    70|         if ($this->options['enable_csrf']) {
    71|             $passport->addBadge(new CsrfTokenBadge($this->options['csrf_token_id'], $credentials['csrf_token']));
    72|         }
    73|         if ($this->userProvider instanceof PasswordUpgraderInterface) {
    74|             $passport->addBadge(new PasswordUpgradeBadge($credentials['password'], $this->userProvider));
    75|         }
    76|         return $passport;
    77|     }
    78|     public function createToken(Passport $passport, string $firewallName): TokenInterface
    79|     {
    80|         return $this->authenticator->createToken($passport, $firewallName);
    81|     }
    82|     public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    83|     {
    84|         return $this->authenticator->onAuthenticationSuccess($request, $token, $firewallName);
    85|     }
    86|     public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
    87|     {
    88|         return $this->authenticator->onAuthenticationFailure($request, $exception);
    89|     }
    90|     public function start(Request $request, ?AuthenticationException $authException = null): Response
    91|     {
    92|         return $this->authenticator->start($request, $authException);
    93|     }
    94|     public function isInteractive(): bool
    95|     {
    96|         return $this->authenticator->isInteractive();
    97|     }
    98|     /**
    99|      * @return array<mixed>
   100|      */
   101|     private function getCredentials(Request $request): array
   102|     {
   103|         $credentials               = [];
   104|         $credentials['csrf_token'] = $request->get($this->options['csrf_parameter']);
   105|         if ($this->options['post_only']) {
   106|             $credentials['username'] = $request->request->get($this->options['username_parameter']);
   107|             $credentials['password'] = $request->request->get($this->options['password_parameter'], '');
   108|         } else {
   109|             $credentials['username'] = $request->get($this->options['username_parameter']);
   110|             $credentials['password'] = $request->get($this->options['password_parameter'], '');
   111|         }
   112|         if (!\is_string($credentials['username']) && !$credentials['username'] instanceof \Stringable) {
   113|             throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['username_parameter'], \gettype($credentials['username'])));
   114|         }
   115|         $credentials['username'] = trim($credentials['username']);
   116|         $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $credentials['username']);
   117|         if (!\is_string($credentials['password']) && (!\is_object($credentials['password']) || !method_exists($credentials['password'], '__toString'))) {
   118|             throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['password_parameter'], \gettype($credentials['password'])));
   119|         }
   120|         if (!\is_string($credentials['csrf_token'] ?? '') && (!\is_object($credentials['csrf_token']) || !method_exists($credentials['csrf_token'], '__toString'))) {
   121|             throw new BadRequestHttpException(sprintf('The key "%s" must be a string, "%s" given.', $this->options['csrf_parameter'], \gettype($credentials['csrf_token'])));
   122|         }
   123|         return $credentials;
   124|     }
   125| }


# ====================================================================
# FILE: app/bundles/WebhookBundle/Assets/js/webhook.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| Mautic.sendHookTest = function() {
     2|     var url = mQuery('#webhook_webhookUrl').val();
     3|     var secret = mQuery('#webhook_secret').val();
     4|     var eventTypes = mQuery("#event-types input[type='checkbox']");
     5|     var selectedTypes = [];
     6|     eventTypes.each(function() {
     7|         var item = mQuery(this);
     8|         if (item.is(':checked')) {
     9|             selectedTypes.push(item.val());
    10|         }
    11|     });
    12|     var data = {
    13|         action: 'webhook:sendHookTest',
    14|         url: url,
    15|         secret: secret,
    16|         types: selectedTypes
    17|     };
    18|     var spinner = mQuery('#spinner');
    19|     spinner.removeClass('hide');
    20|     mQuery.ajax({
    21|         url: mauticAjaxUrl,
    22|         data: data,
    23|         type: 'POST',
    24|         dataType: "json",
    25|         success: function(response) {
    26|             if (response.html) {
    27|                 mQuery('#tester').html(response.html);
    28|             }
    29|         },
    30|         error: function (response, textStatus, errorThrown) {
    31|             console.log(response.responseJSON);
    32|             if (response.responseJSON.html) {
    33|                 mQuery('#tester').html(response.responseJSON.html);
    34|             } else {
    35|                 Mautic.processAjaxError(response, textStatus, errorThrown);
    36|             }
    37|         },
    38|         complete: function(response) {
    39|             spinner.addClass('hide');
    40|         }
    41|     })
    42| };


# ====================================================================
# FILE: app/bundles/WebhookBundle/Config/config.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-75 ---
     1| <?php
     2| return [
     3|     'routes' => [
     4|         'main' => [
     5|             'mautic_webhook_index' => [
     6|                 'path'       => '/webhooks/{page}',
     7|                 'controller' => 'Mautic\WebhookBundle\Controller\WebhookController::indexAction',
     8|             ],
     9|             'mautic_webhook_action' => [
    10|                 'path'       => '/webhooks/{objectAction}/{objectId}',
    11|                 'controller' => 'Mautic\WebhookBundle\Controller\WebhookController::executeAction',
    12|             ],
    13|         ],
    14|         'api' => [
    15|             'mautic_api_webhookstandard' => [
    16|                 'standard_entity' => true,
    17|                 'name'            => 'hooks',
    18|                 'path'            => '/hooks',
    19|                 'controller'      => Mautic\WebhookBundle\Controller\Api\WebhookApiController::class,
    20|             ],
    21|             'mautic_api_webhookevents' => [
    22|                 'path'       => '/hooks/triggers',
    23|                 'controller' => 'Mautic\WebhookBundle\Controller\Api\WebhookApiController::getTriggersAction',
    24|             ],
    25|         ],
    26|     ],
    27|     'menu' => [
    28|         'admin' => [
    29|             'items' => [
    30|                 'mautic.webhook.webhooks' => [
    31|                     'id'        => 'mautic_webhook_root',
    32|                     'access'    => ['webhook:webhooks:viewown', 'webhook:webhooks:viewother'],
    33|                     'route'     => 'mautic_webhook_index',
    34|                     'parent'    => 'mautic.core.integrations',
    35|                     'iconClass' => 'ri-webhook-fill',
    36|                 ],
    37|             ],
    38|         ],
    39|     ],
    40|     'services' => [
    41|         'others' => [
    42|             'mautic.webhook.notificator.webhookkillnotificator' => [
    43|                 'class'     => Mautic\WebhookBundle\Notificator\WebhookKillNotificator::class,
    44|                 'arguments' => [
    45|                     'translator',
    46|                     'router',
    47|                     'mautic.core.model.notification',
    48|                     'doctrine.orm.entity_manager',
    49|                     'mautic.helper.mailer',
    50|                     'mautic.helper.core_parameters',
    51|                 ],
    52|             ],
    53|             'mautic.webhook.campaign.helper' => [
    54|                 'class'     => Mautic\WebhookBundle\Helper\CampaignHelper::class,
    55|                 'arguments' => [
    56|                     'mautic.http.client',
    57|                     'mautic.lead.model.company',
    58|                     'event_dispatcher',
    59|                 ],
    60|             ],
    61|         ],
    62|     ],
    63|     'parameters' => [
    64|         'webhook_limit'                        => 10, // How many entities can be sent in one webhook
    65|         'webhook_time_limit'                   => 600, // How long the webhook processing can run in seconds
    66|         'webhook_log_max'                      => 1000, // How many recent logs to keep
    67|         'clean_webhook_logs_in_background'     => false,
    68|         'webhook_disable_limit'                => 100, // How many times the webhook response can fail until the webhook will be unpublished
    69|         'webhook_timeout'                      => 15, // How long the CURL request can wait for response before Mautic hangs up. In seconds
    70|         'queue_mode'                           => Mautic\WebhookBundle\Model\WebhookModel::IMMEDIATE_PROCESS, // Trigger the webhook immediately or queue it for faster response times
    71|         'events_orderby_dir'                   => Doctrine\Common\Collections\Order::Ascending->value, // Order the queued events chronologically or the other way around
    72|         'webhook_email_details'                => true, // If enabled, email related webhooks send detailed data
    73|         'webhook_allowed_private_addresses'    => [],
    74|     ],
    75| ];


# ====================================================================
# FILE: app/bundles/WebhookBundle/Controller/AjaxController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| <?php
     2| namespace Mautic\WebhookBundle\Controller;
     3| use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
     4| use Mautic\CoreBundle\Helper\InputHelper;
     5| use Mautic\CoreBundle\Helper\PathsHelper;
     6| use Mautic\WebhookBundle\Exception\PrivateAddressException;
     7| use Mautic\WebhookBundle\Http\Client;
     8| use Symfony\Component\HttpFoundation\JsonResponse;
     9| use Symfony\Component\HttpFoundation\Request;
    10| use Symfony\Component\HttpFoundation\Response;
    11| class AjaxController extends CommonAjaxController
    12| {
    13|     public function sendHookTestAction(Request $request, Client $client, PathsHelper $pathsHelper): JsonResponse
    14|     {
    15|         try {
    16|             return $this->processWebhookTest($request, $client, $pathsHelper);
    17|         } catch (PrivateAddressException) {
    18|             return $this->createErrorResponse(
    19|                 'mautic.webhook.error.private_address'
    20|             );
    21|         } catch (\Exception) {
    22|             return $this->createErrorResponse(
    23|                 'mautic.webhook.label.warning'
    24|             );
    25|         }
    26|     }
    27|     private function processWebhookTest(Request $request, Client $client, PathsHelper $pathsHelper): JsonResponse
    28|     {
    29|         $url = $this->validateUrl($request);
    30|         if (!$url) {
    31|             return $this->createErrorResponse('mautic.webhook.label.no.url');
    32|         }
    33|         $selectedTypes        = InputHelper::cleanArray($request->request->all()['types']) ?? [];
    34|         $payloadPaths         = $this->getPayloadPaths($selectedTypes, $pathsHelper);
    35|         $payload              = $this->loadPayloads($payloadPaths);
    36|         $payload['timestamp'] = (new \DateTimeImmutable())->format('c');
    37|         $secret               = InputHelper::string($request->request->get('secret'));
    38|         $response = $client->post($url, $payload, $secret);
    39|         return $this->createResponseFromStatusCode($response->getStatusCode());
    40|     }
    41|     private function validateUrl(Request $request): ?string
    42|     {
    43|         $url = InputHelper::url($request->request->get('url'));
    44|         return '' !== $url ? $url : null;
    45|     }
    46|     private function createResponseFromStatusCode(int $statusCode): JsonResponse
    47|     {
    48|         $isSuccess = str_starts_with((string) $statusCode, '2');
    49|         $message   = $isSuccess
    50|             ? 'mautic.webhook.label.success'
    51|             : 'mautic.webhook.label.warning';
    52|         $cssClass = $isSuccess ? 'has-success' : 'has-error';
    53|         return $this->createJsonResponse($message, $cssClass);
    54|     }
    55|     private function createErrorResponse(string $message): JsonResponse
    56|     {
    57|         return $this->createJsonResponse($message, 'has-error', Response::HTTP_BAD_REQUEST);
    58|     }
    59|     private function createJsonResponse(
    60|         string $message,
    61|         string $cssClass,
    62|         int $status = Response::HTTP_OK,
    63|     ): JsonResponse {
    64|         $html = sprintf(
    65|             '<div class="%s"><span class="help-block">%s</span></div>',
    66|             $cssClass,
    67|             $this->translator->trans($message)
    68|         );
    69|         return $this->sendJsonResponse(
    70|             ['html' => $html],
    71|             $status
    72|         );
    73|     }
    74|     /*
    75|      * Get an array of all the payload paths we need to load
    76|      *
    77|      * @param $types array
    78|      * @return array
    79|      */
    80|     /**
    81|      * @return non-falsy-string[]
    82|      */
    83|     public function getPayloadPaths($types, PathsHelper $pathsHelper): array
    84|     {
    85|         $payloadPaths = [];
    86|         foreach ($types as $type) {
    87|             $typePath = explode('_', $type);
    88|             $prefix = $typePath[0];
    89|             unset($typePath[0]);
    90|             $eventName = implode('_', $typePath);
    91|             $payloadPath = $pathsHelper->getSystemPath('bundles', true);
    92|             if (strpos('plugin.', $prefix)) {
    93|                 $payloadPath = $pathsHelper->getSystemPath('plugins', true);
    94|             }
    95|             $prefixParts = explode('.', $prefix);
    96|             $bundleName = array_pop($prefixParts);
    97|             $payloadPath .= '/'.ucfirst($bundleName).'Bundle/Assets/WebhookPayload/'.$bundleName.'_'.$eventName.'.json';
    98|             $payloadPaths[$type] = $payloadPath;
    99|         }
   100|         return $payloadPaths;
   101|     }
   102|     /*
   103|      * Iterate through the paths and get the json payloads
   104|      *
   105|      * @param  $paths array
   106|      * @return $payload array
   107|      */
   108|     /**
   109|      * @return mixed[]
   110|      */
   111|     public function loadPayloads($paths): array
   112|     {
   113|         $payloads = [];
   114|         foreach ($paths as $key => $path) {
   115|             if (file_exists($path)) {
   116|                 $payloads[$key] = json_decode(file_get_contents($path), true);
   117|             }
   118|         }
   119|         return $payloads;
   120|     }
   121| }


# ====================================================================
# FILE: app/bundles/WebhookBundle/Exception/PrivateAddressException.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\WebhookBundle\Exception;
     4| class PrivateAddressException extends \Exception
     5| {
     6|     private const DEFAULT_MESSAGE = 'Access to private addresses is not allowed.';
     7|     public function __construct(string $message = self::DEFAULT_MESSAGE, int $code = 0, \Throwable $previous = null)
     8|     {
     9|         parent::__construct($message, $code, $previous);
    10|     }
    11| }


# ====================================================================
# FILE: app/bundles/WebhookBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-82 ---
     1| <?php
     2| namespace Mautic\WebhookBundle\Form\Type;
     3| use Doctrine\Common\Collections\Order;
     4| use Mautic\CoreBundle\Form\DataTransformer\ArrayLinebreakTransformer;
     5| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
     6| use Symfony\Component\Form\AbstractType;
     7| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     8| use Symfony\Component\Form\Extension\Core\Type\TextareaType;
     9| use Symfony\Component\Form\FormBuilderInterface;
    10| use Symfony\Component\Validator\Constraints\NotBlank;
    11| /**
    12|  * @extends AbstractType<array<mixed>>
    13|  */
    14| class ConfigType extends AbstractType
    15| {
    16|     public function buildForm(FormBuilderInterface $builder, array $options): void
    17|     {
    18|         $builder->add('queue_mode', ChoiceType::class, [
    19|             'choices' => [
    20|                 'mautic.webhook.config.immediate_process' => 'immediate_process',
    21|                 'mautic.webhook.config.cron_process'      => 'command_process',
    22|             ],
    23|             'label' => 'mautic.webhook.config.form.queue.mode',
    24|             'attr'  => [
    25|                 'class'   => 'form-control',
    26|                 'tooltip' => 'mautic.webhook.config.form.queue.mode.tooltip',
    27|             ],
    28|             'placeholder' => false,
    29|             'constraints' => [
    30|                 new NotBlank(
    31|                     [
    32|                         'message' => 'mautic.core.value.required',
    33|                     ]
    34|                 ),
    35|             ],
    36|         ]);
    37|         $builder->add('events_orderby_dir', ChoiceType::class, [
    38|             'choices' => [
    39|                 'mautic.webhook.config.event.orderby.chronological'         => Order::Ascending->value,
    40|                 'mautic.webhook.config.event.orderby.reverse.chronological' => Order::Descending->value,
    41|             ],
    42|             'label' => 'mautic.webhook.config.event.orderby',
    43|             'attr'  => [
    44|                 'class'   => 'form-control',
    45|                 'tooltip' => 'mautic.webhook.config.event.orderby.tooltip',
    46|             ],
    47|             'required'          => false,
    48|         ]);
    49|         $builder->add(
    50|             'webhook_email_details',
    51|             YesNoButtonGroupType::class,
    52|             [
    53|                 'label' => 'mautic.webhook.config.email.details',
    54|                 'data'  => (bool) ($options['data']['webhook_email_details'] ?? null),
    55|                 'attr'  => [
    56|                     'class'   => 'form-control',
    57|                     'tooltip' => 'mautic.webhook.config.email.details.tooltip',
    58|                 ],
    59|             ]
    60|         );
    61|         $builder->add(
    62|             $builder->create(
    63|                 'webhook_allowed_private_addresses',
    64|                 TextareaType::class,
    65|                 [
    66|                     'label'      => 'mautic.webhook.config.allowed_private_addresses',
    67|                     'label_attr' => ['class' => 'control-label'],
    68|                     'attr'       => [
    69|                         'class'   => 'form-control',
    70|                         'tooltip' => 'mautic.webhook.config.allowed_private_addresses.tooltip',
    71|                         'rows'    => 8,
    72|                     ],
    73|                     'required' => false,
    74|                 ]
    75|             )->addViewTransformer(new ArrayLinebreakTransformer())
    76|         );
    77|     }
    78|     public function getBlockPrefix(): string
    79|     {
    80|         return 'webhookconfig';
    81|     }
    82| }


# ====================================================================
# FILE: app/bundles/WebhookBundle/Http/Client.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php
     2| namespace Mautic\WebhookBundle\Http;
     3| use GuzzleHttp\Client as GuzzleClient;
     4| use GuzzleHttp\Psr7\Request;
     5| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     6| use Mautic\CoreBundle\Helper\PrivateAddressChecker;
     7| use Mautic\WebhookBundle\Exception\PrivateAddressException;
     8| use Psr\Http\Message\ResponseInterface;
     9| class Client
    10| {
    11|     public function __construct(
    12|         private CoreParametersHelper $coreParametersHelper,
    13|         private GuzzleClient $httpClient,
    14|         private PrivateAddressChecker $privateAddressChecker,
    15|     ) {
    16|     }
    17|     /**
    18|      * @throws \Http\Client\Exception
    19|      */
    20|     public function post($url, array $payload, string $secret = null): ResponseInterface
    21|     {
    22|         $jsonPayload = json_encode($payload);
    23|         $signature   = null === $secret ? null : base64_encode(hash_hmac('sha256', $jsonPayload, $secret, true));
    24|         $headers     = [
    25|             'Content-Type'      => 'application/json',
    26|             'X-Origin-Base-URL' => $this->coreParametersHelper->get('site_url'),
    27|             'Webhook-Signature' => $signature,
    28|         ];
    29|         $allowedPrivateAddresses = $this->coreParametersHelper->get('webhook_allowed_private_addresses');
    30|         $this->privateAddressChecker->setAllowedPrivateAddresses($allowedPrivateAddresses);
    31|         if (!$this->privateAddressChecker->isAllowedUrl($url)) {
    32|             throw new PrivateAddressException();
    33|         }
    34|         return $this->httpClient->sendRequest(new Request('POST', $url, $headers, $jsonPayload));
    35|     }
    36| }

