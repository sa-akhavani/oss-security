# ====================================================================
# FILE: .devcontainer/setup-project.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| set -ex
     2| wait_for_docker() {
     3|   while true; do
     4|     docker ps > /dev/null 2>&1 && break
     5|     sleep 1
     6|   done
     7|   echo "Docker is ready."
     8| }
     9| wait_for_docker
    10| ddev debug download-images
    11| ddev poweroff
    12| ddev -v
    13| ddev config global --web-environment="MAUTIC_URL=https://${CODESPACE_NAME}-80.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN},PHPMYADMIN_URL=https://${CODESPACE_NAME}-8036.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN},MAILHOG_URL=https://${CODESPACE_NAME}-8025.${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN}"
    14| cat <<EOF >.ddev/docker-compose.phpmyadmin_norouter.yaml
    15| services:
    16|   phpmyadmin:
    17|     ports:
    18|       - 8036:80
    19| EOF
    20| ddev start -y


# ====================================================================
# FILE: app/AppKernel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-283 ---
     1| <?php
     2| use Mautic\CoreBundle\Loader\ParameterLoader;
     3| use Mautic\CoreBundle\Release\ThisRelease;
     4| use Symfony\Component\Config\Loader\LoaderInterface;
     5| use Symfony\Component\DependencyInjection\ContainerBuilder;
     6| use Symfony\Component\HttpFoundation\RedirectResponse;
     7| use Symfony\Component\HttpFoundation\Request;
     8| use Symfony\Component\HttpFoundation\Response;
     9| use Symfony\Component\HttpKernel\HttpKernelInterface;
    10| use Symfony\Component\HttpKernel\Kernel;
    11| /**
    12|  * Mautic Application Kernel.
    13|  */
    14| class AppKernel extends Kernel
    15| {
    16|     /**
    17|      * @var bool|null
    18|      */
    19|     private $installed;
    20|     /**
    21|      * @var ParameterLoader|null
    22|      */
    23|     private $parameterLoader;
    24|     /**
    25|      * @var string
    26|      */
    27|     private $projectDir;
    28|     /**
    29|      * @param string $environment The environment
    30|      * @param bool   $debug       Whether to enable debugging or not
    31|      *
    32|      * @api
    33|      */
    34|     public function __construct($environment, $debug)
    35|     {
    36|         $metadata = ThisRelease::getMetadata();
    37|         defined('MAUTIC_ENV') or define('MAUTIC_ENV', $environment);
    38|         defined('MAUTIC_VERSION') or define('MAUTIC_VERSION', $metadata->getVersion());
    39|         /**
    40|          * This is required for Doctrine's automatic database detection. When Mautic hasn't been
    41|          * installed yet, we don't have a database to connect to, causing automatic database platform
    42|          * detection to fail. We use the MAUTIC_DB_SERVER_VERSION constant to temporarily set a server_version
    43|          * if no database settings have been provided yet.
    44|          */
    45|         if (!defined('MAUTIC_DB_SERVER_VERSION')) {
    46|             $localConfigFile = ParameterLoader::getLocalConfigFile($this->getApplicationDir().'/app', false);
    47|             define('MAUTIC_DB_SERVER_VERSION', file_exists($localConfigFile) ? null : '5.7');
    48|         }
    49|         parent::__construct($environment, $debug);
    50|     }
    51|     public function handle(Request $request, $type = HttpKernelInterface::MAIN_REQUEST, $catch = true): Response
    52|     {
    53|         if (false !== strpos($request->getRequestUri(), 'installer') || !$this->isInstalled()) {
    54|             defined('MAUTIC_INSTALLER') or define('MAUTIC_INSTALLER', 1);
    55|         }
    56|         if (defined('MAUTIC_INSTALLER')) {
    57|             $uri = $request->getRequestUri();
    58|             if (false === strpos($uri, 'installer')) {
    59|                 $base   = $request->getBaseUrl();
    60|                 $prefix = '';
    61|                 if (false === stripos($request->server->get('SERVER_SOFTWARE', ''), 'apache')
    62|                     || !file_exists($this->getProjectDir().'/.htaccess')
    63|                     && false === strpos(
    64|                         $base,
    65|                         'index'
    66|                     )
    67|                 ) {
    68|                     $prefix .= '/index.php';
    69|                 }
    70|                 return new RedirectResponse($request->getUriForPath($prefix.'/installer'));
    71|             }
    72|         }
    73|         if (false === $this->booted) {
    74|             $this->boot();
    75|         }
    76|         if (!defined('MAUTIC_INSTALLER')) {
    77|             $db = $this->getContainer()->get('database_connection');
    78|             try {
    79|                 $db->connect();
    80|             } catch (Exception $e) {
    81|                 error_log($e);
    82|                 throw new Mautic\CoreBundle\Exception\DatabaseConnectionException($this->getContainer()->get('translator')->trans('mautic.core.db.connection.error', ['%code%' => $e->getCode()]), 0, $e);
    83|             }
    84|         }
    85|         return parent::handle($request, $type, $catch);
    86|     }
    87|     public function registerBundles(): iterable
    88|     {
    89|         $bundles = [
    90|             new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
    91|             new Symfony\Bundle\SecurityBundle\SecurityBundle(),
    92|             new Symfony\Bundle\MonologBundle\MonologBundle(),
    93|             new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
    94|             new Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle(),
    95|             new Doctrine\Bundle\MigrationsBundle\DoctrineMigrationsBundle(),
    96|             new Knp\Bundle\MenuBundle\KnpMenuBundle(),
    97|             new FOS\OAuthServerBundle\FOSOAuthServerBundle(),
    98|             new FOS\RestBundle\FOSRestBundle(),
    99|             new JMS\SerializerBundle\JMSSerializerBundle(),
   100|             new Oneup\UploaderBundle\OneupUploaderBundle(),
   101|             new Symfony\Bundle\TwigBundle\TwigBundle(),
   102|             new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
   103|             new LightSaml\SymfonyBridgeBundle\LightSamlSymfonyBridgeBundle(),
   104|             new LightSaml\SpBundle\LightSamlSpBundle(),
   105|             new Noxlogic\RateLimitBundle\NoxlogicRateLimitBundle(),
   106|             new FM\ElfinderBundle\FMElfinderBundle(),
   107|             new Exercise\HTMLPurifierBundle\ExerciseHTMLPurifierBundle(),
   108|             new Mautic\ApiBundle\MauticApiBundle(),
   109|             new Mautic\AssetBundle\MauticAssetBundle(),
   110|             new Mautic\CampaignBundle\MauticCampaignBundle(),
   111|             new Mautic\CategoryBundle\MauticCategoryBundle(),
   112|             new Mautic\ChannelBundle\MauticChannelBundle(),
   113|             new Mautic\ConfigBundle\MauticConfigBundle(),
   114|             new Mautic\CoreBundle\MauticCoreBundle(),
   115|             new Mautic\DashboardBundle\MauticDashboardBundle(),
   116|             new Mautic\DynamicContentBundle\MauticDynamicContentBundle(),
   117|             new Mautic\EmailBundle\MauticEmailBundle(),
   118|             new Mautic\FormBundle\MauticFormBundle(),
   119|             new Mautic\InstallBundle\MauticInstallBundle(),
   120|             new Mautic\IntegrationsBundle\IntegrationsBundle(),
   121|             new Mautic\LeadBundle\MauticLeadBundle(),
   122|             new Mautic\MarketplaceBundle\MarketplaceBundle(),
   123|             new Mautic\MessengerBundle\MauticMessengerBundle(),
   124|             new Mautic\NotificationBundle\MauticNotificationBundle(),
   125|             new Mautic\PageBundle\MauticPageBundle(),
   126|             new Mautic\PluginBundle\MauticPluginBundle(),
   127|             new Mautic\PointBundle\MauticPointBundle(),
   128|             new Mautic\ReportBundle\MauticReportBundle(),
   129|             new Mautic\SmsBundle\MauticSmsBundle(),
   130|             new Mautic\StageBundle\MauticStageBundle(),
   131|             new Mautic\StatsBundle\MauticStatsBundle(),
   132|             new Mautic\UserBundle\MauticUserBundle(),
   133|             new Mautic\WebhookBundle\MauticWebhookBundle(),
   134|             new Mautic\CacheBundle\MauticCacheBundle(),
   135|         ];
   136|         $searchPath = $this->getApplicationDir().'/plugins';
   137|         $finder     = new Symfony\Component\Finder\Finder();
   138|         $finder->files()
   139|             ->followLinks()
   140|             ->depth('1')
   141|             ->in($searchPath)
   142|             ->name('*Bundle.php');
   143|         foreach ($finder as $file) {
   144|             $dirname  = basename($file->getRelativePath());
   145|             $filename = substr($file->getFilename(), 0, -4);
   146|             $class = '\\MauticPlugin\\'.$dirname.'\\'.$filename;
   147|             if (class_exists($class)) {
   148|                 $plugin = new $class();
   149|                 if ($plugin instanceof Symfony\Component\HttpKernel\Bundle\Bundle) {
   150|                     if (defined($class.'::MINIMUM_MAUTIC_VERSION')) {
   151|                         if (version_compare($this->getVersion(), constant($class.'::MINIMUM_MAUTIC_VERSION'), 'lt')) {
   152|                             continue;
   153|                         }
   154|                     }
   155|                     $bundles[] = $plugin;
   156|                 }
   157|                 unset($plugin);
   158|             }
   159|         }
   160|         if (in_array($this->getEnvironment(), ['dev', 'test'])) {
   161|             $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
   162|             $bundles[] = new Symfony\Bundle\MakerBundle\MakerBundle();
   163|         }
   164|         if (in_array($this->getEnvironment(), ['test'])) {
   165|             $bundles[] = new Liip\FunctionalTestBundle\LiipFunctionalTestBundle();
   166|             $bundles[] = new Liip\TestFixturesBundle\LiipTestFixturesBundle();
   167|         }
   168|         if (file_exists($this->getProjectDir().'/config/bundles_local.php')) {
   169|             include $this->getProjectDir().'/config/bundles_local.php';
   170|         }
   171|         return $bundles;
   172|     }
   173|     protected function build(ContainerBuilder $container): void
   174|     {
   175|         $container->registerForAutoconfiguration(Mautic\CoreBundle\Model\MauticModelInterface::class)
   176|             ->addTag(Mautic\CoreBundle\DependencyInjection\Compiler\ModelPass::TAG);
   177|     }
   178|     public function boot(): void
   179|     {
   180|         if (true === $this->booted) {
   181|             return;
   182|         }
   183|         $parameterLoader = $this->getParameterLoader();
   184|         $parameterLoader->loadIntoEnvironment();
   185|         if (!defined('MAUTIC_TABLE_PREFIX')) {
   186|             $prefix = $_SERVER['MAUTIC_TABLE_PREFIX'];
   187|             if (empty($prefix)) {
   188|                 $prefix = $parameterLoader->getLocalParameterBag()->get('db_table_prefix', '');
   189|             }
   190|             define('MAUTIC_TABLE_PREFIX', $prefix);
   191|         }
   192|         $this->initializeBundles();
   193|         $this->initializeContainer();
   194|         foreach ($this->getBundles() as $name => $bundle) {
   195|             $bundle->setContainer($this->container);
   196|             $bundle->boot();
   197|         }
   198|         $this->booted = true;
   199|     }
   200|     protected function prepareContainer(ContainerBuilder $container): void
   201|     {
   202|         $container->setParameter('mautic.application_dir', $this->getApplicationDir());
   203|         parent::prepareContainer($container);
   204|     }
   205|     public function registerContainerConfiguration(LoaderInterface $loader): void
   206|     {
   207|         $loader->load($this->getApplicationDir().'/app/config/config_'.$this->getEnvironment().'.php');
   208|     }
   209|     /**
   210|      * Retrieves the application's version number.
   211|      */
   212|     public function getVersion(): string
   213|     {
   214|         return MAUTIC_VERSION;
   215|     }
   216|     /**
   217|      * Checks if the application has been installed.
   218|      */
   219|     protected function isInstalled(): bool
   220|     {
   221|         if (null === $this->installed) {
   222|             $localParameters = $this->getParameterLoader()->getLocalParameterBag();
   223|             $dbDriver        = $localParameters->get('db_driver');
   224|             $siteUrl         = $localParameters->get('site_url');
   225|             $this->installed = !empty($dbDriver) && !empty($siteUrl);
   226|         }
   227|         return $this->installed;
   228|     }
   229|     public function getApplicationDir(): string
   230|     {
   231|         return dirname(__DIR__);
   232|     }
   233|     public function getProjectDir(): string
   234|     {
   235|         if (null === $this->projectDir) {
   236|             $r = new ReflectionObject($this);
   237|             if (!is_file($dir = $r->getFileName())) {
   238|                 throw new LogicException(sprintf('Cannot auto-detect project dir for kernel of class "%s".', $r->name));
   239|             }
   240|             $dir = $rootDir = \dirname($dir, 2);
   241|             while (!is_file($dir.'/composer.json')) {
   242|                 if ($dir === \dirname($dir)) {
   243|                     return $this->projectDir = $rootDir;
   244|                 }
   245|                 $dir = \dirname($dir);
   246|             }
   247|             $this->projectDir = $dir;
   248|         }
   249|         return $this->projectDir;
   250|     }
   251|     /**
   252|      * @api
   253|      */
   254|     public function getCacheDir(): string
   255|     {
   256|         if ($cachePath = $this->getParameterLoader()->getLocalParameterBag()->get('cache_path')) {
   257|             $envFolder = ('/' != substr($cachePath, -1)) ? '/'.$this->environment : $this->environment;
   258|             return str_replace('%kernel.project_dir%', $this->getProjectDir(), $cachePath.$envFolder);
   259|         }
   260|         return $this->getProjectDir().'/var/cache/'.$this->getEnvironment();
   261|     }
   262|     public function getLogDir(): string
   263|     {
   264|         if ($logPath = $this->getParameterLoader()->getLocalParameterBag()->get('log_path')) {
   265|             return str_replace('%kernel.project_dir%', $this->getProjectDir(), $logPath);
   266|         }
   267|         return $this->getProjectDir().'/var/logs';
   268|     }
   269|     /**
   270|      * Get local config file.
   271|      */
   272|     public function getLocalConfigFile(): string
   273|     {
   274|         return ParameterLoader::getLocalConfigFile($this->getApplicationDir().'/app');
   275|     }
   276|     private function getParameterLoader(): ParameterLoader
   277|     {
   278|         if ($this->parameterLoader) {
   279|             return $this->parameterLoader;
   280|         }
   281|         return $this->parameterLoader = new ParameterLoader();
   282|     }
   283| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Config/config.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-102 ---
     1| <?php
     2| return [
     3|     'routes' => [
     4|         'public' => [
     5|             'fos_oauth_server_token' => [
     6|                 'path'       => '/oauth/v2/token',
     7|                 'controller' => 'fos_oauth_server.controller.token::tokenAction',
     8|                 'method'     => 'GET|POST',
     9|             ],
    10|             'fos_oauth_server_authorize' => [
    11|                 'path'       => '/oauth/v2/authorize',
    12|                 'controller' => 'Mautic\ApiBundle\Controller\oAuth2\AuthorizeController::authorizeAction',
    13|                 'method'     => 'GET|POST',
    14|             ],
    15|             'mautic_oauth2_server_auth_login' => [
    16|                 'path'       => '/oauth/v2/authorize_login',
    17|                 'controller' => 'Mautic\ApiBundle\Controller\oAuth2\SecurityController::loginAction',
    18|                 'method'     => 'GET|POST',
    19|             ],
    20|             'mautic_oauth2_server_auth_login_check' => [
    21|                 'path'       => '/oauth/v2/authorize_login_check',
    22|                 'controller' => 'Mautic\ApiBundle\Controller\oAuth2\SecurityController::loginCheckAction',
    23|                 'method'     => 'GET|POST',
    24|             ],
    25|         ],
    26|         'main' => [
    27|             'mautic_client_index' => [
    28|                 'path'       => '/credentials/{page}',
    29|                 'controller' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
    30|             ],
    31|             'mautic_client_action' => [
    32|                 'path'       => '/credentials/{objectAction}/{objectId}',
    33|                 'controller' => 'Mautic\ApiBundle\Controller\ClientController::executeAction',
    34|             ],
    35|         ],
    36|     ],
    37|     'menu' => [
    38|         'admin' => [
    39|             'items' => [
    40|                 'mautic.api.client.menu.index' => [
    41|                     'route'     => 'mautic_client_index',
    42|                     'access'    => 'api:clients:view',
    43|                     'parent'    => 'mautic.core.integrations',
    44|                     'iconClass' => 'ri-terminal-box-line',
    45|                     'priority'  => 17,
    46|                     'checks'    => [
    47|                         'parameters' => [
    48|                             'api_enabled' => true,
    49|                         ],
    50|                     ],
    51|                 ],
    52|             ],
    53|         ],
    54|     ],
    55|     'services' => [
    56|         'helpers' => [
    57|             'mautic.api.helper.entity_result' => [
    58|                 'class' => Mautic\ApiBundle\Helper\EntityResultHelper::class,
    59|             ],
    60|         ],
    61|         'other' => [
    62|             'mautic.api.oauth.event_listener' => [
    63|                 'class'     => Mautic\ApiBundle\EventListener\PreAuthorizationEventListener::class,
    64|                 'arguments' => [
    65|                     'doctrine.orm.entity_manager',
    66|                     'mautic.security',
    67|                     'translator',
    68|                 ],
    69|                 'tags' => [
    70|                     'kernel.event_listener',
    71|                     'kernel.event_listener',
    72|                 ],
    73|                 'tagArguments' => [
    74|                     [
    75|                         'event'  => 'fos_oauth_server.pre_authorization_process',
    76|                         'method' => 'onPreAuthorizationProcess',
    77|                     ],
    78|                     [
    79|                         'event'  => 'fos_oauth_server.post_authorization_process',
    80|                         'method' => 'onPostAuthorizationProcess',
    81|                     ],
    82|                 ],
    83|             ],
    84|             'fos_oauth_server.security.authentication.listener.class' => Mautic\ApiBundle\Security\OAuth2\Firewall\OAuthListener::class,
    85|             'mautic.validator.oauthcallback'                          => [
    86|                 'class' => Mautic\ApiBundle\Form\Validator\Constraints\OAuthCallbackValidator::class,
    87|                 'tag'   => 'validator.constraint_validator',
    88|             ],
    89|         ],
    90|     ],
    91|     'parameters' => [
    92|         'api_enabled'                       => false,
    93|         'api_enable_basic_auth'             => false,
    94|         'api_oauth2_access_token_lifetime'  => 60,
    95|         'api_oauth2_refresh_token_lifetime' => 14,
    96|         'api_batch_max_limit'               => 200,
    97|         'api_rate_limiter_limit'            => 0,
    98|         'api_rate_limiter_cache'            => [
    99|             'adapter' => 'cache.adapter.filesystem',
   100|         ],
   101|     ],
   102| ];


# ====================================================================
# FILE: app/bundles/ApiBundle/Controller/ClientController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-394 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Model\ClientModel;
     5| use Mautic\CoreBundle\Controller\AbstractStandardFormController;
     6| use Mautic\CoreBundle\Factory\ModelFactory;
     7| use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\UserHelper;
    10| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    11| use Mautic\CoreBundle\Service\FlashBag;
    12| use Mautic\CoreBundle\Translation\Translator;
    13| use Mautic\FormBundle\Helper\FormFieldHelper;
    14| use Mautic\UserBundle\Entity\User;
    15| use OAuth2\OAuth2;
    16| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    17| use Symfony\Component\Form\FormFactoryInterface;
    18| use Symfony\Component\HttpFoundation\JsonResponse;
    19| use Symfony\Component\HttpFoundation\RedirectResponse;
    20| use Symfony\Component\HttpFoundation\Request;
    21| use Symfony\Component\HttpFoundation\RequestStack;
    22| use Symfony\Component\HttpFoundation\Response;
    23| use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
    24| class ClientController extends AbstractStandardFormController
    25| {
    26|     public function __construct(
    27|         private ClientModel $clientModel,
    28|         FormFactoryInterface $formFactory,
    29|         FormFieldHelper $fieldHelper,
    30|         ManagerRegistry $doctrine,
    31|         ModelFactory $modelFactory,
    32|         UserHelper $userHelper,
    33|         CoreParametersHelper $coreParametersHelper,
    34|         EventDispatcherInterface $dispatcher,
    35|         Translator $translator,
    36|         FlashBag $flashBag,
    37|         RequestStack $requestStack,
    38|         CorePermissions $security,
    39|     ) {
    40|         parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    41|     }
    42|     /**
    43|      * Generate's default client list.
    44|      *
    45|      * @param int $page
    46|      *
    47|      * @return Response
    48|      */
    49|     public function indexAction(Request $request, PageHelperFactoryInterface $pageHelperFactory, $page = 1)
    50|     {
    51|         if (!$this->security->isGranted('api:clients:view')) {
    52|             return $this->accessDenied();
    53|         }
    54|         $this->setListFilters();
    55|         $pageHelper= $pageHelperFactory->make('mautic.api.client', $page);
    56|         $limit     = $pageHelper->getLimit();
    57|         $start     = $pageHelper->getStart();
    58|         $orderBy   = $request->getSession()->get('mautic.api.client.orderby', 'c.name');
    59|         $orderByDir= $request->getSession()->get('mautic.api.client.orderbydir', 'ASC');
    60|         $filter    = $request->get('search', $request->getSession()->get('mautic.api.client.filter', ''));
    61|         $apiMode   = $request->get('api_mode', $request->getSession()->get('mautic.api.client.filter.api_mode', 'oauth2'));
    62|         $request->getSession()->set('mautic.api.client.filter.api_mode', $apiMode);
    63|         $request->getSession()->set('mautic.api.client.filter', $filter);
    64|         $clients = $this->clientModel->getEntities(
    65|             [
    66|                 'start'      => $start,
    67|                 'limit'      => $limit,
    68|                 'filter'     => $filter,
    69|                 'orderBy'    => $orderBy,
    70|                 'orderByDir' => $orderByDir,
    71|             ]
    72|         );
    73|         $count = count($clients);
    74|         if ($count && $count < ($start + 1)) {
    75|             $lastPage  = $pageHelper->countPage($count);
    76|             $returnUrl = $this->generateUrl('mautic_client_index', ['page' => $lastPage]);
    77|             $pageHelper->rememberPage($lastPage);
    78|             return $this->postActionRedirect(
    79|                 [
    80|                     'returnUrl'       => $returnUrl,
    81|                     'viewParameters'  => ['page' => $lastPage],
    82|                     'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
    83|                     'passthroughVars' => [
    84|                         'activeLink'    => 'mautic_client_index',
    85|                         'mauticContent' => 'client',
    86|                     ],
    87|                 ]
    88|             );
    89|         }
    90|         $pageHelper->rememberPage($page);
    91|         $filters = [];
    92|         $apiOptions           = [];
    93|         $apiOptions['oauth2'] = 'OAuth 2';
    94|         $filters['api_mode']  = [
    95|             'values'  => [$apiMode],
    96|             'options' => $apiOptions,
    97|         ];
    98|         return $this->delegateView(
    99|             [
   100|                 'viewParameters'  => [
   101|                     'items'       => $clients,
   102|                     'page'        => $page,
   103|                     'limit'       => $limit,
   104|                     'permissions' => [
   105|                         'create' => $this->security->isGranted('api:clients:create'),
   106|                         'edit'   => $this->security->isGranted('api:clients:editother'),
   107|                         'delete' => $this->security->isGranted('api:clients:deleteother'),
   108|                     ],
   109|                     'tmpl'        => $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index',
   110|                     'searchValue' => $filter,
   111|                     'filters'     => $filters,
   112|                 ],
   113|                 'contentTemplate' => '@MauticApi/Client/list.html.twig',
   114|                 'passthroughVars' => [
   115|                     'route'         => $this->generateUrl('mautic_client_index', ['page' => $page]),
   116|                     'mauticContent' => 'client',
   117|                 ],
   118|             ]
   119|         );
   120|     }
   121|     public function authorizedClientsAction(TokenStorageInterface $tokenStorage): Response
   122|     {
   123|         $me = $tokenStorage->getToken()->getUser();
   124|         \assert($me instanceof User);
   125|         $clients = $this->clientModel->getUserClients($me);
   126|         return $this->render('@MauticApi/Client/authorized.html.twig', ['clients' => $clients]);
   127|     }
   128|     /**
   129|      * @param int $clientId
   130|      */
   131|     public function revokeAction(Request $request, $clientId): Response
   132|     {
   133|         $success = 0;
   134|         $flashes = [];
   135|         if ('POST' == $request->getMethod()) {
   136|             $client = $this->clientModel->getEntity($clientId);
   137|             if (null === $client) {
   138|                 $flashes[] = [
   139|                     'type'    => 'error',
   140|                     'msg'     => 'mautic.api.client.error.notfound',
   141|                     'msgVars' => ['%id%' => $clientId],
   142|                 ];
   143|             } else {
   144|                 $name = $client->getName();
   145|                 $this->clientModel->revokeAccess($client);
   146|                 $flashes[] = [
   147|                     'type'    => 'notice',
   148|                     'msg'     => 'mautic.api.client.notice.revoked',
   149|                     'msgVars' => [
   150|                         '%name%' => $name,
   151|                     ],
   152|                 ];
   153|             }
   154|         }
   155|         return $this->postActionRedirect(
   156|             [
   157|                 'returnUrl'       => $this->generateUrl('mautic_user_account'),
   158|                 'contentTemplate' => 'Mautic\UserBundle\Controller\ProfileController::indexAction',
   159|                 'passthroughVars' => [
   160|                     'success' => $success,
   161|                 ],
   162|                 'flashes' => $flashes,
   163|             ]
   164|         );
   165|     }
   166|     /**
   167|      * @param mixed $objectId
   168|      *
   169|      * @return array|JsonResponse|RedirectResponse|Response
   170|      */
   171|     public function newAction(Request $request, $objectId = 0)
   172|     {
   173|         if (!$this->security->isGranted('api:clients:create')) {
   174|             return $this->accessDenied();
   175|         }
   176|         $apiMode = (0 === $objectId) ? $request->getSession()->get('mautic.client.filter.api_mode', 'oauth2') : $objectId;
   177|         $request->getSession()->set('mautic.client.filter.api_mode', $apiMode);
   178|         $this->clientModel->setApiMode($apiMode);
   179|         $client = $this->clientModel->getEntity();
   180|         $returnUrl = $this->generateUrl('mautic_client_index');
   181|         $action = $this->generateUrl('mautic_client_action', ['objectAction' => 'new']);
   182|         $form   = $this->clientModel->createForm($client, $this->formFactory, $action);
   183|         $form->remove('randomId');
   184|         $form->remove('secret');
   185|         $form->remove('publicId');
   186|         $form->remove('consumerKey');
   187|         $form->remove('consumerSecret');
   188|         if ('POST' == $request->getMethod()) {
   189|             $valid = false;
   190|             if (!$cancelled = $this->isFormCancelled($form)) {
   191|                 if ($valid = $this->isFormValid($form)) {
   192|                     /** @var User $user */
   193|                     $user = $this->getUser();
   194|                     if (ClientModel::API_MODE_OAUTH2 == $apiMode && $user->getRole()->isAdmin()) {
   195|                         $client->addGrantType(OAuth2::GRANT_TYPE_CLIENT_CREDENTIALS);
   196|                     }
   197|                     $client->setRole($user->getRole());
   198|                     $this->clientModel->saveEntity($client);
   199|                     $this->addFlashMessage(
   200|                         'mautic.api.client.notice.created',
   201|                         [
   202|                             '%name%'         => $client->getName(),
   203|                             '%clientId%'     => $client->getPublicId(),
   204|                             '%clientSecret%' => $client->getSecret(),
   205|                             '%url%'          => $this->generateUrl(
   206|                                 'mautic_client_action',
   207|                                 [
   208|                                     'objectAction' => 'edit',
   209|                                     'objectId'     => $client->getId(),
   210|                                 ]
   211|                             ),
   212|                         ]
   213|                     );
   214|                 }
   215|             }
   216|             if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
   217|                 return $this->postActionRedirect(
   218|                     [
   219|                         'returnUrl'       => $returnUrl,
   220|                         'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
   221|                         'passthroughVars' => [
   222|                             'activeLink'    => '#mautic_client_index',
   223|                             'mauticContent' => 'client',
   224|                         ],
   225|                     ]
   226|                 );
   227|             } elseif ($valid && !$cancelled) {
   228|                 return $this->editAction($request, $client->getId(), true);
   229|             }
   230|         }
   231|         return $this->delegateView(
   232|             [
   233|                 'viewParameters' => [
   234|                     'form' => $form->createView(),
   235|                     'tmpl' => $request->get('tmpl', 'form'),
   236|                 ],
   237|                 'contentTemplate' => '@MauticApi/Client/form.html.twig',
   238|                 'passthroughVars' => [
   239|                     'activeLink'    => '#mautic_client_new',
   240|                     'route'         => $action,
   241|                     'mauticContent' => 'client',
   242|                 ],
   243|             ]
   244|         );
   245|     }
   246|     /**
   247|      * Generates edit form and processes post data.
   248|      *
   249|      * @param int  $objectId
   250|      * @param bool $ignorePost
   251|      *
   252|      * @return JsonResponse|RedirectResponse|Response
   253|      */
   254|     public function editAction(Request $request, $objectId, $ignorePost = false)
   255|     {
   256|         if (!$this->security->isGranted('api:clients:editother')) {
   257|             return $this->accessDenied();
   258|         }
   259|         $client    = $this->clientModel->getEntity($objectId);
   260|         $returnUrl = $this->generateUrl('mautic_client_index');
   261|         $postActionVars = [
   262|             'returnUrl'       => $returnUrl,
   263|             'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
   264|             'passthroughVars' => [
   265|                 'activeLink'    => '#mautic_client_index',
   266|                 'mauticContent' => 'client',
   267|             ],
   268|         ];
   269|         if (null === $client) {
   270|             return $this->postActionRedirect(
   271|                 array_merge(
   272|                     $postActionVars,
   273|                     [
   274|                         'flashes' => [
   275|                             [
   276|                                 'type'    => 'error',
   277|                                 'msg'     => 'mautic.api.client.error.notfound',
   278|                                 'msgVars' => ['%id%' => $objectId],
   279|                             ],
   280|                         ],
   281|                     ]
   282|                 )
   283|             );
   284|         } elseif ($this->clientModel->isLocked($client)) {
   285|             return $this->isLocked($postActionVars, $client, 'api.client');
   286|         }
   287|         $action = $this->generateUrl('mautic_client_action', ['objectAction' => 'edit', 'objectId' => $objectId]);
   288|         $form   = $this->clientModel->createForm($client, $this->formFactory, $action);
   289|         $form->remove('api_mode');
   290|         if (!$ignorePost && 'POST' == $request->getMethod()) {
   291|             if (!$cancelled = $this->isFormCancelled($form)) {
   292|                 if ($valid = $this->isFormValid($form)) {
   293|                     $this->clientModel->saveEntity($client, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
   294|                     $this->addFlashMessage(
   295|                         'mautic.core.notice.updated',
   296|                         [
   297|                             '%name%'      => $client->getName(),
   298|                             '%menu_link%' => 'mautic_client_index',
   299|                             '%url%'       => $this->generateUrl(
   300|                                 'mautic_client_action',
   301|                                 [
   302|                                     'objectAction' => 'edit',
   303|                                     'objectId'     => $client->getId(),
   304|                                 ]
   305|                             ),
   306|                         ]
   307|                     );
   308|                     if ($this->getFormButton($form, ['buttons', 'save'])->isClicked()) {
   309|                         return $this->postActionRedirect($postActionVars);
   310|                     }
   311|                 }
   312|             } else {
   313|                 $this->clientModel->unlockEntity($client);
   314|                 return $this->postActionRedirect($postActionVars);
   315|             }
   316|         } else {
   317|             $this->clientModel->lockEntity($client);
   318|         }
   319|         return $this->delegateView(
   320|             [
   321|                 'viewParameters' => [
   322|                     'form' => $form->createView(),
   323|                     'tmpl' => $request->get('tmpl', 'form'),
   324|                 ],
   325|                 'contentTemplate' => '@MauticApi/Client/form.html.twig',
   326|                 'passthroughVars' => [
   327|                     'activeLink'    => '#mautic_client_index',
   328|                     'route'         => $action,
   329|                     'mauticContent' => 'client',
   330|                 ],
   331|             ]
   332|         );
   333|     }
   334|     /**
   335|      * Deletes the entity.
   336|      *
   337|      * @param int $objectId
   338|      *
   339|      * @return Response
   340|      */
   341|     public function deleteAction(Request $request, $objectId)
   342|     {
   343|         if (!$this->security->isGranted('api:clients:delete')) {
   344|             return $this->accessDenied();
   345|         }
   346|         $returnUrl = $this->generateUrl('mautic_client_index');
   347|         $success   = 0;
   348|         $flashes   = [];
   349|         $postActionVars = [
   350|             'returnUrl'       => $returnUrl,
   351|             'contentTemplate' => 'Mautic\ApiBundle\Controller\ClientController::indexAction',
   352|             'passthroughVars' => [
   353|                 'activeLink'    => '#mautic_client_index',
   354|                 'success'       => $success,
   355|                 'mauticContent' => 'client',
   356|             ],
   357|         ];
   358|         if ('POST' === $request->getMethod()) {
   359|             $entity = $this->clientModel->getEntity($objectId);
   360|             if (null === $entity) {
   361|                 $flashes[] = [
   362|                     'type'    => 'error',
   363|                     'msg'     => 'mautic.api.client.error.notfound',
   364|                     'msgVars' => ['%id%' => $objectId],
   365|                 ];
   366|             } elseif ($this->clientModel->isLocked($entity)) {
   367|                 return $this->isLocked($postActionVars, $entity, 'api.client');
   368|             } else {
   369|                 $this->clientModel->deleteEntity($entity);
   370|                 $name      = $entity->getName();
   371|                 $flashes[] = [
   372|                     'type'    => 'notice',
   373|                     'msg'     => 'mautic.core.notice.deleted',
   374|                     'msgVars' => [
   375|                         '%name%' => $name,
   376|                         '%id%'   => $objectId,
   377|                     ],
   378|                 ];
   379|             }
   380|         }
   381|         return $this->postActionRedirect(
   382|             array_merge(
   383|                 $postActionVars,
   384|                 [
   385|                     'flashes' => $flashes,
   386|                 ]
   387|             )
   388|         );
   389|     }
   390|     public function getModelName(): string
   391|     {
   392|         return 'api.client';
   393|     }
   394| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Controller/CommonApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-472 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use FOS\RestBundle\View\View;
     5| use Mautic\ApiBundle\ApiEvents;
     6| use Mautic\ApiBundle\Event\ApiEntityEvent;
     7| use Mautic\ApiBundle\Helper\EntityResultHelper;
     8| use Mautic\CategoryBundle\Entity\Category;
     9| use Mautic\CoreBundle\Factory\ModelFactory;
    10| use Mautic\CoreBundle\Helper\AppVersion;
    11| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    12| use Mautic\CoreBundle\Helper\InputHelper;
    13| use Mautic\CoreBundle\Model\FormModel;
    14| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    15| use Mautic\CoreBundle\Translation\Translator;
    16| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    17| use Symfony\Component\Form\Form;
    18| use Symfony\Component\Form\FormFactoryInterface;
    19| use Symfony\Component\Form\FormInterface;
    20| use Symfony\Component\HttpFoundation\RedirectResponse;
    21| use Symfony\Component\HttpFoundation\Request;
    22| use Symfony\Component\HttpFoundation\RequestStack;
    23| use Symfony\Component\HttpFoundation\Response;
    24| use Symfony\Component\Routing\RouterInterface;
    25| /**
    26|  * @template E of object
    27|  *
    28|  * @extends FetchCommonApiController<E>
    29|  */
    30| class CommonApiController extends FetchCommonApiController
    31| {
    32|     /**
    33|      * @var array
    34|      */
    35|     protected $dataInputMasks = [];
    36|     /**
    37|      * Model object for processing the entity.
    38|      *
    39|      * @var FormModel<E>|null
    40|      */
    41|     protected $model;
    42|     /**
    43|      * @var array
    44|      */
    45|     protected $routeParams = [];
    46|     /**
    47|      * @var array
    48|      */
    49|     protected $entityRequestParameters = [];
    50|     public function __construct(
    51|         CorePermissions $security,
    52|         Translator $translator,
    53|         EntityResultHelper $entityResultHelper,
    54|         protected RouterInterface $router,
    55|         protected FormFactoryInterface $formFactory,
    56|         AppVersion $appVersion,
    57|         RequestStack $requestStack,
    58|         ManagerRegistry $doctrine,
    59|         ModelFactory $modelFactory,
    60|         EventDispatcherInterface $dispatcher,
    61|         CoreParametersHelper $coreParametersHelper,
    62|     ) {
    63|         parent::__construct($security, $translator, $entityResultHelper, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    64|     }
    65|     /**
    66|      * Delete a batch of entities.
    67|      *
    68|      * @return array|Response
    69|      */
    70|     public function deleteEntitiesAction(Request $request)
    71|     {
    72|         $parameters = $request->query->all();
    73|         $valid = $this->validateBatchPayload($parameters);
    74|         if ($valid instanceof Response) {
    75|             return $valid;
    76|         }
    77|         $errors            = [];
    78|         $entities          = $this->getBatchEntities($parameters, $errors, true);
    79|         $this->inBatchMode = true;
    80|         $payload = [$this->entityNameMulti => $entities];
    81|         $view    = $this->view($payload, Response::HTTP_OK);
    82|         $this->setSerializationContext($view);
    83|         $response = $this->handleView($view);
    84|         foreach ($entities as $key => $entity) {
    85|             if (null === $entity || !$entity->getId()) {
    86|                 $this->setBatchError($key, 'mautic.core.error.notfound', Response::HTTP_NOT_FOUND, $errors, $entities, $entity);
    87|                 continue;
    88|             }
    89|             if (!$this->checkEntityAccess($entity, 'delete')) {
    90|                 $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
    91|                 continue;
    92|             }
    93|             $this->model->deleteEntity($entity);
    94|             $this->doctrine->getManager()->detach($entity);
    95|         }
    96|         if (!empty($errors)) {
    97|             $content           = json_decode($response->getContent(), true);
    98|             $content['errors'] = $errors;
    99|             $response->setContent(json_encode($content));
   100|         }
   101|         return $response;
   102|     }
   103|     /**
   104|      * Deletes an entity.
   105|      *
   106|      * @param int $id Entity ID
   107|      *
   108|      * @return Response
   109|      */
   110|     public function deleteEntityAction($id)
   111|     {
   112|         $entity = $this->model->getEntity($id);
   113|         if (null !== $entity) {
   114|             if (!$this->checkEntityAccess($entity, 'delete')) {
   115|                 return $this->accessDenied();
   116|             }
   117|             $this->model->deleteEntity($entity);
   118|             $this->preSerializeEntity($entity);
   119|             $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK);
   120|             $this->setSerializationContext($view);
   121|             return $this->handleView($view);
   122|         }
   123|         return $this->notFound();
   124|     }
   125|     /**
   126|      * Edit a batch of entities.
   127|      *
   128|      * @return array|Response
   129|      */
   130|     public function editEntitiesAction(Request $request)
   131|     {
   132|         $parameters = $request->request->all();
   133|         $valid = $this->validateBatchPayload($parameters);
   134|         if ($valid instanceof Response) {
   135|             return $valid;
   136|         }
   137|         $errors      = [];
   138|         $statusCodes = [];
   139|         $entities    = $this->getBatchEntities($parameters, $errors);
   140|         foreach ($parameters as $key => $params) {
   141|             $method = $request->getMethod();
   142|             $entity = $entities[$key] ?? null;
   143|             $statusCode = Response::HTTP_OK;
   144|             if (null === $entity || !$entity->getId()) {
   145|                 if ('PATCH' === $method) {
   146|                     $this->setBatchError($key, 'mautic.core.error.notfound', Response::HTTP_NOT_FOUND, $errors, $entities, $entity);
   147|                     $statusCodes[$key] = Response::HTTP_NOT_FOUND;
   148|                     continue;
   149|                 }
   150|                 $entity = $this->model->getEntity();
   151|                 if (!$this->checkEntityAccess($entity, 'create')) {
   152|                     $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
   153|                     $statusCodes[$key] = Response::HTTP_FORBIDDEN;
   154|                     continue;
   155|                 }
   156|                 $statusCode = Response::HTTP_CREATED;
   157|             }
   158|             if (!$this->checkEntityAccess($entity, 'edit')) {
   159|                 $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
   160|                 $statusCodes[$key] = Response::HTTP_FORBIDDEN;
   161|                 continue;
   162|             }
   163|             $this->processBatchForm($request, $key, $entity, $params, $method, $errors, $entities);
   164|             if (isset($errors[$key])) {
   165|                 $statusCodes[$key] = $errors[$key]['code'];
   166|             } else {
   167|                 $statusCodes[$key] = $statusCode;
   168|             }
   169|         }
   170|         $payload = [
   171|             $this->entityNameMulti => $entities,
   172|             'statusCodes'          => $statusCodes,
   173|         ];
   174|         if (!empty($errors)) {
   175|             $payload['errors'] = $errors;
   176|         }
   177|         $view = $this->view($payload, Response::HTTP_OK);
   178|         $this->setSerializationContext($view);
   179|         return $this->handleView($view);
   180|     }
   181|     /**
   182|      * Edits an existing entity or creates one on PUT if it doesn't exist.
   183|      *
   184|      * @param int $id Entity ID
   185|      *
   186|      * @return Response
   187|      */
   188|     public function editEntityAction(Request $request, $id)
   189|     {
   190|         $entity     = $this->model->getEntity($id);
   191|         $parameters = $request->request->all();
   192|         $method     = $request->getMethod();
   193|         if (null === $entity || !$entity->getId()) {
   194|             if ('PATCH' === $method) {
   195|                 return $this->notFound();
   196|             }
   197|             $entity = $this->model->getEntity();
   198|             if (!$this->checkEntityAccess($entity, 'create')) {
   199|                 return $this->accessDenied();
   200|             }
   201|         }
   202|         if (!$this->checkEntityAccess($entity, 'edit')) {
   203|             return $this->accessDenied();
   204|         }
   205|         return $this->processForm($request, $entity, $parameters, $method);
   206|     }
   207|     /**
   208|      * Create a batch of new entities.
   209|      *
   210|      * @return array|Response
   211|      */
   212|     public function newEntitiesAction(Request $request)
   213|     {
   214|         $entity = $this->model->getEntity();
   215|         if (!$this->checkEntityAccess($entity, 'create')) {
   216|             return $this->accessDenied();
   217|         }
   218|         $parameters = $request->request->all();
   219|         $valid = $this->validateBatchPayload($parameters);
   220|         if ($valid instanceof Response) {
   221|             return $valid;
   222|         }
   223|         $this->inBatchMode = true;
   224|         $entities          = [];
   225|         $errors            = [];
   226|         $statusCodes       = [];
   227|         foreach ($parameters as $key => $params) {
   228|             $entity       = $this->getNewEntity($params);
   229|             $entityExists = false;
   230|             $method       = 'POST';
   231|             if ($entity->getId()) {
   232|                 $entityExists = true;
   233|                 $method       = 'PATCH';
   234|                 if (!$this->checkEntityAccess($entity, 'edit')) {
   235|                     $this->setBatchError($key, 'mautic.core.error.accessdenied', Response::HTTP_FORBIDDEN, $errors, $entities, $entity);
   236|                     $statusCodes[$key] = Response::HTTP_FORBIDDEN;
   237|                     continue;
   238|                 }
   239|             }
   240|             $this->processBatchForm($request, $key, $entity, $params, $method, $errors, $entities);
   241|             if (isset($errors[$key])) {
   242|                 $statusCodes[$key] = $errors[$key]['code'];
   243|             } elseif ($entityExists) {
   244|                 $statusCodes[$key] = Response::HTTP_OK;
   245|             } else {
   246|                 $statusCodes[$key] = Response::HTTP_CREATED;
   247|             }
   248|         }
   249|         $payload = [
   250|             $this->entityNameMulti => $entities,
   251|             'statusCodes'          => $statusCodes,
   252|         ];
   253|         if (!empty($errors)) {
   254|             $payload['errors'] = $errors;
   255|         }
   256|         $view = $this->view($payload, Response::HTTP_CREATED);
   257|         $this->setSerializationContext($view);
   258|         return $this->handleView($view);
   259|     }
   260|     /**
   261|      * Creates a new entity.
   262|      *
   263|      * @return Response
   264|      */
   265|     public function newEntityAction(Request $request)
   266|     {
   267|         $parameters = $request->request->all();
   268|         $entity     = $this->getNewEntity($parameters);
   269|         if (!$this->checkEntityAccess($entity, 'create')) {
   270|             return $this->accessDenied();
   271|         }
   272|         return $this->processForm($request, $entity, $parameters, 'POST');
   273|     }
   274|     /**
   275|      * @return FormInterface<mixed>
   276|      */
   277|     protected function createEntityForm($entity): FormInterface
   278|     {
   279|         return $this->model->createForm(
   280|             $entity,
   281|             $this->formFactory,
   282|             null,
   283|             array_merge(
   284|                 [
   285|                     'csrf_protection'    => false,
   286|                     'allow_extra_fields' => true,
   287|                 ],
   288|                 $this->getEntityFormOptions()
   289|             )
   290|         );
   291|     }
   292|     /**
   293|      * Gives child controllers opportunity to analyze and do whatever to an entity before populating the form.
   294|      *
   295|      * @param string $action
   296|      *
   297|      * @return mixed
   298|      */
   299|     protected function prePopulateForm(&$entity, $parameters, $action = 'edit')
   300|     {
   301|     }
   302|     /**
   303|      * Give the controller an opportunity to process the entity before persisting.
   304|      *
   305|      * @return mixed
   306|      */
   307|     protected function preSaveEntity(&$entity, $form, $parameters, $action = 'edit')
   308|     {
   309|     }
   310|     /**
   311|      * Convert posted parameters into what the form needs in order to successfully bind.
   312|      *
   313|      * @param mixed[] $parameters
   314|      * @param object  $entity
   315|      * @param string  $action
   316|      *
   317|      * @return mixed
   318|      */
   319|     protected function prepareParametersForBinding(Request $request, $parameters, $entity, $action)
   320|     {
   321|         return $parameters;
   322|     }
   323|     protected function processBatchForm(Request $request, $key, $entity, $params, $method, &$errors, &$entities)
   324|     {
   325|         $this->inBatchMode = true;
   326|         $formResponse      = $this->processForm($request, $entity, $params, $method);
   327|         if ($formResponse instanceof Response) {
   328|             if (!$formResponse instanceof RedirectResponse) {
   329|                 $this->setBatchError(
   330|                     $key,
   331|                     InputHelper::string($formResponse->getContent()),
   332|                     $formResponse->getStatusCode(),
   333|                     $errors,
   334|                     $entities,
   335|                     $entity
   336|                 );
   337|             }
   338|         } elseif (is_object($formResponse) && $formResponse::class === $entity::class) {
   339|             $entities[$key] = $formResponse;
   340|         } elseif (is_array($formResponse) && isset($formResponse['code'], $formResponse['message'])) {
   341|             $errors[$key] = $formResponse;
   342|         }
   343|         $this->doctrine->getManager()->detach($entity);
   344|         $this->inBatchMode = false;
   345|     }
   346|     /**
   347|      * Processes API Form.
   348|      *
   349|      * @param array<mixed>|null $parameters
   350|      * @param string            $method
   351|      *
   352|      * @return mixed
   353|      */
   354|     protected function processForm(Request $request, $entity, $parameters = null, $method = 'PUT')
   355|     {
   356|         $categoryId = null;
   357|         if (null === $parameters) {
   358|             $parameters = $request->request->all();
   359|         }
   360|         $this->entityRequestParameters = $parameters;
   361|         if (isset($parameters['id'])) {
   362|             unset($parameters['id']);
   363|         }
   364|         if ($entity->getId()) {
   365|             $statusCode = Response::HTTP_OK;
   366|             $action     = 'edit';
   367|         } else {
   368|             $statusCode = Response::HTTP_CREATED;
   369|             $action     = 'new';
   370|             $defaultProperties = $this->getEntityDefaultProperties($entity);
   371|             $parameters        = array_merge($defaultProperties, $parameters);
   372|         }
   373|         if (
   374|             (
   375|                 array_key_exists('isPublished', $parameters)
   376|                 || array_key_exists('publishUp', $parameters)
   377|                 || array_key_exists('publishDown', $parameters)
   378|             )
   379|             && $this->security->checkPermissionExists($this->permissionBase.':publish')) {
   380|             if ($this->security->checkPermissionExists($this->permissionBase.':publishown')) {
   381|                 if (!$this->checkEntityAccess($entity, 'publish')) {
   382|                     if ('new' === $action) {
   383|                         $parameters['isPublished'] = 0;
   384|                     } else {
   385|                         unset($parameters['isPublished'], $parameters['publishUp'], $parameters['publishDown']);
   386|                     }
   387|                 }
   388|             }
   389|         }
   390|         $form         = $this->createEntityForm($entity);
   391|         $submitParams = $this->prepareParametersForBinding($request, $parameters, $entity, $action);
   392|         if ($submitParams instanceof Response) {
   393|             return $submitParams;
   394|         }
   395|         if (isset($submitParams['category'])) {
   396|             $categoryId = (int) $submitParams['category'];
   397|             unset($submitParams['category']);
   398|         }
   399|         $this->prepareParametersFromRequest($form, $submitParams, $entity, $this->dataInputMasks);
   400|         $form->submit($submitParams, 'PATCH' !== $method);
   401|         if ($form->isSubmitted() && $form->isValid()) {
   402|             $this->setCategory($entity, $categoryId);
   403|             $preSaveError = $this->preSaveEntity($entity, $form, $submitParams, $action);
   404|             if ($preSaveError instanceof Response) {
   405|                 return $preSaveError;
   406|             }
   407|             try {
   408|                 if ($this->dispatcher->hasListeners(ApiEvents::API_ON_ENTITY_PRE_SAVE)) {
   409|                     $this->dispatcher->dispatch(new ApiEntityEvent($entity, $this->entityRequestParameters, $request), ApiEvents::API_ON_ENTITY_PRE_SAVE);
   410|                 }
   411|             } catch (\Exception $e) {
   412|                 return $this->returnError($e->getMessage(), $e->getCode());
   413|             }
   414|             $statusCode = $this->saveEntity($entity, $statusCode);
   415|             $headers = [];
   416|             if (in_array($statusCode, [Response::HTTP_CREATED, Response::HTTP_ACCEPTED])) {
   417|                 $route = (null !== $this->router->getRouteCollection()->get('mautic_api_'.$this->entityNameMulti.'_getone'))
   418|                     ? 'mautic_api_'.$this->entityNameMulti.'_getone' : 'mautic_api_get'.$this->entityNameOne;
   419|                 $headers['Location'] = $this->generateUrl(
   420|                     $route,
   421|                     array_merge(['id' => $entity->getId()], $this->routeParams),
   422|                     true
   423|                 );
   424|             }
   425|             try {
   426|                 if ($this->dispatcher->hasListeners(ApiEvents::API_ON_ENTITY_POST_SAVE)) {
   427|                     $this->dispatcher->dispatch(new ApiEntityEvent($entity, $this->entityRequestParameters, $request), ApiEvents::API_ON_ENTITY_POST_SAVE);
   428|                 }
   429|             } catch (\Exception $e) {
   430|                 return $this->returnError($e->getMessage(), $e->getCode());
   431|             }
   432|             $this->preSerializeEntity($entity, $action);
   433|             if ($this->inBatchMode) {
   434|                 return $entity;
   435|             } else {
   436|                 $view = $this->view([$this->entityNameOne => $entity], $statusCode, $headers);
   437|             }
   438|             $this->setSerializationContext($view);
   439|         } else {
   440|             $formErrors     = $this->getFormErrorMessages($form);
   441|             $formErrorCodes = $this->getFormErrorCodes($form);
   442|             $msg            = $this->getFormErrorMessage($formErrors);
   443|             if (!$msg) {
   444|                 $msg = $this->translator->trans('mautic.core.error.badrequest', [], 'flashes');
   445|             }
   446|             $responseCode = in_array(Response::HTTP_UNPROCESSABLE_ENTITY, $formErrorCodes) ? Response::HTTP_UNPROCESSABLE_ENTITY : Response::HTTP_BAD_REQUEST;
   447|             return $this->returnError($msg, $responseCode, $formErrors);
   448|         }
   449|         return $this->handleView($view);
   450|     }
   451|     protected function saveEntity($entity, int $statusCode): int
   452|     {
   453|         $this->model->saveEntity($entity);
   454|         return $statusCode;
   455|     }
   456|     /**
   457|      * @param object $entity
   458|      * @param int    $categoryId
   459|      *
   460|      * @throws \UnexpectedValueException
   461|      */
   462|     protected function setCategory($entity, $categoryId)
   463|     {
   464|         if (!empty($categoryId) && method_exists($entity, 'setCategory')) {
   465|             $category = $this->doctrine->getManager()->find(Category::class, $categoryId);
   466|             if (null === $category) {
   467|                 throw new \UnexpectedValueException("Category $categoryId does not exist");
   468|             }
   469|             $entity->setCategory($category);
   470|         }
   471|     }
   472| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Controller/FetchCommonApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-644 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Controller;
     3| use Doctrine\ORM\Mapping\ClassMetadata;
     4| use Doctrine\ORM\Tools\Pagination\Paginator;
     5| use Doctrine\Persistence\ManagerRegistry;
     6| use FOS\RestBundle\Controller\AbstractFOSRestController;
     7| use FOS\RestBundle\View\View;
     8| use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
     9| use Mautic\ApiBundle\ApiEvents;
    10| use Mautic\ApiBundle\Event\ApiSerializationContextEvent;
    11| use Mautic\ApiBundle\Helper\BatchIdToEntityHelper;
    12| use Mautic\ApiBundle\Helper\EntityResultHelper;
    13| use Mautic\ApiBundle\Serializer\Exclusion\ParentChildrenExclusionStrategy;
    14| use Mautic\ApiBundle\Serializer\Exclusion\PublishDetailsExclusionStrategy;
    15| use Mautic\CoreBundle\Controller\FormErrorMessagesTrait;
    16| use Mautic\CoreBundle\Controller\MauticController;
    17| use Mautic\CoreBundle\Factory\ModelFactory;
    18| use Mautic\CoreBundle\Form\RequestTrait;
    19| use Mautic\CoreBundle\Helper\AppVersion;
    20| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    21| use Mautic\CoreBundle\Helper\InputHelper;
    22| use Mautic\CoreBundle\Helper\UserHelper;
    23| use Mautic\CoreBundle\Model\AbstractCommonModel;
    24| use Mautic\CoreBundle\Model\MauticModelInterface;
    25| use Mautic\CoreBundle\Security\Exception\PermissionException;
    26| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    27| use Mautic\CoreBundle\Translation\Translator;
    28| use Mautic\UserBundle\Entity\User;
    29| use Symfony\Component\DependencyInjection\ParameterBag\ContainerBagInterface;
    30| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    31| use Symfony\Component\Form\Form;
    32| use Symfony\Component\HttpFoundation\Request;
    33| use Symfony\Component\HttpFoundation\RequestStack;
    34| use Symfony\Component\HttpFoundation\Response;
    35| /**
    36|  * @template E of object
    37|  */
    38| class FetchCommonApiController extends AbstractFOSRestController implements MauticController
    39| {
    40|     use RequestTrait;
    41|     use FormErrorMessagesTrait;
    42|     /**
    43|      * If set to true, serializer will not return null values.
    44|      *
    45|      * @var bool
    46|      */
    47|     protected $customSelectRequested = false;
    48|     /**
    49|      * Class for the entity.
    50|      *
    51|      * @var class-string<E>
    52|      */
    53|     protected $entityClass;
    54|     /**
    55|      * Key to return for entity lists.
    56|      *
    57|      * @var string
    58|      */
    59|     protected $entityNameMulti;
    60|     /**
    61|      * Key to return for a single entity.
    62|      *
    63|      * @var string
    64|      */
    65|     protected $entityNameOne;
    66|     /**
    67|      * Custom JMS strategies to add to the view's context.
    68|      *
    69|      * @var array<int, ExclusionStrategyInterface>
    70|      */
    71|     protected $exclusionStrategies = [];
    72|     /**
    73|      * Pass to the model's getEntities() method.
    74|      *
    75|      * @var array<mixed>
    76|      */
    77|     protected $extraGetEntitiesArguments = [];
    78|     /**
    79|      * @var bool
    80|      */
    81|     protected $inBatchMode = false;
    82|     /**
    83|      * Used to set default filters for entity lists such as restricting to owning user.
    84|      *
    85|      * @var array<array<string, mixed>>
    86|      */
    87|     protected $listFilters = [];
    88|     /**
    89|      * Model object for processing the entity.
    90|      *
    91|      * @var AbstractCommonModel<E>|null
    92|      */
    93|     protected $model;
    94|     /**
    95|      * The level parent/children should stop loading if applicable.
    96|      *
    97|      * @var int
    98|      */
    99|     protected $parentChildrenLevelDepth = 3;
   100|     /**
   101|      * Permission base for the entity such as page:pages.
   102|      *
   103|      * @var string|null
   104|      */
   105|     protected $permissionBase;
   106|     /**
   107|      * @var array<int, string>
   108|      */
   109|     protected $serializerGroups = [];
   110|     /**
   111|      * @var Translator
   112|      */
   113|     protected $translator;
   114|     protected ContainerBagInterface $parametersContainer;
   115|     /**
   116|      * @param ModelFactory<E> $modelFactory
   117|      */
   118|     public function __construct(
   119|         protected CorePermissions $security,
   120|         Translator $translator,
   121|         protected EntityResultHelper $entityResultHelper,
   122|         private AppVersion $appVersion,
   123|         private RequestStack $requestStack,
   124|         protected ManagerRegistry $doctrine,
   125|         protected ModelFactory $modelFactory,
   126|         protected EventDispatcherInterface $dispatcher,
   127|         protected CoreParametersHelper $coreParametersHelper,
   128|     ) {
   129|         $this->translator           = $translator;
   130|         if (null !== $this->model && !$this->permissionBase && method_exists($this->model, 'getPermissionBase')) {
   131|             $this->permissionBase = $this->model->getPermissionBase();
   132|         }
   133|     }
   134|     /**
   135|      * Obtains a list of entities as defined by the API URL.
   136|      *
   137|      * @return Response
   138|      */
   139|     public function getEntitiesAction(Request $request, UserHelper $userHelper)
   140|     {
   141|         $repo          = $this->model->getRepository();
   142|         $tableAlias    = $repo->getTableAlias();
   143|         $publishedOnly = $request->get('published', 0);
   144|         $minimal       = $request->get('minimal', 0);
   145|         try {
   146|             if (!$this->security->isGranted($this->permissionBase.':view')) {
   147|                 return $this->accessDenied();
   148|             }
   149|         } catch (PermissionException $e) {
   150|             return $this->accessDenied($e->getMessage());
   151|         }
   152|         if ($this->security->checkPermissionExists($this->permissionBase.':viewother')
   153|             && !$this->security->isGranted($this->permissionBase.':viewother')
   154|             && null !== $user = $userHelper->getUser()
   155|         ) {
   156|             $this->listFilters[] = [
   157|                 'column' => $tableAlias.'.createdBy',
   158|                 'expr'   => 'eq',
   159|                 'value'  => $user->getId(),
   160|             ];
   161|         }
   162|         if ($publishedOnly) {
   163|             $this->listFilters[] = [
   164|                 'column' => $tableAlias.'.isPublished',
   165|                 'expr'   => 'eq',
   166|                 'value'  => true,
   167|             ];
   168|         }
   169|         if ($minimal) {
   170|             if (isset($this->serializerGroups[0])) {
   171|                 $this->serializerGroups[0] = str_replace('Details', 'List', $this->serializerGroups[0]);
   172|             }
   173|         }
   174|         $args = array_merge(
   175|             [
   176|                 'start'  => $request->query->get('start', 0),
   177|                 'limit'  => $request->query->get('limit', $this->coreParametersHelper->get('default_pagelimit')),
   178|                 'filter' => [
   179|                     'string' => $request->query->get('search', ''),
   180|                     'force'  => $this->listFilters,
   181|                 ],
   182|                 'orderBy'        => $this->addAliasIfNotPresent($request->query->get('orderBy', ''), $tableAlias),
   183|                 'orderByDir'     => $request->query->get('orderByDir', 'ASC'),
   184|                 'withTotalCount' => true, // for repositories that break free of Paginator
   185|             ],
   186|             $this->extraGetEntitiesArguments
   187|         );
   188|         if ($select = InputHelper::cleanArray($request->query->all()['select'] ?? $request->request->all()['select'] ?? [])) {
   189|             $args['select']              = $select;
   190|             $this->customSelectRequested = true;
   191|         }
   192|         if ($where = $this->getWhereFromRequest($request)) {
   193|             $args['filter']['where'] = $where;
   194|         }
   195|         if ($order = $this->getOrderFromRequest($request)) {
   196|             $args['filter']['order'] = $order;
   197|         }
   198|         if ($totalCountTtl = $this->getTotalCountTtl()) {
   199|             $args['totalCountTtl'] = $totalCountTtl;
   200|         }
   201|         $results = $this->model->getEntities($args);
   202|         [$entities, $totalCount] = $this->prepareEntitiesForView($results);
   203|         $view = $this->view(
   204|             [
   205|                 'total'                => $totalCount,
   206|                 $this->entityNameMulti => $entities,
   207|             ],
   208|             Response::HTTP_OK
   209|         );
   210|         $this->setSerializationContext($view);
   211|         return $this->handleView($view);
   212|     }
   213|     /**
   214|      * Sanitizes and returns an array of where statements from the request.
   215|      *
   216|      * @return array<mixed>
   217|      */
   218|     protected function getWhereFromRequest(Request $request)
   219|     {
   220|         $where = $request->query->all()['where'] ?? [];
   221|         $this->sanitizeWhereClauseArrayFromRequest($where);
   222|         return $where;
   223|     }
   224|     /**
   225|      * Sanitizes and returns an array of ORDER statements from the request.
   226|      *
   227|      * @return array<mixed>
   228|      */
   229|     protected function getOrderFromRequest(Request $request): array
   230|     {
   231|         return InputHelper::cleanArray($request->query->all()['order'] ?? []);
   232|     }
   233|     /**
   234|      * Adds the repository alias to the column name if it doesn't exist.
   235|      *
   236|      * @return string $column name with alias prefix
   237|      */
   238|     protected function addAliasIfNotPresent(string $columns, string $alias): string
   239|     {
   240|         if (!$columns) {
   241|             return $columns;
   242|         }
   243|         $columns = explode(',', trim($columns));
   244|         $prefix  = $alias.'.';
   245|         array_walk(
   246|             $columns,
   247|             function (&$column, $key, $prefix): void {
   248|                 $column = trim($column);
   249|                 if (1 === count(explode('.', $column))) {
   250|                     $column = $prefix.$column;
   251|                 }
   252|             },
   253|             $prefix
   254|         );
   255|         return implode(',', $columns);
   256|     }
   257|     /**
   258|      * Obtains a specific entity as defined by the API URL.
   259|      *
   260|      * @param int $id Entity ID
   261|      *
   262|      * @return Response
   263|      */
   264|     public function getEntityAction(Request $request, $id)
   265|     {
   266|         $args = [];
   267|         if ($select = InputHelper::cleanArray($request->get('select', []))) {
   268|             $args['select']              = $select;
   269|             $this->customSelectRequested = true;
   270|         }
   271|         if (!empty($args)) {
   272|             $args['id'] = $id;
   273|             $entity     = $this->model->getEntity($args);
   274|         } else {
   275|             $entity = $this->model->getEntity($id);
   276|         }
   277|         if (!$entity instanceof $this->entityClass) {
   278|             return $this->notFound();
   279|         }
   280|         if (!$this->checkEntityAccess($entity)) {
   281|             return $this->accessDenied();
   282|         }
   283|         $this->preSerializeEntity($entity);
   284|         $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK);
   285|         $this->setSerializationContext($view);
   286|         return $this->handleView($view);
   287|     }
   288|     /**
   289|      * Creates new entity from provided params.
   290|      *
   291|      * @param array<mixed> $params
   292|      *
   293|      * @return object
   294|      */
   295|     public function getNewEntity(array $params)
   296|     {
   297|         return $this->model->getEntity();
   298|     }
   299|     public function getCurrentRequest(): Request
   300|     {
   301|         $request = $this->requestStack->getCurrentRequest();
   302|         if (null === $request) {
   303|             throw new \RuntimeException('Request is not set.');
   304|         }
   305|         return $request;
   306|     }
   307|     /**
   308|      * Alias for notFound method. It's used in the LeadAccessTrait.
   309|      *
   310|      * @param array<mixed> $args
   311|      *
   312|      * @return Response
   313|      */
   314|     public function postActionRedirect(array $args = [])
   315|     {
   316|         return $this->notFound('mautic.contact.error.notfound');
   317|     }
   318|     /**
   319|      * Returns a 403 Access Denied.
   320|      *
   321|      * @param string $msg
   322|      *
   323|      * @return Response
   324|      */
   325|     protected function accessDenied($msg = 'mautic.core.error.accessdenied')
   326|     {
   327|         return $this->returnError($msg, Response::HTTP_FORBIDDEN);
   328|     }
   329|     protected function addExclusionStrategy(ExclusionStrategyInterface $strategy): void
   330|     {
   331|         $this->exclusionStrategies[] = $strategy;
   332|     }
   333|     /**
   334|      * Returns a 400 Bad Request.
   335|      *
   336|      * @param string $msg
   337|      *
   338|      * @return Response
   339|      */
   340|     protected function badRequest($msg = 'mautic.core.error.badrequest')
   341|     {
   342|         return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
   343|     }
   344|     /**
   345|      * Checks if user has permission to access retrieved entity.
   346|      *
   347|      * @param mixed  $entity
   348|      * @param string $action view|create|edit|publish|delete
   349|      *
   350|      * @return bool|Response
   351|      */
   352|     protected function checkEntityAccess($entity, $action = 'view')
   353|     {
   354|         if ('create' !== $action && is_object($entity) && method_exists($entity, 'getCreatedBy')) {
   355|             $ownPerm   = "{$this->permissionBase}:{$action}own";
   356|             $otherPerm = "{$this->permissionBase}:{$action}other";
   357|             $owner = (method_exists($entity, 'getPermissionUser')) ? $entity->getPermissionUser() : $entity->getCreatedBy();
   358|             return $this->security->hasEntityAccess($ownPerm, $otherPerm, $owner);
   359|         }
   360|         try {
   361|             return $this->security->isGranted("{$this->permissionBase}:{$action}");
   362|         } catch (PermissionException $e) {
   363|             return $this->accessDenied($e->getMessage());
   364|         }
   365|     }
   366|     /**
   367|      * @param mixed[]                   $parameters
   368|      * @param mixed[]                   $errors
   369|      * @param bool                      $prepareForSerialization
   370|      * @param string                    $requestIdColumn
   371|      * @param MauticModelInterface|null $model
   372|      * @param bool                      $returnWithOriginalKeys
   373|      *
   374|      * @return mixed[]
   375|      */
   376|     protected function getBatchEntities($parameters, &$errors, $prepareForSerialization = false, $requestIdColumn = 'id', $model = null, $returnWithOriginalKeys = true): array
   377|     {
   378|         $idHelper = new BatchIdToEntityHelper($parameters, $requestIdColumn);
   379|         if (!$idHelper->hasIds()) {
   380|             return [];
   381|         }
   382|         /** @var AbstractCommonModel<object> $model */
   383|         $model    = $model ?: $this->model;
   384|         $entities = $model->getEntities(
   385|             [
   386|                 'filter' => [
   387|                     'force' => [
   388|                         [
   389|                             'column' => $model->getRepository()->getTableAlias().'.id',
   390|                             'expr'   => 'in',
   391|                             'value'  => $idHelper->getIds(),
   392|                         ],
   393|                     ],
   394|                 ],
   395|                 'ignore_paginator' => true,
   396|             ]
   397|         );
   398|         $idHelper->setIsAssociative(true);
   399|         [$entities, $total] = $prepareForSerialization
   400|                 ?
   401|                 $this->prepareEntitiesForView($entities)
   402|                 :
   403|                 $this->prepareEntityResultsToArray($entities);
   404|         if ($idHelper->hasErrors()) {
   405|             foreach ($idHelper->getErrors() as $key => $error) {
   406|                 $this->setBatchError($key, $error, Response::HTTP_BAD_REQUEST, $errors);
   407|             }
   408|         }
   409|         if ($returnWithOriginalKeys) {
   410|             if ($entities instanceof \ArrayObject) {
   411|                 $entities = $entities->getArrayCopy();
   412|             }
   413|             return $idHelper->orderByOriginalKey($entities);
   414|         }
   415|         $return = [];
   416|         foreach ($entities as $entity) {
   417|             $return[$entity->getId()] = $entity;
   418|         }
   419|         return $return;
   420|     }
   421|     /**
   422|      * Get the default properties of an entity and parents.
   423|      *
   424|      * @phpstan-param E $entity
   425|      *
   426|      * @return array<mixed>
   427|      */
   428|     protected function getEntityDefaultProperties(object $entity): array
   429|     {
   430|         $class         = $entity::class;
   431|         $chain         = array_reverse(class_parents($entity), true) + [$class => $class];
   432|         $defaultValues = [];
   433|         $classMetdata = new ClassMetadata($class);
   434|         foreach ($chain as $class) {
   435|             if (method_exists($class, 'loadMetadata')) {
   436|                 $class::loadMetadata($classMetdata);
   437|             }
   438|             $defaultValues += (new \ReflectionClass($class))->getDefaultProperties();
   439|         }
   440|         $fields = $classMetdata->getFieldNames();
   441|         $properties = [];
   442|         foreach ($fields as $field) {
   443|             $properties[$field] = $defaultValues[$field];
   444|         }
   445|         return $properties;
   446|     }
   447|     /**
   448|      * Append options to the form.
   449|      *
   450|      * @return array<string, mixed>
   451|      */
   452|     protected function getEntityFormOptions(): array
   453|     {
   454|         return [];
   455|     }
   456|     /**
   457|      * Get a model instance from the service container.
   458|      *
   459|      * @return AbstractCommonModel<E>
   460|      */
   461|     protected function getModel(string $modelNameKey): AbstractCommonModel
   462|     {
   463|         return $this->modelFactory->getModel($modelNameKey);
   464|     }
   465|     /**
   466|      * Returns a 404 Not Found.
   467|      *
   468|      * @return Response
   469|      */
   470|     protected function notFound(string $msg = 'mautic.core.error.notfound')
   471|     {
   472|         return $this->returnError($msg, Response::HTTP_NOT_FOUND);
   473|     }
   474|     /**
   475|      * Gives child controllers opportunity to analyze and do whatever to an entity before going through serializer.
   476|      *
   477|      * @phpstan-param E $entity
   478|      */
   479|     protected function preSerializeEntity(object $entity, string $action = 'view'): void
   480|     {
   481|     }
   482|     /**
   483|      * Prepares entities returned from repository getEntities().
   484|      *
   485|      * @param array<mixed>|Paginator<E> $results
   486|      *
   487|      * @return array{0: array<mixed>|\ArrayObject<int,mixed>, 1: int}
   488|      */
   489|     protected function prepareEntitiesForView($results): array
   490|     {
   491|         return $this->prepareEntityResultsToArray(
   492|             $results,
   493|             function ($entity): void {
   494|                 $this->preSerializeEntity($entity);
   495|             }
   496|         );
   497|     }
   498|     /**
   499|      * @param array<mixed>|Paginator<E> $results
   500|      * @param callable|null             $callback
   501|      *
   502|      * @return array{0: array<mixed>|\ArrayObject<int,mixed>, 1: int}
   503|      */
   504|     protected function prepareEntityResultsToArray($results, $callback = null): array
   505|     {
   506|         if (is_array($results) && isset($results['count'])) {
   507|             $totalCount = $results['count'];
   508|             $results    = $results['results'];
   509|         } else {
   510|             $totalCount = count($results);
   511|         }
   512|         $entities = $this->entityResultHelper->getArray($results, $callback);
   513|         return [$entities, $totalCount];
   514|     }
   515|     /**
   516|      * Returns an error.
   517|      *
   518|      * @param array<mixed> $details
   519|      *
   520|      * @return Response|array<string, array<mixed>|int|string|null>
   521|      */
   522|     protected function returnError(string $msg, int $code = Response::HTTP_INTERNAL_SERVER_ERROR, array $details = [])
   523|     {
   524|         if ($this->translator->hasId($msg, 'flashes')) {
   525|             $msg = $this->translator->trans($msg, [], 'flashes');
   526|         } elseif ($this->translator->hasId($msg, 'messages')) {
   527|             $msg = $this->translator->trans($msg, [], 'messages');
   528|         }
   529|         $error = [
   530|             'code'    => $code,
   531|             'message' => $msg,
   532|             'details' => $details,
   533|             'type'    => null,
   534|         ];
   535|         if ($this->inBatchMode) {
   536|             return $error;
   537|         }
   538|         $view = $this->view(
   539|             [
   540|                 'errors' => [
   541|                     $error,
   542|                 ],
   543|             ],
   544|             $code
   545|         );
   546|         return $this->handleView($view);
   547|     }
   548|     /**
   549|      * @param array<mixed> $where
   550|      */
   551|     protected function sanitizeWhereClauseArrayFromRequest(array &$where): void
   552|     {
   553|         foreach ($where as $key => $statement) {
   554|             if (isset($statement['internal'])) {
   555|                 unset($where[$key]);
   556|             } elseif (in_array($statement['expr'], ['andX', 'orX'])) {
   557|                 $this->sanitizeWhereClauseArrayFromRequest($statement['val']);
   558|             }
   559|         }
   560|     }
   561|     /**
   562|      * @param array<int, array<string|int>> $errors
   563|      * @param array<int, object|null>       $entities
   564|      *
   565|      * @phpstan-param E|null $entity
   566|      * @phpstan-param array<int, E|null> $entities
   567|      */
   568|     protected function setBatchError(int $key, string $msg, int $code, array &$errors, array &$entities = [], ?object $entity = null): void
   569|     {
   570|         unset($entities[$key]);
   571|         if ($entity) {
   572|             $this->doctrine->getManager()->detach($entity);
   573|         }
   574|         $errors[$key] = [
   575|             'message' => $this->translator->hasId($msg, 'flashes') ? $this->translator->trans($msg, [], 'flashes') : $msg,
   576|             'code'    => $code,
   577|             'type'    => 'api',
   578|         ];
   579|     }
   580|     /**
   581|      * Set serialization groups and exclusion strategies.
   582|      */
   583|     protected function setSerializationContext(View $view): void
   584|     {
   585|         $context = $view->getContext();
   586|         if ($this->dispatcher->hasListeners(ApiEvents::API_PRE_SERIALIZATION_CONTEXT)) {
   587|             $apiSerializationContextEvent = new ApiSerializationContextEvent($context, $this->getCurrentRequest());
   588|             $this->dispatcher->dispatch($apiSerializationContextEvent, ApiEvents::API_PRE_SERIALIZATION_CONTEXT);
   589|             $context = $apiSerializationContextEvent->getContext();
   590|         }
   591|         if (!empty($this->serializerGroups)) {
   592|             $context->setGroups($this->serializerGroups);
   593|         }
   594|         $context->addExclusionStrategy(
   595|             new PublishDetailsExclusionStrategy()
   596|         );
   597|         if ($this->parentChildrenLevelDepth) {
   598|             $context->addExclusionStrategy(
   599|                 new ParentChildrenExclusionStrategy($this->parentChildrenLevelDepth)
   600|             );
   601|         }
   602|         foreach ($this->exclusionStrategies as $strategy) {
   603|             $context->addExclusionStrategy($strategy);
   604|         }
   605|         if (!$this->customSelectRequested) {
   606|             $context->setSerializeNull(true);
   607|         }
   608|         if ($this->dispatcher->hasListeners(ApiEvents::API_POST_SERIALIZATION_CONTEXT)) {
   609|             $apiSerializationContextEvent = new ApiSerializationContextEvent($context, $this->getCurrentRequest());
   610|             $this->dispatcher->dispatch($apiSerializationContextEvent, ApiEvents::API_POST_SERIALIZATION_CONTEXT);
   611|             $context = $apiSerializationContextEvent->getContext();
   612|         }
   613|         $view->setContext($context);
   614|     }
   615|     /**
   616|      * @param array<mixed> $parameters
   617|      *
   618|      * @return array<string, array<mixed>|int|string|null>|bool|Response
   619|      */
   620|     protected function validateBatchPayload(array $parameters)
   621|     {
   622|         $batchLimit = (int) $this->coreParametersHelper->get('api_batch_max_limit', 200);
   623|         if (count($parameters) > $batchLimit) {
   624|             return $this->returnError($this->translator->trans('mautic.api.call.batch_exception', ['%limit%' => $batchLimit]));
   625|         }
   626|         return true;
   627|     }
   628|     /**
   629|      * @param mixed|null                $data
   630|      * @param array<string, string|int> $headers
   631|      */
   632|     protected function view($data = null, ?int $statusCode = null, array $headers = []): View
   633|     {
   634|         if ($data instanceof Paginator) {
   635|             $data = iterator_to_array($data->getIterator(), true);
   636|         }
   637|         $headers['Mautic-Version'] = $this->appVersion->getVersion();
   638|         return parent::view($data, $statusCode, $headers);
   639|     }
   640|     protected function getTotalCountTtl(): ?int
   641|     {
   642|         return null;
   643|     }
   644| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Controller/oAuth2/AuthorizeController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-70 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Controller\oAuth2;
     3| use FOS\OAuthServerBundle\Form\Handler\AuthorizeFormHandler;
     4| use FOS\OAuthServerBundle\Model\ClientManagerInterface;
     5| use OAuth2\OAuth2;
     6| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
     7| use Symfony\Component\Form\Form;
     8| use Symfony\Component\HttpFoundation\Request;
     9| use Symfony\Component\HttpFoundation\RequestStack;
    10| use Symfony\Component\HttpFoundation\Response;
    11| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    12| use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
    13| use Symfony\Component\Security\Core\Exception\AccessDeniedException;
    14| use Twig\Environment;
    15| use Twig\Error\LoaderError;
    16| use Twig\Error\RuntimeError;
    17| use Twig\Error\SyntaxError;
    18| class AuthorizeController extends \FOS\OAuthServerBundle\Controller\AuthorizeController
    19| {
    20|     private TokenStorageInterface $tokenStorage;
    21|     /**
    22|      * This constructor must be duplicated from the extended class so our custom code could access the properties.
    23|      */
    24|     public function __construct(
    25|         RequestStack $requestStack,
    26|         Form $authorizeForm,
    27|         AuthorizeFormHandler $authorizeFormHandler,
    28|         OAuth2 $oAuth2Server,
    29|         TokenStorageInterface $tokenStorage,
    30|         UrlGeneratorInterface $router,
    31|         ClientManagerInterface $clientManager,
    32|         EventDispatcherInterface $eventDispatcher,
    33|         private Environment $twig,
    34|     ) {
    35|         parent::__construct(
    36|             $requestStack,
    37|             $authorizeForm,
    38|             $authorizeFormHandler,
    39|             $oAuth2Server,
    40|             $twig,
    41|             $tokenStorage,
    42|             $router,
    43|             $clientManager,
    44|             $eventDispatcher
    45|         );
    46|         $this->tokenStorage = $tokenStorage;
    47|     }
    48|     /**
    49|      * @param array<string , mixed> $data Various data to be passed to the twig template
    50|      *
    51|      * @throws LoaderError
    52|      * @throws RuntimeError
    53|      * @throws SyntaxError
    54|      */
    55|     protected function renderAuthorize(array $data): Response
    56|     {
    57|         $response = $this->twig->render(
    58|             '@MauticApi/Authorize/oAuth2/authorize.html.twig',
    59|             $data
    60|         );
    61|         return new Response($response);
    62|     }
    63|     public function authorizeAction(Request $request): Response
    64|     {
    65|         if (null === $this->tokenStorage->getToken()) {
    66|             throw new AccessDeniedException('This user does not have access to this section. No token.');
    67|         }
    68|         return parent::authorizeAction($request);
    69|     }
    70| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Controller/oAuth2/SecurityController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Controller\oAuth2;
     3| use Mautic\CoreBundle\Controller\CommonController;
     4| use Symfony\Component\HttpFoundation\Request;
     5| use Symfony\Component\HttpFoundation\Response;
     6| use Symfony\Component\Security\Core\Exception;
     7| use Symfony\Component\Security\Http\SecurityRequestAttributes;
     8| class SecurityController extends CommonController
     9| {
    10|     public function loginAction(Request $request): Response
    11|     {
    12|         $session = $request->getSession();
    13|         if ($request->attributes->has(SecurityRequestAttributes::AUTHENTICATION_ERROR)) {
    14|             $error = $request->attributes->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
    15|         } else {
    16|             $error = $session->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
    17|             $session->remove(SecurityRequestAttributes::AUTHENTICATION_ERROR);
    18|         }
    19|         if (!empty($error)) {
    20|             if ($error instanceof Exception\BadCredentialsException) {
    21|                 $msg = 'mautic.user.auth.error.invalidlogin';
    22|             } else {
    23|                 $msg = $error->getMessage();
    24|             }
    25|             $this->addFlashMessage($msg, [], 'error', null, false);
    26|         }
    27|         if ($session->has('_security.target_path')) {
    28|             if (str_contains($session->get('_security.target_path'), $this->generateUrl('fos_oauth_server_authorize'))) {
    29|                 $session->set('_fos_oauth_server.ensure_logout', true);
    30|             }
    31|         }
    32|         return $this->render(
    33|             '@MauticApi/Security/login.html.twig',
    34|             [
    35|                 'last_username' => $session->get(SecurityRequestAttributes::LAST_USERNAME),
    36|                 'route'         => 'mautic_oauth2_server_auth_login_check',
    37|             ]
    38|         );
    39|     }
    40|     public function loginCheckAction(): Response
    41|     {
    42|         return new Response('', 400);
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Entity/oAuth2/Client.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-201 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Entity\oAuth2;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\ORM\Mapping as ORM;
     5| use FOS\OAuthServerBundle\Model\Client as BaseClient;
     6| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     7| use Mautic\UserBundle\Entity\Role;
     8| use Mautic\UserBundle\Entity\User;
     9| use OAuth2\OAuth2;
    10| use Symfony\Component\Validator\Constraints as Assert;
    11| use Symfony\Component\Validator\Mapping\ClassMetadata;
    12| class Client extends BaseClient
    13| {
    14|     /**
    15|      * @var int
    16|      */
    17|     protected $id;
    18|     /**
    19|      * @var string
    20|      */
    21|     protected $name;
    22|     /**
    23|      * @var ArrayCollection<int, User>
    24|      */
    25|     protected $users;
    26|     /**
    27|      * @var ArrayCollection
    28|      */
    29|     protected $authCodes;
    30|     protected ?string $randomId = null;
    31|     protected ?string $secret = null;
    32|     /**
    33|      * @var array<string>
    34|      */
    35|     protected array $redirectUris = [];
    36|     /**
    37|      * @var array<string>
    38|      */
    39|     protected array $allowedGrantTypes;
    40|     protected ?Role $role;
    41|     public function __construct()
    42|     {
    43|         parent::__construct();
    44|         $this->allowedGrantTypes = [
    45|             OAuth2::GRANT_TYPE_AUTH_CODE,
    46|             OAuth2::GRANT_TYPE_REFRESH_TOKEN,
    47|         ];
    48|         $this->users     = new ArrayCollection();
    49|         $this->authCodes = new ArrayCollection();
    50|     }
    51|     public static function loadMetadata(ORM\ClassMetadata $metadata): void
    52|     {
    53|         $builder = new ClassMetadataBuilder($metadata);
    54|         $builder->setTable('oauth2_clients')
    55|             ->setCustomRepositoryClass(ClientRepository::class)
    56|             ->addIndex(['random_id'], 'client_id_search');
    57|         $builder->addIdColumns('name', false);
    58|         $builder->createManyToMany('users', User::class)
    59|             ->setJoinTable('oauth2_user_client_xref')
    60|             ->addInverseJoinColumn('user_id', 'id', false, false, 'CASCADE')
    61|             ->addJoinColumn('client_id', 'id', false, false, 'CASCADE')
    62|             ->fetchExtraLazy()
    63|             ->build();
    64|         $builder->createField('randomId', 'string')
    65|             ->columnName('random_id')
    66|             ->build();
    67|         $builder->addField('secret', 'string');
    68|         $builder->createField('redirectUris', 'array')
    69|             ->columnName('redirect_uris')
    70|             ->build();
    71|         $builder->createField('allowedGrantTypes', 'array')
    72|             ->columnName('allowed_grant_types')
    73|             ->build();
    74|         $builder->createManyToOne('role', Role::class)
    75|             ->addJoinColumn('role_id', 'id', true, false)
    76|             ->cascadePersist()
    77|             ->build();
    78|     }
    79|     public static function loadValidatorMetadata(ClassMetadata $metadata): void
    80|     {
    81|         $metadata->addPropertyConstraint('name', new Assert\NotBlank(
    82|             ['message' => 'mautic.core.name.required']
    83|         ));
    84|         $metadata->addPropertyConstraint('redirectUris', new Assert\NotBlank(
    85|             ['message' => 'mautic.api.client.redirecturis.notblank']
    86|         ));
    87|     }
    88|     /**
    89|      * @var array
    90|      */
    91|     protected $changes;
    92|     protected function isChanged($prop, $val)
    93|     {
    94|         $getter  = 'get'.ucfirst($prop);
    95|         $current = $this->$getter();
    96|         if ($current != $val) {
    97|             $this->changes[$prop] = [$current, $val];
    98|         }
    99|     }
   100|     /**
   101|      * @return array
   102|      */
   103|     public function getChanges()
   104|     {
   105|         return $this->changes;
   106|     }
   107|     /**
   108|      * @return int
   109|      */
   110|     public function getId()
   111|     {
   112|         return $this->id;
   113|     }
   114|     /**
   115|      * @param string $name
   116|      *
   117|      * @return Client
   118|      */
   119|     public function setName($name)
   120|     {
   121|         $this->isChanged('name', $name);
   122|         $this->name = $name;
   123|         return $this;
   124|     }
   125|     /**
   126|      * @return string
   127|      */
   128|     public function getName()
   129|     {
   130|         return $this->name;
   131|     }
   132|     public function setRedirectUris(array $redirectUris): void
   133|     {
   134|         $this->isChanged('redirectUris', $redirectUris);
   135|         $this->redirectUris = $redirectUris;
   136|     }
   137|     /**
   138|      * @return Client
   139|      */
   140|     public function addAuthCode(AuthCode $authCodes)
   141|     {
   142|         $this->authCodes[] = $authCodes;
   143|         return $this;
   144|     }
   145|     public function removeAuthCode(AuthCode $authCodes): void
   146|     {
   147|         $this->authCodes->removeElement($authCodes);
   148|     }
   149|     /**
   150|      * @return \Doctrine\Common\Collections\Collection
   151|      */
   152|     public function getAuthCodes()
   153|     {
   154|         return $this->authCodes;
   155|     }
   156|     /**
   157|      * Determines if a client attempting API access is already authorized by the user.
   158|      *
   159|      * @return bool
   160|      */
   161|     public function isAuthorizedClient(User $user)
   162|     {
   163|         $users = $this->getUsers();
   164|         return $users->contains($user);
   165|     }
   166|     /**
   167|      * @return Client
   168|      */
   169|     public function addUser(User $users)
   170|     {
   171|         $this->users[] = $users;
   172|         return $this;
   173|     }
   174|     public function removeUser(User $users): void
   175|     {
   176|         $this->users->removeElement($users);
   177|     }
   178|     /**
   179|      * @return \Doctrine\Common\Collections\Collection
   180|      */
   181|     public function getUsers()
   182|     {
   183|         return $this->users;
   184|     }
   185|     /**
   186|      * Add Authorization Grant Type.
   187|      */
   188|     public function addGrantType(string $grantType): Client
   189|     {
   190|         $this->allowedGrantTypes[] = $grantType;
   191|         return $this;
   192|     }
   193|     public function getRole(): Role
   194|     {
   195|         return $this->role;
   196|     }
   197|     public function setRole(Role $role): void
   198|     {
   199|         $this->role = $role;
   200|     }
   201| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Event/ApiEntityEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Event;
     3| use Mautic\CoreBundle\Event\CommonEvent;
     4| use Symfony\Component\HttpFoundation\Request;
     5| class ApiEntityEvent extends CommonEvent
     6| {
     7|     /**
     8|      * @param object $entity
     9|      */
    10|     public function __construct(
    11|         protected $entity,
    12|         protected array $entityRequestParameters,
    13|         private Request $request,
    14|     ) {
    15|     }
    16|     /**
    17|      * @return object
    18|      */
    19|     public function getEntity()
    20|     {
    21|         return $this->entity;
    22|     }
    23|     /**
    24|      * @return array
    25|      */
    26|     public function getEntityRequestParameters()
    27|     {
    28|         return $this->entityRequestParameters;
    29|     }
    30|     /**
    31|      * @return Request
    32|      */
    33|     public function getRequest()
    34|     {
    35|         return $this->request;
    36|     }
    37| }


# ====================================================================
# FILE: app/bundles/ApiBundle/EventListener/ApiSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-141 ---
     1| <?php
     2| namespace Mautic\ApiBundle\EventListener;
     3| use Mautic\ApiBundle\Helper\RequestHelper;
     4| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     5| use Mautic\CoreBundle\Translation\Translator;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| use Symfony\Component\HttpFoundation\JsonResponse;
     8| use Symfony\Component\HttpKernel\Event\RequestEvent;
     9| use Symfony\Component\HttpKernel\Event\ResponseEvent;
    10| use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
    11| use Symfony\Component\HttpKernel\KernelEvents;
    12| class ApiSubscriber implements EventSubscriberInterface
    13| {
    14|     public function __construct(
    15|         private CoreParametersHelper $coreParametersHelper,
    16|         private Translator $translator,
    17|     ) {
    18|     }
    19|     public static function getSubscribedEvents(): array
    20|     {
    21|         return [
    22|             KernelEvents::REQUEST  => ['onKernelRequest', 255],
    23|             KernelEvents::RESPONSE => ['onKernelResponse', 0],
    24|         ];
    25|     }
    26|     /**
    27|      * Check for API requests and throw denied access if API is disabled.
    28|      *
    29|      * @throws AccessDeniedHttpException
    30|      */
    31|     public function onKernelRequest(RequestEvent $event): void
    32|     {
    33|         if (!$event->isMainRequest()) {
    34|             return;
    35|         }
    36|         $request = $event->getRequest();
    37|         if (!RequestHelper::isApiRequest($request)) {
    38|             return;
    39|         }
    40|         $apiEnabled = $this->coreParametersHelper->get('api_enabled');
    41|         if (!$apiEnabled) {
    42|             $response   = new JsonResponse(
    43|                 [
    44|                     'errors' => [
    45|                         [
    46|                             'message' => $this->translator->trans('mautic.api.error.api.disabled'),
    47|                             'code'    => 403,
    48|                             'type'    => 'api_disabled',
    49|                         ],
    50|                     ],
    51|                 ],
    52|                 403
    53|             );
    54|             $event->setResponse($response);
    55|             return;
    56|         }
    57|         $hasBasicAuth     = RequestHelper::hasBasicAuth($request);
    58|         $basicAuthEnabled = $this->coreParametersHelper->get('api_enable_basic_auth');
    59|         if ($hasBasicAuth && !$basicAuthEnabled) {
    60|             $response   = new JsonResponse(
    61|                 [
    62|                     'errors' => [
    63|                         [
    64|                             'message' => $this->translator->trans('mautic.api.error.basic.auth.disabled'),
    65|                             'code'    => 403,
    66|                             'type'    => 'access_denied',
    67|                         ],
    68|                     ],
    69|                 ],
    70|                 403
    71|             );
    72|             $event->setResponse($response);
    73|         }
    74|     }
    75|     public function onKernelResponse(ResponseEvent $event): void
    76|     {
    77|         $request      = $event->getRequest();
    78|         $isApiRequest = RequestHelper::isApiRequest($request);
    79|         $hasBasicAuth = RequestHelper::hasBasicAuth($event->getRequest());
    80|         if (!$isApiRequest) {
    81|             return;
    82|         }
    83|         $response = $event->getResponse();
    84|         $content  = $response->getContent();
    85|         if (!str_contains($content, 'error')) {
    86|             return;
    87|         }
    88|         if (!$data = json_decode($content, true)) {
    89|             return;
    90|         }
    91|         if (!isset($data['error'])) {
    92|             return;
    93|         }
    94|         $type  = null;
    95|         $error = $data['error'];
    96|         if (is_array($error)) {
    97|             if (!isset($error['message'])) {
    98|                 return;
    99|             }
   100|             $error = $error['message'];
   101|         }
   102|         switch ($error) {
   103|             case 'access_denied':
   104|                 $type    = $error;
   105|                 $message = $this->translator->trans('mautic.api.auth.error.accessdenied');
   106|                 if ($hasBasicAuth) {
   107|                     if ($this->coreParametersHelper->get('api_enable_basic_auth')) {
   108|                         $message = $this->translator->trans('mautic.api.error.basic.auth.invalid.credentials');
   109|                     } else {
   110|                         $message = $this->translator->trans('mautic.api.error.basic.auth.disabled');
   111|                     }
   112|                 }
   113|                 break;
   114|             default:
   115|                 if (isset($data['error_description'])) {
   116|                     $message = $data['error_description'];
   117|                     $type    = $error;
   118|                 } elseif ($this->translator->hasId('mautic.api.auth.error.'.$error)) {
   119|                     $message = $this->translator->trans('mautic.api.auth.error.'.$error);
   120|                     $type    = $error;
   121|                 }
   122|         }
   123|         if (!isset($message)) {
   124|             return;
   125|         }
   126|         $statusCode = $response->getStatusCode();
   127|         $response   = new JsonResponse(
   128|             [
   129|                 'errors' => [
   130|                     [
   131|                         'message' => $message,
   132|                         'code'    => $response->getStatusCode(),
   133|                         'type'    => $type,
   134|                     ],
   135|                 ],
   136|             ],
   137|             $statusCode
   138|         );
   139|         $event->setResponse($response);
   140|     }
   141| }


# ====================================================================
# FILE: app/bundles/ApiBundle/EventListener/ClientSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| <?php
     2| namespace Mautic\ApiBundle\EventListener;
     3| use Mautic\ApiBundle\ApiEvents;
     4| use Mautic\ApiBundle\Event as Events;
     5| use Mautic\CoreBundle\Helper\IpLookupHelper;
     6| use Mautic\CoreBundle\Model\AuditLogModel;
     7| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     8| class ClientSubscriber implements EventSubscriberInterface
     9| {
    10|     public function __construct(
    11|         private IpLookupHelper $ipLookupHelper,
    12|         private AuditLogModel $auditLogModel,
    13|     ) {
    14|     }
    15|     public static function getSubscribedEvents(): array
    16|     {
    17|         return [
    18|             ApiEvents::CLIENT_POST_SAVE   => ['onClientPostSave', 0],
    19|             ApiEvents::CLIENT_POST_DELETE => ['onClientDelete', 0],
    20|         ];
    21|     }
    22|     /**
    23|      * Add a client change entry to the audit log.
    24|      */
    25|     public function onClientPostSave(Events\ClientEvent $event): void
    26|     {
    27|         $client = $event->getClient();
    28|         if (!$details = $event->getChanges()) {
    29|             return;
    30|         }
    31|         $log = [
    32|             'bundle'    => 'api',
    33|             'object'    => 'client',
    34|             'objectId'  => $client->getId(),
    35|             'action'    => ($event->isNew()) ? 'create' : 'update',
    36|             'details'   => $details,
    37|             'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    38|         ];
    39|         $this->auditLogModel->writeToLog($log);
    40|     }
    41|     /**
    42|      * Add a role delete entry to the audit log.
    43|      */
    44|     public function onClientDelete(Events\ClientEvent $event): void
    45|     {
    46|         $client = $event->getClient();
    47|         $log    = [
    48|             'bundle'    => 'api',
    49|             'object'    => 'client',
    50|             'objectId'  => $client->deletedId,
    51|             'action'    => 'delete',
    52|             'details'   => ['name' => $client->getName()],
    53|             'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    54|         ];
    55|         $this->auditLogModel->writeToLog($log);
    56|     }
    57| }


# ====================================================================
# FILE: app/bundles/ApiBundle/EventListener/PreAuthorizationEventListener.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| <?php
     2| namespace Mautic\ApiBundle\EventListener;
     3| use Doctrine\ORM\EntityManager;
     4| use FOS\OAuthServerBundle\Event\OAuthEvent;
     5| use Mautic\ApiBundle\Entity\oAuth2\Client;
     6| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     7| use Symfony\Component\Security\Core\Exception\AccessDeniedException;
     8| use Symfony\Contracts\Translation\TranslatorInterface;
     9| class PreAuthorizationEventListener
    10| {
    11|     public function __construct(
    12|         private EntityManager $em,
    13|         private CorePermissions $mauticSecurity,
    14|         private TranslatorInterface $translator,
    15|     ) {
    16|     }
    17|     /**
    18|      * @throws AccessDeniedException
    19|      */
    20|     public function onPreAuthorizationProcess(OAuthEvent $event): void
    21|     {
    22|         if ($user = $this->getUser($event)) {
    23|             if (!$this->mauticSecurity->isGranted('api:access:full')) {
    24|                 throw new AccessDeniedException($this->translator->trans('mautic.core.error.accessdenied', [], 'flashes'));
    25|             }
    26|             $client = $event->getClient();
    27|             if ($client instanceof Client) {
    28|                 $event->setAuthorizedClient(
    29|                     $client->isAuthorizedClient($user)
    30|                 );
    31|             }
    32|         }
    33|     }
    34|     public function onPostAuthorizationProcess(OAuthEvent $event): void
    35|     {
    36|         if ($event->isAuthorizedClient() && null !== $client = $event->getClient()) {
    37|             if ($client instanceof Client) {
    38|                 $user = $this->getUser($event);
    39|                 $client->addUser($user);
    40|                 $this->em->persist($client);
    41|                 $this->em->flush();
    42|             }
    43|         }
    44|     }
    45|     /**
    46|      * @return mixed
    47|      */
    48|     protected function getUser(OAuthEvent $event)
    49|     {
    50|         return $this->em->getRepository(\Mautic\UserBundle\Entity\User::class)->findOneByUsername($event->getUser()->getUserIdentifier());
    51|     }
    52| }


# ====================================================================
# FILE: app/bundles/ApiBundle/EventListener/RateLimitGenerateKeySubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| <?php
     2| namespace Mautic\ApiBundle\EventListener;
     3| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     4| use Noxlogic\RateLimitBundle\Events\GenerateKeyEvent;
     5| use Noxlogic\RateLimitBundle\Events\RateLimitEvents;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| class RateLimitGenerateKeySubscriber implements EventSubscriberInterface
     8| {
     9|     public function __construct(
    10|         private CoreParametersHelper $coreParametersHelper,
    11|     ) {
    12|     }
    13|     public static function getSubscribedEvents(): array
    14|     {
    15|         return [
    16|             RateLimitEvents::GENERATE_KEY => ['onGenerateKey', 0],
    17|         ];
    18|     }
    19|     public function onGenerateKey(GenerateKeyEvent $event): void
    20|     {
    21|         $suffix = rawurlencode($this->coreParametersHelper->get('site_url'));
    22|         $event->addToKey($suffix);
    23|     }
    24| }


# ====================================================================
# FILE: app/bundles/ApiBundle/EventListener/SearchSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ApiBundle\EventListener;
     4| use Mautic\ApiBundle\Model\ClientModel;
     5| use Mautic\CoreBundle\CoreEvents;
     6| use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
     7| use Mautic\CoreBundle\Event as MauticEvents;
     8| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     9| use Mautic\CoreBundle\Service\GlobalSearch;
    10| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    11| class SearchSubscriber implements EventSubscriberInterface
    12| {
    13|     public function __construct(
    14|         private ClientModel $apiClientModel,
    15|         private CorePermissions $security,
    16|         private GlobalSearch $globalSearch,
    17|     ) {
    18|     }
    19|     public static function getSubscribedEvents(): array
    20|     {
    21|         return [
    22|             CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
    23|             CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
    24|         ];
    25|     }
    26|     public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
    27|     {
    28|         $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
    29|         $results   = $this->globalSearch->performSearch(
    30|             $filterDTO,
    31|             $this->apiClientModel,
    32|             '@MauticApi/SubscribedEvents/Search/global.html.twig'
    33|         );
    34|         if (!empty($results)) {
    35|             $event->addResults('mautic.api.client.menu.index', $results);
    36|         }
    37|     }
    38|     public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
    39|     {
    40|         if ($this->security->isGranted('api:clients:view')) {
    41|             $event->addCommands(
    42|                 'mautic.api.client.header.index',
    43|                 $this->apiClientModel->getCommandList()
    44|             );
    45|         }
    46|     }
    47| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Form/Type/ClientType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-153 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Form\Type;
     3| use Mautic\ApiBundle\Entity\oAuth2\Client;
     4| use Mautic\ApiBundle\Form\Validator\Constraints\OAuthCallback;
     5| use Mautic\CoreBundle\Form\DataTransformer as Transformers;
     6| use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
     7| use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
     8| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     9| use Symfony\Component\Form\AbstractType;
    10| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
    11| use Symfony\Component\Form\Extension\Core\Type\TextType;
    12| use Symfony\Component\Form\FormBuilderInterface;
    13| use Symfony\Component\Form\FormError;
    14| use Symfony\Component\Form\FormEvent;
    15| use Symfony\Component\Form\FormEvents;
    16| use Symfony\Component\HttpFoundation\RequestStack;
    17| use Symfony\Component\OptionsResolver\OptionsResolver;
    18| use Symfony\Component\Routing\RouterInterface;
    19| use Symfony\Component\Validator\Validator\ValidatorInterface;
    20| use Symfony\Contracts\Translation\TranslatorInterface;
    21| /**
    22|  * @extends AbstractType<Client>
    23|  */
    24| class ClientType extends AbstractType
    25| {
    26|     public function __construct(
    27|         private RequestStack $requestStack,
    28|         private TranslatorInterface $translator,
    29|         private ValidatorInterface $validator,
    30|         private RouterInterface $router,
    31|     ) {
    32|     }
    33|     /**
    34|      * @return bool|mixed
    35|      */
    36|     private function getApiMode()
    37|     {
    38|         return $this->requestStack->getCurrentRequest()->get(
    39|             'api_mode',
    40|             $this->requestStack->getSession()->get('mautic.client.filter.api_mode', 'oauth2')
    41|         );
    42|     }
    43|     public function buildForm(FormBuilderInterface $builder, array $options): void
    44|     {
    45|         $apiMode = $this->getApiMode();
    46|         $builder->addEventSubscriber(new CleanFormSubscriber([]));
    47|         $builder->addEventSubscriber(new FormExitSubscriber('api.client', $options));
    48|         if (!$options['data']->getId()) {
    49|             $builder->add(
    50|                 'api_mode',
    51|                 ChoiceType::class,
    52|                 [
    53|                     'mapped'     => false,
    54|                     'label'      => 'mautic.api.client.form.auth_protocol',
    55|                     'label_attr' => ['class' => 'control-label'],
    56|                     'attr'       => [
    57|                         'class'    => 'form-control',
    58|                         'onchange' => 'Mautic.refreshApiClientForm(\''.$this->router->generate('mautic_client_action', ['objectAction' => 'new']).'\', this)',
    59|                     ],
    60|                     'choices' => [
    61|                         'OAuth 2'    => 'oauth2',
    62|                     ],
    63|                     'required'          => false,
    64|                     'placeholder'       => false,
    65|                     'data'              => $apiMode,
    66|                 ]
    67|             );
    68|         }
    69|         $builder->add(
    70|             'name',
    71|             TextType::class,
    72|             [
    73|                 'label'      => 'mautic.core.name',
    74|                 'label_attr' => ['class' => 'control-label'],
    75|                 'attr'       => ['class' => 'form-control'],
    76|             ]
    77|         );
    78|         $arrayStringTransformer = new Transformers\ArrayStringTransformer();
    79|         $builder->add(
    80|             $builder->create(
    81|                 'redirectUris',
    82|                 TextType::class,
    83|                 [
    84|                     'label'      => 'mautic.api.client.redirecturis',
    85|                     'label_attr' => ['class' => 'control-label'],
    86|                     'attr'       => [
    87|                         'class'   => 'form-control',
    88|                         'tooltip' => 'mautic.api.client.form.help.requesturis',
    89|                     ],
    90|                 ]
    91|             )
    92|                 ->addViewTransformer($arrayStringTransformer)
    93|         );
    94|         $builder->add(
    95|             'publicId',
    96|             TextType::class,
    97|             [
    98|                 'label'      => 'mautic.api.client.form.clientid',
    99|                 'label_attr' => ['class' => 'control-label'],
   100|                 'attr'       => ['class' => 'form-control'],
   101|                 'disabled'   => true,
   102|                 'required'   => false,
   103|                 'mapped'     => false,
   104|                 'data'       => $options['data']->getPublicId(),
   105|             ]
   106|         );
   107|         $builder->add(
   108|             'secret',
   109|             TextType::class,
   110|             [
   111|                 'label'      => 'mautic.api.client.form.clientsecret',
   112|                 'label_attr' => ['class' => 'control-label'],
   113|                 'attr'       => ['class' => 'form-control'],
   114|                 'disabled'   => true,
   115|                 'required'   => false,
   116|             ]
   117|         );
   118|         $builder->addEventListener(
   119|             FormEvents::POST_SUBMIT,
   120|             function (FormEvent $event): void {
   121|                 $form = $event->getForm();
   122|                 $data = $event->getData();
   123|                 if ($form->has('redirectUris')) {
   124|                     foreach ($data->getRedirectUris() as $uri) {
   125|                         $urlConstraint          = new OAuthCallback();
   126|                         $urlConstraint->message = $this->translator->trans(
   127|                             'mautic.api.client.redirecturl.invalid',
   128|                             ['%url%' => $uri],
   129|                             'validators'
   130|                         );
   131|                         $errors = $this->validator->validate($uri, $urlConstraint);
   132|                         foreach ($errors as $error) {
   133|                             $form['redirectUris']->addError(new FormError($error->getMessage()));
   134|                         }
   135|                     }
   136|                 }
   137|             }
   138|         );
   139|         $builder->add('buttons', FormButtonsType::class);
   140|         if (!empty($options['action'])) {
   141|             $builder->setAction($options['action']);
   142|         }
   143|     }
   144|     public function configureOptions(OptionsResolver $resolver): void
   145|     {
   146|         $dataClass = Client::class;
   147|         $resolver->setDefaults(
   148|             [
   149|                 'data_class' => $dataClass,
   150|             ]
   151|         );
   152|     }
   153| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\Extension\Core\Type\NumberType;
     6| use Symfony\Component\Form\FormBuilderInterface;
     7| use Symfony\Component\Validator\Constraints\NotBlank;
     8| /**
     9|  * @extends AbstractType<mixed>
    10|  */
    11| class ConfigType extends AbstractType
    12| {
    13|     public function buildForm(FormBuilderInterface $builder, array $options): void
    14|     {
    15|         $builder->add(
    16|             'api_enabled',
    17|             YesNoButtonGroupType::class,
    18|             [
    19|                 'label' => 'mautic.api.config.form.api.enabled',
    20|                 'data'  => isset($options['data']['api_enabled']) && (bool) $options['data']['api_enabled'],
    21|                 'help'  => 'mautic.api.config.form.api.enabled.help',
    22|             ]
    23|         );
    24|         $builder->add(
    25|             'api_enable_basic_auth',
    26|             YesNoButtonGroupType::class,
    27|             [
    28|                 'label' => 'mautic.api.config.form.api.basic_auth_enabled',
    29|                 'data'  => isset($options['data']['api_enable_basic_auth']) && (bool) $options['data']['api_enable_basic_auth'],
    30|                 'attr'  => [
    31|                     'tooltip' => 'mautic.api.config.form.api.basic_auth.tooltip',
    32|                 ],
    33|             ]
    34|         );
    35|         $builder->add(
    36|             'api_oauth2_access_token_lifetime',
    37|             NumberType::class,
    38|             [
    39|                 'label' => 'mautic.api.config.form.api.oauth2_access_token_lifetime',
    40|                 'attr'  => [
    41|                     'tooltip'      => 'mautic.api.config.form.api.oauth2_access_token_lifetime.tooltip',
    42|                     'class'        => 'form-control',
    43|                     'data-show-on' => '{"config_apiconfig_api_enabled_1":"checked"}',
    44|                 ],
    45|                 'constraints' => [
    46|                     new NotBlank(
    47|                         [
    48|                             'message' => 'mautic.core.value.required',
    49|                         ]
    50|                     ),
    51|                 ],
    52|             ]
    53|         );
    54|         $builder->add(
    55|             'api_oauth2_refresh_token_lifetime',
    56|             NumberType::class,
    57|             [
    58|                 'label' => 'mautic.api.config.form.api.oauth2_refresh_token_lifetime',
    59|                 'attr'  => [
    60|                     'tooltip'      => 'mautic.api.config.form.api.oauth2_refresh_token_lifetime.tooltip',
    61|                     'class'        => 'form-control',
    62|                     'data-show-on' => '{"config_apiconfig_api_enabled_1":"checked"}',
    63|                 ],
    64|                 'constraints' => [
    65|                     new NotBlank(
    66|                         [
    67|                             'message' => 'mautic.core.value.required',
    68|                         ]
    69|                     ),
    70|                 ],
    71|             ]
    72|         );
    73|     }
    74|     public function getBlockPrefix(): string
    75|     {
    76|         return 'apiconfig';
    77|     }
    78| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Form/Validator/Constraints/OAuthCallback.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Form\Validator\Constraints;
     3| use Symfony\Component\Validator\Constraint;
     4| class OAuthCallback extends Constraint
     5| {
     6|     public $message = 'The callback URL is invalid.';
     7|     public function validatedBy(): string
     8|     {
     9|         return OAuthCallbackValidator::class;
    10|     }
    11| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Helper/BatchIdToEntityHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-126 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Helper;
     3| class BatchIdToEntityHelper
     4| {
     5|     /**
     6|      * @var array
     7|      */
     8|     private $ids = [];
     9|     private array $originalKeys = [];
    10|     private array $errors = [];
    11|     private bool $isAssociative = false;
    12|     /**
    13|      * @param string $idKey
    14|      */
    15|     public function __construct(
    16|         array $parameters,
    17|         private $idKey = 'id',
    18|     ) {
    19|         $this->extractIds($parameters);
    20|     }
    21|     public function hasIds(): bool
    22|     {
    23|         return !empty($this->ids);
    24|     }
    25|     /**
    26|      * @return array
    27|      */
    28|     public function getIds()
    29|     {
    30|         return $this->ids;
    31|     }
    32|     public function hasErrors(): bool
    33|     {
    34|         return !empty($this->errors);
    35|     }
    36|     /**
    37|      * @return array
    38|      */
    39|     public function getErrors()
    40|     {
    41|         return $this->errors;
    42|     }
    43|     /**
    44|      * Reorder the entities based on the original keys
    45|      * BC allowed a request to have associative keys (don't ask why; yes it's terrible implementation but we're keeping BC here)
    46|      * The issue this solves is the response should match the format given by the request. If the request had associative keys, the response
    47|      * will return with associative keys (json object). If the request was a sequential numeric array starting with 0, the response will
    48|      * be a simple array (json array).
    49|      */
    50|     public function orderByOriginalKey(array $entities): array
    51|     {
    52|         if (!$this->isAssociative) {
    53|             return array_values($entities);
    54|         }
    55|         $entitiesKeyedById = [];
    56|         foreach ($entities as $entity) {
    57|             $entitiesKeyedById[$entity->getId()] = $entity;
    58|         }
    59|         $orderedEntities = [];
    60|         foreach ($this->ids as $key => $id) {
    61|             if (!isset($entitiesKeyedById[$id])) {
    62|                 continue;
    63|             }
    64|             $originalKey                   = $this->originalKeys[$key];
    65|             $orderedEntities[$originalKey] = $entitiesKeyedById[$id];
    66|         }
    67|         return $orderedEntities;
    68|     }
    69|     private function extractIds(array $parameters): void
    70|     {
    71|         $this->ids = [];
    72|         if (isset($parameters['ids'])) {
    73|             $this->extractIdsFromIdKey($parameters['ids']);
    74|             return;
    75|         }
    76|         $this->extractIdsFromParams($parameters);
    77|     }
    78|     /**
    79|      * @param mixed $ids
    80|      */
    81|     private function extractIdsFromIdKey($ids): void
    82|     {
    83|         if (is_array($ids)) {
    84|             $this->isAssociative = $this->isAssociativeArray($ids);
    85|             $this->ids           = array_values($ids);
    86|             $this->originalKeys  = array_keys($ids);
    87|             return;
    88|         }
    89|         if (str_contains($ids, ',') || is_numeric($ids)) {
    90|             $this->ids           = str_getcsv($ids);
    91|             $this->originalKeys  = array_keys($this->ids);
    92|             $this->isAssociative = false;
    93|             return;
    94|         }
    95|         $this->errors[] = 'mautic.api.call.id_missing';
    96|     }
    97|     private function extractIdsFromParams(array $parameters): void
    98|     {
    99|         $this->isAssociative = $this->isAssociativeArray($parameters);
   100|         $this->originalKeys  = array_keys($parameters);
   101|         $firstKey            = array_key_first($parameters);
   102|         if (!is_array($parameters[$firstKey])) {
   103|             $this->ids = array_values($parameters);
   104|             return;
   105|         }
   106|         foreach ($parameters as $key => $params) {
   107|             if (!isset($params[$this->idKey])) {
   108|                 $this->errors[$key] = 'mautic.api.call.id_missing';
   109|                 continue;
   110|             }
   111|             $this->ids[] = $params[$this->idKey];
   112|         }
   113|     }
   114|     private function isAssociativeArray(array $array): bool
   115|     {
   116|         if (empty($array)) {
   117|             return false;
   118|         }
   119|         $firstKey = array_key_first($array);
   120|         return array_keys($array) !== range(0, count($array) - 1) && 0 !== $firstKey;
   121|     }
   122|     public function setIsAssociative(bool $isAssociative): void
   123|     {
   124|         $this->isAssociative = $isAssociative;
   125|     }
   126| }


# ====================================================================
# FILE: app/bundles/ApiBundle/MauticApiBundle.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| <?php
     2| namespace Mautic\ApiBundle;
     3| use Mautic\ApiBundle\DependencyInjection\Compiler\SerializerPass;
     4| use Symfony\Component\DependencyInjection\ContainerBuilder;
     5| use Symfony\Component\HttpKernel\Bundle\Bundle;
     6| class MauticApiBundle extends Bundle
     7| {
     8|     public function build(ContainerBuilder $container): void
     9|     {
    10|         parent::build($container);
    11|         $container->addCompilerPass(new SerializerPass(), \Symfony\Component\DependencyInjection\Compiler\PassConfig::TYPE_BEFORE_OPTIMIZATION, 0);
    12|     }
    13| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Model/ClientModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-136 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Model;
     3| use Doctrine\ORM\EntityManager;
     4| use Mautic\ApiBundle\ApiEvents;
     5| use Mautic\ApiBundle\Entity\oAuth2\Client;
     6| use Mautic\ApiBundle\Event\ClientEvent;
     7| use Mautic\ApiBundle\Form\Type\ClientType;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\UserHelper;
    10| use Mautic\CoreBundle\Model\FormModel;
    11| use Mautic\CoreBundle\Model\GlobalSearchInterface;
    12| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    13| use Mautic\CoreBundle\Translation\Translator;
    14| use Mautic\UserBundle\Entity\User;
    15| use Psr\Log\LoggerInterface;
    16| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    17| use Symfony\Component\Form\FormFactoryInterface;
    18| use Symfony\Component\HttpFoundation\RequestStack;
    19| use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
    20| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    21| use Symfony\Contracts\EventDispatcher\Event;
    22| /**
    23|  * @extends FormModel<Client>
    24|  */
    25| class ClientModel extends FormModel implements GlobalSearchInterface
    26| {
    27|     /**
    28|      * @var string
    29|      */
    30|     public const API_MODE_OAUTH2 = 'oauth2';
    31|     private ?string $apiMode = null;
    32|     private const DEFAULT_API_MODE = 'oauth2';
    33|     public function __construct(
    34|         private RequestStack $requestStack,
    35|         EntityManager $em,
    36|         CorePermissions $security,
    37|         EventDispatcherInterface $dispatcher,
    38|         UrlGeneratorInterface $router,
    39|         Translator $translator,
    40|         UserHelper $userHelper,
    41|         LoggerInterface $mauticLogger,
    42|         CoreParametersHelper $coreParametersHelper,
    43|     ) {
    44|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    45|     }
    46|     private function getApiMode(): string
    47|     {
    48|         if (null !== $this->apiMode) {
    49|             return $this->apiMode;
    50|         }
    51|         if (null !== $request = $this->requestStack->getCurrentRequest()) {
    52|             return $request->get('api_mode', $request->getSession()->get('mautic.client.filter.api_mode', self::DEFAULT_API_MODE));
    53|         }
    54|         return self::DEFAULT_API_MODE;
    55|     }
    56|     public function setApiMode($apiMode): void
    57|     {
    58|         $this->apiMode = $apiMode;
    59|     }
    60|     public function getRepository(): \Mautic\ApiBundle\Entity\oAuth2\ClientRepository
    61|     {
    62|         return $this->em->getRepository(Client::class);
    63|     }
    64|     public function getPermissionBase(): string
    65|     {
    66|         return 'api:clients';
    67|     }
    68|     /**
    69|      * @throws MethodNotAllowedHttpException
    70|      */
    71|     public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
    72|     {
    73|         if (!$entity instanceof Client) {
    74|             throw new MethodNotAllowedHttpException(['Client']);
    75|         }
    76|         $params = (!empty($action)) ? ['action' => $action] : [];
    77|         return $formFactory->create(ClientType::class, $entity, $params);
    78|     }
    79|     public function getEntity($id = null): ?Client
    80|     {
    81|         if (null === $id) {
    82|             return 'oauth2' === $this->getApiMode() ? new Client() : null;
    83|         }
    84|         return parent::getEntity($id);
    85|     }
    86|     /**
    87|      * @throws MethodNotAllowedHttpException
    88|      */
    89|     protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
    90|     {
    91|         if (!$entity instanceof Client) {
    92|             throw new MethodNotAllowedHttpException(['Client']);
    93|         }
    94|         switch ($action) {
    95|             case 'post_save':
    96|                 $name = ApiEvents::CLIENT_POST_SAVE;
    97|                 break;
    98|             case 'post_delete':
    99|                 $name = ApiEvents::CLIENT_POST_DELETE;
   100|                 break;
   101|             default:
   102|                 return null;
   103|         }
   104|         if ($this->dispatcher->hasListeners($name)) {
   105|             if (empty($event)) {
   106|                 $event = new ClientEvent($entity, $isNew);
   107|                 $event->setEntityManager($this->em);
   108|             }
   109|             $this->dispatcher->dispatch($event, $name);
   110|             return $event;
   111|         }
   112|         return null;
   113|     }
   114|     /**
   115|      * @return array
   116|      */
   117|     public function getUserClients(User $user)
   118|     {
   119|         return $this->getRepository()->getUserClients($user);
   120|     }
   121|     /**
   122|      * @throws MethodNotAllowedHttpException
   123|      */
   124|     public function revokeAccess($entity): void
   125|     {
   126|         if (!$entity instanceof Client) {
   127|             throw new MethodNotAllowedHttpException(['Client']);
   128|         }
   129|         if ('oauth2' === $this->getApiMode()) {
   130|             $entity->removeUser($this->userHelper->getUser());
   131|             $this->saveEntity($entity);
   132|         } else {
   133|             $this->getRepository()->deleteAccessTokens($entity, $this->userHelper->getUser());
   134|         }
   135|     }
   136| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Serializer/Driver/ApiMetadataDriver.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-256 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Serializer\Driver;
     3| use JMS\Serializer\Metadata\ClassMetadata;
     4| use JMS\Serializer\Metadata\PropertyMetadata;
     5| use Metadata\ClassMetadata as BaseClassMetadata;
     6| use Metadata\Driver\DriverInterface;
     7| class ApiMetadataDriver implements DriverInterface
     8| {
     9|     private ?ClassMetadata $metadata = null;
    10|     /**
    11|      * @var PropertyMetadata[]
    12|      */
    13|     private array $properties = [];
    14|     private string $groupPrefix = '';
    15|     private string $defaultVersion = '1.0';
    16|     private ?string $currentPropertyName = null;
    17|     /**
    18|      * @throws \ReflectionException
    19|      */
    20|     public function loadMetadataForClass(\ReflectionClass $class): ?BaseClassMetadata
    21|     {
    22|         if ($class->hasMethod('loadApiMetadata')) {
    23|             $this->metadata = new ClassMetadata($class->getName());
    24|             $class->getMethod('loadApiMetadata')->invoke(null, $this);
    25|             $metadata = $this->metadata;
    26|             $this->resetDefaults();
    27|             return $metadata;
    28|         } else {
    29|             return new ClassMetadata($class->getName());
    30|         }
    31|     }
    32|     private function resetDefaults(): void
    33|     {
    34|         $this->metadata       = null;
    35|         $this->properties     = [];
    36|         $this->defaultVersion = '1.0';
    37|         $this->groupPrefix    = '';
    38|     }
    39|     /**
    40|      * Set the root (base key).
    41|      *
    42|      * @return $this
    43|      */
    44|     public function setRoot($root)
    45|     {
    46|         $this->metadata->xmlRootName = $root;
    47|         return $this;
    48|     }
    49|     /**
    50|      * Set prefix for the List and Details groups.
    51|      *
    52|      * @return $this
    53|      */
    54|     public function setGroupPrefix($name)
    55|     {
    56|         $this->groupPrefix = $name;
    57|         return $this;
    58|     }
    59|     /**
    60|      * Set the default version for the properties if different than 1.0.
    61|      *
    62|      * @return $this
    63|      */
    64|     public function setDefaultVersion(string $version)
    65|     {
    66|         $this->defaultVersion = $version;
    67|         return $this;
    68|     }
    69|     /**
    70|      * Create a new property.
    71|      *
    72|      * @return $this
    73|      */
    74|     public function createProperty($name)
    75|     {
    76|         if (!isset($this->properties[$name])) {
    77|             $this->properties[$name] = new PropertyMetadata($this->metadata->name, $name);
    78|         }
    79|         $this->currentPropertyName = $name;
    80|         return $this;
    81|     }
    82|     /**
    83|      * Add property and set default version and Details group.
    84|      *
    85|      * @param bool $useGetter
    86|      *
    87|      * @return $this
    88|      */
    89|     public function addProperty($name, $serializedName = null, $useGetter = false)
    90|     {
    91|         if (empty($name)) {
    92|             return $this;
    93|         }
    94|         $this->createProperty($name);
    95|         if ($useGetter && !$this->properties[$name]->getter) {
    96|             $this->properties[$name]->getter = 'get'.ucfirst($name);
    97|         }
    98|         $this->properties[$name]->serializedName = $serializedName ?? $name;
    99|         if ($this->defaultVersion) {
   100|             $this->setSinceVersion($this->defaultVersion);
   101|         }
   102|         $this->addGroup($this->groupPrefix.'Details');
   103|         return $this;
   104|     }
   105|     /**
   106|      * Create properties.
   107|      *
   108|      * @param bool|false $addToListGroup
   109|      * @param bool|false $useGetter
   110|      *
   111|      * @return $this
   112|      */
   113|     public function addProperties(array $properties, $addToListGroup = false, $useGetter = false)
   114|     {
   115|         foreach ($properties as $prop) {
   116|             if (!empty($prop)) {
   117|                 $serializedName = null;
   118|                 if (is_array($prop)) {
   119|                     [$prop, $serializedName] = $prop;
   120|                 }
   121|                 $this->addProperty($prop, $serializedName, $useGetter);
   122|                 if ($addToListGroup) {
   123|                     $this->inListGroup();
   124|                 }
   125|             }
   126|         }
   127|         return $this;
   128|     }
   129|     /**
   130|      * Create properties and add to the List group.
   131|      *
   132|      * @return $this
   133|      */
   134|     public function addListProperties(array $properties)
   135|     {
   136|         $this->addProperties($properties, true);
   137|         return $this;
   138|     }
   139|     /**
   140|      * @return $this
   141|      */
   142|     public function setSinceVersion($version, $property = null)
   143|     {
   144|         if (null === $property) {
   145|             $property = $this->getCurrentPropertyName();
   146|         }
   147|         $this->properties[$property]->sinceVersion = $version;
   148|         return $this;
   149|     }
   150|     /**
   151|      * @return $this
   152|      */
   153|     public function setUntilVersion($version, $property = null)
   154|     {
   155|         if (null === $property) {
   156|             $property = $this->getCurrentPropertyName();
   157|         }
   158|         $this->properties[$property]->untilVersion = $version;
   159|         return $this;
   160|     }
   161|     /**
   162|      * @return $this
   163|      */
   164|     public function setSerializedName($name, $property = null)
   165|     {
   166|         if (null === $property) {
   167|             $property = $this->getCurrentPropertyName();
   168|         }
   169|         $this->properties[$property]->serializedName = $name;
   170|         return $this;
   171|     }
   172|     /**
   173|      * Set the groups a property belongs to.
   174|      *
   175|      * @return $this
   176|      */
   177|     public function setGroups($groups, $property = null)
   178|     {
   179|         if (!is_array($groups)) {
   180|             $groups = [$groups];
   181|         }
   182|         if (null === $property) {
   183|             $property = $this->getCurrentPropertyName();
   184|         }
   185|         $this->properties[$property]->groups = $groups;
   186|         return $this;
   187|     }
   188|     /**
   189|      * Add a group the property belongs to.
   190|      *
   191|      * @param mixed $property
   192|      *
   193|      * @return $this
   194|      */
   195|     public function addGroup($group, $property = null)
   196|     {
   197|         if (true === $property) {
   198|             foreach ($this->properties as $prop => $metadata) {
   199|                 $this->addGroup($group, $prop);
   200|             }
   201|         } else {
   202|             if (null === $property) {
   203|                 $property = $this->getCurrentPropertyName();
   204|             }
   205|             $this->properties[$property]->groups[] = $group;
   206|         }
   207|         return $this;
   208|     }
   209|     /**
   210|      * Add property to the List group.
   211|      *
   212|      * @return $this
   213|      */
   214|     public function inListGroup()
   215|     {
   216|         $this->properties[$this->currentPropertyName]->groups[] =
   217|             $this->groupPrefix.'List';
   218|         return $this;
   219|     }
   220|     /**
   221|      * Set max depth for the property if an association.
   222|      *
   223|      * @return $this
   224|      */
   225|     public function setMaxDepth($depth, $property = null)
   226|     {
   227|         if (null === $property) {
   228|             $property = $this->getCurrentPropertyName();
   229|         }
   230|         $this->properties[$property]->maxDepth = (int) $depth;
   231|         return $this;
   232|     }
   233|     /**
   234|      * Push the properties into ClassMetadata.
   235|      */
   236|     public function build(): void
   237|     {
   238|         foreach ($this->properties as $prop) {
   239|             $this->metadata->addPropertyMetadata($prop);
   240|         }
   241|         $this->currentPropertyName = null;
   242|         $this->properties          = [];
   243|     }
   244|     /**
   245|      * @return string
   246|      *
   247|      * @throws \Exception
   248|      */
   249|     protected function getCurrentPropertyName()
   250|     {
   251|         if (empty($this->currentPropertyName)) {
   252|             throw new \Exception('Current property is not set');
   253|         }
   254|         return $this->currentPropertyName;
   255|     }
   256| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Serializer/Exclusion/FieldExclusionStrategy.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Serializer\Exclusion;
     3| use JMS\Serializer\Context;
     4| use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
     5| use JMS\Serializer\Metadata\ClassMetadata;
     6| use JMS\Serializer\Metadata\PropertyMetadata;
     7| /**
     8|  * Exclude specific fields at a specific level.
     9|  */
    10| class FieldExclusionStrategy implements ExclusionStrategyInterface
    11| {
    12|     private int $level;
    13|     /**
    14|      * @param int         $level
    15|      * @param string|null $path
    16|      */
    17|     public function __construct(
    18|         private array $fields,
    19|         $level = 3,
    20|         private $path = null,
    21|     ) {
    22|         $this->level  = (int) $level;
    23|     }
    24|     public function shouldSkipClass(ClassMetadata $metadata, Context $navigatorContext): bool
    25|     {
    26|         return false;
    27|     }
    28|     public function shouldSkipProperty(PropertyMetadata $property, Context $navigatorContext): bool
    29|     {
    30|         if ($this->path) {
    31|             $path = implode('.', $navigatorContext->getCurrentPath());
    32|             if ($path !== $this->path) {
    33|                 return false;
    34|             }
    35|         }
    36|         $name = $property->serializedName ?: $property->name;
    37|         if (!in_array($name, $this->fields)) {
    38|             return false;
    39|         }
    40|         if ($navigatorContext->getDepth() <= $this->level) {
    41|             return false;
    42|         }
    43|         return true;
    44|     }
    45| }


# ====================================================================
# FILE: app/bundles/ApiBundle/Serializer/Exclusion/FieldInclusionStrategy.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\ApiBundle\Serializer\Exclusion;
     3| use JMS\Serializer\Context;
     4| use JMS\Serializer\Exclusion\ExclusionStrategyInterface;
     5| use JMS\Serializer\Metadata\ClassMetadata;
     6| use JMS\Serializer\Metadata\PropertyMetadata;
     7| /**
     8|  * Include specific fields at a specific level.
     9|  */
    10| class FieldInclusionStrategy implements ExclusionStrategyInterface
    11| {
    12|     private int $level;
    13|     /**
    14|      * @param int $level
    15|      */
    16|     public function __construct(
    17|         private array $fields,
    18|         $level = 3,
    19|         private $path = null,
    20|     ) {
    21|         $this->level  = (int) $level;
    22|     }
    23|     public function shouldSkipClass(ClassMetadata $metadata, Context $navigatorContext): bool
    24|     {
    25|         return false;
    26|     }
    27|     public function shouldSkipProperty(PropertyMetadata $property, Context $navigatorContext): bool
    28|     {
    29|         if ($this->path) {
    30|             $path = implode('.', $navigatorContext->getCurrentPath());
    31|             if ($path !== $this->path) {
    32|                 return false;
    33|             }
    34|         }
    35|         $name = $property->serializedName ?: $property->name;
    36|         if (in_array($name, $this->fields)) {
    37|             return false;
    38|         }
    39|         if ($navigatorContext->getDepth() <= $this->level) {
    40|             return false;
    41|         }
    42|         return true;
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Config/config.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-108 ---
     1| <?php
     2| return [
     3|     'routes' => [
     4|         'main' => [
     5|             'mautic_asset_index' => [
     6|                 'path'       => '/assets/{page}',
     7|                 'controller' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
     8|             ],
     9|             'mautic_asset_remote' => [
    10|                 'path'       => '/assets/remote',
    11|                 'controller' => 'Mautic\AssetBundle\Controller\AssetController::remoteAction',
    12|             ],
    13|             'mautic_asset_action' => [
    14|                 'path'       => '/assets/{objectAction}/{objectId}',
    15|                 'controller' => 'Mautic\AssetBundle\Controller\AssetController::executeAction',
    16|             ],
    17|         ],
    18|         'api' => [
    19|             'mautic_api_assetsstandard' => [
    20|                 'standard_entity' => true,
    21|                 'name'            => 'assets',
    22|                 'path'            => '/assets',
    23|                 'controller'      => Mautic\AssetBundle\Controller\Api\AssetApiController::class,
    24|             ],
    25|         ],
    26|         'public' => [
    27|             'mautic_asset_download' => [
    28|                 'path'       => '/asset/{slug}',
    29|                 'controller' => 'Mautic\AssetBundle\Controller\PublicController::downloadAction',
    30|                 'defaults'   => [
    31|                     'slug' => '',
    32|                 ],
    33|             ],
    34|         ],
    35|     ],
    36|     'menu' => [
    37|         'main' => [
    38|             'items' => [
    39|                 'mautic.asset.assets' => [
    40|                     'route'    => 'mautic_asset_index',
    41|                     'access'   => ['asset:assets:viewown', 'asset:assets:viewother'],
    42|                     'parent'   => 'mautic.core.components',
    43|                     'priority' => 300,
    44|                 ],
    45|             ],
    46|         ],
    47|     ],
    48|     'categories' => [
    49|         'asset' => [
    50|             'class' => Mautic\AssetBundle\Entity\Asset::class,
    51|         ],
    52|     ],
    53|     'services' => [
    54|         'permissions' => [
    55|             'mautic.asset.permissions' => [
    56|                 'class'     => Mautic\AssetBundle\Security\Permissions\AssetPermissions::class,
    57|                 'arguments' => [
    58|                     'mautic.helper.core_parameters',
    59|                 ],
    60|             ],
    61|         ],
    62|         'others' => [
    63|             'mautic.asset.upload.error.handler' => [
    64|                 'class'     => Mautic\AssetBundle\ErrorHandler\DropzoneErrorHandler::class,
    65|             ],
    66|             'oneup_uploader.controller.dropzone.class' => [
    67|                 'class'     => Mautic\AssetBundle\Controller\UploadController::class,
    68|             ],
    69|         ],
    70|         'fixtures' => [
    71|             'mautic.asset.fixture.asset' => [
    72|                 'class'     => Mautic\AssetBundle\DataFixtures\ORM\LoadAssetData::class,
    73|                 'tag'       => Doctrine\Bundle\FixturesBundle\DependencyInjection\CompilerPass\FixturesCompilerPass::FIXTURE_TAG,
    74|             ],
    75|         ],
    76|     ],
    77|     'parameters' => [
    78|         'upload_dir'          => '%mautic.application_dir%/media/files',
    79|         'max_size'            => '6',
    80|         'allowed_extensions'  => ['csv', 'doc', 'docx', 'epub', 'gif', 'jpg', 'jpeg', 'mpg', 'mpeg', 'mp3', 'odt', 'odp', 'ods', 'pdf', 'png', 'ppt', 'pptx', 'tif', 'tiff', 'txt', 'xls', 'xlsx', 'wav'],
    81|         'streamed_extensions' => ['gif', 'jpg', 'jpeg', 'mpg', 'mpeg', 'mp3', 'pdf', 'png', 'wav'],
    82|         'allowed_mimetypes'   => [
    83|             'csv'  => 'text/csv',
    84|             'doc'  => 'application/msword',
    85|             'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    86|             'epub' => 'application/epub+zip',
    87|             'gif'  => 'image/gif',
    88|             'jpg'  => 'image/jpeg',
    89|             'jpeg' => 'image/jpeg',
    90|             'mpg'  => 'video/mpeg',
    91|             'mpeg' => 'video/mpeg',
    92|             'mp3'  => 'audio/mpeg',
    93|             'odt'  => 'application/vnd.oasis.opendocument.text',
    94|             'odp'  => 'application/vnd.oasis.opendocument.presentation',
    95|             'ods'  => 'application/vnd.oasis.opendocument.spreadsheet',
    96|             'pdf'  => 'application/pdf',
    97|             'png'  => 'image/png',
    98|             'ppt'  => 'application/vnd.ms-powerpoint',
    99|             'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
   100|             'tif'  => 'image/tiff',
   101|             'tiff' => 'image/tiff',
   102|             'txt'  => 'text/plain',
   103|             'xls'  => 'application/vnd.ms-excel',
   104|             'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
   105|             'wav'  => 'audio/wav',
   106|         ],
   107|     ],
   108| ];


# ====================================================================
# FILE: app/bundles/AssetBundle/Controller/AjaxController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Controller;
     3| use Gaufrette\Filesystem;
     4| use Mautic\AssetBundle\AssetEvents;
     5| use Mautic\AssetBundle\Event\RemoteAssetBrowseEvent;
     6| use Mautic\AssetBundle\Model\AssetModel;
     7| use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
     8| use Mautic\CoreBundle\Helper\InputHelper;
     9| use Mautic\PluginBundle\Helper\IntegrationHelper;
    10| use Symfony\Component\HttpFoundation\Request;
    11| class AjaxController extends CommonAjaxController
    12| {
    13|     public function categoryListAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
    14|     {
    15|         $assetModel = $this->getModel('asset');
    16|         \assert($assetModel instanceof AssetModel);
    17|         $filter     = InputHelper::clean($request->query->get('filter'));
    18|         $results    = $assetModel->getLookupResults('category', $filter, 10);
    19|         $dataArray  = [];
    20|         foreach ($results as $r) {
    21|             $dataArray[] = [
    22|                 'label' => $r['title']." ({$r['id']})",
    23|                 'value' => $r['id'],
    24|             ];
    25|         }
    26|         return $this->sendJsonResponse($dataArray);
    27|     }
    28|     /**
    29|      * @throws \Exception
    30|      */
    31|     public function fetchRemoteFilesAction(Request $request, IntegrationHelper $integrationHelper): \Symfony\Component\HttpFoundation\JsonResponse
    32|     {
    33|         $provider   = InputHelper::string($request->request->get('provider'));
    34|         $path       = InputHelper::string($request->request->get('path', ''));
    35|         $dispatcher = $this->dispatcher;
    36|         $name       = AssetEvents::ASSET_ON_REMOTE_BROWSE;
    37|         if (!$dispatcher->hasListeners($name)) {
    38|             return $this->sendJsonResponse(['success' => 0]);
    39|         }
    40|         /** @var \Mautic\PluginBundle\Integration\AbstractIntegration $integration */
    41|         $integration = $integrationHelper->getIntegrationObject($provider);
    42|         $event = new RemoteAssetBrowseEvent($integration);
    43|         $dispatcher->dispatch($event, $name);
    44|         if (!$adapter = $event->getAdapter()) {
    45|             return $this->sendJsonResponse(['success' => 0]);
    46|         }
    47|         $connector = new Filesystem($adapter);
    48|         $output = $this->renderView(
    49|             '@MauticAsset/Remote/list.html.twig',
    50|             [
    51|                 'connector'   => $connector,
    52|                 'integration' => $integration,
    53|                 'items'       => $connector->listKeys($path),
    54|             ]
    55|         );
    56|         return $this->sendJsonResponse(['success' => 1, 'output' => $output]);
    57|     }
    58| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Controller/Api/AssetApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Controller\CommonApiController;
     5| use Mautic\ApiBundle\Helper\EntityResultHelper;
     6| use Mautic\AssetBundle\Entity\Asset;
     7| use Mautic\AssetBundle\Model\AssetModel;
     8| use Mautic\CoreBundle\Factory\ModelFactory;
     9| use Mautic\CoreBundle\Helper\AppVersion;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    12| use Mautic\CoreBundle\Translation\Translator;
    13| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    14| use Symfony\Component\Form\FormFactoryInterface;
    15| use Symfony\Component\HttpFoundation\Request;
    16| use Symfony\Component\HttpFoundation\RequestStack;
    17| use Symfony\Component\HttpFoundation\Response;
    18| use Symfony\Component\Routing\RouterInterface;
    19| /**
    20|  * @extends CommonApiController<Asset>
    21|  */
    22| class AssetApiController extends CommonApiController
    23| {
    24|     /**
    25|      * @var AssetModel|null
    26|      */
    27|     protected $model;
    28|     public function __construct(
    29|         CorePermissions $security,
    30|         Translator $translator,
    31|         EntityResultHelper $entityResultHelper,
    32|         RouterInterface $router,
    33|         FormFactoryInterface $formFactory,
    34|         AppVersion $appVersion,
    35|         RequestStack $requestStack,
    36|         private CoreParametersHelper $parametersHelper,
    37|         ManagerRegistry $doctrine,
    38|         ModelFactory $modelFactory,
    39|         EventDispatcherInterface $dispatcher,
    40|         CoreParametersHelper $coreParametersHelper,
    41|     ) {
    42|         $assetModel = $modelFactory->getModel('asset');
    43|         \assert($assetModel instanceof AssetModel);
    44|         $this->model            = $assetModel;
    45|         $this->entityClass      = Asset::class;
    46|         $this->entityNameOne    = 'asset';
    47|         $this->entityNameMulti  = 'assets';
    48|         $this->serializerGroups = ['assetDetails', 'categoryList', 'publishDetails'];
    49|         parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    50|     }
    51|     /**
    52|      * Gives child controllers opportunity to analyze and do whatever to an entity before going through serializer.
    53|      */
    54|     protected function preSerializeEntity(object $entity, string $action = 'view'): void
    55|     {
    56|         $entity->setDownloadUrl(
    57|             $this->model->generateUrl($entity, true)
    58|         );
    59|     }
    60|     /**
    61|      * Convert posted parameters into what the form needs in order to successfully bind.
    62|      *
    63|      * @return mixed
    64|      */
    65|     protected function prepareParametersForBinding(Request $request, $parameters, $entity, $action)
    66|     {
    67|         $assetDir = $this->parametersHelper->get('upload_dir');
    68|         $entity->setUploadDir($assetDir);
    69|         if (isset($parameters['file'])) {
    70|             if ('local' === $parameters['storageLocation']) {
    71|                 $entity->setPath($parameters['file']);
    72|                 $entity->setFileInfoFromFile();
    73|                 if (null === $entity->loadFile()) {
    74|                     return $this->returnError('File '.$parameters['file'].' was not found in the asset directory.', Response::HTTP_BAD_REQUEST);
    75|                 }
    76|             } elseif ('remote' === $parameters['storageLocation']) {
    77|                 $parameters['remotePath'] = $parameters['file'];
    78|                 $entity->setTitle($parameters['title']);
    79|                 $entity->setStorageLocation('remote');
    80|                 $entity->setRemotePath($parameters['remotePath']);
    81|                 $entity->preUpload();
    82|                 $entity->upload();
    83|             }
    84|             unset($parameters['file']);
    85|         } elseif ('new' === $action) {
    86|             return $this->returnError('File of the asset is required.', Response::HTTP_BAD_REQUEST);
    87|         }
    88|         return $parameters;
    89|     }
    90| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Controller/AssetController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-624 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Controller;
     3| use Mautic\AssetBundle\Model\AssetModel;
     4| use Mautic\CoreBundle\Controller\FormController;
     5| use Mautic\CoreBundle\Form\Type\DateRangeType;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| use Mautic\CoreBundle\Helper\FileHelper;
     8| use Mautic\CoreBundle\Model\AuditLogModel;
     9| use Mautic\PluginBundle\Helper\IntegrationHelper;
    10| use Oneup\UploaderBundle\Templating\Helper\UploaderHelper;
    11| use Symfony\Component\HttpFoundation\JsonResponse;
    12| use Symfony\Component\HttpFoundation\Request;
    13| use Symfony\Component\HttpFoundation\Response;
    14| class AssetController extends FormController
    15| {
    16|     /**
    17|      * @return JsonResponse|Response
    18|      */
    19|     public function indexAction(Request $request, CoreParametersHelper $parametersHelper, AssetModel $assetModel, int $page = 1)
    20|     {
    21|         $permissions = $this->security->isGranted([
    22|             'asset:assets:viewown',
    23|             'asset:assets:viewother',
    24|             'asset:assets:create',
    25|             'asset:assets:editown',
    26|             'asset:assets:editother',
    27|             'asset:assets:deleteown',
    28|             'asset:assets:deleteother',
    29|             'asset:assets:publishown',
    30|             'asset:assets:publishother',
    31|         ], 'RETURN_ARRAY');
    32|         if (!$permissions['asset:assets:viewown'] && !$permissions['asset:assets:viewother']) {
    33|             return $this->accessDenied();
    34|         }
    35|         $this->setListFilters();
    36|         $limit = $request->getSession()->get('mautic.asset.limit', $parametersHelper->get('default_assetlimit'));
    37|         $start = (1 === $page) ? 0 : (($page - 1) * $limit);
    38|         if ($start < 0) {
    39|             $start = 0;
    40|         }
    41|         $search = $request->get('search', $request->getSession()->get('mautic.asset.filter', ''));
    42|         $request->getSession()->set('mautic.asset.filter', $search);
    43|         $filter = ['string' => $search, 'force' => []];
    44|         if (!$permissions['asset:assets:viewother']) {
    45|             $filter['force'][] =
    46|                 ['column' => 'a.createdBy', 'expr' => 'eq', 'value' => $this->user->getId()];
    47|         }
    48|         $orderBy    = $request->getSession()->get('mautic.asset.orderby', 'a.dateModified');
    49|         $orderByDir = $request->getSession()->get('mautic.asset.orderbydir', $this->getDefaultOrderDirection());
    50|         $assets = $assetModel->getEntities(
    51|             [
    52|                 'start'      => $start,
    53|                 'limit'      => $limit,
    54|                 'filter'     => $filter,
    55|                 'orderBy'    => $orderBy,
    56|                 'orderByDir' => $orderByDir,
    57|             ]
    58|         );
    59|         $count = count($assets);
    60|         if ($count && $count < ($start + 1)) {
    61|             if (1 === $count) {
    62|                 $lastPage = 1;
    63|             } else {
    64|                 $lastPage = (ceil($count / $limit)) ?: 1;
    65|             }
    66|             $request->getSession()->set('mautic.asset.asset', $lastPage);
    67|             $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $lastPage]);
    68|             return $this->postActionRedirect([
    69|                 'returnUrl'       => $returnUrl,
    70|                 'viewParameters'  => ['asset' => $lastPage],
    71|                 'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
    72|                 'passthroughVars' => [
    73|                     'activeLink'    => '#mautic_asset_index',
    74|                     'mauticContent' => 'asset',
    75|                 ],
    76|             ]);
    77|         }
    78|         $request->getSession()->set('mautic.asset.page', $page);
    79|         $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
    80|         $categories = $assetModel->getLookupResults('category', '', 0);
    81|         return $this->delegateView([
    82|             'viewParameters' => [
    83|                 'searchValue' => $search,
    84|                 'items'       => $assets,
    85|                 'categories'  => $categories,
    86|                 'limit'       => $limit,
    87|                 'permissions' => $permissions,
    88|                 'model'       => $assetModel,
    89|                 'tmpl'        => $tmpl,
    90|                 'page'        => $page,
    91|                 'security'    => $this->security,
    92|             ],
    93|             'contentTemplate' => '@MauticAsset/Asset/list.html.twig',
    94|             'passthroughVars' => [
    95|                 'activeLink'    => '#mautic_asset_index',
    96|                 'mauticContent' => 'asset',
    97|                 'route'         => $this->generateUrl('mautic_asset_index', ['page' => $page]),
    98|             ],
    99|         ]);
   100|     }
   101|     /**
   102|      * Loads a specific form into the detailed panel.
   103|      *
   104|      * @param int $objectId
   105|      *
   106|      * @return JsonResponse|Response
   107|      */
   108|     public function viewAction(Request $request, AssetModel $model, $objectId)
   109|     {
   110|         $activeAsset = $model->getEntity($objectId);
   111|         $page = $request->getSession()->get('mautic.asset.page', 1);
   112|         $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'details') : 'details';
   113|         $dateRangeValues = $request->get('daterange', []);
   114|         $action          = $this->generateUrl('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $objectId]);
   115|         $dateRangeForm   = $this->formFactory->create(DateRangeType::class, $dateRangeValues, ['action' => $action]);
   116|         if (null === $activeAsset) {
   117|             $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
   118|             return $this->postActionRedirect([
   119|                 'returnUrl'       => $returnUrl,
   120|                 'viewParameters'  => ['page' => $page],
   121|                 'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
   122|                 'passthroughVars' => [
   123|                     'activeLink'    => '#mautic_asset_index',
   124|                     'mauticContent' => 'asset',
   125|                 ],
   126|                 'flashes' => [
   127|                     [
   128|                         'type'    => 'error',
   129|                         'msg'     => 'mautic.asset.asset.error.notfound',
   130|                         'msgVars' => ['%id%' => $objectId],
   131|                     ],
   132|                 ],
   133|             ]);
   134|         } elseif (!$this->security->hasEntityAccess('asset:assets:viewown', 'asset:assets:viewother', $activeAsset->getCreatedBy())) {
   135|             return $this->accessDenied();
   136|         }
   137|         $auditLogModel = $this->getModel('core.auditlog');
   138|         \assert($auditLogModel instanceof AuditLogModel);
   139|         $logs          = $auditLogModel->getLogForObject('asset', $activeAsset->getId(), $activeAsset->getDateAdded());
   140|         return $this->delegateView([
   141|             'returnUrl'      => $action,
   142|             'viewParameters' => [
   143|                 'activeAsset' => $activeAsset,
   144|                 'tmpl'        => $tmpl,
   145|                 'permissions' => $this->security->isGranted([
   146|                     'asset:assets:viewown',
   147|                     'asset:assets:viewother',
   148|                     'asset:assets:create',
   149|                     'asset:assets:editown',
   150|                     'asset:assets:editother',
   151|                     'asset:assets:deleteown',
   152|                     'asset:assets:deleteother',
   153|                     'asset:assets:publishown',
   154|                     'asset:assets:publishother',
   155|                 ], 'RETURN_ARRAY'),
   156|                 'stats' => [
   157|                     'downloads' => [
   158|                         'total'     => $activeAsset->getDownloadCount(),
   159|                         'unique'    => $activeAsset->getUniqueDownloadCount(),
   160|                         'timeStats' => $model->getDownloadsLineChartData(
   161|                             null,
   162|                             new \DateTime($dateRangeForm->get('date_from')->getData()),
   163|                             new \DateTime($dateRangeForm->get('date_to')->getData()),
   164|                             null,
   165|                             ['asset_id' => $activeAsset->getId()]
   166|                         ),
   167|                     ],
   168|                 ],
   169|                 'security'         => $this->security,
   170|                 'assetDownloadUrl' => $model->generateUrl($activeAsset, true),
   171|                 'logs'             => $logs,
   172|                 'dateRangeForm'    => $dateRangeForm->createView(),
   173|             ],
   174|             'contentTemplate' => '@MauticAsset/Asset/'.$tmpl.'.html.twig',
   175|             'passthroughVars' => [
   176|                 'activeLink'    => '#mautic_asset_index',
   177|                 'mauticContent' => 'asset',
   178|             ],
   179|         ]);
   180|     }
   181|     /**
   182|      * Show a preview of the file.
   183|      *
   184|      * @param int $objectId
   185|      *
   186|      * @return JsonResponse|Response
   187|      */
   188|     public function previewAction(Request $request, AssetModel $model, $objectId)
   189|     {
   190|         $activeAsset = $model->getEntity($objectId);
   191|         if (null === $activeAsset || !$this->security->hasEntityAccess('asset:assets:viewown', 'asset:assets:viewother', $activeAsset->getCreatedBy())) {
   192|             return $this->modalAccessDenied();
   193|         }
   194|         $download = $request->query->get('download', 0);
   195|         $defaultStream = in_array($activeAsset->getExtension(), $this->coreParametersHelper->get('streamed_extensions')) ? '1' : null;
   196|         $stream        = $request->query->get('stream', $defaultStream);
   197|         if ('1' === $download || '1' === $stream) {
   198|             try {
   199|                 $activeAsset->setUploadDir($this->coreParametersHelper->get('upload_dir'));
   200|                 $contents = $activeAsset->getFileContents();
   201|             } catch (\Exception) {
   202|                 return $this->notFound();
   203|             }
   204|             $response = new Response();
   205|             $response->headers->set('Content-Type', $activeAsset->getFileMimeType());
   206|             if ('1' === $download) {
   207|                 $response->headers->set('Content-Disposition', 'attachment;filename="'.$activeAsset->getOriginalFileName());
   208|             }
   209|             $response->setContent($contents);
   210|             return $response;
   211|         }
   212|         return $this->delegateView([
   213|             'viewParameters' => [
   214|                 'activeAsset'      => $activeAsset,
   215|                 'assetDownloadUrl' => $model->generateUrl($activeAsset),
   216|             ],
   217|             'contentTemplate' => '@MauticAsset/Asset/preview.html.twig',
   218|             'passthroughVars' => [
   219|                 'route' => false,
   220|             ],
   221|         ]);
   222|     }
   223|     /**
   224|      * Generates new form and processes post data.
   225|      *
   226|      * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
   227|      */
   228|     public function newAction(Request $request, CoreParametersHelper $parametersHelper, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $entity = null)
   229|     {
   230|         if (null == $entity) {
   231|             $entity = $model->getEntity();
   232|         }
   233|         $entity->setMaxSize(FileHelper::convertMegabytesToBytes($this->coreParametersHelper->get('max_size')));
   234|         $method  = $request->getMethod();
   235|         $session = $request->getSession();
   236|         if (!$this->security->isGranted('asset:assets:create')) {
   237|             return $this->accessDenied();
   238|         }
   239|         $maxSize    = $model->getMaxUploadSize();
   240|         $extensions = '.'.implode(', .', $this->coreParametersHelper->get('allowed_extensions'));
   241|         $maxSizeError = $this->translator->trans('mautic.asset.asset.error.file.size', [
   242|             '%fileSize%' => '{{filesize}}',
   243|             '%maxSize%'  => '{{maxFilesize}}',
   244|         ], 'validators');
   245|         $extensionError = $this->translator->trans('mautic.asset.asset.error.file.extension.js', [
   246|             '%extensions%' => $extensions,
   247|         ], 'validators');
   248|         $asset  = $request->request->all()['asset'] ?? [];
   249|         $tempId = 'POST' === $method ? ($asset['tempId'] ?? '') : uniqid('tmp_');
   250|         $entity->setTempId($tempId);
   251|         $page   = $session->get('mautic.asset.page', 1);
   252|         $action = $this->generateUrl('mautic_asset_action', ['objectAction' => 'new']);
   253|         $uploadEndpoint = $uploaderHelper->endpoint('asset');
   254|         $form = $model->createForm($entity, $this->formFactory, $action);
   255|         if ('POST' == $method) {
   256|             $valid = false;
   257|             if (!$cancelled = $this->isFormCancelled($form)) {
   258|                 if ($valid = $this->isFormValid($form)) {
   259|                     $entity->setUploadDir($parametersHelper->get('upload_dir'));
   260|                     $entity->preUpload();
   261|                     $entity->upload();
   262|                     $entity->setDateModified(new \DateTime());
   263|                     $model->saveEntity($entity);
   264|                     $request->files->remove('asset');
   265|                     $this->addFlashMessage('mautic.core.notice.created', [
   266|                         '%name%'      => $entity->getTitle(),
   267|                         '%menu_link%' => 'mautic_asset_index',
   268|                         '%url%'       => $this->generateUrl('mautic_asset_action', [
   269|                             'objectAction' => 'edit',
   270|                             'objectId'     => $entity->getId(),
   271|                         ]),
   272|                     ]);
   273|                     if (!$this->getFormButton($form, ['buttons', 'save'])->isClicked()) {
   274|                         return $this->editAction($request, $uploaderHelper, $integrationHelper, $model, $entity->getId(), true);
   275|                     }
   276|                     $viewParameters = [
   277|                         'objectAction' => 'view',
   278|                         'objectId'     => $entity->getId(),
   279|                     ];
   280|                     $returnUrl = $this->generateUrl('mautic_asset_action', $viewParameters);
   281|                     $template  = 'Mautic\AssetBundle\Controller\AssetController::viewAction';
   282|                 }
   283|             } else {
   284|                 $viewParameters = ['page' => $page];
   285|                 $returnUrl      = $this->generateUrl('mautic_asset_index', $viewParameters);
   286|                 $template       = 'Mautic\AssetBundle\Controller\AssetController::indexAction';
   287|             }
   288|             if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
   289|                 return $this->postActionRedirect([
   290|                     'returnUrl'       => $returnUrl,
   291|                     'viewParameters'  => $viewParameters,
   292|                     'contentTemplate' => $template,
   293|                     'passthroughVars' => [
   294|                         'activeLink'    => 'mautic_asset_index',
   295|                         'mauticContent' => 'asset',
   296|                     ],
   297|                 ]);
   298|             }
   299|         }
   300|         $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
   301|         return $this->delegateView([
   302|             'viewParameters' => [
   303|                 'form'             => $form->createView(),
   304|                 'activeAsset'      => $entity,
   305|                 'assetDownloadUrl' => $model->generateUrl($entity),
   306|                 'integrations'     => $integrations,
   307|                 'startOnLocal'     => $entity->isLocal(),
   308|                 'uploadEndpoint'   => $uploadEndpoint,
   309|                 'maxSize'          => $maxSize,
   310|                 'maxSizeError'     => $maxSizeError,
   311|                 'extensions'       => $extensions,
   312|                 'extensionError'   => $extensionError,
   313|             ],
   314|             'contentTemplate' => '@MauticAsset/Asset/form.html.twig',
   315|             'passthroughVars' => [
   316|                 'activeLink'    => '#mautic_asset_index',
   317|                 'mauticContent' => 'asset',
   318|                 'route'         => $this->generateUrl('mautic_asset_action', [
   319|                     'objectAction' => 'new',
   320|                 ]),
   321|             ],
   322|         ]);
   323|     }
   324|     /**
   325|      * Generates edit form and processes post data.
   326|      *
   327|      * @param int  $objectId
   328|      * @param bool $ignorePost
   329|      *
   330|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
   331|      */
   332|     public function editAction(Request $request, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $objectId, $ignorePost = false)
   333|     {
   334|         $entity = $model->getEntity($objectId);
   335|         if (!$this->security->hasEntityAccess('asset:assets:editown', 'asset:assets:editother', $entity->getCreatedBy())) {
   336|             return $this->accessDenied();
   337|         }
   338|         $entity->setMaxSize(FileHelper::convertMegabytesToBytes($this->coreParametersHelper->get('max_size')));
   339|         $session    = $request->getSession();
   340|         $page       = $session->get('mautic.asset.page', 1);
   341|         $method     = $request->getMethod();
   342|         $maxSize    = $model->getMaxUploadSize();
   343|         $extensions = '.'.implode(', .', $this->coreParametersHelper->get('allowed_extensions'));
   344|         $maxSizeError = $this->translator->trans('mautic.asset.asset.error.file.size', [
   345|             '%fileSize%' => '{{filesize}}',
   346|             '%maxSize%'  => '{{maxFilesize}}',
   347|         ], 'validators');
   348|         $extensionError = $this->translator->trans('mautic.asset.asset.error.file.extension.js', [
   349|             '%extensions%' => $extensions,
   350|         ], 'validators');
   351|         $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
   352|         $uploadEndpoint = $uploaderHelper->endpoint('asset');
   353|         $postActionVars = [
   354|             'returnUrl'       => $returnUrl,
   355|             'viewParameters'  => ['page' => $page],
   356|             'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
   357|             'passthroughVars' => [
   358|                 'activeLink'    => 'mautic_asset_index',
   359|                 'mauticContent' => 'asset',
   360|             ],
   361|         ];
   362|         if (null === $entity) {
   363|             return $this->postActionRedirect(
   364|                 array_merge($postActionVars, [
   365|                     'flashes' => [
   366|                         [
   367|                             'type'    => 'error',
   368|                             'msg'     => 'mautic.asset.asset.error.notfound',
   369|                             'msgVars' => ['%id%' => $objectId],
   370|                         ],
   371|                     ],
   372|                 ])
   373|             );
   374|         } elseif (!$this->security->hasEntityAccess(
   375|             'asset:assets:viewown', 'asset:assets:viewother', $entity->getCreatedBy()
   376|         )
   377|         ) {
   378|             return $this->accessDenied();
   379|         } elseif ($model->isLocked($entity)) {
   380|             return $this->isLocked($postActionVars, $entity, 'asset.asset');
   381|         }
   382|         $asset  = $request->request->all()['asset'] ?? [];
   383|         $tempId = 'POST' === $method ? ($asset['tempId'] ?? '') : uniqid('tmp_');
   384|         $entity->setTempId($tempId);
   385|         $action = $this->generateUrl('mautic_asset_action', ['objectAction' => 'edit', 'objectId' => $objectId]);
   386|         $form   = $model->createForm($entity, $this->formFactory, $action);
   387|         if (!$ignorePost && 'POST' == $method) {
   388|             $valid = false;
   389|             if (!$cancelled = $this->isFormCancelled($form)) {
   390|                 if ($valid = $this->isFormValid($form)) {
   391|                     $entity->setUploadDir($this->coreParametersHelper->get('upload_dir'));
   392|                     $entity->preUpload();
   393|                     $entity->upload();
   394|                     $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
   395|                     $request->files->remove('asset');
   396|                     $this->addFlashMessage('mautic.core.notice.updated', [
   397|                         '%name%'      => $entity->getTitle(),
   398|                         '%menu_link%' => 'mautic_asset_index',
   399|                         '%url%'       => $this->generateUrl('mautic_asset_action', [
   400|                             'objectAction' => 'edit',
   401|                             'objectId'     => $entity->getId(),
   402|                         ]),
   403|                     ]);
   404|                     $returnUrl = $this->generateUrl('mautic_asset_action', [
   405|                         'objectAction' => 'view',
   406|                         'objectId'     => $entity->getId(),
   407|                     ]);
   408|                     $viewParams = ['objectId' => $entity->getId()];
   409|                     $template   = 'Mautic\AssetBundle\Controller\AssetController::viewAction';
   410|                 }
   411|             } else {
   412|                 $session->remove('mautic.asestbuilder.'.$objectId.'.content');
   413|                 $model->unlockEntity($entity);
   414|                 $returnUrl  = $this->generateUrl('mautic_asset_index', ['page' => $page]);
   415|                 $viewParams = ['page' => $page];
   416|                 $template   = 'Mautic\AssetBundle\Controller\AssetController::indexAction';
   417|             }
   418|             if ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked())) {
   419|                 return $this->postActionRedirect(
   420|                     array_merge($postActionVars, [
   421|                         'returnUrl'       => $returnUrl,
   422|                         'viewParameters'  => $viewParams,
   423|                         'contentTemplate' => $template,
   424|                     ])
   425|                 );
   426|             }
   427|         } else {
   428|             $model->lockEntity($entity);
   429|         }
   430|         $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
   431|         return $this->delegateView([
   432|             'viewParameters' => [
   433|                 'form'             => $form->createView(),
   434|                 'activeAsset'      => $entity,
   435|                 'assetDownloadUrl' => $model->generateUrl($entity),
   436|                 'integrations'     => $integrations,
   437|                 'startOnLocal'     => $entity->isLocal(),
   438|                 'uploadEndpoint'   => $uploadEndpoint,
   439|                 'maxSize'          => $maxSize,
   440|                 'maxSizeError'     => $maxSizeError,
   441|                 'extensions'       => $extensions,
   442|                 'extensionError'   => $extensionError,
   443|             ],
   444|             'contentTemplate' => '@MauticAsset/Asset/form.html.twig',
   445|             'passthroughVars' => [
   446|                 'activeLink'    => '#mautic_asset_index',
   447|                 'mauticContent' => 'asset',
   448|                 'route'         => $this->generateUrl('mautic_asset_action', [
   449|                     'objectAction' => 'edit',
   450|                     'objectId'     => $entity->getId(),
   451|                 ]),
   452|             ],
   453|         ]);
   454|     }
   455|     /**
   456|      * Clone an entity.
   457|      *
   458|      * @param int $objectId
   459|      *
   460|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
   461|      */
   462|     public function cloneAction(Request $request, CoreParametersHelper $parametersHelper, UploaderHelper $uploaderHelper, IntegrationHelper $integrationHelper, AssetModel $model, $objectId)
   463|     {
   464|         $entity = $model->getEntity($objectId);
   465|         $clone  = null;
   466|         if (null != $entity) {
   467|             if (!$this->security->isGranted('asset:assets:create')
   468|                 || !$this->security->hasEntityAccess(
   469|                     'asset:assets:viewown', 'asset:assets:viewother', $entity->getCreatedBy()
   470|                 )
   471|             ) {
   472|                 return $this->accessDenied();
   473|             }
   474|             $clone = clone $entity;
   475|             $clone->setDownloadCount(0);
   476|             $clone->setUniqueDownloadCount(0);
   477|             $clone->setRevision(0);
   478|             $clone->setIsPublished(false);
   479|         }
   480|         return $this->newAction($request, $parametersHelper, $uploaderHelper, $integrationHelper, $model, $clone);
   481|     }
   482|     /**
   483|      * Deletes the entity.
   484|      *
   485|      * @param int $objectId
   486|      *
   487|      * @return Response
   488|      */
   489|     public function deleteAction(Request $request, AssetModel $model, $objectId)
   490|     {
   491|         $page      = $request->getSession()->get('mautic.asset.page', 1);
   492|         $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
   493|         $flashes   = [];
   494|         $postActionVars = [
   495|             'returnUrl'       => $returnUrl,
   496|             'viewParameters'  => ['page' => $page],
   497|             'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
   498|             'passthroughVars' => [
   499|                 'activeLink'    => 'mautic_asset_index',
   500|                 'mauticContent' => 'asset',
   501|             ],
   502|         ];
   503|         if ('POST' === $request->getMethod()) {
   504|             $entity = $model->getEntity($objectId);
   505|             if (null === $entity) {
   506|                 $flashes[] = [
   507|                     'type'    => 'error',
   508|                     'msg'     => 'mautic.asset.asset.error.notfound',
   509|                     'msgVars' => ['%id%' => $objectId],
   510|                 ];
   511|             } elseif (!$this->security->hasEntityAccess(
   512|                 'asset:assets:deleteown',
   513|                 'asset:assets:deleteother',
   514|                 $entity->getCreatedBy()
   515|             )
   516|             ) {
   517|                 return $this->accessDenied();
   518|             } elseif ($model->isLocked($entity)) {
   519|                 return $this->isLocked($postActionVars, $entity, 'asset.asset');
   520|             }
   521|             $entity->removeUpload();
   522|             $model->deleteEntity($entity);
   523|             $flashes[] = [
   524|                 'type'    => 'notice',
   525|                 'msg'     => 'mautic.core.notice.deleted',
   526|                 'msgVars' => [
   527|                     '%name%' => $entity->getTitle(),
   528|                     '%id%'   => $objectId,
   529|                 ],
   530|             ];
   531|         } // else don't do anything
   532|         return $this->postActionRedirect(
   533|             array_merge($postActionVars, [
   534|                 'flashes' => $flashes,
   535|             ])
   536|         );
   537|     }
   538|     /**
   539|      * Deletes a group of entities.
   540|      */
   541|     public function batchDeleteAction(Request $request, AssetModel $model): Response
   542|     {
   543|         $page      = $request->getSession()->get('mautic.asset.page', 1);
   544|         $returnUrl = $this->generateUrl('mautic_asset_index', ['page' => $page]);
   545|         $flashes   = [];
   546|         $postActionVars = [
   547|             'returnUrl'       => $returnUrl,
   548|             'viewParameters'  => ['page' => $page],
   549|             'contentTemplate' => 'Mautic\AssetBundle\Controller\AssetController::indexAction',
   550|             'passthroughVars' => [
   551|                 'activeLink'    => 'mautic_asset_index',
   552|                 'mauticContent' => 'asset',
   553|             ],
   554|         ];
   555|         if ('POST' === $request->getMethod()) {
   556|             $ids       = json_decode($request->query->get('ids', '{}'));
   557|             $deleteIds = [];
   558|             foreach ($ids as $objectId) {
   559|                 $entity = $model->getEntity($objectId);
   560|                 if (null === $entity) {
   561|                     $flashes[] = [
   562|                         'type'    => 'error',
   563|                         'msg'     => 'mautic.asset.asset.error.notfound',
   564|                         'msgVars' => ['%id%' => $objectId],
   565|                     ];
   566|                 } elseif (!$this->security->hasEntityAccess(
   567|                     'asset:assets:deleteown', 'asset:assets:deleteother', $entity->getCreatedBy()
   568|                 )
   569|                 ) {
   570|                     $flashes[] = $this->accessDenied(true);
   571|                 } elseif ($model->isLocked($entity)) {
   572|                     $flashes[] = $this->isLocked($postActionVars, $entity, 'asset', true);
   573|                 } else {
   574|                     $deleteIds[] = $objectId;
   575|                 }
   576|             }
   577|             if (!empty($deleteIds)) {
   578|                 $entities = $model->deleteEntities($deleteIds);
   579|                 $flashes[] = [
   580|                     'type'    => 'notice',
   581|                     'msg'     => 'mautic.asset.asset.notice.batch_deleted',
   582|                     'msgVars' => [
   583|                         '%count%' => count($entities),
   584|                     ],
   585|                 ];
   586|             }
   587|         } // else don't do anything
   588|         return $this->postActionRedirect(
   589|             array_merge($postActionVars, [
   590|                 'flashes' => $flashes,
   591|             ])
   592|         );
   593|     }
   594|     /**
   595|      * Renders the container for the remote file browser.
   596|      *
   597|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
   598|      */
   599|     public function remoteAction(Request $request, IntegrationHelper $integrationHelper): Response
   600|     {
   601|         $integrations = $integrationHelper->getIntegrationObjects(null, ['cloud_storage']);
   602|         $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
   603|         return $this->delegateView([
   604|             'viewParameters' => [
   605|                 'integrations' => $integrations,
   606|                 'tmpl'         => $tmpl,
   607|             ],
   608|             'contentTemplate' => '@MauticAsset/Remote/browse.html.twig',
   609|             'passthroughVars' => [
   610|                 'activeLink'    => '#mautic_asset_index',
   611|                 'mauticContent' => 'asset',
   612|                 'route'         => $this->generateUrl('mautic_asset_index', ['page' => $request->getSession()->get('mautic.asset.page', 1)]),
   613|             ],
   614|         ]);
   615|     }
   616|     public function getModelName(): string
   617|     {
   618|         return 'asset';
   619|     }
   620|     protected function getDefaultOrderDirection(): string
   621|     {
   622|         return 'DESC';
   623|     }
   624| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Entity/Asset.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1235 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Entity;
     3| use ApiPlatform\Core\Annotation\ApiResource;
     4| use Doctrine\DBAL\Types\Types;
     5| use Doctrine\ORM\Mapping as ORM;
     6| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     7| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     8| use Mautic\CoreBundle\Entity\FormEntity;
     9| use Mautic\CoreBundle\Entity\UuidInterface;
    10| use Mautic\CoreBundle\Entity\UuidTrait;
    11| use Mautic\CoreBundle\Helper\FileHelper;
    12| use Mautic\CoreBundle\Loader\ParameterLoader;
    13| use Symfony\Component\Filesystem\Filesystem;
    14| use Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException;
    15| use Symfony\Component\HttpFoundation\File\File;
    16| use Symfony\Component\HttpFoundation\File\UploadedFile;
    17| use Symfony\Component\Serializer\Annotation\Groups;
    18| use Symfony\Component\Validator\Constraints as Assert;
    19| use Symfony\Component\Validator\Context\ExecutionContextInterface;
    20| use Symfony\Component\Validator\Mapping\ClassMetadata;
    21| /**
    22|  * @ApiResource(
    23|  *   attributes={
    24|  *     "security"="false",
    25|  *     "normalization_context"={
    26|  *       "groups"={
    27|  *         "asset:read"
    28|  *        },
    29|  *       "swagger_definition_name"="Read",
    30|  *       "api_included"={"category"}
    31|  *     },
    32|  *     "denormalization_context"={
    33|  *       "groups"={
    34|  *         "asset:write"
    35|  *       },
    36|  *       "swagger_definition_name"="Write"
    37|  *     }
    38|  *   }
    39|  * )
    40|  */
    41| class Asset extends FormEntity implements UuidInterface
    42| {
    43|     use UuidTrait;
    44|     /**
    45|      * @var int|null
    46|      *
    47|      * @Groups({"asset:read", "download:read", "email:read"})
    48|      */
    49|     private $id;
    50|     /**
    51|      * @var string|null
    52|      *
    53|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    54|      */
    55|     private $title;
    56|     /**
    57|      * @var string|null
    58|      *
    59|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    60|      */
    61|     private $description;
    62|     /**
    63|      * @var string|null
    64|      *
    65|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    66|      */
    67|     private $storageLocation = 'local';
    68|     /**
    69|      * @var string|null
    70|      *
    71|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    72|      */
    73|     private $path;
    74|     /**
    75|      * @var string|null
    76|      *
    77|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    78|      */
    79|     private $remotePath;
    80|     /**
    81|      * @var string|null
    82|      *
    83|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
    84|      */
    85|     private $originalFileName;
    86|     /**
    87|      * @var File
    88|      */
    89|     private $file;
    90|     /**
    91|      * Holds upload directory.
    92|      */
    93|     private $uploadDir;
    94|     /**
    95|      * Holds max size of uploaded file.
    96|      */
    97|     private $maxSize;
    98|     /**
    99|      * Temporary location when asset file is beeing updated.
   100|      * We need to keep the old file till we are sure the new
   101|      * one is stored correctly.
   102|      */
   103|     private $temp;
   104|     /**
   105|      * Temporary ID used for file upload and validations
   106|      * before the actual ID is known.
   107|      */
   108|     private $tempId;
   109|     /**
   110|      * Temporary file name used for file upload and validations
   111|      * before the actual ID is known.
   112|      */
   113|     private $tempName;
   114|     /**
   115|      * @var string
   116|      *
   117|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   118|      */
   119|     private $alias;
   120|     /**
   121|      * @var string
   122|      *
   123|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   124|      */
   125|     private $language = 'en';
   126|     /**
   127|      * @var \DateTimeInterface|null
   128|      *
   129|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   130|      */
   131|     private $publishUp;
   132|     /**
   133|      * @var \DateTimeInterface|null
   134|      *
   135|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   136|      */
   137|     private $publishDown;
   138|     /**
   139|      * @var int
   140|      *
   141|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   142|      */
   143|     private $downloadCount = 0;
   144|     /**
   145|      * @var int
   146|      *
   147|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   148|      */
   149|     private $uniqueDownloadCount = 0;
   150|     /**
   151|      * @var int
   152|      *
   153|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   154|      */
   155|     private $revision = 1;
   156|     /**
   157|      * @var \Mautic\CategoryBundle\Entity\Category|null
   158|      *
   159|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   160|      **/
   161|     private $category;
   162|     /**
   163|      * @var string|null
   164|      *
   165|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   166|      */
   167|     private $extension;
   168|     /**
   169|      * @var string|null
   170|      *
   171|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   172|      */
   173|     private $mime;
   174|     /**
   175|      * @var int|null
   176|      */
   177|     private $size;
   178|     /**
   179|      * @var string|null
   180|      *
   181|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   182|      */
   183|     private $downloadUrl;
   184|     /**
   185|      * @var bool|null
   186|      *
   187|      * @Groups({"asset:read", "asset:write", "download:read", "email:read"})
   188|      */
   189|     private $disallow = true;
   190|     public static function loadMetadata(ORM\ClassMetadata $metadata): void
   191|     {
   192|         $builder = new ClassMetadataBuilder($metadata);
   193|         $builder->setTable('assets')
   194|             ->setCustomRepositoryClass(AssetRepository::class)
   195|             ->addIndex(['alias'], 'asset_alias_search');
   196|         $builder->addIdColumns('title');
   197|         $builder->addField('alias', 'string');
   198|         $builder->createField('storageLocation', 'string')
   199|             ->columnName('storage_location')
   200|             ->nullable()
   201|             ->build();
   202|         $builder->createField('path', 'string')
   203|             ->nullable()
   204|             ->build();
   205|         $builder->createField('remotePath', Types::TEXT)
   206|             ->columnName('remote_path')
   207|             ->nullable()
   208|             ->build();
   209|         $builder->createField('originalFileName', Types::TEXT)
   210|             ->columnName('original_file_name')
   211|             ->nullable()
   212|             ->build();
   213|         $builder->createField('language', 'string')
   214|             ->columnName('lang')
   215|             ->build();
   216|         $builder->addPublishDates();
   217|         $builder->createField('downloadCount', 'integer')
   218|             ->columnName('download_count')
   219|             ->build();
   220|         $builder->createField('uniqueDownloadCount', 'integer')
   221|             ->columnName('unique_download_count')
   222|             ->build();
   223|         $builder->addField('revision', 'integer');
   224|         $builder->addCategory();
   225|         $builder->createField('extension', 'string')
   226|             ->nullable()
   227|             ->build();
   228|         $builder->createField('mime', 'string')
   229|             ->nullable()
   230|             ->build();
   231|         $builder->createField('size', 'integer')
   232|             ->nullable()
   233|             ->build();
   234|         $builder->createField('disallow', 'boolean')
   235|             ->nullable()
   236|             ->build();
   237|         static::addUuidField($builder);
   238|     }
   239|     /**
   240|      * Prepares the metadata for API usage.
   241|      */
   242|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
   243|     {
   244|         $metadata->setGroupPrefix('asset')
   245|             ->addListProperties(
   246|                 [
   247|                     'id',
   248|                     'title',
   249|                     'alias',
   250|                     'category',
   251|                     'description',
   252|                 ]
   253|             )
   254|             ->addProperties(
   255|                 [
   256|                     'language',
   257|                     'publishUp',
   258|                     'publishDown',
   259|                     'downloadCount',
   260|                     'uniqueDownloadCount',
   261|                     'revision',
   262|                     'extension',
   263|                     'mime',
   264|                     'size',
   265|                     'downloadUrl',
   266|                     'storageLocation',
   267|                     'disallow',
   268|                 ]
   269|             )
   270|             ->build();
   271|     }
   272|     /**
   273|      * Clone magic function.
   274|      */
   275|     public function __clone()
   276|     {
   277|         $this->id = null;
   278|         parent::__clone();
   279|     }
   280|     /**
   281|      * Get id.
   282|      *
   283|      * @return int
   284|      */
   285|     public function getId()
   286|     {
   287|         return $this->id;
   288|     }
   289|     /**
   290|      * Sets file.
   291|      */
   292|     public function setFile(File $file = null): void
   293|     {
   294|         $this->file = $file;
   295|         if (isset($this->path)) {
   296|             $this->temp = $this->path;
   297|             $this->path = null;
   298|         }
   299|     }
   300|     /**
   301|      * Get file.
   302|      *
   303|      * @return UploadedFile
   304|      */
   305|     public function getFile()
   306|     {
   307|         if ($this->isLocal() && empty($this->file)) {
   308|             $tempFile = $this->loadFile(true);
   309|             if ($tempFile) {
   310|                 $this->setFile($tempFile);
   311|             }
   312|         }
   313|         return $this->file;
   314|     }
   315|     /**
   316|      * Set title.
   317|      *
   318|      * @param string $title
   319|      *
   320|      * @return Asset
   321|      */
   322|     public function setTitle($title)
   323|     {
   324|         $this->isChanged('title', $title);
   325|         $this->title = $title;
   326|         return $this;
   327|     }
   328|     /**
   329|      * Get title.
   330|      *
   331|      * @return string
   332|      */
   333|     public function getTitle()
   334|     {
   335|         return $this->title;
   336|     }
   337|     /**
   338|      * @return mixed
   339|      */
   340|     public function getExtension()
   341|     {
   342|         return $this->extension;
   343|     }
   344|     /**
   345|      * @param mixed $extension
   346|      */
   347|     public function setExtension($extension): void
   348|     {
   349|         $this->extension = $extension;
   350|     }
   351|     /**
   352|      * @return mixed
   353|      */
   354|     public function getMime()
   355|     {
   356|         return $this->mime;
   357|     }
   358|     /**
   359|      * @param mixed $mime
   360|      */
   361|     public function setMime($mime): void
   362|     {
   363|         $this->mime = $mime;
   364|     }
   365|     /**
   366|      * Set originalFileName.
   367|      *
   368|      * @param string $originalFileName
   369|      *
   370|      * @return Asset
   371|      */
   372|     public function setOriginalFileName($originalFileName)
   373|     {
   374|         $this->isChanged('originalFileName', $originalFileName);
   375|         $this->originalFileName = $originalFileName;
   376|         return $this;
   377|     }
   378|     /**
   379|      * Get originalFileName.
   380|      *
   381|      * @return string
   382|      */
   383|     public function getOriginalFileName()
   384|     {
   385|         return $this->originalFileName;
   386|     }
   387|     /**
   388|      * Set storage location.
   389|      *
   390|      * @param string $storageLocation
   391|      *
   392|      * @return Asset
   393|      */
   394|     public function setStorageLocation($storageLocation)
   395|     {
   396|         $this->isChanged('storageLocation', $storageLocation);
   397|         $this->storageLocation = $storageLocation;
   398|         return $this;
   399|     }
   400|     /**
   401|      * Get storage location.
   402|      *
   403|      * @return string
   404|      */
   405|     public function getStorageLocation()
   406|     {
   407|         if (null === $this->storageLocation) {
   408|             $this->storageLocation = 'local';
   409|         }
   410|         return $this->storageLocation;
   411|     }
   412|     /**
   413|      * Set path.
   414|      *
   415|      * @param string $path
   416|      *
   417|      * @return Asset
   418|      */
   419|     public function setPath($path)
   420|     {
   421|         $this->isChanged('path', $path);
   422|         $this->path = $path;
   423|         return $this;
   424|     }
   425|     /**
   426|      * Get path.
   427|      *
   428|      * @return string
   429|      */
   430|     public function getPath()
   431|     {
   432|         return $this->path;
   433|     }
   434|     /**
   435|      * Set remote path.
   436|      *
   437|      * @param string $remotePath
   438|      *
   439|      * @return Asset
   440|      */
   441|     public function setRemotePath($remotePath)
   442|     {
   443|         $this->isChanged('remotePath', $remotePath);
   444|         $this->remotePath = $remotePath;
   445|         return $this;
   446|     }
   447|     /**
   448|      * Get remote path.
   449|      *
   450|      * @return string
   451|      */
   452|     public function getRemotePath()
   453|     {
   454|         return $this->remotePath;
   455|     }
   456|     /**
   457|      * Set alias.
   458|      *
   459|      * @param string $alias
   460|      *
   461|      * @return Asset
   462|      */
   463|     public function setAlias($alias)
   464|     {
   465|         $this->isChanged('alias', $alias);
   466|         $this->alias = $alias;
   467|         return $this;
   468|     }
   469|     /**
   470|      * Get alias.
   471|      *
   472|      * @return string
   473|      */
   474|     public function getAlias()
   475|     {
   476|         return $this->alias;
   477|     }
   478|     /**
   479|      * Set publishUp.
   480|      *
   481|      * @param \DateTime $publishUp
   482|      *
   483|      * @return Asset
   484|      */
   485|     public function setPublishUp($publishUp)
   486|     {
   487|         $this->isChanged('publishUp', $publishUp);
   488|         $this->publishUp = $publishUp;
   489|         return $this;
   490|     }
   491|     /**
   492|      * Get publishUp.
   493|      *
   494|      * @return \DateTimeInterface
   495|      */
   496|     public function getPublishUp()
   497|     {
   498|         return $this->publishUp;
   499|     }
   500|     /**
   501|      * Set publishDown.
   502|      *
   503|      * @param \DateTimeInterface $publishDown
   504|      *
   505|      * @return Asset
   506|      */
   507|     public function setPublishDown($publishDown)
   508|     {
   509|         $this->isChanged('publishDown', $publishDown);
   510|         $this->publishDown = $publishDown;
   511|         return $this;
   512|     }
   513|     /**
   514|      * Get publishDown.
   515|      *
   516|      * @return \DateTimeInterface
   517|      */
   518|     public function getPublishDown()
   519|     {
   520|         return $this->publishDown;
   521|     }
   522|     /**
   523|      * Set downloadCount.
   524|      *
   525|      * @param int $downloadCount
   526|      *
   527|      * @return Asset
   528|      */
   529|     public function setDownloadCount($downloadCount)
   530|     {
   531|         $this->downloadCount = $downloadCount;
   532|         return $this;
   533|     }
   534|     /**
   535|      * Get downloadCount.
   536|      *
   537|      * @return int
   538|      */
   539|     public function getDownloadCount()
   540|     {
   541|         return $this->downloadCount;
   542|     }
   543|     /**
   544|      * Set revision.
   545|      *
   546|      * @param int $revision
   547|      *
   548|      * @return Asset
   549|      */
   550|     public function setRevision($revision)
   551|     {
   552|         $this->revision = $revision;
   553|         return $this;
   554|     }
   555|     /**
   556|      * Get revision.
   557|      *
   558|      * @return int
   559|      */
   560|     public function getRevision()
   561|     {
   562|         return $this->revision;
   563|     }
   564|     /**
   565|      * Set language.
   566|      *
   567|      * @param string $language
   568|      *
   569|      * @return Asset
   570|      */
   571|     public function setLanguage($language)
   572|     {
   573|         $this->isChanged('language', $language);
   574|         $this->language = $language;
   575|         return $this;
   576|     }
   577|     /**
   578|      * Get language.
   579|      *
   580|      * @return string
   581|      */
   582|     public function getLanguage()
   583|     {
   584|         return $this->language;
   585|     }
   586|     /**
   587|      * Set category.
   588|      *
   589|      * @return Asset
   590|      */
   591|     public function setCategory(\Mautic\CategoryBundle\Entity\Category $category = null)
   592|     {
   593|         $this->isChanged('category', $category);
   594|         $this->category = $category;
   595|         return $this;
   596|     }
   597|     /**
   598|      * Get category.
   599|      *
   600|      * @return \Mautic\CategoryBundle\Entity\Category
   601|      */
   602|     public function getCategory()
   603|     {
   604|         return $this->category;
   605|     }
   606|     /**
   607|      * Set uniqueDownloadCount.
   608|      *
   609|      * @param int $uniqueDownloadCount
   610|      *
   611|      * @return Asset
   612|      */
   613|     public function setUniqueDownloadCount($uniqueDownloadCount)
   614|     {
   615|         $this->uniqueDownloadCount = $uniqueDownloadCount;
   616|         return $this;
   617|     }
   618|     /**
   619|      * Get uniqueDownloadCount.
   620|      *
   621|      * @return int
   622|      */
   623|     public function getUniqueDownloadCount()
   624|     {
   625|         return $this->uniqueDownloadCount;
   626|     }
   627|     public function setFileNameFromRemote(): void
   628|     {
   629|         $fileName = basename($this->getRemotePath());
   630|         $this->setOriginalFileName($fileName);
   631|         if (null === $this->getTitle()) {
   632|             $this->setTitle($fileName);
   633|         }
   634|     }
   635|     public function preUpload(): void
   636|     {
   637|         if (null !== $this->getFile()) {
   638|             if (null === $this->getTitle()) {
   639|                 $this->setTitle($this->file->getClientOriginalName());
   640|             }
   641|             $filename  = sha1(uniqid(mt_rand(), true));
   642|             $extension = $this->getFile()->guessExtension();
   643|             if (empty($extension)) {
   644|                 $extension = pathinfo($this->originalFileName, PATHINFO_EXTENSION);
   645|             }
   646|             $this->path = $filename.'.'.$extension;
   647|         } elseif ($this->isRemote() && null !== $this->getRemotePath()) {
   648|             $this->setFileNameFromRemote();
   649|         }
   650|     }
   651|     public function upload(): void
   652|     {
   653|         if (null === $this->getFile()) {
   654|             if ($this->isRemote()) {
   655|                 $this->setFileInfoFromFile();
   656|             }
   657|             return;
   658|         }
   659|         $this->getFile()->move($this->getUploadDir(), $this->path);
   660|         $filePath = $this->getUploadDir().'/'.$this->temp;
   661|         $this->setFileInfoFromFile();
   662|         if (isset($this->temp) && file_exists($filePath)) {
   663|             unlink($filePath);
   664|             $this->temp = null;
   665|         }
   666|         $fs = new Filesystem();
   667|         $fs->remove($this->getAbsoluteTempDir());
   668|         $this->file = null;
   669|     }
   670|     /**
   671|      * Remove a file.
   672|      */
   673|     public function setFileInfoFromFile(): void
   674|     {
   675|         $fileInfo = $this->getFileInfo();
   676|         if (!is_array($fileInfo)) {
   677|             return;
   678|         }
   679|         $this->setExtension($fileInfo['extension']);
   680|         $this->setMime($fileInfo['mime']);
   681|         $this->setSize($fileInfo['size']);
   682|     }
   683|     /**
   684|      * Remove a file.
   685|      *
   686|      * @param bool $temp >> regular uploaded file or temporary
   687|      */
   688|     public function removeUpload($temp = false): void
   689|     {
   690|         if ($temp) {
   691|             $file = $this->getAbsoluteTempPath();
   692|         } else {
   693|             $file = $this->getAbsolutePath();
   694|         }
   695|         if ($file && file_exists($file)) {
   696|             unlink($file);
   697|         }
   698|     }
   699|     /**
   700|      * Returns absolute path to the file.
   701|      *
   702|      * @return string
   703|      */
   704|     public function getAbsolutePath()
   705|     {
   706|         return null === $this->path
   707|             ? null
   708|             : $this->getUploadDir().'/'.$this->path;
   709|     }
   710|     /**
   711|      * Returns absolute path to temporary file.
   712|      *
   713|      * @return string
   714|      */
   715|     public function getAbsoluteTempPath()
   716|     {
   717|         return null === $this->tempId || null === $this->tempName
   718|             ? null
   719|             : $this->getAbsoluteTempDir().'/'.$this->tempName;
   720|     }
   721|     /**
   722|      * Returns absolute path to temporary file.
   723|      *
   724|      * @return string
   725|      */
   726|     public function getAbsoluteTempDir()
   727|     {
   728|         return null === $this->tempId
   729|             ? null
   730|             : $this->getUploadDir().'/tmp/'.$this->tempId;
   731|     }
   732|     /**
   733|      * Returns absolute path to upload dir.
   734|      *
   735|      * @return string
   736|      */
   737|     protected function getUploadDir()
   738|     {
   739|         if ($this->uploadDir) {
   740|             return $this->uploadDir;
   741|         }
   742|         return 'media/files';
   743|     }
   744|     /**
   745|      * Set uploadDir.
   746|      *
   747|      * @param string $uploadDir
   748|      *
   749|      * @return Asset
   750|      */
   751|     public function setUploadDir($uploadDir)
   752|     {
   753|         $this->uploadDir = $uploadDir;
   754|         return $this;
   755|     }
   756|     /**
   757|      * Returns maximal uploadable size in bytes.
   758|      * If not set, 6000000 is default.
   759|      *
   760|      * @return string
   761|      */
   762|     protected function getMaxSize()
   763|     {
   764|         if ($this->maxSize) {
   765|             return $this->maxSize;
   766|         }
   767|         return 6_000_000;
   768|     }
   769|     /**
   770|      * Set max size.
   771|      *
   772|      * @param string $maxSize
   773|      *
   774|      * @return Asset
   775|      */
   776|     public function setMaxSize($maxSize)
   777|     {
   778|         $this->maxSize = $maxSize;
   779|         return $this;
   780|     }
   781|     /**
   782|      * Returns file extension.
   783|      *
   784|      * @return string
   785|      */
   786|     public function getFileType()
   787|     {
   788|         if (!empty($this->extension) && empty($this->changes['originalFileName'])) {
   789|             return $this->extension;
   790|         }
   791|         if ($this->isRemote()) {
   792|             return pathinfo(parse_url($this->getRemotePath(), PHP_URL_PATH), PATHINFO_EXTENSION);
   793|         }
   794|         if (null === $this->loadFile()) {
   795|             return '';
   796|         }
   797|         return $this->loadFile()->guessExtension();
   798|     }
   799|     /**
   800|      * Returns some file info.
   801|      *
   802|      * @return array
   803|      */
   804|     public function getFileInfo()
   805|     {
   806|         $fileInfo = [];
   807|         if ($this->isRemote()) {
   808|             $ch = curl_init($this->getRemotePath());
   809|             curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
   810|             curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
   811|             curl_setopt($ch, CURLOPT_HEADER, true);
   812|             curl_setopt($ch, CURLOPT_NOBODY, true);
   813|             curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
   814|             curl_exec($ch);
   815|             $fileInfo['mime']      = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
   816|             $fileInfo['extension'] = $this->getFileType();
   817|             $fileInfo['size']      = curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD);
   818|             return $fileInfo;
   819|         }
   820|         if (null === $this->loadFile()) {
   821|             return '';
   822|         }
   823|         $fileInfo['mime']      = $this->loadFile()->getMimeType();
   824|         $fileInfo['extension'] = $this->getFileType();
   825|         $fileInfo['size']      = $this->getSize(false, true);
   826|         return $fileInfo;
   827|     }
   828|     /**
   829|      * Returns file mime type.
   830|      *
   831|      * @return string
   832|      */
   833|     public function getFileMimeType()
   834|     {
   835|         if ($this->isRemote()) {
   836|             $ch = curl_init($this->getRemotePath());
   837|             curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
   838|             curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
   839|             curl_setopt($ch, CURLOPT_HEADER, true);
   840|             curl_setopt($ch, CURLOPT_NOBODY, true);
   841|             curl_exec($ch);
   842|             return curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
   843|         }
   844|         if (null === $this->loadFile()) {
   845|             return '';
   846|         }
   847|         return $this->loadFile()->getMimeType();
   848|     }
   849|     /**
   850|      * Returns icon class based on file type.
   851|      */
   852|     public function getIconClass(): string
   853|     {
   854|         $fileType = $this->getFileType();
   855|         if (!$fileType) {
   856|             return 'ri-prohibited-line';
   857|         }
   858|         $fileTypes = $this->getFileExtensions();
   859|         foreach ($fileTypes as $icon => $extensions) {
   860|             if (in_array($fileType, $extensions)) {
   861|                 return 'ri-file-'.$icon.'-line';
   862|             }
   863|         }
   864|         return 'ri-file-line';
   865|     }
   866|     /**
   867|      * Decides if an asset is image displayable by browser.
   868|      */
   869|     public function isImage(): bool
   870|     {
   871|         $fileType = strtolower($this->getFileType());
   872|         if (!$fileType) {
   873|             return false;
   874|         }
   875|         $imageTypes = ['jpg', 'jpeg', 'png', 'gif'];
   876|         if (in_array($fileType, $imageTypes)) {
   877|             return true;
   878|         }
   879|         return false;
   880|     }
   881|     /**
   882|      * Returns array of common extensions.
   883|      *
   884|      * @return array<string, string[]>
   885|      */
   886|     public function getFileExtensions(): array
   887|     {
   888|         return [
   889|             'excel' => [
   890|                 'xlsx',
   891|                 'xlsm',
   892|                 'xlsb',
   893|                 'xltx',
   894|                 'xltm',
   895|                 'xls',
   896|                 'xlt',
   897|             ],
   898|             'word' => [
   899|                 'doc',
   900|                 'docx',
   901|                 'docm',
   902|                 'dotx',
   903|             ],
   904|             'pdf' => [
   905|                 'pdf',
   906|             ],
   907|             'audio' => [
   908|                 'mp3',
   909|             ],
   910|             'zip' => [
   911|                 'zip',
   912|                 'rar',
   913|                 'iso',
   914|                 'tar',
   915|                 'gz',
   916|                 '7z',
   917|             ],
   918|             'image' => [
   919|                 'jpg',
   920|                 'jpeg',
   921|                 'png',
   922|                 'gif',
   923|                 'ico',
   924|                 'bmp',
   925|                 'psd',
   926|             ],
   927|             'text' => [
   928|                 'txt',
   929|                 'pub',
   930|             ],
   931|             'code' => [
   932|                 'php',
   933|                 'js',
   934|                 'json',
   935|                 'yaml',
   936|                 'xml',
   937|                 'html',
   938|                 'htm',
   939|                 'sql',
   940|             ],
   941|             'ppt' => [
   942|                 'ppt',
   943|                 'pptx',
   944|                 'pptm',
   945|                 'xps',
   946|                 'potm',
   947|                 'potx',
   948|                 'pot',
   949|                 'pps',
   950|                 'odp',
   951|             ],
   952|             'video' => [
   953|                 'wmv',
   954|                 'avi',
   955|                 'mp4',
   956|                 'mkv',
   957|                 'mpeg',
   958|             ],
   959|         ];
   960|     }
   961|     /**
   962|      * Load the file object from it's path.
   963|      *
   964|      * @return File|null
   965|      */
   966|     public function loadFile($temp = false)
   967|     {
   968|         if ($temp) {
   969|             $path = $this->getAbsoluteTempPath();
   970|         } else {
   971|             $path = $this->getAbsolutePath();
   972|         }
   973|         if (!$path || !file_exists($path)) {
   974|             return null;
   975|         }
   976|         try {
   977|             $file = new File($path);
   978|         } catch (FileNotFoundException) {
   979|             $file = null;
   980|         }
   981|         return $file;
   982|     }
   983|     /**
   984|      * Load content of the file from it's path.
   985|      */
   986|     public function getFileContents(): string|bool
   987|     {
   988|         $path = $this->getFilePath();
   989|         return file_get_contents($path);
   990|     }
   991|     /**
   992|      * Get the path to the file; a URL if remote or full file path if local.
   993|      *
   994|      * @return string
   995|      */
   996|     public function getFilePath()
   997|     {
   998|         return $this->isRemote() ? $this->getRemotePath() : $this->getAbsolutePath();
   999|     }
  1000|     /**
  1001|      * @return mixed
  1002|      */
  1003|     public function getDescription()
  1004|     {
  1005|         return $this->description;
  1006|     }
  1007|     /**
  1008|      * @param mixed $description
  1009|      */
  1010|     public function setDescription($description): void
  1011|     {
  1012|         $this->description = $description;
  1013|     }
  1014|     public static function loadValidatorMetadata(ClassMetadata $metadata): void
  1015|     {
  1016|         $metadata->addConstraint(new Assert\Callback([self::class, 'validateFile']));
  1017|     }
  1018|     /**
  1019|      * Validator to ensure proper data for the file fields.
  1020|      *
  1021|      * @param Asset                     $object  Entity object to validate
  1022|      * @param ExecutionContextInterface $context Context object
  1023|      */
  1024|     public static function validateFile($object, ExecutionContextInterface $context): void
  1025|     {
  1026|         if ($object->isLocal()) {
  1027|             $tempName = $object->getTempName();
  1028|             $path     = $object->getPath();
  1029|             if ($object->isNew() && null === $tempName && null === $path) {
  1030|                 $context->buildViolation('mautic.asset.asset.error.missing.file')
  1031|                     ->atPath('tempName')
  1032|                     ->setTranslationDomain('validators')
  1033|                     ->addViolation();
  1034|             }
  1035|             if (null === $object->getTitle()) {
  1036|                 $context->buildViolation('mautic.asset.asset.error.missing.title')
  1037|                     ->atPath('title')
  1038|                     ->setTranslationDomain('validators')
  1039|                     ->addViolation();
  1040|             }
  1041|             $loader           = new ParameterLoader();
  1042|             $parameters       = $loader->getParameterBag();
  1043|             $mimeTypesAllowed = $parameters->get('allowed_mimetypes');
  1044|             if (!empty($object->getFileMimeType()) && !in_array($object->getFileMimeType(), $mimeTypesAllowed)) {
  1045|                 $context->buildViolation('mautic.asset.asset.error.invalid.mimetype', [
  1046|                     '%fileMimetype%'=> $object->getFileMimeType(),
  1047|                     '%mimetypes%'   => implode(', ', $mimeTypesAllowed),
  1048|                 ])->atPath('file')
  1049|                     ->setTranslationDomain('validators')
  1050|                     ->addViolation();
  1051|             }
  1052|             $extensionsAllowed = array_keys($mimeTypesAllowed);
  1053|             $fileType          = $object->getExtension();
  1054|             if (null !== $object->getExtension() && !in_array($fileType, $extensionsAllowed)) {
  1055|                 $context->buildViolation('mautic.asset.asset.error.file.extension', [
  1056|                     '%fileExtension%'=> $object->getExtension(),
  1057|                     '%extensions%'   => implode(', ', $extensionsAllowed),
  1058|                 ])->atPath('file')
  1059|                     ->setTranslationDomain('validators')
  1060|                     ->addViolation();
  1061|             }
  1062|             $object->setRemotePath(null);
  1063|         } elseif ($object->isRemote()) {
  1064|             if (null === $object->getRemotePath()) {
  1065|                 $context->buildViolation('mautic.asset.asset.error.missing.remote.path')
  1066|                     ->atPath('remotePath')
  1067|                     ->setTranslationDomain('validators')
  1068|                     ->addViolation();
  1069|             }
  1070|             $object->setPath(null);
  1071|         }
  1072|     }
  1073|     /**
  1074|      * Set temporary ID.
  1075|      *
  1076|      * @param string $tempId
  1077|      *
  1078|      * @return Asset
  1079|      */
  1080|     public function setTempId($tempId)
  1081|     {
  1082|         $this->tempId = $tempId;
  1083|         return $this;
  1084|     }
  1085|     /**
  1086|      * Get temporary ID.
  1087|      *
  1088|      * @return string
  1089|      */
  1090|     public function getTempId()
  1091|     {
  1092|         return $this->tempId;
  1093|     }
  1094|     /**
  1095|      * Set temporary file name.
  1096|      *
  1097|      * @param string $tempName
  1098|      *
  1099|      * @return Asset
  1100|      */
  1101|     public function setTempName($tempName)
  1102|     {
  1103|         $this->tempName = $tempName;
  1104|         return $this;
  1105|     }
  1106|     /**
  1107|      * Get temporary file name.
  1108|      *
  1109|      * @return string
  1110|      */
  1111|     public function getTempName()
  1112|     {
  1113|         return $this->tempName;
  1114|     }
  1115|     /**
  1116|      * @param bool   $humanReadable
  1117|      * @param bool   $forceUpdate
  1118|      * @param string $inUnit
  1119|      *
  1120|      * @return float|string
  1121|      */
  1122|     public function getSize($humanReadable = true, $forceUpdate = false, $inUnit = '')
  1123|     {
  1124|         if (empty($this->size) || $forceUpdate) {
  1125|             if ($this->isRemote()) {
  1126|                 $ch = curl_init($this->getRemotePath());
  1127|                 curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  1128|                 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
  1129|                 curl_setopt($ch, CURLOPT_HEADER, true);
  1130|                 curl_setopt($ch, CURLOPT_NOBODY, true);
  1131|                 curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
  1132|                 curl_exec($ch);
  1133|                 $this->setSize(round(curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD)));
  1134|             }
  1135|             if (null === $this->loadFile()) {
  1136|                 return 0;
  1137|             }
  1138|             $this->setSize(round($this->loadFile()->getSize()));
  1139|         }
  1140|         return ($humanReadable) ? static::convertBytesToHumanReadable($this->size, $inUnit) : $this->size;
  1141|     }
  1142|     /**
  1143|      * @param mixed $size
  1144|      *
  1145|      * @return Asset
  1146|      */
  1147|     public function setSize($size)
  1148|     {
  1149|         $this->size = $size;
  1150|         return $this;
  1151|     }
  1152|     /**
  1153|      * Get value from PHP configuration with special handling of -1.
  1154|      *
  1155|      * @param string    $setting
  1156|      * @param bool|true $convertToBytes
  1157|      */
  1158|     public static function getIniValue($setting, $convertToBytes = true): int
  1159|     {
  1160|         $value = ini_get($setting);
  1161|         if (-1 == $value || 0 === $value) {
  1162|             return PHP_INT_MAX;
  1163|         }
  1164|         if ($convertToBytes) {
  1165|             $value = FileHelper::convertPHPSizeToBytes($value);
  1166|         }
  1167|         return (int) $value;
  1168|     }
  1169|     /**
  1170|      * @param string $unit
  1171|      */
  1172|     public static function convertBytesToHumanReadable($size, $unit = ''): string
  1173|     {
  1174|         [$number, $unit] = self::convertBytesToUnit($size, $unit);
  1175|         $number = number_format($number, 2);
  1176|         $number = str_contains($number, '.') ? rtrim(rtrim($number, '0'), '.') : $number;
  1177|         return $number.' '.$unit;
  1178|     }
  1179|     /**
  1180|      * @param string $unit
  1181|      */
  1182|     public static function convertBytesToUnit($size, $unit = ''): array
  1183|     {
  1184|         $unit = strtoupper($unit);
  1185|         if ((!$unit && $size >= 1 << 30) || 'GB' == $unit || 'G' == $unit) {
  1186|             return [$size / (1 << 30), 'GB'];
  1187|         }
  1188|         if ((!$unit && $size >= 1 << 20) || 'MB' == $unit || 'M' == $unit) {
  1189|             return [$size / (1 << 20), 'MB'];
  1190|         }
  1191|         if ((!$unit && $size >= 1 << 10) || 'KB' == $unit || 'K' == $unit) {
  1192|             return [$size / (1 << 10), 'KB'];
  1193|         }
  1194|         return [$size, 'bytes'];
  1195|     }
  1196|     /**
  1197|      * @return string|null
  1198|      */
  1199|     public function getDownloadUrl()
  1200|     {
  1201|         return $this->downloadUrl;
  1202|     }
  1203|     /**
  1204|      * @param string|null $downloadUrl
  1205|      *
  1206|      * @return Asset
  1207|      */
  1208|     public function setDownloadUrl($downloadUrl)
  1209|     {
  1210|         $this->downloadUrl = $downloadUrl;
  1211|         return $this;
  1212|     }
  1213|     public function isLocal(): bool
  1214|     {
  1215|         return 'local' === $this->storageLocation;
  1216|     }
  1217|     public function isRemote(): bool
  1218|     {
  1219|         return 'remote' === $this->storageLocation;
  1220|     }
  1221|     /**
  1222|      * @return bool
  1223|      */
  1224|     public function getDisallow()
  1225|     {
  1226|         return $this->disallow;
  1227|     }
  1228|     /**
  1229|      * @param mixed $disallow
  1230|      */
  1231|     public function setDisallow($disallow): void
  1232|     {
  1233|         $this->disallow = $disallow;
  1234|     }
  1235| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Entity/AssetRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-178 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Entity;
     3| use Doctrine\Common\Collections\Order;
     4| use Doctrine\ORM\NonUniqueResultException;
     5| use Doctrine\ORM\NoResultException;
     6| use Doctrine\ORM\Tools\Pagination\Paginator;
     7| use Mautic\CoreBundle\Entity\CommonRepository;
     8| /**
     9|  * @extends CommonRepository<Asset>
    10|  */
    11| class AssetRepository extends CommonRepository
    12| {
    13|     /**
    14|      * Get a list of entities.
    15|      *
    16|      * @return Paginator
    17|      */
    18|     public function getEntities(array $args = [])
    19|     {
    20|         $q = $this
    21|             ->createQueryBuilder('a')
    22|             ->select('a')
    23|             ->leftJoin('a.category', 'c');
    24|         $args['qb'] = $q;
    25|         return parent::getEntities($args);
    26|     }
    27|     /**
    28|      * @param string     $search
    29|      * @param int        $limit
    30|      * @param int        $start
    31|      * @param bool|false $viewOther
    32|      *
    33|      * @return array
    34|      */
    35|     public function getAssetList($search = '', $limit = 10, $start = 0, $viewOther = false)
    36|     {
    37|         $q = $this->createQueryBuilder('a');
    38|         $q->select('partial a.{id, title, path, alias, language}');
    39|         if (!empty($search)) {
    40|             $q->andWhere($q->expr()->like('a.title', ':search'))
    41|                 ->setParameter('search', "%{$search}%");
    42|         }
    43|         if (!$viewOther) {
    44|             $q->andWhere($q->expr()->eq('a.createdBy', ':id'))
    45|                 ->setParameter('id', $this->currentUser->getId());
    46|         }
    47|         $q->orderBy('a.title');
    48|         if (!empty($limit)) {
    49|             $q->setFirstResult($start)
    50|                 ->setMaxResults($limit);
    51|         }
    52|         return $q->getQuery()->getArrayResult();
    53|     }
    54|     /**
    55|      * @param \Doctrine\ORM\QueryBuilder|\Doctrine\DBAL\Query\QueryBuilder $q
    56|      */
    57|     protected function addCatchAllWhereClause($q, $filter): array
    58|     {
    59|         return $this->addStandardCatchAllWhereClause($q, $filter, [
    60|             'a.title',
    61|             'a.alias',
    62|         ]);
    63|     }
    64|     /**
    65|      * @param \Doctrine\ORM\QueryBuilder|\Doctrine\DBAL\Query\QueryBuilder $q
    66|      */
    67|     protected function addSearchCommandWhereClause($q, $filter): array
    68|     {
    69|         [$expr, $parameters] = $this->addStandardSearchCommandWhereClause($q, $filter);
    70|         if ($expr) {
    71|             return [$expr, $parameters];
    72|         }
    73|         $command         = $field         = $filter->command;
    74|         $unique          = $this->generateRandomParameterName();
    75|         $returnParameter = false; // returning a parameter that is not used will lead to a Doctrine error
    76|         switch ($command) {
    77|             case $this->translator->trans('mautic.asset.asset.searchcommand.lang'):
    78|                 $langUnique      = $this->generateRandomParameterName();
    79|                 $langValue       = $filter->string.'_%';
    80|                 $forceParameters = [
    81|                     $langUnique => $langValue,
    82|                     $unique     => $filter->string,
    83|                 ];
    84|                 $expr = $q->expr()->or(
    85|                     $q->expr()->eq('a.language', ":$unique"),
    86|                     $q->expr()->like('a.language', ":$langUnique")
    87|                 );
    88|                 $returnParameter = true;
    89|                 break;
    90|         }
    91|         if ($expr && $filter->not) {
    92|             $expr = $q->expr()->not($expr);
    93|         }
    94|         if (!empty($forceParameters)) {
    95|             $parameters = $forceParameters;
    96|         } elseif (!$returnParameter) {
    97|             $parameters = [];
    98|         } else {
    99|             $string     = ($filter->strict) ? $filter->string : "%{$filter->string}%";
   100|             $parameters = ["$unique" => $string];
   101|         }
   102|         return [$expr, $parameters];
   103|     }
   104|     /**
   105|      * @return string[]
   106|      */
   107|     public function getSearchCommands(): array
   108|     {
   109|         $commands = [
   110|             'mautic.core.searchcommand.ispublished',
   111|             'mautic.core.searchcommand.isunpublished',
   112|             'mautic.core.searchcommand.isuncategorized',
   113|             'mautic.core.searchcommand.ismine',
   114|             'mautic.core.searchcommand.category',
   115|             'mautic.asset.asset.searchcommand.lang',
   116|         ];
   117|         return array_merge($commands, parent::getSearchCommands());
   118|     }
   119|     /**
   120|      * @return array<array<string>>
   121|      */
   122|     protected function getDefaultOrder(): array
   123|     {
   124|         return [
   125|             ['a.title', 'ASC'],
   126|         ];
   127|     }
   128|     public function getTableAlias(): string
   129|     {
   130|         return 'a';
   131|     }
   132|     /**
   133|      * Gets the sum size of assets.
   134|      */
   135|     public function getAssetSize(array $assets): int
   136|     {
   137|         $q = $this->_em->getConnection()->createQueryBuilder();
   138|         $q->select('sum(a.size) as total_size')
   139|             ->from(MAUTIC_TABLE_PREFIX.'assets', 'a')
   140|             ->where('a.id IN (:assetIds)')
   141|             ->setParameter('assetIds', $assets, \Doctrine\DBAL\ArrayParameterType::INTEGER);
   142|         $result = $q->executeQuery()->fetchAllAssociative();
   143|         return (int) $result[0]['total_size'];
   144|     }
   145|     /**
   146|      * @param int        $increaseBy
   147|      * @param bool|false $unique
   148|      */
   149|     public function upDownloadCount($id, $increaseBy = 1, $unique = false): void
   150|     {
   151|         $q = $this->_em->getConnection()->createQueryBuilder();
   152|         $q->update(MAUTIC_TABLE_PREFIX.'assets')
   153|             ->set('download_count', 'download_count + '.(int) $increaseBy)
   154|             ->where('id = '.(int) $id);
   155|         if ($unique) {
   156|             $q->set('unique_download_count', 'unique_download_count + '.(int) $increaseBy);
   157|         }
   158|         $q->executeStatement();
   159|     }
   160|     /**
   161|      * @param int $categoryId
   162|      *
   163|      * @return Asset
   164|      *
   165|      * @throws NoResultException
   166|      * @throws NonUniqueResultException
   167|      */
   168|     public function getLatestAssetForCategory($categoryId)
   169|     {
   170|         $q = $this->createQueryBuilder($this->getTableAlias());
   171|         $q->where($this->getTableAlias().'.category = :categoryId');
   172|         $q->andWhere($this->getTableAlias().'.isPublished = TRUE');
   173|         $q->setParameter('categoryId', $categoryId);
   174|         $q->orderBy($this->getTableAlias().'.dateAdded', Order::Descending->value);
   175|         $q->setMaxResults(1);
   176|         return $q->getQuery()->getSingleResult();
   177|     }
   178| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Event/AssetLoadEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Event;
     3| use Mautic\AssetBundle\Entity\Download;
     4| use Mautic\CoreBundle\Event\CommonEvent;
     5| class AssetLoadEvent extends CommonEvent
     6| {
     7|     public function __construct(
     8|         Download $download,
     9|         protected bool $unique,
    10|     ) {
    11|         $this->entity = $download;
    12|     }
    13|     /**
    14|      * Returns the Download entity.
    15|      *
    16|      * @return Download
    17|      */
    18|     public function getRecord()
    19|     {
    20|         return $this->entity;
    21|     }
    22|     /**
    23|      * @return \Mautic\AssetBundle\Entity\Asset
    24|      */
    25|     public function getAsset()
    26|     {
    27|         return $this->entity->getAsset();
    28|     }
    29|     /**
    30|      * Returns if this is the first download for the session.
    31|      */
    32|     public function isUnique(): bool
    33|     {
    34|         return $this->unique;
    35|     }
    36| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Event/RemoteAssetBrowseEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Event;
     3| use Gaufrette\Adapter;
     4| use Mautic\CoreBundle\Event\CommonEvent;
     5| use Mautic\PluginBundle\Integration\UnifiedIntegrationInterface;
     6| class RemoteAssetBrowseEvent extends CommonEvent
     7| {
     8|     private ?Adapter $adapter = null;
     9|     public function __construct(
    10|         private UnifiedIntegrationInterface $integration,
    11|     ) {
    12|     }
    13|     public function getAdapter(): ?Adapter
    14|     {
    15|         return $this->adapter;
    16|     }
    17|     public function getIntegration(): UnifiedIntegrationInterface
    18|     {
    19|         return $this->integration;
    20|     }
    21|     public function setAdapter(Adapter $adapter): void
    22|     {
    23|         $this->adapter = $adapter;
    24|     }
    25| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/AssetSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\AssetEvents;
     4| use Mautic\AssetBundle\Event as Events;
     5| use Mautic\CoreBundle\Helper\IpLookupHelper;
     6| use Mautic\CoreBundle\Model\AuditLogModel;
     7| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     8| class AssetSubscriber implements EventSubscriberInterface
     9| {
    10|     public function __construct(
    11|         private IpLookupHelper $ipLookupHelper,
    12|         private AuditLogModel $auditLogModel,
    13|     ) {
    14|     }
    15|     public static function getSubscribedEvents(): array
    16|     {
    17|         return [
    18|             AssetEvents::ASSET_POST_SAVE   => ['onAssetPostSave', 0],
    19|             AssetEvents::ASSET_POST_DELETE => ['onAssetDelete', 0],
    20|         ];
    21|     }
    22|     /**
    23|      * Add an entry to the audit log.
    24|      */
    25|     public function onAssetPostSave(Events\AssetEvent $event): void
    26|     {
    27|         $asset = $event->getAsset();
    28|         if ($details = $event->getChanges()) {
    29|             $log = [
    30|                 'bundle'    => 'asset',
    31|                 'object'    => 'asset',
    32|                 'objectId'  => $asset->getId(),
    33|                 'action'    => ($event->isNew()) ? 'create' : 'update',
    34|                 'details'   => $details,
    35|                 'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    36|             ];
    37|             $this->auditLogModel->writeToLog($log);
    38|         }
    39|     }
    40|     /**
    41|      * Add a delete entry to the audit log.
    42|      */
    43|     public function onAssetDelete(Events\AssetEvent $event): void
    44|     {
    45|         $asset = $event->getAsset();
    46|         $log   = [
    47|             'bundle'    => 'asset',
    48|             'object'    => 'asset',
    49|             'objectId'  => $asset->deletedId,
    50|             'action'    => 'delete',
    51|             'details'   => ['name' => $asset->getTitle()],
    52|             'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    53|         ];
    54|         $this->auditLogModel->writeToLog($log);
    55|         $asset->removeUpload();
    56|     }
    57| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/BuilderSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\Helper\TokenHelper;
     4| use Mautic\CoreBundle\Event\BuilderEvent;
     5| use Mautic\CoreBundle\Helper\BuilderTokenHelperFactory;
     6| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     7| use Mautic\EmailBundle\EmailEvents;
     8| use Mautic\EmailBundle\Event\EmailSendEvent;
     9| use Mautic\LeadBundle\Tracker\ContactTracker;
    10| use Mautic\PageBundle\Event\PageDisplayEvent;
    11| use Mautic\PageBundle\PageEvents;
    12| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    13| class BuilderSubscriber implements EventSubscriberInterface
    14| {
    15|     private string $assetToken = '{assetlink=(.*?)}';
    16|     public function __construct(
    17|         private CorePermissions $security,
    18|         private TokenHelper $tokenHelper,
    19|         private ContactTracker $contactTracker,
    20|         private BuilderTokenHelperFactory $builderTokenHelperFactory,
    21|     ) {
    22|     }
    23|     public static function getSubscribedEvents(): array
    24|     {
    25|         return [
    26|             EmailEvents::EMAIL_ON_BUILD   => ['onBuilderBuild', 0],
    27|             EmailEvents::EMAIL_ON_SEND    => ['onEmailGenerate', 0],
    28|             EmailEvents::EMAIL_ON_DISPLAY => ['onEmailGenerate', 0],
    29|             PageEvents::PAGE_ON_BUILD     => ['onBuilderBuild', 0],
    30|             PageEvents::PAGE_ON_DISPLAY   => ['onPageDisplay', 0],
    31|         ];
    32|     }
    33|     public function onBuilderBuild(BuilderEvent $event): void
    34|     {
    35|         if ($event->tokensRequested($this->assetToken)) {
    36|             $tokenHelper = $this->builderTokenHelperFactory->getBuilderTokenHelper('asset');
    37|             $event->addTokensFromHelper($tokenHelper, $this->assetToken, 'title', 'id', true);
    38|         }
    39|     }
    40|     public function onEmailGenerate(EmailSendEvent $event): void
    41|     {
    42|         $lead   = $event->getLead();
    43|         $leadId = (int) (null !== $lead ? $lead['id'] : null);
    44|         $email  = $event->getEmail();
    45|         $tokens = $this->generateTokensFromContent($event, $leadId, $event->getSource(), null === $email ? null : $email->getId());
    46|         $event->addTokens($tokens);
    47|     }
    48|     public function onPageDisplay(PageDisplayEvent $event): void
    49|     {
    50|         if (!$lead = $event->getLead()) {
    51|             $lead = $this->security->isAnonymous() ? $this->contactTracker->getContact() : null;
    52|         }
    53|         $leadId  = $lead ? $lead->getId() : null;
    54|         $page    = $event->getPage();
    55|         $tokens  = $this->generateTokensFromContent($event, $leadId, ['page', $page->getId()]);
    56|         $content = $event->getContent();
    57|         if ([] !== $tokens) {
    58|             $content = str_ireplace(array_keys($tokens), $tokens, $content);
    59|         }
    60|         $event->setContent($content);
    61|     }
    62|     /**
    63|      * @param PageDisplayEvent|EmailSendEvent $event
    64|      * @param array                           $source
    65|      * @param int|null                        $emailId
    66|      *
    67|      * @return mixed[]
    68|      */
    69|     private function generateTokensFromContent($event, ?int $leadId, $source = [], $emailId = null): array
    70|     {
    71|         if ($event instanceof PageDisplayEvent || ($event instanceof EmailSendEvent && $event->shouldAppendClickthrough())) {
    72|             $clickthrough = [
    73|                 'source' => $source,
    74|                 'lead'   => $leadId ?? false,
    75|                 'email'  => $emailId ?? false,
    76|             ];
    77|         }
    78|         return $this->tokenHelper->findAssetTokens($event->getContent(), array_filter($clickthrough ?? []));
    79|     }
    80| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/CampaignSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\AssetEvents;
     4| use Mautic\AssetBundle\Event\AssetLoadEvent;
     5| use Mautic\AssetBundle\Form\Type\CampaignEventAssetDownloadType;
     6| use Mautic\CampaignBundle\CampaignEvents;
     7| use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
     8| use Mautic\CampaignBundle\Event\CampaignExecutionEvent;
     9| use Mautic\CampaignBundle\Executioner\RealTimeExecutioner;
    10| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    11| class CampaignSubscriber implements EventSubscriberInterface
    12| {
    13|     public function __construct(
    14|         private RealTimeExecutioner $realTimeExecutioner,
    15|     ) {
    16|     }
    17|     public static function getSubscribedEvents(): array
    18|     {
    19|         return [
    20|             CampaignEvents::CAMPAIGN_ON_BUILD         => ['onCampaignBuild', 0],
    21|             AssetEvents::ASSET_ON_LOAD                => ['onAssetDownload', 0],
    22|             AssetEvents::ON_CAMPAIGN_TRIGGER_DECISION => ['onCampaignTriggerDecision', 0],
    23|         ];
    24|     }
    25|     public function onCampaignBuild(CampaignBuilderEvent $event): void
    26|     {
    27|         $trigger = [
    28|             'label'          => 'mautic.asset.campaign.event.download',
    29|             'description'    => 'mautic.asset.campaign.event.download_descr',
    30|             'eventName'      => AssetEvents::ON_CAMPAIGN_TRIGGER_DECISION,
    31|             'formType'       => CampaignEventAssetDownloadType::class,
    32|             'channel'        => 'asset',
    33|             'channelIdField' => 'assets',
    34|         ];
    35|         $event->addDecision('asset.download', $trigger);
    36|     }
    37|     /**
    38|      * Trigger point actions for asset download.
    39|      */
    40|     public function onAssetDownload(AssetLoadEvent $event): void
    41|     {
    42|         $asset = $event->getRecord()->getAsset();
    43|         if (null !== $asset) {
    44|             $this->realTimeExecutioner->execute('asset.download', $asset, 'asset', $asset->getId());
    45|         }
    46|     }
    47|     public function onCampaignTriggerDecision(CampaignExecutionEvent $event)
    48|     {
    49|         $eventDetails = $event->getEventDetails();
    50|         if (null == $eventDetails) {
    51|             return $event->setResult(true);
    52|         }
    53|         $assetId       = $eventDetails->getId();
    54|         $limitToAssets = $event->getConfig()['assets'];
    55|         if (!empty($limitToAssets) && !in_array($assetId, $limitToAssets)) {
    56|             return $event->setResult(false);
    57|         }
    58|         $event->setResult(true);
    59|     }
    60| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/DashboardSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-147 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\Model\AssetModel;
     4| use Mautic\DashboardBundle\Event\WidgetDetailEvent;
     5| use Mautic\DashboardBundle\EventListener\DashboardSubscriber as MainDashboardSubscriber;
     6| use Symfony\Component\Routing\RouterInterface;
     7| class DashboardSubscriber extends MainDashboardSubscriber
     8| {
     9|     /**
    10|      * Define the name of the bundle/category of the widget(s).
    11|      *
    12|      * @var string
    13|      */
    14|     protected $bundle = 'asset';
    15|     /**
    16|      * Define the widget(s).
    17|      *
    18|      * @var array
    19|      */
    20|     protected $types = [
    21|         'asset.downloads.in.time'        => [],
    22|         'unique.vs.repetitive.downloads' => [],
    23|         'popular.assets'                 => [],
    24|         'created.assets'                 => [],
    25|     ];
    26|     /**
    27|      * Define permissions to see those widgets.
    28|      *
    29|      * @var array
    30|      */
    31|     protected $permissions = [
    32|         'asset:assets:viewown',
    33|         'asset:assets:viewother',
    34|     ];
    35|     public function __construct(
    36|         protected AssetModel $assetModel,
    37|         protected RouterInterface $router,
    38|     ) {
    39|     }
    40|     /**
    41|      * Set a widget detail when needed.
    42|      */
    43|     public function onWidgetDetailGenerate(WidgetDetailEvent $event): void
    44|     {
    45|         $this->checkPermissions($event);
    46|         $canViewOthers = $event->hasPermission('asset:assets:viewother');
    47|         if ('asset.downloads.in.time' == $event->getType()) {
    48|             $widget = $event->getWidget();
    49|             $params = $widget->getParams();
    50|             if (!$event->isCached()) {
    51|                 $event->setTemplateData([
    52|                     'chartType'   => 'line',
    53|                     'chartHeight' => $widget->getHeight() - 80,
    54|                     'chartData'   => $this->assetModel->getDownloadsLineChartData(
    55|                         $params['timeUnit'],
    56|                         $params['dateFrom'],
    57|                         $params['dateTo'],
    58|                         $params['dateFormat'],
    59|                         $canViewOthers
    60|                     ),
    61|                 ]);
    62|             }
    63|             $event->setTemplate('@MauticCore/Helper/chart.html.twig');
    64|             $event->stopPropagation();
    65|         }
    66|         if ('unique.vs.repetitive.downloads' == $event->getType()) {
    67|             if (!$event->isCached()) {
    68|                 $params = $event->getWidget()->getParams();
    69|                 $event->setTemplateData([
    70|                     'chartType'   => 'pie',
    71|                     'chartHeight' => $event->getWidget()->getHeight() - 80,
    72|                     'chartData'   => $this->assetModel->getUniqueVsRepetitivePieChartData($params['dateFrom'], $params['dateTo'], $canViewOthers),
    73|                 ]);
    74|             }
    75|             $event->setTemplate('@MauticCore/Helper/chart.html.twig');
    76|             $event->stopPropagation();
    77|         }
    78|         if ('popular.assets' == $event->getType()) {
    79|             if (!$event->isCached()) {
    80|                 $params = $event->getWidget()->getParams();
    81|                 if (empty($params['limit'])) {
    82|                     $limit = round((($event->getWidget()->getHeight() - 80) / 35) - 1);
    83|                 } else {
    84|                     $limit = $params['limit'];
    85|                 }
    86|                 $assets = $this->assetModel->getPopularAssets($limit, $params['dateFrom'], $params['dateTo'], $canViewOthers);
    87|                 $items  = [];
    88|                 foreach ($assets as &$asset) {
    89|                     $assetUrl = $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $asset['id']]);
    90|                     $row      = [
    91|                         [
    92|                             'value' => $asset['title'],
    93|                             'type'  => 'link',
    94|                             'link'  => $assetUrl,
    95|                         ],
    96|                         [
    97|                             'value' => $asset['download_count'],
    98|                         ],
    99|                     ];
   100|                     $items[] = $row;
   101|                 }
   102|                 $event->setTemplateData([
   103|                     'headItems' => [
   104|                         'mautic.dashboard.label.title',
   105|                         'mautic.dashboard.label.downloads',
   106|                     ],
   107|                     'bodyItems' => $items,
   108|                     'raw'       => $assets,
   109|                 ]);
   110|             }
   111|             $event->setTemplate('@MauticCore/Helper/table.html.twig');
   112|             $event->stopPropagation();
   113|         }
   114|         if ('created.assets' == $event->getType()) {
   115|             if (!$event->isCached()) {
   116|                 $params = $event->getWidget()->getParams();
   117|                 if (empty($params['limit'])) {
   118|                     $limit = round((($event->getWidget()->getHeight() - 80) / 35) - 1);
   119|                 } else {
   120|                     $limit = $params['limit'];
   121|                 }
   122|                 $assets = $this->assetModel->getAssetList($limit, $params['dateFrom'], $params['dateTo'], [], ['canViewOthers' => $canViewOthers]);
   123|                 $items  = [];
   124|                 foreach ($assets as &$asset) {
   125|                     $assetUrl = $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $asset['id']]);
   126|                     $row      = [
   127|                         [
   128|                             'value' => $asset['name'],
   129|                             'type'  => 'link',
   130|                             'link'  => $assetUrl,
   131|                         ],
   132|                     ];
   133|                     $items[] = $row;
   134|                 }
   135|                 $event->setTemplateData([
   136|                     'headItems' => [
   137|                         'mautic.dashboard.label.title',
   138|                     ],
   139|                     'bodyItems' => $items,
   140|                     'raw'       => $assets,
   141|                 ]);
   142|             }
   143|             $event->setTemplate('@MauticCore/Helper/table.html.twig');
   144|             $event->stopPropagation();
   145|         }
   146|     }
   147| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/DetermineWinnerSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-96 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Doctrine\ORM\EntityManagerInterface;
     4| use Mautic\AssetBundle\AssetEvents;
     5| use Mautic\AssetBundle\Entity\Download;
     6| use Mautic\CoreBundle\Event\DetermineWinnerEvent;
     7| use Mautic\EmailBundle\Entity\Email;
     8| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     9| use Symfony\Contracts\Translation\TranslatorInterface;
    10| class DetermineWinnerSubscriber implements EventSubscriberInterface
    11| {
    12|     public function __construct(
    13|         private EntityManagerInterface $em,
    14|         private TranslatorInterface $translator,
    15|     ) {
    16|     }
    17|     public static function getSubscribedEvents(): array
    18|     {
    19|         return [
    20|             AssetEvents::ON_DETERMINE_DOWNLOAD_RATE_WINNER => ['onDetermineDownloadRateWinner', 0],
    21|         ];
    22|     }
    23|     /**
    24|      * Determines the winner of A/B test based on number of asset downloads.
    25|      */
    26|     public function onDetermineDownloadRateWinner(DetermineWinnerEvent $event): void
    27|     {
    28|         $repo       = $this->em->getRepository(Download::class);
    29|         $parameters = $event->getParameters();
    30|         $parent     = $parameters['parent'];
    31|         $children   = $parameters['children'];
    32|         $type = ($parent instanceof Email) ? 'email' : 'page';
    33|         $ids = [$parent->getId()];
    34|         foreach ($children as $c) {
    35|             if ($c->isPublished()) {
    36|                 $id    = $c->getId();
    37|                 $ids[] = $id;
    38|             }
    39|         }
    40|         $startDate = $parent->getVariantStartDate();
    41|         if (null != $startDate && !empty($ids)) {
    42|             $counts = ('page' == $type) ? $repo->getDownloadCountsByPage($ids, $startDate) : $repo->getDownloadCountsByEmail($ids, $startDate);
    43|             $translator = $this->translator;
    44|             if ($counts) {
    45|                 $downloads  = $support  = $data  = [];
    46|                 $hasResults = [];
    47|                 $downloadsLabel = $translator->trans('mautic.asset.abtest.label.downloads');
    48|                 $hitsLabel      = ('page' == $type) ? $translator->trans('mautic.asset.abtest.label.hits') : $translator->trans('mautic.asset.abtest.label.sentemils');
    49|                 foreach ($counts as $stats) {
    50|                     $rate                    = ($stats['total']) ? round(($stats['count'] / $stats['total']) * 100, 2) : 0;
    51|                     $downloads[$stats['id']] = $rate;
    52|                     $data[$downloadsLabel][] = $stats['count'];
    53|                     $data[$hitsLabel][]      = $stats['total'];
    54|                     $support['labels'][]     = $stats['id'].':'.$stats['name'].' ('.$rate.'%)';
    55|                     $hasResults[]            = $stats['id'];
    56|                 }
    57|                 if (!in_array($parent->getId(), $hasResults)) {
    58|                     $data[$downloadsLabel][] = 0;
    59|                     $data[$hitsLabel][]      = 0;
    60|                     $support['labels'][]     = $parent->getId().':'.(('page' == $type) ? $parent->getTitle() : $parent->getName()).' (0%)';
    61|                 }
    62|                 foreach ($children as $c) {
    63|                     if ($c->isPublished()) {
    64|                         if (!in_array($c->getId(), $hasResults)) {
    65|                             $data[$downloadsLabel][] = 0;
    66|                             $data[$hitsLabel][]      = 0;
    67|                             $support['labels'][]     = $c->getId().':'.(('page' == $type) ? $c->getTitle() : $c->getName()).' (0%)';
    68|                         }
    69|                     }
    70|                 }
    71|                 $support['data'] = $data;
    72|                 $maxes = [];
    73|                 foreach ($support['data'] as $data) {
    74|                     $maxes[] = max($data);
    75|                 }
    76|                 $top                   = max($maxes);
    77|                 $support['step_width'] = (ceil($top / 10) * 10);
    78|                 asort($downloads);
    79|                 $max = max($downloads);
    80|                 $winners = ($max > 0) ? array_keys($downloads, $max) : [];
    81|                 $event->setAbTestResults([
    82|                     'winners'         => $winners,
    83|                     'support'         => $support,
    84|                     'basedOn'         => 'asset.downloads',
    85|                     'supportTemplate' => '@MauticPage/SubscribedEvents/AbTest/bargraph.html.twig',
    86|                 ]);
    87|                 return;
    88|             }
    89|         }
    90|         $event->setAbTestResults([
    91|             'winners' => [],
    92|             'support' => [],
    93|             'basedOn' => 'asset.downloads',
    94|         ]);
    95|     }
    96| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/FormSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-133 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Doctrine\ORM\NonUniqueResultException;
     4| use Doctrine\ORM\NoResultException;
     5| use Mautic\AssetBundle\Entity\Asset;
     6| use Mautic\AssetBundle\Form\Type\FormSubmitActionDownloadFileType;
     7| use Mautic\AssetBundle\Model\AssetModel;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\ThemeHelperInterface;
    10| use Mautic\CoreBundle\Twig\Helper\AnalyticsHelper;
    11| use Mautic\CoreBundle\Twig\Helper\AssetsHelper;
    12| use Mautic\FormBundle\Entity\Form;
    13| use Mautic\FormBundle\Event\FormBuilderEvent;
    14| use Mautic\FormBundle\Event\SubmissionEvent;
    15| use Mautic\FormBundle\FormEvents;
    16| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    17| use Symfony\Component\HttpFoundation\Response;
    18| use Symfony\Contracts\Translation\TranslatorInterface;
    19| use Twig\Environment;
    20| class FormSubscriber implements EventSubscriberInterface
    21| {
    22|     public function __construct(
    23|         private AssetModel $assetModel,
    24|         protected TranslatorInterface $translator,
    25|         private AnalyticsHelper $analyticsHelper,
    26|         private AssetsHelper $assetsHelper,
    27|         private ThemeHelperInterface $themeHelper,
    28|         private Environment $twig,
    29|         private CoreParametersHelper $coreParametersHelper,
    30|     ) {
    31|     }
    32|     public static function getSubscribedEvents(): array
    33|     {
    34|         return [
    35|             FormEvents::FORM_ON_BUILD                 => ['onFormBuilder', 0],
    36|             FormEvents::ON_EXECUTE_SUBMIT_ACTION      => [
    37|                 ['onFormSubmitActionAssetDownload', 0],
    38|                 ['onFormSubmitActionDownloadFile', 0],
    39|             ],
    40|         ];
    41|     }
    42|     /**
    43|      * Add a lead generation action to available form submit actions.
    44|      */
    45|     public function onFormBuilder(FormBuilderEvent $event): void
    46|     {
    47|         $event->addSubmitAction('asset.download', [
    48|             'group'              => 'mautic.asset.actions',
    49|             'label'              => 'mautic.asset.asset.submitaction.downloadfile',
    50|             'description'        => 'mautic.asset.asset.submitaction.downloadfile_descr',
    51|             'formType'           => FormSubmitActionDownloadFileType::class,
    52|             'formTypeCleanMasks' => ['message' => 'html'],
    53|             'eventName'          => FormEvents::ON_EXECUTE_SUBMIT_ACTION,
    54|             'allowCampaignForm'  => true,
    55|             'template'           => '@MauticAsset/Action/asset.html.twig',
    56|         ]);
    57|     }
    58|     public function onFormSubmitActionAssetDownload(SubmissionEvent $event): void
    59|     {
    60|         if (false === $event->checkContext('asset.download')) {
    61|             return;
    62|         }
    63|         $properties = $event->getAction()->getProperties();
    64|         $assetId    = $properties['asset'];
    65|         $categoryId = $properties['category'] ?? null;
    66|         $asset      = null;
    67|         if (null !== $assetId) {
    68|             $asset = $this->assetModel->getEntity($assetId);
    69|         } elseif (null !== $categoryId) {
    70|             try {
    71|                 $asset = $this->assetModel->getRepository()->getLatestAssetForCategory($categoryId);
    72|             } catch (NoResultException|NonUniqueResultException) {
    73|                 $asset = null;
    74|             }
    75|         }
    76|         if ($asset instanceof Asset && $asset->isPublished()) {
    77|             $event->setPostSubmitCallback('asset.download_file', [
    78|                 'eventName' => FormEvents::ON_EXECUTE_SUBMIT_ACTION,
    79|                 'form'      => $event->getAction()->getForm(),
    80|                 'asset'     => $asset,
    81|                 'message'   => $properties['message'] ?? '',
    82|             ]);
    83|         }
    84|     }
    85|     public function onFormSubmitActionDownloadFile(SubmissionEvent $event): void
    86|     {
    87|         if (false === $event->checkContext('asset.download_file')) {
    88|             return;
    89|         }
    90|         /*
    91|          * No further actions can run after this, as we need to send the
    92|          * download response to the client.
    93|          */
    94|         $event->stopPropagation();
    95|         /**
    96|          * @var Form   $form
    97|          * @var Asset  $asset
    98|          * @var string $message
    99|          * @var bool   $messengerMode
   100|          */
   101|         [
   102|             'form'          => $form,
   103|             'asset'         => $asset,
   104|             'message'       => $message,
   105|             'messengerMode' => $messengerMode,
   106|         ]    = $event->getPostSubmitCallback('asset.download_file');
   107|         $url = $this->assetModel->generateUrl($asset, true, [
   108|             'lead'    => $event->getLead() ? $event->getLead()->getId() : null,
   109|             'channel' => ['form' => $form->getId()],
   110|         ]).'&stream=0';
   111|         if ($messengerMode) {
   112|             $event->setPostSubmitResponse(['download' => $url]);
   113|             return;
   114|         }
   115|         $msg = $message.$this->translator->trans('mautic.asset.asset.submitaction.downloadfile.msg', [
   116|             '%url%' => $url,
   117|         ]);
   118|         $analytics = $this->analyticsHelper->getCode();
   119|         if (!empty($analytics)) {
   120|             $this->assetsHelper->addCustomDeclaration($analytics);
   121|         }
   122|         $event->setPostSubmitResponse(new Response(
   123|             $this->twig->render(
   124|                 $this->themeHelper->checkForTwigTemplate('@themes/'.$this->coreParametersHelper->get('theme').'/html/message.html.twig'),
   125|                 [
   126|                     'message'  => $msg,
   127|                     'type'     => 'notice',
   128|                     'template' => $this->coreParametersHelper->get('theme'),
   129|                 ]
   130|             )
   131|         ));
   132|     }
   133| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/LeadSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\Entity\DownloadRepository;
     4| use Mautic\AssetBundle\Model\AssetModel;
     5| use Mautic\LeadBundle\Event\LeadChangeEvent;
     6| use Mautic\LeadBundle\Event\LeadMergeEvent;
     7| use Mautic\LeadBundle\Event\LeadTimelineEvent;
     8| use Mautic\LeadBundle\LeadEvents;
     9| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    10| use Symfony\Component\Routing\RouterInterface;
    11| use Symfony\Contracts\Translation\TranslatorInterface;
    12| class LeadSubscriber implements EventSubscriberInterface
    13| {
    14|     public function __construct(
    15|         private AssetModel $assetModel,
    16|         private TranslatorInterface $translator,
    17|         private RouterInterface $router,
    18|         private DownloadRepository $downloadRepository,
    19|     ) {
    20|     }
    21|     public static function getSubscribedEvents(): array
    22|     {
    23|         return [
    24|             LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
    25|             LeadEvents::CURRENT_LEAD_CHANGED => ['onLeadChange', 0],
    26|             LeadEvents::LEAD_POST_MERGE      => ['onLeadMerge', 0],
    27|         ];
    28|     }
    29|     /**
    30|      * Compile events for the lead timeline.
    31|      */
    32|     public function onTimelineGenerate(LeadTimelineEvent $event): void
    33|     {
    34|         $eventTypeKey  = 'asset.download';
    35|         $eventTypeName = $this->translator->trans('mautic.asset.event.download');
    36|         $event->addEventType($eventTypeKey, $eventTypeName);
    37|         $event->addSerializerGroup('assetList');
    38|         if (!$event->isApplicable($eventTypeKey)) {
    39|             return;
    40|         }
    41|         $downloads = $this->downloadRepository->getLeadDownloads($event->getLeadId(), $event->getQueryOptions());
    42|         $event->addToCounter($eventTypeKey, $downloads);
    43|         if (!$event->isEngagementCount()) {
    44|             foreach ($downloads['results'] as $download) {
    45|                 $asset = $this->assetModel->getEntity($download['asset_id']);
    46|                 $event->addEvent(
    47|                     [
    48|                         'event'      => $eventTypeKey,
    49|                         'eventId'    => $eventTypeKey.$download['download_id'],
    50|                         'eventLabel' => [
    51|                             'label' => $download['title'],
    52|                             'href'  => $this->router->generate('mautic_asset_action', ['objectAction' => 'view', 'objectId' => $download['asset_id']]),
    53|                         ],
    54|                         'extra' => [
    55|                             'asset'            => $asset,
    56|                             'assetDownloadUrl' => $this->assetModel->generateUrl($asset),
    57|                         ],
    58|                         'eventType'       => $eventTypeName,
    59|                         'timestamp'       => $download['dateDownload'],
    60|                         'icon'            => 'ri-download-line',
    61|                         'contentTemplate' => '@MauticAsset/SubscribedEvents/Timeline/index.html.twig',
    62|                         'contactId'       => $download['lead_id'],
    63|                     ]
    64|                 );
    65|             }
    66|         }
    67|     }
    68|     public function onLeadChange(LeadChangeEvent $event): void
    69|     {
    70|         $this->assetModel->getDownloadRepository()->updateLeadByTrackingId(
    71|             $event->getNewLead()->getId(),
    72|             $event->getNewTrackingId(),
    73|             $event->getOldTrackingId()
    74|         );
    75|     }
    76|     public function onLeadMerge(LeadMergeEvent $event): void
    77|     {
    78|         $this->assetModel->getDownloadRepository()->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
    79|     }
    80| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/PointSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\AssetEvents;
     4| use Mautic\AssetBundle\Event\AssetLoadEvent;
     5| use Mautic\AssetBundle\Form\Type\PointActionAssetDownloadType;
     6| use Mautic\PointBundle\Event\PointBuilderEvent;
     7| use Mautic\PointBundle\Model\PointModel;
     8| use Mautic\PointBundle\PointEvents;
     9| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    10| class PointSubscriber implements EventSubscriberInterface
    11| {
    12|     public function __construct(
    13|         private PointModel $pointModel,
    14|     ) {
    15|     }
    16|     public static function getSubscribedEvents(): array
    17|     {
    18|         return [
    19|             PointEvents::POINT_ON_BUILD => ['onPointBuild', 0],
    20|             AssetEvents::ASSET_ON_LOAD  => ['onAssetDownload', 0],
    21|         ];
    22|     }
    23|     public function onPointBuild(PointBuilderEvent $event): void
    24|     {
    25|         $action = [
    26|             'group'       => 'mautic.asset.actions',
    27|             'label'       => 'mautic.asset.point.action.download',
    28|             'description' => 'mautic.asset.point.action.download_descr',
    29|             'callback'    => [\Mautic\AssetBundle\Helper\PointActionHelper::class, 'validateAssetDownload'],
    30|             'formType'    => PointActionAssetDownloadType::class,
    31|         ];
    32|         $event->addAction('asset.download', $action);
    33|     }
    34|     /**
    35|      * Trigger point actions for asset download.
    36|      */
    37|     public function onAssetDownload(AssetLoadEvent $event): void
    38|     {
    39|         $asset = $event->getRecord()->getAsset();
    40|         if (null !== $asset) {
    41|             $this->pointModel->triggerAction('asset.download', $asset);
    42|         }
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/ReportSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-231 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\Entity\DownloadRepository;
     4| use Mautic\CoreBundle\Helper\Chart\LineChart;
     5| use Mautic\LeadBundle\Model\CompanyReportData;
     6| use Mautic\ReportBundle\Event\ReportBuilderEvent;
     7| use Mautic\ReportBundle\Event\ReportGeneratorEvent;
     8| use Mautic\ReportBundle\Event\ReportGraphEvent;
     9| use Mautic\ReportBundle\ReportEvents;
    10| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    11| class ReportSubscriber implements EventSubscriberInterface
    12| {
    13|     public const CONTEXT_ASSET          = 'assets';
    14|     public const CONTEXT_ASSET_DOWNLOAD = 'asset.downloads';
    15|     public function __construct(
    16|         private CompanyReportData $companyReportData,
    17|         private DownloadRepository $downloadRepository,
    18|     ) {
    19|     }
    20|     public static function getSubscribedEvents(): array
    21|     {
    22|         return [
    23|             ReportEvents::REPORT_ON_BUILD          => ['onReportBuilder', 0],
    24|             ReportEvents::REPORT_ON_GENERATE       => ['onReportGenerate', 0],
    25|             ReportEvents::REPORT_ON_GRAPH_GENERATE => ['onReportGraphGenerate', 0],
    26|         ];
    27|     }
    28|     /**
    29|      * Add available tables and columns to the report builder lookup.
    30|      */
    31|     public function onReportBuilder(ReportBuilderEvent $event): void
    32|     {
    33|         if (!$event->checkContext([self::CONTEXT_ASSET, self::CONTEXT_ASSET_DOWNLOAD])) {
    34|             return;
    35|         }
    36|         $prefix  = 'a.';
    37|         $columns = [
    38|             $prefix.'download_count' => [
    39|                 'alias' => 'download_count',
    40|                 'label' => 'mautic.asset.report.download_count',
    41|                 'type'  => 'int',
    42|             ],
    43|             $prefix.'unique_download_count' => [
    44|                 'alias' => 'unique_download_count',
    45|                 'label' => 'mautic.asset.report.unique_download_count',
    46|                 'type'  => 'int',
    47|             ],
    48|             $prefix.'alias' => [
    49|                 'label' => 'mautic.core.alias',
    50|                 'type'  => 'string',
    51|             ],
    52|             $prefix.'lang' => [
    53|                 'label' => 'mautic.core.language',
    54|                 'type'  => 'string',
    55|             ],
    56|             $prefix.'title' => [
    57|                 'label' => 'mautic.core.title',
    58|                 'type'  => 'string',
    59|             ],
    60|         ];
    61|         $columns = array_merge(
    62|             $columns,
    63|             $event->getStandardColumns($prefix, ['name'], 'mautic_asset_action'),
    64|             $event->getCategoryColumns()
    65|         );
    66|         $event->addTable(
    67|             self::CONTEXT_ASSET,
    68|             [
    69|                 'display_name' => 'mautic.asset.assets',
    70|                 'columns'      => $columns,
    71|             ]
    72|         );
    73|         if ($event->checkContext([self::CONTEXT_ASSET_DOWNLOAD])) {
    74|             $columns[$prefix.'download_count']['formula']        = 'COUNT(ad.id)';
    75|             $columns[$prefix.'unique_download_count']['formula'] = 'COUNT(DISTINCT ad.lead_id)';
    76|             $downloadPrefix  = 'ad.';
    77|             $downloadColumns = [
    78|                 $downloadPrefix.'date_download' => [
    79|                     'label'          => 'mautic.asset.report.download.date_download',
    80|                     'type'           => 'datetime',
    81|                     'groupByFormula' => 'DATE('.$downloadPrefix.'date_download)',
    82|                 ],
    83|                 $downloadPrefix.'code' => [
    84|                     'label' => 'mautic.asset.report.download.code',
    85|                     'type'  => 'string',
    86|                 ],
    87|                 $downloadPrefix.'referer' => [
    88|                     'label' => 'mautic.core.referer',
    89|                     'type'  => 'string',
    90|                 ],
    91|                 $downloadPrefix.'source' => [
    92|                     'label' => 'mautic.report.field.source',
    93|                     'type'  => 'string',
    94|                 ],
    95|                 $downloadPrefix.'source_id' => [
    96|                     'label' => 'mautic.report.field.source_id',
    97|                     'type'  => 'int',
    98|                 ],
    99|                 $downloadPrefix.'utm_campaign' => [
   100|                     'label' => 'mautic.report.field.utm_campaign',
   101|                     'type'  => 'string',
   102|                 ],
   103|                 $downloadPrefix.'utm_content' => [
   104|                     'label' => 'mautic.report.field.utm_content',
   105|                     'type'  => 'string',
   106|                 ],
   107|                 $downloadPrefix.'utm_medium' => [
   108|                     'label' => 'mautic.report.field.utm_medium',
   109|                     'type'  => 'string',
   110|                 ],
   111|                 $downloadPrefix.'utm_source' => [
   112|                     'label' => 'mautic.report.field.utm_source',
   113|                     'type'  => 'string',
   114|                 ],
   115|                 $downloadPrefix.'utm_term' => [
   116|                     'label' => 'mautic.report.field.utm_term',
   117|                     'type'  => 'string',
   118|                 ],
   119|             ];
   120|             $companyColumns = $this->companyReportData->getCompanyData();
   121|             $event->addTable(
   122|                 self::CONTEXT_ASSET_DOWNLOAD,
   123|                 [
   124|                     'display_name' => 'mautic.asset.report.downloads.table',
   125|                     'columns'      => array_merge(
   126|                         $columns,
   127|                         $downloadColumns,
   128|                         $event->getCampaignByChannelColumns(),
   129|                         $event->getLeadColumns(),
   130|                         $event->getIpColumn(),
   131|                         $companyColumns
   132|                     ),
   133|                 ],
   134|                 self::CONTEXT_ASSET
   135|             );
   136|             $context = self::CONTEXT_ASSET_DOWNLOAD;
   137|             $event->addGraph($context, 'line', 'mautic.asset.graph.line.downloads');
   138|             $event->addGraph($context, 'table', 'mautic.asset.table.most.downloaded');
   139|             $event->addGraph($context, 'table', 'mautic.asset.table.top.referrers');
   140|             $event->addGraph($context, 'pie', 'mautic.asset.graph.pie.statuses', ['translate' => false]);
   141|         }
   142|     }
   143|     /**
   144|      * Initialize the QueryBuilder object to generate reports from.
   145|      */
   146|     public function onReportGenerate(ReportGeneratorEvent $event): void
   147|     {
   148|         if (!$event->checkContext([self::CONTEXT_ASSET, self::CONTEXT_ASSET_DOWNLOAD])) {
   149|             return;
   150|         }
   151|         $queryBuilder = $event->getQueryBuilder();
   152|         if ($event->checkContext(self::CONTEXT_ASSET)) {
   153|             $queryBuilder->from(MAUTIC_TABLE_PREFIX.'assets', 'a');
   154|             $event->addCategoryLeftJoin($queryBuilder, 'a');
   155|         } elseif ($event->checkContext(self::CONTEXT_ASSET_DOWNLOAD)) {
   156|             $event->applyDateFilters($queryBuilder, 'date_download', 'ad');
   157|             $queryBuilder->from(MAUTIC_TABLE_PREFIX.'asset_downloads', 'ad')
   158|                 ->leftJoin('ad', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = ad.asset_id');
   159|             $event->addCategoryLeftJoin($queryBuilder, 'a');
   160|             $event->addLeadLeftJoin($queryBuilder, 'ad');
   161|             $event->addIpAddressLeftJoin($queryBuilder, 'ad');
   162|             $event->addCampaignByChannelJoin($queryBuilder, 'a', 'asset');
   163|             if ($this->companyReportData->eventHasCompanyColumns($event)) {
   164|                 $event->addCompanyLeftJoin($queryBuilder);
   165|             }
   166|             if (!$event->hasGroupBy()) {
   167|                 $queryBuilder->groupBy('ad.id');
   168|             }
   169|         }
   170|         $event->setQueryBuilder($queryBuilder);
   171|     }
   172|     /**
   173|      * Initialize the QueryBuilder object to generate reports from.
   174|      */
   175|     public function onReportGraphGenerate(ReportGraphEvent $event): void
   176|     {
   177|         if (!$event->checkContext(self::CONTEXT_ASSET_DOWNLOAD)) {
   178|             return;
   179|         }
   180|         $graphs = $event->getRequestedGraphs();
   181|         $qb     = $event->getQueryBuilder();
   182|         foreach ($graphs as $g) {
   183|             $options      = $event->getOptions($g);
   184|             $queryBuilder = clone $qb;
   185|             $chartQuery   = clone $options['chartQuery'];
   186|             $chartQuery->applyDateFilters($queryBuilder, 'date_download', 'ad');
   187|             switch ($g) {
   188|                 case 'mautic.asset.graph.line.downloads':
   189|                     $chart = new LineChart(null, $options['dateFrom'], $options['dateTo']);
   190|                     $chartQuery->modifyTimeDataQuery($queryBuilder, 'date_download', 'ad');
   191|                     $downloads = $chartQuery->loadAndBuildTimeData($queryBuilder);
   192|                     $chart->setDataset($options['translator']->trans($g), $downloads);
   193|                     $data         = $chart->render();
   194|                     $data['name'] = $g;
   195|                     $event->setGraph($g, $data);
   196|                     break;
   197|                 case 'mautic.asset.table.most.downloaded':
   198|                     $limit                  = 10;
   199|                     $offset                 = 0;
   200|                     $items                  = $this->downloadRepository->getMostDownloaded($queryBuilder, $limit, $offset);
   201|                     $graphData              = [];
   202|                     $graphData['data']      = $items;
   203|                     $graphData['name']      = $g;
   204|                     $graphData['iconClass'] = 'ri-download-line';
   205|                     $graphData['link']      = 'mautic_asset_action';
   206|                     $event->setGraph($g, $graphData);
   207|                     break;
   208|                 case 'mautic.asset.table.top.referrers':
   209|                     $limit                  = 10;
   210|                     $offset                 = 0;
   211|                     $items                  = $this->downloadRepository->getTopReferrers($queryBuilder, $limit, $offset);
   212|                     $graphData              = [];
   213|                     $graphData['data']      = $items;
   214|                     $graphData['name']      = $g;
   215|                     $graphData['iconClass'] = 'ri-download-line';
   216|                     $graphData['link']      = 'mautic_asset_action';
   217|                     $event->setGraph($g, $graphData);
   218|                     break;
   219|                 case 'mautic.asset.graph.pie.statuses':
   220|                     $items                  = $this->downloadRepository->getHttpStatuses($queryBuilder);
   221|                     $graphData              = [];
   222|                     $graphData['data']      = $items;
   223|                     $graphData['name']      = $g;
   224|                     $graphData['iconClass'] = 'ri-earth-line';
   225|                     $event->setGraph($g, $graphData);
   226|                     break;
   227|             }
   228|             unset($queryBuilder);
   229|         }
   230|     }
   231| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/SearchSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\AssetBundle\EventListener;
     4| use Mautic\AssetBundle\Model\AssetModel;
     5| use Mautic\CoreBundle\CoreEvents;
     6| use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
     7| use Mautic\CoreBundle\Event as MauticEvents;
     8| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     9| use Mautic\CoreBundle\Service\GlobalSearch;
    10| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    11| class SearchSubscriber implements EventSubscriberInterface
    12| {
    13|     public function __construct(
    14|         private AssetModel $assetModel,
    15|         private CorePermissions $security,
    16|         private GlobalSearch $globalSearch,
    17|     ) {
    18|     }
    19|     public static function getSubscribedEvents(): array
    20|     {
    21|         return [
    22|             CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
    23|             CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
    24|         ];
    25|     }
    26|     public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
    27|     {
    28|         $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
    29|         $results   = $this->globalSearch->performSearch(
    30|             $filterDTO,
    31|             $this->assetModel,
    32|             '@MauticAsset/SubscribedEvents/Search/global.html.twig'
    33|         );
    34|         if (!empty($results)) {
    35|             $event->addResults('mautic.asset.assets', $results);
    36|         }
    37|     }
    38|     public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
    39|     {
    40|         if ($this->security->isGranted(['asset:assets:viewown', 'asset:assets:viewother'], 'MATCH_ONE')) {
    41|             $event->addCommands(
    42|                 'mautic.asset.assets',
    43|                 $this->assetModel->getCommandList()
    44|             );
    45|         }
    46|     }
    47| }


# ====================================================================
# FILE: app/bundles/AssetBundle/EventListener/UploadSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| <?php
     2| namespace Mautic\AssetBundle\EventListener;
     3| use Mautic\AssetBundle\Model\AssetModel;
     4| use Mautic\CoreBundle\Exception\FileInvalidException;
     5| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     6| use Mautic\CoreBundle\Translation\Translator;
     7| use Mautic\CoreBundle\Validator\FileUploadValidator;
     8| use Oneup\UploaderBundle\Event\PostUploadEvent;
     9| use Oneup\UploaderBundle\Event\ValidationEvent;
    10| use Oneup\UploaderBundle\Uploader\Exception\ValidationException;
    11| use Oneup\UploaderBundle\UploadEvents;
    12| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    13| class UploadSubscriber implements EventSubscriberInterface
    14| {
    15|     public function __construct(
    16|         private CoreParametersHelper $coreParametersHelper,
    17|         private AssetModel $assetModel,
    18|         protected Translator $translator,
    19|         private FileUploadValidator $fileUploadValidator,
    20|     ) {
    21|     }
    22|     public static function getSubscribedEvents(): array
    23|     {
    24|         return [
    25|             UploadEvents::POST_UPLOAD => ['onPostUpload', 0],
    26|             UploadEvents::VALIDATION  => ['onUploadValidation', 0],
    27|         ];
    28|     }
    29|     /**
    30|      * Moves upladed file to temporary directory where it can be found later
    31|      * and all uploaded files in there cleared. Also sets file name to the response.
    32|      */
    33|     public function onPostUpload(PostUploadEvent $event): void
    34|     {
    35|         $request   = $event->getRequest()->request;
    36|         $response  = $event->getResponse();
    37|         $tempId    = basename($request->get('tempId'));
    38|         $file      = $event->getFile();
    39|         $config    = $event->getConfig();
    40|         $uploadDir = $config['storage']['directory'];
    41|         $tmpDir    = $uploadDir.'/tmp/'.$tempId;
    42|         $file->move($tmpDir);
    43|         $response['state']       = 1;
    44|         $response['tmpFileName'] = $file->getBasename();
    45|     }
    46|     /**
    47|      * Validates file before upload.
    48|      *
    49|      * @throws ValidationException
    50|      */
    51|     public function onUploadValidation(ValidationEvent $event): void
    52|     {
    53|         $file       = $event->getFile();
    54|         $mimetypes  = $this->coreParametersHelper->get('allowed_mimetypes');
    55|         $extensions = array_keys($mimetypes);
    56|         $maxSize    = $this->assetModel->getMaxUploadSize('B');
    57|         if (null === $file) {
    58|             return;
    59|         }
    60|         try {
    61|             $this->fileUploadValidator->checkFileSize($file->getSize(), $maxSize, 'mautic.asset.asset.error.file.size');
    62|         } catch (FileInvalidException $e) {
    63|             throw new ValidationException($e->getMessage());
    64|         }
    65|         try {
    66|             $this->fileUploadValidator->checkExtension($file->getExtension(), $extensions, 'mautic.asset.asset.error.file.extension');
    67|         } catch (FileInvalidException $e) {
    68|             throw new ValidationException($e->getMessage());
    69|         }
    70|         try {
    71|             $this->checkMimeType($file->getMimeType(), $mimetypes, 'mautic.asset.asset.error.file.mimetype');
    72|         } catch (FileInvalidException $e) {
    73|             throw new ValidationException($e->getMessage());
    74|         }
    75|     }
    76|     /**
    77|      * @param array<string,string> $allowedMimeTypes
    78|      */
    79|     private function checkMimeType(string $mimeType, array $allowedMimeTypes, string $extensionErrorMsg): void
    80|     {
    81|         if (!in_array(strtolower($mimeType), array_map('strtolower', $allowedMimeTypes), true)) {
    82|             $error = $this->translator->trans($extensionErrorMsg, [
    83|                 '%fileMimetype%' => $mimeType,
    84|                 '%mimetypes%'    => implode(', ', $allowedMimeTypes),
    85|             ], 'validators');
    86|             throw new FileInvalidException($error);
    87|         }
    88|     }
    89| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/AssetListType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Mautic\AssetBundle\Model\AssetModel;
     4| use Mautic\CoreBundle\Helper\UserHelper;
     5| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     6| use Symfony\Component\Form\AbstractType;
     7| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     8| use Symfony\Component\OptionsResolver\OptionsResolver;
     9| /**
    10|  * @extends AbstractType<mixed>
    11|  */
    12| class AssetListType extends AbstractType
    13| {
    14|     public function __construct(
    15|         private CorePermissions $corePermissions,
    16|         private AssetModel $assetModel,
    17|         private UserHelper $userHelper,
    18|     ) {
    19|     }
    20|     public function configureOptions(OptionsResolver $resolver): void
    21|     {
    22|         $resolver->setDefaults([
    23|             'choices'           => $this->getAssetChoices(),
    24|             'placeholder'       => false,
    25|             'expanded'          => false,
    26|             'multiple'          => true,
    27|             'required'          => false,
    28|         ]);
    29|     }
    30|     public function getParent(): ?string
    31|     {
    32|         return ChoiceType::class;
    33|     }
    34|     private function getAssetChoices(): array
    35|     {
    36|         $choices   = [];
    37|         $viewOther = $this->corePermissions->isGranted('asset:assets:viewother');
    38|         $repo      = $this->assetModel->getRepository();
    39|         $repo->setCurrentUser($this->userHelper->getUser());
    40|         $assets = $repo->getAssetList('', 0, 0, $viewOther);
    41|         foreach ($assets as $asset) {
    42|             $choices[$asset['language']][$asset['title']] = $asset['id'];
    43|         }
    44|         ksort($choices);
    45|         return $choices;
    46|     }
    47| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/AssetType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-204 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Mautic\AssetBundle\Entity\Asset;
     4| use Mautic\AssetBundle\Model\AssetModel;
     5| use Mautic\CategoryBundle\Form\Type\CategoryListType;
     6| use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
     7| use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
     8| use Mautic\CoreBundle\Form\Type\ButtonGroupType;
     9| use Mautic\CoreBundle\Form\Type\FormButtonsType;
    10| use Mautic\CoreBundle\Form\Type\PublishDownDateType;
    11| use Mautic\CoreBundle\Form\Type\PublishUpDateType;
    12| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
    13| use Mautic\CoreBundle\Loader\ParameterLoader;
    14| use Symfony\Component\Form\AbstractType;
    15| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
    16| use Symfony\Component\Form\Extension\Core\Type\LocaleType;
    17| use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    18| use Symfony\Component\Form\Extension\Core\Type\TextType;
    19| use Symfony\Component\Form\FormBuilderInterface;
    20| use Symfony\Component\OptionsResolver\OptionsResolver;
    21| use Symfony\Component\Validator\Constraints\Callback;
    22| use Symfony\Component\Validator\Constraints\NotBlank;
    23| use Symfony\Component\Validator\Constraints\Url;
    24| use Symfony\Component\Validator\Context\ExecutionContextInterface;
    25| use Symfony\Contracts\Translation\TranslatorInterface;
    26| /**
    27|  * @extends AbstractType<Asset>
    28|  */
    29| class AssetType extends AbstractType
    30| {
    31|     public function __construct(
    32|         private TranslatorInterface $translator,
    33|         private AssetModel $assetModel,
    34|     ) {
    35|     }
    36|     public function buildForm(FormBuilderInterface $builder, array $options): void
    37|     {
    38|         $builder->addEventSubscriber(new CleanFormSubscriber(['description' => 'html']));
    39|         $builder->addEventSubscriber(new FormExitSubscriber('asset.asset', $options));
    40|         $builder->add('storageLocation', ButtonGroupType::class, [
    41|             'label'   => 'mautic.asset.asset.form.storageLocation',
    42|             'choices' => [
    43|                 'mautic.asset.asset.form.storageLocation.local'  => 'local',
    44|                 'mautic.asset.asset.form.storageLocation.remote' => 'remote',
    45|             ],
    46|             'attr'              => [
    47|                 'onchange' => 'Mautic.changeAssetStorageLocation();',
    48|             ],
    49|         ]);
    50|         $maxUploadSize = $this->assetModel->getMaxUploadSize('', true);
    51|         $builder->add(
    52|             'tempName',
    53|             HiddenType::class,
    54|             [
    55|                 'label'       => $this->translator->trans('mautic.asset.asset.form.file.upload', ['%max%' => $maxUploadSize]),
    56|                 'label_attr'  => ['class' => 'control-label'],
    57|                 'required'    => false,
    58|                 'constraints' => [
    59|                     new Callback([$this, 'validateExtension']),
    60|                 ],
    61|             ]
    62|         );
    63|         $builder->add(
    64|             'originalFileName',
    65|             HiddenType::class,
    66|             [
    67|                 'required'    => false,
    68|                 'constraints' => [
    69|                     new Callback([$this, 'validateExtension']),
    70|                 ],
    71|             ],
    72|         );
    73|         $builder->add(
    74|             'disallow',
    75|             YesNoButtonGroupType::class,
    76|             [
    77|                 'label' => 'mautic.asset.asset.form.disallow.crawlers',
    78|                 'attr'  => [
    79|                     'tooltip'      => 'mautic.asset.asset.form.disallow.crawlers.descr',
    80|                     'data-show-on' => '{"asset_storageLocation_0":"checked"}',
    81|                 ],
    82|                 'data'=> empty($options['data']->getDisallow()) ? false : true,
    83|             ]
    84|         );
    85|         $builder->add(
    86|             'remotePath',
    87|             TextType::class,
    88|             [
    89|                 'label'       => 'mautic.asset.asset.form.remotePath',
    90|                 'label_attr'  => ['class' => 'control-label'],
    91|                 'attr'        => ['class' => 'form-control'],
    92|                 'required'    => false,
    93|                 'constraints' => [
    94|                     new Url(
    95|                         [
    96|                             'message' => 'mautic.asset.validation.error.url',
    97|                         ]
    98|                     ),
    99|                 ],
   100|             ]
   101|         );
   102|         $builder->add(
   103|             'title',
   104|             TextType::class,
   105|             [
   106|                 'label'      => 'mautic.core.title',
   107|                 'label_attr' => ['class' => 'control-label'],
   108|                 'attr'       => ['class' => 'form-control'],
   109|             ]
   110|         );
   111|         $builder->add(
   112|             'alias',
   113|             TextType::class,
   114|             [
   115|                 'label'      => 'mautic.core.alias',
   116|                 'label_attr' => ['class' => 'control-label'],
   117|                 'attr'       => [
   118|                     'class'   => 'form-control',
   119|                     'tooltip' => 'mautic.asset.asset.help.alias',
   120|                 ],
   121|                 'required' => false,
   122|             ]
   123|         );
   124|         $builder->add(
   125|             'description',
   126|             TextareaType::class,
   127|             [
   128|                 'label'      => 'mautic.core.description',
   129|                 'label_attr' => ['class' => 'control-label'],
   130|                 'attr'       => ['class' => 'form-control editor'],
   131|                 'required'   => false,
   132|             ]
   133|         );
   134|         $builder->add(
   135|             'category',
   136|             CategoryListType::class,
   137|             [
   138|                 'bundle' => 'asset',
   139|             ]
   140|         );
   141|         $builder->add('language', LocaleType::class, [
   142|             'label'      => 'mautic.core.language',
   143|             'label_attr' => ['class' => 'control-label'],
   144|             'attr'       => [
   145|                 'class'   => 'form-control',
   146|                 'tooltip' => 'mautic.asset.asset.form.language.help',
   147|             ],
   148|             'required'    => true,
   149|             'constraints' => [
   150|                 new NotBlank(
   151|                     [
   152|                         'message' => 'mautic.core.value.required',
   153|                     ]
   154|                 ),
   155|             ],
   156|         ]);
   157|         $builder->add('isPublished', YesNoButtonGroupType::class, [
   158|             'label' => 'mautic.core.form.available',
   159|         ]);
   160|         $builder->add('publishUp', PublishUpDateType::class);
   161|         $builder->add('publishDown', PublishDownDateType::class);
   162|         $builder->add(
   163|             'tempId',
   164|             HiddenType::class,
   165|             [
   166|                 'required' => false,
   167|             ]
   168|         );
   169|         $builder->add('buttons', FormButtonsType::class, []);
   170|         if (!empty($options['action'])) {
   171|             $builder->setAction($options['action']);
   172|         }
   173|     }
   174|     /**
   175|      * @param Asset|string|null $object
   176|      */
   177|     public function validateExtension($object, ExecutionContextInterface $context): void
   178|     {
   179|         if (empty($object)) {
   180|             return;
   181|         }
   182|         $parameters       = (new ParameterLoader())->getParameterBag();
   183|         $mimeTypesAllowed = $parameters->get('allowed_mimetypes');
   184|         $extensions       = array_keys($mimeTypesAllowed);
   185|         $fileName         = $object;
   186|         if (!is_string($object) && $object instanceof Asset) {
   187|             $fileName = $object->getOriginalFileName();
   188|         }
   189|         $fileExtension    = pathinfo($fileName, PATHINFO_EXTENSION);
   190|         if (!in_array($fileExtension, $extensions, true)) {
   191|             $context->buildViolation('mautic.asset.asset.error.file.extension', [
   192|                 '%fileExtension%'=> $fileExtension,
   193|                 '%extensions%'   => implode(', ', $extensions),
   194|             ])
   195|                 ->atPath('file')
   196|                 ->setTranslationDomain('validators')
   197|                 ->addViolation();
   198|         }
   199|     }
   200|     public function configureOptions(OptionsResolver $resolver): void
   201|     {
   202|         $resolver->setDefaults(['data_class' => Asset::class]);
   203|     }
   204| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/CampaignEventAssetDownloadType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Symfony\Component\Form\AbstractType;
     4| use Symfony\Component\Form\FormBuilderInterface;
     5| /**
     6|  * @extends AbstractType<mixed>
     7|  */
     8| class CampaignEventAssetDownloadType extends AbstractType
     9| {
    10|     public function buildForm(FormBuilderInterface $builder, array $options): void
    11|     {
    12|         $builder->add(
    13|             'assets',
    14|             AssetListType::class,
    15|             [
    16|                 'label'      => 'mautic.asset.campaign.event.assets',
    17|                 'label_attr' => ['class' => 'control-label'],
    18|                 'attr'       => [
    19|                     'class'   => 'form-control',
    20|                     'tooltip' => 'mautic.asset.campaign.event.assets.descr',
    21|                 ],
    22|             ]
    23|         );
    24|     }
    25|     public function getBlockPrefix(): string
    26|     {
    27|         return 'campaignevent_assetdownload';
    28|     }
    29| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-70 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\DataTransformer\ArrayStringTransformer;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\Extension\Core\Type\TextType;
     6| use Symfony\Component\Form\FormBuilderInterface;
     7| use Symfony\Component\Validator\Constraints\NotBlank;
     8| /**
     9|  * @extends AbstractType<mixed>
    10|  */
    11| class ConfigType extends AbstractType
    12| {
    13|     public function buildForm(FormBuilderInterface $builder, array $options): void
    14|     {
    15|         $builder->add(
    16|             'upload_dir',
    17|             TextType::class,
    18|             [
    19|                 'label'      => 'mautic.asset.config.form.upload.dir',
    20|                 'label_attr' => ['class' => 'control-label'],
    21|                 'attr'       => [
    22|                     'class'   => 'form-control',
    23|                     'tooltip' => 'mautic.asset.config.form.upload.dir.tooltip',
    24|                 ],
    25|                 'constraints' => [
    26|                     new NotBlank([
    27|                         'message' => 'mautic.core.value.required',
    28|                     ]),
    29|                 ],
    30|             ]
    31|         );
    32|         $builder->add(
    33|             'max_size',
    34|             TextType::class,
    35|             [
    36|                 'label'      => 'mautic.asset.config.form.max.size',
    37|                 'label_attr' => ['class' => 'control-label'],
    38|                 'attr'       => [
    39|                     'class'   => 'form-control',
    40|                     'tooltip' => 'mautic.asset.config.form.max.size.tooltip',
    41|                 ],
    42|                 'constraints' => [
    43|                     new NotBlank([
    44|                         'message' => 'mautic.core.value.required',
    45|                     ]),
    46|                 ],
    47|             ]
    48|         );
    49|         $arrayStringTransformer = new ArrayStringTransformer();
    50|         $builder->add(
    51|             $builder->create(
    52|                 'allowed_extensions',
    53|                 TextType::class,
    54|                 [
    55|                     'label'      => 'mautic.asset.config.form.allowed.extensions',
    56|                     'label_attr' => ['class' => 'control-label'],
    57|                     'attr'       => [
    58|                         'class'   => 'form-control',
    59|                         'tooltip' => 'mautic.asset.config.form.allowed.extensions.tooltip',
    60|                     ],
    61|                     'required' => false,
    62|                 ]
    63|             )->addViewTransformer($arrayStringTransformer)
    64|         );
    65|     }
    66|     public function getBlockPrefix(): string
    67|     {
    68|         return 'assetconfig';
    69|     }
    70| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/FormSubmitActionDownloadFileType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Mautic\CategoryBundle\Form\Type\CategoryListType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\FormBuilderInterface;
     6| /**
     7|  * @extends AbstractType<mixed>
     8|  */
     9| class FormSubmitActionDownloadFileType extends AbstractType
    10| {
    11|     public function buildForm(FormBuilderInterface $builder, array $options): void
    12|     {
    13|         $builder->add(
    14|             'asset',
    15|             AssetListType::class,
    16|             [
    17|                 'expanded'    => false,
    18|                 'multiple'    => false,
    19|                 'label'       => 'mautic.asset.form.submit.assets',
    20|                 'label_attr'  => ['class' => 'control-label'],
    21|                 'placeholder' => 'mautic.asset.form.submit.latest.category',
    22|                 'required'    => false,
    23|                 'attr'        => [
    24|                     'class'   => 'form-control',
    25|                     'tooltip' => 'mautic.asset.form.submit.assets_descr',
    26|                 ],
    27|             ]
    28|         );
    29|         $builder->add(
    30|             'category',
    31|             CategoryListType::class,
    32|             [
    33|                 'label'         => 'mautic.asset.form.submit.latest.category',
    34|                 'label_attr'    => ['class' => 'control-label'],
    35|                 'placeholder'   => false,
    36|                 'required'      => false,
    37|                 'bundle'        => 'asset',
    38|                 'return_entity' => false,
    39|                 'attr'          => [
    40|                     'class'        => 'form-control',
    41|                     'tooltip'      => 'mautic.asset.form.submit.latest.category_descr',
    42|                     'data-show-on' => '{"formaction_properties_asset":""}',
    43|                 ],
    44|             ]
    45|         );
    46|     }
    47|     public function getBlockPrefix(): string
    48|     {
    49|         return 'asset_submitaction_downloadfile';
    50|     }
    51| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Form/Type/PointActionAssetDownloadType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Form\Type;
     3| use Symfony\Component\Form\AbstractType;
     4| use Symfony\Component\Form\FormBuilderInterface;
     5| /**
     6|  * @extends AbstractType<mixed>
     7|  */
     8| class PointActionAssetDownloadType extends AbstractType
     9| {
    10|     public function buildForm(FormBuilderInterface $builder, array $options): void
    11|     {
    12|         $builder->add(
    13|             'assets',
    14|             AssetListType::class,
    15|             [
    16|                 'expanded'    => false,
    17|                 'multiple'    => true,
    18|                 'label'       => 'mautic.asset.point.action.assets',
    19|                 'label_attr'  => ['class' => 'control-label'],
    20|                 'placeholder' => false,
    21|                 'required'    => false,
    22|                 'attr'        => [
    23|                     'class'   => 'form-control',
    24|                     'tooltip' => 'mautic.asset.point.action.assets.descr',
    25|                 ],
    26|             ]
    27|         );
    28|     }
    29|     public function getBlockPrefix(): string
    30|     {
    31|         return 'pointaction_assetdownload';
    32|     }
    33| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Helper/TokenHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Helper;
     3| use Mautic\AssetBundle\Model\AssetModel;
     4| class TokenHelper
     5| {
     6|     public function __construct(
     7|         protected AssetModel $model,
     8|     ) {
     9|     }
    10|     public function findAssetTokens($content, $clickthrough = []): array
    11|     {
    12|         $tokens = [];
    13|         preg_match_all('/{assetlink=(.*?)}/', $content, $matches);
    14|         foreach ($matches[1] as $key => $assetId) {
    15|             $token = $matches[0][$key];
    16|             if (isset($tokens[$token])) {
    17|                 continue;
    18|             }
    19|             $asset          = $this->model->getEntity($assetId);
    20|             $tokens[$token] = (null !== $asset) ? $this->model->generateUrl($asset, true, $clickthrough) : '';
    21|         }
    22|         return $tokens;
    23|     }
    24| }


# ====================================================================
# FILE: app/bundles/AssetBundle/Model/AssetModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-525 ---
     1| <?php
     2| namespace Mautic\AssetBundle\Model;
     3| use Doctrine\ORM\EntityManager;
     4| use Doctrine\ORM\PersistentCollection;
     5| use Mautic\AssetBundle\AssetEvents;
     6| use Mautic\AssetBundle\Entity\Asset;
     7| use Mautic\AssetBundle\Entity\Download;
     8| use Mautic\AssetBundle\Event\AssetEvent;
     9| use Mautic\AssetBundle\Event\AssetLoadEvent;
    10| use Mautic\AssetBundle\Form\Type\AssetType;
    11| use Mautic\CategoryBundle\Model\CategoryModel;
    12| use Mautic\CoreBundle\Helper\Chart\ChartQuery;
    13| use Mautic\CoreBundle\Helper\Chart\LineChart;
    14| use Mautic\CoreBundle\Helper\Chart\PieChart;
    15| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    16| use Mautic\CoreBundle\Helper\FileHelper;
    17| use Mautic\CoreBundle\Helper\IpLookupHelper;
    18| use Mautic\CoreBundle\Helper\UserHelper;
    19| use Mautic\CoreBundle\Model\FormModel;
    20| use Mautic\CoreBundle\Model\GlobalSearchInterface;
    21| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    22| use Mautic\CoreBundle\Translation\Translator;
    23| use Mautic\EmailBundle\Entity\Email;
    24| use Mautic\LeadBundle\Entity\Lead;
    25| use Mautic\LeadBundle\Model\LeadModel;
    26| use Mautic\LeadBundle\Tracker\ContactTracker;
    27| use Mautic\LeadBundle\Tracker\Factory\DeviceDetectorFactory\DeviceDetectorFactoryInterface;
    28| use Mautic\LeadBundle\Tracker\Service\DeviceCreatorService\DeviceCreatorServiceInterface;
    29| use Mautic\LeadBundle\Tracker\Service\DeviceTrackingService\DeviceTrackingServiceInterface;
    30| use Psr\Log\LoggerInterface;
    31| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    32| use Symfony\Component\Form\FormFactoryInterface;
    33| use Symfony\Component\HttpFoundation\Request;
    34| use Symfony\Component\HttpFoundation\RequestStack;
    35| use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
    36| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    37| use Symfony\Contracts\EventDispatcher\Event;
    38| /**
    39|  * @extends FormModel<Asset>
    40|  */
    41| class AssetModel extends FormModel implements GlobalSearchInterface
    42| {
    43|     /**
    44|      * @var int
    45|      */
    46|     protected $maxAssetSize;
    47|     public function __construct(
    48|         protected LeadModel $leadModel,
    49|         protected CategoryModel $categoryModel,
    50|         private RequestStack $requestStack,
    51|         protected IpLookupHelper $ipLookupHelper,
    52|         private DeviceCreatorServiceInterface $deviceCreatorService,
    53|         private DeviceDetectorFactoryInterface $deviceDetectorFactory,
    54|         private DeviceTrackingServiceInterface $deviceTrackingService,
    55|         private ContactTracker $contactTracker,
    56|         EntityManager $em,
    57|         CorePermissions $security,
    58|         EventDispatcherInterface $dispatcher,
    59|         UrlGeneratorInterface $router,
    60|         Translator $translator,
    61|         UserHelper $userHelper,
    62|         LoggerInterface $logger,
    63|         CoreParametersHelper $coreParametersHelper,
    64|     ) {
    65|         $this->maxAssetSize           = $coreParametersHelper->get('max_size');
    66|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $logger, $coreParametersHelper);
    67|     }
    68|     public function saveEntity($entity, $unlock = true): void
    69|     {
    70|         if (empty($this->inConversion)) {
    71|             $alias = $entity->getAlias();
    72|             if (empty($alias)) {
    73|                 $alias = $entity->getTitle();
    74|             }
    75|             $alias = $this->cleanAlias($alias, '', 0, '-');
    76|             $repo      = $this->getRepository();
    77|             $testAlias = $alias;
    78|             $count     = $repo->checkUniqueAlias($testAlias, $entity);
    79|             $aliasTag  = $count;
    80|             while ($count) {
    81|                 $testAlias = $alias.$aliasTag;
    82|                 $count     = $repo->checkUniqueAlias($testAlias, $entity);
    83|                 ++$aliasTag;
    84|             }
    85|             if ($testAlias != $alias) {
    86|                 $alias = $testAlias;
    87|             }
    88|             $entity->setAlias($alias);
    89|         }
    90|         if (!$entity->isNew()) {
    91|             $revision = $entity->getRevision();
    92|             ++$revision;
    93|             $entity->setRevision($revision);
    94|         }
    95|         parent::saveEntity($entity, $unlock);
    96|     }
    97|     /**
    98|      * @param array $systemEntry
    99|      *
   100|      * @throws \Doctrine\ORM\ORMException
   101|      * @throws \Exception
   102|      */
   103|     public function trackDownload($asset, $request = null, int $code = 200, $systemEntry = []): void
   104|     {
   105|         if (empty($systemEntry) && !$this->security->isAnonymous()) {
   106|             return;
   107|         }
   108|         if (null == $request) {
   109|             $request = $this->requestStack->getCurrentRequest();
   110|         }
   111|         if (!($request instanceof Request)) {
   112|             return;
   113|         }
   114|         $download = new Download();
   115|         $download->setDateDownload(new \DateTime());
   116|         $download->setUtmCampaign($request->get('utm_campaign'));
   117|         $download->setUtmContent($request->get('utm_content'));
   118|         $download->setUtmMedium($request->get('utm_medium'));
   119|         $download->setUtmSource($request->get('utm_source'));
   120|         $download->setUtmTerm($request->get('utm_term'));
   121|         if (empty($systemEntry)) {
   122|             $clickthrough = $request->get('ct', false);
   123|             if (!empty($clickthrough)) {
   124|                 $clickthrough = $this->decodeArrayFromUrl($clickthrough);
   125|                 if (!empty($clickthrough['lead'])) {
   126|                     $lead = $this->leadModel->getEntity($clickthrough['lead']);
   127|                     if (null !== $lead) {
   128|                         $wasTrackedAlready                    = $this->deviceTrackingService->isTracked();
   129|                         $deviceDetector                       = $this->deviceDetectorFactory->create($request->server->get('HTTP_USER_AGENT'));
   130|                         $deviceDetector->parse();
   131|                         $currentDevice                             = $this->deviceCreatorService->getCurrentFromDetector($deviceDetector, $lead);
   132|                         $trackedDevice                             = $this->deviceTrackingService->trackCurrentDevice($currentDevice, false);
   133|                         $trackingId                                = $trackedDevice->getTrackingId();
   134|                         $trackingNewlyGenerated                    = !$wasTrackedAlready;
   135|                         $leadClickthrough                          = true;
   136|                         $this->contactTracker->setTrackedContact($lead);
   137|                     }
   138|                 }
   139|                 if (!empty($clickthrough['channel'])) {
   140|                     if (1 === count($clickthrough['channel'])) {
   141|                         $channelId = reset($clickthrough['channel']);
   142|                         $channel   = key($clickthrough['channel']);
   143|                     } else {
   144|                         $channel   = $clickthrough['channel'][0];
   145|                         $channelId = (int) $clickthrough['channel'][1];
   146|                     }
   147|                     $download->setSource($channel);
   148|                     $download->setSourceId($channelId);
   149|                 } elseif (!empty($clickthrough['source'])) {
   150|                     $download->setSource($clickthrough['source'][0]);
   151|                     $download->setSourceId($clickthrough['source'][1]);
   152|                 }
   153|                 if (!empty($clickthrough['email'])) {
   154|                     $emailRepo = $this->em->getRepository(Email::class);
   155|                     if ($emailEntity = $emailRepo->getEntity($clickthrough['email'])) {
   156|                         $download->setEmail($emailEntity);
   157|                     }
   158|                 }
   159|             }
   160|             if (empty($leadClickthrough)) {
   161|                 $wasTrackedAlready         = $this->deviceTrackingService->isTracked();
   162|                 $lead                      = $this->contactTracker->getContact();
   163|                 $trackedDevice             = $this->deviceTrackingService->getTrackedDevice();
   164|                 $trackingId                = null;
   165|                 $trackingNewlyGenerated    = false;
   166|                 if (null !== $trackedDevice) {
   167|                     $trackingId             = $trackedDevice->getTrackingId();
   168|                     $trackingNewlyGenerated = !$wasTrackedAlready;
   169|                 }
   170|             }
   171|             $download->setLead($lead);
   172|         } else {
   173|             $trackingId = '';
   174|             if (isset($systemEntry['lead'])) {
   175|                 $lead = $systemEntry['lead'];
   176|                 if (!$lead instanceof Lead) {
   177|                     $leadId = is_array($lead) ? $lead['id'] : $lead;
   178|                     $lead   = $this->em->getReference(Lead::class, $leadId);
   179|                 }
   180|                 $download->setLead($lead);
   181|             }
   182|             if (!empty($systemEntry['source'])) {
   183|                 $download->setSource($systemEntry['source'][0]);
   184|                 $download->setSourceId($systemEntry['source'][1]);
   185|             }
   186|             if (isset($systemEntry['email'])) {
   187|                 $email = $systemEntry['email'];
   188|                 if (!$email instanceof Email) {
   189|                     $emailId = is_array($email) ? $email['id'] : $email;
   190|                     $email   = $this->em->getReference(Email::class, $emailId);
   191|                 }
   192|                 $download->setEmail($email);
   193|             }
   194|             if (isset($systemEntry['tracking_id'])) {
   195|                 $trackingId             = $systemEntry['tracking_id'];
   196|                 $trackingNewlyGenerated = false;
   197|             } elseif ($this->security->isAnonymous() && !defined('IN_MAUTIC_CONSOLE')) {
   198|                 $deviceWasTracked       = $this->deviceTrackingService->isTracked();
   199|                 $deviceDetector         = $this->deviceDetectorFactory->create($request->server->get('HTTP_USER_AGENT'));
   200|                 $deviceDetector->parse();
   201|                 $currentDevice          = $this->deviceCreatorService->getCurrentFromDetector($deviceDetector, $lead);
   202|                 $trackedDevice          = $this->deviceTrackingService->trackCurrentDevice($currentDevice, false);
   203|                 $trackingId             = $trackedDevice->getTrackingId();
   204|                 $trackingNewlyGenerated = !$deviceWasTracked;
   205|             }
   206|         }
   207|         $isUnique = true;
   208|         if (!empty($trackingNewlyGenerated)) {
   209|             $isUnique = $trackingNewlyGenerated;
   210|         } elseif (!empty($trackingId)) {
   211|             $isUnique = $this->getDownloadRepository()->isUniqueDownload($asset->getId(), $trackingId);
   212|         }
   213|         $download->setTrackingId($trackingId);
   214|         if (empty($systemEntry)) {
   215|             $download->setAsset($asset);
   216|             $this->getRepository()->upDownloadCount($asset->getId(), 1, $isUnique);
   217|         }
   218|         $ipAddress = $this->ipLookupHelper->getIpAddress();
   219|         $download->setCode($code);
   220|         $download->setIpAddress($ipAddress);
   221|         $download->setReferer($request->server->get('HTTP_REFERER'));
   222|         if ($this->dispatcher->hasListeners(AssetEvents::ASSET_ON_LOAD)) {
   223|             $event = new AssetLoadEvent($download, $isUnique);
   224|             $this->dispatcher->dispatch($event, AssetEvents::ASSET_ON_LOAD);
   225|         }
   226|         try {
   227|             $this->em->persist($download);
   228|             $this->em->flush();
   229|         } catch (\Exception $e) {
   230|             if (MAUTIC_ENV === 'dev') {
   231|                 throw $e;
   232|             } else {
   233|                 error_log($e);
   234|             }
   235|         }
   236|         $this->em->detach($download);
   237|     }
   238|     /**
   239|      * Increase the download count.
   240|      *
   241|      * @param int        $increaseBy
   242|      * @param bool|false $unique
   243|      */
   244|     public function upDownloadCount($asset, $increaseBy = 1, $unique = false): void
   245|     {
   246|         $id = ($asset instanceof Asset) ? $asset->getId() : (int) $asset;
   247|         $this->getRepository()->upDownloadCount($id, $increaseBy, $unique);
   248|     }
   249|     /**
   250|      * @return \Mautic\AssetBundle\Entity\AssetRepository
   251|      */
   252|     public function getRepository()
   253|     {
   254|         return $this->em->getRepository(Asset::class);
   255|     }
   256|     /**
   257|      * @return \Mautic\AssetBundle\Entity\DownloadRepository
   258|      */
   259|     public function getDownloadRepository()
   260|     {
   261|         return $this->em->getRepository(Download::class);
   262|     }
   263|     public function getPermissionBase(): string
   264|     {
   265|         return 'asset:assets';
   266|     }
   267|     public function getNameGetter(): string
   268|     {
   269|         return 'getTitle';
   270|     }
   271|     /**
   272|      * @throws NotFoundHttpException
   273|      */
   274|     public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
   275|     {
   276|         if (!$entity instanceof Asset) {
   277|             throw new MethodNotAllowedHttpException(['Asset']);
   278|         }
   279|         if (!empty($action)) {
   280|             $options['action'] = $action;
   281|         }
   282|         return $formFactory->create(AssetType::class, $entity, $options);
   283|     }
   284|     /**
   285|      * Get a specific entity or generate a new one if id is empty.
   286|      */
   287|     public function getEntity($id = null): ?Asset
   288|     {
   289|         if (null === $id) {
   290|             $entity = new Asset();
   291|         } else {
   292|             $entity = parent::getEntity($id);
   293|         }
   294|         return $entity;
   295|     }
   296|     /**
   297|      * @throws MethodNotAllowedHttpException
   298|      */
   299|     protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
   300|     {
   301|         if (!$entity instanceof Asset) {
   302|             throw new MethodNotAllowedHttpException(['Asset']);
   303|         }
   304|         switch ($action) {
   305|             case 'pre_save':
   306|                 $name = AssetEvents::ASSET_PRE_SAVE;
   307|                 break;
   308|             case 'post_save':
   309|                 $name = AssetEvents::ASSET_POST_SAVE;
   310|                 break;
   311|             case 'pre_delete':
   312|                 $name = AssetEvents::ASSET_PRE_DELETE;
   313|                 break;
   314|             case 'post_delete':
   315|                 $name = AssetEvents::ASSET_POST_DELETE;
   316|                 break;
   317|             default:
   318|                 return null;
   319|         }
   320|         if ($this->dispatcher->hasListeners($name)) {
   321|             if (empty($event)) {
   322|                 $event = new AssetEvent($entity, $isNew);
   323|                 $event->setEntityManager($this->em);
   324|             }
   325|             $this->dispatcher->dispatch($event, $name);
   326|             return $event;
   327|         } else {
   328|             return null;
   329|         }
   330|     }
   331|     /**
   332|      * Get list of entities for autopopulate fields.
   333|      *
   334|      * @return array
   335|      */
   336|     public function getLookupResults($type, $filter = '', $limit = 10)
   337|     {
   338|         $results = [];
   339|         switch ($type) {
   340|             case 'asset':
   341|                 $viewOther = $this->security->isGranted('asset:assets:viewother');
   342|                 $request   = $this->requestStack->getCurrentRequest();
   343|                 $repo      = $this->getRepository();
   344|                 $repo->setCurrentUser($this->userHelper->getUser());
   345|                 if ('mautic_segment_action' === $request->get('_route')
   346|                     && (Request::METHOD_POST === $request->getMethod() || 'edit' === $request->get('objectAction'))
   347|                 ) {
   348|                     $limit = 0;
   349|                 }
   350|                 $results = $repo->getAssetList($filter, $limit, 0, $viewOther);
   351|                 break;
   352|             case 'category':
   353|                 $results = $this->categoryModel->getRepository()->getCategoryList($filter, $limit, 0);
   354|                 break;
   355|         }
   356|         return $results;
   357|     }
   358|     /**
   359|      * Generate url for an asset.
   360|      *
   361|      * @param Asset $entity
   362|      * @param bool  $absolute
   363|      * @param array $clickthrough
   364|      *
   365|      * @return string
   366|      */
   367|     public function generateUrl($entity, $absolute = true, $clickthrough = [])
   368|     {
   369|         $assetSlug = $entity->getId().':'.$entity->getAlias();
   370|         $slugs = [
   371|             'slug' => $assetSlug,
   372|         ];
   373|         return $this->buildUrl('mautic_asset_download', $slugs, $absolute, $clickthrough);
   374|     }
   375|     /**
   376|      * Determine the max upload size based on PHP restrictions and config.
   377|      *
   378|      * @param string     $unit          If '', determine the best unit based on the number
   379|      * @param bool|false $humanReadable Return as a human readable filesize
   380|      *
   381|      * @return float
   382|      */
   383|     public function getMaxUploadSize($unit = 'M', $humanReadable = false)
   384|     {
   385|         $maxAssetSize  = $this->maxAssetSize;
   386|         $maxAssetSize  = (-1 == $maxAssetSize || 0 === $maxAssetSize) ? PHP_INT_MAX : FileHelper::convertMegabytesToBytes($maxAssetSize);
   387|         $maxPostSize   = Asset::getIniValue('post_max_size');
   388|         $maxUploadSize = Asset::getIniValue('upload_max_filesize');
   389|         $memoryLimit   = Asset::getIniValue('memory_limit');
   390|         $maxAllowed    = min(array_filter([$maxAssetSize, $maxPostSize, $maxUploadSize, $memoryLimit]));
   391|         if ($humanReadable) {
   392|             $number = Asset::convertBytesToHumanReadable($maxAllowed);
   393|         } else {
   394|             [$number, $unit] = Asset::convertBytesToUnit($maxAllowed, $unit);
   395|         }
   396|         return $number;
   397|     }
   398|     /**
   399|      * @return int|string
   400|      */
   401|     public function getTotalFilesize($assets)
   402|     {
   403|         $firstAsset = is_array($assets) ? reset($assets) : false;
   404|         if ($assets instanceof PersistentCollection || is_object($firstAsset)) {
   405|             $assetIds = [];
   406|             foreach ($assets as $asset) {
   407|                 $assetIds[] = $asset->getId();
   408|             }
   409|             $assets = $assetIds;
   410|         }
   411|         if (!is_array($assets)) {
   412|             $assets = [$assets];
   413|         }
   414|         if (empty($assets)) {
   415|             return 0;
   416|         }
   417|         $repo = $this->getRepository();
   418|         $size = $repo->getAssetSize($assets);
   419|         if ($size) {
   420|             $size = Asset::convertBytesToHumanReadable($size);
   421|         }
   422|         return $size;
   423|     }
   424|     /**
   425|      * Get line chart data of downloads.
   426|      *
   427|      * @param string|null $unit          {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
   428|      * @param string      $dateFormat
   429|      * @param array       $filter
   430|      * @param bool        $canViewOthers
   431|      */
   432|     public function getDownloadsLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = [], $canViewOthers = true): array
   433|     {
   434|         $chart = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
   435|         $query = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   436|         $q     = $query->prepareTimeDataQuery('asset_downloads', 'date_download', $filter);
   437|         if (!$canViewOthers) {
   438|             $q->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
   439|                 ->andWhere('a.created_by = :userId')
   440|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   441|         }
   442|         $data = $query->loadAndBuildTimeData($q);
   443|         $chart->setDataset($this->translator->trans('mautic.asset.downloadcount'), $data);
   444|         return $chart->render();
   445|     }
   446|     /**
   447|      * Get pie chart data of unique vs repetitive downloads.
   448|      * Repetitive in this case mean if a lead downloaded any of the assets more than once.
   449|      *
   450|      * @param string $dateFrom
   451|      * @param string $dateTo
   452|      * @param array  $filters
   453|      * @param bool   $canViewOthers
   454|      */
   455|     public function getUniqueVsRepetitivePieChartData($dateFrom, $dateTo, $filters = [], $canViewOthers = true): array
   456|     {
   457|         $chart   = new PieChart();
   458|         $query   = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   459|         $allQ    = $query->getCountQuery('asset_downloads', 'id', 'date_download', $filters);
   460|         $uniqueQ = $query->getCountQuery('asset_downloads', 'lead_id', 'date_download', $filters, ['getUnique' => true]);
   461|         if (!$canViewOthers) {
   462|             $allQ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
   463|                 ->andWhere('a.created_by = :userId')
   464|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   465|             $uniqueQ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
   466|                 ->andWhere('a.created_by = :userId')
   467|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   468|         }
   469|         $all    = $query->fetchCount($allQ);
   470|         $unique = $query->fetchCount($uniqueQ);
   471|         $repetitive = $all - $unique;
   472|         $chart->setDataset($this->translator->trans('mautic.asset.unique'), $unique);
   473|         $chart->setDataset($this->translator->trans('mautic.asset.repetitive'), $repetitive);
   474|         return $chart->render();
   475|     }
   476|     /**
   477|      * Get a list of popular (by downloads) assets.
   478|      *
   479|      * @param int    $limit
   480|      * @param string $dateFrom
   481|      * @param string $dateTo
   482|      * @param array  $filters
   483|      * @param bool   $canViewOthers
   484|      */
   485|     public function getPopularAssets($limit = 10, $dateFrom = null, $dateTo = null, $filters = [], $canViewOthers = true): array
   486|     {
   487|         $q = $this->em->getConnection()->createQueryBuilder();
   488|         $q->select('COUNT(DISTINCT t.id) AS download_count, a.id, a.title')
   489|             ->from(MAUTIC_TABLE_PREFIX.'asset_downloads', 't')
   490|             ->join('t', MAUTIC_TABLE_PREFIX.'assets', 'a', 'a.id = t.asset_id')
   491|             ->orderBy('download_count', 'DESC')
   492|             ->groupBy('a.id')
   493|             ->setMaxResults($limit);
   494|         if (!$canViewOthers) {
   495|             $q->andWhere('a.created_by = :userId')
   496|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   497|         }
   498|         $chartQuery = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   499|         $chartQuery->applyFilters($q, $filters);
   500|         $chartQuery->applyDateFilters($q, 'date_download');
   501|         return $q->executeQuery()->fetchAllAssociative();
   502|     }
   503|     /**
   504|      * Get a list of assets in a date range.
   505|      *
   506|      * @param int   $limit
   507|      * @param array $filters
   508|      * @param array $options
   509|      */
   510|     public function getAssetList($limit = 10, \DateTime $dateFrom = null, \DateTime $dateTo = null, $filters = [], $options = []): array
   511|     {
   512|         $q = $this->em->getConnection()->createQueryBuilder();
   513|         $q->select('t.id, t.title as name, t.date_added, t.date_modified')
   514|             ->from(MAUTIC_TABLE_PREFIX.'assets', 't')
   515|             ->setMaxResults($limit);
   516|         if (!empty($options['canViewOthers'])) {
   517|             $q->andWhere('t.created_by = :userId')
   518|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   519|         }
   520|         $chartQuery = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   521|         $chartQuery->applyFilters($q, $filters);
   522|         $chartQuery->applyDateFilters($q, 'date_added');
   523|         return $q->executeQuery()->fetchAllAssociative();
   524|     }
   525| }


# ====================================================================
# FILE: app/bundles/CacheBundle/Cache/CacheProvider.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-135 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CacheBundle\Cache;
     4| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     5| use Psr\Cache\CacheItemInterface;
     6| use Psr\Cache\InvalidArgumentException as Psr6CacheInterface;
     7| use Symfony\Component\Cache\Adapter\TagAwareAdapterInterface;
     8| use Symfony\Component\Cache\CacheItem;
     9| use Symfony\Component\Cache\Exception\InvalidArgumentException;
    10| use Symfony\Component\Cache\Psr16Cache;
    11| use Symfony\Component\DependencyInjection\ContainerInterface;
    12| /**
    13|  * Povides caching mechanism using adapters, it provides both PSR-6 and PSR-16.
    14|  */
    15| final class CacheProvider implements CacheProviderInterface
    16| {
    17|     private ?Psr16Cache $psr16 = null;
    18|     public function __construct(
    19|         private CoreParametersHelper $coreParametersHelper,
    20|         private ContainerInterface $container,
    21|     ) {
    22|     }
    23|     public function getCacheAdapter(): TagAwareAdapterInterface
    24|     {
    25|         $selectedAdapter = $this->coreParametersHelper->get('cache_adapter');
    26|         if (!$selectedAdapter || !$this->container->has($selectedAdapter)) {
    27|             throw new InvalidArgumentException('Requested cache adapter "'.$selectedAdapter.'" is not available');
    28|         }
    29|         $adaptor = $this->container->get($selectedAdapter);
    30|         if (!$adaptor instanceof TagAwareAdapterInterface) {
    31|             throw new InvalidArgumentException(sprintf('Requested cache adapter "%s" is not a %s', $selectedAdapter, TagAwareAdapterInterface::class));
    32|         }
    33|         return $adaptor;
    34|     }
    35|     public function getSimpleCache(): Psr16Cache
    36|     {
    37|         if (is_null($this->psr16)) {
    38|             $this->psr16 = new Psr16Cache($this->getCacheAdapter());
    39|         }
    40|         return $this->psr16;
    41|     }
    42|     /**
    43|      * @param string $key
    44|      *
    45|      * @throws Psr6CacheInterface
    46|      */
    47|     public function getItem($key): CacheItem
    48|     {
    49|         return $this->getCacheAdapter()->getItem($key);
    50|     }
    51|     /**
    52|      * @return CacheItem[]|\Traversable
    53|      *
    54|      * @throws Psr6CacheInterface
    55|      */
    56|     public function getItems(array $keys = []): \Traversable
    57|     {
    58|         return $this->getCacheAdapter()->getItems($keys);
    59|     }
    60|     /**
    61|      * @param string $key
    62|      *
    63|      * @throws Psr6CacheInterface
    64|      */
    65|     public function hasItem($key): bool
    66|     {
    67|         return $this->getCacheAdapter()->hasItem($key);
    68|     }
    69|     public function clear(string $prefix = ''): bool
    70|     {
    71|         return $this->getCacheAdapter()->clear($prefix);
    72|     }
    73|     public function deleteItem($key): bool
    74|     {
    75|         return $this->getCacheAdapter()->deleteItem($key);
    76|     }
    77|     /**
    78|      * Removes multiple items from the pool.
    79|      *
    80|      * @param string[] $keys An array of keys that should be removed from the pool
    81|      *
    82|      * @return bool True if the items were successfully removed. False if there was an error.
    83|      *
    84|      * @throws Psr6CacheInterface If any of the keys in $keys are not a legal value a \Psr\Cache\InvalidArgumentException
    85|      *                            MUST be thrown
    86|      */
    87|     public function deleteItems(array $keys): bool
    88|     {
    89|         return $this->getCacheAdapter()->deleteItems($keys);
    90|     }
    91|     /**
    92|      * Persists a cache item immediately.
    93|      *
    94|      * @param CacheItemInterface $item The cache item to save
    95|      *
    96|      * @return bool True if the item was successfully persisted. False if there was an error.
    97|      */
    98|     public function save(CacheItemInterface $item): bool
    99|     {
   100|         return $this->getCacheAdapter()->save($item);
   101|     }
   102|     /**
   103|      * Sets a cache item to be persisted later.
   104|      *
   105|      * @param CacheItemInterface $item The cache item to save
   106|      *
   107|      * @return bool False if the item could not be queued or if a commit was attempted and failed. True otherwise.
   108|      */
   109|     public function saveDeferred(CacheItemInterface $item): bool
   110|     {
   111|         return $this->getCacheAdapter()->saveDeferred($item);
   112|     }
   113|     /**
   114|      * Persists any deferred cache items.
   115|      *
   116|      * @return bool True if all not-yet-saved items were successfully saved or there were none. False otherwise.
   117|      */
   118|     public function commit(): bool
   119|     {
   120|         return $this->getCacheAdapter()->commit();
   121|     }
   122|     /**
   123|      * Invalidates cached items using tags.
   124|      *
   125|      * @param string[] $tags An array of tags to invalidate
   126|      *
   127|      * @return bool True on success
   128|      *
   129|      * @throws Psr6CacheInterface When $tags is not valid
   130|      */
   131|     public function invalidateTags(array $tags): bool
   132|     {
   133|         return $this->getCacheAdapter()->invalidateTags($tags);
   134|     }
   135| }


# ====================================================================
# FILE: app/bundles/CacheBundle/Command/ClearCacheCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CacheBundle\Command;
     4| use Mautic\CacheBundle\Cache\CacheProviderInterface;
     5| use Symfony\Component\Console\Command\Command;
     6| use Symfony\Component\Console\Input\InputInterface;
     7| use Symfony\Component\Console\Output\OutputInterface;
     8| /**
     9|  * CLI Command to clear the application cache.
    10|  */
    11| class ClearCacheCommand extends Command
    12| {
    13|     public function __construct(
    14|         private CacheProviderInterface $cacheProvider,
    15|     ) {
    16|         parent::__construct();
    17|     }
    18|     protected function configure(): void
    19|     {
    20|         $this->setName('mautic:cache:clear');
    21|     }
    22|     protected function execute(InputInterface $input, OutputInterface $output): int
    23|     {
    24|         return (int) !$this->cacheProvider->clear();
    25|     }
    26|     protected static $defaultDescription = 'Clears Mautic\'s cache';
    27| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Assets/js/campaign.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1893 ---
     1| /**
     2|  * Setup the campaign view
     3|  *
     4|  * @param container
     5|  */
     6| Mautic.campaignOnLoad = function (container, response) {
     7|     Mautic.lazyLoadContactListOnCampaignDetail();
     8|     const $flashes = mQuery('#flashes');
     9|     const $builder = mQuery('#campaign-builder');
    10|     const isCampaignPreview = $builder.hasClass('preview');
    11|     if (mQuery(container + ' #list-search').length) {
    12|         Mautic.activateSearchAutocomplete('list-search', 'campaign');
    13|     }
    14|     if (mQuery('#CampaignEventPanel').length) {
    15|         var tooltipTimeout = null;
    16|         mQuery('#CampaignEventPanelGroups button').on('click', function() {
    17|             var eventType = mQuery(this).data('type');
    18|             Mautic.campaignBuilderUpdateEventList([eventType], false, 'lists', true);
    19|         });
    20|         mQuery('#CampaignEventPanelLists button').on('click', function() {
    21|             Mautic.campaignBuilderUpdateEventList(Mautic.campaignBuilderAnchorClickedAllowedEvents, true, 'groups', true);
    22|         });
    23|         if (!isCampaignPreview) {
    24|             mQuery('#CampaignCanvas .list-campaign-event, #CampaignCanvas .list-campaign-source').off('.eventbuttons')
    25|                 .on('mouseover.eventbuttons', function() {
    26|                     mQuery(this).find('.campaign-event-buttons').removeClass('hide');
    27|                 })
    28|                 .on('mouseout.eventbuttons', function() {
    29|                     mQuery(this).find('.campaign-event-buttons').addClass('hide');
    30|                 })
    31|                 .on('dblclick.eventbuttons', function(event) {
    32|                     event.preventDefault();
    33|                     mQuery(this).find('.btn-edit').first().click();
    34|                 });
    35|         } else {
    36|             mQuery("#CampaignCanvas div.list-campaign-event").each(function () {
    37|                 var thisId = mQuery(this).attr('id');
    38|                 var option  = mQuery('#'+thisId+' option[value="' + mQuery(this).val() + '"]');
    39|             });
    40|         }
    41|         mQuery('.campaign-event-selector').on('chosen:showing_dropdown', function (event) {
    42|             mQuery('.builder-content').css('overflow', 'hidden');
    43|             var thisSelect = mQuery(event.target).attr('id');
    44|             Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, false);
    45|             mQuery('#'+thisSelect+'_chosen .chosen-search input').on('keydown.tooltip', function () {
    46|                 Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, true);
    47|             }).on('keyup.tooltip', function() {
    48|                 if (tooltipTimeout) {
    49|                     clearTimeout(tooltipTimeout);
    50|                 }
    51|                 tooltipTimeout = setTimeout(function () {
    52|                     Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, false);
    53|                 }, 200);
    54|             });
    55|         });
    56|         mQuery('.campaign-event-selector').on('chosen:hiding_dropdown', function (event) {
    57|             mQuery('.builder-content').css('overflow', 'auto');
    58|             var thisSelect = mQuery(event.target).attr('id');
    59|             Mautic.campaignBuilderUpdateEventListTooltips(thisSelect, true);
    60|             mQuery('#'+thisSelect+'_chosen .chosen-search input').off('keyup.tooltip')
    61|                 .off('keydown.tooltip');
    62|         });
    63|         mQuery('.campaign-event-selector').on('change', function() {
    64|             if (!mQuery('#CampaignEvent_newsource').length) {
    65|                 Mautic.hideCampaignEventPanel();
    66|             }
    67|             var thisId = mQuery(this).attr('id');
    68|             var option  = mQuery('#'+thisId+' option[value="' + mQuery(this).val() + '"]');
    69|             if (option.attr('data-href') && Mautic.campaignBuilderAnchorNameClicked) {
    70|                 var updatedUrl = option.attr('data-href').replace(/anchor=(.*?)$/, "anchor=" + Mautic.campaignBuilderAnchorNameClicked + "&anchorEventType=" + Mautic.campaignBuilderAnchorEventTypeClicked);
    71|                 option.attr('data-href', updatedUrl);
    72|             }
    73|             mQuery('#'+thisId).trigger('chosen:close');
    74|             Mautic.ajaxifyModal(option);
    75|             mQuery(this).val('');
    76|             mQuery(this).trigger('chosen:updated');
    77|         });
    78|         mQuery('#CampaignCanvas').on('click', function(event) {
    79|             if (!mQuery(event.target).parents('#CampaignCanvas').length && !mQuery('#CampaignEvent_newsource').length) {
    80|                 Mautic.hideCampaignEventPanel();
    81|             }
    82|         });
    83|         $builder.on('campaign-builder:show', function () {
    84|             $builder.addClass('builder-active').removeClass('hide');
    85|             $flashes.addClass('alert-offset');
    86|         });
    87|         $builder.on('campaign-builder:hide', function () {
    88|             $builder.addClass('hide').removeClass('builder-active');
    89|             $flashes.removeClass('alert-offset');
    90|         });
    91|         Mautic.prepareCampaignCanvas();
    92|         if (response && response.inBuilder) {
    93|             Mautic.launchCampaignEditor();
    94|             Mautic.processBuilderErrors(response);
    95|         }
    96|         const campaignEmailStats = mQuery(container).find('[data-load="campaign-email-stats"]').first();
    97|         if(campaignEmailStats.length) {
    98|             mQuery(campaignEmailStats).on('click', () => {
    99|                 const $campaignWeekdaysContainer = mQuery('[data-campaign-email-stats-weekdays]');
   100|                 const $campaignHoursContainer = mQuery('[data-campaign-email-stats-hours]');
   101|                 if ($campaignWeekdaysContainer.find('canvas').length === 0) {
   102|                     mQuery.ajax({
   103|                         url: $campaignWeekdaysContainer.data('campaign-email-stats-weekdays'),
   104|                         success: function (response) {
   105|                             $campaignWeekdaysContainer.html(response);
   106|                             Mautic.renderCharts($campaignWeekdaysContainer);
   107|                         }
   108|                     });
   109|                 }
   110|                 if ($campaignHoursContainer.find('canvas').length === 0) {
   111|                     mQuery.ajax({
   112|                         url: $campaignHoursContainer.data('campaign-email-stats-hours'),
   113|                         success: function (response) {
   114|                             $campaignHoursContainer.html(response);
   115|                             Mautic.renderCharts($campaignHoursContainer);
   116|                         }
   117|                     });
   118|                 }
   119|             });
   120|         }
   121|         window.addEventListener('storage', function(event) {
   122|             if (event.key === 'mautic_campaign_event_clone') {
   123|                 Mautic.campaignBuilderUpdateEventCloneDescription();
   124|             }
   125|         });
   126|         mQuery(document).ajaxError(function(event, jqxhr, settings, thrownError) {
   127|             var path = settings.url.split('?')[0];
   128|             if (path === "/s/campaigns/events/insert") {
   129|                 Mautic.campaignEventInsertOnError(event, jqxhr);
   130|             }
   131|         });
   132|         if (isCampaignPreview) {
   133|             Mautic.previewCampaignLabels();
   134|         }
   135|     }
   136| };
   137| Mautic.lazyLoadContactListOnCampaignDetail = function() {
   138|     let containerId = '#leads-container';
   139|     let container = mQuery(containerId);
   140|     if (!container.length) {
   141|         return;
   142|     }
   143|     let campaignContactUrl = container.data('target-url');
   144|     mQuery.get(campaignContactUrl, function(response) {
   145|         response.target = containerId;
   146|         Mautic.processPageContent(response);
   147|     });
   148| };
   149| /**
   150|  * Update chosen tooltips
   151|  *
   152|  * @param theSelect
   153|  * @param onlyDestroy
   154|  */
   155| Mautic.campaignBuilderUpdateEventListTooltips = function(theSelect, onlyDestroy) {
   156|     const $select = mQuery('#'+theSelect);
   157|     const dataAttribute = 'tooltips';
   158|     if (undefined === $select.data(dataAttribute)) {
   159|         $select.data(dataAttribute, []);
   160|     }
   161|     const tooltips = $select.data(dataAttribute);
   162|     mQuery.each(tooltips, function (index, $tooltip) {
   163|         if (undefined === $tooltip) {
   164|             return;
   165|         }
   166|         $tooltip.tooltip('hide');
   167|         $tooltip.tooltip('destroy');
   168|     });
   169|     $select.data(dataAttribute, []);
   170|     if (true === onlyDestroy) {
   171|         return;
   172|     }
   173|     $select.find('option').each(function () {
   174|         if (mQuery(this).attr('id')) {
   175|             const chosenOption = '#' + theSelect + '_chosen .option_' + mQuery(this).attr('id');
   176|             const $tooltip = mQuery(chosenOption).tooltip({html: true, container: 'body', placement: 'left'});
   177|             $select.data(dataAttribute).push($tooltip);
   178|         }
   179|     });
   180| }
   181| /**
   182|  * Delete the builder instance so it's regenerated when reopening the campaign event builder
   183|  */
   184| Mautic.campaignOnUnload = function(container) {
   185|     delete Mautic.campaignBuilderInstance;
   186|     delete Mautic.campaignBuilderLabels;
   187| }
   188| Mautic.campaignEventCloneOnLoad = function(container, response) {
   189|     Mautic.setCampaignEventClone({
   190|         'sourceEventName': response['eventName'],
   191|         'sourceEventType': response['eventType'],
   192|         'sourceType': response['type'],
   193|         'sourceCampaignId': response['campaignId'],
   194|         'sourceCampaignName': response['campaignName'],
   195|     });
   196|     const flashMessage = Mautic.addInfoFlashMessage(Mautic.translate('mautic.campaign.event.clone.success'));
   197|     Mautic.setFlashes(flashMessage);
   198|     Mautic.campaignBuilderUpdateEventCloneDescription();
   199| };
   200| Mautic.campaignEventInsertOnError = function (event, jqxhr) {
   201|     Mautic.clearCampaignEventClone();
   202|     Mautic.hideCampaignEventPanel();
   203|     if (jqxhr.responseJSON.error) {
   204|         const flashMessage = Mautic.addErrorFlashMessage(jqxhr.responseJSON.error);
   205|         Mautic.setFlashes(flashMessage);
   206|     }
   207| };
   208| /**
   209|  * Setup the campaign event view
   210|  *
   211|  * @param container
   212|  * @param response
   213|  */
   214| Mautic.campaignEventOnLoad = function (container, response) {
   215|     if (mQuery('#campaignevent_triggerHour').length) {
   216|         Mautic.campaignEventUpdateIntervalHours();
   217|         mQuery('#campaignevent_triggerHour').on('change', Mautic.campaignEventUpdateIntervalHours);
   218|         mQuery('#campaignevent_triggerRestrictedStartHour').on('change', Mautic.campaignEventUpdateIntervalHours);
   219|         mQuery('#campaignevent_triggerRestrictedStopHour').on('change', Mautic.campaignEventUpdateIntervalHours);
   220|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_0').on('change', Mautic.campaignEventSelectDOW);
   221|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_1').on('change', Mautic.campaignEventSelectDOW);
   222|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_2').on('change', Mautic.campaignEventSelectDOW);
   223|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_3').on('change', Mautic.campaignEventSelectDOW);
   224|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_4').on('change', Mautic.campaignEventSelectDOW);
   225|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').on('change', Mautic.campaignEventSelectDOW);
   226|     }
   227|     if (!response.hasOwnProperty('eventId')) {
   228|         return;
   229|     }
   230|     var domEventId = 'CampaignEvent_' + response.eventId;
   231|     var eventId = '#' + domEventId;
   232|     Mautic.campaignBuilderLabels[domEventId] = (response.label) ? response.label : '';
   233|     if (!response.success && Mautic.campaignBuilderConnectionRequiresUpdate) {
   234|         Mautic.campaignBuilderInstance.deleteConnection(Mautic.campaignBuilderLastConnection);
   235|     }
   236|     Mautic.campaignBuilderConnectionRequiresUpdate = false;
   237|     Mautic.campaignBuilderUpdateLabel(domEventId);
   238|     Mautic.campaignBuilderCanvasEvents[response.event.id] = response.event;
   239|     if (response.deleted) {
   240|         Mautic.campaignBuilderInstance.remove(document.getElementById(domEventId));
   241|         delete Mautic.campaignBuilderEventPositions[domEventId];
   242|         delete Mautic.campaignBuilderCanvasEvents[response.event.id];
   243|     } else if (response.updateHtml) {
   244|         mQuery(eventId + " .campaign-event-content").replaceWith(response.updateHtml);
   245|     } else if (response.eventHtml) {
   246|         var newHtml = response.eventHtml;
   247|         var x = parseInt(mQuery('#droppedX').val());
   248|         var y = parseInt(mQuery('#droppedY').val());
   249|         Mautic.campaignBuilderEventPositions[domEventId] = {
   250|             'left': x,
   251|             'top': y
   252|         };
   253|         mQuery(newHtml).appendTo('#CampaignCanvas');
   254|         mQuery(eventId).css({'left': x + 'px', 'top': y + 'px'});
   255|         Mautic.campaignBuilderRegisterAnchors(Mautic.getAnchorsForEvent(response.event), eventId);
   256|         Mautic.campaignBuilderInstance.draggable(domEventId, Mautic.campaignDragOptions);
   257|         mQuery(eventId + " a[data-toggle='ajax']").click(function (event) {
   258|             event.preventDefault();
   259|             return Mautic.ajaxifyLink(this, event);
   260|         });
   261|         mQuery(eventId + " a[data-toggle='ajaxmodal']").on('click.ajaxmodal', function (event) {
   262|             event.preventDefault();
   263|             Mautic.ajaxifyModal(this, event);
   264|         });
   265|         mQuery(eventId).off('.eventbuttons')
   266|             .on('mouseover.eventbuttons', function() {
   267|                 mQuery(this).find('.campaign-event-buttons').removeClass('hide');
   268|             })
   269|             .on('mouseout.eventbuttons', function() {
   270|                 mQuery(this).find('.campaign-event-buttons').addClass('hide');
   271|             })
   272|             .on('dblclick.eventbuttons', function(event) {
   273|                 event.preventDefault();
   274|                 mQuery(this).find('.btn-edit').first().click();
   275|             });
   276|         mQuery(eventId + " *[data-toggle='tooltip']").tooltip({html: true});
   277|         Mautic.campaignBuilderInstance.connect({
   278|             uuids: [
   279|                 Mautic.campaignBuilderAnchorClicked,
   280|                 domEventId+'_top'
   281|             ]
   282|         });
   283|     }
   284|     if (response.hasOwnProperty('clearCloneStorage')) {
   285|         Mautic.hideCampaignEventPanel();
   286|         Mautic.clearCampaignEventClone();
   287|     }
   288|     Mautic.campaignBuilderInstance.repaintEverything();
   289| };
   290| /**
   291|  * Update the trigger hour based on the interval unit selected
   292|  */
   293| Mautic.campaignEventUpdateIntervalHours = function () {
   294|     var hour = mQuery('#campaignevent_triggerHour').val();
   295|     var start = mQuery('#campaignevent_triggerRestrictedStartHour').val();
   296|     var stop = mQuery('#campaignevent_triggerRestrictedStopHour').val();
   297|     if (hour) {
   298|         mQuery('#campaignevent_triggerRestrictedStartHour').val('');
   299|         mQuery('#campaignevent_triggerRestrictedStopHour').val('');
   300|         mQuery('#campaignevent_triggerRestrictedStartHour').prop('disabled', true);
   301|         mQuery('#campaignevent_triggerRestrictedStopHour').prop('disabled', true);
   302|     } else if (start || stop) {
   303|         mQuery('#campaignevent_triggerHour').val('');
   304|         mQuery('#campaignevent_triggerHour').prop('disabled', true);
   305|     } else {
   306|         mQuery('#campaignevent_triggerHour').val('');
   307|         mQuery('#campaignevent_triggerRestrictedStartHour').val('');
   308|         mQuery('#campaignevent_triggerRestrictedStopHour').val('');
   309|         mQuery('#campaignevent_triggerHour').prop('disabled', false);
   310|         mQuery('#campaignevent_triggerRestrictedStartHour').prop('disabled', false);
   311|         mQuery('#campaignevent_triggerRestrictedStopHour').prop('disabled', false);
   312|     }
   313| };
   314| /**
   315|  * Update DOW for weekday selection
   316|  */
   317| Mautic.campaignEventSelectDOW = function() {
   318|     if (mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').prop('checked')) {
   319|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_0').prop('checked', true);
   320|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_1').prop('checked', true);
   321|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_2').prop('checked', true);
   322|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_3').prop('checked', true);
   323|         mQuery('#campaignevent_triggerRestrictedDaysOfWeek_4').prop('checked', true);
   324|     }
   325|     mQuery('#campaignevent_triggerRestrictedDaysOfWeek_7').prop('checked', false);
   326| };
   327| /**
   328|  * Determine anchors to set up for the given event.
   329|  *
   330|  * This inspects the `connectionRestrictions` property
   331|  * within the event's settings that were passed when
   332|  * registering the event in your bundle's CampaignEventListener.
   333|  *
   334|  * @param event
   335|  */
   336| Mautic.getAnchorsForEvent = function (event) {
   337|     var restrictions = Mautic.campaignBuilderConnectionRestrictions[event.type].target;
   338|     if (
   339|         restrictions.decision.length === 1 && restrictions.decision[0] === "none" &&
   340|         restrictions.action.length === 1 && restrictions.action[0] === "none" &&
   341|         restrictions.condition.length === 1 && restrictions.condition[0] === "none"
   342|     ) {
   343|         return ['top'];
   344|     }
   345|     if (event.eventType === 'decision' || event.eventType === 'condition') {
   346|         return ['top', 'yes', 'no'];
   347|     }
   348|     return ['top', 'bottom'];
   349| };
   350| /**
   351|  * Setup the campaign source view
   352|  *
   353|  * @param container
   354|  * @param response
   355|  */
   356| Mautic.campaignSourceOnLoad = function (container, response) {
   357|     var domEventId = 'CampaignEvent_' + response.sourceType;
   358|     var eventId = '#' + domEventId;
   359|     if (response.deleted) {
   360|         Mautic.campaignBuilderInstance.remove(document.getElementById(domEventId));
   361|         delete Mautic.campaignBuilderEventPositions[domEventId];
   362|         mQuery('#campaignLeadSource_' + response.sourceType).prop('disabled', false);
   363|         mQuery('#SourceList').trigger('chosen:updated');
   364|         if (!mQuery('.list-campaign-source:not(#CampaignEvent_newsource_hide)').length) {
   365|             mQuery('#CampaignEvent_newsource_hide').attr('id', 'CampaignEvent_newsource');
   366|             Mautic.campaignBuilderPrepareNewSource();
   367|         }
   368|     } else if (response.updateHtml) {
   369|         mQuery(eventId + " .campaign-event-content").html(response.updateHtml);
   370|     } else if (response.sourceHtml) {
   371|         mQuery('#campaignLeadSource_' + response.sourceType).prop('disabled', true);
   372|         mQuery('#SourceList').trigger('chosen:updated');
   373|         var newHtml = response.sourceHtml;
   374|         if (mQuery('#CampaignEvent_newsource').length) {
   375|             var x = mQuery('#CampaignEvent_newsource').position().left;
   376|             var y = mQuery('#CampaignEvent_newsource').position().top;
   377|             mQuery('#CampaignEvent_newsource').attr('id', 'CampaignEvent_newsource_hide');
   378|             Mautic.hideCampaignEventPanel();
   379|             var autoConnect = false;
   380|         } else {
   381|             var x = parseInt(mQuery('#droppedX').val());
   382|             var y = parseInt(mQuery('#droppedY').val());
   383|             var autoConnect = true;
   384|         }
   385|         mQuery(newHtml).appendTo('#CampaignCanvas');
   386|         Mautic.campaignBuilderEventPositions[domEventId] = {
   387|             'left': x,
   388|             'top': y
   389|         };
   390|         mQuery(eventId).css({'left': x + 'px', 'top': y + 'px'});
   391|         Mautic.campaignBuilderRegisterAnchors(['leadSource', 'leadSourceLeft', 'leadSourceRight'], eventId);
   392|         Mautic.campaignBuilderInstance.draggable(domEventId, Mautic.campaignDragOptions);
   393|         mQuery(eventId + " a[data-toggle='ajax']").click(function (event) {
   394|             event.preventDefault();
   395|             return Mautic.ajaxifyLink(this, event);
   396|         });
   397|         mQuery(eventId + " a[data-toggle='ajaxmodal']").on('click.ajaxmodal', function (event) {
   398|             event.preventDefault();
   399|             Mautic.ajaxifyModal(this, event);
   400|         });
   401|         mQuery(eventId).off('.eventbuttons')
   402|             .on('mouseover.eventbuttons', function() {
   403|                 mQuery(this).find('.campaign-event-buttons').removeClass('hide');
   404|             })
   405|             .on('mouseout.eventbuttons', function() {
   406|                 mQuery(this).find('.campaign-event-buttons').addClass('hide');
   407|             })
   408|             .on('dblclick.eventbuttons', function(event) {
   409|                 event.preventDefault();
   410|                 mQuery(this).find('.btn-edit').first().click();
   411|             });
   412|         mQuery(eventId + " *[data-toggle='tooltip']").tooltip({html: true});
   413|         if (autoConnect) {
   414|             if (Mautic.campaignBuilderAnchorClicked.search('left') !== -1) {
   415|                 var source = domEventId + '_leadsourceright';
   416|                 var target = Mautic.campaignBuilderAnchorClicked;
   417|             } else {
   418|                 var source = Mautic.campaignBuilderAnchorClicked;
   419|                 var target = domEventId + '_leadsourceleft';
   420|             }
   421|             Mautic.campaignBuilderInstance.connect({
   422|                 uuids: [
   423|                     source,
   424|                     target
   425|                 ]
   426|             });
   427|         }
   428|         if (!mQuery('.list-campaign-event').length) {
   429|             mQuery('.jtk-endpoint_anchor_leadsource.'+domEventId).trigger('click');
   430|         }
   431|     }
   432|     Mautic.campaignBuilderInstance.repaintEverything();
   433| };
   434| /**
   435|  * Update a connectors label
   436|  *
   437|  * @param domEventId
   438|  */
   439| Mautic.campaignBuilderUpdateLabel = function (domEventId) {
   440|     var theLabel = typeof Mautic.campaignBuilderLabels[domEventId] == 'undefined' ? '' : Mautic.campaignBuilderLabels[domEventId];
   441|     var currentConnections = Mautic.campaignBuilderInstance.select({
   442|         target: domEventId
   443|     });
   444|     if (currentConnections.length > 0) {
   445|         currentConnections.each(function(conn) {
   446|             var overlays = conn.getOverlays();
   447|             if (overlays.length > 0) {
   448|                 for (var i = 0; i <= overlays.length; i++ ) {
   449|                     if ( typeof overlays[i] != 'undefined' && overlays[i].type == 'Label') {
   450|                         conn.removeOverlay(overlays[i].id);
   451|                     }
   452|                 }
   453|             }
   454|             if (theLabel) {
   455|                 conn.addOverlay(["Label", {
   456|                     label: theLabel,
   457|                     location: 0.65,
   458|                     cssClass: "jtk-label",
   459|                     id: conn.sourceId + "_" + conn.targetId + "_connectionLabel"
   460|                 }]);
   461|             }
   462|         });
   463|     }
   464| };
   465| /**
   466|  * Launch campaign builder modal
   467|  */
   468| Mautic.launchCampaignEditor = function() {
   469|     Mautic.stopIconSpinPostEvent();
   470|     mQuery('body').css('overflow-y', 'hidden');
   471|     mQuery('#campaign-builder').trigger('campaign-builder:show');
   472|     if (mQuery('#CampaignEvent_newsource').length) {
   473|         Mautic.campaignBuilderPrepareNewSource();
   474|     }
   475|     if (Mautic.campaignBuilderCanvasSettings) {
   476|         Mautic.campaignBuilderInstance.setSuspendDrawing(true);
   477|         Mautic.campaignBuilderReconnectEndpoints();
   478|         Mautic.campaignBuilderInstance.setSuspendDrawing(false, true);
   479|     }
   480|     Mautic.campaignBuilderInstance.repaintEverything();
   481| };
   482| /**
   483|  * Launch campaign preview view
   484|  */
   485| Mautic.launchCampaignPreview = function() {
   486|     Mautic.stopIconSpinPostEvent();
   487|     if (Mautic.campaignBuilderCanvasSettings) {
   488|         Mautic.campaignBuilderInstance.setSuspendDrawing(true);
   489|         Mautic.campaignBuilderReconnectEndpoints();
   490|         Mautic.campaignBuilderInstance.setSuspendDrawing(false, true);
   491|     }
   492|     Mautic.campaignBuilderInstance.repaintEverything();
   493| };
   494| /**
   495|  *
   496|  * @type {{source: {leadsource: {source: Array, action: [*], condition: [*], decision: [*]}, leadsourceleft: {source: [*], action: Array, condition: Array, decision: Array}, leadsourceright: {source: [*], action: Array, condition: Array, decision: Array}}, action: {top: {source: [*], action: Array, condition: [*], decision: [*]}, bottom: {source: Array, action: Array, condition: [*], decision: [*]}}, condition: {top: {source: [*], action: [*], condition: [*], decision: [*]}, yes: {source: Array, action: [*], condition: [*], decision: [*]}, no: {source: Array, action: [*], condition: [*], decision: [*]}}, decision: {top: {action: [*], source: [*], condition: [*], decision: Array}, yes: {source: Array, action: [*], condition: [*], decision: Array}, no: {source: Array, action: [*], condition: [*], decision: Array}}}}
   497|  */
   498| Mautic.campaignBuilderConnectionsMap = {
   499|     'source': {
   500|         'leadsource': {
   501|             'source': [],
   502|             'action': ['top'], // target anchors
   503|             'condition': ['top'],
   504|             'decision': ['top'],
   505|         },
   506|         'leadsourceleft': {
   507|             'source': ['leadsourceright'],
   508|             'action': [],
   509|             'condition': [],
   510|             'decision': []
   511|         },
   512|         'leadsourceright': {
   513|             'source': ['leadsourceleft'],
   514|             'action': [],
   515|             'condition': [],
   516|             'decision': []
   517|         }
   518|     },
   519|     'action': {
   520|         'top': {
   521|             'source': ['leadsource'],
   522|             'action': ['bottom'],
   523|             'condition': ['yes', 'no'],
   524|             'decision': ['yes', 'no']
   525|         },
   526|         'bottom': {
   527|             'source': [],
   528|             'action': ['top'],
   529|             'condition': ['top'],
   530|             'decision': ['top']
   531|         }
   532|     },
   533|     'condition': {
   534|         'top': {
   535|             'source': ['leadsource'],
   536|             'action': ['bottom'],
   537|             'condition': ['yes', 'no'],
   538|             'decision': ['yes', 'no']
   539|         },
   540|         'yes': {
   541|             'source': [],
   542|             'action': ['top'],
   543|             'condition': ['top'],
   544|             'decision': ['top']
   545|         },
   546|         'no': {
   547|             'source': [],
   548|             'action': ['top'],
   549|             'condition': ['top'],
   550|             'decision': ['top']
   551|         }
   552|     },
   553|     'decision': {
   554|         'top': {
   555|             'action': ['bottom'],
   556|             'source': ['leadsource'],
   557|             'condition': ['yes', 'no'],
   558|             'decision': [],
   559|         },
   560|         'yes': {
   561|             'source': [],
   562|             'action': ['top'],
   563|             'condition': ['top'],
   564|             'decision': [],
   565|         },
   566|         'no': {
   567|             'source': [],
   568|             'action': ['top'],
   569|             'condition': ['top'],
   570|             'decision': [],
   571|         }
   572|     }
   573| };
   574| Mautic.campaignBuilderAnchorDefaultColor = 'var(--border-subtle)';
   575| Mautic.campaignEndpointDefinitions = {
   576|     'top': {
   577|         anchors: [0.5, 0, 0, -1, 0, 0],
   578|         isTarget: true
   579|     },
   580|     'bottom': {
   581|         anchors: [0.5, 1, 0, 1, 0, 0],
   582|         isTarget: false
   583|     },
   584|     'yes': {
   585|         anchors: [0, 1, 0, 1, 30, 0],
   586|         connectorColor: 'var(--support-success-inverse)',
   587|         isTarget: false
   588|     },
   589|     'no': {
   590|         anchors: [1, 1, 0, 1, -30, 0],
   591|         connectorColor: 'var(--support-error-inverse)',
   592|         isTarget: false
   593|     },
   594|     'leadSource': {
   595|         anchors: [0.5, 1, 0, 1, 0, 0],
   596|         isTarget: false
   597|     },
   598|     'leadSourceLeft': {
   599|         anchors: [0, 0.5, -1, 0, -1, 0],
   600|         connectorColor: '#fdb933',
   601|         isTarget: true,
   602|         connectorStyle: 'Straight'
   603|     },
   604|     'leadSourceRight': {
   605|         anchors: [1, 0.5, 1, 0, 1, 0],
   606|         connectorColor: '#fdb933',
   607|         isTarget: false,
   608|         connectorStyle: 'Straight'
   609|     }
   610| };
   611| /**
   612|  * Push callbacks to these events
   613|  *
   614|  * @type {{connection: Array, connectionDetached: Array, connectionMoved: Array, beforeDrop: Array}}
   615|  */
   616| Mautic.campaignConnectionCallbacks = {
   617|     'beforeDetach': [],
   618|     'beforeDrag': [],
   619|     'beforeStartDetach': [],
   620|     'beforeDrop': [],
   621|     'onHover': [],
   622|     'beforeAnchorsRegistered': [],
   623|     'afterAnchorsRegistered': [],
   624|     'beforeEndpointsRegistered': [],
   625|     'beforeEndpointsReconnected': [],
   626|     'afterEndpointsReconnected': []
   627| };
   628| Mautic.campaignBuilderAnchorClicked = false;
   629| Mautic.campaignBuilderEventPositions = {};
   630| Mautic.prepareCampaignCanvas = function() {
   631|     if (typeof Mautic.campaignBuilderInstance == 'undefined') {
   632|         Mautic.campaignBuilderInstance = jsPlumb.getInstance({
   633|             Container: document.querySelector("#CampaignCanvas")
   634|         });
   635|         Mautic.campaignEndpoints = {};
   636|         var startingPosition;
   637|         Mautic.campaignDragOptions = {
   638|             start: function (params) {
   639|                 startingPosition =
   640|                     {
   641|                         top: params.el.offsetTop,
   642|                         left: params.el.offsetLeft,
   643|                     };
   644|             },
   645|             stop: function (params) {
   646|                 var endingPosition =
   647|                     {
   648|                         top: params.finalPos[0],
   649|                         left: params.finalPos[1]
   650|                     };
   651|                 if (startingPosition.left !== endingPosition.left || startingPosition.top !== endingPosition.top) {
   652|                     Mautic.campaignBuilderEventPositions[mQuery(params.el).attr('id')] = {
   653|                         'left': parseInt(endingPosition.left),
   654|                         'top': parseInt(endingPosition.top)
   655|                     };
   656|                     var campaignId = mQuery('#campaignId').val();
   657|                     var query = "action=campaign:updateCoordinates&campaignId=" + campaignId + "&droppedX=" + endingPosition.top + "&droppedY=" + endingPosition.left + "&eventId=" + mQuery(params.el).attr('id');
   658|                     mQuery.ajax({
   659|                         url: mauticAjaxUrl,
   660|                         type: "POST",
   661|                         data: query,
   662|                         dataType: "json",
   663|                         error: function (request, textStatus, errorThrown) {
   664|                             Mautic.processAjaxError(request, textStatus, errorThrown);
   665|                         }
   666|                     });
   667|                 }
   668|             },
   669|             containment:true
   670|         };
   671|         Mautic.campaignBuilderEventDimensions = {
   672|             'width': 200,
   673|             'height': 45,
   674|             'anchor': 10,
   675|             'wiggleWidth': 30,
   676|             'wiggleHeight': 50
   677|         };
   678|         Mautic.campaignBuilderLabels = {};
   679|         Mautic.campaignBuilderInstance.bind("connection", function (info, originalEvent) {
   680|             Mautic.campaignBuilderConnectionRequiresUpdate = false;
   681|             Mautic.campaignBuilderLastConnection           = info.connection;
   682|             var epDetails          = Mautic.campaignBuilderGetEndpointDetails(info.sourceEndpoint);
   683|             var targetElementId    = info.targetEndpoint.elementId;
   684|             var previousConnection = mQuery('#'+targetElementId).attr('data-connected');
   685|             var editButton         = mQuery('#'+targetElementId).find('a.btn-edit');
   686|             var editUrl            = editButton.attr('href');
   687|             if (editUrl) {
   688|                 var anchorQueryParams = 'anchor=' + epDetails.anchorName + "&anchorEventType=" + epDetails.eventType;
   689|                 if (editUrl.search('anchor=') !== -1) {
   690|                     editUrl.replace(/anchor=(.*?)$/, anchorQueryParams);
   691|                 } else {
   692|                     var delimiter = (editUrl.indexOf('?') === -1) ? '?' : '&';
   693|                     editUrl = editUrl + delimiter + anchorQueryParams;
   694|                 }
   695|                 editButton.attr('data-href', editUrl);
   696|                 if (previousConnection && previousConnection != epDetails.anchorName && (previousConnection == 'no' || epDetails.anchorName == 'no')) {
   697|                     editButton.attr('data-prevent-dismiss', true);
   698|                     Mautic.campaignBuilderConnectionRequiresUpdate = true;
   699|                     editButton.trigger('click');
   700|                 }
   701|             }
   702|             mQuery('#'+targetElementId).attr('data-connected', epDetails.anchorName);
   703|             Mautic.campaignBuilderUpdateLabel(info.connection.targetId);
   704|             info.targetEndpoint.setPaintStyle(
   705|                 {
   706|                     fill: info.connection.getPaintStyle().stroke
   707|                 }
   708|             );
   709|             info.sourceEndpoint.setPaintStyle(
   710|                 {
   711|                     fill: info.connection.getPaintStyle().stroke
   712|                 }
   713|             );
   714|         });
   715|         Mautic.campaignBuilderInstance.bind("connectionDetached", function (info, originalEvent) {
   716|             Mautic.campaignBuilderUpdateLabel(info.connection.targetId);
   717|             info.targetEndpoint.setPaintStyle(
   718|                 {
   719|                     fill: "#d5d4d4"
   720|                 }
   721|             );
   722|             var currentConnections = info.sourceEndpoint.connections.length;
   723|             currentConnections -= 1;
   724|             if (!currentConnections) {
   725|                 info.sourceEndpoint.setPaintStyle(
   726|                     {
   727|                         fill: "#d5d4d4"
   728|                     }
   729|                 );
   730|             }
   731|         });
   732|         Mautic.campaignBuilderInstance.bind("connectionMoved", function (info, originalEvent) {
   733|             Mautic.campaignBuilderUpdateLabel(info.connection.originalTargetId);
   734|             info.originalTargetEndpoint.setPaintStyle(
   735|                 {
   736|                     fill: "#d5d4d4"
   737|                 }
   738|             );
   739|             Mautic.campaignBuilderUpdateLabel(info.connection.newTargetId);
   740|             info.newTargetEndpoint.setPaintStyle(
   741|                 {
   742|                     fill: info.newSourceEndpoint.getPaintStyle().fill
   743|                 }
   744|             );
   745|         });
   746|         mQuery('.builder-content').scroll(function () {
   747|             Mautic.campaignBuilderInstance.repaintEverything();
   748|         });
   749|         mQuery.each(Mautic.campaignConnectionCallbacks.beforeEndpointsRegistered, function (index, callback) {
   750|             callback();
   751|         });
   752|         mQuery.each(Mautic.campaignEndpointDefinitions, function (ep, definition) {
   753|             Mautic.campaignBuilderRegisterEndpoint(ep, definition);
   754|         });
   755|         mQuery.each(Mautic.campaignConnectionCallbacks.beforeAnchorsRegistered, function (index, callback) {
   756|             callback();
   757|         });
   758|         mQuery("#CampaignCanvas div[data-event-id]").each(function () {
   759|             var event = Mautic.campaignBuilderCanvasEvents[mQuery(this).data('eventId')];
   760|             Mautic.campaignBuilderRegisterAnchors(Mautic.getAnchorsForEvent(event), this);
   761|         });
   762|         mQuery("#CampaignCanvas div.list-campaign-event.list-campaign-source").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function () {
   763|             Mautic.campaignBuilderRegisterAnchors(['bottom'], this);
   764|         });
   765|         mQuery("#CampaignCanvas div.list-campaign-leadsource").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function () {
   766|             Mautic.campaignBuilderRegisterAnchors(['leadSource', 'leadSourceLeft', 'leadSourceRight'], this);
   767|         });
   768|         mQuery.each(Mautic.campaignConnectionCallbacks.afterAnchorsRegistered, function (index, callback) {
   769|             callback();
   770|         });
   771|         if (mQuery('.preview').length) {
   772|             Mautic.launchCampaignPreview();
   773|         } else {
   774|             Mautic.campaignBuilderInstance.draggable(
   775|                 document.querySelectorAll("#CampaignCanvas .draggable"),
   776|                 Mautic.campaignDragOptions
   777|             );
   778|         }
   779|     }
   780| };
   781| /**
   782|  * Validate a connection before it can be made
   783|  *
   784|  * @param params
   785|  * @returns {boolean}
   786|  */
   787| Mautic.campaignBeforeDropCallback = function(params) {
   788|     var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(params.connection.endpoints[0]);
   789|     var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(params.dropEndpoint);
   790|     var callbackAllowed = null;
   791|     mQuery.each(Mautic.campaignConnectionCallbacks.beforeDrop, function(index, callback) {
   792|         var result = callback(sourceEndpoint, targetEndpoint, params);
   793|         if (null !== result) {
   794|             callbackAllowed = result;
   795|             return false;
   796|         }
   797|     });
   798|     if (null !== callbackAllowed) {
   799|         return callbackAllowed;
   800|     }
   801|     if (!Mautic.campaignBuilderValidateConnection(sourceEndpoint, targetEndpoint.eventType, targetEndpoint.event)){
   802|         return false;
   803|     }
   804|     if (mQuery.inArray(targetEndpoint.anchorName, ['top', 'leadsourceleft', 'leadsourceright'])) {
   805|         var sourceConnections = Mautic.campaignBuilderInstance.select({
   806|             source: params.targetId
   807|         });
   808|         var loopDetected = false;
   809|         sourceConnections.each(function (conn) {
   810|             if (conn.sourceId == targetEndpoint.elementId && conn.targetId == sourceEndpoint.elementId) {
   811|                 loopDetected = true;
   812|                 return false;
   813|             }
   814|         });
   815|     }
   816|     if (params.sourceId == params.targetId) {
   817|         return false;
   818|     }
   819|     var allowedConnections = Mautic.campaignBuilderConnectionsMap[sourceEndpoint.eventType][sourceEndpoint.anchorName][targetEndpoint.eventType];
   820|     var allowed = mQuery.inArray(targetEndpoint.anchorName, allowedConnections) !== -1;
   821|     if (allowed) {
   822|         if (params.dropEndpoint.connections.length > 0) {
   823|             mQuery.each(params.dropEndpoint.connections, function(key, conn) {
   824|                 Mautic.campaignBuilderInstance.deleteConnection(conn);
   825|             });
   826|         }
   827|     }
   828|     return allowed;
   829| };
   830| /**
   831|  * Process beforeDetach event callbacks
   832|  *
   833|  * @param connection
   834|  * @returns {*}
   835|  */
   836| Mautic.campaignBeforeDetachCallback = function(connection) {
   837|     var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(connection.sourceId);
   838|     var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(connection.targetId);
   839|     var callbackAllowed = null;
   840|     mQuery.each(Mautic.campaignConnectionCallbacks.beforeDetach, function (index, callback) {
   841|         var result = callback(sourceEndpoint, targetEndpoint, connection);
   842|         if (null !== result) {
   843|             callbackAllowed = result;
   844|             return false;
   845|         }
   846|     });
   847|     if (null !== callbackAllowed) {
   848|         return callbackAllowed;
   849|     }
   850|     return true;
   851| };
   852| /**
   853|  * Process beforeDetach event callbacks
   854|  *
   855|  * @param connection
   856|  */
   857| Mautic.campaignBeforeDragCallback = function(endpoint, source, sourceId) {
   858|     var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(sourceId);
   859|     var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(endpoint);
   860|     var callbackAllowed = null;
   861|     mQuery.each(Mautic.campaignConnectionCallbacks.beforeDrag, function (index, callback) {
   862|         var result = callback(sourceEndpoint, targetEndpoint, endpoint, source, sourceId);
   863|         if (null !== result) {
   864|             callbackAllowed = result;
   865|             return false;
   866|         }
   867|     });
   868|     if (null !== callbackAllowed) {
   869|         return callbackAllowed;
   870|     }
   871|     return true;
   872| };
   873| /**
   874|  * Process beforeDetach event callbacks
   875|  *
   876|  * @param endpoint
   877|  * @param source
   878|  * @param sourceId
   879|  * @param connection
   880|  * @returns {*}
   881|  */
   882| Mautic.campaignBeforeStartDetachCallback = function(endpoint, source, sourceId, connection) {
   883|     var sourceEndpoint = Mautic.campaignBuilderGetEndpointDetails(sourceId);
   884|     var targetEndpoint = Mautic.campaignBuilderGetEndpointDetails(endpoint);
   885|     var callbackAllowed = null;
   886|     mQuery.each(Mautic.campaignConnectionCallbacks.beforeStartDetach, function (index, callback) {
   887|         var result = callback(sourceEndpoint, targetEndpoint, endpoint, source, sourceId, connection);
   888|         if (null !== result) {
   889|             callbackAllowed = result;
   890|             return false;
   891|         }
   892|     });
   893|     if (null !== callbackAllowed) {
   894|         return callbackAllowed;
   895|     }
   896|     return true;
   897| };
   898| /**
   899|  * Process beforeDetach event callbacks
   900|  *
   901|  * @param connection
   902|  */
   903| Mautic.campaignHoverCallback = function(sourceEndpoint, endpoint, event) {
   904|     var callbackAllowed = null;
   905|     mQuery.each(Mautic.campaignConnectionCallbacks.onHover, function (index, callback) {
   906|         var result = callback(sourceEndpoint, endpoint, event);
   907|         if (null !== result) {
   908|             callbackAllowed = result;
   909|             return false;
   910|         }
   911|     });
   912|     if (null !== callbackAllowed) {
   913|         return callbackAllowed;
   914|     }
   915|     return true;
   916| };
   917| /**
   918|  * Enable/Disable timeframe settings if the toggle for immediate trigger is changed
   919|  */
   920| Mautic.campaignToggleTimeframes = function() {
   921|     const triggerModes = {
   922|         immediate: mQuery('#campaignevent_triggerMode_0').prop('checked'),
   923|         interval: mQuery('#campaignevent_triggerMode_1').prop('checked'),
   924|         date: mQuery('#campaignevent_triggerMode_2').prop('checked'),
   925|         optimal: mQuery('#campaignevent_triggerMode_3').prop('checked')
   926|     };
   927|     if (!mQuery('#campaignevent_triggerMode_2').length) {
   928|         triggerModes.date = triggerModes.interval;
   929|         triggerModes.interval = triggerModes.immediate;
   930|         triggerModes.immediate = false;
   931|     }
   932|     if (mQuery('#campaignevent_triggerInterval').length) {
   933|         mQuery('#triggerInterval').toggleClass('hide', !triggerModes.interval);
   934|         mQuery('#triggerDate').toggleClass('hide', !triggerModes.date);
   935|         mQuery('#triggerOptimized').toggleClass('hide', !triggerModes.optimal);
   936|     }
   937| };
   938| /**
   939|  * Close campaign builder
   940|  */
   941| Mautic.closeCampaignBuilder = function() {
   942|     mQuery('.btns-builder').find('button').prop('disabled', true);
   943|     var builderCss = {
   944|         margin: "0",
   945|         padding: "0",
   946|         border: "none",
   947|         width: "100%",
   948|         height: "100%"
   949|     };
   950|     var panelHeight = (mQuery('.builder-content').css('right') == '0px') ? mQuery('.builder-panel').height() : 0,
   951|         panelWidth = (mQuery('.builder-content').css('right') == '0px') ? 0 : mQuery('.builder-panel').width(),
   952|         spinnerLeft = (mQuery(window).width() - panelWidth - 60) / 2,
   953|         spinnerTop = (mQuery(window).height() - panelHeight - 60) / 2;
   954|     var overlay = mQuery('<div id="builder-overlay" class="modal-backdrop fade in"><div style="position: absolute; top:' + spinnerTop + 'px; left:' + spinnerLeft + 'px" class=".builder-spinner"><i class="ri-loader-3-line ri-spin ri-5x"></i></div></div>').css(builderCss).appendTo('.builder-content');
   955|     mQuery('#builder-errors').hide('fast').text('');
   956|     Mautic.updateConnections(function(err, response) {
   957|         mQuery('body').css('overflow-y', '');
   958|         if (!err) {
   959|             mQuery('#builder-overlay').remove();
   960|             mQuery('body').css('overflow-y', '');
   961|             if (response.success) {
   962|                 mQuery('#campaign-builder').trigger('campaign-builder:hide');
   963|                 mQuery('.btns-builder').find('button').prop('disabled', false);
   964|             }
   965|         }
   966|     });
   967| };
   968| Mautic.saveCampaignFromBuilder = function() {
   969|     mQuery('.btns-builder').find('button').prop('disabled', true);
   970|     Mautic.activateButtonLoadingIndicator(mQuery('.btn-apply-builder'));
   971|     Mautic.updateConnections(function(err) {
   972|         if (!err) {
   973|             var applyBtn = mQuery('.btn-apply');
   974|             Mautic.inBuilderSubmissionOn(applyBtn.closest('form'));
   975|             applyBtn.trigger('click');
   976|             Mautic.inBuilderSubmissionOff();
   977|         }
   978|     });
   979| };
   980| Mautic.updateConnections = function(callback) {
   981|     var nodes = [];
   982|     mQuery("#CampaignCanvas .list-campaign-event").each(function (idx, elem) {
   983|         nodes.push({
   984|             id:        mQuery(elem).attr('id').replace('CampaignEvent_', ''),
   985|             positionX: parseInt(mQuery(elem).css('left'), 10),
   986|             positionY: parseInt(mQuery(elem).css('top'), 10)
   987|         });
   988|     });
   989|     mQuery("#CampaignCanvas .list-campaign-source").not('#CampaignEvent_newsource').not('#CampaignEvent_newsource_hide').each(function (idx, elem) {
   990|         nodes.push({
   991|             id:        mQuery(elem).attr('id').replace('CampaignEvent_', ''),
   992|             positionX: parseInt(mQuery(elem).css('left'), 10),
   993|             positionY: parseInt(mQuery(elem).css('top'), 10)
   994|         });
   995|     });
   996|     var connections = [];
   997|     mQuery.each(Mautic.campaignBuilderInstance.getConnections(), function (idx, connection) {
   998|         connections.push({
   999|             sourceId:     connection.sourceId.replace('CampaignEvent_', ''),
  1000|             targetId:     connection.targetId.replace('CampaignEvent_', ''),
  1001|             anchors:      mQuery.map(connection.endpoints, function (endpoint) {
  1002|                 var anchor = Mautic.campaignBuilderGetEndpointDetails(endpoint);
  1003|                 return {
  1004|                     'endpoint': anchor.anchorName,
  1005|                     'eventId':  anchor.eventId
  1006|                 };
  1007|             })
  1008|         });
  1009|     });
  1010|     var chart          = {};
  1011|     chart.nodes        = nodes;
  1012|     chart.connections  = connections;
  1013|     var canvasSettings = {canvasSettings: chart};
  1014|     var campaignId     = mQuery('#campaignId').val();
  1015|     var query          = "action=campaign:updateConnections&campaignId=" + campaignId;
  1016|     mQuery.ajax({
  1017|         url: mauticAjaxUrl + '?' + query,
  1018|         type: "POST",
  1019|         data: canvasSettings,
  1020|         dataType: "json",
  1021|         success: function (response) {
  1022|             if (typeof callback === 'function') callback(false, response);
  1023|         },
  1024|         error: function (response, textStatus, errorThrown) {
  1025|             Mautic.processAjaxError(response, textStatus, errorThrown);
  1026|             if (typeof callback === 'function') callback(true, response);
  1027|         }
  1028|     });
  1029| };
  1030| /**
  1031|  * Submit the campaign event form
  1032|  * @param e
  1033|  */
  1034| Mautic.submitCampaignEvent = function(e) {
  1035|     e.preventDefault();
  1036|     mQuery('#campaignevent_canvasSettings_droppedX').val(mQuery('#droppedX').val());
  1037|     mQuery('#campaignevent_canvasSettings_droppedY').val(mQuery('#droppedY').val());
  1038|     mQuery('.btns-builder').find('button').prop('disabled', true);
  1039|     const runningAjax = mQuery.active;
  1040|     mQuery('form[name="campaignevent"]').submit();
  1041|     const waitForElement = function (){
  1042|         if(mQuery.active <= runningAjax){
  1043|             mQuery('.btns-builder').find('button').prop('disabled', false);
  1044|         }
  1045|         else{
  1046|             setTimeout(waitForElement, 100);
  1047|         }
  1048|     }
  1049|     waitForElement();
  1050| };
  1051| /**
  1052|  * Submit source form
  1053|  * @param e
  1054|  */
  1055| Mautic.submitCampaignSource = function(e) {
  1056|     e.preventDefault();
  1057|     mQuery('#campaign_leadsource_droppedX').val(mQuery('#droppedX').val());
  1058|     mQuery('#campaign_leadsource_droppedY').val(mQuery('#droppedY').val());
  1059|     mQuery('form[name="campaign_leadsource"]').submit();
  1060| };
  1061| /**
  1062|  * Reconnect jsplumb connections
  1063|  */
  1064| Mautic.campaignBuilderReconnectEndpoints = function () {
  1065|     mQuery.each(Mautic.campaignConnectionCallbacks.beforeEndpointsReconnected, function (index, callback) {
  1066|         callback();
  1067|     });
  1068|     if (typeof Mautic.campaignBuilderCanvasSettings == 'undefined') {
  1069|         return;
  1070|     }
  1071|     if (typeof Mautic.campaignBuilderCanvasSettings.nodes !== 'undefined') {
  1072|         var sourceFound = false;
  1073|         mQuery.each(Mautic.campaignBuilderCanvasSettings.nodes, function (key, node) {
  1074|             if (typeof Mautic.campaignBuilderCanvasSources[node.id] !== 'undefined') {
  1075|                 sourceFound = true;
  1076|             }
  1077|             mQuery('#CampaignEvent_' + node.id).css({
  1078|                 position: 'absolute',
  1079|                 left: node.positionX + 'px',
  1080|                 top: node.positionY + 'px'
  1081|             });
  1082|             Mautic.campaignBuilderEventPositions['CampaignEvent_' + node.id] = {
  1083|                 left: parseInt(node.positionX),
  1084|                 top: parseInt(node.positionY)
  1085|             };
  1086|         });
  1087|     }
  1088|     if (typeof Mautic.campaignBuilderCanvasSettings.connections !== 'undefined') {
  1089|         mQuery.each(Mautic.campaignBuilderCanvasSettings.connections, function (key, connection) {
  1090|             if (typeof Mautic.campaignBuilderCanvasEvents[connection.targetId] !== 'undefined') {
  1091|                 var targetEvent = Mautic.campaignBuilderCanvasEvents[connection.targetId];
  1092|             } else if (typeof Mautic.campaignBuilderCanvasSources[connection.targetId] !== 'undefined') {
  1093|                 var targetEvent = Mautic.campaignBuilderCanvasSources[connection.targetId];
  1094|             }
  1095|             if (targetEvent && targetEvent.label) {
  1096|                 Mautic.campaignBuilderLabels["CampaignEvent_" + connection.targetId] = targetEvent.label;
  1097|             }
  1098|             Mautic.campaignBuilderInstance.connect({
  1099|                 uuids: [
  1100|                     "CampaignEvent_" + connection.sourceId + '_' + connection.anchors.source,
  1101|                     "CampaignEvent_" + connection.targetId + '_' + connection.anchors.target
  1102|                 ]
  1103|             });
  1104|         });
  1105|     }
  1106|     if (!sourceFound) {
  1107|         var topOffset = 25;
  1108|         mQuery.each(Mautic.campaignBuilderCanvasSources, function (type, source) {
  1109|             mQuery('#CampaignEvent_' + type).css({
  1110|                 position: 'absolute',
  1111|                 left: '20px',
  1112|                 top: topOffset + 'px'
  1113|             });
  1114|         });
  1115|         topOffset += 45;
  1116|     }
  1117|     mQuery.each(Mautic.campaignConnectionCallbacks.afterEndpointsReconnected, function (index, callback) {
  1118|         callback();
  1119|     });
  1120|     delete Mautic.campaignBuilderCanvasSettings;
  1121| };
  1122| /**
  1123|  * Register an endpoint with JsPlumb
  1124|  *
  1125|  * @param name
  1126|  * @param params
  1127|  */
  1128| Mautic.campaignBuilderRegisterEndpoint = function (name, params) {
  1129|     var isTarget, isSource, color, connectorColor, connectorStyle;
  1130|     if (params.color) {
  1131|         color = params.color;
  1132|     } else {
  1133|         color = Mautic.campaignBuilderAnchorDefaultColor;
  1134|     }
  1135|     if (params.connectorColor) {
  1136|         connectorColor = params.connectorColor;
  1137|     } else {
  1138|         connectorColor = color;
  1139|     }
  1140|     if (params.connectorStyle) {
  1141|         connectorStyle = params.connectorStyle;
  1142|     } else {
  1143|         connectorStyle = ["Bezier", {curviness: 25}];
  1144|     }
  1145|     isTarget = params.isTarget;
  1146|     isSource = true;
  1147|     if (isTarget === null) {
  1148|         isTarget = true;
  1149|     } else {
  1150|         if (typeof isTarget == 'undefined') {
  1151|             isTarget = false;
  1152|         }
  1153|         if (isTarget) {
  1154|             isSource = false;
  1155|         }
  1156|     }
  1157|     Mautic.campaignEndpoints[name] = {
  1158|         endpoint: ["Dot", { radius: 10 }],
  1159|         paintStyle: {
  1160|             fill: color
  1161|         },
  1162|         endpointStyle: {
  1163|           fill: color
  1164|         },
  1165|         connectorStyle: {
  1166|             stroke: connectorColor,
  1167|             strokeWidth: 2
  1168|         },
  1169|         connector: connectorStyle,
  1170|         connectorOverlays: [],
  1171|         maxConnections: -1,
  1172|         isTarget: isTarget,
  1173|         isSource: isSource,
  1174|         beforeDrop: Mautic.campaignBeforeDropCallback,
  1175|         beforeDetach: Mautic.campaignBeforeDetachCallback,
  1176|         beforeStartDetach: Mautic.campaignBeforeStartDetachCallback,
  1177|         beforeDrag: Mautic.campaignBeforeDragCallback
  1178|     }
  1179| };
  1180| /**
  1181|  * Register an anchor with JsPlumb
  1182|  *
  1183|  * @param names
  1184|  * @param el
  1185|  */
  1186| Mautic.campaignBuilderRegisterAnchors = function(names, el) {
  1187|     var id = mQuery(el).attr('id');
  1188|     mQuery(names).each(function(key, anchorName) {
  1189|         var theAnchor = Mautic.campaignEndpointDefinitions[anchorName]['anchors'];
  1190|         theAnchor[6] = anchorName.toLowerCase() + ' ' + id;
  1191|         var ep = Mautic.campaignBuilderInstance.addEndpoint(
  1192|             id,
  1193|             {
  1194|                 anchor: theAnchor,
  1195|                 uuid: id + "_" + anchorName.toLowerCase()
  1196|             },
  1197|             Mautic.campaignEndpoints[anchorName]
  1198|         );
  1199|         ep.bind("mouseover", function (endpoint, event) {
  1200|             var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
  1201|             if (!Mautic.campaignHoverCallback(epDetails, endpoint, event)) {
  1202|                 return;
  1203|             }
  1204|             if (epDetails.anchorName == 'top') {
  1205|                 return;
  1206|             }
  1207|             if (epDetails.anchorName == 'leadsourceleft' || epDetails.anchorName == 'leadsourceright') {
  1208|                 if (mQuery('#SourceList option:enabled').length === 1) {
  1209|                     return;
  1210|                 }
  1211|             }
  1212|             endpoint.setPaintStyle(
  1213|                 {
  1214|                     fill: endpoint.connectorStyle.stroke
  1215|                 }
  1216|             );
  1217|             var dot = mQuery(endpoint.canvas);
  1218|             dot.addClass('jtk-clickable_anchor');
  1219|             if (!dot.find('svg text').length) {
  1220|                 var svg = dot.find('svg')[0];
  1221|                 var textElement = document.createElementNS("http://www.w3.org/2000/svg", 'text');
  1222|                 textElement.setAttributeNS(null, 'x', '50%');
  1223|                 textElement.setAttributeNS(null, 'y', '50%');
  1224|                 textElement.setAttributeNS(null, 'text-anchor', 'middle');
  1225|                 textElement.setAttributeNS(null, 'stroke-width', '1px');
  1226|                 textElement.setAttributeNS(null, 'stroke', '#ffffff');
  1227|                 textElement.setAttributeNS(null, 'dy', '.3em');
  1228|                 var textNode = document.createTextNode('+');
  1229|                 textElement.appendChild(textNode);
  1230|                 svg.appendChild(textElement);
  1231|             }
  1232|         });
  1233|         ep.bind("mouseout", function (endpoint) {
  1234|             var dot = mQuery(endpoint.canvas);
  1235|             dot.removeClass('jtk-clickable_anchor');
  1236|             if (!endpoint.connections.length) {
  1237|                 endpoint.setPaintStyle(
  1238|                     {
  1239|                         fill: Mautic.campaignBuilderAnchorDefaultColor
  1240|                     }
  1241|                 );
  1242|             }
  1243|         });
  1244|         ep.bind("click", function (endpoint, event) {
  1245|             if (mQuery('#CampaignEvent_newsource').length) {
  1246|                 return;
  1247|             }
  1248|             var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
  1249|             if (epDetails.anchorName == 'top') {
  1250|                 return;
  1251|             }
  1252|             if (epDetails.anchorName == 'leadsourceleft' || epDetails.anchorName == 'leadsourceright') {
  1253|                 if (mQuery('#SourceList option:enabled').length === 1) {
  1254|                     return;
  1255|                 }
  1256|             }
  1257|             var epDetails = Mautic.campaignBuilderGetEndpointDetails(endpoint);
  1258|             var clickedAnchorName = epDetails.anchorName;
  1259|             Mautic.campaignBuilderAnchorClicked = endpoint.elementId+'_'+clickedAnchorName;
  1260|             Mautic.campaignBuilderAnchorNameClicked = clickedAnchorName;
  1261|             Mautic.campaignBuilderAnchorEventTypeClicked = epDetails.eventType;
  1262|             var elPos = Mautic.campaignBuilderGetEventPosition(endpoint.element);
  1263|             var spotFound = false,
  1264|                 putLeft = elPos.left,
  1265|                 putTop = elPos.top,
  1266|                 direction = '', // xl, xr, yu, yd
  1267|                 fullWidth = Mautic.campaignBuilderEventDimensions.width + Mautic.campaignBuilderEventDimensions.anchor,
  1268|                 wiggleWidth = fullWidth + Mautic.campaignBuilderEventDimensions.wiggleWidth,
  1269|                 fullHeight = Mautic.campaignBuilderEventDimensions.height + Mautic.campaignBuilderEventDimensions.anchor,
  1270|                 wiggleHeight = fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight,
  1271|                 debug = false;
  1272|             if (debug) {
  1273|                 console.log(Mautic.campaignBuilderEventPositions);
  1274|                 console.log(clickedAnchorName+' - starting with: x = '+ putLeft+', y = '+putTop);
  1275|             }
  1276|             switch (clickedAnchorName) {
  1277|                 case 'leadsourceleft':
  1278|                     direction = 'xl';
  1279|                     putLeft -= wiggleWidth;
  1280|                     break;
  1281|                 case 'leadsourceright':
  1282|                     direction = 'xr';
  1283|                     putLeft += wiggleWidth;
  1284|                     break;
  1285|                 case 'bottom':
  1286|                     direction = 'yd';
  1287|                     putTop += wiggleHeight;
  1288|                     break;
  1289|                 case 'yes':
  1290|                 case 'leadsource':
  1291|                     putLeft -= Mautic.campaignBuilderEventDimensions.width/2;
  1292|                     putTop  += wiggleHeight;
  1293|                     direction = 'xl';
  1294|                     break;
  1295|                 case 'no':
  1296|                     putLeft += Mautic.campaignBuilderEventDimensions.width/2;
  1297|                     putTop  += wiggleHeight;
  1298|                     direction = 'xr';
  1299|                     break;
  1300|                 case 'top':
  1301|                     directon = 'yu';
  1302|                     putTop -= wiggleHeight;
  1303|                     break;
  1304|             }
  1305|             if (debug) {
  1306|                 console.log('Going direction: '+direction);
  1307|                 console.log('Start test with: x = '+ putLeft+', y = '+putTop);
  1308|             }
  1309|             var counter = 0;
  1310|             var windowWidth = mQuery(window).width();
  1311|             while (!spotFound) {
  1312|                 var isOccupied = false;
  1313|                 mQuery.each(Mautic.campaignBuilderEventPositions, function (id, pos) {
  1314|                     var l = Math.max(putLeft, pos.left);
  1315|                     var r = Math.min(putLeft + fullWidth, pos.left + fullWidth);
  1316|                     var b = Math.max(putTop, pos.top);
  1317|                     var t = Math.min(putTop + fullHeight, pos.top + fullHeight);
  1318|                     var h = t-b;
  1319|                     var w = r-l;
  1320|                     if (debug) {
  1321|                         console.log('Checking ' + id);
  1322|                         console.log(putLeft, putTop, l,r,b,t,h,w);
  1323|                     }
  1324|                     if (h > 0 && w > 0) {
  1325|                         if (debug) {
  1326|                             console.log('Slot occupied by '+id);
  1327|                         }
  1328|                         isOccupied = true;
  1329|                         switch (direction) {
  1330|                             case 'xl':
  1331|                                 putLeft -= (w + Mautic.campaignBuilderEventDimensions.wiggleWidth);
  1332|                                 if (putLeft <= 0) {
  1333|                                     putLeft = 0;
  1334|                                     direction = 'yd';
  1335|                                     putTop += fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight;
  1336|                                 }
  1337|                                 break;
  1338|                             case 'xr':
  1339|                                 if (putLeft + w + Mautic.campaignBuilderEventDimensions.wiggleWidth > windowWidth) {
  1340|                                     direction = 'yd';
  1341|                                     putLeft -= Mautic.campaignBuilderEventDimensions.wiggleWidth;
  1342|                                     putTop += fullHeight + Mautic.campaignBuilderEventDimensions.wiggleHeight;
  1343|                                 } else {
  1344|                                     putLeft += (w + Mautic.campaignBuilderEventDimensions.wiggleWidth);
  1345|                                 }
  1346|                                 break;
  1347|                             case 'yu':
  1348|                                 putTop -= (h - Mautic.campaignBuilderEventDimensions.wiggleHeight);
  1349|                                 if (putTop <= 0) {
  1350|                                     putTop = 0;
  1351|                                     direction = 'xr';
  1352|                                 }
  1353|                                 break;
  1354|                             case 'yd':
  1355|                                 putTop += (h + Mautic.campaignBuilderEventDimensions.wiggleHeight);
  1356|                                 break;
  1357|                         }
  1358|                         return false
  1359|                     }
  1360|                 });
  1361|                 if (!isOccupied) {
  1362|                     if (debug) {
  1363|                        console.log('It fits!');
  1364|                     }
  1365|                     spotFound = true;
  1366|                 }
  1367|                 counter++;
  1368|                 if (counter >= 100) {
  1369|                     putTop = 10;
  1370|                     putLeft = 10;
  1371|                     if (debug) {
  1372|                         console.log('Too many loops');
  1373|                     }
  1374|                     spotFound = true;
  1375|                 }
  1376|             }
  1377|             if (debug) {
  1378|                 console.log('To be placed at: x = '+ putLeft+', y = '+putTop);
  1379|             }
  1380|             if (putLeft <= 0) {
  1381|                 putLeft = 10;
  1382|             }
  1383|             if (putTop <= 0) {
  1384|                 putTop = 10;
  1385|             }
  1386|             mQuery('#droppedX').val(putLeft);
  1387|             mQuery('#droppedY').val(putTop);
  1388|             var allowedEvents = [];
  1389|             mQuery.each(Mautic.campaignBuilderConnectionsMap[epDetails.eventType][epDetails.anchorName], function (group, eventTypes) {
  1390|                 if (eventTypes.length) {
  1391|                     allowedEvents[allowedEvents.length] = group.charAt(0).toUpperCase() + group.substr(1);
  1392|                 }
  1393|             });
  1394|             Mautic.campaignBuilderAnchorClickedAllowedEvents = allowedEvents;
  1395|             Mautic.campaignBuilderIsEventCloneAllowed = Mautic.isCampaignCloneEventAllowedForEndpoint(epDetails);
  1396|             if (!(mQuery('.preview').length)) {
  1397|                 var el = (mQuery(event.target).hasClass('jtk-endpoint')) ? event.target : mQuery(event.target).parents('.jtk-endpoint')[0];
  1398|                 Mautic.campaignBuilderAnchorClickedPosition = Mautic.campaignBuilderGetEventPosition(el);
  1399|                 Mautic.campaignBuilderUpdateEventList(allowedEvents, false, 'groups');
  1400|                 Mautic.campaignBuilderUpdateEventCloneButton(allowedEvents, epDetails.eventType, epDetails.anchorName);
  1401|                 Mautic.campaignBuilderUpdateEventCloneDescription();
  1402|             }
  1403|             mQuery('.campaign-event-selector:not(#SourceList) option').prop('disabled', false);
  1404|             if ('source' == epDetails.eventType) {
  1405|                 var checkSelects = ['action', 'decision', 'condition'];
  1406|             } else {
  1407|                 var primaryType       = (epDetails.eventType === 'decision') ? 'action': 'decision';
  1408|                 var checkSelects = [primaryType, 'condition'];
  1409|             }
  1410|             mQuery.each(checkSelects, function(key, targetType) {
  1411|                 var selectId = '#' + targetType.charAt(0).toUpperCase() + targetType.slice(1) + 'List';
  1412|                 mQuery(selectId + ' option').each(function () {
  1413|                     var optionVal = mQuery(this).val();
  1414|                     if (optionVal) {
  1415|                         if (!Mautic.campaignBuilderValidateConnection(epDetails, targetType, optionVal)) {
  1416|                             mQuery(this).prop('disabled', true);
  1417|                         }
  1418|                     }
  1419|                 });
  1420|                 mQuery(selectId).trigger('chosen:updated');
  1421|             });
  1422|         });
  1423|     });
  1424| };
  1425| /**
  1426|  * Extract information about an event/endpoint from element
  1427|  *
  1428|  * @param el
  1429|  * @returns {{left: Number, top: Number}}
  1430|  */
  1431| Mautic.campaignBuilderGetEventPosition = function(el) {
  1432|     return {
  1433|         'left': parseInt(mQuery(el).css('left')),
  1434|         'top': parseInt(mQuery(el).css('top'))
  1435|     }
  1436| };
  1437| /**
  1438|  * Update the event select list
  1439|  *
  1440|  * @param groups
  1441|  * @param hidden
  1442|  * @param view
  1443|  * @param active
  1444|  * @param forcePosition
  1445|  */
  1446| Mautic.campaignBuilderUpdateEventList = function (groups, hidden, view, active, forcePosition) {
  1447|     var groupsEnabled = 0;
  1448|     var inGroupsView = ('groups' == view);
  1449|     if (groups.length === 1 && mQuery.inArray('Source', groups) !== -1 && !hidden) {
  1450|         inGroupsView = false;
  1451|     }
  1452|     mQuery.each(['Source', 'Action', 'Decision', 'Condition'], function (key, theGroup) {
  1453|         if (mQuery.inArray(theGroup, groups) !== -1) {
  1454|             if (inGroupsView) {
  1455|                 mQuery('#' + theGroup + 'GroupSelector').removeClass('hide');
  1456|                 if ('source' != theGroup) {
  1457|                     groupsEnabled++;
  1458|                 }
  1459|             } else {
  1460|                 mQuery('#' + theGroup + 'GroupList').removeClass('hide');
  1461|             }
  1462|         } else {
  1463|             if (inGroupsView) {
  1464|                 mQuery('#' + theGroup + 'GroupSelector').addClass('hide');
  1465|             } else {
  1466|                 mQuery('#' + theGroup + 'GroupList').addClass('hide');
  1467|             }
  1468|         }
  1469|     });
  1470|     mQuery('#CampaignEventPanelGroups').removeClass('groups-enabled-1 groups-enabled-2 groups-enabled-3')
  1471|     mQuery('#CampaignEventPanelGroups').addClass('groups-enabled-' + groups.length)
  1472|     if (inGroupsView) {
  1473|         mQuery.each(groups, function (key, theGroup) {
  1474|             mQuery('#'+theGroup+'GroupSelector').removeClass(
  1475|                 function (index, css) {
  1476|                     return (css.match(/col-(\S+)/g) || []).join(' ');
  1477|                 }
  1478|             ).addClass('col-md-' + (12 / groupsEnabled));
  1479|         });
  1480|         var newWidth = (500 / 3) * groupsEnabled;
  1481|         if (newWidth >= mQuery(window).width()) {
  1482|             newWidth = mQuery(window).width() - 10;
  1483|         }
  1484|         var leftPos = (forcePosition) ? forcePosition.left : Mautic.campaignBuilderAnchorClickedPosition.left - (newWidth / 2 - 10);
  1485|         var topPos  = (forcePosition) ? forcePosition.top : Mautic.campaignBuilderAnchorClickedPosition.top + 25;
  1486|         mQuery('#CampaignEventPanel').css({
  1487|                 left: (leftPos >=0 ) ? leftPos : 10,
  1488|                 top: topPos,
  1489|                 width: newWidth,
  1490|             });
  1491|         mQuery('#CampaignEventPanel').removeClass('hide');
  1492|         mQuery('#CampaignEventPanelGroups').removeClass('hide');
  1493|         mQuery('#CampaignEventPanelLists').addClass('hide');
  1494|         if (Mautic.campaignBuilderIsEventCloneAllowed) {
  1495|             mQuery('#CampaignPasteContainer').removeClass('hide');
  1496|         } else {
  1497|             mQuery('#CampaignPasteContainer').addClass('hide');
  1498|         }
  1499|     } else {
  1500|         var leftPos = (forcePosition) ? forcePosition.left : Mautic.campaignBuilderAnchorClickedPosition.left - 125;
  1501|         var topPos  = (forcePosition) ? forcePosition.top : Mautic.campaignBuilderAnchorClickedPosition.top + 25;
  1502|         mQuery('#CampaignEventPanel').css({
  1503|             left: (leftPos >= 0) ? leftPos : 10,
  1504|             top: topPos,
  1505|             width: 300,
  1506|         });
  1507|         mQuery('#CampaignEventPanelGroups').addClass('hide');
  1508|         mQuery('#CampaignEventPanelLists').removeClass('hide');
  1509|         mQuery('#CampaignEventPanel').removeClass('hide');
  1510|         if (groups.length === 1) {
  1511|             setTimeout(function () {
  1512|                 mQuery('#CampaignEventPanelLists #' + groups[0] + 'List').trigger('chosen:open');
  1513|             }, 10);
  1514|         }
  1515|     }
  1516| };
  1517| Mautic.campaignBuilderUpdateEventCloneButton = function (groups, eventType, anchorName) {
  1518|     var $insertButton = mQuery('#EventInsertButton');
  1519|     var updatedUrl = $insertButton.attr('href').replace(/anchor=(.*?)$/, "anchor=" + anchorName + "&anchorEventType=" + eventType);
  1520|     $insertButton.attr('href', updatedUrl);
  1521| };
  1522| Mautic.campaignBuilderUpdateEventCloneDescription = function () {
  1523|     var cloneDetails = Mautic.getCampaignEventClone();
  1524|     if (cloneDetails) {
  1525|         mQuery('[data-campaign-event-clone="sourceEventName"]').html(cloneDetails['sourceEventName']);
  1526|         mQuery('[data-campaign-event-clone="sourceCampaignName"]').html(cloneDetails['sourceCampaignName']);
  1527|     }
  1528| };
  1529| /**
  1530|  *
  1531|  * @param endpoint
  1532|  * @param nameOnly
  1533|  * @returns {{endpointName: *, elementId: *}}
  1534|  */
  1535| Mautic.campaignBuilderGetEndpointDetails = function(endpoint) {
  1536|     var anchorName, eventId;
  1537|     if (typeof endpoint === 'string') {
  1538|         eventId = endpoint;
  1539|     } else {
  1540|         var parts = endpoint.anchor.cssClass.split(' ');
  1541|         if (parts.length > 1) {
  1542|             anchorName = parts[0];
  1543|             eventId = parts[1];
  1544|         } else {
  1545|             anchorName = parts[0];
  1546|             eventId = endpoint.elementId
  1547|         }
  1548|     }
  1549|     return {
  1550|         'anchorName': anchorName,
  1551|         'eventId': eventId.replace('CampaignEvent_', ''),
  1552|         'elementId' : eventId,
  1553|         'eventType': mQuery('#'+eventId).data('type'),
  1554|         'event': mQuery('#'+eventId).data('event')
  1555|     };
  1556| };
  1557| /**
  1558|  * Display new source when required
  1559|  */
  1560| Mautic.campaignBuilderPrepareNewSource = function () {
  1561|     var newSourcePos = {
  1562|         left: mQuery(window).width()/2 - 100,
  1563|         top: 50
  1564|     };
  1565|     mQuery('#CampaignEvent_newsource').css(newSourcePos);
  1566|     Mautic.campaignBuilderUpdateEventList(['Source'], false, 'list', false, {
  1567|         left: newSourcePos.left - 50,
  1568|         top: newSourcePos.top + 35
  1569|     });
  1570|     mQuery('#SourceList').trigger('chosen:open');
  1571| };
  1572| /**
  1573|  *
  1574|  * @param epDetails
  1575|  * @param targetType action|decision|condition
  1576|  * @param targetEvent
  1577|  * @returns {boolean}
  1578|  */
  1579| Mautic.campaignBuilderValidateConnection = function (epDetails, targetType, targetEvent) {
  1580|     var valid = true;
  1581|     var sourceType  = epDetails.eventType;
  1582|     var sourceEvent = 'source' === sourceType ? sourceType : epDetails.event;
  1583|     if (typeof Mautic.campaignBuilderConnectionRestrictions[targetEvent] !== 'undefined') {
  1584|         if ('source' === sourceEvent) {
  1585|             mQuery.each(Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'], function(eventType, events) {
  1586|                 if (events.length) {
  1587|                     valid = false;
  1588|                     return false;
  1589|                 }
  1590|             });
  1591|             return valid;
  1592|         }
  1593|         if (
  1594|             typeof Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType] !== 'undefined' &&
  1595|             Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType].length &&
  1596|             mQuery.inArray(sourceEvent, Mautic.campaignBuilderConnectionRestrictions[targetEvent]['source'][sourceType]) === -1
  1597|         ) {
  1598|             valid = false;
  1599|         }
  1600|     }
  1601|     if (
  1602|         typeof Mautic.campaignBuilderConnectionRestrictions[sourceEvent] !== 'undefined' &&
  1603|         typeof Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType] !== 'undefined' &&
  1604|         Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType].length
  1605|     ) {
  1606|         valid = (mQuery.inArray(targetEvent, Mautic.campaignBuilderConnectionRestrictions[sourceEvent]['target'][targetType]) !== -1);
  1607|     }
  1608|     if (
  1609|         typeof Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType] !== 'undefined' &&
  1610|         typeof Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType][targetEvent] !== 'undefined'
  1611|     ) {
  1612|         mQuery(Mautic.campaignBuilderConnectionRestrictions['anchor'][sourceType][targetEvent]).each(
  1613|             function(key, anchor) {
  1614|                 switch (anchor) {
  1615|                     case 'inaction':
  1616|                         anchor = 'no';
  1617|                         break;
  1618|                     case 'action':
  1619|                         anchor = 'yes';
  1620|                         break;
  1621|                 }
  1622|                 if (anchor == epDetails.anchorName) {
  1623|                     valid = false;
  1624|                     return false;
  1625|                 }
  1626|             }
  1627|         );
  1628|     }
  1629|     return valid;
  1630| };
  1631| /**
  1632|  *
  1633|  * @param eventId
  1634|  * @param contactId
  1635|  */
  1636| Mautic.updateScheduledCampaignEvent = function(eventId, contactId) {
  1637|     mQuery('#timeline-campaign-event-'+eventId+' .btn-reschedule').addClass('disabled');
  1638|     var converting = false;
  1639|     var eventWrapper = '#timeline-campaign-event-'+eventId;
  1640|     var eventSpan = '.timeline-campaign-event-date-'+eventId;
  1641|     var eventText = '#timeline-campaign-event-text-'+eventId;
  1642|     var saveButton = '#timeline-campaign-event-save-' + eventId;
  1643|     var originalDate = mQuery(eventWrapper+' '+eventSpan).first().text();
  1644|     var revertInput = function(input) {
  1645|         converting = true;
  1646|         mQuery(input).datetimepicker('destroy');
  1647|         mQuery(eventSpan).text(originalDate);
  1648|         mQuery(eventWrapper+' .btn-reschedule').removeClass('disabled');
  1649|     };
  1650|     var date = mQuery(eventSpan).attr('data-date');
  1651|     mQuery(saveButton).show();
  1652|     var input = mQuery('<input type="text" id="timeline-reschedule"/>')
  1653|         .css('height', '20px')
  1654|         .css('color', '#000000')
  1655|         .val(date)
  1656|         .on('keyup', function(e) {
  1657|             var code = e.keyCode || e.which;
  1658|             if (code == 13) {
  1659|                 e.preventDefault();
  1660|                 converting = true
  1661|                 mQuery(input).prop('readonly', true);
  1662|                 mQuery(input).datetimepicker('destroy');
  1663|                 Mautic.ajaxActionRequest('campaign:updateScheduledCampaignEvent',
  1664|                     {
  1665|                         eventId: eventId,
  1666|                         contactId: contactId,
  1667|                         date: mQuery(this).val(),
  1668|                         originalDate: date
  1669|                     }, function (response) {
  1670|                         mQuery(eventSpan).text(response.formattedDate);
  1671|                         mQuery(eventSpan).attr('data-date', response.date);
  1672|                         mQuery(eventWrapper+' .btn-reschedule').removeClass('disabled');
  1673|                         if (response.success) {
  1674|                             mQuery(eventText).removeClass('text-warning').addClass('text-info');
  1675|                             mQuery(eventSpan).css('textDecoration', 'inherit');
  1676|                             mQuery('.fa.timeline-campaign-event-cancelled-'+eventId).remove();
  1677|                             mQuery('.timeline-campaign-event-scheduled-'+eventId).removeClass('hide');
  1678|                             mQuery('.timeline-campaign-event-cancelled-'+eventId).addClass('hide');
  1679|                             mQuery(saveButton).hide();
  1680|                         }
  1681|                     }, false
  1682|                 );
  1683|             } else if (code == 27) {
  1684|                 e.preventDefault();
  1685|                 revertInput(input);
  1686|                 mQuery(saveButton).hide();
  1687|             }
  1688|         })
  1689|         .on('blur', function (e) {
  1690|             if (!converting) {
  1691|                 revertInput(input);
  1692|             }
  1693|             mQuery(saveButton).hide();
  1694|         });
  1695|     mQuery('#timeline-campaign-event-'+eventId+' '+eventSpan).html(input);
  1696|     Mautic.activateDateTimeInputs('#timeline-reschedule');
  1697|     mQuery('#timeline-reschedule').focus();
  1698| };
  1699| /**
  1700|  *
  1701|  * @param eventId
  1702|  * @param contactId
  1703|  */
  1704| Mautic.saveScheduledCampaignEvent = function (eventId, contactId) {
  1705|     var saveButton = '#timeline-campaign-event-save-' + eventId;
  1706|     mQuery(saveButton).addClass('disabled');
  1707|     var eventWrapper = '#timeline-campaign-event-' + eventId;
  1708|     var eventSpan = '.timeline-campaign-event-date-' + eventId;
  1709|     var eventText = '#timeline-campaign-event-text-' + eventId;
  1710|     var date = mQuery(eventSpan).attr('data-date');
  1711|     Mautic.ajaxActionRequest('campaign:updateScheduledCampaignEvent',
  1712|         {
  1713|             eventId: eventId,
  1714|             contactId: contactId,
  1715|             date: mQuery('#timeline-reschedule').val(),
  1716|             originalDate: date
  1717|         }, function (response) {
  1718|             mQuery(eventSpan).text(response.formattedDate);
  1719|             mQuery(eventSpan).attr('data-date', response.date);
  1720|             if (response.success) {
  1721|                 mQuery(eventText).removeClass('text-warning').addClass('text-info');
  1722|                 mQuery(eventSpan).css('textDecoration', 'inherit');
  1723|                 mQuery('.fa.timeline-campaign-event-cancelled-' + eventId).remove();
  1724|                 mQuery('.timeline-campaign-event-scheduled-' + eventId).removeClass('hide');
  1725|                 mQuery('.timeline-campaign-event-cancelled-' + eventId).addClass('hide');
  1726|             }
  1727|             mQuery(saveButton).removeClass('disabled').hide();
  1728|             mQuery(eventWrapper + ' .btn-reschedule').removeClass('disabled');
  1729|         }, false);
  1730| };
  1731| /**
  1732|  *
  1733|  * @param eventId
  1734|  * @param contactId
  1735|  */
  1736| Mautic.cancelScheduledCampaignEvent = function(eventId, contactId) {
  1737|     mQuery('#timeline-campaign-event-'+eventId+' .btn').prop('disabled', true).addClass('disabled');
  1738|     var eventWrapper = '#timeline-campaign-event-'+eventId;
  1739|     var eventSpan = '.timeline-campaign-event-date-' + eventId;
  1740|     var eventText = '#timeline-campaign-event-text-' + eventId;
  1741|     Mautic.ajaxActionRequest('campaign:cancelScheduledCampaignEvent',
  1742|         {
  1743|             eventId: eventId,
  1744|             contactId: contactId,
  1745|         }, function (response) {
  1746|             if (response.success) {
  1747|                 mQuery(eventText).removeClass('text-info').addClass('text-warning');
  1748|                 mQuery(eventWrapper+' .btn-edit').prop('disabled', false).removeClass('disabled');
  1749|                 mQuery('.timeline-campaign-event-scheduled-'+eventId).addClass('hide');
  1750|                 mQuery('.timeline-campaign-event-cancelled-'+eventId).removeClass('hide');
  1751|             } else {
  1752|                 mQuery(eventWrapper+' .btn').prop('disabled', false).removeClass('disabled');
  1753|             }
  1754|         }, false
  1755|     );
  1756| };
  1757| /**
  1758|  * Update the "Jump to Event" select list to be available events.
  1759|  */
  1760| Mautic.updateJumpToEventOptions = function() {
  1761|     var jumpToEventSelectNode = mQuery("#campaignevent_properties_jumpToEvent");
  1762|     jumpToEventSelectNode.children().remove();
  1763|     for (var eventId in Mautic.campaignBuilderCanvasEvents) {
  1764|         var event = Mautic.campaignBuilderCanvasEvents[eventId];
  1765|         if (event.type !== 'campaign.jump_to_event' && event.eventType !== 'decision') {
  1766|             var opt = mQuery("<option />")
  1767|                 .attr("value", event.id)
  1768|                 .text(event.name)
  1769|             if (event.id == jumpToEventSelectNode.data("selected")) {
  1770|                 opt.attr("selected", "selected");
  1771|             }
  1772|             jumpToEventSelectNode.append(opt);
  1773|         }
  1774|     }
  1775|     jumpToEventSelectNode.trigger("chosen:updated");
  1776| };
  1777| Mautic.highlightJumpTarget = function(event, el) {
  1778|     var element = mQuery(el);
  1779|     var parentEventElement = element.parent().parent();
  1780|     var highlightedAlready = parentEventElement.data('highlighted');
  1781|     var jumpTargetID = '#CampaignEvent_' + element.data('jumpTarget');
  1782|     var jumpTarget = mQuery(jumpTargetID);
  1783|     var overlay = mQuery('#EventJumpOverlay');
  1784|     if (highlightedAlready) {
  1785|         parentEventElement.data('highlighted', false);
  1786|         overlay.hide();
  1787|         parentEventElement.css("z-index", 1010);
  1788|         jumpTarget.css("z-index", 1010);
  1789|     } else {
  1790|         parentEventElement.data('highlighted', true);
  1791|         overlay.show();
  1792|         parentEventElement.css("z-index", 2010);
  1793|         jumpTarget.css("z-index", 2010);
  1794|     }
  1795| };
  1796| /**
  1797|  * Display confirmation modal if user wishes to unpublish the campaign.
  1798|  */
  1799| Mautic.showCampaignConfirmation = function (el) {
  1800|     let element = mQuery(el);
  1801|     if (element.prop('checked') && element.val() !== "1") {
  1802|         Mautic.showConfirmation(element);
  1803|     }
  1804| };
  1805| /**
  1806|  * Cancel Callback to trigger the yes button and dismiss the confirmation modal.
  1807|  */
  1808| Mautic.setPublishedButtonToYes = function (el) {
  1809|     Mautic.dismissConfirmation();
  1810|     var yesButton  = mQuery(el).parent('.btn-no').siblings('.btn-yes').children('input');
  1811|     var yesButtonId = mQuery(yesButton).attr('id');
  1812|     if (yesButtonId !== undefined) {
  1813|         mQuery('#' + yesButtonId).trigger('click');
  1814|         mQuery(el).parent('.btn-no').removeClass('active');
  1815|         mQuery(el).parent('.btn-no').siblings('.btn-yes').addClass('active');
  1816|     }
  1817| };
  1818| /**
  1819|  * Onclick Callback to show the confirmation modal during toggling campaign status.
  1820|  */
  1821| Mautic.confirmationCampaignPublishStatus = function (el) {
  1822|     let element = mQuery(el);
  1823|     if (element.data('status') === 'published') {
  1824|         Mautic.showConfirmation(element);
  1825|     }
  1826|     else {
  1827|         Mautic.confirmCallbackCampaignPublishStatus('', el);
  1828|     }
  1829| }
  1830| /**
  1831|  * Confirm Callback to toggling campaign status if user chooses Yes.
  1832|  */
  1833| Mautic.confirmCallbackCampaignPublishStatus = function (action, el) {
  1834|     let element = mQuery(el);
  1835|     let idClass = element.data('id-class');
  1836|     let model = element.data('model');
  1837|     let itemId = element.data('item-id');
  1838|     let query = element.data('query');
  1839|     let backdrop = element.data('backdrop');
  1840|     Mautic.togglePublishStatus(event, idClass, model, itemId, query, backdrop);
  1841|     Mautic.dismissConfirmation();
  1842| }
  1843| Mautic.isCampaignCloneEventAllowedForEndpoint = function(endpointDetails) {
  1844|     const eventClone = Mautic.getCampaignEventClone();
  1845|     if (!eventClone) {
  1846|         return false;
  1847|     }
  1848|     const eventType = eventClone['sourceEventType'].charAt(0).toUpperCase() + eventClone['sourceEventType'].slice(1);
  1849|     const allowedEvents = Mautic.campaignBuilderAnchorClickedAllowedEvents || [];
  1850|     const isValidConnection = Mautic.campaignBuilderValidateConnection(endpointDetails, eventClone['sourceEventType'], eventClone['sourceType']);
  1851|     return allowedEvents.includes(eventType) && isValidConnection;
  1852| }
  1853| Mautic.getCampaignEventClone = function() {
  1854|     const eventClone = localStorage.getItem("mautic_campaign_event_clone");
  1855|     return eventClone === null ? null : JSON.parse(eventClone);
  1856| }
  1857| Mautic.setCampaignEventClone = function(data) {
  1858|     localStorage.setItem("mautic_campaign_event_clone", JSON.stringify(data));
  1859| }
  1860| Mautic.clearCampaignEventClone = function() {
  1861|     localStorage.removeItem("mautic_campaign_event_clone");
  1862| }
  1863| Mautic.hideCampaignEventPanel = function() {
  1864|     mQuery('#CampaignEventPanel').addClass('hide');
  1865| }
  1866| Mautic.previewCampaignLabels = function() {
  1867|     const campaignBuilder = Mautic.campaignBuilderInstance;
  1868|     const managedElements = Mautic.campaignBuilderInstance.getManagedElements();
  1869|     const allElements = Object.values(managedElements).map(el => el.el);
  1870|     allElements.forEach(function(element) {
  1871|         const id = element.id;
  1872|         const connections = campaignBuilder.getConnections({source: id});
  1873|         connections.forEach(function(connection) {
  1874|             const connectionAnchor = connection.target.dataset.connected ?? null;
  1875|             if (connectionAnchor === 'yes') {
  1876|                 connection.addOverlay(["Label", {
  1877|                     label: element.dataset.eventYesPercent + '%',
  1878|                     location: 0.44,
  1879|                     cssClass: 'jtk-label jtk-label--success',
  1880|                     id: element.id + 'yes-path-label'
  1881|                 }]);
  1882|             }
  1883|             if (connectionAnchor === 'no') {
  1884|                 connection.addOverlay(["Label", {
  1885|                     label: element.dataset.eventNoPercent + '%',
  1886|                     location: 0.44,
  1887|                     cssClass: 'jtk-label jtk-label--error',
  1888|                     id: element.id + 'no-path-label'
  1889|                 }]);
  1890|             }
  1891|         });
  1892|     });
  1893| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/CampaignDeleteEventLogsCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Command;
     4| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     5| use Mautic\CampaignBundle\Model\CampaignModel;
     6| use Mautic\CampaignBundle\Model\EventModel;
     7| use Symfony\Component\Console\Command\Command;
     8| use Symfony\Component\Console\Input\InputArgument;
     9| use Symfony\Component\Console\Input\InputInterface;
    10| use Symfony\Component\Console\Input\InputOption;
    11| use Symfony\Component\Console\Output\OutputInterface;
    12| class CampaignDeleteEventLogsCommand extends Command
    13| {
    14|     protected static $defaultDescription = 'Delete campaign event logs';
    15|     /**
    16|      * @var string
    17|      */
    18|     public const COMMAND_NAME = 'mautic:campaign:delete-event-logs';
    19|     public function __construct(private LeadEventLogRepository $leadEventLogRepository, private CampaignModel $campaignModel, private EventModel $eventModel)
    20|     {
    21|         parent::__construct();
    22|     }
    23|     protected function configure(): void
    24|     {
    25|         $this->setName(self::COMMAND_NAME)
    26|             ->addArgument(
    27|                 'campaign_event_ids',
    28|                 InputArgument::IS_ARRAY | InputArgument::OPTIONAL,
    29|                 'Campaign event ids to delete event logs.'
    30|             )
    31|             ->addOption(
    32|                 '--campaign-id',
    33|                 '-i',
    34|                 InputOption::VALUE_OPTIONAL,
    35|                 'Delete campaign also otherwise will delete event and event log only.'
    36|             );
    37|     }
    38|     protected function execute(InputInterface $input, OutputInterface $output): int
    39|     {
    40|         $eventIds   = $input->getArgument('campaign_event_ids');
    41|         $campaignId = (int) $input->getOption('campaign-id');
    42|         if (!empty($campaignId)) {
    43|             $this->leadEventLogRepository->removeEventLogsByCampaignId($campaignId);
    44|             $this->eventModel->deleteEventsByCampaignId($campaignId);
    45|             $campaign = $this->campaignModel->getEntity($campaignId);
    46|             $this->campaignModel->deleteCampaign($campaign);
    47|         } elseif (!empty($eventIds)) {
    48|             $this->leadEventLogRepository->removeEventLogs($eventIds);
    49|             $this->eventModel->deleteEventsByEventIds($eventIds);
    50|         }
    51|         return Command::SUCCESS;
    52|     }
    53| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/ExecuteEventCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Command;
     3| use Mautic\CampaignBundle\Executioner\ScheduledExecutioner;
     4| use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
     5| use Symfony\Component\Console\Command\Command;
     6| use Symfony\Component\Console\Input\InputInterface;
     7| use Symfony\Component\Console\Input\InputOption;
     8| use Symfony\Component\Console\Output\OutputInterface;
     9| use Symfony\Contracts\Translation\TranslatorInterface;
    10| class ExecuteEventCommand extends Command
    11| {
    12|     use WriteCountTrait;
    13|     public function __construct(
    14|         private ScheduledExecutioner $scheduledExecutioner,
    15|         private TranslatorInterface $translator,
    16|         private FormatterHelper $formatterHelper,
    17|     ) {
    18|         parent::__construct();
    19|     }
    20|     protected function configure()
    21|     {
    22|         $this
    23|             ->setName('mautic:campaigns:execute')
    24|             ->addOption(
    25|                 '--scheduled-log-ids',
    26|                 null,
    27|                 InputOption::VALUE_REQUIRED,
    28|                 'CSV of specific scheduled log IDs to execute.'
    29|             )
    30|             ->addOption(
    31|                 '--execution-time',
    32|                 null,
    33|                 InputOption::VALUE_REQUIRED,
    34|                 'Scheduled execution time of event log'
    35|             );
    36|         parent::configure();
    37|     }
    38|     /**
    39|      * @throws \Exception
    40|      */
    41|     protected function execute(InputInterface $input, OutputInterface $output): int
    42|     {
    43|         defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
    44|         $now     = empty($input->getOption('execution-time')) ? null : new \DateTime($input->getOption('execution-time'));
    45|         $ids     = $this->formatterHelper->simpleCsvToArray($input->getOption('scheduled-log-ids'), 'int');
    46|         $counter = $this->scheduledExecutioner->executeByIds($ids, $output, $now);
    47|         $this->writeCounts($output, $this->translator, $counter);
    48|         return Command::SUCCESS;
    49|     }
    50|     protected static $defaultDescription = 'Execute specific scheduled events.';
    51| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/SummarizeCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-67 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Command;
     4| use Mautic\CampaignBundle\Model\SummaryModel;
     5| use Mautic\CoreBundle\Command\ModeratedCommand;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| use Mautic\CoreBundle\Helper\PathsHelper;
     8| use Symfony\Component\Console\Input\InputInterface;
     9| use Symfony\Component\Console\Input\InputOption;
    10| use Symfony\Component\Console\Output\OutputInterface;
    11| use Symfony\Contracts\Translation\TranslatorInterface;
    12| class SummarizeCommand extends ModeratedCommand
    13| {
    14|     use WriteCountTrait;
    15|     public const NAME = 'mautic:campaigns:summarize';
    16|     public function __construct(
    17|         private TranslatorInterface $translator,
    18|         private SummaryModel $summaryModel,
    19|         PathsHelper $pathsHelper,
    20|         CoreParametersHelper $coreParametersHelper,
    21|     ) {
    22|         parent::__construct($pathsHelper, $coreParametersHelper);
    23|     }
    24|     protected function configure(): void
    25|     {
    26|         $this->setName(self::NAME)
    27|             ->addOption(
    28|                 '--batch-limit',
    29|                 '-l',
    30|                 InputOption::VALUE_OPTIONAL,
    31|                 'Number of hours to process per batch. 1 hour is default value.',
    32|                 '1'
    33|             )
    34|             ->addOption(
    35|                 '--max-hours',
    36|                 null,
    37|                 InputOption::VALUE_OPTIONAL,
    38|                 'Optionally specify how many hours back in time you wish to summarize.'
    39|             )
    40|             ->addOption(
    41|                 '--rebuild',
    42|                 null,
    43|                 InputOption::VALUE_NONE,
    44|                 'Rebuild existing data. To be used only if database exceptions have been known to cause inaccuracies.'
    45|             );
    46|         parent::configure();
    47|     }
    48|     /**
    49|      * @throws \Doctrine\DBAL\Exception
    50|      */
    51|     protected function execute(InputInterface $input, OutputInterface $output): int
    52|     {
    53|         if (!$this->checkRunStatus($input, $output)) {
    54|             return \Symfony\Component\Console\Command\Command::SUCCESS;
    55|         }
    56|         $batchLimit = (int) $input->getOption('batch-limit');
    57|         $maxHours   = (int) $input->getOption('max-hours');
    58|         $rebuild    = (bool) $input->getOption('rebuild');
    59|         $output->writeln(
    60|             "<info>{$this->translator->trans('mautic.campaign.summarizing', ['%batch%' => $batchLimit])}</info>"
    61|         );
    62|         $this->summaryModel->summarize($output, $batchLimit, $maxHours, $rebuild);
    63|         $this->completeRun();
    64|         return \Symfony\Component\Console\Command\Command::SUCCESS;
    65|     }
    66|     protected static $defaultDescription = 'Builds historical campaign summary statistics if they do not already exist.';
    67| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/TriggerCampaignCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-336 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Command;
     3| use Exception;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\Campaign;
     6| use Mautic\CampaignBundle\Entity\CampaignRepository;
     7| use Mautic\CampaignBundle\Event\CampaignTriggerEvent;
     8| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     9| use Mautic\CampaignBundle\Executioner\InactiveExecutioner;
    10| use Mautic\CampaignBundle\Executioner\KickoffExecutioner;
    11| use Mautic\CampaignBundle\Executioner\ScheduledExecutioner;
    12| use Mautic\CoreBundle\Command\ModeratedCommand;
    13| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    14| use Mautic\CoreBundle\Helper\PathsHelper;
    15| use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
    16| use Mautic\LeadBundle\Helper\SegmentCountCacheHelper;
    17| use Mautic\LeadBundle\Model\ListModel;
    18| use Psr\Log\LoggerInterface;
    19| use Symfony\Component\Console\Input\InputInterface;
    20| use Symfony\Component\Console\Input\InputOption;
    21| use Symfony\Component\Console\Output\NullOutput;
    22| use Symfony\Component\Console\Output\OutputInterface;
    23| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    24| use Symfony\Contracts\Translation\TranslatorInterface;
    25| class TriggerCampaignCommand extends ModeratedCommand
    26| {
    27|     use WriteCountTrait;
    28|     private bool $kickoffOnly  = false;
    29|     private bool $inactiveOnly = false;
    30|     private bool $scheduleOnly = false;
    31|     /**
    32|      * @var OutputInterface
    33|      */
    34|     protected $output;
    35|     private ?ContactLimiter $limiter = null;
    36|     private ?Campaign $campaign = null;
    37|     public function __construct(
    38|         private CampaignRepository $campaignRepository,
    39|         private EventDispatcherInterface $dispatcher,
    40|         private TranslatorInterface $translator,
    41|         private KickoffExecutioner $kickoffExecutioner,
    42|         private ScheduledExecutioner $scheduledExecutioner,
    43|         private InactiveExecutioner $inactiveExecutioner,
    44|         private LoggerInterface $logger,
    45|         private FormatterHelper $formatterHelper,
    46|         private ListModel $listModel,
    47|         private SegmentCountCacheHelper $segmentCountCacheHelper,
    48|         PathsHelper $pathsHelper,
    49|         CoreParametersHelper $coreParametersHelper,
    50|     ) {
    51|         parent::__construct($pathsHelper, $coreParametersHelper);
    52|     }
    53|     protected function configure()
    54|     {
    55|         $this
    56|             ->setName('mautic:campaigns:trigger')
    57|             ->addOption(
    58|                 '--campaign-id',
    59|                 '-i',
    60|                 InputOption::VALUE_OPTIONAL,
    61|                 'Trigger events for a specific campaign.  Otherwise, all campaigns will be triggered.',
    62|                 null
    63|             )
    64|             ->addOption(
    65|                 '--campaign-limit',
    66|                 null,
    67|                 InputOption::VALUE_OPTIONAL,
    68|                 'Limit number of contacts on a per campaign basis',
    69|                 null
    70|             )
    71|             ->addOption(
    72|                 '--contact-id',
    73|                 null,
    74|                 InputOption::VALUE_OPTIONAL,
    75|                 'Trigger events for a specific contact.',
    76|                 null
    77|             )
    78|             ->addOption(
    79|                 '--contact-ids',
    80|                 null,
    81|                 InputOption::VALUE_OPTIONAL,
    82|                 'CSV of contact IDs to evaluate.'
    83|             )
    84|             ->addOption(
    85|                 '--min-contact-id',
    86|                 null,
    87|                 InputOption::VALUE_OPTIONAL,
    88|                 'Trigger events starting at a specific contact ID.',
    89|                 null
    90|             )
    91|             ->addOption(
    92|                 '--max-contact-id',
    93|                 null,
    94|                 InputOption::VALUE_OPTIONAL,
    95|                 'Trigger events starting up to a specific contact ID.',
    96|                 null
    97|             )
    98|             ->addOption(
    99|                 '--thread-id',
   100|                 null,
   101|                 InputOption::VALUE_OPTIONAL,
   102|                 'The number of this current process if running multiple in parallel.'
   103|             )
   104|             ->addOption(
   105|                 '--max-threads',
   106|                 null,
   107|                 InputOption::VALUE_OPTIONAL,
   108|                 'The maximum number of processes you intend to run in parallel.'
   109|             )
   110|             ->addOption(
   111|                 '--kickoff-only',
   112|                 null,
   113|                 InputOption::VALUE_NONE,
   114|                 'Just kickoff the campaign'
   115|             )
   116|             ->addOption(
   117|                 '--scheduled-only',
   118|                 null,
   119|                 InputOption::VALUE_NONE,
   120|                 'Just execute scheduled events'
   121|             )
   122|             ->addOption(
   123|                 '--inactive-only',
   124|                 null,
   125|                 InputOption::VALUE_NONE,
   126|                 'Just execute scheduled events'
   127|             )
   128|             ->addOption(
   129|                 '--batch-limit',
   130|                 '-l',
   131|                 InputOption::VALUE_OPTIONAL,
   132|                 'Set batch size of contacts to process per round. Defaults to 100.',
   133|                 100
   134|             )
   135|             ->addOption(
   136|                 'exclude',
   137|                 'd',
   138|                 InputOption::VALUE_IS_ARRAY | InputOption::VALUE_OPTIONAL,
   139|                 'Exclude a specific campaign from being triggered. Otherwise, all campaigns will be triggered.',
   140|                 []
   141|             );
   142|         parent::configure();
   143|     }
   144|     /**
   145|      * @throws \Exception
   146|      */
   147|     protected function execute(InputInterface $input, OutputInterface $output): int
   148|     {
   149|         $quiet              = $input->getOption('quiet');
   150|         $this->output       = $quiet ? new NullOutput() : $output;
   151|         $this->kickoffOnly  = $input->getOption('kickoff-only');
   152|         $this->scheduleOnly = $input->getOption('scheduled-only');
   153|         $this->inactiveOnly = $input->getOption('inactive-only');
   154|         $id               = $input->getOption('campaign-id');
   155|         $batchLimit       = $input->getOption('batch-limit');
   156|         $campaignLimit    = $input->getOption('campaign-limit');
   157|         $contactMinId     = $input->getOption('min-contact-id');
   158|         $contactMaxId     = $input->getOption('max-contact-id');
   159|         $contactId        = $input->getOption('contact-id');
   160|         $contactIds       = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
   161|         $threadId         = $input->getOption('thread-id');
   162|         $maxThreads       = $input->getOption('max-threads');
   163|         $excludeCampaigns = $input->getOption('exclude');
   164|         if (is_numeric($id)) {
   165|             $id = (int) $id;
   166|         }
   167|         if (is_numeric($maxThreads)) {
   168|             $maxThreads = (int) $maxThreads;
   169|         }
   170|         if (is_numeric($threadId)) {
   171|             $threadId = (int) $threadId;
   172|         }
   173|         if (is_numeric($contactMaxId)) {
   174|             $contactMaxId = (int) $contactMaxId;
   175|         }
   176|         if (is_numeric($contactMinId)) {
   177|             $contactMinId = (int) $contactMinId;
   178|         }
   179|         if (is_numeric($contactId)) {
   180|             $contactId = (int) $contactId;
   181|         }
   182|         if (is_numeric($campaignLimit)) {
   183|             $campaignLimit = (int) $campaignLimit;
   184|         }
   185|         if ($threadId && $maxThreads && (int) $threadId > (int) $maxThreads) {
   186|             $this->output->writeln('--thread-id cannot be larger than --max-thread');
   187|             return \Symfony\Component\Console\Command\Command::FAILURE;
   188|         }
   189|         $this->limiter = new ContactLimiter($batchLimit, $contactId, $contactMinId, $contactMaxId, $contactIds, $threadId, $maxThreads, $campaignLimit);
   190|         defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
   191|         $moderationKey = sprintf('%s-%s', $id, $threadId);
   192|         if (!$this->checkRunStatus($input, $this->output, $moderationKey)) {
   193|             return \Symfony\Component\Console\Command\Command::SUCCESS;
   194|         }
   195|         if ($id) {
   196|             $statusCode = 0;
   197|             /** @var Campaign $campaign */
   198|             if ($campaign = $this->campaignRepository->getEntity($id)) {
   199|                 $this->triggerCampaign($campaign);
   200|             } else {
   201|                 $output->writeln('<error>'.$this->translator->trans('mautic.campaign.rebuild.not_found', ['%id%' => $id]).'</error>');
   202|                 $statusCode = 1;
   203|             }
   204|             $this->completeRun();
   205|             return (int) $statusCode;
   206|         }
   207|         $filter = [
   208|             'iterable_mode' => true,
   209|             'orderBy'       => 'c.dateAdded',
   210|             'orderByDir'    => 'DESC',
   211|         ];
   212|         if (is_array($excludeCampaigns) && count($excludeCampaigns) > 0) {
   213|             $filter['filter'] = [
   214|                 'force' => [
   215|                     [
   216|                         'expr'   => 'notIn',
   217|                         'column' => $this->campaignRepository->getTableAlias().'.id',
   218|                         'value'  => $excludeCampaigns,
   219|                     ],
   220|                 ],
   221|             ];
   222|         }
   223|         /** @var \Doctrine\ORM\Internal\Hydration\IterableResult $campaigns */
   224|         $campaigns = $this->campaignRepository->getEntities($filter);
   225|         foreach ($campaigns as $campaign) {
   226|             $this->triggerCampaign($campaign);
   227|             if ($this->limiter->hasCampaignLimit()) {
   228|                 $this->limiter->resetCampaignLimitRemaining();
   229|             }
   230|         }
   231|         $this->completeRun();
   232|         return \Symfony\Component\Console\Command\Command::SUCCESS;
   233|     }
   234|     /**
   235|      * @return bool
   236|      */
   237|     protected function dispatchTriggerEvent(Campaign $campaign)
   238|     {
   239|         if ($this->dispatcher->hasListeners(CampaignEvents::CAMPAIGN_ON_TRIGGER)) {
   240|             /** @var CampaignTriggerEvent $event */
   241|             $event = $this->dispatcher->dispatch(
   242|                 new CampaignTriggerEvent($campaign),
   243|                 CampaignEvents::CAMPAIGN_ON_TRIGGER
   244|             );
   245|             return $event->shouldTrigger();
   246|         }
   247|         return true;
   248|     }
   249|     /**
   250|      * @throws \Exception
   251|      */
   252|     private function triggerCampaign(Campaign $campaign): void
   253|     {
   254|         if (!$campaign->isPublished()) {
   255|             return;
   256|         }
   257|         if (!$this->dispatchTriggerEvent($campaign)) {
   258|             return;
   259|         }
   260|         $this->campaign = $campaign;
   261|         try {
   262|             $this->output->writeln('<info>'.$this->translator->trans('mautic.campaign.trigger.triggering', ['%id%' => $campaign->getId()]).'</info>');
   263|             $this->limiter->resetBatchMinContactId();
   264|             if (!$this->inactiveOnly && !$this->scheduleOnly) {
   265|                 $this->executeKickoff();
   266|             }
   267|             $this->limiter->resetBatchMinContactId();
   268|             if (!$this->inactiveOnly && !$this->kickoffOnly) {
   269|                 $this->executeScheduled();
   270|             }
   271|             $this->limiter->resetBatchMinContactId();
   272|             if (!$this->scheduleOnly && !$this->kickoffOnly) {
   273|                 $this->executeInactive();
   274|             }
   275|         } catch (\Exception $exception) {
   276|             if ('prod' !== MAUTIC_ENV) {
   277|                 throw $exception;
   278|             }
   279|             $this->logger->error('CAMPAIGN: '.$exception->getMessage());
   280|         } finally {
   281|             $this->updateCampaignSegmentContactCount($campaign);
   282|         }
   283|         if ('test' !== MAUTIC_ENV) {
   284|             $this->campaignRepository->detachEntity($campaign);
   285|         }
   286|     }
   287|     /**
   288|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
   289|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
   290|      * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
   291|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
   292|      */
   293|     private function executeKickoff(): void
   294|     {
   295|         $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.starting').'</comment>');
   296|         $counter = $this->kickoffExecutioner->execute($this->campaign, $this->limiter, $this->output);
   297|         $this->writeCounts($this->output, $this->translator, $counter);
   298|     }
   299|     /**
   300|      * @throws \Doctrine\ORM\Query\QueryException
   301|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
   302|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
   303|      * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
   304|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
   305|      */
   306|     private function executeScheduled(): void
   307|     {
   308|         $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.scheduled').'</comment>');
   309|         $counter = $this->scheduledExecutioner->execute($this->campaign, $this->limiter, $this->output);
   310|         $this->writeCounts($this->output, $this->translator, $counter);
   311|     }
   312|     /**
   313|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
   314|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
   315|      * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
   316|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
   317|      */
   318|     private function executeInactive(): void
   319|     {
   320|         $this->output->writeln('<comment>'.$this->translator->trans('mautic.campaign.trigger.negative').'</comment>');
   321|         $counter = $this->inactiveExecutioner->execute($this->campaign, $this->limiter, $this->output);
   322|         $this->writeCounts($this->output, $this->translator, $counter);
   323|     }
   324|     /**
   325|      * @throws \Exception
   326|      */
   327|     private function updateCampaignSegmentContactCount(Campaign $campaign): void
   328|     {
   329|         $segmentIds = $this->campaignRepository->getCampaignListIds((int) $campaign->getId());
   330|         foreach ($segmentIds as $segmentId) {
   331|             $totalLeadCount = $this->listModel->getRepository()->getLeadCount($segmentId);
   332|             $this->segmentCountCacheHelper->setSegmentContactCount($segmentId, (int) $totalLeadCount);
   333|         }
   334|     }
   335|     protected static $defaultDescription = 'Trigger timed events for published campaigns.';
   336| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/UpdateLeadCampaignsCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-198 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Command;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CampaignBundle\Entity\CampaignRepository;
     5| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     6| use Mautic\CampaignBundle\Membership\MembershipBuilder;
     7| use Mautic\CoreBundle\Command\ModeratedCommand;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\PathsHelper;
    10| use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
    11| use Psr\Log\LoggerInterface;
    12| use Symfony\Component\Console\Input\InputInterface;
    13| use Symfony\Component\Console\Input\InputOption;
    14| use Symfony\Component\Console\Output\NullOutput;
    15| use Symfony\Component\Console\Output\OutputInterface;
    16| use Symfony\Contracts\Translation\TranslatorInterface;
    17| class UpdateLeadCampaignsCommand extends ModeratedCommand
    18| {
    19|     private int $runLimit = 0;
    20|     private ContactLimiter $contactLimiter;
    21|     private bool $quiet = false;
    22|     public function __construct(
    23|         private CampaignRepository $campaignRepository,
    24|         private TranslatorInterface $translator,
    25|         private MembershipBuilder $membershipBuilder,
    26|         private LoggerInterface $logger,
    27|         private FormatterHelper $formatterHelper,
    28|         PathsHelper $pathsHelper,
    29|         CoreParametersHelper $coreParametersHelper,
    30|     ) {
    31|         parent::__construct($pathsHelper, $coreParametersHelper);
    32|     }
    33|     protected function configure()
    34|     {
    35|         $this
    36|             ->setName('mautic:campaigns:rebuild')
    37|             ->setAliases(['mautic:campaigns:update'])
    38|             ->addOption('--batch-limit', '-l', InputOption::VALUE_OPTIONAL, 'Set batch size of contacts to process per round. Defaults to 300.', 300)
    39|             ->addOption(
    40|                 '--max-contacts',
    41|                 '-m',
    42|                 InputOption::VALUE_OPTIONAL,
    43|                 'Set max number of contacts to process per campaign for this script execution. Defaults to all.',
    44|                 0
    45|             )
    46|             ->addOption(
    47|                 '--campaign-id',
    48|                 '-i',
    49|                 InputOption::VALUE_OPTIONAL,
    50|                 'Build membership for a specific campaign.  Otherwise, all campaigns will be rebuilt.',
    51|                 null
    52|             )
    53|             ->addOption(
    54|                 '--contact-id',
    55|                 null,
    56|                 InputOption::VALUE_OPTIONAL,
    57|                 'Build membership for a specific contact.',
    58|                 null
    59|             )
    60|             ->addOption(
    61|                 '--contact-ids',
    62|                 null,
    63|                 InputOption::VALUE_OPTIONAL,
    64|                 'CSV of contact IDs to evaluate.'
    65|             )
    66|             ->addOption(
    67|                 '--min-contact-id',
    68|                 null,
    69|                 InputOption::VALUE_OPTIONAL,
    70|                 'Build membership starting at a specific contact ID.',
    71|                 null
    72|             )
    73|             ->addOption(
    74|                 '--max-contact-id',
    75|                 null,
    76|                 InputOption::VALUE_OPTIONAL,
    77|                 'Build membership up to a specific contact ID.',
    78|                 null
    79|             )
    80|             ->addOption(
    81|                 '--thread-id',
    82|                 null,
    83|                 InputOption::VALUE_OPTIONAL,
    84|                 'The number of this current process if running multiple in parallel.'
    85|             )
    86|             ->addOption(
    87|                 '--max-threads',
    88|                 null,
    89|                 InputOption::VALUE_OPTIONAL,
    90|                 'The maximum number of processes you intend to run in parallel.'
    91|             )
    92|             ->addOption(
    93|                 'exclude',
    94|                 'd',
    95|                 InputOption::VALUE_IS_ARRAY | InputOption::VALUE_OPTIONAL,
    96|                 'Exclude a specific campaign from being rebuilt. Otherwise, all campaigns will be rebuilt.',
    97|                 []
    98|             );
    99|         parent::configure();
   100|     }
   101|     protected function execute(InputInterface $input, OutputInterface $output): int
   102|     {
   103|         $id               = $input->getOption('campaign-id');
   104|         $batchLimit       = $input->getOption('batch-limit');
   105|         $contactMinId     = $input->getOption('min-contact-id');
   106|         $contactMaxId     = $input->getOption('max-contact-id');
   107|         $contactId        = $input->getOption('contact-id');
   108|         $contactIds       = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
   109|         $threadId         = $input->getOption('thread-id');
   110|         $maxThreads       = $input->getOption('max-threads');
   111|         $this->runLimit   = $input->getOption('max-contacts');
   112|         $this->quiet      = (bool) $input->getOption('quiet');
   113|         $this->output     = ($this->quiet) ? new NullOutput() : $output;
   114|         $excludeCampaigns = $input->getOption('exclude');
   115|         if (is_numeric($id)) {
   116|             $id = (int) $id;
   117|         }
   118|         if (is_numeric($maxThreads)) {
   119|             $maxThreads = (int) $maxThreads;
   120|         }
   121|         if (is_numeric($threadId)) {
   122|             $threadId = (int) $threadId;
   123|         }
   124|         if (is_numeric($contactMaxId)) {
   125|             $contactMaxId = (int) $contactMaxId;
   126|         }
   127|         if (is_numeric($contactMinId)) {
   128|             $contactMinId = (int) $contactMinId;
   129|         }
   130|         if (is_numeric($contactId)) {
   131|             $contactId = (int) $contactId;
   132|         }
   133|         if ($threadId && $maxThreads && (int) $threadId > (int) $maxThreads) {
   134|             $this->output->writeln('--thread-id cannot be larger than --max-thread');
   135|             return \Symfony\Component\Console\Command\Command::FAILURE;
   136|         }
   137|         if (!$this->checkRunStatus($input, $output, $id)) {
   138|             return \Symfony\Component\Console\Command\Command::SUCCESS;
   139|         }
   140|         $this->contactLimiter = new ContactLimiter($batchLimit, $contactId, $contactMinId, $contactMaxId, $contactIds, $threadId, $maxThreads);
   141|         if ($id) {
   142|             $campaign = $this->campaignRepository->getEntity($id);
   143|             if (null === $campaign) {
   144|                 $output->writeln('<error>'.$this->translator->trans('mautic.campaign.rebuild.not_found', ['%id%' => $id]).'</error>');
   145|                 return \Symfony\Component\Console\Command\Command::FAILURE;
   146|             }
   147|             $this->updateCampaign($campaign);
   148|         } else {
   149|             $filter = [
   150|                 'iterable_mode' => true,
   151|             ];
   152|             if (is_array($excludeCampaigns) && count($excludeCampaigns) > 0) {
   153|                 $filter['filter'] = [
   154|                     'force' => [
   155|                         [
   156|                             'expr'   => 'notIn',
   157|                             'column' => $this->campaignRepository->getTableAlias().'.id',
   158|                             'value'  => $excludeCampaigns,
   159|                         ],
   160|                     ],
   161|                 ];
   162|             }
   163|             $campaigns = $this->campaignRepository->getEntities($filter);
   164|             foreach ($campaigns as $campaign) {
   165|                 $this->updateCampaign($campaign);
   166|                 unset($campaign);
   167|             }
   168|         }
   169|         $this->completeRun();
   170|         return \Symfony\Component\Console\Command\Command::SUCCESS;
   171|     }
   172|     /**
   173|      * @throws \Exception
   174|      */
   175|     private function updateCampaign(Campaign $campaign): void
   176|     {
   177|         if (!$campaign->isPublished()) {
   178|             return;
   179|         }
   180|         try {
   181|             $this->output->writeln(
   182|                 '<info>'.$this->translator->trans('mautic.campaign.rebuild.rebuilding', ['%id%' => $campaign->getId()]).'</info>'
   183|             );
   184|             $this->contactLimiter->resetBatchMinContactId();
   185|             $this->membershipBuilder->build($campaign, $this->contactLimiter, $this->runLimit, ($this->quiet) ? null : $this->output);
   186|         } catch (\Exception $exception) {
   187|             if ('prod' !== MAUTIC_ENV) {
   188|                 throw $exception;
   189|             }
   190|             $this->logger->error('CAMPAIGN: '.$exception->getMessage());
   191|         }
   192|         if ('test' !== MAUTIC_ENV) {
   193|             $this->campaignRepository->detachEntity($campaign);
   194|         }
   195|         $this->output->writeln('');
   196|     }
   197|     protected static $defaultDescription = 'Rebuild campaigns based on contact segments.';
   198| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Command/ValidateEventCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Command;
     3| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     4| use Mautic\CampaignBundle\Executioner\InactiveExecutioner;
     5| use Mautic\CoreBundle\Twig\Helper\FormatterHelper;
     6| use Symfony\Component\Console\Command\Command;
     7| use Symfony\Component\Console\Input\InputInterface;
     8| use Symfony\Component\Console\Input\InputOption;
     9| use Symfony\Component\Console\Output\OutputInterface;
    10| use Symfony\Contracts\Translation\TranslatorInterface;
    11| class ValidateEventCommand extends Command
    12| {
    13|     use WriteCountTrait;
    14|     public function __construct(
    15|         private InactiveExecutioner $inactiveExecution,
    16|         private TranslatorInterface $translator,
    17|         private FormatterHelper $formatterHelper,
    18|     ) {
    19|         parent::__construct();
    20|     }
    21|     protected function configure()
    22|     {
    23|         $this
    24|             ->setName('mautic:campaigns:validate')
    25|             ->addOption(
    26|                 '--decision-id',
    27|                 null,
    28|                 InputOption::VALUE_REQUIRED,
    29|                 'ID of the decision to evaluate.'
    30|             )
    31|             ->addOption(
    32|                 '--contact-id',
    33|                 null,
    34|                 InputOption::VALUE_OPTIONAL,
    35|                 'Evaluate for specific contact'
    36|             )
    37|             ->addOption(
    38|                 '--contact-ids',
    39|                 null,
    40|                 InputOption::VALUE_OPTIONAL,
    41|                 'CSV of contact IDs to evaluate.'
    42|             );
    43|         parent::configure();
    44|     }
    45|     /**
    46|      * @throws \Exception
    47|      */
    48|     protected function execute(InputInterface $input, OutputInterface $output): int
    49|     {
    50|         defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED', 1);
    51|         $decisionId = $input->getOption('decision-id');
    52|         $contactId  = $input->getOption('contact-id');
    53|         if (is_numeric($decisionId)) {
    54|             $decisionId = (int) $decisionId;
    55|         }
    56|         if (is_numeric($contactId)) {
    57|             $contactId = (int) $contactId;
    58|         }
    59|         $contactIds = $this->formatterHelper->simpleCsvToArray($input->getOption('contact-ids'), 'int');
    60|         if (!$contactIds && !$contactId) {
    61|             $output->writeln(
    62|                 "\n".
    63|                 '<comment>'.$this->translator->trans('mautic.campaign.trigger.events_executed', ['%count%' => 0])
    64|                 .'</comment>'
    65|             );
    66|             return Command::SUCCESS;
    67|         }
    68|         $limiter = new ContactLimiter(null, $contactId, null, null, $contactIds);
    69|         $counter = $this->inactiveExecution->validate($decisionId, $limiter, $output);
    70|         $this->writeCounts($output, $this->translator, $counter);
    71|         return Command::SUCCESS;
    72|     }
    73|     protected static $defaultDescription = 'Validate if a contact has been inactive for a decision and execute events if so.';
    74| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Config/config.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-377 ---
     1| <?php
     2| return [
     3|     'routes' => [
     4|         'main' => [
     5|             'mautic_campaignevent_action'  => [
     6|                 'path'       => '/campaigns/events/{objectAction}/{objectId}',
     7|                 'controller' => 'Mautic\CampaignBundle\Controller\EventController::executeAction',
     8|             ],
     9|             'mautic_campaignsource_action' => [
    10|                 'path'       => '/campaigns/sources/{objectAction}/{objectId}',
    11|                 'controller' => 'Mautic\CampaignBundle\Controller\SourceController::executeAction',
    12|             ],
    13|             'mautic_campaign_index'        => [
    14|                 'path'       => '/campaigns/{page}',
    15|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::indexAction',
    16|             ],
    17|             'mautic_campaign_action'       => [
    18|                 'path'       => '/campaigns/{objectAction}/{objectId}',
    19|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::executeAction',
    20|             ],
    21|             'mautic_campaign_contacts'     => [
    22|                 'path'       => '/campaigns/view/{objectId}/contact/{page}',
    23|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignController::contactsAction',
    24|             ],
    25|             'mautic_campaign_preview'      => [
    26|                 'path'       => '/campaign/preview/{objectId}',
    27|                 'controller' => 'Mautic\EmailBundle\Controller\PublicController::previewAction',
    28|             ],
    29|             'mautic_campaign_map_stats' => [
    30|                 'path'       => '/campaign-map-stats/{objectId}/{dateFrom}/{dateTo}',
    31|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignMapStatsController::viewAction',
    32|             ],
    33|             'mautic_campaign_metrics_email_weekdays' => [
    34|                 'path'       => '/campaign/metrics/email-weekdays/{objectId}/{dateFrom}/{dateTo}',
    35|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignMetricsController::emailWeekdaysAction',
    36|             ],
    37|             'mautic_campaign_metrics_email_hours' => [
    38|                 'path'       => '/campaign/metrics/email-hours/{objectId}/{dateFrom}/{dateTo}',
    39|                 'controller' => 'Mautic\CampaignBundle\Controller\CampaignMetricsController::emailHoursAction',
    40|             ],
    41|         ],
    42|         'api'  => [
    43|             'mautic_api_campaignsstandard'            => [
    44|                 'standard_entity' => true,
    45|                 'name'            => 'campaigns',
    46|                 'path'            => '/campaigns',
    47|                 'controller'      => Mautic\CampaignBundle\Controller\Api\CampaignApiController::class,
    48|             ],
    49|             'mautic_api_campaigneventsstandard'       => [
    50|                 'standard_entity'     => true,
    51|                 'supported_endpoints' => [
    52|                     'getone',
    53|                     'getall',
    54|                 ],
    55|                 'name'                => 'events',
    56|                 'path'                => '/campaigns/events',
    57|                 'controller'          => Mautic\CampaignBundle\Controller\Api\EventApiController::class,
    58|             ],
    59|             'mautic_api_campaigns_events_contact'     => [
    60|                 'path'       => '/campaigns/events/contact/{contactId}',
    61|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::getContactEventsAction',
    62|                 'method'     => 'GET',
    63|             ],
    64|             'mautic_api_campaigns_edit_contact_event' => [
    65|                 'path'       => '/campaigns/events/{eventId}/contact/{contactId}/edit',
    66|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::editContactEventAction',
    67|                 'method'     => 'PUT',
    68|             ],
    69|             'mautic_api_campaigns_batchedit_events'   => [
    70|                 'path'       => '/campaigns/events/batch/edit',
    71|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::editEventsAction',
    72|                 'method'     => 'PUT',
    73|             ],
    74|             'mautic_api_campaign_contact_events'      => [
    75|                 'path'       => '/campaigns/{campaignId}/events/contact/{contactId}',
    76|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\EventLogApiController::getContactEventsAction',
    77|                 'method'     => 'GET',
    78|             ],
    79|             'mautic_api_campaigngetcontacts'          => [
    80|                 'path'       => '/campaigns/{id}/contacts',
    81|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::getContactsAction',
    82|             ],
    83|             'mautic_api_campaignaddcontact'           => [
    84|                 'path'       => '/campaigns/{id}/contact/{leadId}/add',
    85|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::addLeadAction',
    86|                 'method'     => 'POST',
    87|             ],
    88|             'mautic_api_campaignremovecontact'        => [
    89|                 'path'       => '/campaigns/{id}/contact/{leadId}/remove',
    90|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::removeLeadAction',
    91|                 'method'     => 'POST',
    92|             ],
    93|             'mautic_api_contact_clone_campaign' => [
    94|                 'path'       => '/campaigns/clone/{campaignId}',
    95|                 'controller' => 'Mautic\CampaignBundle\Controller\Api\CampaignApiController::cloneCampaignAction',
    96|                 'method'     => 'POST',
    97|             ],
    98|         ],
    99|     ],
   100|     'menu' => [
   101|         'main' => [
   102|             'mautic.campaign.menu.index' => [
   103|                 'iconClass' => 'ri-megaphone-fill',
   104|                 'route'     => 'mautic_campaign_index',
   105|                 'access'    => 'campaign:campaigns:view',
   106|                 'priority'  => 50,
   107|             ],
   108|         ],
   109|     ],
   110|     'categories' => [
   111|         'campaign' => [
   112|             'class' => Mautic\CampaignBundle\Entity\Campaign::class,
   113|         ],
   114|     ],
   115|     'services' => [
   116|         'execution'    => [
   117|             'mautic.campaign.contact_finder.kickoff'  => [
   118|                 'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\KickoffContactFinder::class,
   119|                 'arguments' => [
   120|                     'mautic.lead.repository.lead',
   121|                     'mautic.campaign.repository.campaign',
   122|                     'monolog.logger.mautic',
   123|                 ],
   124|             ],
   125|             'mautic.campaign.contact_finder.scheduled'  => [
   126|                 'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\ScheduledContactFinder::class,
   127|                 'arguments' => [
   128|                     'mautic.lead.repository.lead',
   129|                     'monolog.logger.mautic',
   130|                 ],
   131|             ],
   132|             'mautic.campaign.contact_finder.inactive'     => [
   133|                 'class'     => Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder::class,
   134|                 'arguments' => [
   135|                     'mautic.lead.repository.lead',
   136|                     'mautic.campaign.repository.lead',
   137|                     'monolog.logger.mautic',
   138|                 ],
   139|             ],
   140|             'mautic.campaign.dispatcher.action'        => [
   141|                 'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher::class,
   142|                 'arguments' => [
   143|                     'event_dispatcher',
   144|                     'monolog.logger.mautic',
   145|                     'mautic.campaign.scheduler',
   146|                     'mautic.campaign.legacy_event_dispatcher',
   147|                 ],
   148|             ],
   149|             'mautic.campaign.dispatcher.condition'        => [
   150|                 'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\ConditionDispatcher::class,
   151|                 'arguments' => [
   152|                     'event_dispatcher',
   153|                 ],
   154|             ],
   155|             'mautic.campaign.dispatcher.decision'        => [
   156|                 'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\DecisionDispatcher::class,
   157|                 'arguments' => [
   158|                     'event_dispatcher',
   159|                     'mautic.campaign.legacy_event_dispatcher',
   160|                 ],
   161|             ],
   162|             'mautic.campaign.event_logger' => [
   163|                 'class'     => Mautic\CampaignBundle\Executioner\Logger\EventLogger::class,
   164|                 'arguments' => [
   165|                     'mautic.helper.ip_lookup',
   166|                     'mautic.tracker.contact',
   167|                     'mautic.campaign.repository.lead_event_log',
   168|                     'mautic.campaign.repository.lead',
   169|                     'mautic.campaign.model.summary',
   170|                 ],
   171|             ],
   172|             'mautic.campaign.event_collector' => [
   173|                 'class'     => Mautic\CampaignBundle\EventCollector\EventCollector::class,
   174|                 'arguments' => [
   175|                     'translator',
   176|                     'event_dispatcher',
   177|                 ],
   178|             ],
   179|             'mautic.campaign.scheduler.datetime'      => [
   180|                 'class'     => Mautic\CampaignBundle\Executioner\Scheduler\Mode\DateTime::class,
   181|                 'arguments' => [
   182|                     'monolog.logger.mautic',
   183|                 ],
   184|             ],
   185|             'mautic.campaign.scheduler.interval'      => [
   186|                 'class'     => Mautic\CampaignBundle\Executioner\Scheduler\Mode\Interval::class,
   187|                 'arguments' => [
   188|                     'monolog.logger.mautic',
   189|                     'mautic.helper.core_parameters',
   190|                 ],
   191|             ],
   192|             'mautic.campaign.scheduler'               => [
   193|                 'class'     => Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler::class,
   194|                 'arguments' => [
   195|                     'monolog.logger.mautic',
   196|                     'mautic.campaign.event_logger',
   197|                     'mautic.campaign.scheduler.interval',
   198|                     'mautic.campaign.scheduler.datetime',
   199|                     'mautic.campaign.scheduler.optimized',
   200|                     'mautic.campaign.event_collector',
   201|                     'event_dispatcher',
   202|                     'mautic.helper.core_parameters',
   203|                 ],
   204|             ],
   205|             'mautic.campaign.executioner.action' => [
   206|                 'class'     => Mautic\CampaignBundle\Executioner\Event\ActionExecutioner::class,
   207|                 'arguments' => [
   208|                     'mautic.campaign.dispatcher.action',
   209|                     'mautic.campaign.event_logger',
   210|                 ],
   211|             ],
   212|             'mautic.campaign.executioner.condition' => [
   213|                 'class'     => Mautic\CampaignBundle\Executioner\Event\ConditionExecutioner::class,
   214|                 'arguments' => [
   215|                     'mautic.campaign.dispatcher.condition',
   216|                 ],
   217|             ],
   218|             'mautic.campaign.executioner.decision' => [
   219|                 'class'     => Mautic\CampaignBundle\Executioner\Event\DecisionExecutioner::class,
   220|                 'arguments' => [
   221|                     'mautic.campaign.event_logger',
   222|                     'mautic.campaign.dispatcher.decision',
   223|                 ],
   224|             ],
   225|             'mautic.campaign.event_executioner' => [
   226|                 'class'     => Mautic\CampaignBundle\Executioner\EventExecutioner::class,
   227|                 'arguments' => [
   228|                     'mautic.campaign.event_collector',
   229|                     'mautic.campaign.event_logger',
   230|                     'mautic.campaign.executioner.action',
   231|                     'mautic.campaign.executioner.condition',
   232|                     'mautic.campaign.executioner.decision',
   233|                     'monolog.logger.mautic',
   234|                     'mautic.campaign.scheduler',
   235|                     'mautic.campaign.helper.removed_contact_tracker',
   236|                 ],
   237|             ],
   238|             'mautic.campaign.executioner.kickoff'     => [
   239|                 'class'     => Mautic\CampaignBundle\Executioner\KickoffExecutioner::class,
   240|                 'arguments' => [
   241|                     'monolog.logger.mautic',
   242|                     'mautic.campaign.contact_finder.kickoff',
   243|                     'translator',
   244|                     'mautic.campaign.event_executioner',
   245|                     'mautic.campaign.scheduler',
   246|                 ],
   247|             ],
   248|             'mautic.campaign.executioner.realtime'     => [
   249|                 'class'     => Mautic\CampaignBundle\Executioner\RealTimeExecutioner::class,
   250|                 'arguments' => [
   251|                     'monolog.logger.mautic',
   252|                     'mautic.lead.model.lead',
   253|                     'mautic.campaign.repository.event',
   254|                     'mautic.campaign.event_executioner',
   255|                     'mautic.campaign.executioner.decision',
   256|                     'mautic.campaign.event_collector',
   257|                     'mautic.campaign.scheduler',
   258|                     'mautic.tracker.contact',
   259|                     'mautic.campaign.helper.decision',
   260|                 ],
   261|             ],
   262|             'mautic.campaign.helper.decision' => [
   263|                 'class'     => Mautic\CampaignBundle\Executioner\Helper\DecisionHelper::class,
   264|                 'arguments' => [
   265|                     'mautic.campaign.repository.lead',
   266|                 ],
   267|             ],
   268|             'mautic.campaign.helper.inactivity' => [
   269|                 'class'     => Mautic\CampaignBundle\Executioner\Helper\InactiveHelper::class,
   270|                 'arguments' => [
   271|                     'mautic.campaign.scheduler',
   272|                     'mautic.campaign.contact_finder.inactive',
   273|                     'mautic.campaign.repository.lead_event_log',
   274|                     'mautic.campaign.repository.event',
   275|                     'monolog.logger.mautic',
   276|                     'mautic.campaign.helper.decision',
   277|                 ],
   278|             ],
   279|             'mautic.campaign.helper.removed_contact_tracker' => [
   280|                 'class' => Mautic\CampaignBundle\Helper\RemovedContactTracker::class,
   281|             ],
   282|             'mautic.campaign.helper.notification' => [
   283|                 'class'     => Mautic\CampaignBundle\Executioner\Helper\NotificationHelper::class,
   284|                 'arguments' => [
   285|                     'mautic.user.model.user',
   286|                     'mautic.core.model.notification',
   287|                     'translator',
   288|                     'router',
   289|                     'mautic.helper.core_parameters',
   290|                 ],
   291|             ],
   292|             'mautic.campaign.legacy_event_dispatcher' => [
   293|                 'class'     => Mautic\CampaignBundle\Executioner\Dispatcher\LegacyEventDispatcher::class,
   294|                 'arguments' => [
   295|                     'event_dispatcher',
   296|                     'mautic.campaign.scheduler',
   297|                     'monolog.logger.mautic',
   298|                     'mautic.tracker.contact',
   299|                 ],
   300|             ],
   301|         ],
   302|         'membership' => [
   303|             'mautic.campaign.membership.adder' => [
   304|                 'class'     => Mautic\CampaignBundle\Membership\Action\Adder::class,
   305|                 'arguments' => [
   306|                     'mautic.campaign.repository.lead',
   307|                     'mautic.campaign.repository.lead_event_log',
   308|                 ],
   309|             ],
   310|             'mautic.campaign.membership.remover' => [
   311|                 'class'     => Mautic\CampaignBundle\Membership\Action\Remover::class,
   312|                 'arguments' => [
   313|                     'mautic.campaign.repository.lead',
   314|                     'mautic.campaign.repository.lead_event_log',
   315|                     'translator',
   316|                     'mautic.helper.twig.date',
   317|                 ],
   318|             ],
   319|             'mautic.campaign.membership.event_dispatcher' => [
   320|                 'class'     => Mautic\CampaignBundle\Membership\EventDispatcher::class,
   321|                 'arguments' => [
   322|                     'event_dispatcher',
   323|                 ],
   324|             ],
   325|             'mautic.campaign.membership.manager' => [
   326|                 'class'     => Mautic\CampaignBundle\Membership\MembershipManager::class,
   327|                 'arguments' => [
   328|                     'mautic.campaign.membership.adder',
   329|                     'mautic.campaign.membership.remover',
   330|                     'mautic.campaign.membership.event_dispatcher',
   331|                     'mautic.campaign.repository.lead',
   332|                     'monolog.logger.mautic',
   333|                 ],
   334|             ],
   335|             'mautic.campaign.membership.builder' => [
   336|                 'class'     => Mautic\CampaignBundle\Membership\MembershipBuilder::class,
   337|                 'arguments' => [
   338|                     'mautic.campaign.membership.manager',
   339|                     'mautic.campaign.repository.lead',
   340|                     'mautic.lead.repository.lead',
   341|                     'translator',
   342|                 ],
   343|             ],
   344|         ],
   345|         'services' => [
   346|             'mautic.campaign.service.campaign'=> [
   347|                 /** @phpstan-ignore-next-line */
   348|                 'class'     => Mautic\CampaignBundle\Service\Campaign::class,
   349|                 'arguments' => [
   350|                     'mautic.campaign.repository.campaign',
   351|                     'mautic.email.repository.email',
   352|                 ],
   353|             ],
   354|         ],
   355|         'fixtures' => [
   356|             'mautic.campaign.fixture.campaign' => [
   357|                 'class'    => Mautic\CampaignBundle\DataFixtures\ORM\CampaignData::class,
   358|                 'tag'      => Doctrine\Bundle\FixturesBundle\DependencyInjection\CompilerPass\FixturesCompilerPass::FIXTURE_TAG,
   359|                 'optional' => true,
   360|             ],
   361|         ],
   362|     ],
   363|     'parameters' => [
   364|         'campaign_time_wait_on_event_false'                                                     => 'PT1H',
   365|         'campaign_use_summary'                                                                  => 0,
   366|         'campaign_by_range'                                                                     => 0,
   367|         'delete_campaign_event_log_in_background'                                               => false,
   368|         'campaign_email_stats_enabled'                                                          => true,
   369|         'peak_interaction_timer_cache_timeout'                                                  => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_CACHE_TIMEOUT,
   370|         'peak_interaction_timer_best_default_hour_start'                                        => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_HOUR_START,
   371|         'peak_interaction_timer_best_default_hour_end'                                          => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_HOUR_END,
   372|         'peak_interaction_timer_best_default_days'                                              => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_BEST_DAYS,
   373|         'peak_interaction_timer_fetch_interactions_from'                                        => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_FETCH_INTERACTIONS_FROM,
   374|         'peak_interaction_timer_fetch_limit'                                                    => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_FETCH_LIMIT,
   375|         'peak_interaction_timer_max_optimal_days'                                               => Mautic\LeadBundle\Services\PeakInteractionTimer::DEFAULT_MAX_OPTIMAL_DAYS,
   376|     ],
   377| ];


# ====================================================================
# FILE: app/bundles/CampaignBundle/Config/services.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| <?php
     2| declare(strict_types=1);
     3| use Mautic\CoreBundle\DependencyInjection\MauticCoreExtension;
     4| use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
     5| return function (ContainerConfigurator $configurator): void {
     6|     $services = $configurator->services()
     7|         ->defaults()
     8|         ->autowire()
     9|         ->autoconfigure()
    10|         ->public();
    11|     $excludes = [
    12|         'EventCollector',
    13|         'Executioner/ContactFinder/Limiter/ContactLimiter.php',
    14|         'Executioner/Dispatcher/Exception',
    15|         'Executioner/Scheduler/Mode/DAO',
    16|         'Membership/Exception',
    17|     ];
    18|     $services->load('Mautic\\CampaignBundle\\', '../')
    19|         ->exclude('../{'.implode(',', array_merge(MauticCoreExtension::DEFAULT_EXCLUDES, $excludes)).'}');
    20|     $services->load('Mautic\\CampaignBundle\\Entity\\', '../Entity/*Repository.php')
    21|         ->tag(Doctrine\Bundle\DoctrineBundle\DependencyInjection\Compiler\ServiceRepositoryCompilerPass::REPOSITORY_SERVICE_TAG);
    22|     $services->alias('mautic.campaign.model.campaign', Mautic\CampaignBundle\Model\CampaignModel::class);
    23|     $services->alias('mautic.campaign.model.event', Mautic\CampaignBundle\Model\EventModel::class);
    24|     $services->alias('mautic.campaign.model.event_log', Mautic\CampaignBundle\Model\EventLogModel::class);
    25|     $services->alias('mautic.campaign.model.summary', Mautic\CampaignBundle\Model\SummaryModel::class);
    26|     $services->alias('mautic.campaign.repository.campaign', Mautic\CampaignBundle\Entity\CampaignRepository::class);
    27|     $services->alias('mautic.campaign.repository.lead', Mautic\CampaignBundle\Entity\LeadRepository::class);
    28|     $services->alias('mautic.campaign.repository.event', Mautic\CampaignBundle\Entity\EventRepository::class);
    29|     $services->alias('mautic.campaign.repository.lead_event_log', Mautic\CampaignBundle\Entity\LeadEventLogRepository::class);
    30|     $services->alias('mautic.campaign.repository.summary', Mautic\CampaignBundle\Entity\SummaryRepository::class);
    31|     $services->alias('mautic.campaign.executioner.inactive', Mautic\CampaignBundle\Executioner\InactiveExecutioner::class);
    32|     $services->alias('mautic.campaign.executioner.scheduled', Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class);
    33|     $services->alias('mautic.campaign.scheduler.optimized', Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized::class);
    34|     $services->set(Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class)->tag('kernel.reset', ['method' => 'reset']);
    35|     if ('test' === ($_ENV['APP_ENV'] ?? $_SERVER['APP_ENV'] ?? 'prod')) {
    36|         $services->set(Mautic\CampaignBundle\Executioner\TestInactiveExecutioner::class)
    37|             ->decorate(Mautic\CampaignBundle\Executioner\InactiveExecutioner::class)
    38|             ->tag('kernel.reset', ['method' => 'reset']);
    39|         $services->set(Mautic\CampaignBundle\Executioner\TestScheduledExecutioner::class)
    40|             ->decorate(Mautic\CampaignBundle\Executioner\ScheduledExecutioner::class)
    41|             ->tag('kernel.reset', ['method' => 'reset']);
    42|     }
    43| };


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/AjaxController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-120 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\CampaignBundle\Entity\LeadEventLog;
     5| use Mautic\CampaignBundle\Model\EventLogModel;
     6| use Mautic\CoreBundle\Controller\AjaxController as CommonAjaxController;
     7| use Mautic\CoreBundle\Factory\ModelFactory;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\InputHelper;
    10| use Mautic\CoreBundle\Helper\UserHelper;
    11| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    12| use Mautic\CoreBundle\Service\FlashBag;
    13| use Mautic\CoreBundle\Translation\Translator;
    14| use Mautic\CoreBundle\Twig\Helper\DateHelper;
    15| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    16| use Symfony\Component\HttpFoundation\Request;
    17| use Symfony\Component\HttpFoundation\RequestStack;
    18| class AjaxController extends CommonAjaxController
    19| {
    20|     public function __construct(
    21|         private DateHelper $dateHelper,
    22|         ManagerRegistry $doctrine,
    23|         ModelFactory $modelFactory,
    24|         UserHelper $userHelper,
    25|         CoreParametersHelper $coreParametersHelper,
    26|         EventDispatcherInterface $dispatcher,
    27|         Translator $translator,
    28|         FlashBag $flashBag,
    29|         RequestStack $requestStack,
    30|         CorePermissions $security,
    31|     ) {
    32|         parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    33|     }
    34|     public function updateConnectionsAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
    35|     {
    36|         $session        = $request->getSession();
    37|         $campaignId     = InputHelper::clean($request->query->get('campaignId'));
    38|         $canvasSettings = $request->request->all()['canvasSettings'] ?? [];
    39|         if (empty($campaignId)) {
    40|             $dataArray = ['success' => 0];
    41|         } else {
    42|             $session->set('mautic.campaign.'.$campaignId.'.events.canvassettings', $canvasSettings);
    43|             $dataArray = ['success' => 1];
    44|         }
    45|         return $this->sendJsonResponse($dataArray);
    46|     }
    47|     public function updateScheduledCampaignEventAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
    48|     {
    49|         $eventId      = (int) $request->request->get('eventId');
    50|         $contactId    = (int) $request->request->get('contactId');
    51|         $newDate      = InputHelper::clean($request->request->get('date'));
    52|         $originalDate = InputHelper::clean($request->request->get('originalDate'));
    53|         $dataArray = ['success' => 0, 'date' => $originalDate];
    54|         if (!empty($eventId) && !empty($contactId) && !empty($newDate)) {
    55|             if ($log = $this->getContactEventLog($eventId, $contactId)) {
    56|                 $newDate = new \DateTime($newDate);
    57|                 if ($newDate >= new \DateTime()) {
    58|                     $log->setTriggerDate($newDate);
    59|                     /** @var EventLogModel $logModel */
    60|                     $logModel = $this->getModel('campaign.event_log');
    61|                     $logModel->saveEntity($log);
    62|                     $dataArray = [
    63|                         'success' => 1,
    64|                         'date'    => $newDate->format('Y-m-d H:i:s'),
    65|                     ];
    66|                 }
    67|             }
    68|         }
    69|         $dataArray['formattedDate'] = $this->dateHelper->toFull($dataArray['date']);
    70|         return $this->sendJsonResponse($dataArray);
    71|     }
    72|     public function cancelScheduledCampaignEventAction(Request $request): \Symfony\Component\HttpFoundation\JsonResponse
    73|     {
    74|         $dataArray = ['success' => 0];
    75|         $eventId   = (int) $request->request->get('eventId');
    76|         $contactId = (int) $request->request->get('contactId');
    77|         if (!empty($eventId) && !empty($contactId)) {
    78|             if ($log = $this->getContactEventLog($eventId, $contactId)) {
    79|                 $log->setIsScheduled(false);
    80|                 /** @var EventLogModel $logModel */
    81|                 $logModel           = $this->getModel('campaign.event_log');
    82|                 $metadata           = $log->getMetadata();
    83|                 $metadata['errors'] = $this->translator->trans(
    84|                     'mautic.campaign.event.cancelled.time',
    85|                     ['%date%' => $log->getTriggerDate()->format('Y-m-d H:i:s')]
    86|                 );
    87|                 $log->setMetadata($metadata);
    88|                 $logModel->getRepository()->saveEntity($log);
    89|                 $dataArray = ['success' => 1];
    90|             }
    91|         }
    92|         return $this->sendJsonResponse($dataArray);
    93|     }
    94|     /**
    95|      * @return LeadEventLog|null
    96|      */
    97|     protected function getContactEventLog($eventId, $contactId)
    98|     {
    99|         $contact = $this->getModel('lead')->getEntity($contactId);
   100|         if ($contact) {
   101|             if ($this->security->hasEntityAccess('lead:leads:editown', 'lead:leads:editother', $contact->getPermissionUser())) {
   102|                 /** @var EventLogModel $logModel */
   103|                 $logModel = $this->getModel('campaign.event_log');
   104|                 /** @var LeadEventLog $log */
   105|                 $log = $logModel->getRepository()
   106|                                 ->findOneBy(
   107|                                     [
   108|                                         'lead'  => $contactId,
   109|                                         'event' => $eventId,
   110|                                     ],
   111|                                     ['dateTriggered' => 'desc']
   112|                                 );
   113|                 if ($log && ($log->getTriggerDate() > new \DateTime())) {
   114|                     return $log;
   115|                 }
   116|             }
   117|         }
   118|         return null;
   119|     }
   120| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/Api/CampaignApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-296 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Controller\CommonApiController;
     5| use Mautic\ApiBundle\Helper\EntityResultHelper;
     6| use Mautic\CampaignBundle\Entity\Campaign;
     7| use Mautic\CampaignBundle\Entity\Event;
     8| use Mautic\CampaignBundle\Membership\MembershipManager;
     9| use Mautic\CampaignBundle\Model\CampaignModel;
    10| use Mautic\CampaignBundle\Model\EventModel;
    11| use Mautic\CoreBundle\Factory\ModelFactory;
    12| use Mautic\CoreBundle\Helper\AppVersion;
    13| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    14| use Mautic\CoreBundle\Helper\InputHelper;
    15| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    16| use Mautic\CoreBundle\Translation\Translator;
    17| use Mautic\LeadBundle\Controller\LeadAccessTrait;
    18| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    19| use Symfony\Component\Form\FormFactoryInterface;
    20| use Symfony\Component\HttpFoundation\Request;
    21| use Symfony\Component\HttpFoundation\RequestStack;
    22| use Symfony\Component\HttpFoundation\Response;
    23| use Symfony\Component\Routing\RouterInterface;
    24| use Symfony\Component\Validator\ConstraintViolationInterface;
    25| use Symfony\Component\Validator\ConstraintViolationListInterface;
    26| use Symfony\Component\Validator\Validator\ValidatorInterface;
    27| /**
    28|  * @extends CommonApiController<Campaign>
    29|  */
    30| class CampaignApiController extends CommonApiController
    31| {
    32|     use LeadAccessTrait;
    33|     /**
    34|      * @var CampaignModel|null
    35|      */
    36|     protected $model;
    37|     public function __construct(
    38|         CorePermissions $security,
    39|         Translator $translator,
    40|         EntityResultHelper $entityResultHelper,
    41|         RouterInterface $router,
    42|         FormFactoryInterface $formFactory,
    43|         AppVersion $appVersion,
    44|         private RequestStack $requestStack,
    45|         private MembershipManager $membershipManager,
    46|         ManagerRegistry $doctrine,
    47|         ModelFactory $modelFactory,
    48|         EventDispatcherInterface $dispatcher,
    49|         CoreParametersHelper $coreParametersHelper,
    50|         private ValidatorInterface $validator,
    51|         private EventModel $eventModel,
    52|     ) {
    53|         $campaignModel = $modelFactory->getModel('campaign');
    54|         \assert($campaignModel instanceof CampaignModel);
    55|         $this->model             = $campaignModel;
    56|         $this->entityClass       = Campaign::class;
    57|         $this->entityNameOne     = 'campaign';
    58|         $this->entityNameMulti   = 'campaigns';
    59|         $this->permissionBase    = 'campaign:campaigns';
    60|         $this->serializerGroups  = ['campaignDetails', 'campaignEventDetails', 'categoryList', 'publishDetails', 'leadListList', 'formList'];
    61|         parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    62|     }
    63|     /**
    64|      * Adds a lead to a campaign.
    65|      *
    66|      * @param int $id     Campaign ID
    67|      * @param int $leadId Lead ID
    68|      *
    69|      * @return Response
    70|      *
    71|      * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
    72|      */
    73|     public function addLeadAction($id, $leadId)
    74|     {
    75|         $entity = $this->model->getEntity($id);
    76|         if (null !== $entity) {
    77|             $leadModel = $this->getModel('lead');
    78|             $lead      = $leadModel->getEntity($leadId);
    79|             if (null == $lead) {
    80|                 return $this->notFound();
    81|             } elseif (!$this->security->hasEntityAccess('lead:leads:editown', 'lead:leads:editother', $lead->getOwner())) {
    82|                 return $this->accessDenied();
    83|             }
    84|             $this->membershipManager->addContact($lead, $entity);
    85|             $view = $this->view(['success' => 1], Response::HTTP_OK);
    86|             return $this->handleView($view);
    87|         }
    88|         return $this->notFound();
    89|     }
    90|     /**
    91|      * Removes given lead from a campaign.
    92|      *
    93|      * @param int $id     Campaign ID
    94|      * @param int $leadId Lead ID
    95|      *
    96|      * @return Response
    97|      *
    98|      * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
    99|      */
   100|     public function removeLeadAction($id, $leadId)
   101|     {
   102|         $entity = $this->model->getEntity($id);
   103|         if (null !== $entity) {
   104|             $lead = $this->checkLeadAccess($leadId, 'edit');
   105|             if ($lead instanceof Response) {
   106|                 return $lead;
   107|             }
   108|             $this->membershipManager->removeContact($lead, $entity);
   109|             $view = $this->view(['success' => 1], Response::HTTP_OK);
   110|             return $this->handleView($view);
   111|         }
   112|         return $this->notFound();
   113|     }
   114|     /**
   115|      * @param Campaign &$entity
   116|      * @param string   $action
   117|      */
   118|     protected function preSaveEntity(&$entity, $form, $parameters, $action = 'edit')
   119|     {
   120|         $method = $this->requestStack->getCurrentRequest()->getMethod();
   121|         if ('POST' === $method || 'PUT' === $method) {
   122|             if (empty($parameters['events'])) {
   123|                 $msg = $this->translator->trans('mautic.campaign.form.events.notempty', [], 'validators');
   124|                 return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
   125|             } elseif (empty($parameters['lists']) && empty($parameters['forms'])) {
   126|                 $msg = $this->translator->trans('mautic.campaign.form.sources.notempty', [], 'validators');
   127|                 return $this->returnError($msg, Response::HTTP_BAD_REQUEST);
   128|             }
   129|         }
   130|         $deletedSources = ['lists' => [], 'forms' => []];
   131|         $deletedEvents  = [];
   132|         $currentSources = [
   133|             'lists' => isset($parameters['lists']) ? $this->modifyCampaignEventArray($parameters['lists']) : [],
   134|             'forms' => isset($parameters['forms']) ? $this->modifyCampaignEventArray($parameters['forms']) : [],
   135|         ];
   136|         if ('PUT' === $method) {
   137|             $requestEventIds   = [];
   138|             $requestSegmentIds = [];
   139|             $requestFormIds    = [];
   140|             foreach ($parameters['events'] as $key => $requestEvent) {
   141|                 if (!isset($requestEvent['id'])) {
   142|                     return $this->returnError('$campaign[events]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
   143|                 }
   144|                 $requestEventIds[] = $requestEvent['id'];
   145|             }
   146|             foreach ($entity->getEvents() as $currentEvent) {
   147|                 if (!in_array($currentEvent->getId(), $requestEventIds)) {
   148|                     $deletedEvents[] = $currentEvent->getId();
   149|                 }
   150|             }
   151|             if (isset($parameters['lists'])) {
   152|                 foreach ($parameters['lists'] as $requestSegment) {
   153|                     if (!isset($requestSegment['id'])) {
   154|                         return $this->returnError('$campaign[lists]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
   155|                     }
   156|                     $requestSegmentIds[] = $requestSegment['id'];
   157|                 }
   158|             }
   159|             foreach ($entity->getLists() as $currentSegment) {
   160|                 if (!in_array($currentSegment->getId(), $requestSegmentIds)) {
   161|                     $deletedSources['lists'][$currentSegment->getId()] = 'ignore';
   162|                 }
   163|             }
   164|             if (isset($parameters['forms'])) {
   165|                 foreach ($parameters['forms'] as $requestForm) {
   166|                     if (!isset($requestForm['id'])) {
   167|                         return $this->returnError('$campaign[forms]['.$key.']["id"] is missing', Response::HTTP_BAD_REQUEST);
   168|                     }
   169|                     $requestFormIds[] = $requestForm['id'];
   170|                 }
   171|             }
   172|             foreach ($entity->getForms() as $currentForm) {
   173|                 if (!in_array($currentForm->getId(), $requestFormIds)) {
   174|                     $deletedSources['forms'][$currentForm->getId()] = 'ignore';
   175|                 }
   176|             }
   177|         }
   178|         $this->model->setLeadSources($entity, $currentSources, $deletedSources);
   179|         if (isset($parameters['events']) && isset($parameters['canvasSettings'])) {
   180|             $this->model->setEvents($entity, $parameters['events'], $parameters['canvasSettings'], $deletedEvents);
   181|         }
   182|         /** @var array<ConstraintViolationListInterface<ConstraintViolationInterface>> $eventViolations */
   183|         $eventViolations = array_filter(
   184|             array_map(
   185|                 fn (Event $event) => $this->validator->validate($event),
   186|                 $entity->getEvents()->toArray()
   187|             ),
   188|             fn ($error) => $error->count() > 0
   189|         );
   190|         if (count($eventViolations) > 0) {
   191|             $errors = [];
   192|             foreach ($eventViolations as $violationList) {
   193|                 foreach ($violationList as $violation) {
   194|                     \assert($violation instanceof ConstraintViolationInterface);
   195|                     $errors[] = [
   196|                         'code'    => $violation->getCode(),
   197|                         'message' => $violation->getMessage(),
   198|                         'details' => $violation->getPropertyPath(),
   199|                         'type'    => 'validation',
   200|                     ];
   201|                 }
   202|             }
   203|             $view = $this->view(['errors' => $errors], Response::HTTP_UNPROCESSABLE_ENTITY);
   204|             return $this->handleView($view);
   205|         }
   206|         $this->model->saveEntity($entity);
   207|         if (isset($parameters['canvasSettings'])) {
   208|             $this->model->setCanvasSettings($entity, $parameters['canvasSettings']);
   209|         }
   210|         if (Request::METHOD_PUT === $method && !empty($deletedEvents)) {
   211|             $this->eventModel->deleteEvents($entity->getEvents()->toArray(), $deletedEvents);
   212|         }
   213|     }
   214|     /**
   215|      * Change the array structure.
   216|      *
   217|      * @param array $events
   218|      */
   219|     public function modifyCampaignEventArray($events): array
   220|     {
   221|         $updatedEvents = [];
   222|         if ($events && is_array($events)) {
   223|             foreach ($events as $event) {
   224|                 if (!empty($event['id'])) {
   225|                     $updatedEvents[$event['id']] = 'ignore';
   226|                 }
   227|             }
   228|         }
   229|         return $updatedEvents;
   230|     }
   231|     /**
   232|      * Obtains a list of campaign contacts.
   233|      *
   234|      * @return Response
   235|      */
   236|     public function getContactsAction(Request $request, $id)
   237|     {
   238|         $entity = $this->model->getEntity($id);
   239|         if (null === $entity) {
   240|             return $this->notFound();
   241|         }
   242|         if (!$this->checkEntityAccess($entity)) {
   243|             return $this->accessDenied();
   244|         }
   245|         $where = InputHelper::clean($request->query->get('where') ?? []);
   246|         $order = InputHelper::clean($request->query->get('order') ?? []);
   247|         $start = (int) $request->query->get('start', 0);
   248|         $limit = (int) $request->query->get('limit', 100);
   249|         $where[] = [
   250|             'col'  => 'campaign_id',
   251|             'expr' => 'eq',
   252|             'val'  => $id,
   253|         ];
   254|         $where[] = [
   255|             'col'  => 'manually_removed',
   256|             'expr' => 'eq',
   257|             'val'  => 0,
   258|         ];
   259|         return $this->forward(
   260|             'Mautic\CoreBundle\Controller\Api\StatsApiController::listAction',
   261|             [
   262|                 'table'     => 'campaign_leads',
   263|                 'itemsName' => 'contacts',
   264|                 'order'     => $order,
   265|                 'where'     => $where,
   266|                 'start'     => $start,
   267|                 'limit'     => $limit,
   268|             ]
   269|         );
   270|     }
   271|     public function cloneCampaignAction($campaignId)
   272|     {
   273|         if (empty($campaignId) || false == intval($campaignId)) {
   274|             return $this->notFound();
   275|         }
   276|         $original = $this->model->getEntity($campaignId);
   277|         if (empty($original)) {
   278|             return $this->notFound();
   279|         }
   280|         $entity = clone $original;
   281|         if (!$this->checkEntityAccess($entity, 'create')) {
   282|             return $this->accessDenied();
   283|         }
   284|         $this->model->saveEntity($entity);
   285|         $headers = [];
   286|         $route               = 'mautic_api_campaigns_getone';
   287|         $headers['Location'] = $this->generateUrl(
   288|             $route,
   289|             array_merge(['id' => $entity->getId()], $this->routeParams),
   290|             true
   291|         );
   292|         $view = $this->view([$this->entityNameOne => $entity], Response::HTTP_OK, $headers);
   293|         $this->setSerializationContext($view);
   294|         return $this->handleView($view);
   295|     }
   296| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/Api/EventApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Controller\CommonApiController;
     5| use Mautic\ApiBundle\Helper\EntityResultHelper;
     6| use Mautic\ApiBundle\Serializer\Exclusion\FieldExclusionStrategy;
     7| use Mautic\CampaignBundle\Entity\Event;
     8| use Mautic\CampaignBundle\Model\EventModel;
     9| use Mautic\CoreBundle\Factory\ModelFactory;
    10| use Mautic\CoreBundle\Helper\AppVersion;
    11| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    12| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    13| use Mautic\CoreBundle\Translation\Translator;
    14| use Mautic\LeadBundle\Controller\LeadAccessTrait;
    15| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    16| use Symfony\Component\Form\FormFactoryInterface;
    17| use Symfony\Component\HttpFoundation\RequestStack;
    18| use Symfony\Component\Routing\RouterInterface;
    19| /**
    20|  * @extends CommonApiController<Event>
    21|  */
    22| class EventApiController extends CommonApiController
    23| {
    24|     use LeadAccessTrait;
    25|     public function __construct(CorePermissions $security, Translator $translator, EntityResultHelper $entityResultHelper, RouterInterface $router, FormFactoryInterface $formFactory, AppVersion $appVersion, RequestStack $requestStack, ManagerRegistry $doctrine, ModelFactory $modelFactory, EventDispatcherInterface $dispatcher, CoreParametersHelper $coreParametersHelper)
    26|     {
    27|         $campaignEventModel = $modelFactory->getModel('campaign.event');
    28|         \assert($campaignEventModel instanceof EventModel);
    29|         $this->model                    = $campaignEventModel;
    30|         $this->entityClass              = Event::class;
    31|         $this->entityNameOne            = 'event';
    32|         $this->entityNameMulti          = 'events';
    33|         $this->serializerGroups         = ['campaignEventStandaloneDetails', 'campaignList'];
    34|         $this->parentChildrenLevelDepth = 1;
    35|         $this->addExclusionStrategy(new FieldExclusionStrategy(['campaign'], 1));
    36|         parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    37|     }
    38|     /**
    39|      * @param Event  $entity
    40|      * @param string $action
    41|      *
    42|      * @return bool|mixed
    43|      */
    44|     protected function checkEntityAccess($entity, $action = 'view')
    45|     {
    46|         return parent::checkEntityAccess($entity->getCampaign(), $action);
    47|     }
    48| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/Api/EventLogApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-224 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use FOS\RestBundle\View\View;
     5| use Mautic\ApiBundle\Controller\FetchCommonApiController;
     6| use Mautic\ApiBundle\Helper\EntityResultHelper;
     7| use Mautic\ApiBundle\Serializer\Exclusion\FieldInclusionStrategy;
     8| use Mautic\CampaignBundle\Entity\Campaign;
     9| use Mautic\CampaignBundle\Entity\Event;
    10| use Mautic\CampaignBundle\Entity\LeadEventLog;
    11| use Mautic\CampaignBundle\Model\EventLogModel;
    12| use Mautic\CampaignBundle\Model\EventModel;
    13| use Mautic\CoreBundle\Factory\ModelFactory;
    14| use Mautic\CoreBundle\Helper\AppVersion;
    15| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    16| use Mautic\CoreBundle\Helper\UserHelper;
    17| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    18| use Mautic\CoreBundle\Translation\Translator;
    19| use Mautic\LeadBundle\Controller\LeadAccessTrait;
    20| use Mautic\LeadBundle\Entity\Lead;
    21| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    22| use Symfony\Component\HttpFoundation\Request;
    23| use Symfony\Component\HttpFoundation\RequestStack;
    24| use Symfony\Component\HttpFoundation\Response;
    25| /**
    26|  * @extends FetchCommonApiController<LeadEventLog>
    27|  */
    28| class EventLogApiController extends FetchCommonApiController
    29| {
    30|     use LeadAccessTrait;
    31|     private const LOG_SERIALIZATION = 30;
    32|     /**
    33|      * @var Campaign
    34|      */
    35|     protected $campaign;
    36|     /**
    37|      * @var Lead
    38|      */
    39|     protected $contact;
    40|     /**
    41|      * @var EventLogModel|null
    42|      */
    43|     protected $model;
    44|     public function __construct(
    45|         CorePermissions $security,
    46|         Translator $translator,
    47|         EntityResultHelper $entityResultHelper,
    48|         AppVersion $appVersion,
    49|         RequestStack $requestStack,
    50|         ManagerRegistry $doctrine,
    51|         ModelFactory $modelFactory,
    52|         EventDispatcherInterface $dispatcher,
    53|         CoreParametersHelper $coreParametersHelper,
    54|     ) {
    55|         $campaignEventLogModel = $modelFactory->getModel('campaign.event_log');
    56|         \assert($campaignEventLogModel instanceof EventLogModel);
    57|         $this->model                    = $campaignEventLogModel;
    58|         $this->entityClass              = LeadEventLog::class;
    59|         $this->entityNameOne            = 'event';
    60|         $this->entityNameMulti          = 'events';
    61|         $this->parentChildrenLevelDepth = 1;
    62|         $this->serializerGroups         = [
    63|             'campaignList',
    64|             'ipAddressList',
    65|             self::LOG_SERIALIZATION => 'campaignEventLogDetails',
    66|         ];
    67|         $this->addExclusionStrategy(new FieldInclusionStrategy(['id'], 1, 'parent'));
    68|         parent::__construct($security, $translator, $entityResultHelper, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    69|     }
    70|     /**
    71|      * @return Response
    72|      */
    73|     public function getEntitiesAction(Request $request, UserHelper $userHelper)
    74|     {
    75|         $this->serializerGroups[self::LOG_SERIALIZATION] = 'campaignEventStandaloneLogDetails';
    76|         $this->serializerGroups[]                        = 'campaignEventStandaloneList';
    77|         $this->serializerGroups[]                        = 'leadBasicList';
    78|         return parent::getEntitiesAction($request, $userHelper);
    79|     }
    80|     /**
    81|      * Get a list of events.
    82|      *
    83|      * @return Response
    84|      */
    85|     public function getContactEventsAction(Request $request, UserHelper $userHelper, $contactId, $campaignId = null)
    86|     {
    87|         $contact = $this->checkLeadAccess($contactId, 'view');
    88|         if ($contact instanceof Response) {
    89|             return $contact;
    90|         }
    91|         if (!empty($campaignId)) {
    92|             $campaign = $this->getModel('campaign')->getEntity($campaignId);
    93|             if (null == $campaign || !$campaign->getId()) {
    94|                 return $this->notFound();
    95|             }
    96|             if (!$this->checkEntityAccess($campaign)) {
    97|                 return $this->accessDenied();
    98|             }
    99|             $membership = $campaign->getContactMembership($contact);
   100|             if (0 === count($membership)) {
   101|                 return $this->returnError(
   102|                     $this->translator->trans(
   103|                         'mautic.campaign.error.contact_not_in_campaign',
   104|                         ['%campaign%' => $campaignId, '%contact%' => $contactId]
   105|                     ),
   106|                     Response::HTTP_CONFLICT
   107|                 );
   108|             }
   109|             $this->campaign           = $campaign;
   110|             $this->serializerGroups[] = 'campaignEventWithLogsList';
   111|             $this->serializerGroups[] = 'campaignLeadList';
   112|         } else {
   113|             unset($this->serializerGroups[self::LOG_SERIALIZATION]);
   114|             $this->serializerGroups[] = 'campaignEventStandaloneList';
   115|             $this->serializerGroups[] = 'campaignEventStandaloneLogDetails';
   116|         }
   117|         $this->contact                   = $contact;
   118|         $this->extraGetEntitiesArguments = [
   119|             'contact_id'  => $contactId,
   120|             'campaign_id' => $campaignId,
   121|         ];
   122|         return $this->getEntitiesAction($request, $userHelper);
   123|     }
   124|     /**
   125|      * @return Response
   126|      */
   127|     public function editContactEventAction(Request $request, $eventId, $contactId)
   128|     {
   129|         $parameters = $request->request->all();
   130|         $contact = $this->checkLeadAccess($contactId, 'edit');
   131|         if ($contact instanceof Response) {
   132|             return $contact;
   133|         }
   134|         /** @var EventModel $eventModel */
   135|         $eventModel = $this->getModel('campaign.event');
   136|         /** @var Event $event */
   137|         $event = $eventModel->getEntity($eventId);
   138|         if (null === $event || !$event->getId()) {
   139|             return $this->notFound();
   140|         }
   141|         $campaign = $event->getCampaign();
   142|         if (!$this->checkEntityAccess($campaign, 'edit')) {
   143|             return $this->accessDenied();
   144|         }
   145|         $result = $this->model->updateContactEvent($event, $contact, $parameters);
   146|         if (is_string($result)) {
   147|             return $this->returnError($result, Response::HTTP_CONFLICT);
   148|         } else {
   149|             [$log, $created] = $result;
   150|         }
   151|         $event->addContactLog($log);
   152|         $view = $this->view(
   153|             [
   154|                 $this->entityNameOne => $event,
   155|             ],
   156|             ($created) ? Response::HTTP_CREATED : Response::HTTP_OK
   157|         );
   158|         $this->serializerGroups[] = 'campaignEventWithLogsDetails';
   159|         $this->serializerGroups[] = 'campaignBasicList';
   160|         $this->setSerializationContext($view);
   161|         return $this->handleView($view);
   162|     }
   163|     /**
   164|      * @return array|Response
   165|      */
   166|     public function editEventsAction(Request $request)
   167|     {
   168|         $parameters = $request->request->all();
   169|         $valid = $this->validateBatchPayload($parameters);
   170|         if ($valid instanceof Response) {
   171|             return $valid;
   172|         }
   173|         $events   = $this->getBatchEntities($parameters, $errors, false, 'eventId', $this->getModel('campaign.event'), false);
   174|         $contacts = $this->getBatchEntities($parameters, $errors, false, 'contactId', $this->getModel('lead'), false);
   175|         $this->inBatchMode = true;
   176|         $errors            = [];
   177|         foreach ($parameters as $key => $params) {
   178|             if (!isset($params['eventId']) || !isset($params['contactId']) || !isset($events[$params['eventId']])
   179|                 || !isset($contacts[$params['contactId']])
   180|             ) {
   181|                 $errors[$key] = $this->notFound('mautic.campaign.error.edit_events.request_invalid');
   182|                 continue;
   183|             }
   184|             $event = $events[$params['eventId']];
   185|             $contact = $this->checkLeadAccess($contacts[$params['contactId']], 'edit');
   186|             if ($contact instanceof Response) {
   187|                 $errors[$key] = $contact->getContent();
   188|                 continue;
   189|             }
   190|             $campaign = $event->getCampaign();
   191|             if (!$this->checkEntityAccess($campaign, 'edit')) {
   192|                 $errors[$key] = $this->accessDenied();
   193|                 continue;
   194|             }
   195|             $result = $this->model->updateContactEvent($event, $contact, $params);
   196|             if (is_string($result)) {
   197|                 $errors[$key] = $this->returnError($result, Response::HTTP_CONFLICT);
   198|             } else {
   199|                 [$log, $created] = $result;
   200|                 $event->addContactLog($log);
   201|             }
   202|         }
   203|         $payload = [
   204|             $this->entityNameMulti => $events,
   205|         ];
   206|         if (!empty($errors)) {
   207|             $payload['errors'] = $errors;
   208|         }
   209|         $view                     = $this->view($payload, Response::HTTP_OK);
   210|         $this->serializerGroups[] = 'campaignEventWithLogsList';
   211|         $this->setSerializationContext($view);
   212|         return $this->handleView($view);
   213|     }
   214|     protected function view($data = null, ?int $statusCode = null, array $headers = []): View
   215|     {
   216|         if ($this->campaign) {
   217|             $data['campaign'] = $this->campaign;
   218|             if ($this->contact) {
   219|                 [$data['membership'], $ignore] = $this->prepareEntitiesForView($this->campaign->getContactMembership($this->contact));
   220|             }
   221|         }
   222|         return parent::view($data, $statusCode, $headers);
   223|     }
   224| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/CampaignController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-998 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller;
     3| use Doctrine\DBAL\Cache\CacheException;
     4| use Doctrine\Persistence\ManagerRegistry;
     5| use Mautic\CampaignBundle\Entity\Campaign;
     6| use Mautic\CampaignBundle\Entity\Event;
     7| use Mautic\CampaignBundle\Entity\LeadEventLog;
     8| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     9| use Mautic\CampaignBundle\Entity\Summary;
    10| use Mautic\CampaignBundle\Entity\SummaryRepository;
    11| use Mautic\CampaignBundle\EventCollector\EventCollector;
    12| use Mautic\CampaignBundle\EventListener\CampaignActionJumpToEventSubscriber;
    13| use Mautic\CampaignBundle\Model\CampaignModel;
    14| use Mautic\CampaignBundle\Model\EventModel;
    15| use Mautic\CoreBundle\Controller\AbstractStandardFormController;
    16| use Mautic\CoreBundle\Factory\ModelFactory;
    17| use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
    18| use Mautic\CoreBundle\Form\Type\DateRangeType;
    19| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    20| use Mautic\CoreBundle\Helper\UserHelper;
    21| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    22| use Mautic\CoreBundle\Service\FlashBag;
    23| use Mautic\CoreBundle\Translation\Translator;
    24| use Mautic\CoreBundle\Twig\Helper\DateHelper;
    25| use Mautic\FormBundle\Helper\FormFieldHelper;
    26| use Mautic\LeadBundle\Controller\EntityContactsTrait;
    27| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    28| use Symfony\Component\Form\Form;
    29| use Symfony\Component\Form\FormError;
    30| use Symfony\Component\Form\FormFactoryInterface;
    31| use Symfony\Component\Form\FormInterface;
    32| use Symfony\Component\HttpFoundation\JsonResponse;
    33| use Symfony\Component\HttpFoundation\RedirectResponse;
    34| use Symfony\Component\HttpFoundation\Request;
    35| use Symfony\Component\HttpFoundation\RequestStack;
    36| use Symfony\Component\HttpFoundation\Response;
    37| use Symfony\Component\HttpFoundation\Session\Session;
    38| class CampaignController extends AbstractStandardFormController
    39| {
    40|     use EntityContactsTrait;
    41|     /**
    42|      * @var array
    43|      */
    44|     protected $addedSources = [];
    45|     /**
    46|      * @var array
    47|      */
    48|     protected $campaignEvents = [];
    49|     /**
    50|      * @var array
    51|      */
    52|     protected $campaignSources = [];
    53|     /**
    54|      * @var array
    55|      */
    56|     protected $connections = [];
    57|     /**
    58|      * @var array
    59|      */
    60|     protected $deletedEvents = [];
    61|     /**
    62|      * @var array
    63|      */
    64|     protected $deletedSources = [];
    65|     /**
    66|      * @var array
    67|      */
    68|     protected $listFilters = [];
    69|     /**
    70|      * @var array
    71|      */
    72|     protected $modifiedEvents = [];
    73|     protected $sessionId;
    74|     public function __construct(
    75|         FormFactoryInterface $formFactory,
    76|         FormFieldHelper $fieldHelper,
    77|         private EventCollector $eventCollector,
    78|         private DateHelper $dateHelper,
    79|         ManagerRegistry $managerRegistry,
    80|         ModelFactory $modelFactory,
    81|         UserHelper $userHelper,
    82|         CoreParametersHelper $coreParametersHelper,
    83|         EventDispatcherInterface $dispatcher,
    84|         Translator $translator,
    85|         FlashBag $flashBag,
    86|         private RequestStack $requestStack,
    87|         CorePermissions $security,
    88|     ) {
    89|         parent::__construct($formFactory, $fieldHelper, $managerRegistry, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    90|     }
    91|     protected function getPermissions(): array
    92|     {
    93|         return (array) $this->security->isGranted(
    94|             [
    95|                 'campaign:campaigns:viewown',
    96|                 'campaign:campaigns:viewother',
    97|                 'campaign:campaigns:create',
    98|                 'campaign:campaigns:editown',
    99|                 'campaign:campaigns:editother',
   100|                 'campaign:campaigns:cloneown',
   101|                 'campaign:campaigns:cloneother',
   102|                 'campaign:campaigns:deleteown',
   103|                 'campaign:campaigns:deleteother',
   104|                 'campaign:campaigns:publishown',
   105|                 'campaign:campaigns:publishother',
   106|             ],
   107|             'RETURN_ARRAY'
   108|         );
   109|     }
   110|     /**
   111|      * Deletes a group of entities.
   112|      *
   113|      * @return JsonResponse|RedirectResponse
   114|      */
   115|     public function batchDeleteAction(Request $request)
   116|     {
   117|         return $this->batchDeleteStandard($request);
   118|     }
   119|     /**
   120|      * Clone an entity.
   121|      *
   122|      * @return JsonResponse|RedirectResponse|Response
   123|      */
   124|     public function cloneAction(Request $request, $objectId)
   125|     {
   126|         return $this->cloneStandard($request, $objectId);
   127|     }
   128|     /**
   129|      * @param string|int $objectId
   130|      * @param int        $page
   131|      * @param int|null   $count
   132|      *
   133|      * @return JsonResponse|RedirectResponse|Response
   134|      */
   135|     public function contactsAction(
   136|         Request $request,
   137|         PageHelperFactoryInterface $pageHelperFactory,
   138|         $objectId,
   139|         $page = 1,
   140|         $count = null,
   141|         \DateTimeInterface $dateFrom = null,
   142|         \DateTimeInterface $dateTo = null,
   143|     ) {
   144|         $session = $request->getSession();
   145|         $session->set('mautic.campaign.contact.page', $page);
   146|         $permissions = [
   147|             'campaign:campaigns:view',
   148|             'lead:leads:viewown',
   149|             'lead:leads:viewother',
   150|         ];
   151|         return $this->generateContactsGrid(
   152|             $request,
   153|             $pageHelperFactory,
   154|             $objectId,
   155|             $page,
   156|             $permissions,
   157|             'campaign',
   158|             'campaign_leads',
   159|             null,
   160|             'campaign_id',
   161|             ['manually_removed' => 0],
   162|             null,
   163|             null,
   164|             [],
   165|             null,
   166|             'entity.lead_id',
   167|             'DESC',
   168|             $count,
   169|             $dateFrom,
   170|             $dateTo
   171|         );
   172|     }
   173|     /**
   174|      * Deletes the entity.
   175|      *
   176|      * @return JsonResponse|RedirectResponse
   177|      */
   178|     public function deleteAction(Request $request, $objectId)
   179|     {
   180|         return $this->deleteStandard($request, $objectId);
   181|     }
   182|     /**
   183|      * @param bool $ignorePost
   184|      *
   185|      * @return JsonResponse|RedirectResponse|Response
   186|      */
   187|     public function editAction(Request $request, $objectId, $ignorePost = false)
   188|     {
   189|         return $this->editStandard($request, $objectId, $ignorePost);
   190|     }
   191|     /**
   192|      * @param int $page
   193|      *
   194|      * @return JsonResponse|Response
   195|      */
   196|     public function indexAction(Request $request, $page = null)
   197|     {
   198|         $permissions = $this->security->isGranted(
   199|             [
   200|                 'campaign:campaigns:view',
   201|                 'campaign:campaigns:viewown',
   202|                 'campaign:campaigns:viewother',
   203|                 'campaign:campaigns:create',
   204|                 'campaign:campaigns:edit',
   205|                 'campaign:campaigns:editown',
   206|                 'campaign:campaigns:editother',
   207|                 'campaign:campaigns:delete',
   208|                 'campaign:campaigns:deleteown',
   209|                 'campaign:campaigns:deleteother',
   210|                 'campaign:campaigns:publish',
   211|                 'campaign:campaigns:publishown',
   212|                 'campaign:campaigns:publishother',
   213|             ],
   214|             'RETURN_ARRAY',
   215|             null,
   216|             true
   217|         );
   218|         if (!$permissions['campaign:campaigns:view']) {
   219|             return $this->accessDenied();
   220|         }
   221|         $this->setListFilters();
   222|         $session = $request->getSession();
   223|         if (empty($page)) {
   224|             $page = $session->get('mautic.campaign.page', 1);
   225|         }
   226|         $limit = $session->get('mautic.campaign.limit', $this->coreParametersHelper->get('default_pagelimit'));
   227|         $start = (1 === $page) ? 0 : (($page - 1) * $limit);
   228|         if ($start < 0) {
   229|             $start = 0;
   230|         }
   231|         $search = $request->get('search', $session->get('mautic.campaign.filter', ''));
   232|         $session->set('mautic.campaign.filter', $search);
   233|         $filter = ['string' => $search, 'force' => []];
   234|         $model = $this->getModel('campaign');
   235|         if (!$permissions[$this->getPermissionBase().':viewother']) {
   236|             $filter['force'][] = ['column' => 'c.createdBy', 'expr' => 'eq', 'value' => $this->user->getId()];
   237|         }
   238|         $orderBy    = $session->get('mautic.campaign.orderby', 'c.dateModified');
   239|         $orderByDir = $session->get('mautic.campaign.orderbydir', $this->getDefaultOrderDirection());
   240|         [$count, $items] = $this->getIndexItems($start, $limit, $filter, $orderBy, $orderByDir);
   241|         if ($count && $count < ($start + 1)) {
   242|             $lastPage = (1 === $count) ? 1 : (((ceil($count / $limit)) ?: 1) ?: 1);
   243|             $session->set('mautic.campaign.page', $lastPage);
   244|             $returnUrl = $this->generateUrl('mautic_campaign_index', ['page' => $lastPage]);
   245|             return $this->postActionRedirect(
   246|                 $this->getPostActionRedirectArguments(
   247|                     [
   248|                         'returnUrl'       => $returnUrl,
   249|                         'viewParameters'  => ['page' => $lastPage],
   250|                         'contentTemplate' => 'Mautic\CampaignBundle\Controller\CampaignController::indexAction',
   251|                         'passthroughVars' => [
   252|                             'mauticContent' => 'campaign',
   253|                         ],
   254|                     ],
   255|                     'index'
   256|                 )
   257|             );
   258|         }
   259|         $session->set('mautic.campaign.page', $page);
   260|         $viewParameters = [
   261|             'permissionBase'  => $this->getPermissionBase(),
   262|             'mauticContent'   => $this->getJsLoadMethodPrefix(),
   263|             'sessionVar'      => $this->getSessionBase(),
   264|             'actionRoute'     => $this->getActionRoute(),
   265|             'indexRoute'      => $this->getIndexRoute(),
   266|             'tablePrefix'     => $model->getRepository()->getTableAlias(),
   267|             'modelName'       => $this->getModelName(),
   268|             'translationBase' => $this->getTranslationBase(),
   269|             'searchValue'     => $search,
   270|             'items'           => $items,
   271|             'totalItems'      => $count,
   272|             'page'            => $page,
   273|             'limit'           => $limit,
   274|             'permissions'     => $permissions,
   275|             'tmpl'            => $request->get('tmpl', 'index'),
   276|         ];
   277|         return $this->delegateView(
   278|             $this->getViewArguments(
   279|                 [
   280|                     'viewParameters'  => $viewParameters,
   281|                     'contentTemplate' => '@MauticCampaign/Campaign/list.html.twig',
   282|                     'passthroughVars' => [
   283|                         'mauticContent' => $this->getJsLoadMethodPrefix(),
   284|                         'route'         => $this->generateUrl($this->getIndexRoute(), ['page' => $page]),
   285|                     ],
   286|                 ],
   287|                 'index'
   288|             )
   289|         );
   290|     }
   291|     /**
   292|      * Generates new form and processes post data.
   293|      *
   294|      * @return RedirectResponse|Response
   295|      */
   296|     public function newAction(Request $request)
   297|     {
   298|         /** @var CampaignModel $model */
   299|         $model    = $this->getModel('campaign');
   300|         $campaign = $model->getEntity();
   301|         if (!$this->security->isGranted('campaign:campaigns:create')) {
   302|             return $this->accessDenied();
   303|         }
   304|         $page = $request->getSession()->get('mautic.campaign.page', 1);
   305|         $options = $this->getEntityFormOptions();
   306|         $action  = $this->generateUrl('mautic_campaign_action', ['objectAction' => 'new']);
   307|         $form    = $model->createForm($campaign, $this->formFactory, $action, $options);
   308|         $isPost = 'POST' === $request->getMethod();
   309|         $this->beforeFormProcessed($campaign, $form, 'new', $isPost);
   310|         if ($isPost) {
   311|             $valid = false;
   312|             if (!$cancelled = $this->isFormCancelled($form)) {
   313|                 if ($valid = $this->isFormValid($form)) {
   314|                     if ($valid = $this->beforeEntitySave($campaign, $form, 'new')) {
   315|                         $campaign->setDateModified(new \DateTime());
   316|                         $model->saveEntity($campaign);
   317|                         $this->afterEntitySave($campaign, $form, 'new', $valid);
   318|                         if (method_exists($this, 'viewAction')) {
   319|                             $viewParameters = ['objectId' => $campaign->getId(), 'objectAction' => 'view'];
   320|                             $returnUrl      = $this->generateUrl('mautic_campaign_action', $viewParameters);
   321|                             $template       = 'Mautic\CampaignBundle\Controller\CampaignController::viewAction';
   322|                         } else {
   323|                             $viewParameters = ['page' => $page];
   324|                             $returnUrl      = $this->generateUrl('mautic_campaign_index', $viewParameters);
   325|                             $template       = 'Mautic\CampaignBundle\Controller\CampaignController::indexAction';
   326|                         }
   327|                     }
   328|                 }
   329|                 $this->afterFormProcessed($valid, $campaign, $form, 'new');
   330|             } else {
   331|                 $viewParameters = ['page' => $page];
   332|                 $returnUrl      = $this->generateUrl($this->getIndexRoute(), $viewParameters);
   333|                 $template       = 'Mautic\CampaignBundle\Controller\CampaignController::indexAction';
   334|             }
   335|             $passthrough = [
   336|                 'mauticContent' => 'cammpaign',
   337|             ];
   338|             if ($isInPopup = isset($form['updateSelect'])) {
   339|                 $template    = false;
   340|                 $passthrough = array_merge(
   341|                     $passthrough,
   342|                     $this->getUpdateSelectParams($form['updateSelect']->getData(), $campaign)
   343|                 );
   344|             }
   345|             if ($cancelled || ($valid && !$this->isFormApplied($form))) {
   346|                 if ($isInPopup) {
   347|                     $passthrough['closeModal'] = true;
   348|                 }
   349|                 return $this->postActionRedirect(
   350|                     $this->getPostActionRedirectArguments(
   351|                         [
   352|                             'returnUrl'       => $returnUrl,
   353|                             'viewParameters'  => $viewParameters,
   354|                             'contentTemplate' => $template,
   355|                             'passthroughVars' => $passthrough,
   356|                             'entity'          => $campaign,
   357|                         ],
   358|                         'new'
   359|                     )
   360|                 );
   361|             } elseif ($valid && $this->isFormApplied($form)) {
   362|                 return $this->editAction($request, $campaign->getId(), true);
   363|             }
   364|         }
   365|         $delegateArgs = [
   366|             'viewParameters' => [
   367|                 'permissionBase'  => $model->getPermissionBase(),
   368|                 'mauticContent'   => 'campaign',
   369|                 'actionRoute'     => 'mautic_campaign_action',
   370|                 'indexRoute'      => 'mautic_campaign_index',
   371|                 'tablePrefix'     => 'c',
   372|                 'modelName'       => 'campaign',
   373|                 'translationBase' => $this->getTranslationBase(),
   374|                 'tmpl'            => $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index',
   375|                 'entity'          => $campaign,
   376|                 'form'            => $this->getFormView($form, 'new'),
   377|             ],
   378|             'contentTemplate' => '@MauticCampaign/Campaign/form.html.twig',
   379|             'passthroughVars' => [
   380|                 'mauticContent' => 'campaign',
   381|                 'route'         => $this->generateUrl(
   382|                     'mautic_campaign_action',
   383|                     [
   384|                         'objectAction' => (!empty($valid) ? 'edit' : 'new'), // valid means a new form was applied
   385|                         'objectId'     => ($campaign) ? $campaign->getId() : 0,
   386|                     ]
   387|                 ),
   388|                 'validationError' => $this->getFormErrorForBuilder($form),
   389|             ],
   390|             'entity' => $campaign,
   391|             'form'   => $form,
   392|         ];
   393|         return $this->delegateView(
   394|             $this->getViewArguments($delegateArgs, 'new')
   395|         );
   396|     }
   397|     /**
   398|      * View a specific campaign.
   399|      *
   400|      * @return JsonResponse|Response
   401|      */
   402|     public function viewAction(Request $request, $objectId)
   403|     {
   404|         return $this->viewStandard($request, $objectId, $this->getModelName(), null, null, 'campaign');
   405|     }
   406|     /**
   407|      * @param Campaign $campaign
   408|      * @param Campaign $oldCampaign
   409|      */
   410|     protected function afterEntityClone($campaign, $oldCampaign)
   411|     {
   412|         $tempId   = 'mautic_'.sha1(uniqid(mt_rand(), true));
   413|         $objectId = $oldCampaign->getId();
   414|         $events = $oldCampaign->getEvents()->toArray();
   415|         $campaign->setIsPublished(false);
   416|         /** @var Event $event */
   417|         foreach ($events as $event) {
   418|             $tempEventId = 'new'.$event->getId();
   419|             $clone = clone $event;
   420|             $clone->nullId();
   421|             $clone->setCampaign($campaign);
   422|             $clone->setTempId($tempEventId);
   423|             $clone->setParent(null);
   424|             if (CampaignActionJumpToEventSubscriber::EVENT_NAME === $clone->getType()) {
   425|                 $properties                = $clone->getProperties();
   426|                 $properties['jumpToEvent'] = 'new'.$properties['jumpToEvent'];
   427|                 $clone->setProperties($properties);
   428|             }
   429|             $campaign->addEvent($tempEventId, $clone);
   430|         }
   431|         $canvasSettings = $campaign->getCanvasSettings();
   432|         if (isset($canvasSettings['nodes'])) {
   433|             foreach ($canvasSettings['nodes'] as &$node) {
   434|                 if (is_numeric($node['id'])) {
   435|                     $node['id'] = 'new'.$node['id'];
   436|                 }
   437|             }
   438|         }
   439|         if (isset($canvasSettings['connections'])) {
   440|             foreach ($canvasSettings['connections'] as &$c) {
   441|                 if (is_numeric($c['sourceId'])) {
   442|                     $c['sourceId'] = 'new'.$c['sourceId'];
   443|                 }
   444|                 if (is_numeric($c['targetId'])) {
   445|                     $c['targetId'] = 'new'.$c['targetId'];
   446|                 }
   447|             }
   448|         }
   449|         $campaign->setCanvasSettings($canvasSettings);
   450|         $this->setSessionCanvasSettings($tempId, $canvasSettings);
   451|         $tempId = $this->getCampaignSessionId($campaign, 'clone', $tempId);
   452|         $campaignSources = $this->getCampaignModel()->getLeadSources($objectId);
   453|         $this->prepareCampaignSourcesForEdit($tempId, $campaignSources);
   454|     }
   455|     /**
   456|      * @param object    $entity
   457|      * @param string    $action
   458|      * @param bool|null $persistConnections
   459|      */
   460|     protected function afterEntitySave($entity, FormInterface $form, $action, $persistConnections = null)
   461|     {
   462|         if ($persistConnections) {
   463|             $this->connections = $this->getCampaignModel()->setCanvasSettings($entity, $this->connections);
   464|         } else {
   465|             $this->connections = $this->getCampaignModel()->setCanvasSettings($entity, $this->connections, false, $this->modifiedEvents);
   466|         }
   467|     }
   468|     /**
   469|      * @param bool $isClone
   470|      */
   471|     protected function afterFormProcessed($isValid, $entity, FormInterface $form, $action, $isClone = false)
   472|     {
   473|         if (!$isValid) {
   474|             $this->afterEntitySave($entity, $form, $action, false);
   475|         } else {
   476|             $this->clearSessionComponents($this->sessionId);
   477|             $this->sessionId = $entity->getId();
   478|         }
   479|     }
   480|     /**
   481|      * @param bool $isClone
   482|      */
   483|     protected function beforeFormProcessed($entity, FormInterface $form, $action, $isPost, $objectId = null, $isClone = false)
   484|     {
   485|         $sessionId = $this->getCampaignSessionId($entity, $action, $objectId);
   486|         [$this->modifiedEvents, $this->deletedEvents, $this->campaignEvents] = $this->getSessionEvents($sessionId);
   487|         [$this->addedSources, $this->deletedSources, $campaignSources]     = $this->getSessionSources($sessionId, $isClone);
   488|         $this->connections                                                 = $this->getSessionCanvasSettings($sessionId);
   489|         if ($isPost) {
   490|             $this->getCampaignModel()->setCanvasSettings($entity, $this->connections, false, $this->modifiedEvents);
   491|             $this->prepareCampaignSourcesForEdit($sessionId, $campaignSources, true);
   492|         } else {
   493|             if (!$isClone) {
   494|                 $this->clearSessionComponents($sessionId);
   495|                 $this->modifiedEvents = $this->campaignSources = [];
   496|                 if ($entity->getId()) {
   497|                     $campaignSources = $this->getCampaignModel()->getLeadSources($entity->getId());
   498|                     $this->prepareCampaignSourcesForEdit($sessionId, $campaignSources);
   499|                     $this->setSessionCanvasSettings($sessionId, $entity->getCanvasSettings());
   500|                 }
   501|             }
   502|             $this->deletedEvents = [];
   503|             $form->get('sessionId')->setData($sessionId);
   504|             $this->prepareCampaignEventsForEdit($entity, $sessionId, $isClone);
   505|         }
   506|     }
   507|     /**
   508|      * @param Campaign $entity
   509|      * @param bool     $isClone
   510|      */
   511|     protected function beforeEntitySave($entity, FormInterface $form, $action, $objectId = null, $isClone = false): bool
   512|     {
   513|         if (empty($this->campaignEvents)) {
   514|             $form->addError(
   515|                 new FormError(
   516|                     $this->translator->trans('mautic.campaign.form.events.notempty', [], 'validators')
   517|                 )
   518|             );
   519|             return false;
   520|         }
   521|         if (empty($this->campaignSources['lists']) && empty($this->campaignSources['forms'])) {
   522|             $form->addError(
   523|                 new FormError(
   524|                     $this->translator->trans('mautic.campaign.form.sources.notempty', [], 'validators')
   525|                 )
   526|             );
   527|             return false;
   528|         }
   529|         if ($isClone) {
   530|             [$this->addedSources, $this->deletedSources, $campaignSources] = $this->getSessionSources($objectId, $isClone);
   531|             $this->getCampaignModel()->setLeadSources($entity, $campaignSources, []);
   532|             $this->getCampaignModel()->getRepository()->saveEntity($entity);
   533|             $entity->setNew();
   534|             $this->sessionId = $entity->getId();
   535|         }
   536|         $this->getCampaignModel()->setLeadSources($entity, $this->addedSources, $this->deletedSources);
   537|         $this->getCampaignModel()->setEvents($entity, $this->campaignEvents, $this->connections, $this->deletedEvents);
   538|         if ('edit' === $action && null !== $this->connections) {
   539|             if (!empty($this->deletedEvents)) {
   540|                 /** @var EventModel $eventModel */
   541|                 $eventModel = $this->getModel('campaign.event');
   542|                 $eventModel->deleteEvents($entity->getEvents()->toArray(), $this->deletedEvents);
   543|             }
   544|         }
   545|         return true;
   546|     }
   547|     /**
   548|      * Clear field and events from the session.
   549|      */
   550|     protected function clearSessionComponents($id)
   551|     {
   552|         $session = $this->getCurrentRequest()->getSession();
   553|         $session->remove('mautic.campaign.'.$id.'.events.modified');
   554|         $session->remove('mautic.campaign.'.$id.'.events.deleted');
   555|         $session->remove('mautic.campaign.'.$id.'.events.canvassettings');
   556|         $session->remove('mautic.campaign.'.$id.'.leadsources.current');
   557|         $session->remove('mautic.campaign.'.$id.'.leadsources.modified');
   558|         $session->remove('mautic.campaign.'.$id.'.leadsources.deleted');
   559|     }
   560|     /**
   561|      * @return CampaignModel
   562|      */
   563|     protected function getCampaignModel()
   564|     {
   565|         /** @var CampaignModel $model */
   566|         $model = $this->getModel($this->getModelName());
   567|         return $model;
   568|     }
   569|     /**
   570|      * @return int|string|null
   571|      */
   572|     protected function getCampaignSessionId(Campaign $campaign, $action, $objectId = null)
   573|     {
   574|         if (isset($this->sessionId)) {
   575|             return $this->sessionId;
   576|         }
   577|         if ($objectId) {
   578|             $sessionId = $objectId;
   579|         } elseif ('new' === $action && empty($sessionId)) {
   580|             $sessionId = 'mautic_'.sha1(uniqid(mt_rand(), true));
   581|             if ($this->requestStack->getCurrentRequest()->request->has('campaign')) {
   582|                 $campaign  = $this->requestStack->getCurrentRequest()->request->all()['campaign'] ?? [];
   583|                 $sessionId = $campaign['sessionId'] ?? $sessionId;
   584|             }
   585|         } elseif ('edit' === $action) {
   586|             $sessionId = $campaign->getId();
   587|         }
   588|         $this->sessionId = $sessionId;
   589|         return $sessionId;
   590|     }
   591|     protected function getTemplateBase(): string
   592|     {
   593|         return '@MauticCampaign/Campaign';
   594|     }
   595|     protected function getIndexItems($start, $limit, $filter, $orderBy, $orderByDir, array $args = [])
   596|     {
   597|         $session        = $this->getCurrentRequest()->getSession();
   598|         $currentFilters = $session->get('mautic.campaign.list_filters', []);
   599|         $updatedFilters = $this->requestStack->getCurrentRequest()->get('filters', false);
   600|         $sourceLists = $this->getCampaignModel()->getSourceLists();
   601|         $listFilters = [
   602|             'filters' => [
   603|                 'placeholder' => $this->translator->trans('mautic.campaign.filter.placeholder'),
   604|                 'multiple'    => true,
   605|                 'groups'      => [
   606|                     'mautic.campaign.leadsource.form' => [
   607|                         'options' => $sourceLists['forms'],
   608|                         'prefix'  => 'form',
   609|                     ],
   610|                     'mautic.campaign.leadsource.list' => [
   611|                         'options' => $sourceLists['lists'],
   612|                         'prefix'  => 'list',
   613|                     ],
   614|                 ],
   615|             ],
   616|         ];
   617|         if ($updatedFilters) {
   618|             $newFilters     = [];
   619|             $updatedFilters = json_decode($updatedFilters, true);
   620|             if ($updatedFilters) {
   621|                 foreach ($updatedFilters as $updatedFilter) {
   622|                     [$clmn, $fltr] = explode(':', $updatedFilter);
   623|                     $newFilters[$clmn][] = $fltr;
   624|                 }
   625|                 $currentFilters = $newFilters;
   626|             } else {
   627|                 $currentFilters = [];
   628|             }
   629|         }
   630|         $session->set('mautic.campaign.list_filters', $currentFilters);
   631|         $joinLists = $joinForms = false;
   632|         if (!empty($currentFilters)) {
   633|             $listIds = $catIds = [];
   634|             foreach ($currentFilters as $type => $typeFilters) {
   635|                 $listFilters['filters']['groups']['mautic.campaign.leadsource.'.$type]['values'] = $typeFilters;
   636|                 foreach ($typeFilters as $fltr) {
   637|                     if ('list' == $type) {
   638|                         $listIds[] = (int) $fltr;
   639|                     } else {
   640|                         $formIds[] = (int) $fltr;
   641|                     }
   642|                 }
   643|             }
   644|             if (!empty($listIds)) {
   645|                 $joinLists         = true;
   646|                 $filter['force'][] = ['column' => 'l.id', 'expr' => 'in', 'value' => $listIds];
   647|             }
   648|             if (!empty($formIds)) {
   649|                 $joinForms         = true;
   650|                 $filter['force'][] = ['column' => 'f.id', 'expr' => 'in', 'value' => $formIds];
   651|             }
   652|         }
   653|         $this->listFilters = $listFilters;
   654|         return parent::getIndexItems(
   655|             $start,
   656|             $limit,
   657|             $filter,
   658|             $orderBy,
   659|             $orderByDir,
   660|             [
   661|                 'joinLists' => $joinLists,
   662|                 'joinForms' => $joinForms,
   663|             ]
   664|         );
   665|     }
   666|     protected function getModelName(): string
   667|     {
   668|         return 'campaign';
   669|     }
   670|     /**
   671|      * @return mixed[]
   672|      */
   673|     protected function getPostActionRedirectArguments(array $args, $action): array
   674|     {
   675|         switch ($action) {
   676|             case 'new':
   677|             case 'edit':
   678|                 if (!empty($args['entity'])) {
   679|                     $sessionId = $this->getCampaignSessionId($args['entity'], $action);
   680|                     $this->clearSessionComponents($sessionId);
   681|                 }
   682|                 break;
   683|         }
   684|         return $args;
   685|     }
   686|     /**
   687|      * Get events from session.
   688|      */
   689|     protected function getSessionEvents($id): array
   690|     {
   691|         $session = $this->getCurrentRequest()->getSession();
   692|         $modifiedEvents = $session->get('mautic.campaign.'.$id.'.events.modified', []);
   693|         $deletedEvents  = $session->get('mautic.campaign.'.$id.'.events.deleted', []);
   694|         $events = array_diff_key($modifiedEvents, array_flip($deletedEvents));
   695|         return [$modifiedEvents, $deletedEvents, $events];
   696|     }
   697|     /**
   698|      * Get events from session.
   699|      */
   700|     protected function getSessionSources($id, $isClone = false): array
   701|     {
   702|         $session = $this->getCurrentRequest()->getSession();
   703|         $campaignSources = $session->get('mautic.campaign.'.$id.'.leadsources.current', []);
   704|         $modifiedSources = $session->get('mautic.campaign.'.$id.'.leadsources.modified', []);
   705|         if ($campaignSources === $modifiedSources) {
   706|             if ($isClone) {
   707|                 return [$campaignSources, [], $campaignSources];
   708|             } else {
   709|                 return [[], [], $campaignSources];
   710|             }
   711|         }
   712|         $deletedSources = [];
   713|         foreach ($campaignSources as $type => $sources) {
   714|             if (isset($modifiedSources[$type])) {
   715|                 $deletedSources[$type] = array_diff_key($sources, $modifiedSources[$type]);
   716|             } else {
   717|                 $deletedSources[$type] = $sources;
   718|             }
   719|         }
   720|         $addedSources = [];
   721|         foreach ($modifiedSources as $type => $sources) {
   722|             if (isset($campaignSources[$type])) {
   723|                 $addedSources[$type] = array_diff_key($sources, $campaignSources[$type]);
   724|             } else {
   725|                 $addedSources[$type] = $sources;
   726|             }
   727|         }
   728|         return [$addedSources, $deletedSources, $modifiedSources];
   729|     }
   730|     /**
   731|      * @param string $action
   732|      *
   733|      * @throws CacheException
   734|      */
   735|     protected function getViewArguments(array $args, $action): array
   736|     {
   737|         switch ($action) {
   738|             case 'index':
   739|                 $args['viewParameters']['filters'] = $this->listFilters;
   740|                 break;
   741|             case 'view':
   742|                 /** @var Campaign $entity */
   743|                 $entity   = $args['entity'];
   744|                 $objectId = $args['objectId'];
   745|                 $dateRangeValues = $this->requestStack->getCurrentRequest()->get('daterange', []);
   746|                 $action          = $this->generateUrl('mautic_campaign_action', ['objectAction' => 'view', 'objectId' => $objectId]);
   747|                 $dateRangeForm   = $this->formFactory->create(DateRangeType::class, $dateRangeValues, ['action' => $action]);
   748|                 $events          = $this->getCampaignModel()->getEventRepository()->getCampaignEvents($entity->getId());
   749|                 $dateFrom        = null;
   750|                 $dateTo          = null;
   751|                 $dateToPlusOne   = null;
   752|                 if ($this->coreParametersHelper->get('campaign_by_range')) {
   753|                     $dateFrom      = new \DateTimeImmutable($dateRangeForm->get('date_from')->getData());
   754|                     $dateTo        = new \DateTimeImmutable($dateRangeForm->get('date_to')->getData());
   755|                     $dateToPlusOne = $dateTo->modify('+1 day');
   756|                 }
   757|                 $leadCount = $this->getCampaignModel()->getRepository()->getCampaignLeadCount($entity->getId());
   758|                 $logCounts = $this->processCampaignLogCounts($entity->getId(), $dateFrom, $dateToPlusOne);
   759|                 $campaignLogCounts          = $logCounts['campaignLogCounts'] ?? [];
   760|                 $campaignLogCountsProcessed = $logCounts['campaignLogCountsProcessed'] ?? [];
   761|                 $this->processCampaignEvents($events, $leadCount, $campaignLogCounts, $campaignLogCountsProcessed);
   762|                 $sortedEvents = $this->processCampaignEventsFromParentCondition($events);
   763|                 $stats = $this->getCampaignModel()->getCampaignMetricsLineChartData(
   764|                     null,
   765|                     new \DateTime($dateRangeForm->get('date_from')->getData()),
   766|                     new \DateTime($dateRangeForm->get('date_to')->getData()),
   767|                     null,
   768|                     ['campaign_id' => $objectId]
   769|                 );
   770|                 $sourcesList = $this->getCampaignModel()->getSourceLists();
   771|                 $this->prepareCampaignSourcesForEdit($objectId, $sourcesList, true);
   772|                 $this->prepareCampaignEventsForEdit($entity, $objectId, true);
   773|                 $isEmailStatsEnabled = (bool) $this->coreParametersHelper->get('campaign_email_stats_enabled', true);
   774|                 $showEmailStats      = $isEmailStatsEnabled && $entity->isEmailCampaign();
   775|                 $args['viewParameters'] = array_merge(
   776|                     $args['viewParameters'],
   777|                     [
   778|                         'campaign'        => $entity,
   779|                         'stats'           => $stats,
   780|                         'events'          => $sortedEvents,
   781|                         'eventSettings'   => $this->eventCollector->getEventsArray(),
   782|                         'sources'         => $this->getCampaignModel()->getLeadSources($entity),
   783|                         'dateRangeForm'   => $dateRangeForm->createView(),
   784|                         'campaignSources' => $this->campaignSources,
   785|                         'campaignEvents'  => $events,
   786|                         'showEmailStats'  => $showEmailStats,
   787|                     ]
   788|                 );
   789|                 break;
   790|             case 'new':
   791|             case 'edit':
   792|                 $session                = $this->getCurrentRequest()->getSession();
   793|                 $args['viewParameters'] = array_merge(
   794|                     $args['viewParameters'],
   795|                     [
   796|                         'eventSettings'   => $this->eventCollector->getEventsArray(),
   797|                         'campaignEvents'  => $this->campaignEvents,
   798|                         'campaignSources' => $this->campaignSources,
   799|                         'deletedEvents'   => $this->deletedEvents,
   800|                         'hasEventClone'   => $session->has('mautic.campaign.events.clone.storage'),
   801|                     ]
   802|                 );
   803|                 break;
   804|         }
   805|         return $args;
   806|     }
   807|     /**
   808|      * @param bool $isClone
   809|      *
   810|      * @return array
   811|      */
   812|     protected function prepareCampaignEventsForEdit($entity, $objectId, $isClone = false)
   813|     {
   814|         $campaignEvents = [];
   815|         $existingEvents = $entity->getEvents()->toArray();
   816|         $translator     = $this->translator;
   817|         foreach ($existingEvents as $e) {
   818|             $event = $e->convertToArray();
   819|             if ($isClone) {
   820|                 $id          = $e->getTempId();
   821|                 $event['id'] = $id;
   822|             } else {
   823|                 $id = $e->getId();
   824|             }
   825|             unset($event['campaign']);
   826|             unset($event['children']);
   827|             unset($event['parent']);
   828|             unset($event['log']);
   829|             $label = false;
   830|             switch ($event['triggerMode']) {
   831|                 case 'interval':
   832|                     $label = $translator->trans(
   833|                         'mautic.campaign.connection.trigger.interval.label'.('no' == $event['decisionPath'] ? '_inaction' : ''),
   834|                         [
   835|                             '%number%' => $event['triggerInterval'],
   836|                             '%unit%'   => $translator->trans(
   837|                                 'mautic.campaign.event.intervalunit.'.$event['triggerIntervalUnit'],
   838|                                 ['%count%' => $event['triggerInterval']]
   839|                             ),
   840|                         ]
   841|                     );
   842|                     break;
   843|                 case 'date':
   844|                     $label = $translator->trans(
   845|                         'mautic.campaign.connection.trigger.date.label'.('no' == $event['decisionPath'] ? '_inaction' : ''),
   846|                         [
   847|                             '%full%' => $this->dateHelper->toFull($event['triggerDate']),
   848|                             '%time%' => $this->dateHelper->toTime($event['triggerDate']),
   849|                             '%date%' => $this->dateHelper->toShort($event['triggerDate']),
   850|                         ]
   851|                     );
   852|                     break;
   853|             }
   854|             if ($label) {
   855|                 $event['label'] = $label;
   856|             }
   857|             $campaignEvents[$id] = $event;
   858|         }
   859|         $this->modifiedEvents = $this->campaignEvents = $campaignEvents;
   860|         $this->getCurrentRequest()->getSession()->set('mautic.campaign.'.$objectId.'.events.modified', $campaignEvents);
   861|     }
   862|     protected function prepareCampaignSourcesForEdit($objectId, $campaignSources, $isPost = false)
   863|     {
   864|         $this->campaignSources = [];
   865|         if (is_array($campaignSources)) {
   866|             foreach ($campaignSources as $type => $sources) {
   867|                 if (!empty($sources)) {
   868|                     $campaignModel = $this->getModel('campaign');
   869|                     \assert($campaignModel instanceof CampaignModel);
   870|                     $sourceList                   = $campaignModel->getSourceLists($type);
   871|                     $this->campaignSources[$type] = [
   872|                         'sourceType' => $type,
   873|                         'campaignId' => $objectId,
   874|                         'names'      => implode(', ', array_intersect_key($sourceList, $sources)),
   875|                     ];
   876|                 }
   877|             }
   878|         }
   879|         if (!$isPost) {
   880|             $session = $this->getCurrentRequest()->getSession();
   881|             $session->set('mautic.campaign.'.$objectId.'.leadsources.current', $campaignSources);
   882|             $session->set('mautic.campaign.'.$objectId.'.leadsources.modified', $campaignSources);
   883|         }
   884|     }
   885|     protected function setSessionCanvasSettings($sessionId, $canvasSettings)
   886|     {
   887|         $this->getCurrentRequest()->getSession()->set('mautic.campaign.'.$sessionId.'.events.canvassettings', $canvasSettings);
   888|     }
   889|     protected function getSessionCanvasSettings($sessionId): mixed
   890|     {
   891|         return $this->getCurrentRequest()->getSession()->get('mautic.campaign.'.$sessionId.'.events.canvassettings');
   892|     }
   893|     /**
   894|      * @return array<string, array<int|string, array<int|string, int|string>>>
   895|      *
   896|      * @throws CacheException
   897|      */
   898|     private function processCampaignLogCounts(int $id, ?\DateTimeImmutable $dateFrom, ?\DateTimeImmutable $dateToPlusOne): array
   899|     {
   900|         if ($this->coreParametersHelper->get('campaign_use_summary')) {
   901|             /** @var SummaryRepository $summaryRepo */
   902|             $summaryRepo                = $this->doctrine->getManager()->getRepository(Summary::class);
   903|             $campaignLogCounts          = $summaryRepo->getCampaignLogCounts($id, $dateFrom, $dateToPlusOne);
   904|             $campaignLogCountsProcessed = $this->getCampaignLogCountsProcessed($campaignLogCounts);
   905|         } else {
   906|             /** @var LeadEventLogRepository $eventLogRepo */
   907|             $eventLogRepo               = $this->doctrine->getManager()->getRepository(LeadEventLog::class);
   908|             $campaignLogCounts          = $eventLogRepo->getCampaignLogCounts($id, false, false, true, $dateFrom, $dateToPlusOne);
   909|             $campaignLogCountsProcessed = $eventLogRepo->getCampaignLogCounts($id, false, false, false, $dateFrom, $dateToPlusOne);
   910|         }
   911|         return [
   912|             'campaignLogCounts'          => $campaignLogCounts,
   913|             'campaignLogCountsProcessed' => $campaignLogCountsProcessed,
   914|         ];
   915|     }
   916|     /**
   917|      * @param array<int, array<int|string, int|string>>        $events
   918|      * @param array<int|string, array<int|string, int|string>> $campaignLogCounts
   919|      * @param array<int|string, array<int|string, int|string>> $campaignLogCountsProcessed
   920|      */
   921|     private function processCampaignEvents(
   922|         array &$events,
   923|         int $leadCount,
   924|         array $campaignLogCounts,
   925|         array $campaignLogCountsProcessed,
   926|     ): void {
   927|         foreach ($events as &$event) {
   928|             $event['logCountForPending'] =
   929|             $event['logCountProcessed']  =
   930|             $event['percent']            =
   931|             $event['yesPercent']         =
   932|             $event['noPercent']          = 0;
   933|             if (isset($campaignLogCounts[$event['id']])) {
   934|                 $loggedCount                 = array_sum($campaignLogCounts[$event['id']]);
   935|                 $logCountsProcessed          = isset($campaignLogCountsProcessed[$event['id']]) ? array_sum($campaignLogCountsProcessed[$event['id']]) : 0;
   936|                 $pending                     = $loggedCount - $logCountsProcessed;
   937|                 $event['logCountForPending'] = $pending;
   938|                 $event['logCountProcessed']  = $logCountsProcessed;
   939|                 [$totalNo, $totalYes]        = $campaignLogCounts[$event['id']];
   940|                 $total                       = $totalYes + $totalNo;
   941|                 if ($leadCount) {
   942|                     $event['percent']    = min(100, max(0, round(($loggedCount / $total) * 100, 1)));
   943|                     $event['yesPercent'] = min(100, max(0, round(($totalYes / $total) * 100, 1)));
   944|                     $event['noPercent']  = min(100, max(0, round(($totalNo / $total) * 100, 1)));
   945|                 }
   946|             }
   947|         }
   948|     }
   949|     /**
   950|      * @param array<int, array<int|string, int|string>> $events
   951|      *
   952|      * @return array<string, array<int, array<int|string, int|string>>>
   953|      */
   954|     private function processCampaignEventsFromParentCondition(array &$events): array
   955|     {
   956|         $sortedEvents = [
   957|             'decision'  => [],
   958|             'action'    => [],
   959|             'condition' => [],
   960|         ];
   961|         foreach ($events as &$event) {
   962|             if (!empty($event['decisionPath'])
   963|                 && !empty($event['parent_id'])
   964|                 && isset($events[$event['parent_id']])
   965|                 && 'condition' !== $event['eventType']) {
   966|                 $parentEvent                 = $events[$event['parent_id']];
   967|                 $event['percent']            = $parentEvent['percent'];
   968|                 $event['yesPercent']         = $parentEvent['yesPercent'];
   969|                 $event['noPercent']          = $parentEvent['noPercent'];
   970|                 if ('yes' === $event['decisionPath']) {
   971|                     $event['noPercent'] = 0;
   972|                 } else {
   973|                     $event['yesPercent'] = 0;
   974|                 }
   975|             }
   976|             $sortedEvents[$event['eventType']][] = $event;
   977|         }
   978|         return $sortedEvents;
   979|     }
   980|     /**
   981|      * @param array<int, array<int, string>> $campaignLogCounts
   982|      *
   983|      * @return array<int, array<int, string>>
   984|      */
   985|     private function getCampaignLogCountsProcessed(array &$campaignLogCounts): array
   986|     {
   987|         $campaignLogCountsProcessed = [];
   988|         foreach ($campaignLogCounts as $eventId => $campaignLogCount) {
   989|             $campaignLogCountsProcessed[$eventId][] = $campaignLogCount[2];
   990|             unset($campaignLogCounts[$eventId][2]);
   991|         }
   992|         return $campaignLogCountsProcessed;
   993|     }
   994|     protected function getDefaultOrderDirection(): string
   995|     {
   996|         return 'DESC';
   997|     }
   998| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/CampaignMapStatsController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Controller;
     4| use Doctrine\DBAL\Exception;
     5| use Mautic\CampaignBundle\Entity\Campaign;
     6| use Mautic\CampaignBundle\Model\CampaignModel;
     7| use Mautic\CoreBundle\Helper\MapHelper;
     8| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     9| use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    10| use Symfony\Component\HttpFoundation\Response;
    11| use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
    12| class CampaignMapStatsController extends AbstractController
    13| {
    14|     public const MAP_OPTIONS = [
    15|         'contacts' => [
    16|             'label' => 'mautic.lead.leads',
    17|             'unit'  => 'Contact',
    18|         ],
    19|         'read_count' => [
    20|             'label' => 'mautic.email.read',
    21|             'unit'  => 'Read',
    22|         ],
    23|         'clicked_through_count'=> [
    24|             'label' => 'mautic.email.click',
    25|             'unit'  => 'Click',
    26|         ],
    27|     ];
    28|     public const LEGEND_TEXT = 'Total: %total (%withCountry with country)';
    29|     public function __construct(private CampaignModel $model)
    30|     {
    31|     }
    32|     /**
    33|      * @return array<string, array<int, array<string, int|string>>>
    34|      *
    35|      * @throws Exception
    36|      */
    37|     public function getData(Campaign $entity, \DateTimeImmutable $dateFromObject, \DateTimeImmutable $dateToObject): array
    38|     {
    39|         return $this->model->getCountryStats($entity, $dateFromObject, $dateToObject);
    40|     }
    41|     public function hasAccess(CorePermissions $security, Campaign $entity): bool
    42|     {
    43|         return $security->hasEntityAccess(
    44|             'email:emails:viewown',
    45|             'email:emails:viewother',
    46|             $entity->getCreatedBy()
    47|         );
    48|     }
    49|     /**
    50|      * @return array<string,array<string, string>>
    51|      */
    52|     public function getMapOptions(Campaign $entity): array
    53|     {
    54|         if ($entity->isEmailCampaign()) {
    55|             return self::MAP_OPTIONS;
    56|         }
    57|         $key = array_key_first(self::MAP_OPTIONS);
    58|         return [$key => self::MAP_OPTIONS[$key]];
    59|     }
    60|     public function getMapOptionsTitle(): string
    61|     {
    62|         return '';
    63|     }
    64|     /**
    65|      * @throws \Exception
    66|      */
    67|     public function viewAction(
    68|         CorePermissions $security,
    69|         int $objectId,
    70|         string $dateFrom = '',
    71|         string $dateTo = '',
    72|     ): Response {
    73|         $entity = $this->model->getEntity($objectId);
    74|         if (empty($entity) || !$this->hasAccess($security, $entity)) {
    75|             throw new AccessDeniedHttpException();
    76|         }
    77|         $statsCountries = $this->getData($entity, new \DateTimeImmutable($dateFrom), new \DateTimeImmutable($dateTo));
    78|         $mapData        = MapHelper::buildMapData($statsCountries, $this->getMapOptions($entity), self::LEGEND_TEXT);
    79|         return $this->render(
    80|             '@MauticCore/Helper/map.html.twig',
    81|             [
    82|                 'data'           => $mapData[0]['data'],
    83|                 'height'         => 315,
    84|                 'optionsEnabled' => true,
    85|                 'optionsTitle'   => $this->getMapOptionsTitle(),
    86|                 'options'        => $mapData,
    87|                 'legendEnabled'  => true,
    88|                 'statUnit'       => $mapData[0]['unit'],
    89|             ]
    90|         );
    91|     }
    92| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/CampaignMetricsController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Controller;
     4| use Mautic\CampaignBundle\Model\CampaignModel;
     5| use Mautic\CoreBundle\Helper\Chart\BarChart;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| use Mautic\CoreBundle\Helper\DateTimeHelper;
     8| use Mautic\CoreBundle\Translation\Translator;
     9| use Mautic\EmailBundle\Stats\EmailPeriodMetrics;
    10| use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    11| use Symfony\Component\HttpFoundation\Response;
    12| class CampaignMetricsController extends AbstractController
    13| {
    14|     public function __construct(
    15|         private Translator $translator,
    16|         private CoreParametersHelper $coreParametersHelper,
    17|     ) {
    18|     }
    19|     public function emailWeekdaysAction(
    20|         EmailPeriodMetrics $emailPeriodMetrics,
    21|         CampaignModel $model,
    22|         int $objectId,
    23|         string $dateFrom = '',
    24|         string $dateTo = '',
    25|     ): Response {
    26|         $entity               = $model->getEntity($objectId);
    27|         $eventsIds            = $entity->getEmailSendEvents()->getKeys();
    28|         $dateFromObject       = new \DateTimeImmutable($dateFrom);
    29|         $dateToObject         = new \DateTimeImmutable($dateTo);
    30|         $dateTimeHelper        = new DateTimeHelper();
    31|         $defaultTimezoneOffset = $dateTimeHelper->getLocalDateTime()->format('Z');
    32|         $stats                 = $emailPeriodMetrics->emailMetricsPerWeekdayByCampaignEvents($eventsIds, $dateFromObject, $dateToObject, $defaultTimezoneOffset);
    33|         $chart  = new BarChart([
    34|             $this->translator->trans('mautic.core.date.monday'),
    35|             $this->translator->trans('mautic.core.date.tuesday'),
    36|             $this->translator->trans('mautic.core.date.wednesday'),
    37|             $this->translator->trans('mautic.core.date.thursday'),
    38|             $this->translator->trans('mautic.core.date.friday'),
    39|             $this->translator->trans('mautic.core.date.saturday'),
    40|             $this->translator->trans('mautic.core.date.sunday'),
    41|         ]);
    42|         $chart->setDataset($this->translator->trans('mautic.email.sent'), array_column($stats, 'sent_count'));
    43|         $chart->setDataset($this->translator->trans('mautic.email.read'), array_column($stats, 'read_count'));
    44|         $chart->setDataset($this->translator->trans('mautic.email.click'), array_column($stats, 'hit_count'));
    45|         return $this->render(
    46|             '@MauticCore/Helper/chart.html.twig',
    47|             [
    48|                 'chartData'   => $chart->render(),
    49|                 'chartType'   => 'bar',
    50|                 'chartHeight' => 300,
    51|             ]
    52|         );
    53|     }
    54|     public function emailHoursAction(
    55|         EmailPeriodMetrics $emailPeriodMetrics,
    56|         CampaignModel $model,
    57|         int $objectId,
    58|         string $dateFrom = '',
    59|         string $dateTo = '',
    60|     ): Response {
    61|         $entity               = $model->getEntity($objectId);
    62|         $eventsIds            = $entity->getEmailSendEvents()->getKeys();
    63|         $dateFromObject       = new \DateTimeImmutable($dateFrom);
    64|         $dateToObject         = new \DateTimeImmutable($dateTo);
    65|         $dateTimeHelper        = new DateTimeHelper();
    66|         $defaultTimezoneOffset = $dateTimeHelper->getLocalDateTime()->format('Z');
    67|         $stats = $emailPeriodMetrics->emailMetricsPerHourByCampaignEvents($eventsIds, $dateFromObject, $dateToObject, $defaultTimezoneOffset);
    68|         $hoursRange = range(0, 23);
    69|         $labels     = [];
    70|         $timeFormat = $this->coreParametersHelper->get('date_format_timeonly');
    71|         foreach ($hoursRange as $hour) {
    72|             $startTime = (new \DateTime())->setTime($hour, 0);
    73|             $endTime   = (new \DateTime())->setTime(($hour + 1) % 24, 0);
    74|             $labels[] = $startTime->format($timeFormat).' - '.$endTime->format($timeFormat);
    75|         }
    76|         $chart  = new BarChart($labels);
    77|         $chart->setDataset($this->translator->trans('mautic.email.sent'), array_column($stats, 'sent_count'));
    78|         $chart->setDataset($this->translator->trans('mautic.email.read'), array_column($stats, 'read_count'));
    79|         $chart->setDataset($this->translator->trans('mautic.email.click'), array_column($stats, 'hit_count'));
    80|         return $this->render(
    81|             '@MauticCore/Helper/chart.html.twig',
    82|             [
    83|                 'chartData'   => $chart->render(),
    84|                 'chartType'   => 'hour',
    85|                 'chartHeight' => 300,
    86|             ]
    87|         );
    88|     }
    89| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Controller/EventController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-506 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\EventCollector\EventCollector;
     6| use Mautic\CampaignBundle\Form\Type\EventType;
     7| use Mautic\CampaignBundle\Model\CampaignModel;
     8| use Mautic\CoreBundle\Controller\FormController as CommonFormController;
     9| use Mautic\CoreBundle\Factory\ModelFactory;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Helper\DateTimeHelper;
    12| use Mautic\CoreBundle\Helper\UserHelper;
    13| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    14| use Mautic\CoreBundle\Service\FlashBag;
    15| use Mautic\CoreBundle\Translation\Translator;
    16| use Mautic\CoreBundle\Twig\Helper\DateHelper;
    17| use Mautic\FormBundle\Helper\FormFieldHelper;
    18| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    19| use Symfony\Component\Form\FormFactoryInterface;
    20| use Symfony\Component\HttpFoundation\JsonResponse;
    21| use Symfony\Component\HttpFoundation\Request;
    22| use Symfony\Component\HttpFoundation\RequestStack;
    23| class EventController extends CommonFormController
    24| {
    25|     /**
    26|      * @var string[]
    27|      */
    28|     private array $supportedEventTypes = [
    29|         Event::TYPE_DECISION,
    30|         Event::TYPE_ACTION,
    31|         Event::TYPE_CONDITION,
    32|     ];
    33|     public function __construct(
    34|         FormFactoryInterface $formFactory,
    35|         FormFieldHelper $fieldHelper,
    36|         private EventCollector $eventCollector,
    37|         private DateHelper $dateHelper,
    38|         ManagerRegistry $doctrine,
    39|         ModelFactory $modelFactory,
    40|         UserHelper $userHelper,
    41|         CoreParametersHelper $coreParametersHelper,
    42|         EventDispatcherInterface $dispatcher,
    43|         Translator $translator,
    44|         FlashBag $flashBag,
    45|         RequestStack $requestStack,
    46|         CorePermissions $security,
    47|         private CampaignModel $campaignModel,
    48|     ) {
    49|         parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    50|     }
    51|     /**
    52|      * Generates new form and processes post data.
    53|      *
    54|      * @return \Symfony\Component\HttpFoundation\RedirectResponse|\Symfony\Component\HttpFoundation\Response
    55|      */
    56|     public function newAction(Request $request)
    57|     {
    58|         $success = 0;
    59|         $valid   = $cancelled   = false;
    60|         $method  = $request->getMethod();
    61|         $session = $request->getSession();
    62|         if ('POST' === $method) {
    63|             $event                = $request->request->all()['campaignevent'] ?? [];
    64|             $type                 = $event['type'];
    65|             $eventType            = $event['eventType'];
    66|             $campaignId           = $event['campaignId'];
    67|             $event['triggerDate'] = (!empty($event['triggerDate'])) ? (new DateTimeHelper($event['triggerDate']))->getDateTime() : null;
    68|         } else {
    69|             $type       = $request->query->get('type');
    70|             $eventType  = $request->query->get('eventType');
    71|             $campaignId = $request->query->get('campaignId');
    72|             $anchorName = $request->query->get('anchor', '');
    73|             $event      = [
    74|                 'type'            => $type,
    75|                 'eventType'       => $eventType,
    76|                 'campaignId'      => $campaignId,
    77|                 'anchor'          => $anchorName,
    78|                 'anchorEventType' => $request->query->get('anchorEventType', ''),
    79|             ];
    80|         }
    81|         if (!in_array($eventType, $this->supportedEventTypes)) {
    82|             return $this->modalAccessDenied();
    83|         }
    84|         if (!$type
    85|             || !$request->isXmlHttpRequest()
    86|             || !$this->security->isGranted(
    87|                 [
    88|                     'campaign:campaigns:edit',
    89|                     'campaign:campaigns:create',
    90|                 ],
    91|                 'MATCH_ONE'
    92|             )
    93|         ) {
    94|             return $this->modalAccessDenied();
    95|         }
    96|         $events = $this->eventCollector->getEventsArray();
    97|         $form   = $this->formFactory->create(
    98|             EventType::class,
    99|             $event,
   100|             [
   101|                 'action'   => $this->generateUrl('mautic_campaignevent_action', ['objectAction' => 'new']),
   102|                 'settings' => $events[$eventType][$type],
   103|             ]
   104|         );
   105|         $event['settings'] = $events[$eventType][$type];
   106|         $form->get('campaignId')->setData($campaignId);
   107|         if ('POST' == $method) {
   108|             if (!$cancelled = $this->isFormCancelled($form)) {
   109|                 if ($valid = $this->isFormValid($form)) {
   110|                     $success = 1;
   111|                     $keyId = 'new'.hash('sha1', uniqid((string) mt_rand()));
   112|                     $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified');
   113|                     $formData       = $form->getData();
   114|                     $event          = array_merge($event, $formData);
   115|                     $event['id']    = $event['tempId']    = $keyId;
   116|                     if (empty($event['name'])) {
   117|                         $event['name'] = $this->translator->trans($event['settings']['label']);
   118|                     }
   119|                     $modifiedEvents[$keyId] = $event;
   120|                     $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
   121|                 } else {
   122|                     $success = 0;
   123|                 }
   124|             }
   125|         }
   126|         $viewParams = ['type' => $type];
   127|         if ($cancelled || $valid) {
   128|             $closeModal = true;
   129|         } else {
   130|             $closeModal = false;
   131|             if (isset($event['settings']['formTheme'])) {
   132|                 $viewParams['formTheme'] = $event['settings']['formTheme'];
   133|             }
   134|             $viewParams['form']             = $form->createView();
   135|             $viewParams['eventHeader']      = $this->translator->trans($event['settings']['label']);
   136|             $viewParams['eventDescription'] = (!empty($event['settings']['description'])) ? $this->translator->trans(
   137|                 $event['settings']['description']
   138|             ) : '';
   139|         }
   140|         $viewParams['hideTriggerMode'] = isset($event['settings']['hideTriggerMode']) && $event['settings']['hideTriggerMode'];
   141|         $passthroughVars = [
   142|             'mauticContent' => 'campaignEvent',
   143|             'success'       => $success,
   144|             'route'         => false,
   145|         ];
   146|         if (!empty($keyId)) {
   147|             $passthroughVars = array_merge($passthroughVars, $this->eventViewVars($event, $campaignId, 'new'));
   148|         }
   149|         if ($closeModal) {
   150|             $passthroughVars['closeModal'] = 1;
   151|             return new JsonResponse($passthroughVars);
   152|         } else {
   153|             return $this->ajaxAction(
   154|                 $request,
   155|                 [
   156|                     'contentTemplate' => '@MauticCampaign/Event/form.html.twig',
   157|                     'viewParameters'  => $viewParams,
   158|                     'passthroughVars' => $passthroughVars,
   159|                 ]
   160|             );
   161|         }
   162|     }
   163|     /**
   164|      * Generates edit form and processes post data.
   165|      *
   166|      * @return \Symfony\Component\HttpFoundation\RedirectResponse|\Symfony\Component\HttpFoundation\Response
   167|      */
   168|     public function editAction(Request $request, $objectId)
   169|     {
   170|         $session       = $request->getSession();
   171|         $valid         = $cancelled = false;
   172|         $method        = $request->getMethod();
   173|         $campaignEvent = $request->request->all()['campaignevent'] ?? [];
   174|         $campaignId    = 'POST' === $method
   175|             ? ($campaignEvent['campaignId'] ?? '')
   176|             : $request->query->get('campaignId');
   177|         $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
   178|         $event          = array_key_exists($objectId, $modifiedEvents) ? $modifiedEvents[$objectId] : [];
   179|         if ('POST' === $method) {
   180|             $event = array_merge($event, [
   181|                 'anchor'          => $campaignEvent['anchor'] ?? '',
   182|                 'anchorEventType' => $campaignEvent['anchorEventType'] ?? '',
   183|             ]);
   184|         } else {
   185|             if (!isset($event['anchor']) && !empty($event['decisionPath'])) {
   186|                 $event['anchor'] = $event['decisionPath'];
   187|             }
   188|             if ($request->query->has('anchor')) {
   189|                 $event['anchor'] = $request->get('anchor');
   190|             }
   191|             if ($request->query->has('anchorEventType')) {
   192|                 $event['anchorEventType'] = $request->get('anchorEventType');
   193|             }
   194|         }
   195|         /*
   196|          * If we don't have an event, don't support the event type, this is not an
   197|          * AJAX request, or we are not granted campaign edit/create, deny access.
   198|          */
   199|         if (empty($event)
   200|             || empty($event['eventType'])
   201|             || !in_array($event['eventType'], $this->supportedEventTypes)
   202|             || !isset($event['type'])
   203|             || !$request->isXmlHttpRequest()
   204|             || !$this->security->isGranted(
   205|                 [
   206|                     'campaign:campaigns:edit',
   207|                     'campaign:campaigns:create',
   208|                 ],
   209|                 'MATCH_ONE'
   210|             )
   211|         ) {
   212|             return $this->modalAccessDenied();
   213|         }
   214|         /**
   215|          * Fire the CampaignBuilderEvent event to get all events.
   216|          *
   217|          * We can directly dereference the return value here to get
   218|          * the supported events for this type because we already made
   219|          * sure that we're accessing a supported event type above.
   220|          *
   221|          * Method getEventsArray() returns translated labels & descriptions
   222|          */
   223|         $supportedEvents = $this->eventCollector->getEventsArray()[$event['eventType']];
   224|         $form            = $this->formFactory->create(
   225|             EventType::class,
   226|             $event,
   227|             [
   228|                 'action'   => $this->generateUrl('mautic_campaignevent_action', ['objectAction' => 'edit', 'objectId' => $objectId]),
   229|                 'settings' => $supportedEvents[$event['type']],
   230|             ]
   231|         );
   232|         $event['settings'] = $supportedEvents[$event['type']];
   233|         $form->get('campaignId')->setData($campaignId);
   234|         if ('POST' === $method) {
   235|             if (!$cancelled = $this->isFormCancelled($form)) {
   236|                 if ($valid = $this->isFormValid($form)) {
   237|                     $formData = $form->getData();
   238|                     $event    = array_merge($event, $formData);
   239|                     if (empty($event['name'])) {
   240|                         $event['name'] = $event['settings']['label'];
   241|                     }
   242|                     $modifiedEvents[$objectId] = $event;
   243|                     $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
   244|                 }
   245|             }
   246|         }
   247|         $viewParams = [
   248|             'type'            => $event['type'],
   249|             'hideTriggerMode' => isset($event['settings']['hideTriggerMode']) && $event['settings']['hideTriggerMode'],
   250|         ];
   251|         $passthroughVars = [
   252|             'mauticContent' => 'campaignEvent',
   253|             'success'       => !$cancelled && $valid,
   254|             'route'         => false,
   255|         ];
   256|         if (!$cancelled && !$valid) {
   257|             if (isset($event['settings']['formTheme'])) {
   258|                 $viewParams['formTheme'] = $event['settings']['formTheme'];
   259|             }
   260|             $viewParams = array_merge($viewParams, [
   261|                 'form'             => $form->createView(),
   262|                 'eventHeader'      => $event['settings']['label'],
   263|                 'eventDescription' => $event['settings']['description'],
   264|             ]);
   265|             return $this->ajaxAction(
   266|                 $request,
   267|                 [
   268|                     'contentTemplate' => '@MauticCampaign/Event/form.html.twig',
   269|                     'viewParameters'  => $viewParams,
   270|                     'passthroughVars' => $passthroughVars,
   271|                 ]
   272|             );
   273|         }
   274|         if (!$cancelled && $valid) {
   275|             $passthroughVars = array_merge($passthroughVars, $this->eventViewVars($event, $campaignId, 'edit'));
   276|         }
   277|         $passthroughVars['closeModal'] = 1;
   278|         return new JsonResponse($passthroughVars);
   279|     }
   280|     /**
   281|      * Deletes the entity.
   282|      *
   283|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
   284|      */
   285|     public function deleteAction(Request $request, $objectId)
   286|     {
   287|         $campaignId     = $request->query->get('campaignId');
   288|         $session        = $request->getSession();
   289|         $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
   290|         $deletedEvents  = $session->get('mautic.campaign.'.$campaignId.'.events.deleted', []);
   291|         if (!$request->isXmlHttpRequest()
   292|             || !$this->security->isGranted(
   293|                 [
   294|                     'campaign:campaigns:edit',
   295|                     'campaign:campaigns:create',
   296|                 ],
   297|                 'MATCH_ONE'
   298|             )
   299|         ) {
   300|             return $this->accessDenied();
   301|         }
   302|         $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
   303|         if ('POST' == $request->getMethod() && null !== $event) {
   304|             $events            = $this->eventCollector->getEventsArray();
   305|             $event['settings'] = $events[$event['eventType']][$event['type']];
   306|             if (!in_array($objectId, $deletedEvents)) {
   307|                 if (!str_contains($objectId, 'new')) {
   308|                     $deletedEvents[] = $objectId;
   309|                     $session->set('mautic.campaign.'.$campaignId.'.events.deleted', $deletedEvents);
   310|                 }
   311|                 if (isset($modifiedEvents[$objectId])) {
   312|                     unset($modifiedEvents[$objectId]);
   313|                     $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
   314|                 }
   315|             }
   316|             $dataArray = [
   317|                 'mauticContent' => 'campaignEvent',
   318|                 'success'       => 1,
   319|                 'route'         => false,
   320|                 'eventId'       => $objectId,
   321|                 'deleted'       => 1,
   322|                 'event'         => $event,
   323|             ];
   324|         } else {
   325|             $dataArray = ['success' => 0];
   326|         }
   327|         return new JsonResponse($dataArray);
   328|     }
   329|     /**
   330|      * Undeletes the entity.
   331|      *
   332|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
   333|      */
   334|     public function undeleteAction(Request $request, $objectId)
   335|     {
   336|         $campaignId     = $request->query->get('campaignId');
   337|         $session        = $request->getSession();
   338|         $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
   339|         $deletedEvents  = $session->get('mautic.campaign.'.$campaignId.'.events.deleted', []);
   340|         if (!$request->isXmlHttpRequest()
   341|             || !$this->security->isGranted(
   342|                 [
   343|                     'campaign:campaigns:edit',
   344|                     'campaign:campaigns:create',
   345|                 ],
   346|                 'MATCH_ONE'
   347|             )
   348|         ) {
   349|             return $this->accessDenied();
   350|         }
   351|         $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
   352|         if ('POST' == $request->getMethod() && null !== $event) {
   353|             $events            = $this->eventCollector->getEventsArray();
   354|             $event['settings'] = $events[$event['eventType']][$event['type']];
   355|             if (in_array($objectId, $deletedEvents)) {
   356|                 $key = array_search($objectId, $deletedEvents);
   357|                 unset($deletedEvents[$key]);
   358|                 $session->set('mautic.campaign.'.$campaignId.'.events.deleted', $deletedEvents);
   359|             }
   360|             $template = (empty($event['settings']['template'])) ? '@MauticCampaign/Event/_generic.html.twig'
   361|                 : $event['settings']['template'];
   362|             $entity = new Event();
   363|             $blank  = $entity->convertToArray();
   364|             $event  = array_merge($blank, $event);
   365|             $dataArray = [
   366|                 'mauticContent' => 'campaignEvent',
   367|                 'success'       => 1,
   368|                 'route'         => false,
   369|                 'eventId'       => $objectId,
   370|                 'eventHtml'     => $this->renderView(
   371|                     $template,
   372|                     [
   373|                         'event'      => $event,
   374|                         'id'         => $objectId,
   375|                         'campaignId' => $campaignId,
   376|                     ]
   377|                 ),
   378|             ];
   379|         } else {
   380|             $dataArray = ['success' => 0];
   381|         }
   382|         return new JsonResponse($dataArray);
   383|     }
   384|     public function cloneAction(Request $request, string $objectId): JsonResponse
   385|     {
   386|         $campaignId     = $request->query->get('campaignId');
   387|         $session        = $request->getSession();
   388|         $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
   389|         $campaign       = $this->campaignModel->getEntity($campaignId);
   390|         if (!$request->isXmlHttpRequest()
   391|             || !$this->security->isGranted(
   392|                 [
   393|                     'campaign:campaigns:edit',
   394|                     'campaign:campaigns:create',
   395|                 ],
   396|                 'MATCH_ONE'
   397|             )
   398|         ) {
   399|             return $this->accessDenied();
   400|         }
   401|         $event = (array_key_exists($objectId, $modifiedEvents)) ? $modifiedEvents[$objectId] : null;
   402|         if ('POST' == $request->getMethod() && null !== $event) {
   403|             $keyId          = 'new'.hash('sha1', uniqid((string) mt_rand()));
   404|             $event['id']    = $event['tempId']    = $keyId;
   405|             $session->set('mautic.campaign.events.clone.storage', $event);
   406|             $dataArray = [
   407|                 'success'       => 1,
   408|                 'mauticContent' => 'campaignEventClone',
   409|                 'route'         => false,
   410|                 'eventId'       => $objectId,
   411|                 'eventName'     => $event['name'],
   412|                 'eventType'     => $event['eventType'],
   413|                 'type'          => $event['type'],
   414|                 'campaignId'    => $campaign ? $campaign->getId() : $campaignId,
   415|                 'campaignName'  => $campaign ? $campaign->getName() : $this->translator->trans('mautic.campaign.event.clone.new.campaign'),
   416|             ];
   417|         } else {
   418|             $dataArray = ['success' => 0];
   419|         }
   420|         return new JsonResponse($dataArray);
   421|     }
   422|     public function insertAction(Request $request): JsonResponse
   423|     {
   424|         $campaignId     = $request->query->get('campaignId');
   425|         $session        = $request->getSession();
   426|         $modifiedEvents = $session->get('mautic.campaign.'.$campaignId.'.events.modified', []);
   427|         $event          = $session->get('mautic.campaign.events.clone.storage');
   428|         if (empty($event)) {
   429|             return new JsonResponse([
   430|                 'error' => $this->translator->trans('mautic.campaign.event.clone.request.missing'),
   431|             ], 400);
   432|         }
   433|         $session->remove('mautic.campaign.events.clone.storage');
   434|         $keyId          = 'new'.hash('sha1', uniqid((string) mt_rand()));
   435|         $event['id']    = $event['tempId'] = $keyId;
   436|         $modifiedEvents[$keyId] = $event;
   437|         $session->set('mautic.campaign.'.$campaignId.'.events.modified', $modifiedEvents);
   438|         $passThroughVars               = [
   439|             'mauticContent'     => 'campaignEvent',
   440|             'clearCloneStorage' => true,
   441|             'success'           => 1,
   442|             'route'             => false,
   443|         ];
   444|         $passThroughVars = array_merge($passThroughVars, $this->eventViewVars($event, $campaignId, 'insert'));
   445|         return new JsonResponse($passThroughVars);
   446|     }
   447|     /**
   448|      * @param array<string, mixed> $event
   449|      *
   450|      * @return array<string, mixed>
   451|      */
   452|     private function eventViewVars(
   453|         array $event,
   454|         string $campaignId,
   455|         string $action,
   456|     ): array {
   457|         $event = array_merge((new Event())->convertToArray(), $event);
   458|         $template = $event['settings']['template'] ?? '@MauticCampaign/Event/_generic.html.twig';
   459|         $templateVars = [
   460|             'event'      => $event,
   461|             'id'         => $event['id'],
   462|             'campaignId' => $campaignId,
   463|         ];
   464|         if ('edit' === $action) {
   465|             $templateVars['update']        = true;
   466|         }
   467|         $passThroughKey                   = ('edit' === $action) ? 'updateHtml' : 'eventHtml';
   468|         $passThroughVars[$passThroughKey] = $this->renderView($template, $templateVars);
   469|         $passThroughVars += [
   470|             'event'     => $event,
   471|             'eventId'   => $event['id'],
   472|             'eventType' => $event['eventType'],
   473|         ];
   474|         if (Event::TRIGGER_MODE_INTERVAL === $event['triggerMode']) {
   475|             $label = 'mautic.campaign.connection.trigger.interval.label';
   476|             if (Event::PATH_INACTION === $event['anchor']) {
   477|                 $label .= '_inaction';
   478|             }
   479|             $passThroughVars['label'] = $this->translator->trans(
   480|                 $label,
   481|                 [
   482|                     '%number%' => $event['triggerInterval'],
   483|                     '%unit%'   => $this->translator->trans(
   484|                         'mautic.campaign.event.intervalunit.'.$event['triggerIntervalUnit'],
   485|                         ['%count%' => $event['triggerInterval']]
   486|                     ),
   487|                 ]
   488|             );
   489|         }
   490|         if (Event::TRIGGER_MODE_DATE === $event['triggerMode']) {
   491|             $label = 'mautic.campaign.connection.trigger.date.label';
   492|             if (Event::PATH_INACTION === $event['anchor']) {
   493|                 $label .= '_inaction';
   494|             }
   495|             $passThroughVars['label'] = $this->translator->trans(
   496|                 $label,
   497|                 [
   498|                     '%full%' => $this->dateHelper->toFull($event['triggerDate']),
   499|                     '%time%' => $this->dateHelper->toTime($event['triggerDate']),
   500|                     '%date%' => $this->dateHelper->toShort($event['triggerDate']),
   501|                 ]
   502|             );
   503|         }
   504|         return $passThroughVars;
   505|     }
   506| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Entity/Campaign.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-594 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Entity;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\Common\Collections\Criteria;
     5| use Doctrine\Common\Collections\Order;
     6| use Doctrine\ORM\Mapping as ORM;
     7| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     8| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     9| use Mautic\CoreBundle\Entity\FormEntity;
    10| use Mautic\CoreBundle\Entity\OptimisticLockInterface;
    11| use Mautic\CoreBundle\Entity\OptimisticLockTrait;
    12| use Mautic\CoreBundle\Entity\PublishStatusIconAttributesInterface;
    13| use Mautic\CoreBundle\Entity\UuidInterface;
    14| use Mautic\CoreBundle\Entity\UuidTrait;
    15| use Mautic\FormBundle\Entity\Form;
    16| use Mautic\LeadBundle\Entity\Lead as Contact;
    17| use Mautic\LeadBundle\Entity\LeadList;
    18| use Symfony\Component\Validator\Constraints as Assert;
    19| use Symfony\Component\Validator\Mapping\ClassMetadata;
    20| /**
    21|  * @ApiResource(
    22|  *   attributes={
    23|  *     "security"="false",
    24|  *     "normalization_context"={
    25|  *       "groups"={
    26|  *         "campaign:read"
    27|  *        },
    28|  *       "swagger_definition_name"="Read",
    29|  *       "api_included"={"category", "events", "lists", "forms", "fields", "actions"}
    30|  *     },
    31|  *     "denormalization_context"={
    32|  *       "groups"={
    33|  *         "campaign:write"
    34|  *       },
    35|  *       "swagger_definition_name"="Write"
    36|  *     }
    37|  *   }
    38|  * )
    39|  */
    40| class Campaign extends FormEntity implements PublishStatusIconAttributesInterface, OptimisticLockInterface, UuidInterface
    41| {
    42|     use UuidTrait;
    43|     use OptimisticLockTrait;
    44|     public const TABLE_NAME = 'campaigns';
    45|     /**
    46|      * @var int
    47|      */
    48|     private $id;
    49|     /**
    50|      * @var string
    51|      */
    52|     private $name;
    53|     /**
    54|      * @var string|null
    55|      */
    56|     private $description;
    57|     /**
    58|      * @var \DateTimeInterface|null
    59|      */
    60|     private $publishUp;
    61|     /**
    62|      * @var \DateTimeInterface|null
    63|      */
    64|     private $publishDown;
    65|     public ?\DateTimeInterface $deleted = null;
    66|     /**
    67|      * @var \Mautic\CategoryBundle\Entity\Category|null
    68|      **/
    69|     private $category;
    70|     /**
    71|      * @var ArrayCollection<int, Event>
    72|      */
    73|     private $events;
    74|     /**
    75|      * @var ArrayCollection<int, Lead>
    76|      */
    77|     private $leads;
    78|     /**
    79|      * @var ArrayCollection<int, LeadList>
    80|      */
    81|     private $lists;
    82|     /**
    83|      * @var ArrayCollection<int, Form>
    84|      */
    85|     private $forms;
    86|     /**
    87|      * @var array
    88|      */
    89|     private $canvasSettings = [];
    90|     private bool $allowRestart = false;
    91|     public function __construct()
    92|     {
    93|         $this->events = new ArrayCollection();
    94|         $this->leads  = new ArrayCollection();
    95|         $this->lists  = new ArrayCollection();
    96|         $this->forms  = new ArrayCollection();
    97|     }
    98|     public function __clone()
    99|     {
   100|         $this->leads  = new ArrayCollection();
   101|         $this->events = new ArrayCollection();
   102|         $this->lists  = new ArrayCollection();
   103|         $this->forms  = new ArrayCollection();
   104|         $this->id     = null;
   105|         parent::__clone();
   106|     }
   107|     public static function loadMetadata(ORM\ClassMetadata $metadata): void
   108|     {
   109|         $builder = new ClassMetadataBuilder($metadata);
   110|         $builder->setTable(self::TABLE_NAME)
   111|             ->setCustomRepositoryClass(CampaignRepository::class);
   112|         $builder->addIdColumns();
   113|         $builder->addPublishDates();
   114|         $builder->addCategory();
   115|         $builder->createOneToMany('events', Event::class)
   116|             ->setIndexBy('id')
   117|             ->setOrderBy(['order' => 'ASC'])
   118|             ->mappedBy('campaign')
   119|             ->cascadeAll()
   120|             ->fetchExtraLazy()
   121|             ->build();
   122|         $builder->createOneToMany('leads', Lead::class)
   123|             ->mappedBy('campaign')
   124|             ->fetchExtraLazy()
   125|             ->build();
   126|         $builder->createManyToMany('lists', LeadList::class)
   127|             ->setJoinTable('campaign_leadlist_xref')
   128|             ->setIndexBy('id')
   129|             ->addInverseJoinColumn('leadlist_id', 'id', false, false, 'CASCADE')
   130|             ->addJoinColumn('campaign_id', 'id', true, false, 'CASCADE')
   131|             ->build();
   132|         $builder->createManyToMany('forms', Form::class)
   133|             ->setJoinTable('campaign_form_xref')
   134|             ->setIndexBy('id')
   135|             ->addInverseJoinColumn('form_id', 'id', false, false, 'CASCADE')
   136|             ->addJoinColumn('campaign_id', 'id', true, false, 'CASCADE')
   137|             ->build();
   138|         $builder->createField('canvasSettings', 'array')
   139|             ->columnName('canvas_settings')
   140|             ->nullable()
   141|             ->build();
   142|         $builder->addNamedField('allowRestart', 'boolean', 'allow_restart');
   143|         $builder->addNullableField('deleted', 'datetime');
   144|         self::addVersionField($builder);
   145|         static::addUuidField($builder);
   146|     }
   147|     public static function loadValidatorMetadata(ClassMetadata $metadata): void
   148|     {
   149|         $metadata->addPropertyConstraint(
   150|             'name',
   151|             new Assert\NotBlank(
   152|                 [
   153|                     'message' => 'mautic.core.name.required',
   154|                 ]
   155|             )
   156|         );
   157|     }
   158|     /**
   159|      * Prepares the metadata for API usage.
   160|      */
   161|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
   162|     {
   163|         $metadata->setGroupPrefix('campaign')
   164|             ->addListProperties(
   165|                 [
   166|                     'id',
   167|                     'name',
   168|                     'category',
   169|                     'description',
   170|                 ]
   171|             )
   172|             ->addProperties(
   173|                 [
   174|                     'allowRestart',
   175|                     'publishUp',
   176|                     'publishDown',
   177|                     'events',
   178|                     'forms',
   179|                     'lists', // @deprecated, will be renamed to 'segments' in 3.0.0
   180|                     'canvasSettings',
   181|                 ]
   182|             )
   183|             ->setGroupPrefix('campaignBasic')
   184|             ->addListProperties(
   185|                 [
   186|                     'id',
   187|                     'name',
   188|                     'description',
   189|                     'allowRestart',
   190|                     'events',
   191|                     'publishUp',
   192|                     'publishDown',
   193|                     'deleted',
   194|                 ]
   195|             )
   196|             ->build();
   197|     }
   198|     public function convertToArray(): array
   199|     {
   200|         return get_object_vars($this);
   201|     }
   202|     /**
   203|      * @param string $prop
   204|      * @param mixed  $val
   205|      */
   206|     protected function isChanged($prop, $val)
   207|     {
   208|         $getter  = 'get'.ucfirst($prop);
   209|         $current = $this->$getter();
   210|         if ('category' == $prop) {
   211|             $currentId = ($current) ? $current->getId() : '';
   212|             $newId     = ($val) ? $val->getId() : null;
   213|             if ($currentId != $newId) {
   214|                 $this->changes[$prop] = [$currentId, $newId];
   215|             }
   216|         } else {
   217|             parent::isChanged($prop, $val);
   218|         }
   219|     }
   220|     /**
   221|      * @return int
   222|      */
   223|     public function getId()
   224|     {
   225|         return $this->id;
   226|     }
   227|     /**
   228|      * Set description.
   229|      *
   230|      * @param string $description
   231|      *
   232|      * @return Campaign
   233|      */
   234|     public function setDescription($description)
   235|     {
   236|         $this->isChanged('description', $description);
   237|         $this->description = $description;
   238|         return $this;
   239|     }
   240|     /**
   241|      * Get description.
   242|      *
   243|      * @return string
   244|      */
   245|     public function getDescription()
   246|     {
   247|         return $this->description;
   248|     }
   249|     /**
   250|      * Set name.
   251|      *
   252|      * @param string $name
   253|      *
   254|      * @return Campaign
   255|      */
   256|     public function setName($name)
   257|     {
   258|         $this->isChanged('name', $name);
   259|         $this->name = $name;
   260|         return $this;
   261|     }
   262|     /**
   263|      * Get name.
   264|      *
   265|      * @return string
   266|      */
   267|     public function getName()
   268|     {
   269|         return $this->name;
   270|     }
   271|     /**
   272|      * Calls $this->addEvent on every item in the collection.
   273|      *
   274|      * @return Campaign
   275|      */
   276|     public function addEvents(array $events)
   277|     {
   278|         foreach ($events as $id => $event) {
   279|             $this->addEvent($id, $event);
   280|         }
   281|         return $this;
   282|     }
   283|     /**
   284|      * Add events.
   285|      *
   286|      * @return Campaign
   287|      */
   288|     public function addEvent($key, Event $event)
   289|     {
   290|         if ($changes = $event->getChanges()) {
   291|             $this->changes['events']['added'][$key] = [$key, $changes];
   292|         }
   293|         $this->events[$key] = $event;
   294|         return $this;
   295|     }
   296|     /**
   297|      * Remove events.
   298|      */
   299|     public function removeEvent(Event $event): void
   300|     {
   301|         $this->changes['events']['removed'][$event->getId()] = $event->getName();
   302|         $this->events->removeElement($event);
   303|     }
   304|     /**
   305|      * Get events.
   306|      *
   307|      * @return ArrayCollection
   308|      */
   309|     public function getEvents()
   310|     {
   311|         return $this->events;
   312|     }
   313|     public function getRootEvents(): ArrayCollection
   314|     {
   315|         $criteria = Criteria::create()->where(
   316|             Criteria::expr()->andX(
   317|                 Criteria::expr()->isNull('parent'),
   318|                 Criteria::expr()->isNull('deleted')
   319|             )
   320|         );
   321|         $events   = $this->getEvents()->matching($criteria);
   322|         $keyedArrayCollection = new ArrayCollection();
   323|         /** @var Event $event */
   324|         foreach ($events as $event) {
   325|             $keyedArrayCollection->set($event->getId(), $event);
   326|         }
   327|         unset($events);
   328|         return $keyedArrayCollection;
   329|     }
   330|     public function getInactionBasedEvents(): ArrayCollection
   331|     {
   332|         $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', Event::PATH_INACTION));
   333|         $events   = $this->getEvents()->matching($criteria);
   334|         $keyedArrayCollection = new ArrayCollection();
   335|         /** @var Event $event */
   336|         foreach ($events as $event) {
   337|             $keyedArrayCollection->set($event->getId(), $event);
   338|         }
   339|         unset($events);
   340|         return $keyedArrayCollection;
   341|     }
   342|     /**
   343|      * @param string $type
   344|      *
   345|      * @return ArrayCollection<int,Event>
   346|      */
   347|     public function getEventsByType($type): ArrayCollection
   348|     {
   349|         $criteria = Criteria::create()->where(Criteria::expr()->eq('eventType', $type));
   350|         $events   = $this->getEvents()->matching($criteria);
   351|         $keyedArrayCollection = new ArrayCollection();
   352|         /** @var Event $event */
   353|         foreach ($events as $event) {
   354|             $keyedArrayCollection->set($event->getId(), $event);
   355|         }
   356|         unset($events);
   357|         return $keyedArrayCollection;
   358|     }
   359|     /**
   360|      * @return ArrayCollection<int, Event>
   361|      */
   362|     public function getEmailSendEvents(): ArrayCollection
   363|     {
   364|         $criteria = Criteria::create()->where(Criteria::expr()->eq('type', 'email.send'));
   365|         $events   = $this->getEvents()->matching($criteria);
   366|         $keyedArrayCollection = new ArrayCollection();
   367|         /** @var Event $event */
   368|         foreach ($events as $event) {
   369|             $keyedArrayCollection->set($event->getId(), $event);
   370|         }
   371|         return $keyedArrayCollection;
   372|     }
   373|     public function isEmailCampaign(): bool
   374|     {
   375|         $criteria     = Criteria::create()->where(Criteria::expr()->eq('type', 'email.send'))->setMaxResults(1);
   376|         $emailEvent   = $this->getEvents()->matching($criteria);
   377|         return !$emailEvent->isEmpty();
   378|     }
   379|     /**
   380|      * Set publishUp.
   381|      *
   382|      * @param ?\DateTime $publishUp
   383|      *
   384|      * @return Campaign
   385|      */
   386|     public function setPublishUp($publishUp)
   387|     {
   388|         $this->isChanged('publishUp', $publishUp);
   389|         $this->publishUp = $publishUp;
   390|         return $this;
   391|     }
   392|     /**
   393|      * Get publishUp.
   394|      *
   395|      * @return \DateTimeInterface
   396|      */
   397|     public function getPublishUp()
   398|     {
   399|         return $this->publishUp;
   400|     }
   401|     /**
   402|      * Set publishDown.
   403|      *
   404|      * @param ?\DateTime $publishDown
   405|      *
   406|      * @return Campaign
   407|      */
   408|     public function setPublishDown($publishDown)
   409|     {
   410|         $this->isChanged('publishDown', $publishDown);
   411|         $this->publishDown = $publishDown;
   412|         return $this;
   413|     }
   414|     /**
   415|      * Get publishDown.
   416|      *
   417|      * @return \DateTimeInterface
   418|      */
   419|     public function getPublishDown()
   420|     {
   421|         return $this->publishDown;
   422|     }
   423|     /**
   424|      * @return mixed
   425|      */
   426|     public function getCategory()
   427|     {
   428|         return $this->category;
   429|     }
   430|     /**
   431|      * @param mixed $category
   432|      */
   433|     public function setCategory($category): void
   434|     {
   435|         $this->isChanged('category', $category);
   436|         $this->category = $category;
   437|     }
   438|     /**
   439|      * Add lead.
   440|      *
   441|      * @return Campaign
   442|      */
   443|     public function addLead($key, Lead $lead)
   444|     {
   445|         $action     = ($this->leads->contains($lead)) ? 'updated' : 'added';
   446|         $leadEntity = $lead->getLead();
   447|         $this->changes['leads'][$action][$leadEntity->getId()] = $leadEntity->getPrimaryIdentifier();
   448|         $this->leads[$key]                                     = $lead;
   449|         return $this;
   450|     }
   451|     /**
   452|      * Remove lead.
   453|      */
   454|     public function removeLead(Lead $lead): void
   455|     {
   456|         $leadEntity                                              = $lead->getLead();
   457|         $this->changes['leads']['removed'][$leadEntity->getId()] = $leadEntity->getPrimaryIdentifier();
   458|         $this->leads->removeElement($lead);
   459|     }
   460|     /**
   461|      * Get leads.
   462|      *
   463|      * @return Lead[]|\Doctrine\Common\Collections\Collection
   464|      */
   465|     public function getLeads()
   466|     {
   467|         return $this->leads;
   468|     }
   469|     /**
   470|      * @return ArrayCollection
   471|      */
   472|     public function getLists()
   473|     {
   474|         return $this->lists;
   475|     }
   476|     /**
   477|      * Add list.
   478|      *
   479|      * @return Campaign
   480|      */
   481|     public function addList(LeadList $list)
   482|     {
   483|         $this->lists[$list->getId()] = $list;
   484|         $this->changes['lists']['added'][$list->getId()] = $list->getName();
   485|         return $this;
   486|     }
   487|     /**
   488|      * Remove list.
   489|      */
   490|     public function removeList(LeadList $list): void
   491|     {
   492|         $this->changes['lists']['removed'][$list->getId()] = $list->getName();
   493|         $this->lists->removeElement($list);
   494|     }
   495|     /**
   496|      * @return ArrayCollection
   497|      */
   498|     public function getForms()
   499|     {
   500|         return $this->forms;
   501|     }
   502|     /**
   503|      * Add form.
   504|      *
   505|      * @return Campaign
   506|      */
   507|     public function addForm(Form $form)
   508|     {
   509|         $this->forms[$form->getId()] = $form;
   510|         $this->changes['forms']['added'][$form->getId()] = $form->getName();
   511|         return $this;
   512|     }
   513|     /**
   514|      * Remove form.
   515|      */
   516|     public function removeForm(Form $form): void
   517|     {
   518|         $this->changes['forms']['removed'][$form->getId()] = $form->getName();
   519|         $this->forms->removeElement($form);
   520|     }
   521|     /**
   522|      * @return mixed
   523|      */
   524|     public function getCanvasSettings()
   525|     {
   526|         return $this->canvasSettings;
   527|     }
   528|     public function setCanvasSettings(array $canvasSettings): void
   529|     {
   530|         $this->canvasSettings = $canvasSettings;
   531|     }
   532|     public function getAllowRestart(): bool
   533|     {
   534|         return (bool) $this->allowRestart;
   535|     }
   536|     public function allowRestart(): bool
   537|     {
   538|         return $this->getAllowRestart();
   539|     }
   540|     /**
   541|      * @param bool $allowRestart
   542|      *
   543|      * @return Campaign
   544|      */
   545|     public function setAllowRestart($allowRestart)
   546|     {
   547|         $allowRestart = (bool) $allowRestart;
   548|         $this->isChanged('allowRestart', $allowRestart);
   549|         $this->allowRestart = $allowRestart;
   550|         return $this;
   551|     }
   552|     public function setDeleted(?\DateTimeInterface $deleted): void
   553|     {
   554|         $this->isChanged('deleted', $deleted);
   555|         $this->deleted = $deleted;
   556|     }
   557|     public function isDeleted(): bool
   558|     {
   559|         return !is_null($this->deleted);
   560|     }
   561|     /**
   562|      * Get contact membership.
   563|      *
   564|      * @return \Doctrine\Common\Collections\Collection
   565|      */
   566|     public function getContactMembership(Contact $contact)
   567|     {
   568|         return $this->leads->matching(
   569|             Criteria::create()
   570|                 ->where(Criteria::expr()->eq('lead', $contact))
   571|                 ->orderBy(['dateAdded' => Order::Descending->value])
   572|         );
   573|     }
   574|     public function getOnclickMethod(): string
   575|     {
   576|         return 'Mautic.confirmationCampaignPublishStatus(mQuery(this));';
   577|     }
   578|     public function getDataAttributes(): array
   579|     {
   580|         return [
   581|             'data-toggle'           => 'confirmation',
   582|             'data-confirm-callback' => 'confirmCallbackCampaignPublishStatus',
   583|             'data-cancel-callback'  => 'dismissConfirmation',
   584|         ];
   585|     }
   586|     public function getTranslationKeysDataAttributes(): array
   587|     {
   588|         return [
   589|             'data-message'      => 'mautic.campaign.form.confirmation.message',
   590|             'data-confirm-text' => 'mautic.campaign.form.confirmation.confirm_text',
   591|             'data-cancel-text'  => 'mautic.campaign.form.confirmation.cancel_text',
   592|         ];
   593|     }
   594| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Entity/Event.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-938 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Entity;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\Common\Collections\Collection;
     5| use Doctrine\Common\Collections\Criteria;
     6| use Doctrine\ORM\Mapping as ORM;
     7| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     8| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     9| use Mautic\CoreBundle\Entity\UuidInterface;
    10| use Mautic\CoreBundle\Entity\UuidTrait;
    11| use Mautic\CoreBundle\Validator\EntityEvent;
    12| use Mautic\LeadBundle\Entity\Lead as Contact;
    13| use Symfony\Component\Validator\Mapping\ClassMetadata;
    14| /**
    15|  * @ApiResource(
    16|  *   attributes={
    17|  *     "security"="false",
    18|  *     "normalization_context"={
    19|  *       "groups"={
    20|  *         "event:read"
    21|  *        },
    22|  *       "swagger_definition_name"="Read"
    23|  *     },
    24|  *     "denormalization_context"={
    25|  *       "groups"={
    26|  *         "event:write"
    27|  *       },
    28|  *       "swagger_definition_name"="Write"
    29|  *     }
    30|  *   }
    31|  * )
    32|  */
    33| class Event implements ChannelInterface, UuidInterface
    34| {
    35|     use UuidTrait;
    36|     public const TABLE_NAME = 'campaign_events';
    37|     public const TYPE_DECISION  = 'decision';
    38|     public const TYPE_ACTION    = 'action';
    39|     public const TYPE_CONDITION = 'condition';
    40|     public const PATH_INACTION = 'no';
    41|     public const PATH_ACTION   = 'yes';
    42|     public const TRIGGER_MODE_DATE      = 'date';
    43|     public const TRIGGER_MODE_INTERVAL  = 'interval';
    44|     public const TRIGGER_MODE_IMMEDIATE = 'immediate';
    45|     public const TRIGGER_MODE_OPTIMIZED = 'optimized';
    46|     public const CHANNEL_EMAIL = 'email';
    47|     /**
    48|      * @var int
    49|      */
    50|     private $id;
    51|     /**
    52|      * @var string
    53|      */
    54|     private $name;
    55|     /**
    56|      * @var string|null
    57|      */
    58|     private $description;
    59|     /**
    60|      * @var string
    61|      */
    62|     private $type;
    63|     /**
    64|      * @var string
    65|      */
    66|     private $eventType;
    67|     /**
    68|      * @var int
    69|      */
    70|     private $order = 0;
    71|     /**
    72|      * @var array
    73|      */
    74|     private $properties = [];
    75|     /**
    76|      * @var \DateTimeInterface|null
    77|      */
    78|     private $triggerDate;
    79|     /**
    80|      * @var int|null
    81|      */
    82|     private $triggerInterval = 0;
    83|     /**
    84|      * @var string|null
    85|      */
    86|     private $triggerIntervalUnit;
    87|     /**
    88|      * @var \DateTimeInterface|null
    89|      */
    90|     private $triggerHour;
    91|     /**
    92|      * @var \DateTimeInterface|null
    93|      */
    94|     private $triggerRestrictedStartHour;
    95|     /**
    96|      * @var \DateTimeInterface|null
    97|      */
    98|     private $triggerRestrictedStopHour;
    99|     /**
   100|      * @var array|null
   101|      */
   102|     private $triggerRestrictedDaysOfWeek = [];
   103|     private ?int $triggerWindow;
   104|     /**
   105|      * @var string|null
   106|      */
   107|     private $triggerMode;
   108|     /**
   109|      * @var Campaign
   110|      */
   111|     private $campaign;
   112|     /**
   113|      * @var ArrayCollection<int, Event>
   114|      **/
   115|     private $children;
   116|     /**
   117|      * @var Event|null
   118|      **/
   119|     private $parent;
   120|     /**
   121|      * @var string|null
   122|      **/
   123|     private $decisionPath;
   124|     /**
   125|      * @var string|null
   126|      **/
   127|     private $tempId;
   128|     /**
   129|      * @var ArrayCollection<int, LeadEventLog>
   130|      */
   131|     private $log;
   132|     /**
   133|      * Used by API to house contact specific logs.
   134|      *
   135|      * @var array
   136|      */
   137|     private $contactLog = [];
   138|     /**
   139|      * @var string|null
   140|      */
   141|     private $channel;
   142|     /**
   143|      * @var int|null
   144|      */
   145|     private $channelId;
   146|     /**
   147|      * @var array
   148|      */
   149|     private $changes = [];
   150|     private ?\DateTimeInterface $deleted = null;
   151|     private int $failedCount = 0;
   152|     public function __construct()
   153|     {
   154|         $this->log      = new ArrayCollection();
   155|         $this->children = new ArrayCollection();
   156|     }
   157|     /**
   158|      * Clean up after clone.
   159|      */
   160|     public function __clone()
   161|     {
   162|         $this->tempId    = null;
   163|         $this->campaign  = null;
   164|         $this->channel   = null;
   165|         $this->channelId = null;
   166|     }
   167|     public static function loadMetadata(ORM\ClassMetadata $metadata): void
   168|     {
   169|         $builder = new ClassMetadataBuilder($metadata);
   170|         $builder->setTable(self::TABLE_NAME)
   171|             ->setCustomRepositoryClass(EventRepository::class)
   172|             ->addIndex(['type', 'event_type'], 'campaign_event_search')
   173|             ->addIndex(['event_type'], 'campaign_event_type')
   174|             ->addIndex(['channel', 'channel_id'], 'campaign_event_channel');
   175|         $builder->addIdColumns();
   176|         $builder->createField('type', 'string')
   177|             ->length(50)
   178|             ->build();
   179|         $builder->createField('eventType', 'string')
   180|             ->columnName('event_type')
   181|             ->length(50)
   182|             ->build();
   183|         $builder->createField('order', 'integer')
   184|             ->columnName('event_order')
   185|             ->build();
   186|         $builder->addField('properties', 'array');
   187|         $builder->addNullableField('deleted', 'datetime');
   188|         $builder->createField('triggerDate', 'datetime')
   189|             ->columnName('trigger_date')
   190|             ->nullable()
   191|             ->build();
   192|         $builder->createField('triggerInterval', 'integer')
   193|             ->columnName('trigger_interval')
   194|             ->nullable()
   195|             ->build();
   196|         $builder->createField('triggerIntervalUnit', 'string')
   197|             ->columnName('trigger_interval_unit')
   198|             ->length(1)
   199|             ->nullable()
   200|             ->build();
   201|         $builder->createField('triggerHour', 'time')
   202|             ->columnName('trigger_hour')
   203|             ->nullable()
   204|             ->build();
   205|         $builder->createField('triggerRestrictedStartHour', 'time')
   206|             ->columnName('trigger_restricted_start_hour')
   207|             ->nullable()
   208|             ->build();
   209|         $builder->createField('triggerRestrictedStopHour', 'time')
   210|             ->columnName('trigger_restricted_stop_hour')
   211|             ->nullable()
   212|             ->build();
   213|         $builder->createField('triggerRestrictedDaysOfWeek', 'array')
   214|             ->columnName('trigger_restricted_dow')
   215|             ->nullable()
   216|             ->build();
   217|         $builder->createField('triggerWindow', 'integer')
   218|             ->columnName('trigger_window')
   219|             ->nullable()
   220|             ->build();
   221|         $builder->createField('triggerMode', 'string')
   222|             ->columnName('trigger_mode')
   223|             ->length(10)
   224|             ->nullable()
   225|             ->build();
   226|         $builder->createManyToOne('campaign', 'Campaign')
   227|             ->inversedBy('events')
   228|             ->addJoinColumn('campaign_id', 'id', false, false, 'CASCADE')
   229|             ->build();
   230|         $builder->createOneToMany('children', 'Event')
   231|             ->setIndexBy('id')
   232|             ->setOrderBy(['order' => 'ASC'])
   233|             ->mappedBy('parent')
   234|             ->build();
   235|         $builder->createManyToOne('parent', 'Event')
   236|             ->inversedBy('children')
   237|             ->cascadePersist()
   238|             ->addJoinColumn('parent_id', 'id')
   239|             ->build();
   240|         $builder->createField('decisionPath', 'string')
   241|             ->columnName('decision_path')
   242|             ->nullable()
   243|             ->build();
   244|         $builder->createField('tempId', 'string')
   245|             ->columnName('temp_id')
   246|             ->nullable()
   247|             ->build();
   248|         $builder->createOneToMany('log', 'LeadEventLog')
   249|             ->mappedBy('event')
   250|             ->cascadePersist()
   251|             ->fetchExtraLazy()
   252|             ->build();
   253|         $builder->createField('channel', 'string')
   254|             ->nullable()
   255|             ->build();
   256|         $builder->createField('channelId', 'integer')
   257|             ->columnName('channel_id')
   258|             ->nullable()
   259|             ->build();
   260|         $builder->createField('failedCount', 'integer')
   261|             ->columnName('failed_count')
   262|             ->build();
   263|         static::addUuidField($builder);
   264|     }
   265|     /**
   266|      * Prepares the metadata for API usage.
   267|      */
   268|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
   269|     {
   270|         $metadata->setGroupPrefix('campaignEvent')
   271|             ->addListProperties(
   272|                 [
   273|                     'id',
   274|                     'name',
   275|                     'description',
   276|                     'type',
   277|                     'eventType',
   278|                     'channel',
   279|                     'channelId',
   280|                 ]
   281|             )
   282|             ->addProperties(
   283|                 [
   284|                     'order',
   285|                     'properties',
   286|                     'triggerDate',
   287|                     'triggerInterval',
   288|                     'triggerIntervalUnit',
   289|                     'triggerHour',
   290|                     'triggerRestrictedStartHour',
   291|                     'triggerRestrictedStopHour',
   292|                     'triggerRestrictedDaysOfWeek',
   293|                     'triggerMode',
   294|                     'decisionPath',
   295|                     'channel',
   296|                     'channelId',
   297|                     'parent',
   298|                     'children',
   299|                 ]
   300|             )
   301|             ->setMaxDepth(1, 'parent')
   302|             ->setMaxDepth(1, 'children')
   303|             ->setGroupPrefix('campaignEventStandalone')
   304|              ->addListProperties(
   305|                  [
   306|                      'id',
   307|                      'name',
   308|                      'description',
   309|                      'type',
   310|                      'eventType',
   311|                      'channel',
   312|                      'channelId',
   313|                  ]
   314|              )
   315|              ->addProperties(
   316|                  [
   317|                      'campaign',
   318|                      'order',
   319|                      'properties',
   320|                      'triggerDate',
   321|                      'triggerInterval',
   322|                      'triggerIntervalUnit',
   323|                      'triggerHour',
   324|                      'triggerRestrictedStartHour',
   325|                      'triggerRestrictedStopHour',
   326|                      'triggerRestrictedDaysOfWeek',
   327|                      'triggerMode',
   328|                      'children',
   329|                      'parent',
   330|                      'decisionPath',
   331|                  ]
   332|              )
   333|             ->setGroupPrefix('campaignEventWithLogs')
   334|             ->addListProperties(
   335|                 [
   336|                     'id',
   337|                     'name',
   338|                     'description',
   339|                     'type',
   340|                     'eventType',
   341|                     'contactLog',
   342|                     'triggerDate',
   343|                     'triggerInterval',
   344|                     'triggerIntervalUnit',
   345|                     'triggerHour',
   346|                     'triggerRestrictedStartHour',
   347|                     'triggerRestrictedStopHour',
   348|                     'triggerRestrictedDaysOfWeek',
   349|                     'triggerMode',
   350|                     'decisionPath',
   351|                     'order',
   352|                     'parent',
   353|                     'channel',
   354|                     'channelId',
   355|                 ]
   356|             )
   357|             ->addProperties(
   358|                 [
   359|                     'campaign',
   360|                 ]
   361|             )
   362|              ->build();
   363|     }
   364|     public static function loadValidatorMetadata(ClassMetadata $metadata): void
   365|     {
   366|         $metadata->addConstraint(new EntityEvent());
   367|     }
   368|     /**
   369|      * @param string $prop
   370|      * @param mixed  $val
   371|      */
   372|     private function isChanged($prop, $val): void
   373|     {
   374|         $getter  = 'get'.ucfirst($prop);
   375|         $current = $this->$getter();
   376|         if ('category' == $prop || 'parent' == $prop) {
   377|             $currentId = ($current) ? $current->getId() : '';
   378|             $newId     = ($val) ? $val->getId() : null;
   379|             if ($currentId != $newId) {
   380|                 $this->changes[$prop] = [$currentId, $newId];
   381|             }
   382|         } elseif ($this->$prop != $val) {
   383|             $this->changes[$prop] = [$this->$prop, $val];
   384|         }
   385|     }
   386|     /**
   387|      * @return array
   388|      */
   389|     public function getChanges()
   390|     {
   391|         return $this->changes;
   392|     }
   393|     /**
   394|      * @return int
   395|      */
   396|     public function getId()
   397|     {
   398|         return $this->id;
   399|     }
   400|     public function nullId(): void
   401|     {
   402|         $this->id = null;
   403|     }
   404|     /**
   405|      * @param int $order
   406|      *
   407|      * @return Event
   408|      */
   409|     public function setOrder($order)
   410|     {
   411|         $this->isChanged('order', $order);
   412|         $this->order = $order;
   413|         return $this;
   414|     }
   415|     /**
   416|      * @return int
   417|      */
   418|     public function getOrder()
   419|     {
   420|         return $this->order;
   421|     }
   422|     /**
   423|      * @param array $properties
   424|      *
   425|      * @return Event
   426|      */
   427|     public function setProperties($properties)
   428|     {
   429|         $this->isChanged('properties', $properties);
   430|         $this->properties = $properties;
   431|         return $this;
   432|     }
   433|     /**
   434|      * @return array
   435|      */
   436|     public function getProperties()
   437|     {
   438|         return $this->properties;
   439|     }
   440|     /**
   441|      * @return Event
   442|      */
   443|     public function setCampaign(Campaign $campaign)
   444|     {
   445|         $this->campaign = $campaign;
   446|         return $this;
   447|     }
   448|     /**
   449|      * @return Campaign
   450|      */
   451|     public function getCampaign()
   452|     {
   453|         return $this->campaign;
   454|     }
   455|     /**
   456|      * @param string $type
   457|      *
   458|      * @return Event
   459|      */
   460|     public function setType($type)
   461|     {
   462|         $this->isChanged('type', $type);
   463|         $this->type = $type;
   464|         return $this;
   465|     }
   466|     /**
   467|      * @return string
   468|      */
   469|     public function getType()
   470|     {
   471|         return $this->type;
   472|     }
   473|     public function convertToArray(): array
   474|     {
   475|         return get_object_vars($this);
   476|     }
   477|     /**
   478|      * @param string $description
   479|      *
   480|      * @return Event
   481|      */
   482|     public function setDescription($description)
   483|     {
   484|         $this->isChanged('description', $description);
   485|         $this->description = $description;
   486|         return $this;
   487|     }
   488|     /**
   489|      * @return string
   490|      */
   491|     public function getDescription()
   492|     {
   493|         return $this->description;
   494|     }
   495|     /**
   496|      * @param string $name
   497|      *
   498|      * @return Event
   499|      */
   500|     public function setName($name)
   501|     {
   502|         $this->isChanged('name', $name);
   503|         $this->name = $name;
   504|         return $this;
   505|     }
   506|     /**
   507|      * @return string
   508|      */
   509|     public function getName()
   510|     {
   511|         return $this->name;
   512|     }
   513|     /**
   514|      * @return Event
   515|      */
   516|     public function addLog(LeadEventLog $log)
   517|     {
   518|         $this->log[] = $log;
   519|         return $this;
   520|     }
   521|     /**
   522|      * Remove log.
   523|      */
   524|     public function removeLog(LeadEventLog $log): void
   525|     {
   526|         $this->log->removeElement($log);
   527|     }
   528|     /**
   529|      * @return Collection
   530|      */
   531|     public function getLog()
   532|     {
   533|         return $this->log;
   534|     }
   535|     /**
   536|      * Get log for a contact and a rotation.
   537|      *
   538|      * @return LeadEventLog|null
   539|      */
   540|     public function getLogByContactAndRotation(Contact $contact, $rotation)
   541|     {
   542|         $criteria = Criteria::create()
   543|             ->where(Criteria::expr()->eq('lead', $contact))
   544|             ->andWhere(Criteria::expr()->eq('rotation', $rotation))
   545|             ->setMaxResults(1);
   546|         $log = $this->getLog()->matching($criteria);
   547|         if (count($log)) {
   548|             return $log->first();
   549|         }
   550|         return null;
   551|     }
   552|     /**
   553|      * Add children.
   554|      *
   555|      * @return Event
   556|      */
   557|     public function addChild(Event $children)
   558|     {
   559|         $this->children[] = $children;
   560|         return $this;
   561|     }
   562|     /**
   563|      * Remove children.
   564|      */
   565|     public function removeChild(Event $children): void
   566|     {
   567|         $this->children->removeElement($children);
   568|     }
   569|     /**
   570|      * @return ArrayCollection<int,Event>|Collection<(int|string), mixed>
   571|      */
   572|     public function getChildren()
   573|     {
   574|         $criteria = Criteria::create()->where(Criteria::expr()->isNull('deleted'));
   575|         return $this->children->matching($criteria);
   576|     }
   577|     /**
   578|      * @return ArrayCollection<int,Event>
   579|      */
   580|     public function getPositiveChildren()
   581|     {
   582|         $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', self::PATH_ACTION));
   583|         return $this->getChildren()->matching($criteria);
   584|     }
   585|     /**
   586|      * @return ArrayCollection<int,Event>
   587|      */
   588|     public function getNegativeChildren()
   589|     {
   590|         $criteria = Criteria::create()->where(Criteria::expr()->eq('decisionPath', self::PATH_INACTION));
   591|         return $this->getChildren()->matching($criteria);
   592|     }
   593|     /**
   594|      * @param string $type
   595|      *
   596|      * @return ArrayCollection<int,Event>
   597|      */
   598|     public function getChildrenByType($type)
   599|     {
   600|         $criteria = Criteria::create()->where(Criteria::expr()->eq('type', $type));
   601|         return $this->getChildren()->matching($criteria);
   602|     }
   603|     /**
   604|      * @param string $type
   605|      *
   606|      * @return ArrayCollection<int,Event>
   607|      */
   608|     public function getChildrenByEventType($type)
   609|     {
   610|         $criteria = Criteria::create()->where(Criteria::expr()->eq('eventType', $type));
   611|         return $this->getChildren()->matching($criteria);
   612|     }
   613|     /**
   614|      * Set parent.
   615|      *
   616|      * @return Event
   617|      */
   618|     public function setParent(Event $parent = null)
   619|     {
   620|         $this->isChanged('parent', $parent);
   621|         $this->parent = $parent;
   622|         return $this;
   623|     }
   624|     /**
   625|      * Remove parent.
   626|      */
   627|     public function removeParent(): void
   628|     {
   629|         $this->isChanged('parent', '');
   630|         $this->parent = null;
   631|     }
   632|     /**
   633|      * @return ?Event
   634|      */
   635|     public function getParent()
   636|     {
   637|         return $this->parent;
   638|     }
   639|     /**
   640|      * @return mixed
   641|      */
   642|     public function getTriggerDate()
   643|     {
   644|         return $this->triggerDate;
   645|     }
   646|     /**
   647|      * @param \DateTime|null $triggerDate
   648|      */
   649|     public function setTriggerDate($triggerDate): void
   650|     {
   651|         $this->isChanged('triggerDate', $triggerDate);
   652|         $this->triggerDate = $triggerDate;
   653|     }
   654|     /**
   655|      * @return int
   656|      */
   657|     public function getTriggerInterval()
   658|     {
   659|         return $this->triggerInterval;
   660|     }
   661|     /**
   662|      * @param int $triggerInterval
   663|      */
   664|     public function setTriggerInterval($triggerInterval): void
   665|     {
   666|         $this->isChanged('triggerInterval', $triggerInterval);
   667|         $this->triggerInterval = $triggerInterval;
   668|     }
   669|     /**
   670|      * @return \DateTimeInterface|null
   671|      */
   672|     public function getTriggerHour()
   673|     {
   674|         return $this->triggerHour;
   675|     }
   676|     /**
   677|      * @param string $triggerHour
   678|      *
   679|      * @return Event
   680|      */
   681|     public function setTriggerHour($triggerHour)
   682|     {
   683|         if (empty($triggerHour)) {
   684|             $triggerHour = null;
   685|         } elseif (!$triggerHour instanceof \DateTime) {
   686|             $triggerHour = new \DateTime($triggerHour);
   687|         }
   688|         $this->isChanged('triggerHour', $triggerHour ? $triggerHour->format('H:i') : $triggerHour);
   689|         $this->triggerHour = $triggerHour;
   690|         return $this;
   691|     }
   692|     /**
   693|      * @return mixed
   694|      */
   695|     public function getTriggerIntervalUnit()
   696|     {
   697|         return $this->triggerIntervalUnit;
   698|     }
   699|     /**
   700|      * @param mixed $triggerIntervalUnit
   701|      */
   702|     public function setTriggerIntervalUnit($triggerIntervalUnit): void
   703|     {
   704|         $this->isChanged('triggerIntervalUnit', $triggerIntervalUnit);
   705|         $this->triggerIntervalUnit = $triggerIntervalUnit;
   706|     }
   707|     /**
   708|      * @return mixed
   709|      */
   710|     public function getEventType()
   711|     {
   712|         return $this->eventType;
   713|     }
   714|     /**
   715|      * @return $this
   716|      */
   717|     public function setEventType($eventType)
   718|     {
   719|         $this->isChanged('eventType', $eventType);
   720|         $this->eventType = $eventType;
   721|         return $this;
   722|     }
   723|     public function getTriggerWindow(): ?int
   724|     {
   725|         return $this->triggerWindow;
   726|     }
   727|     public function setTriggerWindow(?int $triggerWindow): Event
   728|     {
   729|         $this->triggerWindow = $triggerWindow;
   730|         return $this;
   731|     }
   732|     /**
   733|      * @return mixed
   734|      */
   735|     public function getTriggerMode()
   736|     {
   737|         return $this->triggerMode;
   738|     }
   739|     /**
   740|      * @param mixed $triggerMode
   741|      */
   742|     public function setTriggerMode($triggerMode): void
   743|     {
   744|         $this->isChanged('triggerMode', $triggerMode);
   745|         $this->triggerMode = $triggerMode;
   746|     }
   747|     /**
   748|      * @return mixed
   749|      */
   750|     public function getDecisionPath()
   751|     {
   752|         return $this->decisionPath;
   753|     }
   754|     /**
   755|      * @param mixed $decisionPath
   756|      */
   757|     public function setDecisionPath($decisionPath): void
   758|     {
   759|         $this->isChanged('decisionPath', $decisionPath);
   760|         $this->decisionPath = $decisionPath;
   761|     }
   762|     /**
   763|      * @return mixed
   764|      */
   765|     public function getTempId()
   766|     {
   767|         return $this->tempId;
   768|     }
   769|     /**
   770|      * @param mixed $tempId
   771|      */
   772|     public function setTempId($tempId): void
   773|     {
   774|         $this->isChanged('tempId', $tempId);
   775|         $this->tempId = $tempId;
   776|     }
   777|     /**
   778|      * @return mixed
   779|      */
   780|     public function getChannel()
   781|     {
   782|         return $this->channel;
   783|     }
   784|     /**
   785|      * @param mixed $channel
   786|      */
   787|     public function setChannel($channel): void
   788|     {
   789|         $this->isChanged('channel', $channel);
   790|         $this->channel = $channel;
   791|     }
   792|     /**
   793|      * @return int
   794|      */
   795|     public function getChannelId()
   796|     {
   797|         return $this->channelId;
   798|     }
   799|     /**
   800|      * @param int $channelId
   801|      */
   802|     public function setChannelId($channelId): void
   803|     {
   804|         $this->isChanged('channelId', $channelId);
   805|         $this->channelId = (int) $channelId;
   806|     }
   807|     /**
   808|      * Used by the API.
   809|      *
   810|      * @return LeadEventLog[]|Collection|static
   811|      */
   812|     public function getContactLog(Contact $contact = null)
   813|     {
   814|         if ($this->contactLog) {
   815|             return $this->contactLog;
   816|         }
   817|         return $this->log->matching(
   818|             Criteria::create()
   819|                     ->where(
   820|                         Criteria::expr()->eq('lead', $contact)
   821|                     )
   822|         );
   823|     }
   824|     /**
   825|      * Used by the API.
   826|      *
   827|      * @param array $contactLog
   828|      *
   829|      * @return Event
   830|      */
   831|     public function setContactLog($contactLog)
   832|     {
   833|         $this->contactLog = $contactLog;
   834|         return $this;
   835|     }
   836|     /**
   837|      * Used by the API.
   838|      *
   839|      * @return Event
   840|      */
   841|     public function addContactLog($contactLog)
   842|     {
   843|         $this->contactLog[] = $contactLog;
   844|         return $this;
   845|     }
   846|     /**
   847|      * Get the value of triggerRestrictedStartHour.
   848|      *
   849|      * @return \DateTimeInterface|null
   850|      */
   851|     public function getTriggerRestrictedStartHour()
   852|     {
   853|         return $this->triggerRestrictedStartHour;
   854|     }
   855|     /**
   856|      * Set the value of triggerRestrictedStartHour.
   857|      *
   858|      * @param \DateTime|null $triggerRestrictedStartHour
   859|      *
   860|      * @return self
   861|      */
   862|     public function setTriggerRestrictedStartHour($triggerRestrictedStartHour)
   863|     {
   864|         if (empty($triggerRestrictedStartHour)) {
   865|             $triggerRestrictedStartHour = null;
   866|         } elseif (!$triggerRestrictedStartHour instanceof \DateTime) {
   867|             $triggerRestrictedStartHour = new \DateTime($triggerRestrictedStartHour);
   868|         }
   869|         $this->isChanged('triggerRestrictedStartHour', $triggerRestrictedStartHour ? $triggerRestrictedStartHour->format('H:i') : $triggerRestrictedStartHour);
   870|         $this->triggerRestrictedStartHour = $triggerRestrictedStartHour;
   871|         return $this;
   872|     }
   873|     /**
   874|      * Get the value of triggerRestrictedStopHour.
   875|      *
   876|      * @return \DateTimeInterface|null
   877|      */
   878|     public function getTriggerRestrictedStopHour()
   879|     {
   880|         return $this->triggerRestrictedStopHour;
   881|     }
   882|     /**
   883|      * Set the value of triggerRestrictedStopHour.
   884|      *
   885|      * @param \DateTime|null $triggerRestrictedStopHour
   886|      *
   887|      * @return self
   888|      */
   889|     public function setTriggerRestrictedStopHour($triggerRestrictedStopHour)
   890|     {
   891|         if (empty($triggerRestrictedStopHour)) {
   892|             $triggerRestrictedStopHour = null;
   893|         } elseif (!$triggerRestrictedStopHour instanceof \DateTime) {
   894|             $triggerRestrictedStopHour = new \DateTime($triggerRestrictedStopHour);
   895|         }
   896|         $this->isChanged('triggerRestrictedStopHour', $triggerRestrictedStopHour ? $triggerRestrictedStopHour->format('H:i') : $triggerRestrictedStopHour);
   897|         $this->triggerRestrictedStopHour = $triggerRestrictedStopHour;
   898|         return $this;
   899|     }
   900|     /**
   901|      * Get the value of triggerRestrictedDaysOfWeek.
   902|      *
   903|      * @return array
   904|      */
   905|     public function getTriggerRestrictedDaysOfWeek()
   906|     {
   907|         return (array) $this->triggerRestrictedDaysOfWeek;
   908|     }
   909|     /**
   910|      * Set the value of triggerRestrictedDaysOfWeek.
   911|      *
   912|      * @return self
   913|      */
   914|     public function setTriggerRestrictedDaysOfWeek(array $triggerRestrictedDaysOfWeek = null)
   915|     {
   916|         $this->triggerRestrictedDaysOfWeek = $triggerRestrictedDaysOfWeek;
   917|         $this->isChanged('triggerRestrictedDaysOfWeek', $triggerRestrictedDaysOfWeek);
   918|         return $this;
   919|     }
   920|     public function setDeleted(?\DateTimeInterface $deleted): Event
   921|     {
   922|         $this->isChanged('deleted', $deleted);
   923|         $this->deleted = $deleted;
   924|         return $this;
   925|     }
   926|     public function getDeleted(): ?\DateTimeInterface
   927|     {
   928|         return $this->deleted;
   929|     }
   930|     public function isDeleted(): bool
   931|     {
   932|         return !is_null($this->deleted);
   933|     }
   934|     public function getFailedCount(): int
   935|     {
   936|         return $this->failedCount;
   937|     }
   938| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Entity/EventRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-377 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Entity;
     3| use Doctrine\Common\Collections\Order;
     4| use Doctrine\DBAL\ArrayParameterType;
     5| use Mautic\CoreBundle\Entity\CommonRepository;
     6| /**
     7|  * @extends CommonRepository<Event>
     8|  */
     9| class EventRepository extends CommonRepository
    10| {
    11|     /**
    12|      * Get a list of entities.
    13|      *
    14|      * @param mixed[] $args
    15|      *
    16|      * @return \Doctrine\ORM\Tools\Pagination\Paginator<object>|object[]|mixed[]
    17|      */
    18|     public function getEntities(array $args = [])
    19|     {
    20|         $select = 'e';
    21|         $q      = $this
    22|             ->createQueryBuilder('e')
    23|             ->join('e.campaign', 'c');
    24|         if (!empty($args['campaign_id'])) {
    25|             $q->andWhere(
    26|                 $q->expr()->eq('IDENTITY(e.campaign)', (int) $args['campaign_id'])
    27|             );
    28|         }
    29|         if (empty($args['ignore_children'])) {
    30|             $select .= ', ec, ep';
    31|             $q->leftJoin('e.children', 'ec')
    32|                 ->leftJoin('e.parent', 'ep');
    33|         }
    34|         $q->select($select);
    35|         $args['qb'] = $q;
    36|         return parent::getEntities($args);
    37|     }
    38|     /**
    39|      * @param int    $contactId
    40|      * @param string $type
    41|      *
    42|      * @return array
    43|      */
    44|     public function getContactPendingEvents($contactId, $type)
    45|     {
    46|         $eventQb = $this->getEntityManager()->createQueryBuilder();
    47|         $eventQb->select('IDENTITY(log_event.event)')
    48|             ->from(LeadEventLog::class, 'log_event')
    49|             ->where(
    50|                 $eventQb->expr()->andX(
    51|                     $eventQb->expr()->eq('log_event.event', 'e'),
    52|                     $eventQb->expr()->eq('log_event.lead', 'l.lead'),
    53|                     $eventQb->expr()->eq('log_event.rotation', 'l.rotation')
    54|                 )
    55|             );
    56|         $parentQb = $this->getEntityManager()->createQueryBuilder();
    57|         $parentQb->select('parent_log_event.id')
    58|             ->from(LeadEventLog::class, 'parent_log_event')
    59|             ->where(
    60|                 $parentQb->expr()->eq('parent_log_event.event', 'e.parent'),
    61|                 $parentQb->expr()->eq('parent_log_event.lead', 'l.lead'),
    62|                 $parentQb->expr()->eq('parent_log_event.rotation', 'l.rotation'),
    63|                 $parentQb->expr()->eq('parent_log_event.isScheduled', 0)
    64|             );
    65|         $q = $this->createQueryBuilder('e', 'e.id');
    66|         $q->select('e,c')
    67|             ->innerJoin('e.campaign', 'c')
    68|             ->innerJoin('c.leads', 'l')
    69|             ->where(
    70|                 $q->expr()->andX(
    71|                     $q->expr()->eq('c.isPublished', 1),
    72|                     $q->expr()->orX(
    73|                         $q->expr()->isNull('c.publishUp'),
    74|                         $q->expr()->lt('c.publishUp', 'CURRENT_TIMESTAMP()'),
    75|                     ),
    76|                     $q->expr()->orX(
    77|                         $q->expr()->isNull('c.publishDown'),
    78|                         $q->expr()->gt('c.publishDown', 'CURRENT_TIMESTAMP()'),
    79|                     ),
    80|                     $q->expr()->isNull('c.deleted'),
    81|                     $q->expr()->eq('e.type', ':type'),
    82|                     $q->expr()->isNull('e.deleted'),
    83|                     $q->expr()->eq('IDENTITY(l.lead)', ':contactId'),
    84|                     $q->expr()->eq('l.manuallyRemoved', 0),
    85|                     $q->expr()->notIn('e.id', $eventQb->getDQL()),
    86|                     $q->expr()->orX(
    87|                         $q->expr()->isNull('e.parent'),
    88|                         $q->expr()->exists($parentQb->getDQL())
    89|                     )
    90|                 )
    91|             )
    92|             ->setParameter('type', $type)
    93|             ->setParameter('contactId', (int) $contactId);
    94|         return $q->getQuery()->getResult();
    95|     }
    96|     /**
    97|      * Get array of events by parent.
    98|      *
    99|      * @param int         $parentId
   100|      * @param string|null $decisionPath
   101|      * @param string|null $eventType
   102|      *
   103|      * @return array
   104|      */
   105|     public function getEventsByParent($parentId, $decisionPath = null, $eventType = null)
   106|     {
   107|         $q = $this->getEntityManager()->createQueryBuilder();
   108|         $q->select('e')
   109|             ->from(Event::class, 'e', 'e.id')
   110|             ->where(
   111|                 $q->expr()->eq('IDENTITY(e.parent)', (int) $parentId)
   112|             );
   113|         if (null !== $decisionPath) {
   114|             $q->andWhere(
   115|                 $q->expr()->eq('e.decisionPath', ':decisionPath')
   116|             )
   117|                 ->setParameter('decisionPath', $decisionPath);
   118|         }
   119|         if (null !== $eventType) {
   120|             $q->andWhere(
   121|                 $q->expr()->eq('e.eventType', ':eventType')
   122|             )
   123|               ->setParameter('eventType', $eventType);
   124|         }
   125|         return $q->getQuery()->getArrayResult();
   126|     }
   127|     /**
   128|      * @param int  $campaignId
   129|      * @param bool $ignoreDeleted
   130|      *
   131|      * @return array<int,mixed[]>
   132|      */
   133|     public function getCampaignEvents($campaignId, $ignoreDeleted = true): array
   134|     {
   135|         $q = $this->getEntityManager()->createQueryBuilder();
   136|         $q->select('e, IDENTITY(e.parent)')
   137|             ->from(Event::class, 'e', 'e.id')
   138|             ->where(
   139|                 $q->expr()->eq('IDENTITY(e.campaign)', (int) $campaignId)
   140|             )
   141|             ->orderBy('e.order', Order::Ascending->value);
   142|         if ($ignoreDeleted) {
   143|             $q->andWhere($q->expr()->isNull('e.deleted'));
   144|         }
   145|         $results = $q->getQuery()->getArrayResult();
   146|         $events = [];
   147|         foreach ($results as $id => $r) {
   148|             $r[0]['parent_id'] = $r[1];
   149|             $events[$id]       = $r[0];
   150|         }
   151|         unset($results);
   152|         return $events;
   153|     }
   154|     /**
   155|      * @return string[]
   156|      */
   157|     public function getCampaignEventIds(int $campaignId): array
   158|     {
   159|         $q = $this->getEntityManager()->getConnection()->createQueryBuilder();
   160|         $q->select('e.id')
   161|             ->from(MAUTIC_TABLE_PREFIX.Event::TABLE_NAME, 'e')
   162|             ->where($q->expr()->eq('e.campaign_id', $campaignId));
   163|         return array_column($q->executeQuery()->fetchAllAssociative(), 'id');
   164|     }
   165|     /**
   166|      * Get array of events with stats.
   167|      *
   168|      * @param array $args
   169|      *
   170|      * @return array
   171|      */
   172|     public function getEvents($args = [])
   173|     {
   174|         $q = $this->createQueryBuilder('e')
   175|             ->select('e, ec, ep')
   176|             ->join('e.campaign', 'c')
   177|             ->leftJoin('e.children', 'ec')
   178|             ->leftJoin('e.parent', 'ep')
   179|             ->orderBy('e.order');
   180|         if (!empty($args['campaigns'])) {
   181|             $q->andWhere($q->expr()->in('e.campaign', ':campaigns'))
   182|                 ->setParameter('campaigns', $args['campaigns']);
   183|         }
   184|         if (isset($args['positivePathOnly'])) {
   185|             $q->andWhere(
   186|                 $q->expr()->orX(
   187|                     $q->expr()->neq(
   188|                         'e.decisionPath',
   189|                         $q->expr()->literal('no')
   190|                     ),
   191|                     $q->expr()->isNull('e.decisionPath')
   192|                 )
   193|             );
   194|         }
   195|         return $q->getQuery()->getArrayResult();
   196|     }
   197|     /**
   198|      * Null event parents in preparation for deleI'lting a campaign.
   199|      *
   200|      * @param int $campaignId
   201|      */
   202|     public function nullEventParents($campaignId): void
   203|     {
   204|         $this->getEntityManager()->getConnection()->update(
   205|             MAUTIC_TABLE_PREFIX.'campaign_events',
   206|             ['parent_id'   => null],
   207|             ['campaign_id' => (int) $campaignId]
   208|         );
   209|     }
   210|     /**
   211|      * Null event parents in preparation for deleting events from a campaign.
   212|      *
   213|      * @param string[] $events
   214|      */
   215|     public function nullEventRelationships($events): void
   216|     {
   217|         $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
   218|         $qb->update(MAUTIC_TABLE_PREFIX.'campaign_events')
   219|             ->set('parent_id', ':null')
   220|             ->setParameter('null', null)
   221|             ->where(
   222|                 $qb->expr()->in('parent_id', $events)
   223|             )
   224|             ->executeStatement();
   225|     }
   226|     /**
   227|      * @param string[] $eventIds
   228|      */
   229|     public function deleteEvents(array $eventIds): void
   230|     {
   231|         $qb = $this->getEntityManager()->createQueryBuilder();
   232|         $qb->delete(Event::class, 'e')
   233|             ->where($qb->expr()->in('e.id', ':event_ids'))
   234|             ->setParameter('event_ids', $eventIds, ArrayParameterType::INTEGER)
   235|             ->getQuery()
   236|             ->execute();
   237|     }
   238|     /**
   239|      * @param string[] $eventIds
   240|      */
   241|     public function setEventsAsDeleted(array $eventIds): void
   242|     {
   243|         $dateTime = (new \DateTime())->format('Y-m-d H:i:s');
   244|         $qb       = $this->getEntityManager()->getConnection()->createQueryBuilder();
   245|         $qb->update(MAUTIC_TABLE_PREFIX.Event::TABLE_NAME)
   246|             ->set('deleted', ':deleted')
   247|             ->setParameter('deleted', $dateTime)
   248|             ->where(
   249|                 $qb->expr()->in('id', $eventIds)
   250|             )
   251|             ->executeStatement();
   252|     }
   253|     public function getTableAlias(): string
   254|     {
   255|         return 'e';
   256|     }
   257|     /**
   258|      * For the API.
   259|      *
   260|      * @return string[]
   261|      */
   262|     public function getSearchCommands(): array
   263|     {
   264|         return $this->getStandardSearchCommands();
   265|     }
   266|     /**
   267|      * Get an array of events that have been triggered by this lead.
   268|      */
   269|     public function getLeadTriggeredEvents($leadId): array
   270|     {
   271|         $q = $this->getEntityManager()->createQueryBuilder()
   272|             ->select('e, c, l')
   273|             ->from(Event::class, 'e')
   274|             ->join('e.campaign', 'c')
   275|             ->join('e.log', 'l');
   276|         $q->where($q->expr()->eq('IDENTITY(l.lead)', (int) $leadId));
   277|         $results = $q->getQuery()->getArrayResult();
   278|         $return = [];
   279|         foreach ($results as $r) {
   280|             $return[$r['id']] = $r;
   281|         }
   282|         return $return;
   283|     }
   284|     /**
   285|      * {@inheritdoc}
   286|      *
   287|      * For the API
   288|      */
   289|     protected function addCatchAllWhereClause($q, $filter): array
   290|     {
   291|         return $this->addStandardCatchAllWhereClause(
   292|             $q,
   293|             $filter,
   294|             [
   295|                 $this->getTableAlias().'.name',
   296|             ]
   297|         );
   298|     }
   299|     /**
   300|      * {@inheritdoc}
   301|      *
   302|      * For the API
   303|      */
   304|     protected function addSearchCommandWhereClause($q, $filter): array
   305|     {
   306|         return $this->addStandardSearchCommandWhereClause($q, $filter);
   307|     }
   308|     /**
   309|      * Update the failed count using DBAL to avoid
   310|      * race conditions and deadlocks.
   311|      */
   312|     public function incrementFailedCount(Event $event): int
   313|     {
   314|         $q = $this->_em->getConnection()->createQueryBuilder();
   315|         $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
   316|             ->set('failed_count', 'failed_count + 1')
   317|             ->where($q->expr()->eq('id', ':id'))
   318|             ->setParameter('id', $event->getId());
   319|         $q->executeStatement();
   320|         return $this->getFailedCount($event);
   321|     }
   322|     /**
   323|      * Update the failed count using DBAL to avoid
   324|      * race conditions and deadlocks.
   325|      */
   326|     public function decreaseFailedCount(Event $event): void
   327|     {
   328|         $q = $this->_em->getConnection()->createQueryBuilder();
   329|         $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
   330|             ->set('failed_count', 'failed_count - 1')
   331|             ->where($q->expr()->eq('id', ':id'))
   332|             ->andWhere($q->expr()->gt('failed_count', 0))
   333|             ->setParameter('id', $event->getId());
   334|         $q->executeStatement();
   335|     }
   336|     /**
   337|      * Get the up to date failed count
   338|      * for the given Event.
   339|      */
   340|     public function getFailedCount(Event $event): int
   341|     {
   342|         $q = $this->_em->getConnection()->createQueryBuilder();
   343|         $q->select('failed_count')
   344|             ->from(MAUTIC_TABLE_PREFIX.'campaign_events')
   345|             ->where($q->expr()->eq('id', ':id'))
   346|             ->setParameter('id', $event->getId());
   347|         return (int) $q->executeQuery()->fetchOne();
   348|     }
   349|     /**
   350|      * Reset the failed_count's for all events
   351|      * within the given Campaign.
   352|      */
   353|     public function resetFailedCountsForEventsInCampaign(Campaign $campaign): void
   354|     {
   355|         $q = $this->_em->getConnection()->createQueryBuilder();
   356|         $q->update(MAUTIC_TABLE_PREFIX.'campaign_events')
   357|             ->set('failed_count', ':failedCount')
   358|             ->where($q->expr()->eq('campaign_id', ':campaignId'))
   359|             ->setParameter('failedCount', 0)
   360|             ->setParameter('campaignId', $campaign->getId());
   361|         $q->executeStatement();
   362|     }
   363|     /**
   364|      * Get the count of failed event for Lead/Event.
   365|      */
   366|     public function getFailedCountLeadEvent(int $leadId, int $eventId): int
   367|     {
   368|         $q = $this->_em->getConnection()->createQueryBuilder();
   369|         $q->select('count(le.id)')
   370|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'le')
   371|             ->innerJoin('le', MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fle', 'le.id = fle.log_id')
   372|             ->where('le.lead_id = :leadId')
   373|             ->andWhere('le.event_id = :eventId')
   374|             ->setParameters(['leadId' => $leadId, 'eventId' => $eventId]);
   375|         return (int) $q->executeQuery()->fetchOne();
   376|     }
   377| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Entity/LeadEventLogRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-567 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Entity;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\DBAL\ArrayParameterType;
     5| use Doctrine\DBAL\Cache\QueryCacheProfile;
     6| use Doctrine\DBAL\Types\Types;
     7| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     8| use Mautic\CoreBundle\Entity\CommonRepository;
     9| use Mautic\CoreBundle\Helper\Chart\ChartQuery;
    10| use Mautic\LeadBundle\Entity\TimelineTrait;
    11| /**
    12|  * @extends CommonRepository<LeadEventLog>
    13|  */
    14| class LeadEventLogRepository extends CommonRepository
    15| {
    16|     use TimelineTrait;
    17|     use ContactLimiterTrait;
    18|     use ReplicaConnectionTrait;
    19|     public const LOG_DELETE_BATCH_SIZE = 5000;
    20|     public function getEntities(array $args = [])
    21|     {
    22|         $alias = $this->getTableAlias();
    23|         $q     = $this
    24|             ->createQueryBuilder($alias)
    25|             ->join($alias.'.ipAddress', 'i');
    26|         if (empty($args['campaign_id'])) {
    27|             $q->join($alias.'.event', 'e')
    28|                 ->join($alias.'.campaign', 'c');
    29|         } else {
    30|             $q->andWhere(
    31|                 $q->expr()->eq('IDENTITY('.$this->getTableAlias().'.campaign)', (int) $args['campaign_id'])
    32|             );
    33|         }
    34|         if (!empty($args['contact_id'])) {
    35|             $q->andWhere(
    36|                 $q->expr()->eq('IDENTITY('.$this->getTableAlias().'.lead)', (int) $args['contact_id'])
    37|             );
    38|         }
    39|         $args['qb'] = $q;
    40|         return parent::getEntities($args);
    41|     }
    42|     public function getTableAlias(): string
    43|     {
    44|         return 'll';
    45|     }
    46|     /**
    47|      * Get a lead's page event log.
    48|      *
    49|      * @param int|null $leadId
    50|      *
    51|      * @return array
    52|      */
    53|     public function getLeadLogs($leadId = null, array $options = [])
    54|     {
    55|         $query = $this->getEntityManager()
    56|                       ->getConnection()
    57|                       ->createQueryBuilder()
    58|                       ->select('ll.id as log_id,
    59|                     ll.event_id,
    60|                     ll.campaign_id,
    61|                     ll.date_triggered as dateTriggered,
    62|                     e.name AS event_name,
    63|                     e.description AS event_description,
    64|                     e.parent_id AS parent_id,
    65|                     e.decision_path AS decision_path,
    66|                     c.name AS campaign_name,
    67|                     c.description AS campaign_description,
    68|                     ll.metadata,
    69|                     e.type,
    70|                     ll.is_scheduled as isScheduled,
    71|                     ll.trigger_date as triggerDate,
    72|                     ll.channel,
    73|                     ll.channel_id as channel_id,
    74|                     ll.lead_id,
    75|                     fl.reason as fail_reason
    76|                     '
    77|                       )
    78|                         ->add('from', [
    79|                             'table' => MAUTIC_TABLE_PREFIX.'campaign_lead_event_log',
    80|                             'alias' => 'll',
    81|                             'hint'  => 'USE INDEX ('.MAUTIC_TABLE_PREFIX.'campaign_date_triggered)',
    82|                         ], true)
    83|                         ->join('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'll.event_id = e.id')
    84|                         ->join('ll', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'll.campaign_id = c.id')
    85|                         ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fl', 'fl.log_id = ll.id')
    86|                         ->andWhere('e.event_type != :eventType')
    87|                         ->setParameter('eventType', 'decision');
    88|         if ($leadId) {
    89|             $query->where('ll.lead_id = '.(int) $leadId);
    90|         }
    91|         if (isset($options['scheduledState'])) {
    92|             if ($options['scheduledState']) {
    93|                 $query->andWhere(
    94|                     $query->expr()->or(
    95|                         $query->expr()->eq('ll.is_scheduled', ':scheduled'),
    96|                         $query->expr()->and(
    97|                             $query->expr()->eq('ll.is_scheduled', 0),
    98|                             $query->expr()->isNull('ll.date_triggered')
    99|                         )
   100|                     )
   101|                 );
   102|             } else {
   103|                 $query->andWhere(
   104|                     $query->expr()->eq('ll.is_scheduled', ':scheduled')
   105|                 );
   106|             }
   107|             $query->setParameter('scheduled', $options['scheduledState'], 'boolean');
   108|         }
   109|         if (isset($options['search']) && $options['search']) {
   110|             $query->andWhere(
   111|                 $query->expr()->or(
   112|                     $query->expr()->like('e.name', $query->expr()->literal('%'.$options['search'].'%')),
   113|                     $query->expr()->like('e.description', $query->expr()->literal('%'.$options['search'].'%')),
   114|                     $query->expr()->like('c.name', $query->expr()->literal('%'.$options['search'].'%')),
   115|                     $query->expr()->like('c.description', $query->expr()->literal('%'.$options['search'].'%'))
   116|                 )
   117|             );
   118|         }
   119|         return $this->getTimelineResults($query, $options, 'e.name', 'll.date_triggered', ['metadata'], ['dateTriggered', 'triggerDate'], null, 'll.id');
   120|     }
   121|     /**
   122|      * Get a lead's upcoming events.
   123|      */
   124|     public function getUpcomingEvents(array $options = null): array
   125|     {
   126|         $leadIps = [];
   127|         $query = $this->_em->getConnection()->createQueryBuilder();
   128|         $query->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'll')
   129|             ->select('ll.event_id,
   130|                     ll.campaign_id,
   131|                     ll.trigger_date,
   132|                     ll.lead_id,
   133|                     e.name AS event_name,
   134|                     e.description AS event_description,
   135|                     c.name AS campaign_name,
   136|                     c.description AS campaign_description,
   137|                     ll.metadata,
   138|                     CONCAT(CONCAT(l.firstname, \' \'), l.lastname) AS lead_name')
   139|             ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = ll.event_id')
   140|             ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = e.campaign_id')
   141|             ->leftJoin('ll', MAUTIC_TABLE_PREFIX.'leads', 'l', 'l.id = ll.lead_id')
   142|             ->where($query->expr()->eq('ll.is_scheduled', 1));
   143|         if (isset($options['lead'])) {
   144|             /** @var \Mautic\CoreBundle\Entity\IpAddress $ip */
   145|             foreach ($options['lead']->getIpAddresses() as $ip) {
   146|                 $leadIps[] = $ip->getId();
   147|             }
   148|             $query->andWhere('ll.lead_id = :leadId')
   149|                 ->setParameter('leadId', $options['lead']->getId());
   150|         }
   151|         if (isset($options['type'])) {
   152|             $query->andwhere('e.type = :type')
   153|                   ->setParameter('type', $options['type']);
   154|         }
   155|         if (isset($options['eventType'])) {
   156|             if (is_array($options['eventType'])) {
   157|                 $query->andWhere(
   158|                     $query->expr()->in('e.event_type', array_map([$query->expr(), 'literal'], $options['eventType']))
   159|                 );
   160|             } else {
   161|                 $query->andwhere('e.event_type = :eventTypes')
   162|                     ->setParameter('eventTypes', $options['eventType']);
   163|             }
   164|         }
   165|         if (isset($options['limit'])) {
   166|             $query->setMaxResults($options['limit']);
   167|         } else {
   168|             $query->setMaxResults(10);
   169|         }
   170|         $query->orderBy('ll.trigger_date');
   171|         if (empty($options['canViewOthers']) && isset($this->currentUser)) {
   172|             $query->andWhere('c.created_by = :userId')
   173|                 ->setParameter('userId', $this->currentUser->getId());
   174|         }
   175|         return $query->executeQuery()->fetchAllAssociative();
   176|     }
   177|     /**
   178|      * @param int  $campaignId
   179|      * @param bool $excludeScheduled
   180|      * @param bool $excludeNegative
   181|      * @param bool $all
   182|      *
   183|      * @throws \Doctrine\DBAL\Cache\CacheException
   184|      */
   185|     public function getCampaignLogCounts(
   186|         $campaignId,
   187|         $excludeScheduled = false,
   188|         $excludeNegative = true,
   189|         $all = false,
   190|         \DateTimeInterface $dateFrom = null,
   191|         \DateTimeInterface $dateTo = null,
   192|         int $eventId = null,
   193|     ): array {
   194|         $join = $all ? 'leftJoin' : 'innerJoin';
   195|         $q = $this->_em->getConnection()->createQueryBuilder();
   196|         $q->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'o');
   197|         $q->$join(
   198|             'o',
   199|             MAUTIC_TABLE_PREFIX.'campaign_leads',
   200|             'l',
   201|             'l.campaign_id = '.(int) $campaignId.' and l.manually_removed = 0 and o.lead_id = l.lead_id and l.rotation = o.rotation'
   202|         );
   203|         $expr = $q->expr()->and(
   204|             $q->expr()->eq('o.campaign_id', (int) $campaignId)
   205|         );
   206|         if ($eventId) {
   207|             $expr = $expr->with(
   208|                 $q->expr()->eq('o.event_id', $eventId)
   209|             );
   210|         }
   211|         $groupBy = 'o.event_id';
   212|         if ($excludeNegative) {
   213|             $q->select('o.event_id, count(o.lead_id) as lead_count');
   214|             $expr = $expr->with(
   215|                 $q->expr()->or(
   216|                     $q->expr()->isNull('o.non_action_path_taken'),
   217|                     $q->expr()->eq('o.non_action_path_taken', ':false')
   218|                 )
   219|             );
   220|         } else {
   221|             $q->select('o.event_id, count(o.lead_id) as lead_count, o.non_action_path_taken');
   222|             $groupBy .= ', o.non_action_path_taken';
   223|         }
   224|         if ($excludeScheduled) {
   225|             $expr = $expr->with(
   226|                 $q->expr()->eq('o.is_scheduled', ':false')
   227|             );
   228|         }
   229|         $failedSq = $this->getReplicaConnection()->createQueryBuilder();
   230|         $failedSq->select('null')
   231|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fe')
   232|             ->where(
   233|                 $failedSq->expr()->eq('fe.log_id', 'o.id')
   234|             );
   235|         if ($dateFrom && $dateTo) {
   236|             $failedSq->andWhere('fe.date_added BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
   237|                 ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
   238|                 ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
   239|         }
   240|         $expr = $expr->with(
   241|             sprintf('NOT EXISTS (%s)', $failedSq->getSQL())
   242|         );
   243|         $q->where($expr)
   244|           ->setParameter('false', false, 'boolean')
   245|           ->groupBy($groupBy);
   246|         if ($dateFrom && $dateTo) {
   247|             $q->andWhere('o.date_triggered BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
   248|                 ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
   249|                 ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
   250|         }
   251|         if ($this->_em->getConnection()->getConfiguration()->getResultCache()) {
   252|             $results = $this->_em->getConnection()->executeCacheQuery(
   253|                 $q->getSQL(),
   254|                 $q->getParameters(),
   255|                 $q->getParameterTypes(),
   256|                 new QueryCacheProfile(600)
   257|             )->fetchAllAssociative();
   258|         } else {
   259|             $results = $q->executeQuery()->fetchAllAssociative();
   260|         }
   261|         $return = [];
   262|         foreach ($results as $l) {
   263|             if (!$excludeNegative) {
   264|                 if (!isset($return[$l['event_id']])) {
   265|                     $return[$l['event_id']] = [
   266|                         0 => 0,
   267|                         1 => 0,
   268|                     ];
   269|                 }
   270|                 $key                          = (int) $l['non_action_path_taken'] ? 0 : 1;
   271|                 $return[$l['event_id']][$key] = (int) $l['lead_count'];
   272|             } else {
   273|                 $return[$l['event_id']] = (int) $l['lead_count'];
   274|             }
   275|         }
   276|         return $return;
   277|     }
   278|     /**
   279|      * Updates lead ID (e.g. after a lead merge).
   280|      */
   281|     public function updateLead($fromLeadId, $toLeadId): void
   282|     {
   283|         $results = $this->_em->getConnection()->createQueryBuilder()
   284|             ->select('cl.event_id')
   285|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'cl')
   286|             ->where('cl.lead_id = '.$toLeadId)
   287|             ->executeQuery()
   288|             ->fetchAllAssociative();
   289|         $exists = [];
   290|         foreach ($results as $r) {
   291|             $exists[] = $r['event_id'];
   292|         }
   293|         $q = $this->_em->getConnection()->createQueryBuilder();
   294|         $q->update(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
   295|             ->set('lead_id', (int) $toLeadId)
   296|             ->where('lead_id = '.(int) $fromLeadId);
   297|         if (!empty($exists)) {
   298|             $q->andWhere(
   299|                 $q->expr()->notIn('event_id', $exists)
   300|             )->executeStatement();
   301|             $this->_em->getConnection()->createQueryBuilder()
   302|                 ->delete(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
   303|                 ->where('lead_id = '.(int) $fromLeadId)
   304|                 ->executeStatement();
   305|         } else {
   306|             $q->executeStatement();
   307|         }
   308|     }
   309|     public function getChartQuery($options): array
   310|     {
   311|         $chartQuery = new ChartQuery($this->getReplicaConnection(), $options['dateFrom'], $options['dateTo']);
   312|         $query = $this->getReplicaConnection()->createQueryBuilder();
   313|         $query->select('ll.id, ll.date_triggered')
   314|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'll')
   315|             ->join('ll', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = ll.event_id');
   316|         if (isset($options['channel'])) {
   317|             $query->andwhere("e.channel = '".$options['channel']."'");
   318|         }
   319|         if (isset($options['channelId'])) {
   320|             $query->andwhere('e.channel_id = '.(int) $options['channelId']);
   321|         }
   322|         if (isset($options['type'])) {
   323|             $query->andwhere("e.type = '".$options['type']."'");
   324|         }
   325|         if (isset($options['logChannel'])) {
   326|             $query->andwhere("ll.channel = '".$options['logChannel']."'");
   327|         }
   328|         if (isset($options['logChannelId'])) {
   329|             $query->andwhere('ll.channel_id = '.(int) $options['logChannelId']);
   330|         }
   331|         if (!isset($options['is_scheduled'])) {
   332|             $query->andWhere($query->expr()->eq('ll.is_scheduled', 0));
   333|         } else {
   334|             $query->andWhere($query->expr()->eq('ll.is_scheduled', 1));
   335|         }
   336|         return $chartQuery->fetchTimeData('('.$query.')', 'date_triggered');
   337|     }
   338|     /**
   339|      * @param int $eventId
   340|      *
   341|      * @return ArrayCollection
   342|      *
   343|      * @throws \Doctrine\ORM\Query\QueryException
   344|      */
   345|     public function getScheduled($eventId, \DateTime $now, ContactLimiter $limiter)
   346|     {
   347|         if ($limiter->hasCampaignLimit() && 0 === $limiter->getCampaignLimitRemaining()) {
   348|             return new ArrayCollection();
   349|         }
   350|         $this->getReplicaConnection($limiter);
   351|         $q = $this->createQueryBuilder('o');
   352|         $q->select('o, e, c')
   353|             ->indexBy('o', 'o.id')
   354|             ->innerJoin('o.event', 'e')
   355|             ->innerJoin('e.campaign', 'c')
   356|             ->where(
   357|                 $q->expr()->andX(
   358|                     $q->expr()->eq('IDENTITY(o.event)', ':eventId'),
   359|                     $q->expr()->eq('o.isScheduled', ':true'),
   360|                     $q->expr()->lte('o.triggerDate', ':now'),
   361|                     $q->expr()->eq('c.isPublished', 1)
   362|                 )
   363|             )
   364|             ->setParameter('eventId', (int) $eventId)
   365|             ->setParameter('now', $now)
   366|             ->setParameter('true', true, Types::BOOLEAN);
   367|         $this->updateOrmQueryFromContactLimiter('o', $q, $limiter);
   368|         if ($limiter->hasCampaignLimit() && $limiter->getCampaignLimitRemaining() < $limiter->getBatchLimit()) {
   369|             $q->setMaxResults($limiter->getCampaignLimitRemaining());
   370|         }
   371|         $result = new ArrayCollection($q->getQuery()->getResult());
   372|         if ($limiter->hasCampaignLimit()) {
   373|             $limiter->reduceCampaignLimitRemaining($result->count());
   374|         }
   375|         return $result;
   376|     }
   377|     /**
   378|      * @throws \Doctrine\ORM\Query\QueryException
   379|      */
   380|     public function getScheduledByIds(array $ids): ArrayCollection
   381|     {
   382|         $this->getReplicaConnection();
   383|         $q = $this->createQueryBuilder('o');
   384|         $q->select('o, e, c')
   385|             ->indexBy('o', 'o.id')
   386|             ->innerJoin('o.event', 'e')
   387|             ->innerJoin('e.campaign', 'c')
   388|             ->where(
   389|                 $q->expr()->andX(
   390|                     $q->expr()->in('o.id', $ids),
   391|                     $q->expr()->eq('o.isScheduled', 1),
   392|                     $q->expr()->eq('c.isPublished', 1),
   393|                     $q->expr()->isNull('c.deleted'),
   394|                     $q->expr()->isNull('e.deleted')
   395|                 )
   396|             );
   397|         return new ArrayCollection($q->getQuery()->getResult());
   398|     }
   399|     /**
   400|      * @param int $campaignId
   401|      */
   402|     public function getScheduledCounts($campaignId, \DateTime $date, ContactLimiter $limiter): array
   403|     {
   404|         $now = clone $date;
   405|         $now->setTimezone(new \DateTimeZone('UTC'));
   406|         $q = $this->getReplicaConnection($limiter)->createQueryBuilder();
   407|         $expr = $q->expr()->and(
   408|             $q->expr()->eq('l.campaign_id', ':campaignId'),
   409|             $q->expr()->eq('l.is_scheduled', ':true'),
   410|             $q->expr()->lte('l.trigger_date', ':now'),
   411|             $q->expr()->eq('c.is_published', 1)
   412|         );
   413|         $this->updateQueryFromContactLimiter('l', $q, $limiter, true);
   414|         $results = $q->select('COUNT(*) as event_count, l.event_id')
   415|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'l')
   416|             ->join('l', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'l.campaign_id = c.id')
   417|             ->where($expr)
   418|             ->setParameter('campaignId', (int) $campaignId)
   419|             ->setParameter('now', $now->format('Y-m-d H:i:s'))
   420|             ->setParameter('true', true, \PDO::PARAM_BOOL)
   421|             ->groupBy('l.event_id')
   422|             ->executeQuery()
   423|             ->fetchAllAssociative();
   424|         $events = [];
   425|         foreach ($results as $result) {
   426|             $events[$result['event_id']] = (int) $result['event_count'];
   427|         }
   428|         return $events;
   429|     }
   430|     public function getDatesExecuted($eventId, array $contactIds): array
   431|     {
   432|         $qb = $this->getReplicaConnection()->createQueryBuilder();
   433|         $qb->select('log.lead_id, log.date_triggered, log.is_scheduled')
   434|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
   435|             ->where(
   436|                 $qb->expr()->and(
   437|                     $qb->expr()->eq('log.event_id', $eventId),
   438|                     $qb->expr()->in('log.lead_id', $contactIds)
   439|                 )
   440|             );
   441|         $results = $qb->executeQuery()->fetchAllAssociative();
   442|         $dates = [];
   443|         foreach ($results as $result) {
   444|             $dates[$result['lead_id']] = new \DateTime($result['date_triggered'], new \DateTimeZone('UTC'));
   445|             if (1 === (int) $result['is_scheduled']) {
   446|                 unset($dates[$result['lead_id']]);
   447|             }
   448|         }
   449|         return $dates;
   450|     }
   451|     public function getOldestTriggeredDate(): ?\DateTime
   452|     {
   453|         $qb = $this->getReplicaConnection()->createQueryBuilder();
   454|         $qb->select('log.date_triggered')
   455|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
   456|             ->orderBy('log.date_triggered', 'ASC')
   457|             ->setMaxResults(1);
   458|         $results = $qb->executeQuery()->fetchAllAssociative();
   459|         return isset($results[0]['date_triggered']) ? new \DateTime($results[0]['date_triggered']) : null;
   460|     }
   461|     /**
   462|      * @param int $contactId
   463|      * @param int $campaignId
   464|      * @param int $rotation
   465|      */
   466|     public function hasBeenInCampaignRotation($contactId, $campaignId, $rotation): bool
   467|     {
   468|         $qb = $this->getReplicaConnection()->createQueryBuilder();
   469|         $qb->select('log.rotation')
   470|             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
   471|             ->where(
   472|                 $qb->expr()->and(
   473|                     $qb->expr()->eq('log.lead_id', ':contactId'),
   474|                     $qb->expr()->eq('log.campaign_id', ':campaignId'),
   475|                     $qb->expr()->in('log.rotation', ':rotation')
   476|                 )
   477|             )
   478|             ->setParameter('contactId', (int) $contactId)
   479|             ->setParameter('campaignId', (int) $campaignId)
   480|             ->setParameter('rotation', (int) $rotation)
   481|             ->setMaxResults(1);
   482|         $results = $qb->executeQuery()->fetchAllAssociative();
   483|         return !empty($results);
   484|     }
   485|     /**
   486|      * @param string $message
   487|      *
   488|      * @throws \Doctrine\DBAL\Exception
   489|      */
   490|     public function unscheduleEvents(Lead $campaignMember, $message): void
   491|     {
   492|         $contactId  = $campaignMember->getLead()->getId();
   493|         $campaignId = $campaignMember->getCampaign()->getId();
   494|         $rotation   = $campaignMember->getRotation();
   495|         $dateAdded  = (new \DateTime('now', new \DateTimeZone('UTC')))->format('Y-m-d H:i:s');
   496|         $prefix = MAUTIC_TABLE_PREFIX;
   497|         $sql    = <<<SQL
   498| REPLACE INTO {$prefix}campaign_lead_event_failed_log( `log_id`, `date_added`, `reason`)
   499| SELECT id, :dateAdded as date_added, :message as reason from {$prefix}campaign_lead_event_log
   500| WHERE is_scheduled = 1 AND lead_id = :contactId AND campaign_id = :campaignId AND rotation = :rotation
   501| SQL;
   502|         $connection = $this->getEntityManager()->getConnection();
   503|         $stmt       = $connection->prepare($sql);
   504|         $stmt->bindValue('dateAdded', $dateAdded, \PDO::PARAM_STR);
   505|         $stmt->bindValue('message', $message, \PDO::PARAM_STR);
   506|         $stmt->bindValue('contactId', $contactId, \PDO::PARAM_INT);
   507|         $stmt->bindValue('campaignId', $campaignId, \PDO::PARAM_INT);
   508|         $stmt->bindValue('rotation', $rotation, \PDO::PARAM_INT);
   509|         $stmt->executeStatement();
   510|         $qb = $connection->createQueryBuilder();
   511|         $qb->update(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log')
   512|             ->set('is_scheduled', 0)
   513|             ->where(
   514|                 $qb->expr()->and(
   515|                     $qb->expr()->eq('is_scheduled', 1),
   516|                     $qb->expr()->eq('lead_id', ':contactId'),
   517|                     $qb->expr()->eq('campaign_id', ':campaignId'),
   518|                     $qb->expr()->eq('rotation', ':rotation')
   519|                 )
   520|             )
   521|             ->setParameters(
   522|                 [
   523|                     'contactId'     => (int) $contactId,
   524|                     'campaignId'    => (int) $campaignId,
   525|                     'rotation'      => (int) $rotation,
   526|                 ]
   527|             )
   528|             ->executeStatement();
   529|     }
   530|     public function removeEventLogsByCampaignId(int $campaignId): void
   531|     {
   532|         $table_name    = $this->getTableName();
   533|         $sql           = "DELETE FROM {$table_name} WHERE campaign_id = (?) LIMIT ".self::LOG_DELETE_BATCH_SIZE;
   534|         $conn          = $this->getEntityManager()->getConnection();
   535|         $deleteEntries = true;
   536|         while ($deleteEntries) {
   537|             $deleteEntries = $conn->executeQuery($sql, [$campaignId], [Types::INTEGER])->rowCount();
   538|         }
   539|     }
   540|     /**
   541|      * @param string[] $eventIds
   542|      */
   543|     public function removeEventLogs(array $eventIds): void
   544|     {
   545|         $table_name    = $this->getTableName();
   546|         $sql           = "DELETE FROM {$table_name} WHERE event_id IN (?) ORDER BY event_id ASC LIMIT ".self::LOG_DELETE_BATCH_SIZE;
   547|         $conn          = $this->getEntityManager()->getConnection();
   548|         $deleteEntries = true;
   549|         while ($deleteEntries) {
   550|             $deleteEntries = $conn->executeQuery($sql, [$eventIds], [ArrayParameterType::INTEGER])->rowCount();
   551|         }
   552|     }
   553|     /**
   554|      * Check if last lead/event failed.
   555|      *
   556|      * @throws \Doctrine\ORM\NonUniqueResultException
   557|      */
   558|     public function isLastFailed(int $leadId, int $eventId): bool
   559|     {
   560|         /** @var LeadEventLog $log */
   561|         $log = $this->findOneBy(['lead' => $leadId, 'event' => $eventId], ['dateTriggered' => 'DESC']);
   562|         if (null !== $log && null !== $log->getFailedLog()) {
   563|             return true;
   564|         }
   565|         return false;
   566|     }
   567| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Entity/SummaryRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Entity;
     4| use Mautic\CoreBundle\Entity\CommonRepository;
     5| use Mautic\LeadBundle\Entity\TimelineTrait;
     6| /**
     7|  * @extends CommonRepository<Summary>
     8|  */
     9| class SummaryRepository extends CommonRepository
    10| {
    11|     use TimelineTrait;
    12|     use ContactLimiterTrait;
    13|     public function getTableAlias(): string
    14|     {
    15|         return 's';
    16|     }
    17|     /**
    18|      * @return array<int|string, array<int|string, int|string>>
    19|      */
    20|     public function getCampaignLogCounts(
    21|         int $campaignId,
    22|         \DateTimeInterface $dateFrom = null,
    23|         \DateTimeInterface $dateTo = null,
    24|     ): array {
    25|         $q = $this->_em->getConnection()->createQueryBuilder()
    26|             ->select(
    27|                 [
    28|                     'cs.event_id',
    29|                     'SUM(cs.scheduled_count) as scheduled_count',
    30|                     'SUM(cs.triggered_count) as triggered_count',
    31|                     'SUM(cs.non_action_path_taken_count) as non_action_path_taken_count',
    32|                     'SUM(cs.failed_count) as failed_count',
    33|                     'SUM(cs.log_counts_processed) as log_counts_processed',
    34|                 ]
    35|             )
    36|             ->from(MAUTIC_TABLE_PREFIX.'campaign_summary', 'cs')
    37|             ->where('cs.campaign_id = '.(int) $campaignId)
    38|             ->groupBy('cs.event_id');
    39|         if ($dateFrom && $dateTo) {
    40|             $q->andWhere('cs.date_triggered BETWEEN FROM_UNIXTIME(:dateFrom) AND FROM_UNIXTIME(:dateTo)')
    41|                 ->setParameter('dateFrom', $dateFrom->getTimestamp(), \PDO::PARAM_INT)
    42|                 ->setParameter('dateTo', $dateTo->getTimestamp(), \PDO::PARAM_INT);
    43|         }
    44|         $results = $q->executeQuery()->fetchAllAssociative();
    45|         $return = [];
    46|         foreach ($results as $row) {
    47|             $return[$row['event_id']] = [
    48|                 0 => (int) $row['non_action_path_taken_count'],
    49|                 1 => (int) $row['triggered_count'] + (int) $row['scheduled_count'],
    50|                 2 => (int) $row['log_counts_processed'],
    51|             ];
    52|         }
    53|         return $return;
    54|     }
    55|     /**
    56|      * Get the oldest triggered time for back-filling historical data.
    57|      */
    58|     public function getOldestTriggeredDate(): ?\DateTimeInterface
    59|     {
    60|         $qb = $this->getEntityManager()->getConnection()->createQueryBuilder();
    61|         $qb->select('cs.date_triggered')
    62|             ->from(MAUTIC_TABLE_PREFIX.'campaign_summary', 'cs')
    63|             ->orderBy('cs.date_triggered', 'ASC')
    64|             ->setMaxResults(1);
    65|         $results = $qb->executeQuery()->fetchAllAssociative();
    66|         return isset($results[0]['date_triggered']) ? new \DateTime($results[0]['date_triggered']) : null;
    67|     }
    68|     /**
    69|      * Regenerate summary entries for a given time frame.
    70|      *
    71|      * @throws \Doctrine\DBAL\Exception
    72|      */
    73|     public function summarize(
    74|         \DateTimeInterface $dateFrom,
    75|         \DateTimeInterface $dateTo,
    76|         int $campaignId = null,
    77|         int $eventId = null,
    78|     ): void {
    79|         $dateFromTsActual = $dateFrom->getTimestamp();
    80|         $dateToTsActual   = $dateTo->getTimestamp();
    81|         $intervalInSeconds= 3600;
    82|         $dateFromStartWithZeroMinutes = $dateFromTsActual - ($dateFromTsActual % $intervalInSeconds);
    83|         $numberOfIntervals            = ceil(($dateToTsActual - $dateFromStartWithZeroMinutes) / $intervalInSeconds);
    84|         for ($interval = 0; $interval < $numberOfIntervals; ++$interval) {
    85|             $dateFromTs = date('Y-m-d H:i:s', $dateFromStartWithZeroMinutes + ($interval * $intervalInSeconds));
    86|             $dateToTs   = date('Y-m-d H:i:s', strtotime($dateFromTs) + ($intervalInSeconds - 1));
    87|             $sql = 'INSERT INTO '.MAUTIC_TABLE_PREFIX.'campaign_summary '.
    88|             ' (campaign_id, event_id, date_triggered, scheduled_count, non_action_path_taken_count, failed_count, triggered_count, log_counts_processed) '.
    89|             ' SELECT * FROM (SELECT '.
    90|             '       mclel.campaign_id AS campaign_id, '.
    91|             '       mclel.event_id AS event_id, '.
    92|             '       "'.$dateFromTs.'" AS date_triggered_i, '.
    93|             '       SUM(IF(mclel.is_scheduled = 1 AND mclel.trigger_date > NOW(), 1, 0)) AS scheduled_count_i, '.
    94|             '       SUM(IF(mclel.is_scheduled = 1 AND mclel.trigger_date > NOW(), 0, mclel.non_action_path_taken)) AS non_action_path_taken_count_i, '.
    95|             '       SUM(IF((mclel.is_scheduled = 1 AND mclel.trigger_date > NOW()) OR mclel.non_action_path_taken, 0, mclefl.log_id IS NOT NULL)) AS failed_count_i, '.
    96|             '       SUM(IF((mclel.is_scheduled = 1 AND mclel.trigger_date > NOW()) OR mclel.non_action_path_taken OR mclefl.log_id IS NOT NULL, 0, 1)) AS triggered_count_i, '.
    97|             '       COUNT((SELECT mcl.campaign_id FROM '.MAUTIC_TABLE_PREFIX.'campaign_leads mcl '.
    98|             '           WHERE mcl.campaign_id = mclel.campaign_id AND mcl.manually_removed = 0 '.
    99|             '           AND mclel.lead_id = mcl.lead_id AND mcl.rotation = mclel.rotation '.
   100|             '           AND NOT EXISTS(SELECT NULL FROM '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log mclefl2 '.
   101|             '               WHERE mclefl2.log_id = mclel.id AND mclefl2.date_added BETWEEN "'.$dateFromTs.'" AND "'.$dateToTs.'")'.
   102|             '       )) AS log_counts_processed_i '.
   103|             ' FROM '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_log mclel LEFT JOIN '.MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log mclefl ON mclefl.log_id = mclel.id '.
   104|             ' WHERE (mclel.date_triggered BETWEEN "'.$dateFromTs.'" AND "'.$dateToTs.'") ';
   105|             if ($campaignId) {
   106|                 $sql .= ' AND mclel.campaign_id = '.$campaignId;
   107|             }
   108|             if ($eventId) {
   109|                 $sql .= ' AND mclel.event_id = '.$eventId;
   110|             }
   111|             $sql .= ' GROUP BY mclel.campaign_id, mclel.event_id) AS `s` '.
   112|             ' ON DUPLICATE KEY UPDATE '.
   113|             ' scheduled_count = s.scheduled_count_i, '.
   114|             ' non_action_path_taken_count = s.non_action_path_taken_count_i, '.
   115|             ' failed_count = s.failed_count_i, '.
   116|             ' triggered_count = s.triggered_count_i, '.
   117|             ' log_counts_processed = s.log_counts_processed_i;';
   118|             $this->getEntityManager()->getConnection()->executeQuery($sql);
   119|         }
   120|     }
   121| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/AbstractLogCollectionEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     7| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     8| use Mautic\LeadBundle\Entity\Lead;
     9| abstract class AbstractLogCollectionEvent extends \Symfony\Contracts\EventDispatcher\Event
    10| {
    11|     /**
    12|      * @var ArrayCollection
    13|      */
    14|     protected $logs;
    15|     /**
    16|      * @var ArrayCollection|Lead[]
    17|      */
    18|     private ArrayCollection $contacts;
    19|     private array $logContactXref = [];
    20|     public function __construct(
    21|         protected AbstractEventAccessor $config,
    22|         protected Event $event,
    23|         ArrayCollection $logs,
    24|     ) {
    25|         $this->logs     = $logs;
    26|         $this->contacts = new ArrayCollection();
    27|         $this->extractContacts();
    28|     }
    29|     /**
    30|      * @return AbstractEventAccessor
    31|      */
    32|     public function getConfig()
    33|     {
    34|         return $this->config;
    35|     }
    36|     /**
    37|      * @return Event
    38|      */
    39|     public function getEvent()
    40|     {
    41|         return $this->event;
    42|     }
    43|     /**
    44|      * Return an array of Lead entities keyed by LeadEventLog ID.
    45|      *
    46|      * @return Lead[]|ArrayCollection
    47|      */
    48|     public function getContacts()
    49|     {
    50|         return $this->contacts;
    51|     }
    52|     /**
    53|      * @return ArrayCollection
    54|      */
    55|     public function getContactsKeyedById()
    56|     {
    57|         $contacts = new ArrayCollection();
    58|         /** @var Lead $contact */
    59|         foreach ($this->contacts as $contact) {
    60|             $contacts->set($contact->getId(), $contact);
    61|         }
    62|         return $contacts;
    63|     }
    64|     /**
    65|      * Get the IDs of all contacts affected by this event.
    66|      *
    67|      * @return array
    68|      */
    69|     public function getContactIds()
    70|     {
    71|         $contactIds = array_keys($this->logContactXref);
    72|         return array_combine($contactIds, $contactIds);
    73|     }
    74|     /**
    75|      * @param int $id
    76|      *
    77|      * @return LeadEventLog
    78|      *
    79|      * @throws NoContactsFoundException
    80|      */
    81|     public function findLogByContactId($id)
    82|     {
    83|         if (!isset($this->logContactXref[$id])) {
    84|             throw new NoContactsFoundException("$id not found");
    85|         }
    86|         if (!$this->logs->offsetExists($this->logContactXref[$id])) {
    87|             throw new NoContactsFoundException("$id was found in the xref table but no log was found");
    88|         }
    89|         return $this->logs->get($this->logContactXref[$id]);
    90|     }
    91|     private function extractContacts(): void
    92|     {
    93|         /** @var LeadEventLog $log */
    94|         foreach ($this->logs as $log) {
    95|             $contact                                 = $log->getLead();
    96|             $this->logContactXref[$contact->getId()] = $log->getId();
    97|             $this->contacts->set($log->getId(), $contact);
    98|         }
    99|     }
   100| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignBuilderEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-170 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Event\Exception\KeyAlreadyRegisteredException;
     4| use Mautic\CoreBundle\Event\ComponentValidationTrait;
     5| use Symfony\Contracts\EventDispatcher\Event;
     6| use Symfony\Contracts\Translation\TranslatorInterface;
     7| class CampaignBuilderEvent extends Event
     8| {
     9|     use ComponentValidationTrait;
    10|     private array $decisions = [];
    11|     private array $conditions = [];
    12|     private array $actions = [];
    13|     /**
    14|      * Holds info if some property has been already sorted or not.
    15|      */
    16|     private array $sortCache = [];
    17|     public function __construct(
    18|         private TranslatorInterface $translator,
    19|     ) {
    20|     }
    21|     /**
    22|      * Add an lead decision to the list of available .
    23|      *
    24|      * @param string $key      a unique identifier; it is recommended that it be namespaced i.e. lead.mytrigger
    25|      * @param array  $decision can contain the following keys:
    26|      *                         $decision = [
    27|      *                         'label'                   => (required) what to display in the list
    28|      *                         'eventName'               => (required) The event name to fire when this event is triggered.
    29|      *                         'description'             => (optional) short description of event
    30|      *                         'formType'                => (optional) name of the form type SERVICE for the action
    31|      *                         'formTypeOptions'         => (optional) array of options to pass to the formType service
    32|      *                         'formTheme'               => (optional) form theme
    33|      *                         'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
    34|      *                         [
    35|      *                         'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
    36|      *                         'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
    37|      *                         'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
    38|      *                         ]
    39|      *                         ]
    40|      */
    41|     public function addDecision($key, array $decision): void
    42|     {
    43|         if (array_key_exists($key, $this->decisions)) {
    44|             throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another contact action. Please use a different key.");
    45|         }
    46|         $this->verifyComponent(
    47|             ['label', ['eventName', 'callback']],
    48|             $decision,
    49|             ['callback']
    50|         );
    51|         $decision['label']       = $this->translator->trans($decision['label']);
    52|         $decision['description'] = (isset($decision['description'])) ? $this->translator->trans($decision['description']) : '';
    53|         $this->decisions[$key] = $decision;
    54|     }
    55|     /**
    56|      * @return mixed
    57|      */
    58|     public function getDecisions()
    59|     {
    60|         return $this->sort('decisions');
    61|     }
    62|     /**
    63|      * Add an lead condition to the list of available conditions.
    64|      *
    65|      * @param string $key   a unique identifier; it is recommended that it be namespaced i.e. lead.mytrigger
    66|      * @param array  $event can contain the following keys:
    67|      *                      $condition = [
    68|      *                      'label'                   => (required) what to display in the list
    69|      *                      'eventName'               => (required) The event name to fire when this event is triggered.
    70|      *                      'description'             => (optional) short description of event
    71|      *                      'formType'                => (optional) name of the form type SERVICE for the action
    72|      *                      'formTypeOptions'         => (optional) array of options to pass to the formType service
    73|      *                      'formTheme'               => (optional) form theme
    74|      *                      'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
    75|      *                      [
    76|      *                      'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
    77|      *                      'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
    78|      *                      'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
    79|      *                      ]
    80|      *                      ]
    81|      */
    82|     public function addCondition($key, array $event): void
    83|     {
    84|         if (array_key_exists($key, $this->conditions)) {
    85|             throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another contact action. Please use a different key.");
    86|         }
    87|         $this->verifyComponent(
    88|             ['label', ['eventName', 'callback']],
    89|             $event,
    90|             ['callback']
    91|         );
    92|         $event['label']       = $this->translator->trans($event['label']);
    93|         $event['description'] = (isset($event['description'])) ? $this->translator->trans($event['description']) : '';
    94|         $this->conditions[$key] = $event;
    95|     }
    96|     /**
    97|      * Get lead conditions.
    98|      *
    99|      * @return array
   100|      */
   101|     public function getConditions()
   102|     {
   103|         return $this->sort('conditions');
   104|     }
   105|     /**
   106|      * Add an action to the list of available .
   107|      *
   108|      * @param string $key    a unique identifier; it is recommended that it be namespaced i.e. lead.action
   109|      * @param array  $action can contain the following keys:
   110|      *                       $action = [
   111|      *                       'label'               => (required) what to display in the list
   112|      *                       'eventName'           => (required) The event to fire when this event is triggered.
   113|      *                       'description'         => (optional) short description of event
   114|      *                       'formType'            => (optional) name of the form type SERVICE for the action
   115|      *                       'formTypeOptions'     => (optional) array of options to pass to the formType service
   116|      *                       'formTheme'           => (optional) form theme
   117|      *                       'timelineTemplate'    => (optional) custom template for the lead timeline
   118|      *                       'connectionRestrictions'  => (optional) Array of events to restrict this event to. Implicit events
   119|      *                       [
   120|      *                       'anchor' => [], // array of anchors this event should _not_ be allowed to connect to in the format of eventType.anchorName, e.g. decision.no
   121|      *                       'source' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to connect into this event
   122|      *                       'target' => ['action' => [], 'decision' => [], 'condition' => []], // array of event keys allowed to flow from this event
   123|      *                       ]
   124|      *                       ]
   125|      */
   126|     public function addAction($key, array $action): void
   127|     {
   128|         if (array_key_exists($key, $this->actions)) {
   129|             throw new KeyAlreadyRegisteredException("The key, '$key' is already used by another action. Please use a different key.");
   130|         }
   131|         $this->verifyComponent(
   132|             ['label', ['batchEventName', 'eventName', 'callback']],
   133|             $action,
   134|             ['callback']
   135|         );
   136|         $action['label']       = $this->translator->trans($action['label']);
   137|         $action['description'] = (isset($action['description'])) ? $this->translator->trans($action['description']) : '';
   138|         $this->actions[$key] = $action;
   139|     }
   140|     /**
   141|      * Get actions.
   142|      *
   143|      * @return array
   144|      */
   145|     public function getActions()
   146|     {
   147|         return $this->sort('actions');
   148|     }
   149|     /**
   150|      * Sort internal actions, decisions and conditions arrays.
   151|      *
   152|      * @param string $property name
   153|      *
   154|      * @return array
   155|      */
   156|     protected function sort($property)
   157|     {
   158|         if (empty($this->sortCache[$property])) {
   159|             uasort(
   160|                 $this->{$property},
   161|                 fn ($a, $b): int => strnatcasecmp(
   162|                     $a['label'],
   163|                     $b['label']
   164|                 )
   165|             );
   166|             $this->sortCache[$property] = true;
   167|         }
   168|         return $this->{$property};
   169|     }
   170| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignDecisionEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-98 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| /**
     6|  * @deprecated 2.13.0; to be removed in 3.0
     7|  */
     8| class CampaignDecisionEvent extends Event
     9| {
    10|     protected $decisionTriggered = false;
    11|     /**
    12|      * @param LeadEventLog[] $logs
    13|      */
    14|     public function __construct(
    15|         protected $lead,
    16|         protected $decisionType,
    17|         protected $decisionEventDetails,
    18|         protected $events,
    19|         protected $eventSettings,
    20|         protected $isRootLevel = false,
    21|         protected $logs = [],
    22|     ) {
    23|     }
    24|     /**
    25|      * @return mixed
    26|      */
    27|     public function getLead()
    28|     {
    29|         return $this->lead;
    30|     }
    31|     /**
    32|      * @return mixed
    33|      */
    34|     public function getEvents()
    35|     {
    36|         return $this->events;
    37|     }
    38|     /**
    39|      * @return mixed
    40|      */
    41|     public function getDecisionType()
    42|     {
    43|         return $this->decisionType;
    44|     }
    45|     /**
    46|      * @return mixed
    47|      */
    48|     public function getDecisionEventDetails()
    49|     {
    50|         return $this->decisionEventDetails;
    51|     }
    52|     /**
    53|      * @return bool
    54|      */
    55|     public function getEventSettings($eventType = null, $type = null)
    56|     {
    57|         if ($type) {
    58|             return (!empty($this->eventSettings[$eventType][$type])) ? $this->eventSettings[$eventType][$type] : false;
    59|         } elseif ($eventType) {
    60|             return (!empty($this->eventSettings[$eventType])) ? $this->eventSettings[$eventType] : false;
    61|         }
    62|         return $this->eventSettings;
    63|     }
    64|     /**
    65|      * Is the decision used as a root level event?
    66|      *
    67|      * @return bool
    68|      */
    69|     public function isRootLevel()
    70|     {
    71|         return $this->isRootLevel;
    72|     }
    73|     /**
    74|      * Set if the decision has already been triggered and if so, child events will be executed.
    75|      *
    76|      * @param bool|true $triggered
    77|      */
    78|     public function setDecisionAlreadyTriggered($triggered = true): void
    79|     {
    80|         $this->decisionTriggered = $triggered;
    81|     }
    82|     /**
    83|      * Returns if the decision has already been triggered.
    84|      *
    85|      * @return mixed
    86|      */
    87|     public function wasDecisionTriggered()
    88|     {
    89|         return $this->decisionTriggered;
    90|     }
    91|     /**
    92|      * @return array|LeadEventLog[]
    93|      */
    94|     public function getLogs()
    95|     {
    96|         return $this->logs;
    97|     }
    98| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignExecutionEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-203 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\LeadBundle\Entity\Lead;
     5| use Symfony\Contracts\EventDispatcher\Event;
     6| /**
     7|  * @deprecated 2.13.0; to be removed in 3.0
     8|  */
     9| class CampaignExecutionEvent extends Event
    10| {
    11|     use EventArrayTrait;
    12|     use ContextTrait;
    13|     /**
    14|      * @var Lead
    15|      */
    16|     protected $lead;
    17|     /**
    18|      * @var array
    19|      */
    20|     protected $event;
    21|     /**
    22|      * @var array
    23|      */
    24|     protected $eventDetails;
    25|     /**
    26|      * @var bool
    27|      */
    28|     protected $systemTriggered;
    29|     /**
    30|      * @var array
    31|      */
    32|     protected $eventSettings;
    33|     /**
    34|      * @var bool
    35|      */
    36|     protected $logUpdatedByListener = false;
    37|     /**
    38|      * @var string
    39|      */
    40|     protected $channel;
    41|     /**
    42|      * @var int
    43|      */
    44|     protected $channelId;
    45|     /**
    46|      * @param bool|mixed[]|string|null $result
    47|      */
    48|     public function __construct(
    49|         array $args,
    50|         protected $result,
    51|         protected ?LeadEventLog $log = null,
    52|     ) {
    53|         $this->lead            = $args['lead'];
    54|         $this->event           = $args['event'];
    55|         $this->eventDetails    = $args['eventDetails'];
    56|         $this->systemTriggered = $args['systemTriggered'];
    57|         $this->eventSettings   = $args['eventSettings'];
    58|     }
    59|     /**
    60|      * @return Lead
    61|      */
    62|     public function getLead()
    63|     {
    64|         return $this->lead;
    65|     }
    66|     /**
    67|      * Returns array with lead fields and owner ID if exist.
    68|      *
    69|      * @return array
    70|      */
    71|     public function getLeadFields()
    72|     {
    73|         $lead         = $this->getLead();
    74|         $isLeadEntity = $lead instanceof Lead;
    75|         if (!$isLeadEntity && !is_array($lead)) {
    76|             $lead = [];
    77|         }
    78|         $leadFields             = $isLeadEntity ? $lead->getProfileFields() : $lead;
    79|         $leadFields['owner_id'] = $isLeadEntity && ($owner = $lead->getOwner()) ? $owner->getId() : 0;
    80|         return $leadFields;
    81|     }
    82|     /**
    83|      * @return array
    84|      */
    85|     public function getEvent()
    86|     {
    87|         return ($this->event instanceof \Mautic\CampaignBundle\Entity\Event) ? $this->getEventArray($this->event) : $this->event;
    88|     }
    89|     /**
    90|      * @return array
    91|      */
    92|     public function getConfig()
    93|     {
    94|         return $this->getEvent()['properties'];
    95|     }
    96|     /**
    97|      * @return array
    98|      */
    99|     public function getEventDetails()
   100|     {
   101|         return $this->eventDetails;
   102|     }
   103|     /**
   104|      * @return bool
   105|      */
   106|     public function getSystemTriggered()
   107|     {
   108|         return $this->systemTriggered;
   109|     }
   110|     /**
   111|      * @return bool|mixed[]|string|null
   112|      */
   113|     public function getResult()
   114|     {
   115|         return $this->result;
   116|     }
   117|     /**
   118|      * @param bool|mixed[]|string|null $result
   119|      *
   120|      * @return $this
   121|      */
   122|     public function setResult($result)
   123|     {
   124|         $this->result = $result;
   125|         return $this;
   126|     }
   127|     /**
   128|      * Set the result to failed.
   129|      *
   130|      * @param string|null $reason
   131|      *
   132|      * @return $this
   133|      */
   134|     public function setFailed($reason = null)
   135|     {
   136|         $this->result = [
   137|             'failed' => 1,
   138|             'reason' => $reason,
   139|         ];
   140|         return $this;
   141|     }
   142|     /**
   143|      * @return mixed
   144|      */
   145|     public function getEventSettings()
   146|     {
   147|         return $this->eventSettings;
   148|     }
   149|     /**
   150|      * Set a custom log entry to override auto-handling of the log entry.
   151|      *
   152|      * @return $this
   153|      */
   154|     public function setLogEntry(LeadEventLog $log)
   155|     {
   156|         $this->logUpdatedByListener = true;
   157|         $this->log                  = $log;
   158|         return $this;
   159|     }
   160|     /**
   161|      * @return LeadEventLog
   162|      */
   163|     public function getLogEntry()
   164|     {
   165|         return $this->log;
   166|     }
   167|     /**
   168|      * Returns if a listener updated the log entry.
   169|      *
   170|      * @return bool
   171|      */
   172|     public function wasLogUpdatedByListener()
   173|     {
   174|         return $this->logUpdatedByListener;
   175|     }
   176|     /**
   177|      * @param string          $channel
   178|      * @param string|int|null $channelId
   179|      */
   180|     public function setChannel($channel, $channelId = null): void
   181|     {
   182|         if (null !== $this->log) {
   183|             $this->log->setChannel($channel);
   184|             $this->log->setChannelId($channelId);
   185|         }
   186|         $this->channel   = $channel;
   187|         $this->channelId = $channelId;
   188|     }
   189|     /**
   190|      * @return mixed
   191|      */
   192|     public function getChannel()
   193|     {
   194|         return $this->channel;
   195|     }
   196|     /**
   197|      * @return mixed
   198|      */
   199|     public function getChannelId()
   200|     {
   201|         return $this->channelId;
   202|     }
   203| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignLeadChangeEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\LeadBundle\Entity\Lead;
     5| use Symfony\Contracts\EventDispatcher\Event;
     6| class CampaignLeadChangeEvent extends Event
     7| {
     8|     /**
     9|      * @var ?Lead
    10|      */
    11|     private $lead;
    12|     /**
    13|      * @var Lead[]
    14|      */
    15|     private array $leads = [];
    16|     /**
    17|      * @param Lead|Lead[] $leads
    18|      * @param ?string     $action
    19|      */
    20|     public function __construct(
    21|         private Campaign $campaign,
    22|         $leads,
    23|         private $action,
    24|     ) {
    25|         if (is_array($leads)) {
    26|             $this->leads = $leads;
    27|         } else {
    28|             $this->lead = $leads;
    29|         }
    30|     }
    31|     /**
    32|      * Returns the Campaign entity.
    33|      *
    34|      * @return Campaign
    35|      */
    36|     public function getCampaign()
    37|     {
    38|         return $this->campaign;
    39|     }
    40|     /**
    41|      * Returns the Lead entity.
    42|      *
    43|      * @return Lead|null
    44|      */
    45|     public function getLead()
    46|     {
    47|         return $this->lead;
    48|     }
    49|     /**
    50|      * If this is a batch event, return array of leads.
    51|      *
    52|      * @return Lead[]|null
    53|      */
    54|     public function getLeads()
    55|     {
    56|         return $this->leads;
    57|     }
    58|     /**
    59|      * Returns added or removed.
    60|      *
    61|      * @return string|null
    62|      */
    63|     public function getAction()
    64|     {
    65|         return $this->action;
    66|     }
    67|     /**
    68|      * Lead was removed from the campaign.
    69|      */
    70|     public function wasRemoved(): bool
    71|     {
    72|         return 'removed' === $this->action;
    73|     }
    74|     /**
    75|      * Lead was added to the campaign.
    76|      */
    77|     public function wasAdded(): bool
    78|     {
    79|         return 'added' === $this->action;
    80|     }
    81| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignScheduledEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-102 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| /**
     6|  * @deprecated 2.13.0; to be removed in 3.0
     7|  */
     8| class CampaignScheduledEvent extends Event
     9| {
    10|     use EventArrayTrait;
    11|     /**
    12|      * @var \Mautic\LeadBundle\Entity\Lead
    13|      */
    14|     protected $lead;
    15|     /**
    16|      * @var array
    17|      */
    18|     protected $event;
    19|     /**
    20|      * @var array
    21|      */
    22|     protected $eventDetails;
    23|     /**
    24|      * @var bool
    25|      */
    26|     protected $systemTriggered;
    27|     /**
    28|      * @var \DateTimeInterface
    29|      */
    30|     protected $dateScheduled;
    31|     /**
    32|      * @var array
    33|      */
    34|     protected $eventSettings;
    35|     public function __construct(
    36|         array $args,
    37|         protected ?LeadEventLog $log = null,
    38|     ) {
    39|         $this->lead            = $args['lead'];
    40|         $this->event           = $args['event'];
    41|         $this->eventDetails    = $args['eventDetails'];
    42|         $this->systemTriggered = $args['systemTriggered'];
    43|         $this->dateScheduled   = $args['dateScheduled'];
    44|         $this->eventSettings   = $args['eventSettings'];
    45|     }
    46|     /**
    47|      * @return \Mautic\LeadBundle\Entity\Lead
    48|      */
    49|     public function getLead()
    50|     {
    51|         return $this->lead;
    52|     }
    53|     /**
    54|      * @return array
    55|      */
    56|     public function getEvent()
    57|     {
    58|         return ($this->event instanceof \Mautic\CampaignBundle\Entity\Event) ? $this->getEventArray($this->event) : $this->event;
    59|     }
    60|     /**
    61|      * @return array
    62|      */
    63|     public function getConfig()
    64|     {
    65|         return $this->getEvent()['properties'];
    66|     }
    67|     /**
    68|      * @return array
    69|      */
    70|     public function getEventDetails()
    71|     {
    72|         return $this->eventDetails;
    73|     }
    74|     /**
    75|      * @return bool
    76|      */
    77|     public function getSystemTriggered()
    78|     {
    79|         return $this->systemTriggered;
    80|     }
    81|     /**
    82|      * @return \DateTimeInterface
    83|      */
    84|     public function getDateScheduled()
    85|     {
    86|         return $this->dateScheduled;
    87|     }
    88|     /**
    89|      * @return mixed
    90|      */
    91|     public function getEventSettings()
    92|     {
    93|         return $this->eventSettings;
    94|     }
    95|     /**
    96|      * @return LeadEventLog|null
    97|      */
    98|     public function getLog()
    99|     {
   100|         return $this->log;
   101|     }
   102| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/CampaignTriggerEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| class CampaignTriggerEvent extends Event
     6| {
     7|     /**
     8|      * @var bool
     9|      */
    10|     protected $triggerCampaign = true;
    11|     public function __construct(
    12|         protected Campaign $campaign,
    13|     ) {
    14|     }
    15|     /**
    16|      * Returns the Campaign entity.
    17|      *
    18|      * @return Campaign
    19|      */
    20|     public function getCampaign()
    21|     {
    22|         return $this->campaign;
    23|     }
    24|     /**
    25|      * @return bool
    26|      */
    27|     public function shouldTrigger()
    28|     {
    29|         return $this->triggerCampaign;
    30|     }
    31|     /**
    32|      * Do not trigger this campaign.
    33|      */
    34|     public function doNotTrigger(): void
    35|     {
    36|         $this->triggerCampaign = false;
    37|         $this->stopPropagation();
    38|     }
    39| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/ConditionEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     5| class ConditionEvent extends CampaignExecutionEvent
     6| {
     7|     use ContextTrait;
     8|     private bool $passed = false;
     9|     public function __construct(
    10|         private AbstractEventAccessor $eventConfig,
    11|         private LeadEventLog $eventLog,
    12|     ) {
    13|         parent::__construct(
    14|             [
    15|                 'eventSettings'   => $eventConfig->getConfig(),
    16|                 'eventDetails'    => null,
    17|                 'event'           => $eventLog->getEvent(),
    18|                 'lead'            => $eventLog->getLead(),
    19|                 'systemTriggered' => $eventLog->getSystemTriggered(),
    20|             ],
    21|             null,
    22|             $eventLog
    23|         );
    24|     }
    25|     /**
    26|      * @return AbstractEventAccessor
    27|      */
    28|     public function getEventConfig()
    29|     {
    30|         return $this->eventConfig;
    31|     }
    32|     /**
    33|      * @return LeadEventLog
    34|      */
    35|     public function getLog()
    36|     {
    37|         return $this->eventLog;
    38|     }
    39|     /**
    40|      * Pass this condition.
    41|      */
    42|     public function pass(): void
    43|     {
    44|         $this->passed = true;
    45|     }
    46|     /**
    47|      * Fail this condition.
    48|      */
    49|     public function fail(): void
    50|     {
    51|         $this->passed = false;
    52|     }
    53|     public function wasConditionSatisfied(): bool
    54|     {
    55|         return $this->passed;
    56|     }
    57|     /**
    58|      * @param string   $channel
    59|      * @param int|null $channelId
    60|      */
    61|     public function setChannel($channel, $channelId = null): void
    62|     {
    63|         $this->log->setChannel($this->channel);
    64|         $this->log->setChannelId($this->channelId);
    65|     }
    66|     /**
    67|      * @deprecated 2.13.0 to be removed in 3.0; BC support
    68|      */
    69|     public function getResult(): bool
    70|     {
    71|         return $this->passed;
    72|     }
    73|     /**
    74|      * @deprecated 2.13.0 to be removed in 3.0; BC support
    75|      *
    76|      * @return $this
    77|      */
    78|     public function setResult($result)
    79|     {
    80|         $this->passed = (bool) $result;
    81|         return $this;
    82|     }
    83| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/DecisionEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     5| class DecisionEvent extends CampaignExecutionEvent
     6| {
     7|     use ContextTrait;
     8|     private bool $applicable = false;
     9|     /**
    10|      * @param mixed $passthrough
    11|      */
    12|     public function __construct(
    13|         private AbstractEventAccessor $eventConfig,
    14|         private LeadEventLog $eventLog,
    15|         private $passthrough = null,
    16|     ) {
    17|         parent::__construct(
    18|             [
    19|                 'eventSettings'   => $eventConfig->getConfig(),
    20|                 'eventDetails'    => $passthrough,
    21|                 'event'           => $eventLog->getEvent(),
    22|                 'lead'            => $eventLog->getLead(),
    23|                 'systemTriggered' => defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED'),
    24|                 'dateScheduled'   => $eventLog->getTriggerDate(),
    25|             ],
    26|             null,
    27|             $eventLog
    28|         );
    29|     }
    30|     /**
    31|      * @return AbstractEventAccessor
    32|      */
    33|     public function getEventConfig()
    34|     {
    35|         return $this->eventConfig;
    36|     }
    37|     /**
    38|      * @return LeadEventLog
    39|      */
    40|     public function getLog()
    41|     {
    42|         return $this->eventLog;
    43|     }
    44|     /**
    45|      * @return mixed
    46|      */
    47|     public function getPassthrough()
    48|     {
    49|         return $this->passthrough;
    50|     }
    51|     /**
    52|      * Note that this decision is a match and the child events should be executed.
    53|      */
    54|     public function setAsApplicable(): void
    55|     {
    56|         $this->applicable = true;
    57|     }
    58|     public function wasDecisionApplicable(): bool
    59|     {
    60|         return $this->applicable;
    61|     }
    62|     /**
    63|      * @param string   $channel
    64|      * @param int|null $channelId
    65|      */
    66|     public function setChannel($channel, $channelId = null): void
    67|     {
    68|         $this->log->setChannel($this->channel);
    69|         $this->log->setChannelId($this->channelId);
    70|     }
    71|     /**
    72|      * @deprecated 2.13.0 to be removed in 3.0; BC support
    73|      */
    74|     public function getResult(): bool
    75|     {
    76|         return $this->applicable;
    77|     }
    78|     /**
    79|      * @deprecated 2.13.0 to be removed in 3.0; BC support
    80|      *
    81|      * @param mixed $result
    82|      *
    83|      * @return $this
    84|      */
    85|     public function setResult($result)
    86|     {
    87|         $this->applicable = (bool) $result;
    88|         return $this;
    89|     }
    90| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/DecisionResultsEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\LeadEventLog;
     5| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     6| use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
     7| use Symfony\Contracts\EventDispatcher\Event;
     8| class DecisionResultsEvent extends Event
     9| {
    10|     /**
    11|      * @param ArrayCollection<int, LeadEventLog> $eventLogs
    12|      */
    13|     public function __construct(
    14|         private AbstractEventAccessor $eventConfig,
    15|         private ArrayCollection $eventLogs,
    16|         private EvaluatedContacts $evaluatedContacts,
    17|     ) {
    18|     }
    19|     /**
    20|      * @return AbstractEventAccessor
    21|      */
    22|     public function getEventConfig()
    23|     {
    24|         return $this->eventConfig;
    25|     }
    26|     /**
    27|      * @return ArrayCollection|LeadEventLog[]
    28|      */
    29|     public function getLogs()
    30|     {
    31|         return $this->eventLogs;
    32|     }
    33|     /**
    34|      * @return EvaluatedContacts
    35|      */
    36|     public function getEvaluatedContacts()
    37|     {
    38|         return $this->evaluatedContacts;
    39|     }
    40| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/ExecutedEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     5| class ExecutedEvent extends \Symfony\Contracts\EventDispatcher\Event
     6| {
     7|     public function __construct(
     8|         private AbstractEventAccessor $config,
     9|         private LeadEventLog $log,
    10|     ) {
    11|     }
    12|     /**
    13|      * @return AbstractEventAccessor
    14|      */
    15|     public function getConfig()
    16|     {
    17|         return $this->config;
    18|     }
    19|     /**
    20|      * @return LeadEventLog
    21|      */
    22|     public function getLog()
    23|     {
    24|         return $this->log;
    25|     }
    26| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/FailedEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     5| class FailedEvent extends \Symfony\Contracts\EventDispatcher\Event
     6| {
     7|     public function __construct(
     8|         private AbstractEventAccessor $config,
     9|         private LeadEventLog $log,
    10|     ) {
    11|     }
    12|     /**
    13|      * @return AbstractEventAccessor
    14|      */
    15|     public function getConfig()
    16|     {
    17|         return $this->config;
    18|     }
    19|     /**
    20|      * @return LeadEventLog
    21|      */
    22|     public function getLog()
    23|     {
    24|         return $this->log;
    25|     }
    26| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/PendingEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-223 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\FailedLeadEventLog;
     6| use Mautic\CampaignBundle\Entity\LeadEventLog;
     7| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     8| class PendingEvent extends AbstractLogCollectionEvent
     9| {
    10|     use ContextTrait;
    11|     private ArrayCollection $failures;
    12|     private ArrayCollection $successful;
    13|     /**
    14|      * @var string|null
    15|      */
    16|     private $channel;
    17|     /**
    18|      * @var int|null
    19|      */
    20|     private $channelId;
    21|     private \DateTimeInterface $now;
    22|     /**
    23|      * @throws \Exception
    24|      */
    25|     public function __construct(AbstractEventAccessor $config, Event $event, ArrayCollection $logs)
    26|     {
    27|         $this->failures   = new ArrayCollection();
    28|         $this->successful = new ArrayCollection();
    29|         $this->now        = new \DateTime();
    30|         parent::__construct($config, $event, $logs);
    31|     }
    32|     /**
    33|      * @return LeadEventLog[]|ArrayCollection
    34|      */
    35|     public function getPending()
    36|     {
    37|         return $this->logs;
    38|     }
    39|     /**
    40|      * @param string $reason
    41|      */
    42|     public function fail(LeadEventLog $log, $reason, \DateInterval $rescheduleInterval = null): void
    43|     {
    44|         if (!$failedLog = $log->getFailedLog()) {
    45|             $failedLog = new FailedLeadEventLog();
    46|         }
    47|         $log->setRescheduleInterval($rescheduleInterval);
    48|         $failedLog->setLog($log)
    49|             ->setDateAdded(new \DateTime())
    50|             ->setReason($reason);
    51|         $metadata = $log->getMetadata();
    52|         $metadata = array_merge(
    53|             $metadata,
    54|             [
    55|                 'failed' => 1,
    56|                 'reason' => $reason,
    57|             ]
    58|         );
    59|         $log->setMetadata($metadata);
    60|         $this->logChannel($log);
    61|         $this->failures->set($log->getId(), $log);
    62|     }
    63|     /**
    64|      * @param string $reason
    65|      */
    66|     public function failAll($reason): void
    67|     {
    68|         foreach ($this->logs as $log) {
    69|             $this->fail($log, $reason);
    70|         }
    71|     }
    72|     /**
    73|      * Fail all that have not passed yet.
    74|      *
    75|      * @param string $reason
    76|      */
    77|     public function failRemaining($reason): void
    78|     {
    79|         foreach ($this->logs as $log) {
    80|             if (!$this->successful->contains($log)) {
    81|                 $this->fail($log, $reason);
    82|             }
    83|         }
    84|     }
    85|     /**
    86|      * Fail all that have not passed or failed yet.
    87|      *
    88|      * @param string $reason
    89|      */
    90|     public function failRemainingPending($reason): void
    91|     {
    92|         foreach ($this->logs as $log) {
    93|             if (!$this->failures->contains($log) && !$this->successful->contains($log)) {
    94|                 $this->fail($log, $reason);
    95|             }
    96|         }
    97|     }
    98|     /**
    99|      * @param LeadEventLog[]|ArrayCollection $logs
   100|      * @param string                         $reason
   101|      */
   102|     public function failLogs(ArrayCollection $logs, $reason): void
   103|     {
   104|         foreach ($logs as $log) {
   105|             $this->fail($log, $reason);
   106|         }
   107|     }
   108|     public function pass(LeadEventLog $log): void
   109|     {
   110|         $metadata = $log->getMetadata();
   111|         unset($metadata['errors']);
   112|         if (isset($metadata['failed'])) {
   113|             unset($metadata['failed'], $metadata['reason']);
   114|         }
   115|         $log->setMetadata($metadata);
   116|         $this->passLog($log);
   117|     }
   118|     /**
   119|      * @param string $error
   120|      */
   121|     public function passWithError(LeadEventLog $log, $error): void
   122|     {
   123|         $log->appendToMetadata(
   124|             [
   125|                 'failed' => 1,
   126|                 'reason' => $error,
   127|             ]
   128|         );
   129|         $this->passLog($log);
   130|     }
   131|     /**
   132|      * @param string $error
   133|      */
   134|     public function passAllWithError($error): void
   135|     {
   136|         /** @var LeadEventLog $log */
   137|         foreach ($this->logs as $log) {
   138|             $this->passWithError($log, $error);
   139|         }
   140|     }
   141|     /**
   142|      * Pass all remainging logs that have not failed failed nor suceeded yet.
   143|      */
   144|     public function passRemainingWithError(string $error): void
   145|     {
   146|         foreach ($this->logs as $log) {
   147|             if (!$this->failures->contains($log) && !$this->successful->contains($log)) {
   148|                 $this->passWithError($log, $error);
   149|             }
   150|         }
   151|     }
   152|     /**
   153|      * Pass all pending.
   154|      */
   155|     public function passAll(): void
   156|     {
   157|         /** @var LeadEventLog $log */
   158|         foreach ($this->logs as $log) {
   159|             $this->pass($log);
   160|         }
   161|     }
   162|     /**
   163|      * @param LeadEventLog[]|ArrayCollection $logs
   164|      */
   165|     public function passLogs(ArrayCollection $logs): void
   166|     {
   167|         foreach ($logs as $log) {
   168|             $this->pass($log);
   169|         }
   170|     }
   171|     /**
   172|      * Pass all that have not failed yet.
   173|      */
   174|     public function passRemaining(): void
   175|     {
   176|         foreach ($this->logs as $log) {
   177|             if (!$this->failures->contains($log)) {
   178|                 $this->pass($log);
   179|             }
   180|         }
   181|     }
   182|     /**
   183|      * @return LeadEventLog[]|ArrayCollection
   184|      */
   185|     public function getFailures()
   186|     {
   187|         return $this->failures;
   188|     }
   189|     /**
   190|      * @return LeadEventLog[]|ArrayCollection
   191|      */
   192|     public function getSuccessful()
   193|     {
   194|         return $this->successful;
   195|     }
   196|     /**
   197|      * @param string   $channel
   198|      * @param int|null $channelId
   199|      */
   200|     public function setChannel($channel, $channelId = null): void
   201|     {
   202|         $this->channel   = $channel;
   203|         $this->channelId = $channelId;
   204|     }
   205|     private function passLog(LeadEventLog $log): void
   206|     {
   207|         if ($failedLog = $log->getFailedLog()) {
   208|             $failedLog->setLog(null);
   209|             $log->setFailedLog(null);
   210|         }
   211|         $this->logChannel($log);
   212|         $log->setIsScheduled(false)
   213|             ->setDateTriggered($this->now);
   214|         $this->successful->set($log->getId(), $log);
   215|     }
   216|     private function logChannel(LeadEventLog $log): void
   217|     {
   218|         if ($this->channel) {
   219|             $log->setChannel($this->channel);
   220|             $log->setChannelId($this->channelId);
   221|         }
   222|     }
   223| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/ScheduledBatchEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     6| class ScheduledBatchEvent extends AbstractLogCollectionEvent
     7| {
     8|     /**
     9|      * @param bool $isReschedule
    10|      */
    11|     public function __construct(
    12|         AbstractEventAccessor $config,
    13|         Event $event,
    14|         ArrayCollection $logs,
    15|         private $isReschedule = false,
    16|     ) {
    17|         parent::__construct($config, $event, $logs);
    18|     }
    19|     /**
    20|      * @return ArrayCollection
    21|      */
    22|     public function getScheduled()
    23|     {
    24|         return $this->logs;
    25|     }
    26|     /**
    27|      * @return bool
    28|      */
    29|     public function isReschedule()
    30|     {
    31|         return $this->isReschedule;
    32|     }
    33| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Event/ScheduledEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Event;
     3| use Mautic\CampaignBundle\Entity\LeadEventLog;
     4| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     5| class ScheduledEvent extends CampaignScheduledEvent
     6| {
     7|     use ContextTrait;
     8|     /**
     9|      * @param bool $isReschedule
    10|      */
    11|     public function __construct(
    12|         private AbstractEventAccessor $eventConfig,
    13|         private LeadEventLog $eventLog,
    14|         private $isReschedule = false,
    15|     ) {
    16|         parent::__construct(
    17|             [
    18|                 'eventSettings'   => $eventConfig->getConfig(),
    19|                 'eventDetails'    => null,
    20|                 'event'           => $eventLog->getEvent(),
    21|                 'lead'            => $eventLog->getLead(),
    22|                 'systemTriggered' => true,
    23|                 'dateScheduled'   => $eventLog->getTriggerDate(),
    24|             ],
    25|             $eventLog
    26|         );
    27|     }
    28|     /**
    29|      * @return AbstractEventAccessor
    30|      */
    31|     public function getEventConfig()
    32|     {
    33|         return $this->eventConfig;
    34|     }
    35|     /**
    36|      * @return LeadEventLog
    37|      */
    38|     public function getLog()
    39|     {
    40|         return $this->eventLog;
    41|     }
    42|     /**
    43|      * @return bool
    44|      */
    45|     public function isReschedule()
    46|     {
    47|         return $this->isReschedule;
    48|     }
    49| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventCollector/Accessor/Event/AbstractEventAccessor.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-119 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventCollector\Accessor\Event;
     3| abstract class AbstractEventAccessor
     4| {
     5|     /**
     6|      * @var array
     7|      */
     8|     protected $systemProperties = [
     9|         'label',
    10|         'description',
    11|         'formType',
    12|         'formTypeOptions',
    13|         'formTheme',
    14|         'timelineTemplate',
    15|         'connectionRestrictions',
    16|         'channel',
    17|         'channelIdField',
    18|     ];
    19|     private array $extraProperties = [];
    20|     public function __construct(
    21|         protected array $config,
    22|     ) {
    23|         $this->filterExtraProperties();
    24|     }
    25|     /**
    26|      * @return string
    27|      */
    28|     public function getLabel()
    29|     {
    30|         return $this->getProperty('label');
    31|     }
    32|     /**
    33|      * @return string
    34|      */
    35|     public function getDescription()
    36|     {
    37|         return $this->getProperty('description');
    38|     }
    39|     /**
    40|      * @return string
    41|      */
    42|     public function getFormType()
    43|     {
    44|         return $this->getProperty('formType');
    45|     }
    46|     /**
    47|      * @return array
    48|      */
    49|     public function getFormTypeOptions()
    50|     {
    51|         return $this->getProperty('formTypeOptions', []);
    52|     }
    53|     /**
    54|      * @return string
    55|      */
    56|     public function getFormTheme()
    57|     {
    58|         return $this->getProperty('formTheme');
    59|     }
    60|     /**
    61|      * @return string
    62|      */
    63|     public function getTimelineTemplate()
    64|     {
    65|         return $this->getProperty('timelineTemplate');
    66|     }
    67|     /**
    68|      * @return array
    69|      */
    70|     public function getConnectionRestrictions()
    71|     {
    72|         return $this->getProperty('connectionRestrictions', []);
    73|     }
    74|     /**
    75|      * @return array
    76|      */
    77|     public function getExtraProperties()
    78|     {
    79|         return $this->extraProperties;
    80|     }
    81|     /**
    82|      * @return string
    83|      */
    84|     public function getChannel()
    85|     {
    86|         return $this->getProperty('channel');
    87|     }
    88|     /**
    89|      * @return mixed
    90|      */
    91|     public function getChannelIdField()
    92|     {
    93|         return $this->getProperty('channelIdField');
    94|     }
    95|     /**
    96|      * @deprecated pre 2.13.0 support; to be removed in 3.0
    97|      */
    98|     public function getConfig()
    99|     {
   100|         return $this->config;
   101|     }
   102|     /**
   103|      * @param string $property
   104|      * @param mixed  $default
   105|      *
   106|      * @return mixed
   107|      */
   108|     protected function getProperty($property, $default = null)
   109|     {
   110|         return $this->config[$property] ?? $default;
   111|     }
   112|     /**
   113|      * Calculate the difference in systemProperties and what was fed to the class.
   114|      */
   115|     private function filterExtraProperties(): void
   116|     {
   117|         $this->extraProperties = array_diff_key($this->config, array_flip($this->systemProperties));
   118|     }
   119| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventCollector/Builder/ConnectionBuilder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-94 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventCollector\Builder;
     3| use Mautic\CampaignBundle\Entity\Event;
     4| class ConnectionBuilder
     5| {
     6|     private static array $eventTypes = [];
     7|     private static array $connectionRestrictions = ['anchor' => []];
     8|     /**
     9|      * Used by JS/JsPlumb to restrict how events can be associated to each other in the UI.
    10|      *
    11|      * @return array
    12|      */
    13|     public static function buildRestrictionsArray(array $events)
    14|     {
    15|         self::$connectionRestrictions = ['anchor' => []];
    16|         self::$eventTypes = array_fill_keys(array_keys($events), []);
    17|         foreach ($events as $eventType => $typeEvents) {
    18|             foreach ($typeEvents as $key => $event) {
    19|                 self::addTypeConnection($eventType, $key, $event);
    20|             }
    21|         }
    22|         return self::$connectionRestrictions;
    23|     }
    24|     /**
    25|      * @param string $eventType
    26|      * @param string $key
    27|      */
    28|     private static function addTypeConnection($eventType, $key, array $event): void
    29|     {
    30|         if (!isset(self::$connectionRestrictions[$key])) {
    31|             self::$connectionRestrictions[$key] = [
    32|                 'source' => self::$eventTypes,
    33|                 'target' => self::$eventTypes,
    34|             ];
    35|         }
    36|         if (!isset(self::$connectionRestrictions[$key])) {
    37|             self::$connectionRestrictions['anchor'][$key] = [];
    38|         }
    39|         if (isset($event['connectionRestrictions'])) {
    40|             foreach ($event['connectionRestrictions'] as $restrictionType => $restrictions) {
    41|                 self::addRestriction($key, $restrictionType, $restrictions);
    42|             }
    43|         }
    44|         self::addDeprecatedAnchorRestrictions($eventType, $key, $event);
    45|     }
    46|     /**
    47|      * @param string $key
    48|      * @param string $restrictionType
    49|      */
    50|     private static function addRestriction($key, $restrictionType, array $restrictions): void
    51|     {
    52|         switch ($restrictionType) {
    53|             case 'source':
    54|             case 'target':
    55|                 foreach ($restrictions as $groupType => $groupRestrictions) {
    56|                     self::$connectionRestrictions[$key][$restrictionType][$groupType] += $groupRestrictions;
    57|                 }
    58|                 break;
    59|             case 'anchor':
    60|                 foreach ($restrictions as $anchor) {
    61|                     [$group, $anchor]                                               = explode('.', $anchor);
    62|                     self::$connectionRestrictions[$restrictionType][$group][$key][] = $anchor;
    63|                 }
    64|                 break;
    65|         }
    66|     }
    67|     /**
    68|      * @deprecated 2.6.0 to be removed in 3.0; BC support
    69|      *
    70|      * @param string $eventType
    71|      * @param string $key
    72|      */
    73|     private static function addDeprecatedAnchorRestrictions($eventType, $key, array $event): void
    74|     {
    75|         switch ($eventType) {
    76|             case Event::TYPE_DECISION:
    77|                 if (isset($event['associatedActions'])) {
    78|                     self::$connectionRestrictions[$key]['target']['action'] += $event['associatedActions'];
    79|                 }
    80|                 break;
    81|             case Event::TYPE_ACTION:
    82|                 if (isset($event['associatedDecisions'])) {
    83|                     self::$connectionRestrictions[$key]['source']['decision'] += $event['associatedDecisions'];
    84|                 }
    85|                 break;
    86|         }
    87|         if (isset($event['anchorRestrictions'])) {
    88|             foreach ($event['anchorRestrictions'] as $restriction) {
    89|                 [$group, $anchor]                                       = explode('.', $restriction);
    90|                 self::$connectionRestrictions['anchor'][$key][$group][] = $anchor;
    91|             }
    92|         }
    93|     }
    94| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventCollector/EventCollector.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventCollector;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     7| use Mautic\CampaignBundle\EventCollector\Accessor\EventAccessor;
     8| use Mautic\CampaignBundle\EventCollector\Builder\ConnectionBuilder;
     9| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    10| use Symfony\Contracts\Translation\TranslatorInterface;
    11| class EventCollector
    12| {
    13|     private array $eventsArray = [];
    14|     private ?EventAccessor $events = null;
    15|     public function __construct(
    16|         private TranslatorInterface $translator,
    17|         private EventDispatcherInterface $dispatcher,
    18|     ) {
    19|     }
    20|     /**
    21|      * @return EventAccessor
    22|      */
    23|     public function getEvents()
    24|     {
    25|         if (empty($this->eventsArray)) {
    26|             $this->buildEventList();
    27|         }
    28|         if (empty($this->events)) {
    29|             $this->events = new EventAccessor($this->eventsArray);
    30|         }
    31|         return $this->events;
    32|     }
    33|     /**
    34|      * @return AbstractEventAccessor
    35|      */
    36|     public function getEventConfig(Event $event)
    37|     {
    38|         return $this->getEvents()->getEvent($event->getEventType(), $event->getType());
    39|     }
    40|     /**
    41|      * Deprecated support for pre 2.13.
    42|      *
    43|      * @deprecated 2.13.0 to be removed in 3.0
    44|      *
    45|      * @param string|null $type
    46|      *
    47|      * @return array|mixed
    48|      */
    49|     public function getEventsArray($type = null)
    50|     {
    51|         if (empty($this->eventsArray)) {
    52|             $this->buildEventList();
    53|         }
    54|         if (null !== $type) {
    55|             if (!isset($this->events[$type])) {
    56|                 throw new \InvalidArgumentException("$type not found as array key");
    57|             }
    58|             return $this->eventsArray[$type];
    59|         }
    60|         return $this->eventsArray;
    61|     }
    62|     private function buildEventList(): void
    63|     {
    64|         $event  = new CampaignBuilderEvent($this->translator);
    65|         $this->dispatcher->dispatch($event, CampaignEvents::CAMPAIGN_ON_BUILD);
    66|         $this->eventsArray[Event::TYPE_ACTION]    = $event->getActions();
    67|         $this->eventsArray[Event::TYPE_CONDITION] = $event->getConditions();
    68|         $this->eventsArray[Event::TYPE_DECISION]  = $event->getDecisions();
    69|         $this->eventsArray['connectionRestrictions'] = ConnectionBuilder::buildRestrictionsArray($this->eventsArray);
    70|     }
    71| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/CampaignActionChangeMembershipSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-114 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\Campaign;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
     7| use Mautic\CampaignBundle\Event\PendingEvent;
     8| use Mautic\CampaignBundle\Form\Type\CampaignEventAddRemoveLeadType;
     9| use Mautic\CampaignBundle\Form\Validator\Constraints\InfiniteLoopValidator;
    10| use Mautic\CampaignBundle\Membership\MembershipManager;
    11| use Mautic\CampaignBundle\Model\CampaignModel;
    12| use Mautic\CoreBundle\Event\EntityValidateEvent;
    13| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    14| class CampaignActionChangeMembershipSubscriber implements EventSubscriberInterface
    15| {
    16|     public function __construct(
    17|         private MembershipManager $membershipManager,
    18|         private CampaignModel $campaignModel,
    19|         private InfiniteLoopValidator $infiniteLoopValidator,
    20|     ) {
    21|     }
    22|     public static function getSubscribedEvents(): array
    23|     {
    24|         return [
    25|             CampaignEvents::CAMPAIGN_ON_BUILD                    => ['addAction', 0],
    26|             CampaignEvents::ON_CAMPAIGN_ACTION_CHANGE_MEMBERSHIP => ['changeMembership', 0],
    27|             EntityValidateEvent::class                           => ['validateInfiniteLoop', 0],
    28|         ];
    29|     }
    30|     /**
    31|      * Add change membership action.
    32|      */
    33|     public function addAction(CampaignBuilderEvent $event): void
    34|     {
    35|         $event->addAction(
    36|             'campaign.addremovelead',
    37|             [
    38|                 'label'           => 'mautic.campaign.event.addremovelead',
    39|                 'description'     => 'mautic.campaign.event.addremovelead_descr',
    40|                 'formType'        => CampaignEventAddRemoveLeadType::class,
    41|                 'formTypeOptions' => [
    42|                     'include_this' => true,
    43|                 ],
    44|                 'batchEventName'  => CampaignEvents::ON_CAMPAIGN_ACTION_CHANGE_MEMBERSHIP,
    45|             ]
    46|         );
    47|     }
    48|     public function changeMembership(PendingEvent $event): void
    49|     {
    50|         $properties          = $event->getEvent()->getProperties();
    51|         $contacts            = $event->getContactsKeyedById();
    52|         $executingCampaign   = $event->getEvent()->getCampaign();
    53|         if (!empty($properties['addTo'])) {
    54|             $campaigns = $this->getCampaigns($properties['addTo'], $executingCampaign);
    55|             /** @var Campaign $campaign */
    56|             foreach ($campaigns as $campaign) {
    57|                 $this->membershipManager->addContacts(
    58|                     $contacts,
    59|                     $campaign,
    60|                     true
    61|                 );
    62|             }
    63|         }
    64|         if (!empty($properties['removeFrom'])) {
    65|             $campaigns = $this->getCampaigns($properties['removeFrom'], $executingCampaign);
    66|             /** @var Campaign $campaign */
    67|             foreach ($campaigns as $campaign) {
    68|                 $this->membershipManager->removeContacts(
    69|                     $event->getContactsKeyedById(),
    70|                     $campaign,
    71|                     true
    72|                 );
    73|             }
    74|         }
    75|         $event->passAll();
    76|     }
    77|     public function validateInfiniteLoop(EntityValidateEvent $event): void
    78|     {
    79|         $campaignEvent = $event->getEntity();
    80|         if (!$campaignEvent instanceof Event) {
    81|             return;
    82|         }
    83|         if ('campaign.addremovelead' !== $campaignEvent->getType()) {
    84|             return;
    85|         }
    86|         $this->infiniteLoopValidator->validateEvent(
    87|             $event->getContext(),
    88|             $campaignEvent->getTriggerMode(),
    89|             $campaignEvent->getProperties()['addTo'],
    90|             $campaignEvent->getTriggerInterval(),
    91|             $campaignEvent->getTriggerIntervalUnit()
    92|         );
    93|     }
    94|     /**
    95|      * @return array
    96|      */
    97|     private function getCampaigns(array $campaigns, Campaign $executingCampaign)
    98|     {
    99|         $includeExecutingCampaign = false;
   100|         $key                      = array_search('this', $campaigns);
   101|         if (false !== $key) {
   102|             $includeExecutingCampaign = true;
   103|             unset($campaigns[$key]);
   104|         }
   105|         $campaignEntities = [];
   106|         if (!empty($campaigns)) {
   107|             $campaignEntities = $this->campaignModel->getEntities(['ids' => $campaigns, 'ignore_paginator' => true]);
   108|         }
   109|         if ($includeExecutingCampaign) {
   110|             $campaignEntities[] = $executingCampaign;
   111|         }
   112|         return $campaignEntities;
   113|     }
   114| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/CampaignActionJumpToEventSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-150 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\EventRepository;
     6| use Mautic\CampaignBundle\Entity\LeadRepository;
     7| use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
     8| use Mautic\CampaignBundle\Event\CampaignEvent;
     9| use Mautic\CampaignBundle\Event\PendingEvent;
    10| use Mautic\CampaignBundle\Executioner\EventExecutioner;
    11| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    12| use Mautic\CampaignBundle\Form\Type\CampaignEventJumpToEventType;
    13| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    14| use Symfony\Contracts\Translation\TranslatorInterface;
    15| class CampaignActionJumpToEventSubscriber implements EventSubscriberInterface
    16| {
    17|     public const EVENT_NAME = 'campaign.jump_to_event';
    18|     public function __construct(
    19|         private EventRepository $eventRepository,
    20|         private EventExecutioner $eventExecutioner,
    21|         private TranslatorInterface $translator,
    22|         private LeadRepository $leadRepository,
    23|         private EventScheduler $eventScheduler,
    24|     ) {
    25|     }
    26|     public static function getSubscribedEvents(): array
    27|     {
    28|         return [
    29|             CampaignEvents::CAMPAIGN_POST_SAVE     => ['processCampaignEventsAfterSave', 1],
    30|             CampaignEvents::CAMPAIGN_ON_BUILD      => ['onCampaignBuild', 0],
    31|             CampaignEvents::ON_EVENT_JUMP_TO_EVENT => ['onJumpToEvent', 0],
    32|         ];
    33|     }
    34|     /**
    35|      * Add event triggers and actions.
    36|      */
    37|     public function onCampaignBuild(CampaignBuilderEvent $event): void
    38|     {
    39|         $event->addAction(self::EVENT_NAME, [
    40|             'label'                  => 'mautic.campaign.event.jump_to_event',
    41|             'description'            => 'mautic.campaign.event.jump_to_event_descr',
    42|             'formType'               => CampaignEventJumpToEventType::class,
    43|             'template'               => '@MauticCampaign/Event/jump.html.twig',
    44|             'batchEventName'         => CampaignEvents::ON_EVENT_JUMP_TO_EVENT,
    45|             'connectionRestrictions' => [
    46|                 'target' => [
    47|                     Event::TYPE_DECISION  => ['none'],
    48|                     Event::TYPE_ACTION    => ['none'],
    49|                     Event::TYPE_CONDITION => ['none'],
    50|                 ],
    51|             ],
    52|         ]);
    53|     }
    54|     /**
    55|      * Process campaign.jump_to_event actions.
    56|      *
    57|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
    58|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
    59|      * @throws \Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException
    60|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
    61|      */
    62|     public function onJumpToEvent(PendingEvent $campaignEvent): void
    63|     {
    64|         $event      = $campaignEvent->getEvent();
    65|         $jumpTarget = $this->getJumpTargetForEvent($event, 'e.id');
    66|         if (null === $jumpTarget) {
    67|             $pending  = $campaignEvent->getPending();
    68|             $contacts = $campaignEvent->getContacts();
    69|             foreach ($contacts as $logId => $contact) {
    70|                 $campaignEvent->passWithError(
    71|                     $pending->get($logId),
    72|                     $this->translator->trans('mautic.campaign.campaign.jump_to_event.target_not_exist')
    73|                 );
    74|             }
    75|         } else {
    76|             $contacts = $campaignEvent->getContactsKeyedById();
    77|             $this->leadRepository->incrementCampaignRotationForContacts(
    78|                 $contacts->getKeys(),
    79|                 $event->getCampaign()->getId()
    80|             );
    81|             $executionDate       = $event->getTriggerDate() ?? new \DateTime();
    82|             $targetExecutionDate = $this->eventScheduler->getExecutionDateTime($jumpTarget, $executionDate);
    83|             if ($this->eventScheduler->shouldScheduleEvent($jumpTarget, $targetExecutionDate, $executionDate)) {
    84|                 $this->eventScheduler->schedule($jumpTarget, $targetExecutionDate, $contacts);
    85|             } else {
    86|                 $this->eventExecutioner->executeForContacts($jumpTarget, $contacts);
    87|             }
    88|             $campaignEvent->passRemaining();
    89|         }
    90|     }
    91|     /**
    92|      * Update campaign events.
    93|      *
    94|      * This block specifically handles the campaign.jump_to_event properties
    95|      * to ensure that it has the actual ID and not the temp_id as the
    96|      * target for the jump.
    97|      */
    98|     public function processCampaignEventsAfterSave(CampaignEvent $campaignEvent): void
    99|     {
   100|         $campaign = $campaignEvent->getCampaign();
   101|         $events   = $campaign->getEvents();
   102|         $toSave   = [];
   103|         foreach ($events as $event) {
   104|             if (self::EVENT_NAME !== $event->getType()) {
   105|                 continue;
   106|             }
   107|             $jumpTarget = $this->getJumpTargetForEvent($event, 'e.tempId');
   108|             if (null !== $jumpTarget) {
   109|                 $event->setProperties(array_merge(
   110|                     $event->getProperties(),
   111|                     [
   112|                         'jumpToEvent' => $jumpTarget->getId(),
   113|                     ]
   114|                 ));
   115|                 $toSave[] = $event;
   116|             }
   117|         }
   118|         if (count($toSave)) {
   119|             $this->eventRepository->saveEntities($toSave);
   120|         }
   121|     }
   122|     /**
   123|      * Inspect a jump event and get its target.
   124|      */
   125|     private function getJumpTargetForEvent(Event $event, string $column): ?Event
   126|     {
   127|         $properties  = $event->getProperties();
   128|         $jumpToEvent = $this->eventRepository->getEntities([
   129|             'ignore_paginator' => true,
   130|             'filter'           => [
   131|                 'force' => [
   132|                     [
   133|                         'column' => $column,
   134|                         'value'  => $properties['jumpToEvent'],
   135|                         'expr'   => 'eq',
   136|                     ],
   137|                     [
   138|                         'column' => 'e.campaign',
   139|                         'value'  => $event->getCampaign(),
   140|                         'expr'   => 'eq',
   141|                     ],
   142|                 ],
   143|             ],
   144|         ]);
   145|         if (count($jumpToEvent)) {
   146|             return $jumpToEvent[0];
   147|         }
   148|         return null;
   149|     }
   150| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/CampaignEventDeleteSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\EventListener;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     6| use Mautic\CampaignBundle\Event\DeleteCampaign;
     7| use Mautic\CampaignBundle\Event\DeleteEvent;
     8| use Mautic\CampaignBundle\Helper\CampaignConfig;
     9| use Mautic\CampaignBundle\Model\CampaignModel;
    10| use Mautic\CampaignBundle\Model\EventModel;
    11| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    12| class CampaignEventDeleteSubscriber implements EventSubscriberInterface
    13| {
    14|     public function __construct(
    15|         private LeadEventLogRepository $leadEventLogRepository,
    16|         private CampaignConfig $campaignConfig,
    17|         private CampaignModel $campaignModel,
    18|         private EventModel $eventModel,
    19|     ) {
    20|     }
    21|     public static function getSubscribedEvents(): array
    22|     {
    23|         return [
    24|             CampaignEvents::ON_CAMPAIGN_DELETE => ['onCampaignDelete', 0],
    25|             CampaignEvents::ON_EVENT_DELETE    => ['onEventDelete', 0],
    26|         ];
    27|     }
    28|     public function onCampaignDelete(DeleteCampaign $event): void
    29|     {
    30|         if ($this->campaignConfig->shouldDeleteEventLogInBackground()) {
    31|             return;
    32|         }
    33|         $campaignId = $event->getCampaign()->getId();
    34|         $this->leadEventLogRepository->removeEventLogsByCampaignId($campaignId);
    35|         $this->eventModel->deleteEventsByCampaignId($campaignId);
    36|         $this->campaignModel->deleteCampaign($event->getCampaign());
    37|     }
    38|     public function onEventDelete(DeleteEvent $event): void
    39|     {
    40|         if ($this->campaignConfig->shouldDeleteEventLogInBackground()) {
    41|             return;
    42|         }
    43|         $eventIds   = $event->getEventIds();
    44|         $this->leadEventLogRepository->removeEventLogs($eventIds);
    45|         $this->eventModel->deleteEventsByEventIds($eventIds);
    46|     }
    47| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/CampaignEventSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-97 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\CampaignRepository;
     5| use Mautic\CampaignBundle\Entity\EventRepository;
     6| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     7| use Mautic\CampaignBundle\Event\CampaignEvent;
     8| use Mautic\CampaignBundle\Event\ExecutedEvent;
     9| use Mautic\CampaignBundle\Event\FailedEvent;
    10| use Mautic\CampaignBundle\Executioner\Helper\NotificationHelper;
    11| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    12| class CampaignEventSubscriber implements EventSubscriberInterface
    13| {
    14|     public const LOOPS_TO_FAIL = 100;
    15|     private float $disableCampaignThreshold = 0.35;
    16|     public function __construct(private EventRepository $eventRepository, private NotificationHelper $notificationHelper, private CampaignRepository $campaignRepository, private LeadEventLogRepository $leadEventLogRepository)
    17|     {
    18|     }
    19|     /**
    20|      * Get the subscribed events for this listener.
    21|      *
    22|      * @return array<string,mixed>
    23|      */
    24|     public static function getSubscribedEvents(): array
    25|     {
    26|         return [
    27|             CampaignEvents::CAMPAIGN_PRE_SAVE => ['onCampaignPreSave', 0],
    28|             CampaignEvents::ON_EVENT_FAILED   => ['onEventFailed', 0],
    29|             CampaignEvents::ON_EVENT_EXECUTED => ['onEventExecuted', 0],
    30|         ];
    31|     }
    32|     /**
    33|      * Reset all campaign event failed_count's
    34|      * to 0 when the campaign is published.
    35|      */
    36|     public function onCampaignPreSave(CampaignEvent $event): void
    37|     {
    38|         $campaign = $event->getCampaign();
    39|         $changes  = $campaign->getChanges();
    40|         if (array_key_exists('isPublished', $changes)) {
    41|             list($actual, $inMemory) = $changes['isPublished'];
    42|             if (false === $actual && true === $inMemory) {
    43|                 $this->eventRepository->resetFailedCountsForEventsInCampaign($campaign);
    44|             }
    45|         }
    46|     }
    47|     /**
    48|      * Process the FailedEvent event. Notifies users and checks
    49|      * failed thresholds to notify CS and/or disable the campaign.
    50|      *
    51|      * @throws \Doctrine\ORM\NonUniqueResultException
    52|      */
    53|     public function onEventFailed(FailedEvent $event): void
    54|     {
    55|         $log                  = $event->getLog();
    56|         $failedEvent          = $log->getEvent();
    57|         $campaign             = $failedEvent->getCampaign();
    58|         $lead                 = $log->getLead();
    59|         $countFailedLeadEvent = $this->eventRepository->getFailedCountLeadEvent($lead->getId(), $failedEvent->getId());
    60|         if ($countFailedLeadEvent < self::LOOPS_TO_FAIL) {
    61|             return;
    62|         } elseif ($countFailedLeadEvent > self::LOOPS_TO_FAIL
    63|             && $this->leadEventLogRepository->isLastFailed($lead->getId(), $failedEvent->getId())
    64|         ) {
    65|             return;
    66|         }
    67|         $failedCount   = $this->eventRepository->incrementFailedCount($failedEvent);
    68|         $contactCount  = $campaign->getLeads()->count();
    69|         $failedPercent = $contactCount ? ($failedCount / $contactCount) : 1;
    70|         $this->notificationHelper->notifyOfFailure($lead, $failedEvent);
    71|         if ($failedPercent >= $this->disableCampaignThreshold && $campaign->isPublished()) {
    72|             $this->notificationHelper->notifyOfUnpublish($failedEvent);
    73|             $campaign->setIsPublished(false);
    74|             $this->campaignRepository->saveEntity($campaign);
    75|         }
    76|     }
    77|     /**
    78|      * Check the fail log if the lead is recorded there. If yes it decrease the failed count. It prevents counting
    79|      * the same failure twice.
    80|      *
    81|      * @throws \Doctrine\ORM\NonUniqueResultException
    82|      */
    83|     public function onEventExecuted(ExecutedEvent $event): void
    84|     {
    85|         $log                  = $event->getLog();
    86|         $executedEvent        = $log->getEvent();
    87|         $lead                 = $log->getLead();
    88|         $leadId               = ($lead->getId() > 0) ? $lead->getId() : $lead->deletedId;
    89|         $countFailedLeadEvent = $this->eventRepository->getFailedCountLeadEvent($leadId, $executedEvent->getId());
    90|         if (!$this->leadEventLogRepository->isLastFailed($leadId, $executedEvent->getId())
    91|             || $countFailedLeadEvent < self::LOOPS_TO_FAIL
    92|         ) {
    93|             return;
    94|         }
    95|         $this->eventRepository->decreaseFailedCount($executedEvent);
    96|     }
    97| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/DashboardSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-86 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Mautic\CampaignBundle\Model\CampaignModel;
     4| use Mautic\CampaignBundle\Model\EventModel;
     5| use Mautic\DashboardBundle\Event\WidgetDetailEvent;
     6| use Mautic\DashboardBundle\EventListener\DashboardSubscriber as MainDashboardSubscriber;
     7| class DashboardSubscriber extends MainDashboardSubscriber
     8| {
     9|     /**
    10|      * Define the name of the bundle/category of the widget(s).
    11|      *
    12|      * @var string
    13|      */
    14|     protected $bundle = 'campaign';
    15|     /**
    16|      * Define the widget(s).
    17|      *
    18|      * @var string
    19|      */
    20|     protected $types = [
    21|         'events.in.time'      => [],
    22|         'leads.added.in.time' => [],
    23|     ];
    24|     /**
    25|      * Define permissions to see those widgets.
    26|      *
    27|      * @var array
    28|      */
    29|     protected $permissions = [
    30|         'campaign:campaigns:viewown',
    31|         'campaign:campaigns:viewother',
    32|     ];
    33|     public function __construct(
    34|         protected CampaignModel $campaignModel,
    35|         protected EventModel $campaignEventModel,
    36|     ) {
    37|     }
    38|     /**
    39|      * Set a widget detail when needed.
    40|      */
    41|     public function onWidgetDetailGenerate(WidgetDetailEvent $event): void
    42|     {
    43|         $this->checkPermissions($event);
    44|         $canViewOthers = $event->hasPermission('campaign:campaigns:viewother');
    45|         if ('events.in.time' == $event->getType()) {
    46|             $widget = $event->getWidget();
    47|             $params = $widget->getParams();
    48|             if (!$event->isCached()) {
    49|                 $event->setTemplateData([
    50|                     'chartType'   => 'line',
    51|                     'chartHeight' => $widget->getHeight() - 80,
    52|                     'chartData'   => $this->campaignEventModel->getEventLineChartData(
    53|                         $params['timeUnit'],
    54|                         $params['dateFrom'],
    55|                         $params['dateTo'],
    56|                         $params['dateFormat'],
    57|                         [],
    58|                         $canViewOthers
    59|                     ),
    60|                 ]);
    61|             }
    62|             $event->setTemplate('@MauticCore/Helper/chart.html.twig');
    63|             $event->stopPropagation();
    64|         }
    65|         if ('leads.added.in.time' == $event->getType()) {
    66|             $widget = $event->getWidget();
    67|             $params = $widget->getParams();
    68|             if (!$event->isCached()) {
    69|                 $event->setTemplateData([
    70|                     'chartType'   => 'line',
    71|                     'chartHeight' => $widget->getHeight() - 80,
    72|                     'chartData'   => $this->campaignModel->getLeadsAddedLineChartData(
    73|                         $params['timeUnit'],
    74|                         $params['dateFrom'],
    75|                         $params['dateTo'],
    76|                         $params['dateFormat'],
    77|                         [],
    78|                         $canViewOthers
    79|                     ),
    80|                 ]);
    81|             }
    82|             $event->setTemplate('@MauticCore/Helper/chart.html.twig');
    83|             $event->stopPropagation();
    84|         }
    85|     }
    86| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/LeadSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-155 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Doctrine\ORM\EntityManagerInterface;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\EventRepository;
     6| use Mautic\CampaignBundle\Entity\Lead as CampaignLead;
     7| use Mautic\CampaignBundle\Entity\LeadEventLog;
     8| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     9| use Mautic\CampaignBundle\Entity\LeadRepository;
    10| use Mautic\CampaignBundle\EventCollector\EventCollector;
    11| use Mautic\CoreBundle\Helper\ArrayHelper;
    12| use Mautic\LeadBundle\Event\LeadMergeEvent;
    13| use Mautic\LeadBundle\Event\LeadTimelineEvent;
    14| use Mautic\LeadBundle\LeadEvents;
    15| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    16| use Symfony\Component\Routing\RouterInterface;
    17| use Symfony\Contracts\Translation\TranslatorInterface;
    18| class LeadSubscriber implements EventSubscriberInterface
    19| {
    20|     public function __construct(
    21|         private EventCollector $eventCollector,
    22|         private TranslatorInterface $translator,
    23|         private EntityManagerInterface $entityManager,
    24|         private RouterInterface $router,
    25|         private EventRepository $eventRepository,
    26|     ) {
    27|     }
    28|     public static function getSubscribedEvents(): array
    29|     {
    30|         return [
    31|             LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
    32|             LeadEvents::LEAD_POST_MERGE      => ['onLeadMerge', 0],
    33|         ];
    34|     }
    35|     /**
    36|      * Compile events for the lead timeline.
    37|      */
    38|     public function onTimelineGenerate(LeadTimelineEvent $event): void
    39|     {
    40|         $this->addTimelineEvents($event, 'campaign.event', $this->translator->trans('mautic.campaign.triggered'));
    41|         $this->addTimelineEvents($event, 'campaign.event.scheduled', $this->translator->trans('mautic.campaign.scheduled'));
    42|     }
    43|     /**
    44|      * Update records after lead merge.
    45|      */
    46|     public function onLeadMerge(LeadMergeEvent $event): void
    47|     {
    48|         /** @var LeadEventLogRepository $leadEventLogRepository */
    49|         $leadEventLogRepository = $this->entityManager->getRepository(LeadEventLog::class);
    50|         /** @var LeadRepository $campaignLeadRepository */
    51|         $campaignLeadRepository = $this->entityManager->getRepository(CampaignLead::class);
    52|         $leadEventLogRepository->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
    53|         $campaignLeadRepository->updateLead($event->getLoser()->getId(), $event->getVictor()->getId());
    54|     }
    55|     /**
    56|      * @param string $eventTypeKey
    57|      * @param string $eventTypeName
    58|      */
    59|     private function addTimelineEvents(LeadTimelineEvent $event, $eventTypeKey, $eventTypeName): void
    60|     {
    61|         $event->addEventType($eventTypeKey, $eventTypeName);
    62|         $event->addSerializerGroup('campaignList');
    63|         if (!$event->isApplicable($eventTypeKey)) {
    64|             return;
    65|         }
    66|         /** @var LeadEventLogRepository $leadEventLogRepository */
    67|         $leadEventLogRepository = $this->entityManager->getRepository(LeadEventLog::class);
    68|         $options                   = $event->getQueryOptions();
    69|         $options['scheduledState'] = ('campaign.event' === $eventTypeKey) ? false : true;
    70|         $logs                      = $leadEventLogRepository->getLeadLogs($event->getLeadId(), $options);
    71|         $eventSettings             = $this->eventCollector->getEventsArray();
    72|         $event->addToCounter($eventTypeKey, $logs);
    73|         if (!$event->isEngagementCount()) {
    74|             foreach ($logs['results'] as $log) {
    75|                 $template = (!empty($eventSettings['action'][$log['type']]['timelineTemplate']))
    76|                     ? $eventSettings['action'][$log['type']]['timelineTemplate'] : '@MauticCampaign/SubscribedEvents/Timeline/index.html.twig';
    77|                 $label = $log['event_name'].' / '.$log['campaign_name'];
    78|                 if (empty($log['isScheduled']) && empty($log['dateTriggered'])) {
    79|                     $label .= ' <i data-toggle="tooltip" title="'.$this->translator->trans('mautic.campaign.event.cancelled')
    80|                         .'" class="ri-calendar-close-fill text-warning timeline-campaign-event-cancelled-'.$log['event_id'].'"></i>';
    81|                 }
    82|                 if ((!empty($log['metadata']['errors']) && empty($log['dateTriggered'])) || !empty($log['metadata']['failed']) || !empty($log['fail_reason'])) {
    83|                     $label .= ' <i data-toggle="tooltip" title="'.$this->translator->trans('mautic.campaign.event.has_last_attempt_error')
    84|                         .'" class="ri-alert-line text-danger"></i>';
    85|                 }
    86|                 $extra = [
    87|                     'log' => $log,
    88|                 ];
    89|                 if (!empty($log['parent_id'])) {
    90|                     $parentEvent = $this->getParentEvent($log['parent_id']);
    91|                     if ($parentEvent) {
    92|                         $extra['parentDetails'] = $this->getParentDetails($parentEvent, $log);
    93|                         $toolTipClass = 'yes' === $log['decision_path'] ? 'text-success' : 'text-danger';
    94|                         $toolTip      = $this->translator->trans('mautic.campaign.event.path.tooltip', ['%path%' => ucfirst($log['decision_path'])]);
    95|                         $label .= sprintf(' <i class="ri-node-tree %s" data-toggle="tooltip" title="%s"></i>', $toolTipClass, $toolTip);
    96|                     }
    97|                 }
    98|                 if ($event->isForTimeline()) {
    99|                     $extra['campaignEventSettings'] = $eventSettings;
   100|                 }
   101|                 $event->addEvent(
   102|                     [
   103|                         'event'      => $eventTypeKey,
   104|                         'eventId'    => $eventTypeKey.$log['log_id'],
   105|                         'eventLabel' => [
   106|                             'label' => $label,
   107|                             'href'  => $this->router->generate(
   108|                                 'mautic_campaign_action',
   109|                                 ['objectAction' => 'view', 'objectId' => $log['campaign_id']]
   110|                             ),
   111|                         ],
   112|                         'eventType'       => $eventTypeName,
   113|                         'timestamp'       => $log['dateTriggered'],
   114|                         'extra'           => $extra,
   115|                         'contentTemplate' => $template,
   116|                         'icon'            => 'ri-time-line',
   117|                         'contactId'       => $log['lead_id'],
   118|                     ]
   119|                 );
   120|             }
   121|         }
   122|     }
   123|     /**
   124|      * Fetch the parent event if exists.
   125|      */
   126|     private function getParentEvent(int $parentId): ?Event
   127|     {
   128|         $entities = $this->eventRepository->findBy([
   129|             'id'        => $parentId,
   130|             'eventType' => [Event::TYPE_CONDITION, Event::TYPE_DECISION],
   131|         ]);
   132|         return $entities[0] ?? null;
   133|     }
   134|     /**
   135|      * Get details for the parent event.
   136|      *
   137|      * @param array<string, mixed> $log
   138|      *
   139|      * @return array<string, mixed>
   140|      */
   141|     private function getParentDetails(Event $parentEvent, array $log): array
   142|     {
   143|         $properties = ArrayHelper::removeEmptyValues($parentEvent->getProperties());
   144|         $keysToRemove = ['canvasSettings', 'anchor', 'type', 'eventType', 'campaignId', '_token', 'buttons', 'anchorEventType', 'tempId', 'id', 'order', 'contactLog', 'changes', 'failedCount', 'properties'];
   145|         foreach ($keysToRemove as $key) {
   146|             unset($properties[$key]);
   147|         }
   148|         return [
   149|             'name'       => $parentEvent->getName(),
   150|             'type'       => $parentEvent->getEventType(),
   151|             'path'       => $log['decision_path'],
   152|             'properties' => $properties,
   153|         ];
   154|     }
   155| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/ReportSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-196 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\EventListener;
     3| use Mautic\CoreBundle\Helper\Chart\ChartQuery;
     4| use Mautic\LeadBundle\Model\CompanyReportData;
     5| use Mautic\ReportBundle\Event\ReportBuilderEvent;
     6| use Mautic\ReportBundle\Event\ReportGeneratorEvent;
     7| use Mautic\ReportBundle\Event\ReportGraphEvent;
     8| use Mautic\ReportBundle\ReportEvents;
     9| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    10| class ReportSubscriber implements EventSubscriberInterface
    11| {
    12|     public const CONTEXT_CAMPAIGN_LEAD_EVENT_LOG = 'campaign_lead_event_log';
    13|     public function __construct(
    14|         private CompanyReportData $companyReportData,
    15|     ) {
    16|     }
    17|     public static function getSubscribedEvents(): array
    18|     {
    19|         return [
    20|             ReportEvents::REPORT_ON_BUILD          => ['onReportBuilder', 0],
    21|             ReportEvents::REPORT_ON_GENERATE       => ['onReportGenerate', 0],
    22|             ReportEvents::REPORT_ON_GRAPH_GENERATE => ['onReportGraphGenerate', 0],
    23|         ];
    24|     }
    25|     /**
    26|      * Add available tables and columns to the report builder lookup.
    27|      */
    28|     public function onReportBuilder(ReportBuilderEvent $event): void
    29|     {
    30|         if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
    31|             return;
    32|         }
    33|         $prefix           = 'log.';
    34|         $aliasPrefix      = 'log_';
    35|         $campaignPrefix   = 'c.';
    36|         $eventPrefix      = 'e.';
    37|         $eventAliasPrefix = 'e_';
    38|         $catPrefix        = 'cat.';
    39|         $leadPrefix       = 'l.';
    40|         $columns = [
    41|             $prefix.'date_triggered' => [
    42|                 'label'          => 'mautic.report.campaign.log.date_triggered',
    43|                 'type'           => 'datetime',
    44|                 'alias'          => $aliasPrefix.'date_triggered',
    45|                 'groupByFormula' => 'DATE('.$prefix.'date_triggered)',
    46|             ],
    47|             $prefix.'is_scheduled' => [
    48|                 'label' => 'mautic.report.campaign.log.is_scheduled',
    49|                 'type'  => 'boolean',
    50|                 'alias' => $aliasPrefix.'is_scheduled',
    51|             ],
    52|             $prefix.'trigger_date' => [
    53|                 'label'          => 'mautic.report.campaign.log.trigger_date',
    54|                 'type'           => 'datetime',
    55|                 'alias'          => $aliasPrefix.'trigger_date',
    56|                 'groupByFormula' => 'DATE('.$prefix.'trigger_date)',
    57|             ],
    58|             $prefix.'system_triggered' => [
    59|                 'label' => 'mautic.report.campaign.log.system_triggered',
    60|                 'type'  => 'boolean',
    61|                 'alias' => $aliasPrefix.'system_triggered',
    62|             ],
    63|             $prefix.'non_action_path_taken' => [
    64|                 'label' => 'mautic.report.campaign.log.non_action_path_taken',
    65|                 'type'  => 'boolean',
    66|                 'alias' => $aliasPrefix.'non_action_path_taken',
    67|             ],
    68|             $prefix.'channel' => [
    69|                 'label' => 'mautic.report.campaign.log.channel',
    70|                 'type'  => 'string',
    71|                 'alias' => $aliasPrefix.'channel',
    72|             ],
    73|             $prefix.'channel_id' => [
    74|                 'label' => 'mautic.report.campaign.log.channel_id',
    75|                 'type'  => 'int',
    76|                 'alias' => $aliasPrefix.'channel_id',
    77|             ],
    78|             $prefix.'rotation' => [
    79|                 'label' => 'mautic.report.campaign.event.rotation',
    80|                 'type'  => 'int',
    81|                 'alias' => $eventAliasPrefix.'rotation',
    82|             ],
    83|             $eventPrefix.'name' => [
    84|                 'label' => 'mautic.report.campaign.event.name',
    85|                 'type'  => 'string',
    86|                 'alias' => $eventAliasPrefix.'name',
    87|             ],
    88|             $eventPrefix.'description' => [
    89|                 'label' => 'mautic.report.campaign.event.description',
    90|                 'type'  => 'string',
    91|                 'alias' => $eventAliasPrefix.'description',
    92|             ],
    93|             $eventPrefix.'type' => [
    94|                 'label' => 'mautic.report.campaign.event.type',
    95|                 'type'  => 'string',
    96|                 'alias' => $eventAliasPrefix.'type',
    97|             ],
    98|             $eventPrefix.'event_type' => [
    99|                 'label' => 'mautic.report.campaign.event.event_type',
   100|                 'type'  => 'string',
   101|                 'alias' => $eventAliasPrefix.'event_type',
   102|             ],
   103|             $eventPrefix.'trigger_date' => [
   104|                 'label'          => 'mautic.report.campaign.event.trigger_date',
   105|                 'type'           => 'datetime',
   106|                 'alias'          => $eventAliasPrefix.'trigger_date',
   107|                 'groupByFormula' => 'DATE('.$eventPrefix.'trigger_date)',
   108|             ],
   109|             $eventPrefix.'trigger_mode' => [
   110|                 'label' => 'mautic.report.campaign.event.trigger_mode',
   111|                 'type'  => 'string',
   112|                 'alias' => $eventAliasPrefix.'trigger_mode',
   113|             ],
   114|             $eventPrefix.'channel' => [
   115|                 'label' => 'mautic.report.campaign.event.channel',
   116|                 'type'  => 'string',
   117|                 'alias' => $eventAliasPrefix.'channel',
   118|             ],
   119|             $eventPrefix.'channel_id' => [
   120|                 'label' => 'mautic.report.campaign.event.channel_id',
   121|                 'type'  => 'int',
   122|                 'alias' => $eventAliasPrefix.'channel_id',
   123|             ],
   124|         ];
   125|         $companyColumns = $this->companyReportData->getCompanyData();
   126|         $columns = array_merge(
   127|             $columns,
   128|             $event->getStandardColumns($campaignPrefix, [], 'mautic_campaign_action'),
   129|             $event->getCategoryColumns($catPrefix),
   130|             $event->getLeadColumns($leadPrefix),
   131|             $event->getIpColumn(),
   132|             $event->getChannelColumns(),
   133|             $companyColumns
   134|         );
   135|         $data = [
   136|             'display_name' => 'mautic.campaign.events',
   137|             'columns'      => $columns,
   138|         ];
   139|         $event->addTable(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG, $data);
   140|     }
   141|     /**
   142|      * Initialize the QueryBuilder object to generate reports from.
   143|      */
   144|     public function onReportGenerate(ReportGeneratorEvent $event): void
   145|     {
   146|         if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
   147|             return;
   148|         }
   149|         $qb = $event->getQueryBuilder();
   150|         $qb->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_log', 'log')
   151|             ->leftJoin('log', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = log.campaign_id')
   152|             ->leftJoin('log', MAUTIC_TABLE_PREFIX.'campaign_events', 'e', 'e.id = log.event_id');
   153|         $event
   154|             ->addLeadLeftJoin($qb, 'log')
   155|             ->addIpAddressLeftJoin($qb, 'log')
   156|             ->addCategoryLeftJoin($qb, 'c', 'cat')
   157|             ->addChannelLeftJoins($qb, 'log');
   158|         if ($this->companyReportData->eventHasCompanyColumns($event)) {
   159|             $event->addCompanyLeftJoin($qb);
   160|         }
   161|         $event->applyDateFilters($qb, 'date_triggered', 'log');
   162|         $event->setQueryBuilder($qb);
   163|     }
   164|     /**
   165|      * Initialize the QueryBuilder object to generate reports from.
   166|      */
   167|     public function onReportGraphGenerate(ReportGraphEvent $event): void
   168|     {
   169|         if (!$event->checkContext(self::CONTEXT_CAMPAIGN_LEAD_EVENT_LOG)) {
   170|             return;
   171|         }
   172|         $graphs = $event->getRequestedGraphs();
   173|         $qb     = $event->getQueryBuilder();
   174|         foreach ($graphs as $g) {
   175|             $options      = $event->getOptions($g);
   176|             $queryBuilder = clone $qb;
   177|             /** @var ChartQuery $chartQuery */
   178|             $chartQuery = clone $options['chartQuery'];
   179|             $chartQuery->applyDateFilters($queryBuilder, 'date_triggered', 'log');
   180|             switch ($g) {
   181|                 /*
   182|                 case 'mautic.page.graph.line.hits':
   183|                     $chart = new LineChart(null, $options['dateFrom'], $options['dateTo']);
   184|                     $chartQuery->modifyTimeDataQuery($queryBuilder, 'date_hit', 'ph');
   185|                     $hits = $chartQuery->loadAndBuildTimeData($queryBuilder);
   186|                     $chart->setDataset($options['translator']->trans($g), $hits);
   187|                     $data         = $chart->render();
   188|                     $data['name'] = $g;
   189|                     $event->setGraph($g, $data);
   190|                     break;
   191|                 */
   192|             }
   193|             unset($queryBuilder);
   194|         }
   195|     }
   196| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/EventListener/SearchSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\EventListener;
     4| use Mautic\CampaignBundle\Model\CampaignModel;
     5| use Mautic\CoreBundle\CoreEvents;
     6| use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
     7| use Mautic\CoreBundle\Event as MauticEvents;
     8| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     9| use Mautic\CoreBundle\Service\GlobalSearch;
    10| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    11| class SearchSubscriber implements EventSubscriberInterface
    12| {
    13|     public function __construct(
    14|         private CampaignModel $campaignModel,
    15|         private CorePermissions $security,
    16|         private GlobalSearch $globalSearch,
    17|     ) {
    18|     }
    19|     public static function getSubscribedEvents(): array
    20|     {
    21|         return [
    22|             CoreEvents::GLOBAL_SEARCH      => ['onGlobalSearch', 0],
    23|             CoreEvents::BUILD_COMMAND_LIST => ['onBuildCommandList', 0],
    24|         ];
    25|     }
    26|     public function onGlobalSearch(MauticEvents\GlobalSearchEvent $event): void
    27|     {
    28|         $filterDTO = new GlobalSearchFilterDTO($event->getSearchString());
    29|         $results   = $this->globalSearch->performSearch(
    30|             $filterDTO,
    31|             $this->campaignModel,
    32|             '@MauticCampaign/SubscribedEvents/Search/global.html.twig'
    33|         );
    34|         if (!empty($results)) {
    35|             $event->addResults('mautic.campaign.campaigns', $results);
    36|         }
    37|     }
    38|     public function onBuildCommandList(MauticEvents\CommandListEvent $event): void
    39|     {
    40|         $security = $this->security;
    41|         if ($security->isGranted('campaign:campaigns:view')) {
    42|             $event->addCommands(
    43|                 'mautic.campaign.campaigns',
    44|                 $this->campaignModel->getCommandList()
    45|             );
    46|         }
    47|     }
    48| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/ContactFinder/InactiveContactFinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\ContactFinder;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\Common\Collections\Collection;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Entity\LeadRepository as CampaignLeadRepository;
     7| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     8| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     9| use Mautic\LeadBundle\Entity\Lead;
    10| use Mautic\LeadBundle\Entity\LeadRepository;
    11| use Psr\Log\LoggerInterface;
    12| class InactiveContactFinder
    13| {
    14|     /**
    15|      * @var array<string, \DateTimeInterface>|null
    16|      */
    17|     private ?array $campaignMemberDatesAdded = null;
    18|     public function __construct(
    19|         private LeadRepository $leadRepository,
    20|         private CampaignLeadRepository $campaignLeadRepository,
    21|         private LoggerInterface $logger,
    22|     ) {
    23|     }
    24|     /**
    25|      * @param int $campaignId
    26|      *
    27|      * @return ArrayCollection
    28|      *
    29|      * @throws NoContactsFoundException
    30|      */
    31|     public function getContacts($campaignId, Event $decisionEvent, ContactLimiter $limiter)
    32|     {
    33|         if ($limiter->hasCampaignLimit() && 0 === $limiter->getCampaignLimitRemaining()) {
    34|             return new ArrayCollection();
    35|         }
    36|         $decisionParentEvent            = $decisionEvent->getParent();
    37|         $this->campaignMemberDatesAdded = $this->campaignLeadRepository->getInactiveContacts(
    38|             $campaignId,
    39|             $decisionEvent->getId(),
    40|             ($decisionParentEvent) ? $decisionParentEvent->getId() : null,
    41|             $limiter
    42|         );
    43|         if (empty($this->campaignMemberDatesAdded)) {
    44|             throw new NoContactsFoundException();
    45|         }
    46|         $campaignContacts = array_keys($this->campaignMemberDatesAdded);
    47|         $this->logger->debug('CAMPAIGN: Processing the following contacts: '.implode(', ', $campaignContacts));
    48|         $contacts = $this->leadRepository->getContactCollection($campaignContacts);
    49|         if (!count($contacts)) {
    50|             $this->logger->debug('CAMPAIGN: No contact entities found.');
    51|             throw new NoContactsFoundException();
    52|         }
    53|         return $contacts;
    54|     }
    55|     /**
    56|      * @return array<string, \DateTimeInterface>|null
    57|      */
    58|     public function getDatesAdded(): ?array
    59|     {
    60|         return $this->campaignMemberDatesAdded;
    61|     }
    62|     /**
    63|      * @param int $campaignId
    64|      */
    65|     public function getContactCount($campaignId, array $decisionEvents, ContactLimiter $limiter): int
    66|     {
    67|         return $this->campaignLeadRepository->getInactiveContactCount($campaignId, $decisionEvents, $limiter);
    68|     }
    69|     /**
    70|      * Clear Lead entities from memory.
    71|      *
    72|      * @param Collection<int, Lead> $contacts
    73|      */
    74|     public function clear(Collection $contacts): void
    75|     {
    76|         $this->leadRepository->detachEntities($contacts->toArray());
    77|     }
    78| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/ContactFinder/KickoffContactFinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\ContactFinder;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\Common\Collections\Collection;
     5| use Mautic\CampaignBundle\Entity\CampaignRepository;
     6| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     7| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     8| use Mautic\LeadBundle\Entity\Lead;
     9| use Mautic\LeadBundle\Entity\LeadRepository;
    10| use Psr\Log\LoggerInterface;
    11| class KickoffContactFinder
    12| {
    13|     public function __construct(
    14|         private LeadRepository $leadRepository,
    15|         private CampaignRepository $campaignRepository,
    16|         private LoggerInterface $logger,
    17|     ) {
    18|     }
    19|     /**
    20|      * @param int $campaignId
    21|      *
    22|      * @return ArrayCollection
    23|      *
    24|      * @throws NoContactsFoundException
    25|      */
    26|     public function getContacts($campaignId, ContactLimiter $limiter)
    27|     {
    28|         $campaignContacts = $this->campaignRepository->getPendingContactIds($campaignId, $limiter);
    29|         if (empty($campaignContacts)) {
    30|             throw new NoContactsFoundException();
    31|         }
    32|         $this->logger->debug('CAMPAIGN: Processing the following contacts: '.implode(', ', $campaignContacts));
    33|         $contacts = $this->leadRepository->getContactCollection($campaignContacts);
    34|         if (!count($contacts)) {
    35|             $this->logger->debug('CAMPAIGN: No contact entities found.');
    36|             throw new NoContactsFoundException();
    37|         }
    38|         return $contacts;
    39|     }
    40|     /**
    41|      * @param int $campaignId
    42|      */
    43|     public function getContactCount($campaignId, array $eventIds, ContactLimiter $limiter): int
    44|     {
    45|         $countResult = $this->campaignRepository->getCountsForPendingContacts($campaignId, $eventIds, $limiter);
    46|         return $countResult->getCount();
    47|     }
    48|     /**
    49|      * Clear Lead entities from memory.
    50|      *
    51|      * @param Collection<int, Lead> $contacts
    52|      */
    53|     public function clear(Collection $contacts): void
    54|     {
    55|         $this->leadRepository->detachEntities($contacts->toArray());
    56|     }
    57| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/ContactFinder/Limiter/ContactLimiter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-171 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\ContactFinder\Limiter;
     3| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     4| class ContactLimiter
     5| {
     6|     private int $batchLimit;
     7|     private ?int $contactId;
     8|     private ?int $minContactId;
     9|     private ?int $batchMinContactId = null;
    10|     private ?int $maxContactId;
    11|     private ?int $threadId = null;
    12|     private ?int $maxThreads = null;
    13|     /**
    14|      * @var int|null
    15|      */
    16|     private $campaignLimit;
    17|     private ?int $campaignLimitUsed = null;
    18|     /**
    19|      * @param int      $batchLimit
    20|      * @param int|null $contactId
    21|      * @param int|null $minContactId
    22|      * @param int|null $maxContactId
    23|      * @param int|null $threadId
    24|      * @param int|null $maxThreads
    25|      * @param int|null $campaignLimit
    26|      */
    27|     public function __construct(
    28|         $batchLimit,
    29|         $contactId = null,
    30|         $minContactId = null,
    31|         $maxContactId = null,
    32|         private array $contactIdList = [],
    33|         $threadId = null,
    34|         $maxThreads = null,
    35|         $campaignLimit = null,
    36|     ) {
    37|         $this->batchLimit    = ($batchLimit) ? (int) $batchLimit : 100;
    38|         $this->contactId     = ($contactId) ? (int) $contactId : null;
    39|         $this->minContactId  = ($minContactId) ? (int) $minContactId : null;
    40|         $this->maxContactId  = ($maxContactId) ? (int) $maxContactId : null;
    41|         if ($threadId && $maxThreads) {
    42|             $this->threadId     = (int) $threadId;
    43|             $this->maxThreads   = (int) $maxThreads;
    44|             if ($threadId > $maxThreads) {
    45|                 throw new \InvalidArgumentException('$threadId cannot be larger than $maxThreads');
    46|             }
    47|         }
    48|         if ($campaignLimit) {
    49|             $this->campaignLimit     = $campaignLimit;
    50|             $this->campaignLimitUsed = 0;
    51|         }
    52|     }
    53|     public function getBatchLimit(): int
    54|     {
    55|         return $this->batchLimit;
    56|     }
    57|     /**
    58|      * @return int|null
    59|      */
    60|     public function getContactId()
    61|     {
    62|         return $this->contactId;
    63|     }
    64|     public function getMinContactId(): ?int
    65|     {
    66|         return $this->batchMinContactId ?: $this->minContactId;
    67|     }
    68|     /**
    69|      * @return int|null
    70|      */
    71|     public function getMaxContactId()
    72|     {
    73|         return $this->maxContactId;
    74|     }
    75|     /**
    76|      * @return array
    77|      */
    78|     public function getContactIdList()
    79|     {
    80|         return $this->contactIdList;
    81|     }
    82|     /**
    83|      * @param int $id
    84|      *
    85|      * @return $this
    86|      *
    87|      * @throws NoContactsFoundException
    88|      */
    89|     public function setBatchMinContactId($id)
    90|     {
    91|         if ($this->minContactId && $this->minContactId > (int) $id) {
    92|             throw new NoContactsFoundException();
    93|         }
    94|         if ($this->maxContactId && $this->maxContactId < (int) $id) {
    95|             throw new NoContactsFoundException();
    96|         }
    97|         if ($this->batchMinContactId && $this->batchMinContactId >= $id) {
    98|             throw new NoContactsFoundException();
    99|         }
   100|         $this->batchMinContactId = (int) $id;
   101|         return $this;
   102|     }
   103|     /**
   104|      * @return $this
   105|      */
   106|     public function resetBatchMinContactId()
   107|     {
   108|         $this->batchMinContactId =  null;
   109|         return $this;
   110|     }
   111|     /**
   112|      * @return int|null
   113|      */
   114|     public function getMaxThreads()
   115|     {
   116|         return $this->maxThreads;
   117|     }
   118|     /**
   119|      * @return int|null
   120|      */
   121|     public function getThreadId()
   122|     {
   123|         return $this->threadId;
   124|     }
   125|     /**
   126|      * @return int|null
   127|      */
   128|     public function getCampaignLimit()
   129|     {
   130|         return $this->campaignLimit;
   131|     }
   132|     public function hasCampaignLimit(): bool
   133|     {
   134|         return null !== $this->campaignLimit;
   135|     }
   136|     /**
   137|      * @return int
   138|      *
   139|      * @throws \Exception
   140|      */
   141|     public function getCampaignLimitRemaining()
   142|     {
   143|         if (!$this->hasCampaignLimit()) {
   144|             throw new \Exception('Campaign Limit was not set');
   145|         }
   146|         return $this->campaignLimit - $this->campaignLimitUsed;
   147|     }
   148|     /**
   149|      * @return $this
   150|      *
   151|      * @throws \Exception
   152|      */
   153|     public function reduceCampaignLimitRemaining($reduction)
   154|     {
   155|         if (!$this->hasCampaignLimit()) {
   156|             throw new \Exception('Campaign Limit was not set');
   157|         } elseif ($this->campaignLimit < ($this->campaignLimitUsed + $reduction)) {
   158|             throw new \Exception('Campaign Limit exceeded');
   159|         }
   160|         $this->campaignLimitUsed += $reduction;
   161|         return $this;
   162|     }
   163|     /**
   164|      * @return $this
   165|      */
   166|     public function resetCampaignLimitRemaining()
   167|     {
   168|         $this->campaignLimitUsed = 0;
   169|         return $this;
   170|     }
   171| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/ContactFinder/ScheduledContactFinder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\ContactFinder;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\Common\Collections\Collection;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     7| use Mautic\LeadBundle\Entity\Lead;
     8| use Mautic\LeadBundle\Entity\LeadRepository;
     9| use Psr\Log\LoggerInterface;
    10| class ScheduledContactFinder
    11| {
    12|     public function __construct(
    13|         private LeadRepository $leadRepository,
    14|         private LoggerInterface $logger,
    15|     ) {
    16|     }
    17|     /**
    18|      * Hydrate contacts with custom field value, companies, etc.
    19|      *
    20|      * @return Collection<int, Lead>
    21|      */
    22|     public function hydrateContacts(ArrayCollection $logs): Collection
    23|     {
    24|         $contactIds = [];
    25|         /** @var LeadEventLog $log */
    26|         foreach ($logs as $log) {
    27|             $contactIds[] = $log->getLead()->getId();
    28|         }
    29|         if (!count($contactIds)) {
    30|             $this->logger->debug('CAMPAIGN: No contact entities found.');
    31|             throw new NoContactsFoundException();
    32|         }
    33|         $contacts = $this->leadRepository->getContactCollection($contactIds);
    34|         foreach ($logs as $key => $log) {
    35|             $contactId = $log->getLead()->getId();
    36|             if (!$contact = $contacts->get($contactId)) {
    37|                 $logs->remove($key);
    38|                 continue;
    39|             }
    40|             $log->setLead($contact);
    41|         }
    42|         return $contacts;
    43|     }
    44|     /**
    45|      * Clear Lead entities from memory.
    46|      *
    47|      * @param Collection<int, Lead> $contacts
    48|      */
    49|     public function clear(Collection $contacts): void
    50|     {
    51|         $this->leadRepository->detachEntities($contacts->toArray());
    52|     }
    53| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Dispatcher/ActionDispatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Dispatcher;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Entity\LeadEventLog;
     7| use Mautic\CampaignBundle\Event\ExecutedBatchEvent;
     8| use Mautic\CampaignBundle\Event\ExecutedEvent;
     9| use Mautic\CampaignBundle\Event\FailedEvent;
    10| use Mautic\CampaignBundle\Event\PendingEvent;
    11| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
    12| use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
    13| use Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException;
    14| use Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException;
    15| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    16| use Psr\Log\LoggerInterface;
    17| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    18| class ActionDispatcher
    19| {
    20|     public function __construct(
    21|         private EventDispatcherInterface $dispatcher,
    22|         private LoggerInterface $logger,
    23|         private EventScheduler $scheduler,
    24|         private LegacyEventDispatcher $legacyDispatcher,
    25|     ) {
    26|     }
    27|     /**
    28|      * @throws LogNotProcessedException
    29|      * @throws LogPassedAndFailedException
    30|      */
    31|     public function dispatchEvent(ActionAccessor $config, Event $event, ArrayCollection $logs, PendingEvent $pendingEvent = null): PendingEvent
    32|     {
    33|         if (!$pendingEvent) {
    34|             $pendingEvent = new PendingEvent($config, $event, $logs);
    35|         }
    36|         if ($customEvent = $config->getBatchEventName()) {
    37|             $this->dispatcher->dispatch($pendingEvent, $customEvent);
    38|             $success = $pendingEvent->getSuccessful();
    39|             $failed  = $pendingEvent->getFailures();
    40|             $this->validateProcessedLogs($logs, $success, $failed);
    41|             if ($success) {
    42|                 $this->dispatchExecutedEvent($config, $event, $success);
    43|             }
    44|             if ($failed) {
    45|                 $this->dispatchFailedEvent($config, $failed);
    46|             }
    47|             $this->legacyDispatcher->dispatchExecutionEvents($config, $success, $failed);
    48|         }
    49|         $this->legacyDispatcher->dispatchCustomEvent($config, $logs, $customEvent, $pendingEvent);
    50|         return $pendingEvent;
    51|     }
    52|     private function dispatchExecutedEvent(AbstractEventAccessor $config, Event $event, ArrayCollection $logs): void
    53|     {
    54|         if (!$logs->count()) {
    55|             return;
    56|         }
    57|         foreach ($logs as $log) {
    58|             $this->dispatcher->dispatch(
    59|                 new ExecutedEvent($config, $log),
    60|                 CampaignEvents::ON_EVENT_EXECUTED
    61|             );
    62|         }
    63|         $this->dispatcher->dispatch(
    64|             new ExecutedBatchEvent($config, $event, $logs),
    65|             CampaignEvents::ON_EVENT_EXECUTED_BATCH
    66|         );
    67|     }
    68|     private function dispatchFailedEvent(AbstractEventAccessor $config, ArrayCollection $logs): void
    69|     {
    70|         if (!$logs->count()) {
    71|             return;
    72|         }
    73|         /** @var LeadEventLog $log */
    74|         foreach ($logs as $log) {
    75|             $this->logger->debug(
    76|                 'CAMPAIGN: '.ucfirst($log->getEvent()->getEventType() ?? 'unknown event').' ID# '.$log->getEvent()->getId().' for contact ID# '.$log->getLead()->getId()
    77|             );
    78|             $this->dispatcher->dispatch(
    79|                 new FailedEvent($config, $log),
    80|                 CampaignEvents::ON_EVENT_FAILED
    81|             );
    82|         }
    83|         $this->scheduler->rescheduleFailures($logs);
    84|     }
    85|     /**
    86|      * @throws LogNotProcessedException
    87|      * @throws LogPassedAndFailedException
    88|      */
    89|     private function validateProcessedLogs(ArrayCollection $pending, ArrayCollection $success, ArrayCollection $failed): void
    90|     {
    91|         foreach ($pending as $log) {
    92|             if (!$success->contains($log) && !$failed->contains($log)) {
    93|                 throw new LogNotProcessedException($log);
    94|             }
    95|             if ($success->contains($log) && $failed->contains($log)) {
    96|                 throw new LogPassedAndFailedException($log);
    97|             }
    98|         }
    99|     }
   100| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Dispatcher/ConditionDispatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Dispatcher;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\LeadEventLog;
     5| use Mautic\CampaignBundle\Event\ConditionEvent;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\ConditionAccessor;
     7| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
     8| class ConditionDispatcher
     9| {
    10|     public function __construct(
    11|         private EventDispatcherInterface $dispatcher,
    12|     ) {
    13|     }
    14|     public function dispatchEvent(ConditionAccessor $config, LeadEventLog $log): ConditionEvent
    15|     {
    16|         $event = new ConditionEvent($config, $log);
    17|         $this->dispatcher->dispatch($event, $config->getEventName());
    18|         $this->dispatcher->dispatch($event, CampaignEvents::ON_EVENT_CONDITION_EVALUATION);
    19|         return $event;
    20|     }
    21| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Dispatcher/DecisionDispatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Dispatcher;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Event\DecisionEvent;
     7| use Mautic\CampaignBundle\Event\DecisionResultsEvent;
     8| use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
     9| use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
    10| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    11| class DecisionDispatcher
    12| {
    13|     public function __construct(
    14|         private EventDispatcherInterface $dispatcher,
    15|         private LegacyEventDispatcher $legacyDispatcher,
    16|     ) {
    17|     }
    18|     /**
    19|      * @param mixed $passthrough
    20|      */
    21|     public function dispatchRealTimeEvent(DecisionAccessor $config, LeadEventLog $log, $passthrough): DecisionEvent
    22|     {
    23|         $event = new DecisionEvent($config, $log, $passthrough);
    24|         $this->dispatcher->dispatch($event, $config->getEventName());
    25|         return $event;
    26|     }
    27|     public function dispatchEvaluationEvent(DecisionAccessor $config, LeadEventLog $log): DecisionEvent
    28|     {
    29|         $event = new DecisionEvent($config, $log);
    30|         $this->dispatcher->dispatch($event, CampaignEvents::ON_EVENT_DECISION_EVALUATION);
    31|         $this->legacyDispatcher->dispatchDecisionEvent($event);
    32|         return $event;
    33|     }
    34|     public function dispatchDecisionResultsEvent(DecisionAccessor $config, ArrayCollection $logs, EvaluatedContacts $evaluatedContacts): void
    35|     {
    36|         if (!$logs->count()) {
    37|             return;
    38|         }
    39|         $this->dispatcher->dispatch(
    40|             new DecisionResultsEvent($config, $logs, $evaluatedContacts),
    41|             CampaignEvents::ON_EVENT_DECISION_EVALUATION_RESULTS
    42|         );
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Dispatcher/LegacyEventDispatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-233 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Dispatcher;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Event\CampaignDecisionEvent;
     7| use Mautic\CampaignBundle\Event\CampaignExecutionEvent;
     8| use Mautic\CampaignBundle\Event\DecisionEvent;
     9| use Mautic\CampaignBundle\Event\EventArrayTrait;
    10| use Mautic\CampaignBundle\Event\ExecutedBatchEvent;
    11| use Mautic\CampaignBundle\Event\ExecutedEvent;
    12| use Mautic\CampaignBundle\Event\FailedEvent;
    13| use Mautic\CampaignBundle\Event\PendingEvent;
    14| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
    15| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    16| use Mautic\LeadBundle\Tracker\ContactTracker;
    17| use Psr\Log\LoggerInterface;
    18| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    19| /**
    20|  * @deprecated 2.13.0 to be removed in 3.0; BC support for old listeners
    21|  */
    22| class LegacyEventDispatcher
    23| {
    24|     use EventArrayTrait;
    25|     public function __construct(
    26|         private EventDispatcherInterface $dispatcher,
    27|         private EventScheduler $scheduler,
    28|         private LoggerInterface $logger,
    29|         private ContactTracker $contactTracker,
    30|     ) {
    31|     }
    32|     public function dispatchCustomEvent(
    33|         AbstractEventAccessor $config,
    34|         ArrayCollection $logs,
    35|         $wasBatchProcessed,
    36|         PendingEvent $pendingEvent,
    37|     ): void {
    38|         $settings = $config->getConfig();
    39|         if (!isset($settings['eventName']) && !isset($settings['callback'])) {
    40|             if (!$wasBatchProcessed) {
    41|                 $pendingEvent->failAll('Invalid event configuration');
    42|             }
    43|             return;
    44|         }
    45|         $rescheduleFailures = new ArrayCollection();
    46|         /** @var LeadEventLog $log */
    47|         foreach ($logs as $log) {
    48|             $this->contactTracker->setSystemContact($log->getLead());
    49|             if (isset($settings['eventName'])) {
    50|                 $event  = $this->dispatchEventName($settings['eventName'], $settings, $log);
    51|                 $result = $event->getResult();
    52|             } else {
    53|                 if (!is_callable($settings['callback'])) {
    54|                     break;
    55|                 }
    56|                 $result = $this->dispatchCallback($settings, $log);
    57|             }
    58|             if (!$wasBatchProcessed) {
    59|                 $this->dispatchExecutionEvent($config, $log, $result);
    60|                 if (!is_bool($result)) {
    61|                     $log->appendToMetadata($result);
    62|                 }
    63|                 if ($this->isFailed($result)) {
    64|                     $this->processFailedLog($log, $pendingEvent);
    65|                     $rescheduleFailures->set($log->getId(), $log);
    66|                     $this->dispatchFailedEvent($config, $log);
    67|                     continue;
    68|                 }
    69|                 if (is_array($result) && !empty($result['failed']) && isset($result['reason'])) {
    70|                     $pendingEvent->passWithError($log, (string) $result['reason']);
    71|                 } else {
    72|                     $pendingEvent->pass($log);
    73|                 }
    74|                 $this->dispatchExecutedEvent($config, $log);
    75|             }
    76|         }
    77|         if ($rescheduleFailures->count()) {
    78|             $this->scheduler->rescheduleFailures($rescheduleFailures);
    79|         }
    80|         $this->contactTracker->setSystemContact(null);
    81|     }
    82|     /**
    83|      * Execute the new ON_EVENT_FAILED and ON_EVENT_EXECUTED events for logs processed by BC code.
    84|      */
    85|     public function dispatchExecutionEvents(AbstractEventAccessor $config, ArrayCollection $success, ArrayCollection $failures): void
    86|     {
    87|         foreach ($success as $log) {
    88|             $this->dispatchExecutionEvent($config, $log, true);
    89|         }
    90|         foreach ($failures as $log) {
    91|             $this->dispatchExecutionEvent($config, $log, false);
    92|         }
    93|     }
    94|     public function dispatchDecisionEvent(DecisionEvent $decisionEvent): void
    95|     {
    96|         if ($this->dispatcher->hasListeners(CampaignEvents::ON_EVENT_DECISION_TRIGGER)) {
    97|             $log   = $decisionEvent->getLog();
    98|             $event = $log->getEvent();
    99|             $legacyDecisionEvent = $this->dispatcher->dispatch(
   100|                 new CampaignDecisionEvent(
   101|                     $log->getLead(),
   102|                     $event->getType(),
   103|                     $decisionEvent->getEventConfig()->getConfig(),
   104|                     $this->getLegacyEventsArray($log),
   105|                     $this->getLegacyEventsConfigArray($event, $decisionEvent->getEventConfig()),
   106|                     0 === $event->getOrder(),
   107|                     [$log]
   108|                 ),
   109|                 CampaignEvents::ON_EVENT_DECISION_TRIGGER
   110|             );
   111|             if ($legacyDecisionEvent->wasDecisionTriggered()) {
   112|                 $decisionEvent->setAsApplicable();
   113|             }
   114|         }
   115|     }
   116|     private function dispatchEventName($eventName, array $settings, LeadEventLog $log): CampaignExecutionEvent
   117|     {
   118|         @trigger_error('eventName is deprecated. Convert to using batchEventName.', E_USER_DEPRECATED);
   119|         $campaignEvent = new CampaignExecutionEvent(
   120|             [
   121|                 'eventSettings'   => $settings,
   122|                 'eventDetails'    => null,
   123|                 'event'           => $log->getEvent(),
   124|                 'lead'            => $log->getLead(),
   125|                 'systemTriggered' => $log->getSystemTriggered(),
   126|             ],
   127|             null,
   128|             $log
   129|         );
   130|         $this->dispatcher->dispatch($campaignEvent, $eventName);
   131|         if ($channel = $campaignEvent->getChannel()) {
   132|             $log->setChannel($channel);
   133|             $log->setChannelId($campaignEvent->getChannelId());
   134|         }
   135|         return $campaignEvent;
   136|     }
   137|     /**
   138|      * @return mixed
   139|      */
   140|     private function dispatchCallback(array $settings, LeadEventLog $log)
   141|     {
   142|         @trigger_error('callback is deprecated. Convert to using batchEventName.', E_USER_DEPRECATED);
   143|         $eventArray = $this->getEventArray($log->getEvent());
   144|         $args       = [
   145|             'eventSettings'   => $settings,
   146|             'eventDetails'    => null, // @todo fix when procesing decisions,
   147|             'event'           => $eventArray,
   148|             'lead'            => $log->getLead(),
   149|             'systemTriggered' => $log->getSystemTriggered(),
   150|             'config'          => $eventArray['properties'],
   151|         ];
   152|         try {
   153|             if (is_array($settings['callback'])) {
   154|                 $reflection = new \ReflectionMethod($settings['callback'][0], $settings['callback'][1]);
   155|             } elseif (str_contains($settings['callback'], '::')) {
   156|                 $parts      = explode('::', $settings['callback']);
   157|                 $reflection = new \ReflectionMethod($parts[0], $parts[1]);
   158|             } else {
   159|                 $reflection = new \ReflectionMethod(null, $settings['callback']);
   160|             }
   161|             $pass = [];
   162|             foreach ($reflection->getParameters() as $param) {
   163|                 if (isset($args[$param->getName()])) {
   164|                     $pass[] = $args[$param->getName()];
   165|                 } else {
   166|                     $pass[] = null;
   167|                 }
   168|             }
   169|             return $reflection->invokeArgs($this, $pass);
   170|         } catch (\ReflectionException) {
   171|             return false;
   172|         }
   173|     }
   174|     private function dispatchExecutionEvent(AbstractEventAccessor $config, LeadEventLog $log, $result): void
   175|     {
   176|         $eventArray = $this->getEventArray($log->getEvent());
   177|         $this->dispatcher->dispatch(
   178|             new CampaignExecutionEvent(
   179|                 [
   180|                     'eventSettings'   => $config->getConfig(),
   181|                     'eventDetails'    => null, // @todo fix when procesing decisions,
   182|                     'event'           => $eventArray,
   183|                     'lead'            => $log->getLead(),
   184|                     'systemTriggered' => $log->getSystemTriggered(),
   185|                     'config'          => $eventArray['properties'],
   186|                 ],
   187|                 $result,
   188|                 $log
   189|             ),
   190|             CampaignEvents::ON_EVENT_EXECUTION
   191|         );
   192|     }
   193|     private function dispatchExecutedEvent(AbstractEventAccessor $config, LeadEventLog $log): void
   194|     {
   195|         $this->dispatcher->dispatch(
   196|             new ExecutedEvent($config, $log),
   197|             CampaignEvents::ON_EVENT_EXECUTED
   198|         );
   199|         $collection = new ArrayCollection();
   200|         $collection->set($log->getId(), $log);
   201|         $this->dispatcher->dispatch(
   202|             new ExecutedBatchEvent($config, $log->getEvent(), $collection),
   203|             CampaignEvents::ON_EVENT_EXECUTED_BATCH
   204|         );
   205|     }
   206|     private function dispatchFailedEvent(AbstractEventAccessor $config, LeadEventLog $log): void
   207|     {
   208|         $this->dispatcher->dispatch(
   209|             new FailedEvent($config, $log),
   210|             CampaignEvents::ON_EVENT_FAILED
   211|         );
   212|     }
   213|     private function isFailed($result): bool
   214|     {
   215|         return
   216|             false === $result
   217|             || (is_array($result) && isset($result['result']) && false === $result['result']);
   218|     }
   219|     private function processFailedLog(LeadEventLog $log, PendingEvent $pendingEvent): void
   220|     {
   221|         $this->logger->debug(
   222|             'CAMPAIGN: '.ucfirst($log->getEvent()->getEventType() ?? 'unknown event').' ID# '.$log->getEvent()->getId().' for contact ID# '.$log->getLead()->getId()
   223|         );
   224|         $metadata = $log->getMetadata();
   225|         $reason = null;
   226|         if (isset($metadata['errors'])) {
   227|             $reason = (is_array($metadata['errors'])) ? implode('<br />', $metadata['errors']) : $metadata['errors'];
   228|         } elseif (isset($metadata['reason'])) {
   229|             $reason = $metadata['reason'];
   230|         }
   231|         $pendingEvent->fail($log, $reason);
   232|     }
   233| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Event/ActionExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     7| use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
     8| use Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher;
     9| use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
    10| use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
    11| use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
    12| class ActionExecutioner implements EventInterface
    13| {
    14|     public const TYPE = 'action';
    15|     public function __construct(
    16|         private ActionDispatcher $dispatcher,
    17|         private EventLogger $eventLogger,
    18|     ) {
    19|     }
    20|     /**
    21|      * @throws CannotProcessEventException
    22|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
    23|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
    24|      */
    25|     public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
    26|     {
    27|         \assert($config instanceof ActionAccessor);
    28|         /** @var LeadEventLog $firstLog */
    29|         if (!$firstLog = $logs->first()) {
    30|             return new EvaluatedContacts();
    31|         }
    32|         $event = $firstLog->getEvent();
    33|         if (Event::TYPE_ACTION !== $event->getEventType()) {
    34|             throw new CannotProcessEventException('Cannot process event ID '.$event->getId().' as an action.');
    35|         }
    36|         $pendingEvent = $this->dispatcher->dispatchEvent($config, $event, $logs);
    37|         $passed = $this->eventLogger->extractContactsFromLogs($pendingEvent->getSuccessful());
    38|         $failed = $this->eventLogger->extractContactsFromLogs($pendingEvent->getFailures());
    39|         return new EvaluatedContacts($passed, $failed);
    40|     }
    41| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Event/ConditionExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     7| use Mautic\CampaignBundle\EventCollector\Accessor\Event\ConditionAccessor;
     8| use Mautic\CampaignBundle\Executioner\Dispatcher\ConditionDispatcher;
     9| use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
    10| use Mautic\CampaignBundle\Executioner\Exception\ConditionFailedException;
    11| use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
    12| class ConditionExecutioner implements EventInterface
    13| {
    14|     public const TYPE = 'condition';
    15|     public function __construct(
    16|         private ConditionDispatcher $dispatcher,
    17|     ) {
    18|     }
    19|     /**
    20|      * @throws CannotProcessEventException
    21|      */
    22|     public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
    23|     {
    24|         \assert($config instanceof ConditionAccessor);
    25|         $evaluatedContacts = new EvaluatedContacts();
    26|         /** @var LeadEventLog $log */
    27|         foreach ($logs as $log) {
    28|             try {
    29|                 /* @var ConditionAccessor $config */
    30|                 $this->dispatchEvent($config, $log);
    31|                 $evaluatedContacts->pass($log->getLead());
    32|             } catch (ConditionFailedException) {
    33|                 $evaluatedContacts->fail($log->getLead());
    34|                 $log->setNonActionPathTaken(true);
    35|             }
    36|             $log->setDateTriggered(new \DateTime());
    37|         }
    38|         return $evaluatedContacts;
    39|     }
    40|     /**
    41|      * @throws CannotProcessEventException
    42|      * @throws ConditionFailedException
    43|      */
    44|     private function dispatchEvent(ConditionAccessor $config, LeadEventLog $log): void
    45|     {
    46|         if (Event::TYPE_CONDITION !== $log->getEvent()->getEventType()) {
    47|             throw new CannotProcessEventException('Cannot process event ID '.$log->getEvent()->getId().' as a condition.');
    48|         }
    49|         $conditionEvent = $this->dispatcher->dispatchEvent($config, $log);
    50|         if (!$conditionEvent->wasConditionSatisfied()) {
    51|             throw new ConditionFailedException('evaluation failed');
    52|         }
    53|     }
    54| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Event/DecisionExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Event;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     7| use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
     8| use Mautic\CampaignBundle\Executioner\Dispatcher\DecisionDispatcher;
     9| use Mautic\CampaignBundle\Executioner\Exception\CannotProcessEventException;
    10| use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
    11| use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
    12| use Mautic\CampaignBundle\Executioner\Result\EvaluatedContacts;
    13| use Mautic\LeadBundle\Entity\Lead;
    14| class DecisionExecutioner implements EventInterface
    15| {
    16|     public const TYPE = 'decision';
    17|     public function __construct(
    18|         private EventLogger $eventLogger,
    19|         private DecisionDispatcher $dispatcher,
    20|     ) {
    21|     }
    22|     /**
    23|      * @param mixed       $passthrough
    24|      * @param string|null $channel
    25|      * @param int|null    $channelId
    26|      *
    27|      * @throws CannotProcessEventException
    28|      * @throws DecisionNotApplicableException
    29|      */
    30|     public function evaluateForContact(DecisionAccessor $config, Event $event, Lead $contact, $passthrough = null, $channel = null, $channelId = null): void
    31|     {
    32|         if (Event::TYPE_DECISION !== $event->getEventType()) {
    33|             throw new CannotProcessEventException('Cannot process event ID '.$event->getId().' as a decision.');
    34|         }
    35|         $log = $this->eventLogger->buildLogEntry($event, $contact);
    36|         $log->setChannel($channel);
    37|         $log->setChannelId($channelId);
    38|         $decisionEvent = $this->dispatcher->dispatchRealTimeEvent($config, $log, $passthrough);
    39|         if (!$decisionEvent->wasDecisionApplicable()) {
    40|             throw new DecisionNotApplicableException('evaluation failed');
    41|         }
    42|         $this->eventLogger->persistLog($log);
    43|     }
    44|     /**
    45|      * @throws CannotProcessEventException
    46|      */
    47|     public function execute(AbstractEventAccessor $config, ArrayCollection $logs): EvaluatedContacts
    48|     {
    49|         \assert($config instanceof DecisionAccessor);
    50|         $evaluatedContacts = new EvaluatedContacts();
    51|         $failedLogs        = [];
    52|         /** @var LeadEventLog $log */
    53|         foreach ($logs as $log) {
    54|             if (Event::TYPE_DECISION !== $log->getEvent()->getEventType()) {
    55|                 throw new CannotProcessEventException('Event ID '.$log->getEvent()->getId().' is not a decision');
    56|             }
    57|             try {
    58|                 /* @var DecisionAccessor $config */
    59|                 $this->dispatchEvent($config, $log);
    60|                 $evaluatedContacts->pass($log->getLead());
    61|                 $log->setDateTriggered(new \DateTime());
    62|             } catch (DecisionNotApplicableException) {
    63|                 $failedLogs[] = $log;
    64|                 $evaluatedContacts->fail($log->getLead());
    65|             }
    66|         }
    67|         $this->dispatcher->dispatchDecisionResultsEvent($config, $logs, $evaluatedContacts);
    68|         foreach ($failedLogs as $log) {
    69|             $logs->removeElement($log);
    70|         }
    71|         return $evaluatedContacts;
    72|     }
    73|     /**
    74|      * @throws DecisionNotApplicableException
    75|      */
    76|     private function dispatchEvent(DecisionAccessor $config, LeadEventLog $log): void
    77|     {
    78|         $decisionEvent = $this->dispatcher->dispatchEvaluationEvent($config, $log);
    79|         if (!$decisionEvent->wasDecisionApplicable()) {
    80|             throw new DecisionNotApplicableException('evaluation failed');
    81|         }
    82|     }
    83| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Helper/DecisionHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Executioner\Helper;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadRepository;
     6| use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
     7| use Mautic\LeadBundle\Entity\Lead;
     8| class DecisionHelper
     9| {
    10|     public function __construct(
    11|         private LeadRepository $leadRepository,
    12|     ) {
    13|     }
    14|     /**
    15|      * @throws DecisionNotApplicableException
    16|      */
    17|     public function checkIsDecisionApplicableForContact(Event $event, Lead $contact, ?string $channel = null, ?int $channelId = null): void
    18|     {
    19|         if (Event::TYPE_DECISION !== $event->getEventType()) {
    20|             @trigger_error(
    21|                 "{$event->getType()} is not assigned to a decision and no longer supported. ".
    22|                 'Check that you are executing RealTimeExecutioner::execute for an event registered as a decision.',
    23|                 E_USER_DEPRECATED
    24|             );
    25|             throw new DecisionNotApplicableException("Event {$event->getId()} is not a decision.");
    26|         }
    27|         if ($channel && $event->getChannel() && !str_contains($channel, $event->getChannel())) {
    28|             throw new DecisionNotApplicableException("Channels, $channel and {$event->getChannel()}, do not match.");
    29|         }
    30|         if ($channel && $channelId && $event->getChannelId() && $channelId !== $event->getChannelId()) {
    31|             throw new DecisionNotApplicableException("Channel IDs, $channelId and {$event->getChannelId()}, do not match for $channel.");
    32|         }
    33|         $parentEvent = $event->getParent();
    34|         if (null !== $parentEvent && !$parentEvent->isDeleted() && null !== $event->getDecisionPath()) {
    35|             $rotation      = $this->leadRepository->getContactRotations([$contact->getId()], $event->getCampaign()->getId());
    36|             $rotationValue = isset($rotation[$contact->getId()]) ? $rotation[$contact->getId()]['rotation'] : null;
    37|             $log           = $parentEvent->getLogByContactAndRotation($contact, $rotationValue);
    38|             if (null === $log) {
    39|                 throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} has not been fired, event {$event->getId()} should not be fired.");
    40|             }
    41|             $pathTaken   = (int) $log->getNonActionPathTaken();
    42|             if (1 === $pathTaken && !$parentEvent->getNegativeChildren()->contains($event)) {
    43|                 throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} take negative path, event {$event->getId()} is on positive path.");
    44|             } elseif (0 === $pathTaken && !$parentEvent->getPositiveChildren()->contains($event)) {
    45|                 throw new DecisionNotApplicableException("Parent {$parentEvent->getId()} take positive path, event {$event->getId()} is on negative path.");
    46|             }
    47|         }
    48|     }
    49| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Helper/InactiveHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-125 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Helper;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\EventRepository;
     6| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     7| use Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder;
     8| use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
     9| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    10| use Psr\Log\LoggerInterface;
    11| class InactiveHelper
    12| {
    13|     private ?\DateTimeInterface $earliestInactiveDate = null;
    14|     public function __construct(
    15|         private EventScheduler $scheduler,
    16|         private InactiveContactFinder $inactiveContactFinder,
    17|         private LeadEventLogRepository $eventLogRepository,
    18|         private EventRepository $eventRepository,
    19|         private LoggerInterface $logger,
    20|         private DecisionHelper $decisionHelper,
    21|     ) {
    22|     }
    23|     /**
    24|      * @param ArrayCollection<int, Event> $decisions
    25|      */
    26|     public function removeDecisionsWithoutNegativeChildren(ArrayCollection $decisions): void
    27|     {
    28|         /**
    29|          * @var int   $key
    30|          * @var Event $decision
    31|          */
    32|         foreach ($decisions as $key => $decision) {
    33|             $negativeChildren = $decision->getNegativeChildren();
    34|             if (!$negativeChildren->count()) {
    35|                 $decisions->remove($key);
    36|             }
    37|         }
    38|     }
    39|     /**
    40|      * @param int $lastActiveEventId
    41|      *
    42|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
    43|      */
    44|     public function removeContactsThatAreNotApplicable(
    45|         \DateTime $now,
    46|         ArrayCollection $contacts,
    47|         $lastActiveEventId,
    48|         ArrayCollection $negativeChildren,
    49|         Event $event,
    50|     ): void {
    51|         $contactIds                 = $contacts->getKeys();
    52|         $lastActiveDates            = $this->getLastActiveDates($lastActiveEventId, $contactIds);
    53|         $this->earliestInactiveDate = $now;
    54|         foreach ($contactIds as $contactId) {
    55|             try {
    56|                 $this->decisionHelper->checkIsDecisionApplicableForContact($event, $contacts->get($contactId));
    57|             } catch (DecisionNotApplicableException $e) {
    58|                 $this->logger->debug($e->getMessage());
    59|                 $contacts->remove($contactId);
    60|                 continue;
    61|             }
    62|             if (!isset($lastActiveDates[$contactId])) {
    63|                 $contacts->remove($contactId);
    64|                 $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' does not have a last active date ('.$lastActiveEventId.')');
    65|                 continue;
    66|             }
    67|             $earliestContactInactiveDate = $this->getEarliestInactiveDate($negativeChildren, $lastActiveDates[$contactId]);
    68|             $this->logger->debug(
    69|                 'CAMPAIGN: Earliest date for inactivity for contact ID# '.$contactId.' is '.
    70|                 $earliestContactInactiveDate->format('Y-m-d H:i:s T').' based on last active date of '.
    71|                 $lastActiveDates[$contactId]->format('Y-m-d H:i:s T')
    72|             );
    73|             if ($this->earliestInactiveDate < $earliestContactInactiveDate) {
    74|                 $this->earliestInactiveDate = $earliestContactInactiveDate;
    75|             }
    76|             if ($earliestContactInactiveDate > $now) {
    77|                 $contacts->remove($contactId);
    78|                 $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' has been active and thus not applicable');
    79|                 continue;
    80|             }
    81|             $this->logger->debug('CAMPAIGN: Contact ID# '.$contactId.' has not been active');
    82|         }
    83|     }
    84|     /**
    85|      * @return \DateTimeInterface
    86|      */
    87|     public function getEarliestInactiveDateTime()
    88|     {
    89|         return $this->earliestInactiveDate;
    90|     }
    91|     public function getCollectionByDecisionId($decisionId): ArrayCollection
    92|     {
    93|         $collection = new ArrayCollection();
    94|         /** @var Event|null $decision */
    95|         $decision = $this->eventRepository->find($decisionId);
    96|         if ($decision && !$decision->isDeleted()) {
    97|             $collection->set($decision->getId(), $decision);
    98|         }
    99|         return $collection;
   100|     }
   101|     /**
   102|      * @throws \Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException
   103|      */
   104|     public function getEarliestInactiveDate(ArrayCollection $negativeChildren, \DateTimeInterface $lastActiveDate): ?\DateTimeInterface
   105|     {
   106|         $earliestDate = null;
   107|         foreach ($negativeChildren as $event) {
   108|             $executionDate = $this->scheduler->getExecutionDateTime($event, $lastActiveDate);
   109|             if (!$earliestDate || $executionDate < $earliestDate) {
   110|                 $earliestDate = $executionDate;
   111|             }
   112|         }
   113|         return $earliestDate;
   114|     }
   115|     /**
   116|      * @return array<string, \DateTimeInterface>|null
   117|      */
   118|     private function getLastActiveDates($lastActiveEventId, array $contactIds): ?array
   119|     {
   120|         if ($lastActiveEventId) {
   121|             return $this->eventLogRepository->getDatesExecuted($lastActiveEventId, $contactIds);
   122|         }
   123|         return $this->inactiveContactFinder->getDatesAdded();
   124|     }
   125| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Helper/NotificationHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Helper;
     3| use Mautic\CampaignBundle\Entity\Event;
     4| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     5| use Mautic\CoreBundle\Model\NotificationModel;
     6| use Mautic\LeadBundle\Entity\Lead;
     7| use Mautic\UserBundle\Entity\User;
     8| use Mautic\UserBundle\Model\UserModel;
     9| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    10| use Symfony\Component\Routing\Router;
    11| use Symfony\Contracts\Translation\TranslatorInterface;
    12| class NotificationHelper
    13| {
    14|     public function __construct(
    15|         private UserModel $userModel,
    16|         private NotificationModel $notificationModel,
    17|         private TranslatorInterface $translator,
    18|         private Router $router,
    19|         private CoreParametersHelper $coreParametersHelper,
    20|     ) {
    21|     }
    22|     public function notifyOfFailure(Lead $contact, Event $event): void
    23|     {
    24|         $user = $this->getUser($contact, $event);
    25|         if (!$user || !$user->getId()) {
    26|             return;
    27|         }
    28|         $this->notificationModel->addNotification(
    29|             $event->getCampaign()->getName().' / '.$event->getName(),
    30|             'error',
    31|             false,
    32|             $this->translator->trans(
    33|                 'mautic.campaign.event.failed',
    34|                 [
    35|                     '%contact%' => '<a href="'.$this->router->generate(
    36|                         'mautic_contact_action',
    37|                         ['objectAction' => 'view', 'objectId' => $contact->getId()]
    38|                     ).'" data-toggle="ajax">'.$contact->getPrimaryIdentifier().'</a>',
    39|                 ]
    40|             ),
    41|             null,
    42|             null,
    43|             $user
    44|         );
    45|     }
    46|     public function notifyOfUnpublish(Event $event): void
    47|     {
    48|         /**
    49|          * Pass a fake lead so we can just get the campaign creator.
    50|          */
    51|         $user = $this->getUser(new Lead(), $event);
    52|         if (!$user || !$user->getId()) {
    53|             return;
    54|         }
    55|         $campaign = $event->getCampaign();
    56|         $this->notificationModel->addNotification(
    57|             $campaign->getName().' / '.$event->getName(),
    58|             'error',
    59|             false,
    60|             $this->translator->trans(
    61|                 'mautic.campaign.event.failed.campaign.unpublished',
    62|                 [
    63|                     '%campaign%' => '<a href="'.$this->router->generate(
    64|                         'mautic_campaign_action',
    65|                         [
    66|                             'objectAction' => 'view',
    67|                             'objectId'     => $campaign->getId(),
    68|                         ],
    69|                         UrlGeneratorInterface::ABSOLUTE_URL
    70|                     ).'" data-toggle="ajax">'.$campaign->getName().'</a>',
    71|                     '%event%' => $event->getName(),
    72|                 ]
    73|             ),
    74|             null,
    75|             null,
    76|             $user
    77|         );
    78|         $subject = $this->translator->trans(
    79|             'mautic.campaign.event.campaign_unpublished',
    80|             [
    81|                 '%title%' => $campaign->getName(),
    82|             ]
    83|         );
    84|         $content = $this->translator->trans(
    85|             'mautic.campaign.event.failed.campaign.unpublished',
    86|             [
    87|                 '%campaign%' => '<a href="'.$this->router->generate(
    88|                     'mautic_campaign_action',
    89|                     [
    90|                         'objectAction' => 'view',
    91|                         'objectId'     => $campaign->getId(),
    92|                     ],
    93|                     UrlGeneratorInterface::ABSOLUTE_URL
    94|                 ).'" data-toggle="ajax">'.$campaign->getName().'</a>',
    95|                 '%event%' => $event->getName(),
    96|             ]
    97|         );
    98|         $sendToAuthor = $this->coreParametersHelper->get('campaign_send_notification_to_author', 1);
    99|         if ($sendToAuthor) {
   100|             $this->userModel->emailUser($user, $subject, $content);
   101|         } else {
   102|             $emailAddresses =  array_map('trim', explode(',', $this->coreParametersHelper->get('campaign_notification_email_addresses')));
   103|             $this->userModel->sendMailToEmailAddresses($emailAddresses, $subject, $content);
   104|         }
   105|     }
   106|     /**
   107|      * @return User|null
   108|      */
   109|     private function getUser(Lead $contact, Event $event)
   110|     {
   111|         if ($owner = $contact->getOwner()) {
   112|             return $owner;
   113|         }
   114|         if ($campaignCreator = $event->getCampaign()->getCreatedBy()) {
   115|             if ($owner = $this->userModel->getEntity($campaignCreator)) {
   116|                 return $owner;
   117|             }
   118|         }
   119|         return $this->userModel->getSystemAdministrator();
   120|     }
   121| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/InactiveExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-230 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Campaign;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Executioner\ContactFinder\InactiveContactFinder;
     7| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     8| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     9| use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
    10| use Mautic\CampaignBundle\Executioner\Helper\InactiveHelper;
    11| use Mautic\CampaignBundle\Executioner\Result\Counter;
    12| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    13| use Mautic\CoreBundle\Helper\ProgressBarHelper;
    14| use Psr\Log\LoggerInterface;
    15| use Symfony\Component\Console\Output\NullOutput;
    16| use Symfony\Component\Console\Output\OutputInterface;
    17| use Symfony\Contracts\Translation\TranslatorInterface;
    18| class InactiveExecutioner implements ExecutionerInterface
    19| {
    20|     /**
    21|      * @var Campaign
    22|      */
    23|     private $campaign;
    24|     private ?ContactLimiter $limiter = null;
    25|     private ?OutputInterface $output = null;
    26|     private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
    27|     private ?Counter $counter = null;
    28|     private ?ArrayCollection $decisions = null;
    29|     protected ?\DateTime $now = null;
    30|     public function __construct(
    31|         private InactiveContactFinder $inactiveContactFinder,
    32|         private LoggerInterface $logger,
    33|         private TranslatorInterface $translator,
    34|         private EventScheduler $scheduler,
    35|         private InactiveHelper $helper,
    36|         private EventExecutioner $executioner,
    37|     ) {
    38|     }
    39|     /**
    40|      * @return Counter
    41|      *
    42|      * @throws Dispatcher\Exception\LogNotProcessedException
    43|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    44|      * @throws Exception\CannotProcessEventException
    45|      * @throws Scheduler\Exception\NotSchedulableException
    46|      */
    47|     public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
    48|     {
    49|         $this->campaign = $campaign;
    50|         $this->limiter  = $limiter;
    51|         $this->output   = $output ?: new NullOutput();
    52|         $this->counter  = new Counter();
    53|         try {
    54|             $this->decisions = $this->campaign->getEventsByType(Event::TYPE_DECISION);
    55|             $this->prepareForExecution();
    56|             $this->executeEvents();
    57|         } catch (NoContactsFoundException) {
    58|             $this->logger->debug('CAMPAIGN: No more contacts to process');
    59|         } catch (NoEventsFoundException) {
    60|             $this->logger->debug('CAMPAIGN: No events to process');
    61|         } finally {
    62|             if ($this->progressBar) {
    63|                 $this->progressBar->finish();
    64|             }
    65|         }
    66|         return $this->counter;
    67|     }
    68|     /**
    69|      * @param int $decisionId
    70|      *
    71|      * @return Counter
    72|      *
    73|      * @throws Dispatcher\Exception\LogNotProcessedException
    74|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    75|      * @throws Exception\CannotProcessEventException
    76|      * @throws Scheduler\Exception\NotSchedulableException
    77|      */
    78|     public function validate($decisionId, ContactLimiter $limiter, OutputInterface $output = null)
    79|     {
    80|         $this->limiter = $limiter;
    81|         $this->output  = $output ?: new NullOutput();
    82|         $this->counter = new Counter();
    83|         try {
    84|             $this->decisions = $this->helper->getCollectionByDecisionId($decisionId);
    85|             $this->checkCampaignIsPublished();
    86|             $this->prepareForExecution();
    87|             $this->executeEvents();
    88|         } catch (NoContactsFoundException) {
    89|             $this->logger->debug('CAMPAIGN: No more contacts to process');
    90|         } catch (NoEventsFoundException) {
    91|             $this->logger->debug('CAMPAIGN: No events to process');
    92|         } finally {
    93|             if ($this->progressBar) {
    94|                 $this->progressBar->finish();
    95|             }
    96|         }
    97|         return $this->counter;
    98|     }
    99|     /**
   100|      * @throws NoEventsFoundException
   101|      */
   102|     private function checkCampaignIsPublished(): void
   103|     {
   104|         if (!$this->decisions->count()) {
   105|             throw new NoEventsFoundException();
   106|         }
   107|         $this->campaign = $this->decisions->first()->getCampaign();
   108|         if (!$this->campaign->isPublished()) {
   109|             throw new NoEventsFoundException();
   110|         }
   111|         if ($this->campaign->isDeleted()) {
   112|             throw new NoEventsFoundException();
   113|         }
   114|     }
   115|     /**
   116|      * @throws NoContactsFoundException
   117|      * @throws NoEventsFoundException
   118|      */
   119|     private function prepareForExecution(): void
   120|     {
   121|         $this->logger->debug('CAMPAIGN: Triggering inaction events');
   122|         $this->helper->removeDecisionsWithoutNegativeChildren($this->decisions);
   123|         $totalDecisions = $this->decisions->count();
   124|         if (!$totalDecisions) {
   125|             throw new NoEventsFoundException();
   126|         }
   127|         $totalContacts = 0;
   128|         if (!($this->output instanceof NullOutput)) {
   129|             $totalContacts = $this->inactiveContactFinder->getContactCount($this->campaign->getId(), $this->decisions->getKeys(), $this->limiter);
   130|             $this->output->writeln(
   131|                 $this->translator->trans(
   132|                     'mautic.campaign.trigger.decision_count_analyzed',
   133|                     [
   134|                         '%decisions%' => $totalDecisions,
   135|                         '%leads%'     => $totalContacts,
   136|                         '%batch%'     => $this->limiter->getBatchLimit(),
   137|                     ]
   138|                 )
   139|             );
   140|             if (!$totalContacts) {
   141|                 throw new NoContactsFoundException();
   142|             }
   143|         }
   144|         $this->progressBar = ProgressBarHelper::init($this->output, $totalContacts * $totalDecisions);
   145|         $this->progressBar->start();
   146|     }
   147|     /**
   148|      * @throws Dispatcher\Exception\LogNotProcessedException
   149|      * @throws Dispatcher\Exception\LogPassedAndFailedException
   150|      * @throws Exception\CannotProcessEventException
   151|      * @throws Scheduler\Exception\NotSchedulableException
   152|      */
   153|     private function executeEvents(): void
   154|     {
   155|         $now = $this->now ?? new \DateTime();
   156|         /** @var Event $decisionEvent */
   157|         foreach ($this->decisions as $decisionEvent) {
   158|             try {
   159|                 $parentEvent   = $decisionEvent->getParent();
   160|                 $parentEventId = $parentEvent && !$parentEvent->isDeleted() ? $parentEvent->getId() : null;
   161|                 $contacts = $this->inactiveContactFinder->getContacts($this->campaign->getId(), $decisionEvent, $this->limiter);
   162|                 while ($contacts->count()) {
   163|                     $batchMinContactId = max($contacts->getKeys()) + 1;
   164|                     $this->progressBar->advance($contacts->count());
   165|                     $this->counter->advanceEvaluated($contacts->count());
   166|                     $inactiveEvents = $decisionEvent->getNegativeChildren();
   167|                     $this->helper->removeContactsThatAreNotApplicable($now, $contacts, $parentEventId, $inactiveEvents, $decisionEvent);
   168|                     $earliestLastActiveDateTime = $this->helper->getEarliestInactiveDateTime();
   169|                     $this->logger->debug(
   170|                         'CAMPAIGN: ('.$decisionEvent->getId().') Earliest date for inactivity for this batch of contacts is '.
   171|                         $earliestLastActiveDateTime->format('Y-m-d H:i:s T')
   172|                     );
   173|                     if ($contacts->count()) {
   174|                         $this->executioner->recordLogsAsExecutedForEvent($decisionEvent, $contacts, true);
   175|                         $this->executeLogsForInactiveEvents($inactiveEvents, $contacts, $this->counter, $earliestLastActiveDateTime);
   176|                     }
   177|                     $this->inactiveContactFinder->clear($contacts);
   178|                     if ($this->limiter->getContactId()) {
   179|                         break;
   180|                     }
   181|                     $this->logger->debug('CAMPAIGN: Fetching the next batch of inactive contacts starting with contact ID '.$batchMinContactId);
   182|                     $this->limiter->setBatchMinContactId($batchMinContactId);
   183|                     $contacts = $this->inactiveContactFinder->getContacts($this->campaign->getId(), $decisionEvent, $this->limiter);
   184|                 }
   185|             } catch (NoContactsFoundException) {
   186|                 $this->logger->debug('CAMPAIGN: No more contacts to process for decision ID #'.$decisionEvent->getId());
   187|             }
   188|             $this->limiter->resetBatchMinContactId();
   189|         }
   190|     }
   191|     /**
   192|      * @throws Dispatcher\Exception\LogNotProcessedException
   193|      * @throws Dispatcher\Exception\LogPassedAndFailedException
   194|      * @throws Exception\CannotProcessEventException
   195|      * @throws Scheduler\Exception\NotSchedulableException
   196|      */
   197|     private function executeLogsForInactiveEvents(ArrayCollection $events, ArrayCollection $contacts, Counter $childrenCounter, \DateTimeInterface $earliestLastActiveDateTime): void
   198|     {
   199|         $events              = clone $events;
   200|         $eventExecutionDates = $this->scheduler->getSortedExecutionDates($events, $earliestLastActiveDateTime);
   201|         /** @var \DateTime $earliestExecutionDate */
   202|         $earliestExecutionDate = reset($eventExecutionDates);
   203|         $executionDate = $this->executioner->getExecutionDate();
   204|         foreach ($events as $key => $event) {
   205|             if (Event::TYPE_DECISION == $event->getEventType()) {
   206|                 $this->logger->debug('CAMPAIGN: Ignoring child event ID '.$event->getId().' as a decision');
   207|                 $events->remove($key);
   208|                 continue;
   209|             }
   210|             $eventExecutionDate = $this->scheduler->getExecutionDateForInactivity(
   211|                 $eventExecutionDates[$event->getId()],
   212|                 $earliestExecutionDate,
   213|                 $executionDate
   214|             );
   215|             $this->logger->debug(
   216|                 'CAMPAIGN: Event ID# '.$event->getId().
   217|                 ' to be executed on '.$eventExecutionDate->format('Y-m-d H:i:s e')
   218|             );
   219|             if ($this->scheduler->shouldScheduleEvent($event, $eventExecutionDate, $executionDate)) {
   220|                 $childrenCounter->advanceTotalScheduled($contacts->count());
   221|                 $this->scheduler->schedule($event, $eventExecutionDate, $contacts, true);
   222|                 $events->remove($key);
   223|                 continue;
   224|             }
   225|         }
   226|         if ($events->count()) {
   227|             $this->executioner->executeEventsForContacts($events, $contacts, $childrenCounter, true);
   228|         }
   229|     }
   230| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/KickoffExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-139 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Executioner\ContactFinder\KickoffContactFinder;
     6| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     7| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
     8| use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
     9| use Mautic\CampaignBundle\Executioner\Result\Counter;
    10| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    11| use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
    12| use Mautic\CoreBundle\Helper\ProgressBarHelper;
    13| use Psr\Log\LoggerInterface;
    14| use Symfony\Component\Console\Output\NullOutput;
    15| use Symfony\Component\Console\Output\OutputInterface;
    16| use Symfony\Contracts\Translation\TranslatorInterface;
    17| class KickoffExecutioner implements ExecutionerInterface
    18| {
    19|     private ?ContactLimiter $limiter = null;
    20|     private ?Campaign $campaign = null;
    21|     private ?OutputInterface $output = null;
    22|     private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
    23|     private ?\Doctrine\Common\Collections\ArrayCollection $rootEvents = null;
    24|     private ?Counter $counter = null;
    25|     public function __construct(
    26|         private LoggerInterface $logger,
    27|         private KickoffContactFinder $kickoffContactFinder,
    28|         private TranslatorInterface $translator,
    29|         private EventExecutioner $executioner,
    30|         private EventScheduler $scheduler,
    31|     ) {
    32|     }
    33|     /**
    34|      * @return Counter
    35|      *
    36|      * @throws Dispatcher\Exception\LogNotProcessedException
    37|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    38|      * @throws Exception\CannotProcessEventException
    39|      * @throws NotSchedulableException
    40|      */
    41|     public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
    42|     {
    43|         $this->campaign = $campaign;
    44|         $this->limiter  = $limiter;
    45|         $this->output   = $output ?: new NullOutput();
    46|         $this->counter  = new Counter();
    47|         try {
    48|             $this->prepareForExecution();
    49|             $this->executeOrScheduleEvent();
    50|         } catch (NoContactsFoundException) {
    51|             $this->logger->debug('CAMPAIGN: No more contacts to process');
    52|         } catch (NoEventsFoundException) {
    53|             $this->logger->debug('CAMPAIGN: No events to process');
    54|         } finally {
    55|             if ($this->progressBar) {
    56|                 $this->progressBar->finish();
    57|             }
    58|             $this->executioner->persistSummaries();
    59|         }
    60|         return $this->counter;
    61|     }
    62|     /**
    63|      * @throws NoEventsFoundException
    64|      */
    65|     private function prepareForExecution(): void
    66|     {
    67|         $this->logger->debug('CAMPAIGN: Triggering kickoff events');
    68|         $this->rootEvents = $this->campaign->getRootEvents();
    69|         $totalRootEvents  = $this->rootEvents->count();
    70|         if (!$totalRootEvents) {
    71|             throw new NoEventsFoundException();
    72|         }
    73|         $this->logger->debug('CAMPAIGN: Processing the following events: '.implode(', ', $this->rootEvents->getKeys()));
    74|         $totalKickoffEvents = 0;
    75|         if (!($this->output instanceof NullOutput)) {
    76|             $totalContacts      = $this->kickoffContactFinder->getContactCount($this->campaign->getId(), $this->rootEvents->getKeys(), $this->limiter);
    77|             $totalKickoffEvents = $totalRootEvents * $totalContacts;
    78|             $this->output->writeln(
    79|                 $this->translator->trans(
    80|                     'mautic.campaign.trigger.event_count',
    81|                     [
    82|                         '%events%' => $totalKickoffEvents,
    83|                         '%batch%'  => $this->limiter->getBatchLimit(),
    84|                     ]
    85|                 )
    86|             );
    87|             if (!$totalKickoffEvents) {
    88|                 throw new NoEventsFoundException();
    89|             }
    90|         }
    91|         $this->progressBar = ProgressBarHelper::init($this->output, $totalKickoffEvents);
    92|         $this->progressBar->start();
    93|     }
    94|     /**
    95|      * @throws Dispatcher\Exception\LogNotProcessedException
    96|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    97|      * @throws Exception\CannotProcessEventException
    98|      * @throws NoContactsFoundException
    99|      * @throws NotSchedulableException
   100|      */
   101|     private function executeOrScheduleEvent(): void
   102|     {
   103|         $now = new \DateTime();
   104|         $this->counter->advanceEventCount($this->rootEvents->count());
   105|         $contacts = $this->kickoffContactFinder->getContacts($this->campaign->getId(), $this->limiter);
   106|         while ($contacts && $contacts->count()) {
   107|             $batchMinContactId = max($contacts->getKeys()) + 1;
   108|             $rootEvents        = clone $this->rootEvents;
   109|             /** @var Event $event */
   110|             foreach ($rootEvents as $key => $event) {
   111|                 $this->progressBar->advance($contacts->count());
   112|                 $this->counter->advanceEvaluated($contacts->count());
   113|                 try {
   114|                     $executionDate = $this->scheduler->getExecutionDateTime($event, $now);
   115|                     $this->logger->debug(
   116|                         'CAMPAIGN: Event ID# '.$event->getId().
   117|                         ' to be executed on '.$executionDate->format('Y-m-d H:i:s e').
   118|                         ' compared to '.$now->format('Y-m-d H:i:s e')
   119|                     );
   120|                     $this->scheduler->validateAndScheduleEventForContacts($event, $executionDate, $contacts, $now);
   121|                     $this->counter->advanceTotalScheduled($contacts->count());
   122|                     $rootEvents->remove($key);
   123|                     continue;
   124|                 } catch (NotSchedulableException) {
   125|                 }
   126|             }
   127|             if ($rootEvents->count()) {
   128|                 $this->executioner->executeEventsForContacts($rootEvents, $contacts, $this->counter);
   129|             }
   130|             $this->kickoffContactFinder->clear($contacts);
   131|             if ($this->limiter->getContactId()) {
   132|                 break;
   133|             }
   134|             $this->logger->debug('CAMPAIGN: Fetching the next batch of kickoff contacts starting with contact ID '.$batchMinContactId);
   135|             $this->limiter->setBatchMinContactId($batchMinContactId);
   136|             $contacts = $this->kickoffContactFinder->getContacts($this->campaign->getId(), $this->limiter);
   137|         }
   138|     }
   139| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Logger/EventLogger.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-168 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Logger;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     7| use Mautic\CampaignBundle\Entity\LeadRepository;
     8| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
     9| use Mautic\CampaignBundle\Helper\ChannelExtractor;
    10| use Mautic\CampaignBundle\Model\SummaryModel;
    11| use Mautic\CoreBundle\Helper\IpLookupHelper;
    12| use Mautic\LeadBundle\Entity\Lead;
    13| use Mautic\LeadBundle\Tracker\ContactTracker;
    14| class EventLogger
    15| {
    16|     private ArrayCollection $persistQueue;
    17|     private ArrayCollection $logs;
    18|     private array $contactRotations = [];
    19|     /**
    20|      * @var int
    21|      */
    22|     private $lastUsedCampaignIdToFetchRotation;
    23|     public function __construct(
    24|         private IpLookupHelper $ipLookupHelper,
    25|         private ContactTracker $contactTracker,
    26|         private LeadEventLogRepository $leadEventLogRepository,
    27|         private LeadRepository $leadRepository,
    28|         private SummaryModel $summaryModel,
    29|     ) {
    30|         $this->persistQueue = new ArrayCollection();
    31|         $this->logs         = new ArrayCollection();
    32|     }
    33|     public function queueToPersist(LeadEventLog $log): void
    34|     {
    35|         $this->persistQueue->add($log);
    36|         if ($this->persistQueue->count() >= 20) {
    37|             $this->persistPendingAndInsertIntoLogStack();
    38|         }
    39|     }
    40|     public function persistLog(LeadEventLog $log): void
    41|     {
    42|         $this->leadEventLogRepository->saveEntity($log);
    43|         $this->summaryModel->updateSummary([$log]);
    44|     }
    45|     /**
    46|      * @param bool $isInactiveEvent
    47|      */
    48|     public function buildLogEntry(Event $event, Lead $contact = null, $isInactiveEvent = false): LeadEventLog
    49|     {
    50|         $log = new LeadEventLog();
    51|         if (!defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED')) {
    52|             $log->setIpAddress($this->ipLookupHelper->getIpAddress());
    53|         }
    54|         $log->setEvent($event);
    55|         $log->setCampaign($event->getCampaign());
    56|         if (null === $contact) {
    57|             $contact = $this->contactTracker->getContact();
    58|         }
    59|         $log->setLead($contact);
    60|         if ($isInactiveEvent) {
    61|             $log->setNonActionPathTaken(true);
    62|         }
    63|         $log->setDateTriggered(new \DateTime());
    64|         $log->setSystemTriggered(defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED'));
    65|         if (isset($this->contactRotations[$contact->getId()]) && ($this->lastUsedCampaignIdToFetchRotation === $event->getCampaign()->getId())) {
    66|             $log->setRotation($this->contactRotations[$contact->getId()]['rotation']);
    67|         } else {
    68|             $rotations   = $this->leadRepository->getContactRotations([$contact->getId()], $event->getCampaign()->getId());
    69|             $rotationVal = isset($rotations[$contact->getId()]) ? $rotations[$contact->getId()]['rotation'] : 1;
    70|             $log->setRotation($rotationVal);
    71|         }
    72|         return $log;
    73|     }
    74|     /**
    75|      * Persist the queue, clear the entities from memory, and reset the queue.
    76|      *
    77|      * @return ArrayCollection
    78|      */
    79|     public function persistQueuedLogs()
    80|     {
    81|         $this->persistPendingAndInsertIntoLogStack();
    82|         $logs = clone $this->logs;
    83|         $this->logs->clear();
    84|         return $logs;
    85|     }
    86|     public function persistCollection(ArrayCollection $collection): self
    87|     {
    88|         if (!$collection->count()) {
    89|             return $this;
    90|         }
    91|         $this->leadEventLogRepository->saveEntities($collection->getValues());
    92|         $this->summaryModel->updateSummary($collection->getValues());
    93|         return $this;
    94|     }
    95|     public function clearCollection(ArrayCollection $collection): self
    96|     {
    97|         $this->leadEventLogRepository->detachEntities($collection->getValues());
    98|         return $this;
    99|     }
   100|     public function extractContactsFromLogs(ArrayCollection $logs): ArrayCollection
   101|     {
   102|         $contacts = new ArrayCollection();
   103|         /** @var LeadEventLog $log */
   104|         foreach ($logs as $log) {
   105|             $contact = $log->getLead();
   106|             $contacts->set($contact->getId(), $contact);
   107|         }
   108|         return $contacts;
   109|     }
   110|     /**
   111|      * @param bool $isInactiveEntry
   112|      *
   113|      * @return ArrayCollection
   114|      */
   115|     public function fetchRotationAndGenerateLogsFromContacts(Event $event, AbstractEventAccessor $config, ArrayCollection $contacts, $isInactiveEntry = false)
   116|     {
   117|         $this->hydrateContactRotationsForNewLogs($contacts->getKeys(), $event->getCampaign()->getId());
   118|         return $this->generateLogsFromContacts($event, $config, $contacts, $isInactiveEntry);
   119|     }
   120|     /**
   121|      * @param bool $isInactiveEntry
   122|      *
   123|      * @return ArrayCollection
   124|      */
   125|     public function generateLogsFromContacts(Event $event, AbstractEventAccessor $config, ArrayCollection $contacts, $isInactiveEntry)
   126|     {
   127|         $isDecision = Event::TYPE_DECISION === $event->getEventType();
   128|         foreach ($contacts as $contact) {
   129|             if (isset($this->contactRotations[$contact->getId()]) && $this->contactRotations[$contact->getId()]['manually_removed']) {
   130|                 continue;
   131|             }
   132|             $log = $this->buildLogEntry($event, $contact, $isInactiveEntry);
   133|             $log->setIsScheduled(false);
   134|             $log->setDateTriggered(new \DateTime());
   135|             ChannelExtractor::setChannel($log, $event, $config);
   136|             if ($isDecision) {
   137|                 $this->logs->add($log);
   138|             } else {
   139|                 $this->queueToPersist($log);
   140|             }
   141|         }
   142|         return $this->persistQueuedLogs();
   143|     }
   144|     /**
   145|      * @param int $campaignId
   146|      */
   147|     public function hydrateContactRotationsForNewLogs(array $contactIds, $campaignId): void
   148|     {
   149|         $this->contactRotations                  = $this->leadRepository->getContactRotations($contactIds, $campaignId);
   150|         $this->lastUsedCampaignIdToFetchRotation = $campaignId;
   151|     }
   152|     private function persistPendingAndInsertIntoLogStack(): void
   153|     {
   154|         if (!$this->persistQueue->count()) {
   155|             return;
   156|         }
   157|         $this->leadEventLogRepository->saveEntities($this->persistQueue->getValues());
   158|         /** @var LeadEventLog $log */
   159|         foreach ($this->persistQueue as $log) {
   160|             $this->logs->set($log->getId(), $log);
   161|         }
   162|         $this->persistQueue->clear();
   163|     }
   164|     public function getSummaryModel(): SummaryModel
   165|     {
   166|         return $this->summaryModel;
   167|     }
   168| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/RealTimeExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-162 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\EventRepository;
     6| use Mautic\CampaignBundle\EventCollector\Accessor\Event\DecisionAccessor;
     7| use Mautic\CampaignBundle\EventCollector\EventCollector;
     8| use Mautic\CampaignBundle\Executioner\Event\DecisionExecutioner as Executioner;
     9| use Mautic\CampaignBundle\Executioner\Exception\CampaignNotExecutableException;
    10| use Mautic\CampaignBundle\Executioner\Exception\DecisionNotApplicableException;
    11| use Mautic\CampaignBundle\Executioner\Helper\DecisionHelper;
    12| use Mautic\CampaignBundle\Executioner\Result\Responses;
    13| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    14| use Mautic\CampaignBundle\Helper\ChannelExtractor;
    15| use Mautic\LeadBundle\Entity\Lead;
    16| use Mautic\LeadBundle\Model\LeadModel;
    17| use Mautic\LeadBundle\Tracker\ContactTracker;
    18| use Psr\Log\LoggerInterface;
    19| class RealTimeExecutioner
    20| {
    21|     /**
    22|      * @var Lead
    23|      */
    24|     private $contact;
    25|     /**
    26|      * @var array
    27|      */
    28|     private $events;
    29|     private ?Responses $responses = null;
    30|     public function __construct(
    31|         private LoggerInterface $logger,
    32|         private LeadModel $leadModel,
    33|         private EventRepository $eventRepository,
    34|         private EventExecutioner $executioner,
    35|         private Executioner $decisionExecutioner,
    36|         private EventCollector $collector,
    37|         private EventScheduler $scheduler,
    38|         private ContactTracker $contactTracker,
    39|         private DecisionHelper $decisionHelper,
    40|     ) {
    41|     }
    42|     /**
    43|      * @param string      $type
    44|      * @param mixed       $passthrough
    45|      * @param string|null $channel
    46|      * @param int|null    $channelId
    47|      *
    48|      * @return Responses
    49|      *
    50|      * @throws Dispatcher\Exception\LogNotProcessedException
    51|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    52|      * @throws Exception\CannotProcessEventException
    53|      * @throws Scheduler\Exception\NotSchedulableException
    54|      */
    55|     public function execute($type, $passthrough = null, $channel = null, $channelId = null)
    56|     {
    57|         $this->responses = new Responses();
    58|         $now             = new \DateTime();
    59|         $this->logger->debug('CAMPAIGN: Campaign triggered for event type '.$type.'('.$channel.' / '.$channelId.')');
    60|         defined('MAUTIC_CAMPAIGN_NOT_SYSTEM_TRIGGERED') or define('MAUTIC_CAMPAIGN_NOT_SYSTEM_TRIGGERED', 1);
    61|         try {
    62|             $this->fetchCurrentContact();
    63|         } catch (CampaignNotExecutableException $exception) {
    64|             $this->logger->debug('CAMPAIGN: '.$exception->getMessage());
    65|             return $this->responses;
    66|         }
    67|         try {
    68|             $this->fetchCampaignData($type);
    69|         } catch (CampaignNotExecutableException $exception) {
    70|             $this->logger->debug('CAMPAIGN: '.$exception->getMessage());
    71|             return $this->responses;
    72|         }
    73|         /** @var Event $event */
    74|         foreach ($this->events as $event) {
    75|             try {
    76|                 $this->evaluateDecisionForContact($event, $passthrough, $channel, $channelId);
    77|             } catch (DecisionNotApplicableException $exception) {
    78|                 $this->logger->debug('CAMPAIGN: Event ID '.$event->getId().' is not applicable ('.$exception->getMessage().')');
    79|                 continue;
    80|             }
    81|             $children = $event->getPositiveChildren();
    82|             if (!$children->count()) {
    83|                 $this->logger->debug('CAMPAIGN: Event ID '.$event->getId().' has no positive children');
    84|                 continue;
    85|             }
    86|             $this->executeAssociatedEvents($children, $now);
    87|         }
    88|         if ($this->contact->getChanges()) {
    89|             $this->leadModel->saveEntity($this->contact, false);
    90|         }
    91|         return $this->responses;
    92|     }
    93|     /**
    94|      * @throws Dispatcher\Exception\LogNotProcessedException
    95|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    96|      * @throws Exception\CannotProcessEventException
    97|      * @throws Scheduler\Exception\NotSchedulableException
    98|      */
    99|     private function executeAssociatedEvents(ArrayCollection $children, \DateTime $now): void
   100|     {
   101|         $children = clone $children;
   102|         /** @var Event $child */
   103|         foreach ($children as $key => $child) {
   104|             $executionDate = $this->scheduler->getExecutionDateTime($child, $now);
   105|             $this->logger->debug(
   106|                 'CAMPAIGN: Event ID# '.$child->getId().
   107|                 ' to be executed on '.$executionDate->format('Y-m-d H:i:s e')
   108|             );
   109|             if ($this->scheduler->shouldSchedule($executionDate, $now)) {
   110|                 $this->scheduler->scheduleForContact($child, $executionDate, $this->contact);
   111|                 $children->remove($key);
   112|             }
   113|         }
   114|         if ($children->count()) {
   115|             $this->executioner->executeEventsForContact($children, $this->contact, $this->responses);
   116|         }
   117|     }
   118|     /**
   119|      * @param mixed       $passthrough
   120|      * @param string|null $channel
   121|      * @param int|null    $channelId
   122|      *
   123|      * @throws DecisionNotApplicableException
   124|      * @throws Exception\CannotProcessEventException
   125|      */
   126|     private function evaluateDecisionForContact(Event $event, $passthrough = null, $channel = null, $channelId = null): void
   127|     {
   128|         $this->logger->debug('CAMPAIGN: Executing '.$event->getType().' ID '.$event->getId().' for contact ID '.$this->contact->getId());
   129|         $this->decisionHelper->checkIsDecisionApplicableForContact($event, $this->contact, $channel, $channelId);
   130|         /** @var DecisionAccessor $config */
   131|         $config = $this->collector->getEventConfig($event);
   132|         $this->decisionExecutioner->evaluateForContact($config, $event, $this->contact, $passthrough, $channel, $channelId);
   133|     }
   134|     /**
   135|      * @throws CampaignNotExecutableException
   136|      */
   137|     private function fetchCurrentContact(): void
   138|     {
   139|         $this->contact = $this->contactTracker->getContact();
   140|         if (!$this->contact instanceof Lead || !$this->contact->getId()) {
   141|             throw new CampaignNotExecutableException('Unidentifiable contact');
   142|         }
   143|         $this->logger->debug('CAMPAIGN: Current contact ID# '.$this->contact->getId());
   144|     }
   145|     /**
   146|      * @throws CampaignNotExecutableException
   147|      */
   148|     private function fetchCampaignData($type): void
   149|     {
   150|         if (!$this->events = $this->eventRepository->getContactPendingEvents($this->contact->getId(), $type)) {
   151|             throw new CampaignNotExecutableException('Contact does not have any applicable '.$type.' associations.');
   152|         }
   153|         /** @var Event $event */
   154|         foreach ($this->events as $event) {
   155|             if (1 === $event->getChannelId()) {
   156|                 ChannelExtractor::setChannel($event, $event, $this->collector->getEventConfig($event));
   157|                 $this->eventRepository->saveEntity($event);
   158|             }
   159|         }
   160|         $this->logger->debug('CAMPAIGN: Found '.count($this->events).' events to analyze for contact ID '.$this->contact->getId());
   161|     }
   162| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Result/Counter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-112 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Result;
     3| class Counter
     4| {
     5|     /**
     6|      * @param int $eventCount
     7|      * @param int $evaluated
     8|      * @param int $executed
     9|      * @param int $totalEvaluated
    10|      * @param int $totalExecuted
    11|      * @param int $totalScheduled
    12|      */
    13|     public function __construct(
    14|         private $eventCount = 0,
    15|         private $evaluated = 0,
    16|         private $executed = 0,
    17|         private $totalEvaluated = 0,
    18|         private $totalExecuted = 0,
    19|         private $totalScheduled = 0,
    20|     ) {
    21|     }
    22|     /**
    23|      * @return int
    24|      */
    25|     public function getEventCount()
    26|     {
    27|         return $this->eventCount;
    28|     }
    29|     /**
    30|      * @param int $step
    31|      */
    32|     public function advanceEventCount($step = 1): void
    33|     {
    34|         $this->eventCount += $step;
    35|     }
    36|     /**
    37|      * @return int
    38|      */
    39|     public function getEvaluated()
    40|     {
    41|         return $this->evaluated;
    42|     }
    43|     /**
    44|      * @param int $step
    45|      */
    46|     public function advanceEvaluated($step = 1): void
    47|     {
    48|         $this->evaluated += $step;
    49|         $this->totalEvaluated += $step;
    50|     }
    51|     /**
    52|      * @return int
    53|      */
    54|     public function getExecuted()
    55|     {
    56|         return $this->executed;
    57|     }
    58|     /**
    59|      * @param int $step
    60|      */
    61|     public function advanceExecuted($step = 1): void
    62|     {
    63|         $this->executed += $step;
    64|         $this->totalExecuted += $step;
    65|     }
    66|     /**
    67|      * Includes all child events (conditions, etc) evaluated.
    68|      *
    69|      * @return int
    70|      */
    71|     public function getTotalEvaluated()
    72|     {
    73|         return $this->totalEvaluated;
    74|     }
    75|     /**
    76|      * @param int $step
    77|      */
    78|     public function advanceTotalEvaluated($step = 1): void
    79|     {
    80|         $this->totalEvaluated += $step;
    81|     }
    82|     /**
    83|      * Includes all child events (conditions, etc) executed.
    84|      *
    85|      * @return int
    86|      */
    87|     public function getTotalExecuted()
    88|     {
    89|         return $this->totalExecuted;
    90|     }
    91|     /**
    92|      * @param int $step
    93|      */
    94|     public function advanceTotalExecuted($step = 1): void
    95|     {
    96|         $this->totalExecuted += $step;
    97|     }
    98|     /**
    99|      * @return int
   100|      */
   101|     public function getTotalScheduled()
   102|     {
   103|         return $this->totalScheduled;
   104|     }
   105|     /**
   106|      * @param int $step
   107|      */
   108|     public function advanceTotalScheduled($step = 1): void
   109|     {
   110|         $this->totalScheduled += $step;
   111|     }
   112| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/ScheduledExecutioner.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-250 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Campaign;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Entity\LeadEventLog;
     7| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     8| use Mautic\CampaignBundle\EventListener\CampaignActionJumpToEventSubscriber;
     9| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
    10| use Mautic\CampaignBundle\Executioner\ContactFinder\ScheduledContactFinder;
    11| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
    12| use Mautic\CampaignBundle\Executioner\Exception\NoEventsFoundException;
    13| use Mautic\CampaignBundle\Executioner\Result\Counter;
    14| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
    15| use Mautic\CoreBundle\Helper\ProgressBarHelper;
    16| use Psr\Log\LoggerInterface;
    17| use Symfony\Component\Console\Output\NullOutput;
    18| use Symfony\Component\Console\Output\OutputInterface;
    19| use Symfony\Contracts\Service\ResetInterface;
    20| use Symfony\Contracts\Translation\TranslatorInterface;
    21| class ScheduledExecutioner implements ExecutionerInterface, ResetInterface
    22| {
    23|     private ?Campaign $campaign = null;
    24|     private ?ContactLimiter $limiter = null;
    25|     private ?OutputInterface $output = null;
    26|     private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
    27|     private ?array $scheduledEvents = null;
    28|     private ?Counter $counter = null;
    29|     protected ?\DateTime $now = null;
    30|     public function __construct(
    31|         private LeadEventLogRepository $repo,
    32|         private LoggerInterface $logger,
    33|         private TranslatorInterface $translator,
    34|         private EventExecutioner $executioner,
    35|         private EventScheduler $scheduler,
    36|         private ScheduledContactFinder $scheduledContactFinder,
    37|     ) {
    38|     }
    39|     /**
    40|      * @return Counter|mixed
    41|      *
    42|      * @throws Dispatcher\Exception\LogNotProcessedException
    43|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    44|      * @throws Exception\CannotProcessEventException
    45|      * @throws Scheduler\Exception\NotSchedulableException
    46|      * @throws \Doctrine\ORM\Query\QueryException
    47|      */
    48|     public function execute(Campaign $campaign, ContactLimiter $limiter, OutputInterface $output = null)
    49|     {
    50|         $this->campaign   = $campaign;
    51|         $this->limiter    = $limiter;
    52|         $this->output     = $output ?: new NullOutput();
    53|         $this->counter    = new Counter();
    54|         $this->logger->debug('CAMPAIGN: Triggering scheduled events');
    55|         try {
    56|             $this->prepareForExecution();
    57|             $this->executeOrRescheduleEvent();
    58|         } catch (NoEventsFoundException) {
    59|             $this->logger->debug('CAMPAIGN: No events to process');
    60|         } finally {
    61|             if ($this->progressBar) {
    62|                 $this->progressBar->finish();
    63|             }
    64|         }
    65|         return $this->counter;
    66|     }
    67|     /**
    68|      * @return Counter
    69|      *
    70|      * @throws Dispatcher\Exception\LogNotProcessedException
    71|      * @throws Dispatcher\Exception\LogPassedAndFailedException
    72|      * @throws Exception\CannotProcessEventException
    73|      * @throws Scheduler\Exception\NotSchedulableException
    74|      * @throws \Doctrine\ORM\Query\QueryException
    75|      */
    76|     public function executeByIds(array $logIds, OutputInterface $output = null, ?\DateTime $now = null)
    77|     {
    78|         $now           = $now ?? $this->now ?? new \DateTime();
    79|         $this->output  = $output ?: new NullOutput();
    80|         $this->counter = new Counter();
    81|         if (!$logIds) {
    82|             return $this->counter;
    83|         }
    84|         $logs           = $this->repo->getScheduledByIds($logIds);
    85|         $totalLogsFound = $logs->count();
    86|         $this->counter->advanceEvaluated($totalLogsFound);
    87|         $this->logger->debug('CAMPAIGN: '.$logs->count().' events scheduled to execute.');
    88|         $this->output->writeln(
    89|             $this->translator->trans(
    90|                 'mautic.campaign.trigger.event_count',
    91|                 [
    92|                     '%events%' => $totalLogsFound,
    93|                     '%batch%'  => 'n/a',
    94|                 ]
    95|             )
    96|         );
    97|         if (!$logs->count()) {
    98|             return $this->counter;
    99|         }
   100|         $this->progressBar = ProgressBarHelper::init($this->output, $totalLogsFound);
   101|         $this->progressBar->start();
   102|         $scheduledLogCount = $totalLogsFound - $logs->count();
   103|         $this->progressBar->advance($scheduledLogCount);
   104|         $organized = $this->organizeByEvent($logs);
   105|         foreach ($organized as $organizedLogs) {
   106|             /** @var Event $event */
   107|             $event = $organizedLogs->first()->getEvent();
   108|             $this->validateSchedule($organizedLogs, $now, true);
   109|             if ($event->getCampaign()->isPublished()) {
   110|                 try {
   111|                     $this->scheduledContactFinder->hydrateContacts($organizedLogs);
   112|                     $this->executioner->executeLogs($event, $organizedLogs, $this->counter);
   113|                 } catch (NoContactsFoundException) {
   114|                 }
   115|             }
   116|             $this->progressBar->advance($organizedLogs->count());
   117|         }
   118|         $this->progressBar->finish();
   119|         return $this->counter;
   120|     }
   121|     public function reset(): void
   122|     {
   123|         $this->now = null;
   124|     }
   125|     /**
   126|      * @throws NoEventsFoundException
   127|      */
   128|     private function prepareForExecution(): void
   129|     {
   130|         $this->now ??= new \DateTime();
   131|         $scheduledEvents       = $this->repo->getScheduledCounts($this->campaign->getId(), $this->now, $this->limiter);
   132|         $totalScheduledCount   = $scheduledEvents ? array_sum($scheduledEvents) : 0;
   133|         $this->scheduledEvents = array_keys($scheduledEvents);
   134|         $this->logger->debug('CAMPAIGN: '.$totalScheduledCount.' events scheduled to execute.');
   135|         $this->output->writeln(
   136|             $this->translator->trans(
   137|                 'mautic.campaign.trigger.event_count',
   138|                 [
   139|                     '%events%' => $totalScheduledCount,
   140|                     '%batch%'  => $this->limiter->getBatchLimit(),
   141|                 ]
   142|             )
   143|         );
   144|         if (!$totalScheduledCount) {
   145|             throw new NoEventsFoundException();
   146|         }
   147|         $this->progressBar = ProgressBarHelper::init($this->output, $totalScheduledCount);
   148|         $this->progressBar->start();
   149|     }
   150|     /**
   151|      * @throws Dispatcher\Exception\LogNotProcessedException
   152|      * @throws Dispatcher\Exception\LogPassedAndFailedException
   153|      * @throws Exception\CannotProcessEventException
   154|      * @throws Scheduler\Exception\NotSchedulableException
   155|      * @throws \Doctrine\ORM\Query\QueryException
   156|      */
   157|     private function executeOrRescheduleEvent(): void
   158|     {
   159|         $now = $this->now ?? new \DateTime();
   160|         foreach ($this->scheduledEvents as $eventId) {
   161|             $this->counter->advanceEventCount();
   162|             $this->executeScheduled($eventId, $now);
   163|         }
   164|     }
   165|     /**
   166|      * @throws Dispatcher\Exception\LogNotProcessedException
   167|      * @throws Dispatcher\Exception\LogPassedAndFailedException
   168|      * @throws Exception\CannotProcessEventException
   169|      * @throws Scheduler\Exception\NotSchedulableException
   170|      * @throws \Doctrine\ORM\Query\QueryException
   171|      */
   172|     private function executeScheduled($eventId, \DateTime $now): void
   173|     {
   174|         $logs = $this->repo->getScheduled($eventId, $this->now, $this->limiter);
   175|         while ($logs->count()) {
   176|             try {
   177|                 $fetchedContacts = $this->scheduledContactFinder->hydrateContacts($logs);
   178|             } catch (NoContactsFoundException) {
   179|                 break;
   180|             }
   181|             $event = $logs->first()->getEvent();
   182|             $this->progressBar->advance($logs->count());
   183|             $this->counter->advanceEvaluated($logs->count());
   184|             $this->validateSchedule($logs, $now);
   185|             $this->executioner->executeLogs($event, $logs, $this->counter);
   186|             $this->scheduledContactFinder->clear($fetchedContacts);
   187|             $logs = $this->repo->getScheduled($eventId, $this->now, $this->limiter);
   188|         }
   189|     }
   190|     /**
   191|      * @param bool $scheduleTogether
   192|      *
   193|      * @throws Scheduler\Exception\NotSchedulableException
   194|      */
   195|     private function validateSchedule(ArrayCollection $logs, \DateTime $now, $scheduleTogether = false): void
   196|     {
   197|         $toBeRescheduled     = new ArrayCollection();
   198|         $latestExecutionDate = $now;
   199|         /** @var LeadEventLog $log */
   200|         foreach ($logs as $key => $log) {
   201|             $executionDate = $this->scheduler->validateExecutionDateTime($log, $now);
   202|             $this->logger->debug(
   203|                 'CAMPAIGN: Log ID #'.$log->getID().
   204|                 ' to be executed on '.$executionDate->format('Y-m-d H:i:s e').
   205|                 ' compared to '.$now->format('Y-m-d H:i:s e')
   206|             );
   207|             if ($this->scheduler->shouldSchedule($executionDate, $now)) {
   208|                 $this->counter->advanceTotalScheduled();
   209|                 if ($scheduleTogether) {
   210|                     $toBeRescheduled->set($key, $log);
   211|                     if ($executionDate > $latestExecutionDate) {
   212|                         $latestExecutionDate = $executionDate;
   213|                     }
   214|                 } else {
   215|                     $this->scheduler->reschedule($log, $executionDate);
   216|                 }
   217|                 $logs->remove($key);
   218|                 continue;
   219|             }
   220|         }
   221|         if ($toBeRescheduled->count()) {
   222|             $this->scheduler->rescheduleLogs($toBeRescheduled, $latestExecutionDate);
   223|         }
   224|     }
   225|     /**
   226|      * @return ArrayCollection[]
   227|      */
   228|     private function organizeByEvent(ArrayCollection $logs): array
   229|     {
   230|         $jumpTo = [];
   231|         $other  = [];
   232|         /** @var LeadEventLog $log */
   233|         foreach ($logs as $log) {
   234|             $event     = $log->getEvent();
   235|             $eventType = $event->getType();
   236|             if (CampaignActionJumpToEventSubscriber::EVENT_NAME === $eventType) {
   237|                 if (!isset($jumpTo[$event->getId()])) {
   238|                     $jumpTo[$event->getId()] = new ArrayCollection();
   239|                 }
   240|                 $jumpTo[$event->getId()]->set($log->getId(), $log);
   241|             } else {
   242|                 if (!isset($other[$event->getId()])) {
   243|                     $other[$event->getId()] = new ArrayCollection();
   244|                 }
   245|                 $other[$event->getId()]->set($log->getId(), $log);
   246|             }
   247|         }
   248|         return array_merge($other, $jumpTo);
   249|     }
   250| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Scheduler/EventScheduler.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-296 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Scheduler;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\CampaignEvents;
     5| use Mautic\CampaignBundle\Entity\Event;
     6| use Mautic\CampaignBundle\Entity\LeadEventLog;
     7| use Mautic\CampaignBundle\Event\ScheduledBatchEvent;
     8| use Mautic\CampaignBundle\Event\ScheduledEvent;
     9| use Mautic\CampaignBundle\EventCollector\Accessor\Event\AbstractEventAccessor;
    10| use Mautic\CampaignBundle\EventCollector\EventCollector;
    11| use Mautic\CampaignBundle\Executioner\Exception\IntervalNotConfiguredException;
    12| use Mautic\CampaignBundle\Executioner\Logger\EventLogger;
    13| use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
    14| use Mautic\CampaignBundle\Executioner\Scheduler\Mode\DateTime as DateTimeScheduler;
    15| use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Interval as IntervalScheduler;
    16| use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized as OptimizedScheduler;
    17| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    18| use Mautic\LeadBundle\Entity\Lead;
    19| use Psr\Log\LoggerInterface;
    20| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    21| class EventScheduler
    22| {
    23|     public function __construct(
    24|         private LoggerInterface $logger,
    25|         private EventLogger $eventLogger,
    26|         private IntervalScheduler $intervalScheduler,
    27|         private DateTimeScheduler $dateTimeScheduler,
    28|         private OptimizedScheduler $optimizedScheduler,
    29|         private EventCollector $collector,
    30|         private EventDispatcherInterface $dispatcher,
    31|         private CoreParametersHelper $coreParametersHelper,
    32|     ) {
    33|     }
    34|     public function scheduleForContact(Event $event, \DateTimeInterface $executionDate, Lead $contact): void
    35|     {
    36|         $contacts = new ArrayCollection([$contact]);
    37|         $this->schedule($event, $executionDate, $contacts);
    38|     }
    39|     /**
    40|      * @param bool $isInactiveEvent
    41|      */
    42|     public function schedule(Event $event, \DateTimeInterface $executionDate, ArrayCollection $contacts, $isInactiveEvent = false): void
    43|     {
    44|         $config = $this->collector->getEventConfig($event);
    45|         $this->eventLogger->hydrateContactRotationsForNewLogs($contacts->getKeys(), $event->getCampaign()->getId());
    46|         if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
    47|             $groupedExecutionDates = $this->intervalScheduler->groupContactsByDate($event, $contacts, $executionDate);
    48|             foreach ($groupedExecutionDates as $groupExecutionDateDAO) {
    49|                 $this->scheduleEventForContacts(
    50|                     $event,
    51|                     $config,
    52|                     $groupExecutionDateDAO->getExecutionDate(),
    53|                     $groupExecutionDateDAO->getContacts(),
    54|                     $isInactiveEvent
    55|                 );
    56|             }
    57|             return;
    58|         }
    59|         $this->scheduleEventForContacts($event, $config, $executionDate, $contacts, $isInactiveEvent);
    60|     }
    61|     public function reschedule(LeadEventLog $log, \DateTimeInterface $toBeExecutedOn): void
    62|     {
    63|         $log->setTriggerDate($toBeExecutedOn);
    64|         $this->eventLogger->persistLog($log);
    65|         $event  = $log->getEvent();
    66|         $config = $this->collector->getEventConfig($event);
    67|         $this->dispatchScheduledEvent($config, $log, true);
    68|     }
    69|     /**
    70|      * @param ArrayCollection|LeadEventLog[] $logs
    71|      */
    72|     public function rescheduleLogs(ArrayCollection $logs, \DateTimeInterface $toBeExecutedOn): void
    73|     {
    74|         foreach ($logs as $log) {
    75|             $log->setTriggerDate($toBeExecutedOn);
    76|         }
    77|         $this->eventLogger->persistCollection($logs);
    78|         $event  = $logs->first()->getEvent();
    79|         $config = $this->collector->getEventConfig($event);
    80|         $this->dispatchBatchScheduledEvent($config, $event, $logs, true);
    81|     }
    82|     /**
    83|      * @deprecated since Mautic 3. To be removed in Mautic 4. Use rescheduleFailures instead.
    84|      */
    85|     public function rescheduleFailure(LeadEventLog $log): void
    86|     {
    87|         try {
    88|             $this->reschedule($log, $this->getRescheduleDate($log));
    89|         } catch (IntervalNotConfiguredException) {
    90|         }
    91|     }
    92|     public function rescheduleFailures(ArrayCollection $logs): void
    93|     {
    94|         if (!$logs->count()) {
    95|             return;
    96|         }
    97|         foreach ($logs as $log) {
    98|             try {
    99|                 $this->reschedule($log, $this->getRescheduleDate($log));
   100|             } catch (IntervalNotConfiguredException) {
   101|             }
   102|         }
   103|         $event  = $logs->first()->getEvent();
   104|         $config = $this->collector->getEventConfig($event);
   105|         $this->dispatchBatchScheduledEvent($config, $event, $logs, true);
   106|     }
   107|     /**
   108|      * @throws NotSchedulableException
   109|      */
   110|     public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime = null, \DateTime $comparedToDateTime = null): \DateTimeInterface
   111|     {
   112|         if (null === $compareFromDateTime) {
   113|             $compareFromDateTime = new \DateTime();
   114|         } else {
   115|             $compareFromDateTime = clone $compareFromDateTime;
   116|         }
   117|         if (null === $comparedToDateTime) {
   118|             $comparedToDateTime = clone $compareFromDateTime;
   119|         } else {
   120|             $comparedToDateTime = clone $comparedToDateTime;
   121|         }
   122|         switch ($event->getTriggerMode()) {
   123|             case Event::TRIGGER_MODE_IMMEDIATE:
   124|             case Event::TRIGGER_MODE_OPTIMIZED:
   125|             case null: // decision
   126|                 $this->logger->debug('CAMPAIGN: ('.$event->getId().') Executing immediately');
   127|                 return $compareFromDateTime;
   128|             case Event::TRIGGER_MODE_INTERVAL:
   129|                 return $this->intervalScheduler->getExecutionDateTime($event, $compareFromDateTime, $comparedToDateTime);
   130|             case Event::TRIGGER_MODE_DATE:
   131|                 return $this->dateTimeScheduler->getExecutionDateTime($event, $compareFromDateTime, $comparedToDateTime);
   132|         }
   133|         throw new NotSchedulableException();
   134|     }
   135|     /**
   136|      * @return \DateTimeInterface
   137|      *
   138|      * @throws NotSchedulableException
   139|      */
   140|     public function validateExecutionDateTime(LeadEventLog $log, \DateTime $currentDateTime)
   141|     {
   142|         if (!$scheduledDateTime = $log->getTriggerDate()) {
   143|             throw new NotSchedulableException();
   144|         }
   145|         $event = $log->getEvent();
   146|         switch ($event->getTriggerMode()) {
   147|             case Event::TRIGGER_MODE_IMMEDIATE:
   148|             case Event::TRIGGER_MODE_OPTIMIZED:
   149|             case null: // decision
   150|                 $this->logger->debug('CAMPAIGN: ('.$event->getId().') Executing immediately');
   151|                 return $currentDateTime;
   152|             case Event::TRIGGER_MODE_INTERVAL:
   153|                 return $this->intervalScheduler->validateExecutionDateTime($log, $currentDateTime);
   154|             case Event::TRIGGER_MODE_DATE:
   155|                 return $this->dateTimeScheduler->getExecutionDateTime($event, $currentDateTime, $scheduledDateTime);
   156|         }
   157|         throw new NotSchedulableException();
   158|     }
   159|     /**
   160|      * @param ArrayCollection|Event[] $events
   161|      *
   162|      * @throws NotSchedulableException
   163|      */
   164|     public function getSortedExecutionDates(ArrayCollection $events, \DateTimeInterface $lastActiveDate): array
   165|     {
   166|         $eventExecutionDates = [];
   167|         /** @var Event $child */
   168|         foreach ($events as $child) {
   169|             $eventExecutionDates[$child->getId()] = $this->getExecutionDateTime($child, $lastActiveDate);
   170|         }
   171|         uasort(
   172|             $eventExecutionDates,
   173|             fn (\DateTimeInterface $a, \DateTimeInterface $b): int => $a <=> $b
   174|         );
   175|         return $eventExecutionDates;
   176|     }
   177|     public function getExecutionDateForInactivity(\DateTimeInterface $eventExecutionDate, \DateTimeInterface $earliestExecutionDate, \DateTimeInterface $now): \DateTimeInterface
   178|     {
   179|         if ($eventExecutionDate->getTimestamp() === $earliestExecutionDate->getTimestamp()) {
   180|             return clone $now;
   181|         }
   182|         return $eventExecutionDate;
   183|     }
   184|     public function shouldSchedule(\DateTimeInterface $executionDate, \DateTimeInterface $now): bool
   185|     {
   186|         if (false === (bool) getenv('CAMPAIGN_EXECUTIONER_SCHEDULER_ACKNOWLEDGE_SECONDS')) {
   187|             $executionDate = new \DateTime($executionDate->format('Y-m-d H:i'), $executionDate->getTimezone());
   188|             $now           = new \DateTime($now->format('Y-m-d H:i'), $now->getTimezone());
   189|         }
   190|         return $executionDate > $now;
   191|     }
   192|     public function shouldScheduleEvent(Event $event, \DateTimeInterface $executionDate, \DateTimeInterface $now): bool
   193|     {
   194|         if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
   195|             return true;
   196|         }
   197|         return $this->shouldSchedule($executionDate, $now);
   198|     }
   199|     /**
   200|      * @throws NotSchedulableException
   201|      */
   202|     public function validateAndScheduleEventForContacts(Event $event, \DateTimeInterface $executionDateTime, ArrayCollection $contacts, \DateTimeInterface $comparedFromDateTime): void
   203|     {
   204|         if ($this->intervalScheduler->isContactSpecificExecutionDateRequired($event)) {
   205|             $this->logger->debug(
   206|                 'CAMPAIGN: Event ID# '.$event->getId().
   207|                 ' has to be scheduled based on contact specific parameters '.
   208|                 ' compared to '.$executionDateTime->format('Y-m-d H:i:s')
   209|             );
   210|             $groupedExecutionDates = $this->intervalScheduler->groupContactsByDate($event, $contacts, $executionDateTime);
   211|             $config                = $this->collector->getEventConfig($event);
   212|             foreach ($groupedExecutionDates as $groupExecutionDateDAO) {
   213|                 $this->scheduleEventForContacts(
   214|                     $event,
   215|                     $config,
   216|                     $groupExecutionDateDAO->getExecutionDate(),
   217|                     $groupExecutionDateDAO->getContacts()
   218|                 );
   219|             }
   220|             return;
   221|         }
   222|         if ($this->shouldSchedule($executionDateTime, $comparedFromDateTime)) {
   223|             $this->schedule($event, $executionDateTime, $contacts);
   224|             return;
   225|         }
   226|         throw new NotSchedulableException();
   227|     }
   228|     /**
   229|      * @param bool $isReschedule
   230|      */
   231|     private function dispatchScheduledEvent(AbstractEventAccessor $config, LeadEventLog $log, $isReschedule = false): void
   232|     {
   233|         $this->dispatcher->dispatch(
   234|             new ScheduledEvent($config, $log, $isReschedule),
   235|             CampaignEvents::ON_EVENT_SCHEDULED
   236|         );
   237|     }
   238|     /**
   239|      * @param bool $isReschedule
   240|      */
   241|     private function dispatchBatchScheduledEvent(AbstractEventAccessor $config, Event $event, ArrayCollection $logs, $isReschedule = false): void
   242|     {
   243|         if (!$logs->count()) {
   244|             return;
   245|         }
   246|         $this->dispatcher->dispatch(
   247|             new ScheduledBatchEvent($config, $event, $logs, $isReschedule),
   248|             CampaignEvents::ON_EVENT_SCHEDULED_BATCH
   249|         );
   250|     }
   251|     /**
   252|      * @param bool $isInactiveEvent
   253|      */
   254|     private function scheduleEventForContacts(Event $event, AbstractEventAccessor $config, \DateTimeInterface $executionDate, ArrayCollection $contacts, $isInactiveEvent = false): void
   255|     {
   256|         foreach ($contacts as $contact) {
   257|             $log = $this->eventLogger->buildLogEntry($event, $contact, $isInactiveEvent);
   258|             if (Event::TRIGGER_MODE_OPTIMIZED === $event->getTriggerMode()) {
   259|                 $optimizedExecutionDate = $this->optimizedScheduler->getExecutionDateTimeForContact($event, $contact);
   260|                 $log->setTriggerDate($optimizedExecutionDate);
   261|             } else {
   262|                 $log->setTriggerDate($executionDate);
   263|             }
   264|             $this->eventLogger->queueToPersist($log);
   265|             $this->logger->debug(
   266|                 'CAMPAIGN: '.ucfirst($event->getEventType()).' ID# '.$event->getId().' for contact ID# '.$contact->getId()
   267|                 .' has timing that is not appropriate and thus scheduled for '.$executionDate->format('Y-m-d H:i:s T')
   268|             );
   269|             $this->dispatchScheduledEvent($config, $log);
   270|         }
   271|         $logs = $this->eventLogger->persistQueuedLogs();
   272|         $this->dispatchBatchScheduledEvent($config, $event, $logs);
   273|         $this->eventLogger->persistCollection($logs)
   274|             ->clearCollection($logs);
   275|     }
   276|     /**
   277|      * @throws IntervalNotConfiguredException
   278|      */
   279|     private function getRescheduleDate(LeadEventLog $leadEventLog): \DateTimeInterface
   280|     {
   281|         $rescheduleDate = new \DateTime();
   282|         $logInterval    = $leadEventLog->getRescheduleInterval();
   283|         if ($logInterval) {
   284|             return $rescheduleDate->add($logInterval);
   285|         }
   286|         $defaultIntervalString = $this->coreParametersHelper->get('campaign_time_wait_on_event_false');
   287|         if (!$defaultIntervalString) {
   288|             throw new IntervalNotConfiguredException('No Interval has been set on the lead event log nor as campaign_time_wait_on_event_false config value.');
   289|         }
   290|         try {
   291|             return $rescheduleDate->add(new \DateInterval($defaultIntervalString));
   292|         } catch (\Exception) {
   293|             throw new IntervalNotConfiguredException("'{$defaultIntervalString}' is not valid interval string for campaign_time_wait_on_event_false config key.");
   294|         }
   295|     }
   296| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Scheduler/Mode/DAO/GroupExecutionDateDAO.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode\DAO;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\LeadBundle\Entity\Lead;
     5| class GroupExecutionDateDAO
     6| {
     7|     private ArrayCollection $contacts;
     8|     public function __construct(
     9|         private \DateTimeInterface $executionDate,
    10|     ) {
    11|         $this->contacts      = new ArrayCollection();
    12|     }
    13|     public function addContact(Lead $contact): void
    14|     {
    15|         $this->contacts->set($contact->getId(), $contact);
    16|     }
    17|     /**
    18|      * @return \DateTimeInterface
    19|      */
    20|     public function getExecutionDate()
    21|     {
    22|         return $this->executionDate;
    23|     }
    24|     /**
    25|      * @return ArrayCollection
    26|      */
    27|     public function getContacts()
    28|     {
    29|         return $this->contacts;
    30|     }
    31| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Scheduler/Mode/DateTime.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
     3| use Mautic\CampaignBundle\Entity\Event;
     4| use Psr\Log\LoggerInterface;
     5| class DateTime implements ScheduleModeInterface
     6| {
     7|     public function __construct(
     8|         private LoggerInterface $logger,
     9|     ) {
    10|     }
    11|     public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
    12|     {
    13|         $triggerDate = $event->getTriggerDate();
    14|         if (null === $triggerDate) {
    15|             $this->logger->debug('CAMPAIGN: Trigger date is null');
    16|             return $compareFromDateTime;
    17|         }
    18|         if ($compareFromDateTime >= $triggerDate) {
    19|             $this->logger->debug(
    20|                 'CAMPAIGN: ('.$event->getId().') Date to execute ('.$triggerDate->format('Y-m-d H:i:s T').') compared to now ('
    21|                 .$compareFromDateTime->format('Y-m-d H:i:s T').') and is thus overdue'
    22|             );
    23|             return $compareFromDateTime;
    24|         }
    25|         return $triggerDate;
    26|     }
    27| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Scheduler/Mode/Interval.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-289 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Executioner\Scheduler\Exception\NotSchedulableException;
     7| use Mautic\CampaignBundle\Executioner\Scheduler\Mode\DAO\GroupExecutionDateDAO;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\DateTimeHelper;
    10| use Mautic\LeadBundle\Entity\Lead;
    11| use Psr\Log\LoggerInterface;
    12| class Interval implements ScheduleModeInterface
    13| {
    14|     public const LOG_DATE_FORMAT = 'Y-m-d H:i:s T';
    15|     private ?\DateTimeZone $defaultTimezone = null;
    16|     public function __construct(
    17|         private LoggerInterface $logger,
    18|         private CoreParametersHelper $coreParametersHelper,
    19|     ) {
    20|     }
    21|     /**
    22|      * @throws NotSchedulableException
    23|      */
    24|     public function getExecutionDateTime(Event $event, \DateTimeInterface $compareFromDateTime, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
    25|     {
    26|         $interval = $event->getTriggerInterval();
    27|         $unit     = $event->getTriggerIntervalUnit();
    28|         try {
    29|             $this->logger->debug(
    30|                 'CAMPAIGN: ('.$event->getId().') Adding interval of '.$interval.$unit.' to '.$comparedToDateTime->format(self::LOG_DATE_FORMAT)
    31|             );
    32|             /** @var \DateTime $comparedToDateTime */
    33|             $comparedToDateTime->add((new DateTimeHelper())->buildInterval($interval, $unit));
    34|         } catch (\Exception $exception) {
    35|             $this->logger->error('CAMPAIGN: Determining interval scheduled failed with "'.$exception->getMessage().'"');
    36|             throw new NotSchedulableException($exception->getMessage());
    37|         }
    38|         if ($comparedToDateTime > $compareFromDateTime) {
    39|             $this->logger->debug(
    40|                 'CAMPAIGN: ('.$event->getId().') '.$comparedToDateTime->format(self::LOG_DATE_FORMAT).' is later than '
    41|                 .$compareFromDateTime->format(self::LOG_DATE_FORMAT).' and thus returning '.$comparedToDateTime->format(self::LOG_DATE_FORMAT)
    42|             );
    43|             return $comparedToDateTime;
    44|         }
    45|         $this->logger->debug(
    46|             'CAMPAIGN: ('.$event->getId().') '.$comparedToDateTime->format(self::LOG_DATE_FORMAT).' is earlier than '
    47|             .$compareFromDateTime->format(self::LOG_DATE_FORMAT).' and thus returning '.$compareFromDateTime->format(self::LOG_DATE_FORMAT)
    48|         );
    49|         return $compareFromDateTime;
    50|     }
    51|     /**
    52|      * @return \DateTimeInterface
    53|      *
    54|      * @throws NotSchedulableException
    55|      */
    56|     public function validateExecutionDateTime(LeadEventLog $log, \DateTimeInterface $compareFromDateTime)
    57|     {
    58|         $event         = $log->getEvent();
    59|         $dateTriggered = clone $log->getDateTriggered();
    60|         if (!$this->isContactSpecificExecutionDateRequired($event)) {
    61|             return $this->getExecutionDateTime($event, $compareFromDateTime, $dateTriggered);
    62|         }
    63|         $interval      = $event->getTriggerInterval();
    64|         $unit          = $event->getTriggerIntervalUnit();
    65|         if ($interval && $unit) {
    66|             /** @var \DateTime $dateTriggered */
    67|             $dateTriggered->add((new DateTimeHelper())->buildInterval($interval, $unit));
    68|         }
    69|         if ($dateTriggered < $compareFromDateTime) {
    70|             $this->logger->debug(
    71|                 sprintf('CAMPAIGN: (%s) %s is earlier than %s and thus setting %s', $event->getId(), $dateTriggered->format(self::LOG_DATE_FORMAT), $compareFromDateTime->format(self::LOG_DATE_FORMAT), $compareFromDateTime->format(self::LOG_DATE_FORMAT))
    72|             );
    73|             $dateTriggered = clone $compareFromDateTime;
    74|         }
    75|         $hour      = $event->getTriggerHour();
    76|         $startTime = $event->getTriggerRestrictedStartHour();
    77|         $endTime   = $event->getTriggerRestrictedStopHour();
    78|         $dow       = $event->getTriggerRestrictedDaysOfWeek();
    79|         return $this->getGroupExecutionDateTime($event->getId(), $log->getLead(), $dateTriggered, $hour, $startTime, $endTime, $dow);
    80|     }
    81|     /**
    82|      * @return GroupExecutionDateDAO[]
    83|      */
    84|     public function groupContactsByDate(Event $event, ArrayCollection $contacts, \DateTimeInterface $executionDate, \DateTimeInterface $compareFromDateTime = null): array
    85|     {
    86|         $groupedExecutionDates = [];
    87|         $hour                  = $event->getTriggerHour();
    88|         $startTime             = $event->getTriggerRestrictedStartHour();
    89|         $endTime               = $event->getTriggerRestrictedStopHour();
    90|         $daysOfWeek            = $event->getTriggerRestrictedDaysOfWeek();
    91|         /** @var Lead $contact */
    92|         foreach ($contacts as $contact) {
    93|             $groupExecutionDate = $this->getGroupExecutionDateTime(
    94|                 $event->getId(),
    95|                 $contact,
    96|                 $executionDate,
    97|                 $hour,
    98|                 $startTime,
    99|                 $endTime,
   100|                 $daysOfWeek
   101|             );
   102|             $key = $groupExecutionDate->format(DateTimeHelper::FORMAT_DB);
   103|             if (!isset($groupedExecutionDates[$key])) {
   104|                 $groupedExecutionDates[$key] = new GroupExecutionDateDAO($groupExecutionDate);
   105|             }
   106|             $groupedExecutionDates[$key]->addContact($contact);
   107|         }
   108|         return $groupedExecutionDates;
   109|     }
   110|     /**
   111|      * Checks if an event has a relative time configured.
   112|      */
   113|     public function isContactSpecificExecutionDateRequired(Event $event): bool
   114|     {
   115|         if ($this->isTriggerModeOptimized($event)) {
   116|             return true;
   117|         }
   118|         if (!$this->isTriggerModeInterval($event) || $this->isRestrictedToDailyScheduling($event) || $this->hasTimeRelatedRestrictions($event) || $this->isNegativePath($event)) {
   119|             return false;
   120|         }
   121|         return true;
   122|     }
   123|     private function isTriggerModeInterval(Event $event): bool
   124|     {
   125|         return Event::TRIGGER_MODE_INTERVAL === $event->getTriggerMode();
   126|     }
   127|     private function isTriggerModeOptimized(Event $event): bool
   128|     {
   129|         return Event::TRIGGER_MODE_OPTIMIZED === $event->getTriggerMode();
   130|     }
   131|     private function isRestrictedToDailyScheduling(Event $event): bool
   132|     {
   133|         return !in_array($event->getTriggerIntervalUnit(), ['i', 'h', 'd', 'm', 'y'])
   134|             && empty($event->getTriggerRestrictedDaysOfWeek());
   135|     }
   136|     private function hasTimeRelatedRestrictions(Event $event): bool
   137|     {
   138|         return null === $event->getTriggerHour()
   139|             && (null === $event->getTriggerRestrictedStartHour() || null === $event->getTriggerRestrictedStopHour())
   140|             && empty($event->getTriggerRestrictedDaysOfWeek());
   141|     }
   142|     private function isNegativePath(Event $event): bool
   143|     {
   144|         if ($event->getParent()) {
   145|             return Event::TYPE_DECISION === $event->getParent()->getEventType() && Event::TYPE_ACTION === $event->getEventType() && Event::PATH_INACTION === $event->getDecisionPath();
   146|         }
   147|         return false;
   148|     }
   149|     /**
   150|      * @return \DateTimeInterface
   151|      */
   152|     private function getGroupExecutionDateTime(
   153|         $eventId,
   154|         Lead $contact,
   155|         \DateTimeInterface $compareFromDateTime,
   156|         \DateTimeInterface $hour = null,
   157|         \DateTimeInterface $startTime = null,
   158|         \DateTimeInterface $endTime = null,
   159|         array $daysOfWeek = [],
   160|     ) {
   161|         $this->logger->debug(
   162|             sprintf('CAMPAIGN: Comparing calculated executed time for event ID %s and contact ID %s with %s', $eventId, $contact->getId(), $compareFromDateTime->format('Y-m-d H:i:s e'))
   163|         );
   164|         if ($hour) {
   165|             $this->logger->debug(
   166|                 sprintf('CAMPAIGN: Scheduling event ID %s for contact ID %s based on hour of %s', $eventId, $contact->getId(), $hour->format('H:i e'))
   167|             );
   168|             $groupDateTime = $this->getExecutionDateTimeFromHour($contact, $hour, $eventId, $compareFromDateTime);
   169|         } elseif ($startTime && $endTime) {
   170|             $this->logger->debug(
   171|                 sprintf(
   172|                     'CAMPAIGN: Scheduling event ID %s for contact ID %s based on hour range of %s to %s',
   173|                     $eventId,
   174|                     $contact->getId(),
   175|                     $startTime->format('H:i e'),
   176|                     $endTime->format('H:i e')
   177|                 )
   178|             );
   179|             $groupDateTime = $this->getExecutionDateTimeBetweenHours($contact, $startTime, $endTime, $eventId, $compareFromDateTime);
   180|         } else {
   181|             $this->logger->debug(
   182|                 sprintf('CAMPAIGN: Scheduling event ID %s for contact ID %s without hour restrictions.', $eventId, $contact->getId())
   183|             );
   184|             $groupDateTime = clone $compareFromDateTime;
   185|         }
   186|         if ([] !== $daysOfWeek) {
   187|             $this->logger->debug(
   188|                 sprintf(
   189|                     'CAMPAIGN: Scheduling event ID %s for contact ID %s based on DOW restrictions of %s',
   190|                     $eventId,
   191|                     $contact->getId(),
   192|                     implode(',', $daysOfWeek)
   193|                 )
   194|             );
   195|             if (in_array(7, $daysOfWeek, true) || in_array('7', $daysOfWeek, true)) {
   196|                 throw new \LogicException('The Mautic accepts only 0-6 as day of week (0 is Sunday).');
   197|             }
   198|             while (!in_array((int) $groupDateTime->format('w'), $daysOfWeek)) {
   199|                 /** @var \DateTime $groupDateTime */
   200|                 $groupDateTime->modify('+1 day');
   201|             }
   202|         }
   203|         return $groupDateTime;
   204|     }
   205|     /**
   206|      * @return \DateTimeInterface
   207|      */
   208|     private function getExecutionDateTimeFromHour(Lead $contact, \DateTimeInterface $hour, $eventId, \DateTimeInterface $compareFromDateTime)
   209|     {
   210|         /** @var \DateTime $groupHour */
   211|         $groupHour = clone $hour;
   212|         /** @var \DateTime $groupExecutionDate */
   213|         $groupExecutionDate = $this->getGroupExecutionDateWithTimeZone($contact, $eventId, $compareFromDateTime);
   214|         $groupExecutionDate->setTime((int) $groupExecutionDate->format('H'), (int) $groupExecutionDate->format('i'));
   215|         $testGroupHour = clone $groupExecutionDate;
   216|         $testGroupHour->setTime($groupHour->format('H'), $groupHour->format('i'));
   217|         if ($groupExecutionDate <= $testGroupHour) {
   218|             return $testGroupHour;
   219|         }
   220|         return $groupExecutionDate;
   221|     }
   222|     /**
   223|      * @return \DateTimeInterface
   224|      */
   225|     private function getExecutionDateTimeBetweenHours(
   226|         Lead $contact,
   227|         \DateTimeInterface $startTime,
   228|         \DateTimeInterface $endTime,
   229|         $eventId,
   230|         \DateTimeInterface $compareFromDateTime,
   231|     ) {
   232|         /* @var \DateTime $startTime */
   233|         $startTime = clone $startTime;
   234|         /* @var \DateTime $endTime */
   235|         $endTime   = clone $endTime;
   236|         if ($endTime < $startTime) {
   237|             $tempStartTime = clone $startTime;
   238|             $startTime     = clone $endTime;
   239|             $endTime       = clone $tempStartTime;
   240|             unset($tempStartTime);
   241|         }
   242|         /** @var \DateTime $groupExecutionDate */
   243|         $groupExecutionDate = $this->getGroupExecutionDateWithTimeZone($contact, $eventId, $compareFromDateTime);
   244|         $testStartDateTime = clone $groupExecutionDate;
   245|         $testStartDateTime->setTime($startTime->format('H'), $startTime->format('i'));
   246|         $testStopDateTime = clone $groupExecutionDate;
   247|         $testStopDateTime->setTime($endTime->format('H'), $endTime->format('i'));
   248|         if ($groupExecutionDate < $testStartDateTime) {
   249|             return $testStartDateTime;
   250|         }
   251|         if ($groupExecutionDate >= $testStopDateTime) {
   252|             $groupExecutionDate->modify('+1 day')->setTime((int) $startTime->format('H'), (int) $startTime->format('i'));
   253|         }
   254|         return $groupExecutionDate;
   255|     }
   256|     /**
   257|      * @return \DateTimeZone
   258|      */
   259|     private function getDefaultTimezone()
   260|     {
   261|         if ($this->defaultTimezone) {
   262|             return $this->defaultTimezone;
   263|         }
   264|         $this->defaultTimezone = new \DateTimeZone(
   265|             $this->coreParametersHelper->get('default_timezone', 'UTC')
   266|         );
   267|         return $this->defaultTimezone;
   268|     }
   269|     private function getGroupExecutionDateWithTimeZone(Lead $contact, int $eventId, \DateTimeInterface $compareFromDateTime): \DateTimeInterface
   270|     {
   271|         /** @var \DateTime $groupExecutionDate */
   272|         $groupExecutionDate = clone $compareFromDateTime;
   273|         $contactTimezone    = $this->getDefaultTimezone();
   274|         if ($timezone = $contact->getTimezone()) {
   275|             try {
   276|                 $contactTimezone = new \DateTimeZone($timezone);
   277|                 $this->logger->debug(
   278|                     'CAMPAIGN: ('.$eventId.') Setting '.$timezone.' for contact '.$contact->getId()
   279|                 );
   280|             } catch (\Exception) {
   281|                 $this->logger->debug(
   282|                     'CAMPAIGN: ('.$eventId.') '.$timezone.' for contact '.$contact->getId().' is not recognized'
   283|                 );
   284|             }
   285|         }
   286|         $groupExecutionDate->setTimezone($contactTimezone);
   287|         return $groupExecutionDate;
   288|     }
   289| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Executioner/Scheduler/Mode/Optimized.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Executioner\Scheduler\Mode;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\LeadBundle\Entity\Lead;
     6| use Mautic\LeadBundle\Services\PeakInteractionTimer;
     7| class Optimized implements ScheduleModeInterface
     8| {
     9|     public const OPTIMIZED_TIME         = 0;
    10|     public const OPTIMIZED_DAY_AND_TIME = 1;
    11|     /** @var string[] */
    12|     public const AVAILABLE_FOR_EVENTS = ['email.send', 'message.send', 'plugin.leadpush', 'campaign.sendwebhook'];
    13|     public function __construct(
    14|         private PeakInteractionTimer $peakInteractionTimer,
    15|     ) {
    16|     }
    17|     public function getExecutionDateTime(Event $event, \DateTimeInterface $now, \DateTimeInterface $comparedToDateTime): \DateTimeInterface
    18|     {
    19|         return $now;
    20|     }
    21|     public function getExecutionDateTimeForContact(Event $event, Lead $contact): \DateTimeInterface
    22|     {
    23|         if (self::OPTIMIZED_DAY_AND_TIME === $event->getTriggerWindow()) {
    24|             return $this->peakInteractionTimer->getOptimalTimeAndDay($contact);
    25|         } else {
    26|             return $this->peakInteractionTimer->getOptimalTime($contact);
    27|         }
    28|     }
    29| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignEventAddRemoveLeadType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CampaignBundle\Form\Validator\Constraints\InfiniteLoop;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\FormBuilderInterface;
     6| use Symfony\Component\OptionsResolver\OptionsResolver;
     7| /**
     8|  * @extends AbstractType<mixed>
     9|  */
    10| class CampaignEventAddRemoveLeadType extends AbstractType
    11| {
    12|     public function buildForm(FormBuilderInterface $builder, array $options): void
    13|     {
    14|         $builder->add('addTo', CampaignListType::class, [
    15|             'label'      => 'mautic.campaign.form.addtocampaigns',
    16|             'label_attr' => ['class' => 'control-label'],
    17|             'attr'       => [
    18|                 'class' => 'form-control',
    19|             ],
    20|             'required'         => false,
    21|             'include_this'     => $options['include_this'],
    22|             'this_translation' => 'mautic.campaign.form.thiscampaign_restart',
    23|             'constraints'      => [new InfiniteLoop()],
    24|         ]);
    25|         $builder->add('removeFrom', CampaignListType::class, [
    26|             'label'      => 'mautic.campaign.form.removefromcampaigns',
    27|             'label_attr' => ['class' => 'control-label'],
    28|             'attr'       => [
    29|                 'class' => 'form-control',
    30|             ],
    31|             'required'     => false,
    32|             'include_this' => $options['include_this'],
    33|         ]);
    34|     }
    35|     public function getBlockPrefix(): string
    36|     {
    37|         return 'campaignevent_addremovelead';
    38|     }
    39|     public function configureOptions(OptionsResolver $resolver): void
    40|     {
    41|         $resolver->setDefaults([
    42|             'include_this' => false,
    43|         ]);
    44|     }
    45| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignEventJumpToEventType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Symfony\Component\Form\AbstractType;
     4| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     5| use Symfony\Component\Form\FormBuilderInterface;
     6| use Symfony\Component\Validator\Constraints\NotBlank;
     7| /**
     8|  * @extends AbstractType<mixed>
     9|  */
    10| class CampaignEventJumpToEventType extends AbstractType
    11| {
    12|     public function buildForm(FormBuilderInterface $builder, array $options): void
    13|     {
    14|         $jumpProps = $builder->getData();
    15|         $selected  = $jumpProps['jumpToEvent'] ?? null;
    16|         $builder->add(
    17|             'jumpToEvent',
    18|             ChoiceType::class,
    19|             [
    20|                 'choices'    => [],
    21|                 'multiple'   => false,
    22|                 'label'      => 'mautic.campaign.form.jump_to_event',
    23|                 'label_attr' => ['class' => 'control-label'],
    24|                 'attr'       => [
    25|                     'class'                => 'form-control',
    26|                     'data-onload-callback' => 'updateJumpToEventOptions',
    27|                     'data-selected'        => $selected,
    28|                 ],
    29|                 'constraints' => [
    30|                     new NotBlank(
    31|                         [
    32|                             'message' => 'mautic.core.value.required',
    33|                         ]
    34|                     ),
    35|                 ],
    36|             ]
    37|         );
    38|         $builder->get('jumpToEvent')->resetViewTransformers();
    39|     }
    40|     public function getBlockPrefix(): string
    41|     {
    42|         return 'campaignevent_jump_to_event';
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignEventLeadChangeType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\Type\ButtonGroupType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\FormBuilderInterface;
     6| /**
     7|  * @deprecated since Mautic 5.0, to be removed in 6.0 with no replacement.
     8|  *
     9|  * @extends AbstractType<mixed>
    10|  */
    11| class CampaignEventLeadChangeType extends AbstractType
    12| {
    13|     public function buildForm(FormBuilderInterface $builder, array $options): void
    14|     {
    15|         $data = $options['data']['action'] ?? 'added';
    16|         $builder->add('action', ButtonGroupType::class, [
    17|             'choices' => [
    18|                 'mautic.campaign.form.trigger_leadchanged_added'   => 'added',
    19|                 'mautic.campaign.form.trigger_leadchanged_removed' => 'removed',
    20|             ],
    21|             'expanded'          => true,
    22|             'multiple'          => false,
    23|             'label_attr'        => ['class' => 'control-label'],
    24|             'label'             => 'mautic.campaign.form.trigger_leadchanged',
    25|             'placeholder'       => false,
    26|             'required'          => false,
    27|             'data'              => $data,
    28|         ]);
    29|         $builder->add('campaigns', CampaignListType::class, [
    30|             'label'      => 'mautic.campaign.form.limittocampaigns',
    31|             'label_attr' => ['class' => 'control-label'],
    32|             'attr'       => [
    33|                 'class'   => 'form-control',
    34|                 'tooltip' => 'mautic.campaign.form.limittocampaigns_descr',
    35|             ],
    36|             'required' => false,
    37|         ]);
    38|     }
    39|     public function getBlockPrefix(): string
    40|     {
    41|         return 'campaignevent_leadchange';
    42|     }
    43| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignLeadSourceType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-97 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     6| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
     7| use Symfony\Component\Form\FormBuilderInterface;
     8| use Symfony\Component\OptionsResolver\OptionsResolver;
     9| use Symfony\Component\Validator\Constraints\NotBlank;
    10| /**
    11|  * @extends AbstractType<mixed>
    12|  */
    13| class CampaignLeadSourceType extends AbstractType
    14| {
    15|     public function buildForm(FormBuilderInterface $builder, array $options): void
    16|     {
    17|         $sourceType    = $options['data']['sourceType'];
    18|         $sourceChoices = $options['source_choices'] ?? [];
    19|         foreach ($sourceChoices as $key => $val) {
    20|             $sourceChoices[$key] = $val.' ('.$key.')';
    21|         }
    22|         switch ($sourceType) {
    23|             case 'lists':
    24|                 $builder->add(
    25|                     'lists',
    26|                     ChoiceType::class,
    27|                     [
    28|                         'choices'           => array_flip($sourceChoices),
    29|                         'multiple'          => true,
    30|                         'label'             => 'mautic.campaign.leadsource.lists',
    31|                         'label_attr'        => ['class' => 'control-label'],
    32|                         'attr'              => [
    33|                             'class' => 'form-control',
    34|                         ],
    35|                         'constraints' => [
    36|                             new NotBlank(
    37|                                 [
    38|                                     'message' => 'mautic.core.value.required',
    39|                                 ]
    40|                             ),
    41|                         ],
    42|                     ]
    43|                 );
    44|                 break;
    45|             case 'forms':
    46|                 $builder->add(
    47|                     'forms',
    48|                     ChoiceType::class,
    49|                     [
    50|                         'choices'           => array_flip($sourceChoices),
    51|                         'multiple'          => true,
    52|                         'label'             => 'mautic.campaign.leadsource.forms',
    53|                         'label_attr'        => ['class' => 'control-label'],
    54|                         'attr'              => [
    55|                             'class' => 'form-control',
    56|                         ],
    57|                         'constraints' => [
    58|                             new NotBlank(
    59|                                 [
    60|                                     'message' => 'mautic.core.value.required',
    61|                                 ]
    62|                             ),
    63|                         ],
    64|                     ]
    65|                 );
    66|                 break;
    67|             default:
    68|                 break;
    69|         }
    70|         $builder->add('sourceType', HiddenType::class);
    71|         $builder->add('droppedX', HiddenType::class);
    72|         $builder->add('droppedY', HiddenType::class);
    73|         $update = !empty($options['data'][$sourceType]);
    74|         if (!empty($update)) {
    75|             $btnValue = 'mautic.core.form.update';
    76|             $btnIcon  = 'ri-edit-line';
    77|         } else {
    78|             $btnValue = 'mautic.core.form.add';
    79|             $btnIcon  = 'ri-add-line';
    80|         }
    81|         $builder->add('buttons', FormButtonsType::class, [
    82|             'save_text'       => $btnValue,
    83|             'save_icon'       => $btnIcon,
    84|             'save_onclick'    => 'Mautic.submitCampaignSource(event)',
    85|             'apply_text'      => false,
    86|             'container_class' => 'bottom-form-buttons',
    87|         ]);
    88|     }
    89|     public function configureOptions(OptionsResolver $resolver): void
    90|     {
    91|         $resolver->setRequired(['source_choices']);
    92|     }
    93|     public function getBlockPrefix(): string
    94|     {
    95|         return 'campaign_leadsource';
    96|     }
    97| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignListType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CampaignBundle\Model\CampaignModel;
     4| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     5| use Symfony\Component\Form\AbstractType;
     6| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     7| use Symfony\Component\OptionsResolver\Options;
     8| use Symfony\Component\OptionsResolver\OptionsResolver;
     9| use Symfony\Contracts\Translation\TranslatorInterface;
    10| /**
    11|  * @extends AbstractType<mixed>
    12|  */
    13| class CampaignListType extends AbstractType
    14| {
    15|     /**
    16|      * @var bool
    17|      */
    18|     private $canViewOther = false;
    19|     public function __construct(
    20|         private CampaignModel $model,
    21|         protected TranslatorInterface $translator,
    22|         CorePermissions $security,
    23|     ) {
    24|         $this->canViewOther = $security->isGranted('campaign:campaigns:viewother');
    25|     }
    26|     public function configureOptions(OptionsResolver $resolver): void
    27|     {
    28|         $resolver->setDefaults(
    29|             [
    30|                 'choices'      => function (Options $options): array {
    31|                     $choices   = [];
    32|                     $campaigns = $this->model->getRepository()->getPublishedCampaigns(null, null, true, $this->canViewOther);
    33|                     foreach ($campaigns as $campaign) {
    34|                         $choices[$campaign['name']] = $campaign['id'];
    35|                     }
    36|                     ksort($choices);
    37|                     if ($options['include_this']) {
    38|                         $choices = [$options['this_translation'] => 'this'] + $choices;
    39|                     }
    40|                     return $choices;
    41|                 },
    42|                 'placeholder'       => false,
    43|                 'expanded'          => false,
    44|                 'multiple'          => true,
    45|                 'required'          => false,
    46|                 'include_this'      => false,
    47|                 'this_translation'  => 'mautic.campaign.form.thiscampaign',
    48|             ]
    49|         );
    50|     }
    51|     public function getParent(): ?string
    52|     {
    53|         return ChoiceType::class;
    54|     }
    55| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/CampaignType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-113 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CategoryBundle\Form\Type\CategoryListType;
     5| use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
     6| use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
     7| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     8| use Mautic\CoreBundle\Form\Type\PublishDownDateType;
     9| use Mautic\CoreBundle\Form\Type\PublishUpDateType;
    10| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
    11| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    12| use Symfony\Component\Form\AbstractType;
    13| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
    14| use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    15| use Symfony\Component\Form\Extension\Core\Type\TextType;
    16| use Symfony\Component\Form\FormBuilderInterface;
    17| use Symfony\Component\OptionsResolver\OptionsResolver;
    18| use Symfony\Contracts\Translation\TranslatorInterface;
    19| /**
    20|  * @extends AbstractType<Campaign>
    21|  */
    22| class CampaignType extends AbstractType
    23| {
    24|     public function __construct(
    25|         private CorePermissions $security,
    26|         private TranslatorInterface $translator,
    27|     ) {
    28|     }
    29|     public function buildForm(FormBuilderInterface $builder, array $options): void
    30|     {
    31|         $builder->addEventSubscriber(new CleanFormSubscriber(['description' => 'html']));
    32|         $builder->addEventSubscriber(new FormExitSubscriber('campaign', $options));
    33|         $builder->add('name', TextType::class, [
    34|             'label'      => 'mautic.core.name',
    35|             'label_attr' => ['class' => 'control-label'],
    36|             'attr'       => ['class' => 'form-control'],
    37|         ]);
    38|         $builder->add('description', TextareaType::class, [
    39|             'label'      => 'mautic.core.description',
    40|             'label_attr' => ['class' => 'control-label'],
    41|             'attr'       => ['class' => 'form-control editor'],
    42|             'required'   => false,
    43|         ]);
    44|         $builder->add('allowRestart',
    45|             YesNoButtonGroupType::class,
    46|             [
    47|                 'label' => 'mautic.campaign.allow_restart',
    48|                 'attr'  => [
    49|                     'tooltip' => 'mautic.campaign.allow_restart.tooltip',
    50|                 ],
    51|             ]
    52|         );
    53|         $builder->add('category', CategoryListType::class, [
    54|             'bundle' => 'campaign',
    55|         ]);
    56|         $attr = [];
    57|         if (!empty($options['data']) && $options['data']->getId()) {
    58|             $readonly = !$this->security->isGranted('campaign:campaigns:publish');
    59|             $data     = $options['data']->isPublished(false);
    60|             $attr     = [
    61|                 'onchange'              => 'Mautic.showCampaignConfirmation(mQuery(this));',
    62|                 'data-toggle'           => 'confirmation',
    63|                 'data-message'          => $this->translator->trans('mautic.campaign.form.confirmation.message'),
    64|                 'data-confirm-text'     => $this->translator->trans('mautic.campaign.form.confirmation.confirm_text'),
    65|                 'data-confirm-callback' => 'dismissConfirmation',
    66|                 'data-cancel-text'      => $this->translator->trans('mautic.campaign.form.confirmation.cancel_text'),
    67|                 'data-cancel-callback'  => 'setPublishedButtonToYes',
    68|                 'class'                 => 'btn btn-ghost',
    69|             ];
    70|         } elseif (!$this->security->isGranted('campaign:campaigns:publish')) {
    71|             $readonly = true;
    72|             $data     = false;
    73|         } else {
    74|             $readonly = false;
    75|             $data     = false;
    76|         }
    77|         $attr['readonly'] = $readonly;
    78|         $builder->add('isPublished', YesNoButtonGroupType::class, [
    79|             'data' => $data,
    80|             'attr' => $attr,
    81|         ]);
    82|         $builder->add('publishUp', PublishUpDateType::class);
    83|         $builder->add('publishDown', PublishDownDateType::class);
    84|         $builder->add('sessionId', HiddenType::class, [
    85|             'mapped' => false,
    86|         ]);
    87|         if (!empty($options['action'])) {
    88|             $builder->setAction($options['action']);
    89|         }
    90|         $builder->add('buttons', FormButtonsType::class, [
    91|             'pre_extra_buttons' => [
    92|                 [
    93|                     'name'  => 'builder',
    94|                     'label' => 'mautic.campaign.campaign.launch.builder',
    95|                     'attr'  => [
    96|                         'class'   => 'btn btn-ghost btn-dnd',
    97|                         'icon'    => 'ri-organization-chart',
    98|                         'onclick' => 'Mautic.launchCampaignEditor();',
    99|                     ],
   100|                 ],
   101|             ],
   102|         ]);
   103|         $builder->add('version', HiddenType::class, [
   104|             'mapped' => false,
   105|         ]);
   106|     }
   107|     public function configureOptions(OptionsResolver $resolver): void
   108|     {
   109|         $resolver->setDefaults([
   110|             'data_class' => Campaign::class,
   111|         ]);
   112|     }
   113| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-227 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     6| use Symfony\Component\Form\Extension\Core\Type\NumberType;
     7| use Symfony\Component\Form\FormBuilderInterface;
     8| use Symfony\Component\Validator\Constraints\Callback;
     9| use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
    10| use Symfony\Component\Validator\Constraints\Range;
    11| use Symfony\Component\Validator\Context\ExecutionContextInterface;
    12| use Symfony\Contracts\Translation\TranslatorInterface;
    13| /**
    14|  * @extends AbstractType<mixed>
    15|  */
    16| class ConfigType extends AbstractType
    17| {
    18|     public function __construct(
    19|         private TranslatorInterface $translator,
    20|     ) {
    21|     }
    22|     public function buildForm(FormBuilderInterface $builder, array $options): void
    23|     {
    24|         $builder->add(
    25|             'campaign_time_wait_on_event_false',
    26|             ChoiceType::class,
    27|             [
    28|                 'label'      => 'mautic.campaignconfig.campaign_time_wait_on_event_false',
    29|                 'label_attr' => ['class' => 'control-label'],
    30|                 'help'       => 'mautic.campaignconfig.campaign_time_wait_on_event_false_help',
    31|                 'data'       => $options['data']['campaign_time_wait_on_event_false'],
    32|                 'choices'    => [
    33|                     'mautic.core.never' => 'null',
    34|                     '15 mn'             => 'PT15M',
    35|                     '30 mn'             => 'PT30M',
    36|                     '45 mn'             => 'PT45M',
    37|                     '1 h'               => 'PT1H',
    38|                     '2 h'               => 'PT2H',
    39|                     '4 h'               => 'PT4H',
    40|                     '8 h'               => 'PT8H',
    41|                     '12 h'              => 'PT12H',
    42|                     '24 h'              => 'PT1D',
    43|                     '3 days'            => 'PT3D',
    44|                     '5 days'            => 'PT5D',
    45|                     '1 week'            => 'PT14D',
    46|                     '3 months'          => 'P3M',
    47|                 ],
    48|                 'attr'              => [
    49|                     'class'   => 'form-control',
    50|                     'tooltip' => 'mautic.campaignconfig.campaign_time_wait_on_event_false_tooltip',
    51|                 ],
    52|                 'required' => false,
    53|             ]
    54|         );
    55|         $builder->add(
    56|             'campaign_by_range',
    57|             YesNoButtonGroupType::class,
    58|             [
    59|                 'label' => 'mautic.campaignconfig.campaign_by_range',
    60|                 'attr'  => [
    61|                     'tooltip' => 'mautic.campaignconfig.campaign_by_range.tooltip',
    62|                 ],
    63|                 'data'  => (bool) ($options['data']['campaign_by_range'] ?? false),
    64|             ]
    65|         );
    66|         $builder->add(
    67|             'campaign_use_summary',
    68|             YesNoButtonGroupType::class,
    69|             [
    70|                 'label' => 'mautic.campaignconfig.use_summary',
    71|                 'attr'  => [
    72|                     'tooltip' => 'mautic.campaignconfig.use_summary.tooltip',
    73|                 ],
    74|                 'data'  => (bool) ($options['data']['campaign_use_summary'] ?? false),
    75|             ]
    76|         );
    77|         $builder->add(
    78|             'campaign_email_stats_enabled',
    79|             YesNoButtonGroupType::class,
    80|             [
    81|                 'label'      => 'mautic.campaignconfig.campaign_email_stats_enabled',
    82|                 'label_attr' => ['class' => 'control-label'],
    83|                 'data'       => $options['data']['campaign_email_stats_enabled'] ?? true,
    84|                 'required'   => false,
    85|                 'attr'       => [
    86|                     'class'   => 'form-control',
    87|                     'tooltip' => 'mautic.campaignconfig.campaign_email_stats_enabled.tooltip',
    88|                 ],
    89|             ]
    90|         );
    91|         $builder->add(
    92|             'peak_interaction_timer_best_default_hour_start',
    93|             NumberType::class,
    94|             [
    95|                 'label'      => 'mautic.config.peak_interaction_timer.best_default_hour_start',
    96|                 'label_attr' => ['class' => 'control-label'],
    97|                 'attr'       => [
    98|                     'class'   => 'form-control',
    99|                     'tooltip' => 'mautic.config.peak_interaction_timer.best_default_hour_start.tooltip',
   100|                 ],
   101|                 'data'        => $options['data']['peak_interaction_timer_best_default_hour_start'] ?? 9,
   102|                 'constraints' => [
   103|                     new Range([
   104|                         'min' => 0,
   105|                         'max' => 23,
   106|                     ]),
   107|                 ],
   108|             ]
   109|         );
   110|         $builder->add(
   111|             'peak_interaction_timer_best_default_hour_end',
   112|             NumberType::class,
   113|             [
   114|                 'label'      => 'mautic.config.peak_interaction_timer.best_default_hour_end',
   115|                 'label_attr' => ['class' => 'control-label'],
   116|                 'attr'       => [
   117|                     'class'   => 'form-control',
   118|                     'tooltip' => 'mautic.config.peak_interaction_timer.best_default_hour_end.tooltip',
   119|                 ],
   120|                 'data'        => $options['data']['peak_interaction_timer_best_default_hour_end'] ?? 12,
   121|                 'constraints' => [
   122|                     new Range([
   123|                         'min' => 0,
   124|                         'max' => 23,
   125|                     ]),
   126|                     new Callback(
   127|                         function ($hourEnd, ExecutionContextInterface $context): void {
   128|                             $data      = $context->getRoot()->getData();
   129|                             $hourStart = $data['campaignconfig']['peak_interaction_timer_best_default_hour_start'] ?? null;
   130|                             if (null !== $hourStart && null !== $hourEnd && $hourStart >= $hourEnd) {
   131|                                 $context->buildViolation('mautic.config.peak_interaction_timer.best_default_hour.validation.range')->addViolation();
   132|                             }
   133|                         }
   134|                     ),
   135|                 ],
   136|             ]
   137|         );
   138|         $builder->add(
   139|             'peak_interaction_timer_best_default_days',
   140|             ChoiceType::class,
   141|             [
   142|                 'label'      => 'mautic.config.peak_interaction_timer.best_default_days',
   143|                 'label_attr' => ['class' => 'control-label'],
   144|                 'attr'       => [
   145|                     'class'   => 'form-control',
   146|                     'tooltip' => 'mautic.config.peak_interaction_timer.best_default_days.tooltip',
   147|                 ],
   148|                 'choices' => [
   149|                     'mautic.core.date.monday'    => 1,
   150|                     'mautic.core.date.tuesday'   => 2,
   151|                     'mautic.core.date.wednesday' => 3,
   152|                     'mautic.core.date.thursday'  => 4,
   153|                     'mautic.core.date.friday'    => 5,
   154|                     'mautic.core.date.saturday'  => 6,
   155|                     'mautic.core.date.sunday'    => 7,
   156|                 ],
   157|                 'data'     => $options['data']['peak_interaction_timer_best_default_days'] ?? [2, 3, 4],
   158|                 'multiple' => true,
   159|                 'required' => true,
   160|             ]
   161|         );
   162|         $builder->add(
   163|             'peak_interaction_timer_cache_timeout',
   164|             ChoiceType::class,
   165|             [
   166|                 'label'      => 'mautic.config.peak_interaction_timer.cache_timeout',
   167|                 'label_attr' => ['class' => 'control-label'],
   168|                 'attr'       => [
   169|                     'class'   => 'form-control',
   170|                     'tooltip' => 'mautic.config.peak_interaction_timer.cache_timeout.tooltip',
   171|                 ],
   172|                 'choices' => [
   173|                     'mautic.config.peak_interaction_timer.cache.off'                                        => 0,
   174|                     '1 '.$this->translator->trans('mautic.campaign.event.intervalunit.d', ['%count%' => 1]) => 1440,
   175|                     '7 '.$this->translator->trans('mautic.campaign.event.intervalunit.d', ['%count%' => 7]) => 10080,
   176|                     '1 '.$this->translator->trans('mautic.campaign.event.intervalunit.m', ['%count%' => 1]) => 43800,
   177|                 ],
   178|                 'data'        => $options['data']['peak_interaction_timer_cache_timeout'] ?? 43800,
   179|                 'constraints' => [
   180|                     new GreaterThanOrEqual([
   181|                         'value' => 0,
   182|                     ]),
   183|                 ],
   184|             ]
   185|         );
   186|         $builder->add(
   187|             'peak_interaction_timer_fetch_interactions_from',
   188|             ChoiceType::class,
   189|             [
   190|                 'label'      => 'mautic.config.peak_interaction_timer.fetch_interactions_from',
   191|                 'label_attr' => ['class' => 'control-label'],
   192|                 'attr'       => [
   193|                     'class'   => 'form-control',
   194|                     'tooltip' => 'mautic.config.peak_interaction_timer.fetch_interactions_from.tooltip',
   195|                 ],
   196|                 'choices' => [
   197|                     'mautic.config.peak_interaction_timer.fetch.from_30_days' => '-30 days',
   198|                     'mautic.config.peak_interaction_timer.fetch.from_60_days' => '-60 days',
   199|                     'mautic.config.peak_interaction_timer.fetch.from_90_days' => '-90 days',
   200|                 ],
   201|                 'data' => $options['data']['peak_interaction_timer_fetch_interactions_from'] ?? '-60 days',
   202|             ]
   203|         );
   204|         $builder->add(
   205|             'peak_interaction_timer_fetch_limit',
   206|             NumberType::class,
   207|             [
   208|                 'label'      => 'mautic.config.peak_interaction_timer.fetch_limit',
   209|                 'label_attr' => ['class' => 'control-label'],
   210|                 'attr'       => [
   211|                     'class'   => 'form-control',
   212|                     'tooltip' => 'mautic.config.peak_interaction_timer.fetch_limit.tooltip',
   213|                 ],
   214|                 'data'        => $options['data']['peak_interaction_timer_fetch_limit'] ?? 50,
   215|                 'constraints' => [
   216|                     new GreaterThanOrEqual([
   217|                         'value' => 10,
   218|                     ]),
   219|                 ],
   220|             ]
   221|         );
   222|     }
   223|     public function getBlockPrefix(): string
   224|     {
   225|         return 'campaignconfig';
   226|     }
   227| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/EventCanvasSettingsType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Symfony\Component\Form\AbstractType;
     4| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
     5| use Symfony\Component\Form\FormBuilderInterface;
     6| /**
     7|  * @extends AbstractType<mixed>
     8|  */
     9| class EventCanvasSettingsType extends AbstractType
    10| {
    11|     public function buildForm(FormBuilderInterface $builder, array $options): void
    12|     {
    13|         $builder->add('droppedX', HiddenType::class);
    14|         $builder->add('droppedY', HiddenType::class);
    15|     }
    16|     public function getBlockPrefix(): string
    17|     {
    18|         return 'campaignevent_canvassettings';
    19|     }
    20| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Type/EventType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-299 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Form\Type;
     3| use Mautic\CampaignBundle\Executioner\Scheduler\Mode\Optimized as OptimizedScheduler;
     4| use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
     5| use Mautic\CoreBundle\Form\Type\ButtonGroupType;
     6| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     7| use Mautic\CoreBundle\Form\Type\PropertiesTrait;
     8| use Symfony\Component\Form\AbstractType;
     9| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
    10| use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
    11| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
    12| use Symfony\Component\Form\Extension\Core\Type\IntegerType;
    13| use Symfony\Component\Form\Extension\Core\Type\TextType;
    14| use Symfony\Component\Form\FormBuilderInterface;
    15| use Symfony\Component\Form\FormEvent;
    16| use Symfony\Component\Form\FormEvents;
    17| use Symfony\Component\OptionsResolver\OptionsResolver;
    18| /**
    19|  * @extends AbstractType<mixed>
    20|  */
    21| class EventType extends AbstractType
    22| {
    23|     use PropertiesTrait;
    24|     public function buildForm(FormBuilderInterface $builder, array $options): void
    25|     {
    26|         $masks = [];
    27|         $builder->add(
    28|             'name',
    29|             TextType::class,
    30|             [
    31|                 'label'      => 'mautic.core.name',
    32|                 'label_attr' => ['class' => 'control-label'],
    33|                 'attr'       => ['class' => 'form-control'],
    34|                 'required'   => false,
    35|             ]
    36|         );
    37|         $builder->add(
    38|             'anchor',
    39|             HiddenType::class,
    40|             [
    41|                 'label' => false,
    42|             ]
    43|         );
    44|         if (in_array($options['data']['eventType'], ['action', 'condition'])) {
    45|             $label = 'mautic.campaign.form.type';
    46|             $choices = [
    47|                 'immediate' => 'mautic.campaign.form.type.immediate',
    48|                 'interval'  => 'mautic.campaign.form.type.interval',
    49|                 'date'      => 'mautic.campaign.form.type.date',
    50|             ];
    51|             if (in_array($options['data']['type'], OptimizedScheduler::AVAILABLE_FOR_EVENTS)) {
    52|                 $choices['optimized'] = 'mautic.campaign.form.type.optimized';
    53|             }
    54|             if ('no' == $options['data']['anchor'] && 'condition' != $options['data']['anchorEventType']
    55|                 && 'condition' != $options['data']['eventType']
    56|             ) {
    57|                 $label .= '_inaction';
    58|                 unset($choices['immediate']);
    59|                 $choices['interval'] = $choices['interval'].'_inaction';
    60|                 $choices['date']     = $choices['date'].'_inaction';
    61|             }
    62|             $default = array_key_first($choices);
    63|             $triggerMode = (empty($options['data']['triggerMode'])) ? $default : $options['data']['triggerMode'];
    64|             $builder->add(
    65|                 'triggerMode',
    66|                 ButtonGroupType::class,
    67|                 [
    68|                     'choices'           => array_flip($choices),
    69|                     'expanded'          => true,
    70|                     'multiple'          => false,
    71|                     'label_attr'        => ['class' => 'control-label'],
    72|                     'label'             => $label,
    73|                     'placeholder'       => false,
    74|                     'required'          => false,
    75|                     'attr'              => [
    76|                         'onchange' => 'Mautic.campaignToggleTimeframes();',
    77|                         'tooltip'  => 'mautic.campaign.form.type.help',
    78|                     ],
    79|                     'data'        => $triggerMode,
    80|                 ]
    81|             );
    82|             $builder->add(
    83|                 'triggerDate',
    84|                 DateTimeType::class,
    85|                 [
    86|                     'label'  => false,
    87|                     'attr'   => [
    88|                         'class'       => 'form-control',
    89|                         'preaddon'    => 'ri-calendar-line',
    90|                         'data-toggle' => 'datetime',
    91|                     ],
    92|                     'widget' => 'single_text',
    93|                     'html5'  => false,
    94|                     'format' => 'yyyy-MM-dd HH:mm',
    95|                 ]
    96|             );
    97|             $data = (!isset($options['data']['triggerInterval']) || '' === $options['data']['triggerInterval']
    98|                 || null === $options['data']['triggerInterval']) ? 1 : (int) $options['data']['triggerInterval'];
    99|             $builder->add(
   100|                 'triggerInterval',
   101|                 IntegerType::class,
   102|                 [
   103|                     'label' => false,
   104|                     'attr'  => [
   105|                         'class'    => 'form-control',
   106|                         'preaddon' => 'symbol-hashtag',
   107|                     ],
   108|                     'data'  => $data,
   109|                 ]
   110|             );
   111|             $data = (!empty($options['data']['triggerIntervalUnit'])) ? $options['data']['triggerIntervalUnit'] : 'd';
   112|             $builder->add(
   113|                 'triggerIntervalUnit',
   114|                 ChoiceType::class,
   115|                 [
   116|                     'choices'     => [
   117|                         'mautic.campaign.event.intervalunit.choice.i' => 'i',
   118|                         'mautic.campaign.event.intervalunit.choice.h' => 'h',
   119|                         'mautic.campaign.event.intervalunit.choice.d' => 'd',
   120|                         'mautic.campaign.event.intervalunit.choice.m' => 'm',
   121|                         'mautic.campaign.event.intervalunit.choice.y' => 'y',
   122|                     ],
   123|                     'multiple'          => false,
   124|                     'label_attr'        => ['class' => 'control-label'],
   125|                     'label'             => false,
   126|                     'attr'              => [
   127|                         'class' => 'form-control',
   128|                     ],
   129|                     'placeholder' => false,
   130|                     'required'    => false,
   131|                     'data'        => $data,
   132|                 ]
   133|             );
   134|             $data = $this->getTimeValue($options['data'], 'triggerHour');
   135|             $builder->add(
   136|                 'triggerHour',
   137|                 TextType::class,
   138|                 [
   139|                     'label' => false,
   140|                     'attr'  => [
   141|                         'class'        => 'form-control',
   142|                         'data-toggle'  => 'time',
   143|                         'data-format'  => 'H:i',
   144|                         'autocomplete' => 'off',
   145|                     ],
   146|                     'data'  => ($data) ? $data->format('H:i') : $data,
   147|                 ]
   148|             );
   149|             $data = $this->getTimeValue($options['data'], 'triggerRestrictedStartHour');
   150|             $builder->add(
   151|                 'triggerRestrictedStartHour',
   152|                 TextType::class,
   153|                 [
   154|                     'label' => false,
   155|                     'attr'  => [
   156|                         'class'        => 'form-control',
   157|                         'data-toggle'  => 'time',
   158|                         'data-format'  => 'H:i',
   159|                         'autocomplete' => 'off',
   160|                     ],
   161|                     'data'  => ($data) ? $data->format('H:i') : $data,
   162|                 ]
   163|             );
   164|             $data = $this->getTimeValue($options['data'], 'triggerRestrictedStopHour');
   165|             $builder->add(
   166|                 'triggerRestrictedStopHour',
   167|                 TextType::class,
   168|                 [
   169|                     'label' => false,
   170|                     'attr'  => [
   171|                         'class'        => 'form-control',
   172|                         'data-toggle'  => 'time',
   173|                         'data-format'  => 'H:i',
   174|                         'autocomplete' => 'off',
   175|                     ],
   176|                     'data'  => ($data) ? $data->format('H:i') : $data,
   177|                 ]
   178|             );
   179|             $builder->add(
   180|                 'triggerRestrictedDaysOfWeek',
   181|                 ChoiceType::class,
   182|                 [
   183|                     'label'    => true,
   184|                     'attr'     => [
   185|                         'data-toggle' => 'time',
   186|                         'data-format' => 'H:i',
   187|                     ],
   188|                     'choices'  => [
   189|                         'mautic.report.schedule.day.monday'     => 1,
   190|                         'mautic.report.schedule.day.tuesday'    => 2,
   191|                         'mautic.report.schedule.day.wednesday'  => 3,
   192|                         'mautic.report.schedule.day.thursday'   => 4,
   193|                         'mautic.report.schedule.day.friday'     => 5,
   194|                         'mautic.report.schedule.day.saturday'   => 6,
   195|                         'mautic.report.schedule.day.sunday'     => 0,
   196|                         'mautic.report.schedule.day.week_days'  => -1,
   197|                     ],
   198|                     'expanded'          => true,
   199|                     'multiple'          => true,
   200|                     'required'          => false,
   201|                 ]
   202|             );
   203|             $builder->add(
   204|                 'triggerWindow',
   205|                 ChoiceType::class,
   206|                 [
   207|                     'label'    => false,
   208|                     'choices'  => [
   209|                         'mautic.campaign.form.type.trigger_window_day'   => OptimizedScheduler::OPTIMIZED_TIME,
   210|                         'mautic.campaign.form.type.trigger_window_week'  => OptimizedScheduler::OPTIMIZED_DAY_AND_TIME,
   211|                     ],
   212|                     'data'              => $options['data']['triggerWindow'] ?? 0,
   213|                     'required'          => false,
   214|                     'expanded'          => true,
   215|                     'placeholder'       => false,
   216|                 ]
   217|             );
   218|             $builder->addEventListener(FormEvents::PRE_SUBMIT, function (FormEvent $event): void {
   219|                 $data        = $event->getData();
   220|                 $triggerMode = $data['triggerMode'] ?? 'immediate';
   221|                 if ('optimized' !== $triggerMode) {
   222|                     $data['triggerWindow'] = null;
   223|                     $event->setData($data);
   224|                 }
   225|             });
   226|         }
   227|         if (!empty($options['settings']['formType'])) {
   228|             $this->addPropertiesType($builder, $options, $masks);
   229|         }
   230|         $builder->add('type', HiddenType::class);
   231|         $builder->add('eventType', HiddenType::class);
   232|         $builder->add(
   233|             'anchorEventType',
   234|             HiddenType::class,
   235|             [
   236|                 'mapped' => false,
   237|                 'data'   => $options['data']['anchorEventType'] ?? '',
   238|             ]
   239|         );
   240|         $builder->add(
   241|             'canvasSettings',
   242|             EventCanvasSettingsType::class,
   243|             [
   244|                 'label' => false,
   245|             ]
   246|         );
   247|         $update = !empty($options['data']['properties']);
   248|         if (!empty($update)) {
   249|             $btnValue = 'mautic.core.form.update';
   250|             $btnIcon  = 'ri-edit-line';
   251|         } else {
   252|             $btnValue = 'mautic.core.form.add';
   253|             $btnIcon  = 'ri-add-line';
   254|         }
   255|         $builder->add(
   256|             'buttons',
   257|             FormButtonsType::class,
   258|             [
   259|                 'save_text'       => $btnValue,
   260|                 'save_icon'       => $btnIcon,
   261|                 'save_onclick'    => 'Mautic.submitCampaignEvent(event)',
   262|                 'apply_text'      => false,
   263|                 'container_class' => 'bottom-form-buttons',
   264|             ]
   265|         );
   266|         $builder->add(
   267|             'campaignId',
   268|             HiddenType::class,
   269|             [
   270|                 'mapped' => false,
   271|             ]
   272|         );
   273|         $builder->addEventSubscriber(new CleanFormSubscriber($masks));
   274|         if (!empty($options['action'])) {
   275|             $builder->setAction($options['action']);
   276|         }
   277|     }
   278|     public function configureOptions(OptionsResolver $resolver): void
   279|     {
   280|         $resolver->setRequired(['settings']);
   281|     }
   282|     /**
   283|      * @return \DateTime|mixed|null
   284|      */
   285|     private function getTimeValue(array $data, $name)
   286|     {
   287|         if (empty($data[$name])) {
   288|             return null;
   289|         }
   290|         if ($data[$name] instanceof \DateTime) {
   291|             return $data[$name];
   292|         }
   293|         return new \DateTime($data[$name]);
   294|     }
   295|     public function getBlockPrefix(): string
   296|     {
   297|         return 'campaignevent';
   298|     }
   299| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Form/Validator/Constraints/InfiniteLoopValidator.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CampaignBundle\Form\Validator\Constraints;
     4| use Symfony\Component\Validator\Constraint;
     5| use Symfony\Component\Validator\ConstraintValidator;
     6| use Symfony\Component\Validator\Context\ExecutionContextInterface;
     7| use Symfony\Component\Validator\Exception\UnexpectedTypeException;
     8| final class InfiniteLoopValidator extends ConstraintValidator
     9| {
    10|     public function validate(mixed $value, Constraint $constraint): void
    11|     {
    12|         if (!$constraint instanceof InfiniteLoop) {
    13|             throw new UnexpectedTypeException($constraint, InfiniteLoop::class);
    14|         }
    15|         $data = $this->context->getRoot()->getData();
    16|         $this->validateEvent($this->context, $data['triggerMode'] ?? '', $value, (int) ($data['triggerInterval'] ?? 0), $data['triggerIntervalUnit'] ?? '');
    17|     }
    18|     /**
    19|      * @param string[] $addTo
    20|      */
    21|     public function validateEvent(ExecutionContextInterface $context, string $triggerMode, array $addTo, int $triggerInterval, string $triggerIntervalUnit): void
    22|     {
    23|         if (!in_array('this', $addTo)) {
    24|             return;
    25|         }
    26|         if ('immediate' === $triggerMode) {
    27|             $context->buildViolation('mautic.campaign.infiniteloop.immediate')->addViolation();
    28|             return;
    29|         }
    30|         if ('interval' === $triggerMode && 'i' === $triggerIntervalUnit && $triggerInterval < 30) {
    31|             $context->buildViolation('mautic.campaign.infiniteloop.interval')
    32|                 ->setParameter('%count%', (string) $triggerInterval)
    33|                 ->addViolation();
    34|         }
    35|     }
    36| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Membership/Action/Adder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-59 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Membership\Action;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
     5| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     6| use Mautic\CampaignBundle\Entity\LeadRepository;
     7| use Mautic\CampaignBundle\Membership\Exception\ContactCannotBeAddedToCampaignException;
     8| use Mautic\LeadBundle\Entity\Lead;
     9| class Adder
    10| {
    11|     public const NAME = 'added';
    12|     public function __construct(
    13|         private LeadRepository $leadRepository,
    14|         private LeadEventLogRepository $leadEventLogRepository,
    15|     ) {
    16|     }
    17|     public function createNewMembership(Lead $contact, Campaign $campaign, $isManualAction): CampaignMember
    18|     {
    19|         $rotation = 1;
    20|         if ($this->leadEventLogRepository->hasBeenInCampaignRotation($contact->getId(), $campaign->getId(), 1)) {
    21|             $rotation = 2;
    22|         }
    23|         $campaignMember = new CampaignMember();
    24|         $campaignMember->setLead($contact);
    25|         $campaignMember->setCampaign($campaign);
    26|         $campaignMember->setManuallyAdded($isManualAction);
    27|         $campaignMember->setDateAdded(new \DateTime());
    28|         $campaignMember->setRotation($rotation);
    29|         $this->saveCampaignMember($campaignMember);
    30|         return $campaignMember;
    31|     }
    32|     /**
    33|      * @param bool $isManualAction
    34|      *
    35|      * @throws ContactCannotBeAddedToCampaignException
    36|      */
    37|     public function updateExistingMembership(CampaignMember $campaignMember, $isManualAction): void
    38|     {
    39|         $wasRemoved = $campaignMember->wasManuallyRemoved();
    40|         if (!($wasRemoved && $isManualAction) && !$campaignMember->getCampaign()->allowRestart()) {
    41|             throw new ContactCannotBeAddedToCampaignException('Contacts cannot restart the campaign');
    42|         }
    43|         if ($wasRemoved && !$isManualAction && null === $campaignMember->getDateLastExited()) {
    44|             throw new ContactCannotBeAddedToCampaignException('Contact was manually removed');
    45|         }
    46|         if ($wasRemoved && $isManualAction) {
    47|             $campaignMember->setManuallyAdded($isManualAction);
    48|         }
    49|         $campaignMember->setManuallyRemoved(false);
    50|         $campaignMember->setDateLastExited(null);
    51|         $campaignMember->startNewRotation();
    52|         $this->saveCampaignMember($campaignMember);
    53|     }
    54|     private function saveCampaignMember($campaignMember): void
    55|     {
    56|         $this->leadRepository->saveEntity($campaignMember);
    57|         $this->leadRepository->detachEntity($campaignMember);
    58|     }
    59| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Membership/Action/Remover.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Membership\Action;
     3| use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
     4| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     5| use Mautic\CampaignBundle\Entity\LeadRepository;
     6| use Mautic\CampaignBundle\Membership\Exception\ContactAlreadyRemovedFromCampaignException;
     7| use Mautic\CoreBundle\Twig\Helper\DateHelper;
     8| use Symfony\Contracts\Translation\TranslatorInterface;
     9| class Remover
    10| {
    11|     public const NAME = 'removed';
    12|     private string $unscheduledMessage;
    13|     public function __construct(
    14|         private LeadRepository $leadRepository,
    15|         private LeadEventLogRepository $leadEventLogRepository,
    16|         TranslatorInterface $translator,
    17|         DateHelper $dateHelper,
    18|     ) {
    19|         $dateRemoved              = $dateHelper->toFull(new \DateTime());
    20|         $this->unscheduledMessage = $translator->trans('mautic.campaign.member.removed', ['%date%' => $dateRemoved]);
    21|     }
    22|     /**
    23|      * @param bool $isExit
    24|      *
    25|      * @throws ContactAlreadyRemovedFromCampaignException
    26|      */
    27|     public function updateExistingMembership(CampaignMember $campaignMember, $isExit): void
    28|     {
    29|         if ($isExit) {
    30|             $campaignMember->setDateLastExited(new \DateTime());
    31|         } else {
    32|             $campaignMember->setDateLastExited(null);
    33|         }
    34|         if ($campaignMember->wasManuallyRemoved()) {
    35|             $this->saveCampaignMember($campaignMember);
    36|             throw new ContactAlreadyRemovedFromCampaignException();
    37|         }
    38|         $this->leadEventLogRepository->unscheduleEvents($campaignMember, $this->unscheduledMessage);
    39|         $campaignMember->setManuallyRemoved(true);
    40|         $campaignMember->setManuallyAdded(false);
    41|         $this->saveCampaignMember($campaignMember);
    42|     }
    43|     private function saveCampaignMember($campaignMember): void
    44|     {
    45|         $this->leadRepository->saveEntity($campaignMember);
    46|         $this->leadRepository->detachEntity($campaignMember);
    47|     }
    48| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Membership/EventDispatcher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Membership;
     3| use Mautic\CampaignBundle\CampaignEvents;
     4| use Mautic\CampaignBundle\Entity\Campaign;
     5| use Mautic\CampaignBundle\Event\CampaignLeadChangeEvent;
     6| use Mautic\LeadBundle\Entity\Lead;
     7| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
     8| class EventDispatcher
     9| {
    10|     public function __construct(
    11|         private EventDispatcherInterface $dispatcher,
    12|     ) {
    13|     }
    14|     /**
    15|      * @param string $action
    16|      */
    17|     public function dispatchMembershipChange(Lead $contact, Campaign $campaign, $action): void
    18|     {
    19|         $this->dispatcher->dispatch(
    20|             new CampaignLeadChangeEvent($campaign, $contact, $action),
    21|             CampaignEvents::CAMPAIGN_ON_LEADCHANGE
    22|         );
    23|     }
    24|     public function dispatchBatchMembershipChange(array $contacts, Campaign $campaign, $action): void
    25|     {
    26|         $this->dispatcher->dispatch(
    27|             new CampaignLeadChangeEvent($campaign, $contacts, $action),
    28|             CampaignEvents::LEAD_CAMPAIGN_BATCH_CHANGE
    29|         );
    30|     }
    31| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Membership/MembershipBuilder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-154 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Membership;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CampaignBundle\Entity\LeadRepository as CampaignLeadRepository;
     5| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
     6| use Mautic\CampaignBundle\Membership\Exception\RunLimitReachedException;
     7| use Mautic\CoreBundle\Helper\ProgressBarHelper;
     8| use Mautic\LeadBundle\Entity\LeadRepository;
     9| use Symfony\Component\Console\Output\OutputInterface;
    10| use Symfony\Contracts\Translation\TranslatorInterface;
    11| class MembershipBuilder
    12| {
    13|     private ?Campaign $campaign = null;
    14|     private ?ContactLimiter $contactLimiter = null;
    15|     private ?int $runLimit = null;
    16|     private ?OutputInterface $output = null;
    17|     private ?\Symfony\Component\Console\Helper\ProgressBar $progressBar = null;
    18|     public function __construct(
    19|         private MembershipManager $manager,
    20|         private CampaignLeadRepository $campaignLeadRepository,
    21|         private LeadRepository $leadRepository,
    22|         private TranslatorInterface $translator,
    23|     ) {
    24|     }
    25|     /**
    26|      * @param int $runLimit
    27|      */
    28|     public function build(Campaign $campaign, ContactLimiter $contactLimiter, $runLimit, OutputInterface $output = null): int
    29|     {
    30|         defined('MAUTIC_REBUILDING_CAMPAIGNS') or define('MAUTIC_REBUILDING_CAMPAIGNS', 1);
    31|         $this->campaign       = $campaign;
    32|         $this->contactLimiter = $contactLimiter;
    33|         $this->runLimit       = (int) $runLimit;
    34|         $this->output         = $output;
    35|         $contactsProcessed = 0;
    36|         try {
    37|             $contactsProcessed += $this->addNewlyQualifiedMembers($contactsProcessed);
    38|         } catch (RunLimitReachedException $exception) {
    39|             return $exception->getContactsProcessed();
    40|         }
    41|         try {
    42|             $contactsProcessed += $this->removeUnqualifiedMembers($contactsProcessed);
    43|         } catch (RunLimitReachedException $exception) {
    44|             return $exception->getContactsProcessed();
    45|         }
    46|         return $contactsProcessed;
    47|     }
    48|     /**
    49|      * Add contacts to a campaign.
    50|      *
    51|      * @throws RunLimitReachedException
    52|      */
    53|     private function addNewlyQualifiedMembers(int $totalContactsProcessed): int
    54|     {
    55|         $contactsProcessed = 0;
    56|         if ($this->output) {
    57|             $countResult = $this->campaignLeadRepository->getCountsForCampaignContactsBySegment(
    58|                 $this->campaign->getId(),
    59|                 $this->contactLimiter,
    60|                 $this->campaign->allowRestart()
    61|             );
    62|             $this->output->writeln(
    63|                 $this->translator->trans(
    64|                     'mautic.campaign.rebuild.to_be_added',
    65|                     ['%leads%' => $countResult->getCount(), '%batch%' => $this->contactLimiter->getBatchLimit()]
    66|                 )
    67|             );
    68|             if (0 === $countResult->getCount()) {
    69|                 return 0;
    70|             }
    71|             $this->startProgressBar($countResult->getCount());
    72|         }
    73|         $contacts = $this->campaignLeadRepository->getCampaignContactsBySegments(
    74|             $this->campaign->getId(),
    75|             $this->contactLimiter,
    76|             $this->campaign->allowRestart()
    77|         );
    78|         while (count($contacts)) {
    79|             $contactCollection = $this->leadRepository->getContactCollection($contacts);
    80|             if ($contactCollection->count() <= 0) {
    81|                 break;
    82|             }
    83|             $contactsProcessed += $contactCollection->count();
    84|             $this->manager->addContacts($contactCollection, $this->campaign, false);
    85|             $this->leadRepository->detachEntities($contactCollection->toArray());
    86|             if ($this->runLimit && $contactsProcessed >= $this->runLimit) {
    87|                 $this->finishProgressBar();
    88|                 throw new RunLimitReachedException($contactsProcessed + $totalContactsProcessed);
    89|             }
    90|             $contacts = $this->campaignLeadRepository->getCampaignContactsBySegments(
    91|                 $this->campaign->getId(),
    92|                 $this->contactLimiter,
    93|                 $this->campaign->allowRestart()
    94|             );
    95|         }
    96|         $this->finishProgressBar();
    97|         return $contactsProcessed;
    98|     }
    99|     /**
   100|      * @throws RunLimitReachedException
   101|      */
   102|     private function removeUnqualifiedMembers(int $totalContactsProcessed): int
   103|     {
   104|         $contactsProcessed = 0;
   105|         if ($this->output) {
   106|             $countResult = $this->campaignLeadRepository->getCountsForOrphanedContactsBySegments($this->campaign->getId(), $this->contactLimiter);
   107|             $this->output->writeln(
   108|                 $this->translator->trans(
   109|                     'mautic.lead.list.rebuild.to_be_removed',
   110|                     ['%leads%' => $countResult->getCount(), '%batch%' => $this->contactLimiter->getBatchLimit()]
   111|                 )
   112|             );
   113|             if (0 === $countResult->getCount()) {
   114|                 return 0;
   115|             }
   116|             $this->startProgressBar($countResult->getCount());
   117|         }
   118|         $contacts = $this->campaignLeadRepository->getOrphanedContacts($this->campaign->getId(), $this->contactLimiter);
   119|         while (count($contacts)) {
   120|             $contactCollection = $this->leadRepository->getContactCollection($contacts);
   121|             if (!$contactCollection->count()) {
   122|                 break;
   123|             }
   124|             $contactsProcessed += $contactCollection->count();
   125|             $this->manager->removeContacts($contactCollection, $this->campaign, true);
   126|             $this->leadRepository->detachEntities($contactCollection->toArray());
   127|             if ($this->runLimit && $contactsProcessed >= $this->runLimit) {
   128|                 $this->finishProgressBar();
   129|                 throw new RunLimitReachedException($contactsProcessed + $totalContactsProcessed);
   130|             }
   131|             $contacts = $this->campaignLeadRepository->getOrphanedContacts($this->campaign->getId(), $this->contactLimiter);
   132|         }
   133|         $this->finishProgressBar();
   134|         return $contactsProcessed;
   135|     }
   136|     private function startProgressBar(int $total): void
   137|     {
   138|         if (!$this->output) {
   139|             $this->progressBar = null;
   140|             $this->manager->setProgressBar($this->progressBar);
   141|             return;
   142|         }
   143|         $this->progressBar = ProgressBarHelper::init($this->output, $total);
   144|         $this->progressBar->start();
   145|         $this->manager->setProgressBar($this->progressBar);
   146|     }
   147|     private function finishProgressBar(): void
   148|     {
   149|         if ($this->progressBar) {
   150|             $this->progressBar->finish();
   151|             $this->output->writeln('');
   152|         }
   153|     }
   154| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Membership/MembershipManager.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-171 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Membership;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Campaign;
     5| use Mautic\CampaignBundle\Entity\Lead as CampaignMember;
     6| use Mautic\CampaignBundle\Entity\LeadRepository;
     7| use Mautic\CampaignBundle\Membership\Action\Adder;
     8| use Mautic\CampaignBundle\Membership\Action\Remover;
     9| use Mautic\CampaignBundle\Membership\Exception\ContactAlreadyRemovedFromCampaignException;
    10| use Mautic\CampaignBundle\Membership\Exception\ContactCannotBeAddedToCampaignException;
    11| use Mautic\LeadBundle\Entity\Lead;
    12| use Psr\Log\LoggerInterface;
    13| use Symfony\Component\Console\Helper\ProgressBar;
    14| class MembershipManager
    15| {
    16|     public const ACTION_ADDED   = 'added';
    17|     public const ACTION_REMOVED = 'removed';
    18|     private ?ProgressBar $progressBar = null;
    19|     public function __construct(
    20|         private Adder $adder,
    21|         private Remover $remover,
    22|         private EventDispatcher $eventDispatcher,
    23|         private LeadRepository $leadRepository,
    24|         private LoggerInterface $logger,
    25|     ) {
    26|     }
    27|     /**
    28|      * @param bool $isManualAction
    29|      */
    30|     public function addContact(Lead $contact, Campaign $campaign, $isManualAction = true): void
    31|     {
    32|         /** @var CampaignMember $campaignMember */
    33|         $campaignMember = $this->leadRepository->findOneBy(
    34|             [
    35|                 'lead'     => $contact,
    36|                 'campaign' => $campaign,
    37|             ]
    38|         );
    39|         if ($campaignMember) {
    40|             try {
    41|                 $this->adder->updateExistingMembership($campaignMember, $isManualAction);
    42|                 $this->logger->debug(
    43|                     "CAMPAIGN: Membership for contact ID {$contact->getId()} in campaign ID {$campaign->getId()} was updated to be included."
    44|                 );
    45|                 $this->eventDispatcher->dispatchMembershipChange($campaignMember->getLead(), $campaignMember->getCampaign(), Adder::NAME);
    46|             } catch (ContactCannotBeAddedToCampaignException $exception) {
    47|                 $this->logger->debug(
    48|                     "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
    49|                     $exception->toArray()
    50|                 );
    51|             }
    52|             return;
    53|         }
    54|         try {
    55|             $this->adder->createNewMembership($contact, $campaign, $isManualAction);
    56|         } catch (ContactCannotBeAddedToCampaignException $exception) {
    57|             $this->logger->debug(
    58|                 "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
    59|                 $exception->toArray()
    60|             );
    61|             return;
    62|         }
    63|         $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was added to campaign ID {$campaign->getId()} as a new member.");
    64|         $this->eventDispatcher->dispatchMembershipChange($contact, $campaign, Adder::NAME);
    65|     }
    66|     /**
    67|      * @param ArrayCollection<int, Lead> $contacts
    68|      * @param bool                       $isManualAction
    69|      */
    70|     public function addContacts(ArrayCollection $contacts, Campaign $campaign, $isManualAction = true): void
    71|     {
    72|         $campaignMembers = $this->leadRepository->getCampaignMembers($contacts->getKeys(), $campaign);
    73|         foreach ($contacts as $contact) {
    74|             $this->advanceProgressBar();
    75|             $this->logger->debug(
    76|                 'CAMPAIGN: Contacts: '.count($contacts),
    77|                 array_map(fn ($item) => $item->getId(), $contacts->toArray())
    78|             );
    79|             if (isset($campaignMembers[$contact->getId()])) {
    80|                 try {
    81|                     $this->adder->updateExistingMembership($campaignMembers[$contact->getId()], $isManualAction);
    82|                     $this->logger->debug(
    83|                         "CAMPAIGN: Membership for contact ID {$contact->getId()} in campaign ID {$campaign->getId()} was updated to be included."
    84|                     );
    85|                 } catch (ContactCannotBeAddedToCampaignException $exception) {
    86|                     $contacts->remove($contact->getId());
    87|                     $this->logger->debug(
    88|                         "CAMPAIGN: Contact ID {$contact->getId()} could not be added to campaign ID {$campaign->getId()}.",
    89|                         $exception->toArray()
    90|                     );
    91|                 }
    92|                 continue;
    93|             }
    94|             $this->adder->createNewMembership($contact, $campaign, $isManualAction);
    95|             $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was added to campaign ID {$campaign->getId()} as a new member.");
    96|         }
    97|         if ($contacts->count()) {
    98|             $this->eventDispatcher->dispatchBatchMembershipChange($contacts->toArray(), $campaign, Adder::NAME);
    99|         }
   100|         $this->leadRepository->detachEntities($campaignMembers);
   101|     }
   102|     /**
   103|      * @param bool $isExit
   104|      */
   105|     public function removeContact(Lead $contact, Campaign $campaign, $isExit = false): void
   106|     {
   107|         /** @var CampaignMember $campaignMember */
   108|         $campaignMember = $this->leadRepository->findOneBy(
   109|             [
   110|                 'lead'     => $contact,
   111|                 'campaign' => $campaign,
   112|             ]
   113|         );
   114|         if (!$campaignMember) {
   115|             $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} is not in campaign ID {$campaign->getId()}.");
   116|             return;
   117|         }
   118|         try {
   119|             $this->remover->updateExistingMembership($campaignMember, $isExit);
   120|             $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was removed from campaign ID {$campaign->getId()}.");
   121|             $this->eventDispatcher->dispatchMembershipChange($contact, $campaign, Remover::NAME);
   122|         } catch (ContactAlreadyRemovedFromCampaignException $exception) {
   123|             $this->logger->debug(
   124|                 "CAMPAIGN: Contact ID {$contact->getId()} was already removed from campaign ID {$campaign->getId()}.",
   125|                 $exception->toArray()
   126|             );
   127|         }
   128|     }
   129|     /**
   130|      * @param ArrayCollection<int, Lead> $contacts
   131|      * @param bool                       $isExit   If true, the contact can be added by a segment/source. If false, the contact can only be added back
   132|      *                                             by a manual process.
   133|      */
   134|     public function removeContacts(ArrayCollection $contacts, Campaign $campaign, $isExit = false): void
   135|     {
   136|         $campaignMembers = $this->leadRepository->getCampaignMembers($contacts->getKeys(), $campaign);
   137|         foreach ($contacts as $contact) {
   138|             $this->advanceProgressBar();
   139|             if (!isset($campaignMembers[$contact->getId()])) {
   140|                 $contacts->remove($contact->getId());
   141|                 continue;
   142|             }
   143|             /** @var CampaignMember $campaignMember */
   144|             $campaignMember = $campaignMembers[$contact->getId()];
   145|             try {
   146|                 $this->remover->updateExistingMembership($campaignMember, $isExit);
   147|                 $this->logger->debug("CAMPAIGN: Contact ID {$contact->getId()} was removed from campaign ID {$campaign->getId()}.");
   148|             } catch (ContactAlreadyRemovedFromCampaignException $exception) {
   149|                 $contacts->remove($contact->getId());
   150|                 $this->logger->debug(
   151|                     "CAMPAIGN: Contact ID {$contact->getId()} was already removed from campaign ID {$campaign->getId()}.",
   152|                     $exception->toArray()
   153|                 );
   154|             }
   155|         }
   156|         if ($contacts->count()) {
   157|             $this->eventDispatcher->dispatchBatchMembershipChange($contacts->toArray(), $campaign, Remover::NAME);
   158|         }
   159|         $this->leadRepository->detachEntities($campaignMembers);
   160|     }
   161|     public function setProgressBar(ProgressBar $progressBar = null): void
   162|     {
   163|         $this->progressBar = $progressBar;
   164|     }
   165|     private function advanceProgressBar(): void
   166|     {
   167|         if ($this->progressBar) {
   168|             $this->progressBar->advance();
   169|         }
   170|     }
   171| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Model/CampaignModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-710 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Model;
     3| use Doctrine\DBAL\Exception;
     4| use Doctrine\ORM\EntityManager;
     5| use Doctrine\ORM\PersistentCollection;
     6| use Mautic\CampaignBundle\CampaignEvents;
     7| use Mautic\CampaignBundle\Entity\Campaign;
     8| use Mautic\CampaignBundle\Entity\Event;
     9| use Mautic\CampaignBundle\Entity\Lead as CampaignLead;
    10| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
    11| use Mautic\CampaignBundle\Event as Events;
    12| use Mautic\CampaignBundle\EventCollector\EventCollector;
    13| use Mautic\CampaignBundle\Executioner\ContactFinder\Limiter\ContactLimiter;
    14| use Mautic\CampaignBundle\Form\Type\CampaignType;
    15| use Mautic\CampaignBundle\Helper\ChannelExtractor;
    16| use Mautic\CampaignBundle\Membership\MembershipBuilder;
    17| use Mautic\CoreBundle\Helper\Chart\ChartQuery;
    18| use Mautic\CoreBundle\Helper\Chart\LineChart;
    19| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    20| use Mautic\CoreBundle\Helper\UserHelper;
    21| use Mautic\CoreBundle\Model\FormModel as CommonFormModel;
    22| use Mautic\CoreBundle\Model\GlobalSearchInterface;
    23| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    24| use Mautic\CoreBundle\Translation\Translator;
    25| use Mautic\EmailBundle\Entity\Stat;
    26| use Mautic\EmailBundle\Entity\StatRepository;
    27| use Mautic\FormBundle\Entity\Form;
    28| use Mautic\FormBundle\Model\FormModel;
    29| use Mautic\LeadBundle\Entity\Lead;
    30| use Mautic\LeadBundle\Model\ListModel;
    31| use Mautic\LeadBundle\Tracker\ContactTracker;
    32| use Psr\Log\LoggerInterface;
    33| use Symfony\Component\Console\Output\OutputInterface;
    34| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    35| use Symfony\Component\Form\FormFactoryInterface;
    36| use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
    37| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    38| /**
    39|  * @extends CommonFormModel<Campaign>
    40|  */
    41| class CampaignModel extends CommonFormModel implements GlobalSearchInterface
    42| {
    43|     public function __construct(
    44|         protected ListModel $leadListModel,
    45|         protected FormModel $formModel,
    46|         private EventCollector $eventCollector,
    47|         private MembershipBuilder $membershipBuilder,
    48|         private ContactTracker $contactTracker,
    49|         EntityManager $em,
    50|         CorePermissions $security,
    51|         EventDispatcherInterface $dispatcher,
    52|         UrlGeneratorInterface $router,
    53|         Translator $translator,
    54|         UserHelper $userHelper,
    55|         LoggerInterface $mauticLogger,
    56|         CoreParametersHelper $coreParametersHelper,
    57|     ) {
    58|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    59|     }
    60|     /**
    61|      * @return \Mautic\CampaignBundle\Entity\CampaignRepository
    62|      */
    63|     public function getRepository()
    64|     {
    65|         $repo = $this->em->getRepository(Campaign::class);
    66|         $repo->setCurrentUser($this->userHelper->getUser());
    67|         return $repo;
    68|     }
    69|     /**
    70|      * @return \Mautic\CampaignBundle\Entity\EventRepository
    71|      */
    72|     public function getEventRepository()
    73|     {
    74|         return $this->em->getRepository(Event::class);
    75|     }
    76|     /**
    77|      * @return \Mautic\CampaignBundle\Entity\LeadRepository
    78|      */
    79|     public function getCampaignLeadRepository()
    80|     {
    81|         return $this->em->getRepository(CampaignLead::class);
    82|     }
    83|     /**
    84|      * @return LeadEventLogRepository
    85|      */
    86|     public function getCampaignLeadEventLogRepository()
    87|     {
    88|         return $this->em->getRepository(\Mautic\CampaignBundle\Entity\LeadEventLog::class);
    89|     }
    90|     public function getPermissionBase(): string
    91|     {
    92|         return 'campaign:campaigns';
    93|     }
    94|     /**
    95|      * @param object      $entity
    96|      * @param string|null $action
    97|      * @param array       $options
    98|      */
    99|     public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
   100|     {
   101|         if (!$entity instanceof Campaign) {
   102|             throw new MethodNotAllowedHttpException(['Campaign']);
   103|         }
   104|         if (!empty($action)) {
   105|             $options['action'] = $action;
   106|         }
   107|         return $formFactory->create(CampaignType::class, $entity, $options);
   108|     }
   109|     /**
   110|      * Get a specific entity or generate a new one if id is empty.
   111|      */
   112|     public function getEntity($id = null): ?Campaign
   113|     {
   114|         if (null === $id) {
   115|             return new Campaign();
   116|         }
   117|         return parent::getEntity($id);
   118|     }
   119|     /**
   120|      * Delete an array of campaigns.
   121|      *
   122|      * @param int[] $campaignIds
   123|      *
   124|      * @return array<int,Campaign>
   125|      */
   126|     public function deleteEntities($campaignIds): array
   127|     {
   128|         $entities = [];
   129|         foreach ($campaignIds as $campaignId) {
   130|             $campaign = $this->getEntity($campaignId);
   131|             if ($campaign) {
   132|                 $entities[$campaignId] = $campaign;
   133|                 $this->deleteEntity($campaign);
   134|             }
   135|         }
   136|         return $entities;
   137|     }
   138|     public function deleteEntity($entity): void
   139|     {
   140|         $this->getEventRepository()->nullEventParents($entity->getId());
   141|         $this->dispatchEvent('pre_delete', $entity);
   142|         $this->getRepository()->setCampaignAsDeleted($entity->getId());
   143|         $this->dispatcher->dispatch(new Events\DeleteCampaign($entity), CampaignEvents::ON_CAMPAIGN_DELETE);
   144|     }
   145|     public function deleteCampaign(Campaign $campaign): void
   146|     {
   147|         $campaign->deletedId = $campaign->getId();
   148|         $this->getRepository()->deleteEntity($campaign);
   149|         $this->dispatchEvent('post_delete', $campaign);
   150|     }
   151|     /**
   152|      * @throws MethodNotAllowedHttpException
   153|      */
   154|     protected function dispatchEvent($action, &$entity, $isNew = false, \Symfony\Contracts\EventDispatcher\Event $event = null): ?\Symfony\Contracts\EventDispatcher\Event
   155|     {
   156|         if ($entity instanceof CampaignLead) {
   157|             return null;
   158|         }
   159|         if (!$entity instanceof Campaign) {
   160|             throw new MethodNotAllowedHttpException(['Campaign']);
   161|         }
   162|         switch ($action) {
   163|             case 'pre_save':
   164|                 $name = CampaignEvents::CAMPAIGN_PRE_SAVE;
   165|                 break;
   166|             case 'post_save':
   167|                 $name = CampaignEvents::CAMPAIGN_POST_SAVE;
   168|                 break;
   169|             case 'pre_delete':
   170|                 $name = CampaignEvents::CAMPAIGN_PRE_DELETE;
   171|                 break;
   172|             case 'post_delete':
   173|                 $name = CampaignEvents::CAMPAIGN_POST_DELETE;
   174|                 break;
   175|             default:
   176|                 return null;
   177|         }
   178|         if ($this->dispatcher->hasListeners($name)) {
   179|             if (empty($event)) {
   180|                 $event = new Events\CampaignEvent($entity, $isNew);
   181|             }
   182|             $this->dispatcher->dispatch($event, $name);
   183|             return $event;
   184|         } else {
   185|             return null;
   186|         }
   187|     }
   188|     public function setEvents(Campaign $entity, $sessionEvents, $sessionConnections, $deletedEvents): array
   189|     {
   190|         $existingEvents = $entity->getEvents()->toArray();
   191|         $events         = [];
   192|         $hierarchy      = [];
   193|         foreach ($sessionEvents as $properties) {
   194|             $isNew = (!empty($properties['id']) && isset($existingEvents[$properties['id']])) ? false : true;
   195|             $event = !$isNew ? $existingEvents[$properties['id']] : new Event();
   196|             foreach ($properties as $f => $v) {
   197|                 if ('id' == $f && str_starts_with($v, 'new')) {
   198|                     $event->setTempId($v);
   199|                 }
   200|                 if (in_array($f, ['id', 'parent'])) {
   201|                     continue;
   202|                 }
   203|                 $func = 'set'.ucfirst($f);
   204|                 if (method_exists($event, $func)) {
   205|                     $event->$func($v);
   206|                 }
   207|             }
   208|             ChannelExtractor::setChannel($event, $event, $this->eventCollector->getEventConfig($event));
   209|             $event->setCampaign($entity);
   210|             $events[$properties['id']] = $event;
   211|         }
   212|         foreach ($deletedEvents as $deleteMe) {
   213|             if (isset($existingEvents[$deleteMe])) {
   214|                 $parent = $existingEvents[$deleteMe]->getParent();
   215|                 if ($parent) {
   216|                     $parent->removeChild($existingEvents[$deleteMe]);
   217|                     $existingEvents[$deleteMe]->removeParent();
   218|                 }
   219|                 $entity->removeEvent($existingEvents[$deleteMe]);
   220|                 unset($events[$deleteMe]);
   221|             }
   222|         }
   223|         $relationships = [];
   224|         if (isset($sessionConnections['connections'])) {
   225|             foreach ($sessionConnections['connections'] as $connection) {
   226|                 $source = $connection['sourceId'];
   227|                 $target = $connection['targetId'];
   228|                 if (in_array($source, ['lists', 'forms'])) {
   229|                     continue;
   230|                 }
   231|                 if (isset($connection['anchors']['source'])) {
   232|                     $sourceDecision = $connection['anchors']['source'];
   233|                 } else {
   234|                     $sourceDecision = (!empty($connection['anchors'][0])) ? $connection['anchors'][0]['endpoint'] : null;
   235|                 }
   236|                 if ('leadsource' == $sourceDecision) {
   237|                     continue;
   238|                 }
   239|                 $relationships[$target] = [
   240|                     'parent'   => $source,
   241|                     'decision' => $sourceDecision,
   242|                 ];
   243|             }
   244|         }
   245|         foreach ($events as $id => $e) {
   246|             if (isset($relationships[$id])) {
   247|                 $anchor = in_array($relationships[$id]['decision'], ['yes', 'no']) ? $relationships[$id]['decision'] : null;
   248|                 $events[$id]->setDecisionPath($anchor);
   249|                 $parentId = $relationships[$id]['parent'];
   250|                 $events[$id]->setParent($events[$parentId]);
   251|                 $hierarchy[$id] = $parentId;
   252|             } elseif ($events[$id]->getParent()) {
   253|                 $events[$id]->setDecisionPath(null);
   254|                 $parent = $events[$id]->getParent();
   255|                 $parent->removeChild($events[$id]);
   256|                 $events[$id]->removeParent();
   257|                 $hierarchy[$id] = 'null';
   258|             } else {
   259|                 $hierarchy[$id] = 'null';
   260|                 $events[$id]->setDecisionPath(null);
   261|             }
   262|         }
   263|         $entity->addEvents($events);
   264|         $this->buildOrder($hierarchy, $events, $entity);
   265|         uasort(
   266|             $events,
   267|             function ($a, $b): int {
   268|                 $aOrder = $a->getOrder();
   269|                 $bOrder = $b->getOrder();
   270|                 return $aOrder <=> $bOrder;
   271|             }
   272|         );
   273|         if ($entity->getId()) {
   274|             $this->getEventRepository()->saveEntities($events);
   275|         }
   276|         return $events;
   277|     }
   278|     /**
   279|      * @param bool $persist
   280|      *
   281|      * @return array
   282|      */
   283|     public function setCanvasSettings($entity, $settings, $persist = true, $events = null)
   284|     {
   285|         if (null === $events) {
   286|             $events = $entity->getEvents();
   287|         }
   288|         $tempIds = [];
   289|         foreach ($events as $e) {
   290|             if ($e instanceof Event) {
   291|                 $tempIds[$e->getTempId()] = $e->getId();
   292|             } else {
   293|                 $tempIds[$e['tempId']] = $e['id'];
   294|             }
   295|         }
   296|         if (!isset($settings['nodes'])) {
   297|             $settings['nodes'] = [];
   298|         }
   299|         foreach ($settings['nodes'] as &$node) {
   300|             if (str_contains($node['id'], 'new')) {
   301|                 $node['id'] = str_replace($node['id'], $tempIds[$node['id']], $node['id']);
   302|             }
   303|         }
   304|         if (!isset($settings['connections'])) {
   305|             $settings['connections'] = [];
   306|         }
   307|         foreach ($settings['connections'] as &$connection) {
   308|             if (str_contains($connection['sourceId'], 'new')) {
   309|                 $connection['sourceId'] = str_replace($connection['sourceId'], $tempIds[$connection['sourceId']], $connection['sourceId']);
   310|             }
   311|             if (str_contains($connection['targetId'], 'new')) {
   312|                 $connection['targetId'] = str_replace($connection['targetId'], $tempIds[$connection['targetId']], $connection['targetId']);
   313|             }
   314|             if (!isset($connection['anchors']['source'])) {
   315|                 $anchors = [];
   316|                 foreach ($connection['anchors'] as $k => $anchor) {
   317|                     $type           = (0 === $k) ? 'source' : 'target';
   318|                     $anchors[$type] = $anchor['endpoint'];
   319|                 }
   320|                 $connection['anchors'] = $anchors;
   321|             }
   322|         }
   323|         $entity->setCanvasSettings($settings);
   324|         if ($persist) {
   325|             $this->getRepository()->saveEntity($entity);
   326|         }
   327|         return $settings;
   328|     }
   329|     /**
   330|      * Get list of sources for a campaign.
   331|      */
   332|     public function getLeadSources($campaign): array
   333|     {
   334|         $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
   335|         $sources = [];
   336|         $sources['lists'] = $this->getRepository()->getCampaignListSources($campaignId);
   337|         $sources['forms'] = $this->getRepository()->getCampaignFormSources($campaignId);
   338|         return $sources;
   339|     }
   340|     /**
   341|      * Add and/or delete lead sources from a campaign.
   342|      */
   343|     public function setLeadSources(Campaign $entity, $addedSources, $deletedSources): void
   344|     {
   345|         foreach ($addedSources as $type => $sources) {
   346|             foreach ($sources as $id => $label) {
   347|                 switch ($type) {
   348|                     case 'lists':
   349|                         $entity->addList($this->em->getReference(\Mautic\LeadBundle\Entity\LeadList::class, $id));
   350|                         break;
   351|                     case 'forms':
   352|                         $entity->addForm($this->em->getReference(Form::class, $id));
   353|                         break;
   354|                     default:
   355|                         break;
   356|                 }
   357|             }
   358|         }
   359|         foreach ($deletedSources as $type => $sources) {
   360|             foreach ($sources as $id => $label) {
   361|                 switch ($type) {
   362|                     case 'lists':
   363|                         $entity->removeList($this->em->getReference(\Mautic\LeadBundle\Entity\LeadList::class, $id));
   364|                         break;
   365|                     case 'forms':
   366|                         $entity->removeForm($this->em->getReference(Form::class, $id));
   367|                         break;
   368|                     default:
   369|                         break;
   370|                 }
   371|             }
   372|         }
   373|     }
   374|     /**
   375|      * Get a list of source choices.
   376|      *
   377|      * @param string $sourceType
   378|      * @param bool   $globalOnly
   379|      */
   380|     public function getSourceLists($sourceType = null, $globalOnly = false): array
   381|     {
   382|         $choices = [];
   383|         switch ($sourceType) {
   384|             case 'lists':
   385|             case null:
   386|                 $choices['lists'] = [];
   387|                 $lists            = $globalOnly ? $this->leadListModel->getGlobalLists() : $this->leadListModel->getUserLists();
   388|                 if ($lists) {
   389|                     foreach ($lists as $list) {
   390|                         $choices['lists'][$list['id']] = $list['name'];
   391|                     }
   392|                 }
   393|             case 'forms':
   394|             case null:
   395|                 $choices['forms'] = [];
   396|                 $viewOther        = $this->security->isGranted('form:forms:viewother');
   397|                 $repo             = $this->formModel->getRepository();
   398|                 $repo->setCurrentUser($this->userHelper->getUser());
   399|                 $forms = $repo->getFormList('', 0, 0, $viewOther, 'campaign');
   400|                 foreach ($forms as $form) {
   401|                     $choices['forms'][$form['id']] = $form['name'];
   402|                 }
   403|         }
   404|         foreach ($choices as &$typeChoices) {
   405|             asort($typeChoices);
   406|         }
   407|         return (null == $sourceType) ? $choices : $choices[$sourceType];
   408|     }
   409|     /**
   410|      * @param mixed $form
   411|      *
   412|      * @return array
   413|      */
   414|     public function getCampaignsByForm($form)
   415|     {
   416|         $formId = ($form instanceof Form) ? $form->getId() : $form;
   417|         return $this->getRepository()->findByFormId($formId);
   418|     }
   419|     /**
   420|      * Gets the campaigns a specific lead is part of.
   421|      *
   422|      * @param bool $forList
   423|      *
   424|      * @return mixed
   425|      */
   426|     public function getLeadCampaigns(Lead $lead = null, $forList = false)
   427|     {
   428|         static $campaigns = [];
   429|         if (null === $lead) {
   430|             $lead = $this->contactTracker->getContact();
   431|         }
   432|         if (!isset($campaigns[$lead->getId()])) {
   433|             $repo   = $this->getRepository();
   434|             $leadId = $lead->getId();
   435|             $campaigns[$leadId] = $repo->getPublishedCampaigns(
   436|                 null,
   437|                 $lead->getId(),
   438|                 $forList,
   439|                 $this->security->isGranted($this->getPermissionBase().':viewother')
   440|             );
   441|         }
   442|         return $campaigns[$lead->getId()];
   443|     }
   444|     /**
   445|      * Gets a list of published campaigns.
   446|      *
   447|      * @return array
   448|      */
   449|     public function getPublishedCampaigns(bool $forList = false)
   450|     {
   451|         static $campaigns = [];
   452|         if (empty($campaigns)) {
   453|             $campaigns = $this->getRepository()->getPublishedCampaigns(
   454|                 null,
   455|                 null,
   456|                 $forList,
   457|                 $this->security->isGranted($this->getPermissionBase().':viewother')
   458|             );
   459|         }
   460|         return $campaigns;
   461|     }
   462|     /**
   463|      * Saves a campaign lead, logs the error if saving fails.
   464|      */
   465|     public function saveCampaignLead(CampaignLead $campaignLead): bool
   466|     {
   467|         try {
   468|             $this->getCampaignLeadRepository()->saveEntity($campaignLead);
   469|             return true;
   470|         } catch (\Exception $exception) {
   471|             $this->logger->log('error', $exception->getMessage(), ['exception' => $exception]);
   472|             return false;
   473|         }
   474|     }
   475|     /**
   476|      * Get details of leads in a campaign.
   477|      *
   478|      * @return mixed
   479|      */
   480|     public function getLeadDetails($campaign, $leads = null)
   481|     {
   482|         $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
   483|         if ($leads instanceof PersistentCollection) {
   484|             $leads = array_keys($leads->toArray());
   485|         }
   486|         return $this->em->getRepository(CampaignLead::class)->getLeadDetails($campaignId, $leads);
   487|     }
   488|     /**
   489|      * Get leads for a campaign.  If $event is passed in, only leads who have not triggered the event are returned.
   490|      *
   491|      * @param Campaign $campaign
   492|      * @param array    $event
   493|      *
   494|      * @return mixed
   495|      */
   496|     public function getCampaignLeads($campaign, $event = null)
   497|     {
   498|         $campaignId = ($campaign instanceof Campaign) ? $campaign->getId() : $campaign;
   499|         $eventId    = (is_array($event) && isset($event['id'])) ? $event['id'] : $event;
   500|         return $this->em->getRepository(CampaignLead::class)->getLeads($campaignId, $eventId);
   501|     }
   502|     public function getCampaignListIds($id): array
   503|     {
   504|         return $this->getRepository()->getCampaignListIds((int) $id);
   505|     }
   506|     /**
   507|      * Get line chart data of leads added to campaigns.
   508|      *
   509|      * @param string $unit          {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
   510|      * @param string $dateFormat
   511|      * @param array  $filter
   512|      * @param bool   $canViewOthers
   513|      */
   514|     public function getLeadsAddedLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = [], $canViewOthers = true): array
   515|     {
   516|         $chart = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
   517|         $query = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   518|         $q     = $query->prepareTimeDataQuery('campaign_leads', 'date_added', $filter);
   519|         if (!$canViewOthers) {
   520|             $q->join('t', MAUTIC_TABLE_PREFIX.'campaigns', 'c', 'c.id = c.campaign_id')
   521|                 ->andWhere('c.created_by = :userId')
   522|                 ->setParameter('userId', $this->userHelper->getUser()->getId());
   523|         }
   524|         $data = $query->loadAndBuildTimeData($q);
   525|         $chart->setDataset($this->translator->trans('mautic.campaign.campaign.leads'), $data);
   526|         return $chart->render();
   527|     }
   528|     /**
   529|      * Get line chart data of hits.
   530|      *
   531|      * @param string|null $unit       {@link php.net/manual/en/function.date.php#refsect1-function.date-parameters}
   532|      * @param string      $dateFormat
   533|      * @param array       $filter
   534|      */
   535|     public function getCampaignMetricsLineChartData($unit, \DateTime $dateFrom, \DateTime $dateTo, $dateFormat = null, $filter = []): array
   536|     {
   537|         $events = [];
   538|         $chart  = new LineChart($unit, $dateFrom, $dateTo, $dateFormat);
   539|         $query  = new ChartQuery($this->em->getConnection(), $dateFrom, $dateTo);
   540|         $contacts = $query->fetchTimeData('campaign_leads', 'date_added', $filter);
   541|         $chart->setDataset($this->translator->trans('mautic.campaign.campaign.leads'), $contacts);
   542|         if (isset($filter['campaign_id'])) {
   543|             $rawEvents = $this->getEventRepository()->getCampaignEvents($filter['campaign_id']);
   544|             foreach ($rawEvents as $event) {
   545|                 if (isset($events[$event['type']])) {
   546|                     $events[$event['type']][] = $event['id'];
   547|                 } else {
   548|                     $events[$event['type']] = [$event['id']];
   549|                 }
   550|             }
   551|             if ($events) {
   552|                 foreach ($events as $type => $eventIds) {
   553|                     $filter['event_id'] = $eventIds;
   554|                     if ($this->coreParametersHelper->get('campaign_use_summary')) {
   555|                         $q       = $query->prepareTimeDataQuery('campaign_summary', 'date_triggered', $filter, 'triggered_count + non_action_path_taken_count', 'sum');
   556|                         $rawData = $q->executeQuery()->fetchAllAssociative();
   557|                     } else {
   558|                         $failedSq = $this->em->getConnection()->createQueryBuilder();
   559|                         $failedSq->select('null')
   560|                             ->from(MAUTIC_TABLE_PREFIX.'campaign_lead_event_failed_log', 'fe')
   561|                             ->where(
   562|                                 $failedSq->expr()->eq('fe.log_id', 't.id')
   563|                             );
   564|                         $filter['failed_events'] = [
   565|                             'subquery' => sprintf('NOT EXISTS (%s)', $failedSq->getSQL()),
   566|                         ];
   567|                         $q       = $query->prepareTimeDataQuery('campaign_lead_event_log', 'date_triggered', $filter);
   568|                         $rawData = $q->executeQuery()->fetchAllAssociative();
   569|                     }
   570|                     if (!empty($rawData)) {
   571|                         $triggers = $query->completeTimeData($rawData);
   572|                         $chart->setDataset($this->translator->trans('mautic.campaign.'.$type), $triggers);
   573|                     }
   574|                 }
   575|                 unset($filter['event_id']);
   576|             }
   577|         }
   578|         return $chart->render();
   579|     }
   580|     /**
   581|      * @param Campaign $entity
   582|      * @param string   $root
   583|      * @param int      $order
   584|      */
   585|     protected function buildOrder($hierarchy, &$events, $entity, $root = 'null', $order = 1)
   586|     {
   587|         $count = count($hierarchy);
   588|         if (1 === $count && 'null' === array_unique(array_values($hierarchy))[0]) {
   589|             return;
   590|         } else {
   591|             foreach ($hierarchy as $eventId => $parent) {
   592|                 if ($parent == $root || 1 === $count) {
   593|                     $events[$eventId]->setOrder($order);
   594|                     unset($hierarchy[$eventId]);
   595|                     if (count($hierarchy)) {
   596|                         $this->buildOrder($hierarchy, $events, $entity, $eventId, $order + 1);
   597|                     }
   598|                 }
   599|             }
   600|         }
   601|     }
   602|     /**
   603|      * @param int  $limit
   604|      * @param bool $maxLeads
   605|      */
   606|     public function rebuildCampaignLeads(Campaign $campaign, $limit = 1000, $maxLeads = false, OutputInterface $output = null): int
   607|     {
   608|         $contactLimiter = new ContactLimiter($limit);
   609|         return $this->membershipBuilder->build($campaign, $contactLimiter, $maxLeads, $output);
   610|     }
   611|     public function getCampaignIdsWithDependenciesOnSegment($segmentId): array
   612|     {
   613|         $entities = $this->getRepository()->getEntities(
   614|             [
   615|                 'filter'    => [
   616|                     'force' => [
   617|                         [
   618|                             'column' => 'l.id',
   619|                             'expr'   => 'eq',
   620|                             'value'  => $segmentId,
   621|                         ],
   622|                     ],
   623|                 ],
   624|                 'joinLists' => true,
   625|             ]
   626|         );
   627|         $ids = [];
   628|         foreach ($entities as $entity) {
   629|             $ids[] = $entity->getId();
   630|         }
   631|         return $ids;
   632|     }
   633|     /**
   634|      * @return array<int, int>
   635|      */
   636|     public function getCampaignIdsWithDependenciesOnEmail(int $emailId): array
   637|     {
   638|         return $this->getRepository()->getCampaignIdsWithDependenciesOnEmail($emailId);
   639|     }
   640|     /**
   641|      * @return array<int, int>
   642|      */
   643|     public function getCampaignIdsWithDependenciesOnTagName(string $tagName): array
   644|     {
   645|         $entities = $this->getEventRepository()->getEntities(
   646|             [
   647|                 'filter' => [
   648|                     'force'  => [
   649|                         [
   650|                             'column' => 'e.type',
   651|                             'expr'   => 'IN',
   652|                             'value'  => ['lead.changetags', 'lead.tags'],
   653|                         ],
   654|                     ],
   655|                 ],
   656|             ]
   657|         );
   658|         $dependents = [];
   659|         /** @var Event $entity */
   660|         foreach ($entities as $entity) {
   661|             $type       = $entity->getType();
   662|             $properties = $entity->getProperties();
   663|             if ('lead.changetags' === $type) {
   664|                 $eventTags = array_merge([], $properties['add_tags'], $properties['remove_tags']);
   665|             }
   666|             if ('lead.tags' === $type) {
   667|                 $eventTags = $properties['tags'];
   668|             }
   669|             if (in_array($tagName, $eventTags)) {
   670|                 $dependents[] = $entity->getCampaign()->getId();
   671|             }
   672|         }
   673|         return array_unique($dependents);
   674|     }
   675|     /**
   676|      * @return array<string, array<int, array<string, int|string>>>
   677|      *
   678|      * @throws Exception
   679|      */
   680|     public function getCountryStats(Campaign $entity, \DateTimeImmutable $dateFrom, \DateTimeImmutable $dateTo): array
   681|     {
   682|         /** @var StatRepository $statRepo */
   683|         $statRepo            = $this->em->getRepository(Stat::class);
   684|         $results['contacts'] =  $this->getCampaignMembersGroupByCountry($entity, $dateFrom, $dateTo);
   685|         if ($entity->isEmailCampaign()) {
   686|             $eventsEmailsSend     = $entity->getEmailSendEvents();
   687|             $eventsIds            = $eventsEmailsSend->getKeys();
   688|             $emailIds             = [];
   689|             foreach ($eventsEmailsSend as $event) {
   690|                 $emailIds[] = $event->getChannelId();
   691|             }
   692|             $emailStats            = $statRepo->getStatsSummaryByCountry($dateFrom, $dateTo, $emailIds, 'campaign', $eventsIds);
   693|             $results['read_count'] = $results['clicked_through_count'] = [];
   694|             foreach ($emailStats as $e) {
   695|                 $results['read_count'][]            = array_intersect_key($e, array_flip(['country', 'read_count']));
   696|                 $results['clicked_through_count'][] = array_intersect_key($e, array_flip(['country', 'clicked_through_count']));
   697|             }
   698|         }
   699|         return $results;
   700|     }
   701|     /**
   702|      * Get leads in a campaign grouped by country.
   703|      *
   704|      * @return array{}|array<int, array<string, string|null>>
   705|      */
   706|     public function getCampaignMembersGroupByCountry(Campaign $campaign, \DateTimeImmutable $dateFromObject, \DateTimeImmutable $dateToObject): array
   707|     {
   708|         return $this->em->getRepository(CampaignLead::class)->getCampaignMembersGroupByCountry($campaign, $dateFromObject, $dateToObject);
   709|     }
   710| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Model/EventLogModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-191 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Model;
     3| use Doctrine\ORM\EntityManager;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\CampaignBundle\Entity\LeadEventLogRepository;
     7| use Mautic\CampaignBundle\Executioner\Scheduler\EventScheduler;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\InputHelper;
    10| use Mautic\CoreBundle\Helper\IpLookupHelper;
    11| use Mautic\CoreBundle\Helper\UserHelper;
    12| use Mautic\CoreBundle\Model\AbstractCommonModel;
    13| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    14| use Mautic\CoreBundle\Translation\Translator;
    15| use Mautic\LeadBundle\Entity\Lead;
    16| use Psr\Log\LoggerInterface;
    17| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    18| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    19| /**
    20|  * @extends AbstractCommonModel<LeadEventLog>
    21|  */
    22| class EventLogModel extends AbstractCommonModel
    23| {
    24|     public function __construct(
    25|         protected EventModel $eventModel,
    26|         protected CampaignModel $campaignModel,
    27|         protected IpLookupHelper $ipLookupHelper,
    28|         protected EventScheduler $eventScheduler,
    29|         EntityManager $em,
    30|         CorePermissions $security,
    31|         EventDispatcherInterface $dispatcher,
    32|         UrlGeneratorInterface $router,
    33|         Translator $translator,
    34|         UserHelper $userHelper,
    35|         LoggerInterface $mauticLogger,
    36|         CoreParametersHelper $coreParametersHelper,
    37|     ) {
    38|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    39|     }
    40|     public function getRepository(): LeadEventLogRepository
    41|     {
    42|         return $this->em->getRepository(LeadEventLog::class);
    43|     }
    44|     public function getPermissionBase(): string
    45|     {
    46|         return 'campaign:campaigns';
    47|     }
    48|     public function getEntities(array $args = [])
    49|     {
    50|         /** @var LeadEventLog[] $logs */
    51|         $logs = parent::getEntities($args);
    52|         if (!empty($args['campaign_id']) && !empty($args['contact_id'])) {
    53|             /** @var Event[] $events */
    54|             $events = $this->eventModel->getEntities(
    55|                 [
    56|                     'campaign_id'      => $args['campaign_id'],
    57|                     'ignore_children'  => true,
    58|                     'index_by'         => 'id',
    59|                     'ignore_paginator' => true,
    60|                 ]
    61|             );
    62|             foreach ($logs as $log) {
    63|                 $event = $log->getEvent()->getId();
    64|                 $events[$event]->addContactLog($log);
    65|             }
    66|             return array_values($events);
    67|         }
    68|         return $logs;
    69|     }
    70|     /**
    71|      * @return string|mixed[]
    72|      */
    73|     public function updateContactEvent(Event $event, Lead $contact, array $parameters): string|array
    74|     {
    75|         $campaign = $event->getCampaign();
    76|         $membership = $campaign->getContactMembership($contact);
    77|         if (0 === count($membership)) {
    78|             return $this->translator->trans(
    79|                 'mautic.campaign.error.contact_not_in_campaign',
    80|                 ['%campaign%' => $campaign->getId(), '%contact%' => $contact->getId()],
    81|                 'flashes'
    82|             );
    83|         }
    84|         /** @var \Mautic\CampaignBundle\Entity\Lead $m */
    85|         foreach ($membership as $m) {
    86|             if ($m->getManuallyRemoved()) {
    87|                 return $this->translator->trans(
    88|                     'mautic.campaign.error.contact_not_in_campaign',
    89|                     ['%campaign%' => $campaign->getId(), '%contact%' => $contact->getId()],
    90|                     'flashes'
    91|                 );
    92|             }
    93|         }
    94|         $logs    = $event->getContactLog($contact);
    95|         $created = false;
    96|         if (count($logs)) {
    97|             $log = $logs[0];
    98|             if ($log->getDateTriggered()) {
    99|                 return $this->translator->trans(
   100|                     'mautic.campaign.error.event_already_executed',
   101|                     [
   102|                         '%campaign%'      => $campaign->getId(),
   103|                         '%event%'         => $event->getId(),
   104|                         '%contact%'       => $contact->getId(),
   105|                         '%dateTriggered%' => $log->getDateTriggered()->format(\DateTimeInterface::ATOM),
   106|                     ],
   107|                     'flashes'
   108|                 );
   109|             }
   110|         } else {
   111|             if (!isset($parameters['triggerDate']) && !isset($parameters['dateTriggered'])) {
   112|                 return $this->translator->trans(
   113|                     'mautic.campaign.error.event_must_be_scheduled',
   114|                     [
   115|                         '%campaign%' => $campaign->getId(),
   116|                         '%event%'    => $event->getId(),
   117|                         '%contact%'  => $contact->getId(),
   118|                     ],
   119|                     'flashes'
   120|                 );
   121|             }
   122|             $log = (new LeadEventLog())
   123|                 ->setLead($contact)
   124|                 ->setEvent($event);
   125|             $created = true;
   126|         }
   127|         foreach ($parameters as $property => $value) {
   128|             switch ($property) {
   129|                 case 'dateTriggered':
   130|                     $log->setDateTriggered(
   131|                         new \DateTime($value)
   132|                     );
   133|                     break;
   134|                 case 'triggerDate':
   135|                     if (Event::TYPE_DECISION === $event->getEventType()) {
   136|                         return $this->translator->trans(
   137|                             'mautic.campaign.error.decision_cannot_be_scheduled',
   138|                             [
   139|                                 '%campaign%' => $campaign->getId(),
   140|                                 '%event%'    => $event->getId(),
   141|                                 '%contact%'  => $contact->getId(),
   142|                             ],
   143|                             'flashes'
   144|                         );
   145|                     }
   146|                     $log->setTriggerDate(
   147|                         new \DateTime($value)
   148|                     );
   149|                     break;
   150|                 case 'ipAddress':
   151|                     if (!defined('MAUTIC_CAMPAIGN_SYSTEM_TRIGGERED')) {
   152|                         $log->setIpAddress(
   153|                             $this->ipLookupHelper->getIpAddress($value)
   154|                         );
   155|                     }
   156|                     break;
   157|                 case 'metadata':
   158|                     $metadata = $log->getMetadata();
   159|                     if (is_array($value)) {
   160|                         $newMetadata = $value;
   161|                     } elseif ($jsonDecoded = json_decode($value, true)) {
   162|                         $newMetadata = $jsonDecoded;
   163|                     } else {
   164|                         $newMetadata = (array) $value;
   165|                     }
   166|                     $newMetadata = InputHelper::cleanArray($newMetadata);
   167|                     $log->setMetadata(array_merge($metadata, $newMetadata));
   168|                     break;
   169|                 case 'nonActionPathTaken':
   170|                     $log->setNonActionPathTaken((bool) $value);
   171|                     break;
   172|                 case 'channel':
   173|                     $log->setChannel(InputHelper::clean($value));
   174|                     break;
   175|                 case 'channelId':
   176|                     $log->setChannel(intval($value));
   177|                     break;
   178|             }
   179|         }
   180|         $this->saveEntity($log);
   181|         return [$log, $created];
   182|     }
   183|     public function saveEntity(LeadEventLog $entity): void
   184|     {
   185|         $triggerDate = $entity->getTriggerDate();
   186|         if (null === $triggerDate) {
   187|             $triggerDate = new \DateTime();
   188|         }
   189|         $this->eventScheduler->reschedule($entity, $triggerDate);
   190|     }
   191| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Service/Campaign.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Service;
     3| use Mautic\CampaignBundle\Entity\CampaignRepository;
     4| use Mautic\EmailBundle\Entity\EmailRepository;
     5| /**
     6|  * @deprecated to be removed in 6.0; use CampaignAuditService instead
     7|  */
     8| class Campaign
     9| {
    10|     public function __construct(
    11|         private CampaignRepository $campaignRepository,
    12|         private EmailRepository $emailRepository,
    13|     ) {
    14|     }
    15|     /**
    16|      * Has campaign at least one unpublished e-mail?
    17|      *
    18|      * @param int $id
    19|      */
    20|     public function hasUnpublishedEmail($id): bool
    21|     {
    22|         $emailIds = $this->campaignRepository->fetchEmailIdsById($id);
    23|         if (!$emailIds) {
    24|             return false;
    25|         }
    26|         return $this->emailRepository->isOneUnpublished($emailIds);
    27|     }
    28| }


# ====================================================================
# FILE: app/bundles/CampaignBundle/Service/CampaignAuditService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| <?php
     2| namespace Mautic\CampaignBundle\Service;
     3| use Mautic\CampaignBundle\Entity\Campaign;
     4| use Mautic\CampaignBundle\Entity\CampaignRepository;
     5| use Mautic\CoreBundle\Service\FlashBag;
     6| use Mautic\EmailBundle\Entity\Email;
     7| use Mautic\EmailBundle\Entity\EmailRepository;
     8| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
     9| class CampaignAuditService
    10| {
    11|     public function __construct(
    12|         private FlashBag $flashBag,
    13|         private UrlGeneratorInterface $urlGenerator,
    14|         private CampaignRepository $campaignRepository,
    15|         private EmailRepository $emailRepository,
    16|     ) {
    17|     }
    18|     public function addWarningForUnpublishedEmails(Campaign $campaign): void
    19|     {
    20|         $emailIds = $this->campaignRepository->fetchEmailIdsById($campaign->getId());
    21|         $emails   = $this->emailRepository->findBy(['id' => $emailIds]);
    22|         foreach ($emails as $email) {
    23|             if (!$email->isPublished()) {
    24|                 $this->setEmailWarningFlashMessage($email);
    25|             }
    26|         }
    27|     }
    28|     private function setEmailWarningFlashMessage(Email $email): void
    29|     {
    30|         $this->flashBag->add(
    31|             'mautic.core.notice.campaign.unpublished.email',
    32|             [
    33|                 '%name%'      => $email->getName(),
    34|                 '%menu_link%' => 'mautic_email_index',
    35|                 '%url%'       => $this->urlGenerator->generate('mautic_email_action', [
    36|                     'objectAction' => 'edit',
    37|                     'objectId'     => $email->getId(),
    38|                 ]),
    39|             ],
    40|             FlashBag::LEVEL_WARNING,
    41|         );
    42|     }
    43| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Controller/Api/CategoryApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Controller\CommonApiController;
     5| use Mautic\ApiBundle\Helper\EntityResultHelper;
     6| use Mautic\CategoryBundle\Entity\Category;
     7| use Mautic\CategoryBundle\Model\CategoryModel;
     8| use Mautic\CoreBundle\Factory\ModelFactory;
     9| use Mautic\CoreBundle\Helper\AppVersion;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    12| use Mautic\CoreBundle\Translation\Translator;
    13| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    14| use Symfony\Component\Form\FormFactoryInterface;
    15| use Symfony\Component\HttpFoundation\RequestStack;
    16| use Symfony\Component\Routing\RouterInterface;
    17| /**
    18|  * @extends CommonApiController<Category>
    19|  */
    20| class CategoryApiController extends CommonApiController
    21| {
    22|     public function __construct(CorePermissions $security, Translator $translator, EntityResultHelper $entityResultHelper, RouterInterface $router, FormFactoryInterface $formFactory, AppVersion $appVersion, RequestStack $requestStack, ManagerRegistry $doctrine, ModelFactory $modelFactory, EventDispatcherInterface $dispatcher, CoreParametersHelper $coreParametersHelper)
    23|     {
    24|         $categoryModel = $modelFactory->getModel('category');
    25|         \assert($categoryModel instanceof CategoryModel);
    26|         $this->model            = $categoryModel;
    27|         $this->entityClass      = Category::class;
    28|         $this->entityNameOne    = 'category';
    29|         $this->entityNameMulti  = 'categories';
    30|         $this->serializerGroups = ['categoryDetails'];
    31|         parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    32|     }
    33|     /**
    34|      * Checks if user has permission to access retrieved entity.
    35|      *
    36|      * @param Category $entity
    37|      * @param string   $action view|create|edit|publish|delete
    38|      *
    39|      * @return bool
    40|      */
    41|     protected function checkEntityAccess($entity, $action = 'view')
    42|     {
    43|         if (!$bundle = $entity->getBundle()) {
    44|             $bundle = 'category';
    45|         }
    46|         $permissionBase = $this->permissionBase;
    47|         if ($this->security->checkPermissionExists($bundle.':categories:'.$action)) {
    48|             $permissionBase = $bundle.':categories';
    49|         }
    50|         if ('create' != $action) {
    51|             $ownPerm   = "$permissionBase:{$action}own";
    52|             $otherPerm = "$permissionBase:{$action}other";
    53|             return $this->security->hasEntityAccess($ownPerm, $otherPerm, $entity->getCreatedBy());
    54|         }
    55|         return $this->security->isGranted("$permissionBase:create");
    56|     }
    57|     /**
    58|      * @return array<string, mixed>
    59|      */
    60|     protected function getEntityFormOptions(): array
    61|     {
    62|         return ['show_bundle_select' => true];
    63|     }
    64| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Controller/BatchContactController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\CategoryBundle\Model\CategoryModel;
     5| use Mautic\CategoryBundle\Model\ContactActionModel;
     6| use Mautic\CoreBundle\Controller\AbstractFormController;
     7| use Mautic\CoreBundle\Factory\ModelFactory;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\UserHelper;
    10| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    11| use Mautic\CoreBundle\Service\FlashBag;
    12| use Mautic\CoreBundle\Translation\Translator;
    13| use Mautic\LeadBundle\Form\Type\BatchType;
    14| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    15| use Symfony\Component\HttpFoundation\JsonResponse;
    16| use Symfony\Component\HttpFoundation\Request;
    17| use Symfony\Component\HttpFoundation\RequestStack;
    18| class BatchContactController extends AbstractFormController
    19| {
    20|     public function __construct(
    21|         private ContactActionModel $actionModel,
    22|         private CategoryModel $categoryModel,
    23|         ManagerRegistry $doctrine,
    24|         ModelFactory $modelFactory,
    25|         UserHelper $userHelper,
    26|         CoreParametersHelper $coreParametersHelper,
    27|         EventDispatcherInterface $dispatcher,
    28|         Translator $translator,
    29|         FlashBag $flashBag,
    30|         RequestStack $requestStack,
    31|         CorePermissions $security,
    32|     ) {
    33|         parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    34|     }
    35|     /**
    36|      * Adds or removes categories to multiple contacts defined by contact ID.
    37|      */
    38|     public function execAction(Request $request): JsonResponse
    39|     {
    40|         $params = $request->get('lead_batch');
    41|         $ids    = empty($params['ids']) ? [] : json_decode($params['ids']);
    42|         if ($ids && is_array($ids)) {
    43|             $categoriesToAdd    = $params['add'] ?? [];
    44|             $categoriesToRemove = $params['remove'] ?? [];
    45|             $contactIds         = json_decode($params['ids']);
    46|             $this->actionModel->addContactsToCategories($contactIds, $categoriesToAdd);
    47|             $this->actionModel->removeContactsFromCategories($contactIds, $categoriesToRemove);
    48|             $this->addFlashMessage('mautic.lead.batch_leads_affected', [
    49|                 '%count%'     => count($ids),
    50|             ]);
    51|         } else {
    52|             $this->addFlashMessage('mautic.core.error.ids.missing');
    53|         }
    54|         return new JsonResponse([
    55|             'closeModal' => true,
    56|             'flashes'    => $this->getFlashContent(),
    57|         ]);
    58|     }
    59|     /**
    60|      * View the modal form for adding contacts into categories in batches.
    61|      */
    62|     public function indexAction(): \Symfony\Component\HttpFoundation\Response
    63|     {
    64|         $route = $this->generateUrl('mautic_category_batch_contact_set');
    65|         $rows  = $this->categoryModel->getLookupResults('global', '', 300);
    66|         $items = [];
    67|         foreach ($rows as $category) {
    68|             $items[$category['title']] = $category['id'];
    69|         }
    70|         return $this->delegateView(
    71|             [
    72|                 'viewParameters' => [
    73|                     'form' => $this->createForm(
    74|                         BatchType::class,
    75|                         [],
    76|                         [
    77|                             'items'  => $items,
    78|                             'action' => $route,
    79|                         ]
    80|                     )->createView(),
    81|                 ],
    82|                 'contentTemplate' => '@MauticLead/Batch/form.html.twig',
    83|                 'passthroughVars' => [
    84|                     'activeLink'    => '#mautic_contact_index',
    85|                     'mauticContent' => 'leadBatch',
    86|                     'route'         => $route,
    87|                 ],
    88|             ]
    89|         );
    90|     }
    91| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Controller/CategoryController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-531 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\CategoryBundle\CategoryEvents;
     5| use Mautic\CategoryBundle\Event\CategoryTypesEvent;
     6| use Mautic\CategoryBundle\Model\CategoryModel;
     7| use Mautic\CoreBundle\Controller\AbstractFormController;
     8| use Mautic\CoreBundle\Exception\RecordCanNotBeDeletedException;
     9| use Mautic\CoreBundle\Factory\ModelFactory;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Helper\UserHelper;
    12| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    13| use Mautic\CoreBundle\Service\FlashBag;
    14| use Mautic\CoreBundle\Translation\Translator;
    15| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    16| use Symfony\Component\Form\FormFactoryInterface;
    17| use Symfony\Component\Form\SubmitButton;
    18| use Symfony\Component\HttpFoundation\JsonResponse;
    19| use Symfony\Component\HttpFoundation\Request;
    20| use Symfony\Component\HttpFoundation\RequestStack;
    21| use Symfony\Component\HttpFoundation\Response;
    22| class CategoryController extends AbstractFormController
    23| {
    24|     public function __construct(
    25|         private FormFactoryInterface $formFactory,
    26|         ManagerRegistry $doctrine,
    27|         ModelFactory $modelFactory,
    28|         UserHelper $userHelper,
    29|         CoreParametersHelper $coreParametersHelper,
    30|         EventDispatcherInterface $dispatcher,
    31|         Translator $translator,
    32|         FlashBag $flashBag,
    33|         RequestStack $requestStack,
    34|         CorePermissions $security,
    35|     ) {
    36|         parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    37|     }
    38|     /**
    39|      * @param int    $objectId
    40|      * @param string $objectModel
    41|      */
    42|     public function executeCategoryAction(Request $request, $bundle, $objectAction, $objectId = 0, $objectModel = ''): Response
    43|     {
    44|         if (method_exists($this, $objectAction.'Action')) {
    45|             return $this->forward(
    46|                 static::class.'::'.$objectAction.'Action',
    47|                 [
    48|                     'bundle'      => $bundle,
    49|                     'objectId'    => $objectId,
    50|                     'objectModel' => $objectModel,
    51|                 ],
    52|                 $request->query->all()
    53|             );
    54|         }
    55|         return $this->accessDenied();
    56|     }
    57|     /**
    58|      * @param int $page
    59|      *
    60|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
    61|      */
    62|     public function indexAction(Request $request, $bundle, $page = 1)
    63|     {
    64|         $session = $request->getSession();
    65|         $search = $request->query->get('search', $session->get('mautic.category.filter', ''));
    66|         $bundle = $request->query->get('bundle', $session->get('mautic.category.type', $bundle));
    67|         if ($bundle) {
    68|             $session->set('mautic.category.type', $bundle);
    69|         }
    70|         if ('all' == $bundle) {
    71|             $bundle = 'category';
    72|         }
    73|         $session->set('mautic.category.filter', $search);
    74|         $categoryModel  = $this->getModel('category');
    75|         \assert($categoryModel instanceof CategoryModel);
    76|         $permissionBase = $categoryModel->getPermissionBase($bundle);
    77|         $permissions    = $this->security->isGranted(
    78|             [
    79|                 $permissionBase.':view',
    80|                 $permissionBase.':create',
    81|                 $permissionBase.':edit',
    82|                 $permissionBase.':delete',
    83|             ],
    84|             'RETURN_ARRAY'
    85|         );
    86|         if (!$permissions[$permissionBase.':view']) {
    87|             return $this->accessDenied();
    88|         }
    89|         $this->setListFilters();
    90|         $viewParams = [
    91|             'page'   => $page,
    92|             'bundle' => $bundle,
    93|         ];
    94|         $limit = $session->get('mautic.category.limit', $this->coreParametersHelper->get('default_pagelimit'));
    95|         $start = (1 === $page) ? 0 : (($page - 1) * $limit);
    96|         if ($start < 0) {
    97|             $start = 0;
    98|         }
    99|         $filter = ['string' => $search];
   100|         if ('category' != $bundle) {
   101|             $filter['force'] = [
   102|                 [
   103|                     'column' => 'c.bundle',
   104|                     'expr'   => 'eq',
   105|                     'value'  => $bundle,
   106|                 ],
   107|             ];
   108|         }
   109|         $orderBy    = $request->getSession()->get('mautic.category.orderby', 'c.title');
   110|         $orderByDir = $request->getSession()->get('mautic.category.orderbydir', 'DESC');
   111|         $entities = $categoryModel->getEntities(
   112|             [
   113|                 'start'      => $start,
   114|                 'limit'      => $limit,
   115|                 'filter'     => $filter,
   116|                 'orderBy'    => $orderBy,
   117|                 'orderByDir' => $orderByDir,
   118|             ]
   119|         );
   120|         $count = count($entities);
   121|         if ($count && $count < ($start + 1)) {
   122|             if (1 === $count) {
   123|                 $lastPage = 1;
   124|             } else {
   125|                 $lastPage = (ceil($count / $limit)) ?: 1;
   126|             }
   127|             $viewParams['page'] = $lastPage;
   128|             $session->set('mautic.category.page', $lastPage);
   129|             $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
   130|             return $this->postActionRedirect(
   131|                 [
   132|                     'returnUrl'       => $returnUrl,
   133|                     'viewParameters'  => ['page' => $lastPage],
   134|                     'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   135|                     'passthroughVars' => [
   136|                         'activeLink'    => '#mautic_'.$bundle.'category_index',
   137|                         'mauticContent' => 'category',
   138|                     ],
   139|                 ]
   140|             );
   141|         }
   142|         $categoryTypes = ['category' => $this->translator->trans('mautic.core.select')];
   143|         $dispatcher = $this->dispatcher;
   144|         if ($dispatcher->hasListeners(CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD)) {
   145|             $event = new CategoryTypesEvent();
   146|             $dispatcher->dispatch($event, CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD);
   147|             $categoryTypes = array_merge($categoryTypes, $event->getCategoryTypes());
   148|         }
   149|         $session->set('mautic.category.page', $page);
   150|         $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
   151|         return $this->delegateView(
   152|             [
   153|                 'returnUrl'      => $this->generateUrl('mautic_category_index', $viewParams),
   154|                 'viewParameters' => [
   155|                     'bundle'         => $bundle,
   156|                     'permissionBase' => $permissionBase,
   157|                     'searchValue'    => $search,
   158|                     'items'          => $entities,
   159|                     'page'           => $page,
   160|                     'limit'          => $limit,
   161|                     'permissions'    => $permissions,
   162|                     'tmpl'           => $tmpl,
   163|                     'categoryTypes'  => $categoryTypes,
   164|                 ],
   165|                 'contentTemplate' => '@MauticCategory/Category/list.html.twig',
   166|                 'passthroughVars' => [
   167|                     'activeLink'    => '#mautic_'.$bundle.'category_index',
   168|                     'mauticContent' => 'category',
   169|                     'route'         => $this->generateUrl('mautic_category_index', $viewParams),
   170|                 ],
   171|             ]
   172|         );
   173|     }
   174|     /**
   175|      * Generates new form and processes post data.
   176|      *
   177|      * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
   178|      */
   179|     public function newAction(Request $request, $bundle)
   180|     {
   181|         $model = $this->getModel('category');
   182|         \assert($model instanceof CategoryModel);
   183|         $session    = $request->getSession();
   184|         $entity     = $model->getEntity();
   185|         $success    = 0;
   186|         $cancelled  = $valid  = false;
   187|         $method     = $request->getMethod();
   188|         $inForm     = $this->getInFormValue($request, $method);
   189|         $showSelect = $request->get('show_bundle_select', false);
   190|         if (!$this->security->isGranted($model->getPermissionBase($bundle).':create')) {
   191|             return $this->modalAccessDenied();
   192|         }
   193|         $action = $this->generateUrl('mautic_category_action', [
   194|             'objectAction' => 'new',
   195|             'bundle'       => $bundle,
   196|         ]);
   197|         $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle, 'show_bundle_select' => $showSelect]);
   198|         $form['inForm']->setData($inForm);
   199|         if (Request::METHOD_POST === $method) {
   200|             $valid = false;
   201|             if (!$cancelled = $this->isFormCancelled($form)) {
   202|                 if ($valid = $this->isFormValid($form)) {
   203|                     $success = 1;
   204|                     $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
   205|                     $this->addFlashMessage('mautic.category.notice.created', [
   206|                         '%name%' => $entity->getTitle(),
   207|                     ]);
   208|                 }
   209|             } else {
   210|                 $success = 1;
   211|             }
   212|         }
   213|         $closeModal = ($cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked()));
   214|         if ($closeModal) {
   215|             if ($inForm) {
   216|                 return new JsonResponse([
   217|                     'mauticContent' => 'category',
   218|                     'closeModal'    => 1,
   219|                     'inForm'        => 1,
   220|                     'categoryName'  => $entity->getTitle(),
   221|                     'categoryId'    => $entity->getId(),
   222|                 ]);
   223|             }
   224|             $viewParameters = [
   225|                 'page'   => $session->get('mautic.category.page'),
   226|                 'bundle' => $bundle,
   227|             ];
   228|             return $this->postActionRedirect([
   229|                 'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParameters),
   230|                 'viewParameters'  => $viewParameters,
   231|                 'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   232|                 'passthroughVars' => [
   233|                     'activeLink'    => '#mautic_'.$bundle.'category_index',
   234|                     'mauticContent' => 'category',
   235|                     'closeModal'    => 1,
   236|                 ],
   237|             ]);
   238|         } elseif (!empty($valid)) {
   239|             return $this->editAction($request, $bundle, $entity->getId(), true);
   240|         } else {
   241|             return $this->ajaxAction(
   242|                 $request,
   243|                 [
   244|                     'contentTemplate' => '@MauticCategory/Category/form.html.twig',
   245|                     'viewParameters'  => [
   246|                         'form'           => $form->createView(),
   247|                         'activeCategory' => $entity,
   248|                         'bundle'         => $bundle,
   249|                     ],
   250|                     'passthroughVars' => [
   251|                         'mauticContent' => 'category',
   252|                         'success'       => $success,
   253|                         'route'         => false,
   254|                     ],
   255|                 ]
   256|             );
   257|         }
   258|     }
   259|     /**
   260|      * Generates edit form and processes post data.
   261|      *
   262|      * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
   263|      */
   264|     public function editAction(Request $request, $bundle, $objectId, $ignorePost = false)
   265|     {
   266|         $session = $request->getSession();
   267|         $model   = $this->getModel('category');
   268|         \assert($model instanceof CategoryModel);
   269|         $entity    = $model->getEntity($objectId);
   270|         $success   = $closeModal   = 0;
   271|         $cancelled = $valid = false;
   272|         $method    = $request->getMethod();
   273|         $inForm    = $this->getInFormValue($request, $method);
   274|         if (null === $entity) {
   275|             $closeModal = true;
   276|         } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':view')) {
   277|             return $this->modalAccessDenied();
   278|         } elseif ($model->isLocked($entity)) {
   279|             $viewParams = [
   280|                 'page'   => $session->get('mautic.category.page', 1),
   281|                 'bundle' => $bundle,
   282|             ];
   283|             $postActionVars = [
   284|                 'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParams),
   285|                 'viewParameters'  => $viewParams,
   286|                 'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   287|                 'passthroughVars' => [
   288|                     'activeLink'    => 'mautic_'.$bundle.'category_index',
   289|                     'mauticContent' => 'category',
   290|                     'closeModal'    => 1,
   291|                 ],
   292|             ];
   293|             return $this->isLocked($postActionVars, $entity, 'category.category');
   294|         }
   295|         $action = $this->generateUrl(
   296|             'mautic_category_action',
   297|             [
   298|                 'objectAction' => 'edit',
   299|                 'objectId'     => $objectId,
   300|                 'bundle'       => $bundle,
   301|             ]
   302|         );
   303|         $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle]);
   304|         $form['inForm']->setData($inForm);
   305|         if (!$ignorePost && 'POST' == $method) {
   306|             $valid = false;
   307|             if (!$cancelled = $this->isFormCancelled($form)) {
   308|                 if ($valid = $this->isFormValid($form)) {
   309|                     $success = 1;
   310|                     $model->saveEntity($entity, $this->getFormButton($form, ['buttons', 'save'])->isClicked());
   311|                     $this->addFlashMessage(
   312|                         'mautic.category.notice.updated',
   313|                         [
   314|                             '%name%' => $entity->getTitle(),
   315|                         ]
   316|                     );
   317|                     /** @var SubmitButton $applySubmitButton */
   318|                     $applySubmitButton = $form->get('buttons')->get('apply');
   319|                     if ($applySubmitButton->isClicked()) {
   320|                         $action = $this->generateUrl(
   321|                             'mautic_category_action',
   322|                             [
   323|                                 'objectAction' => 'edit',
   324|                                 'objectId'     => $entity->getId(),
   325|                                 'bundle'       => $bundle,
   326|                             ]
   327|                         );
   328|                         $form = $model->createForm($entity, $this->formFactory, $action, ['bundle' => $bundle]);
   329|                     }
   330|                 }
   331|             } else {
   332|                 $success = 1;
   333|                 $model->unlockEntity($entity);
   334|             }
   335|         } else {
   336|             $model->lockEntity($entity);
   337|         }
   338|         $closeModal = ($closeModal || $cancelled || ($valid && $this->getFormButton($form, ['buttons', 'save'])->isClicked()));
   339|         if ($closeModal) {
   340|             if ($inForm) {
   341|                 return new JsonResponse(
   342|                     [
   343|                         'mauticContent' => 'category',
   344|                         'closeModal'    => 1,
   345|                         'inForm'        => 1,
   346|                         'categoryName'  => $entity->getTitle(),
   347|                         'categoryId'    => $entity->getId(),
   348|                     ]
   349|                 );
   350|             }
   351|             $viewParameters = [
   352|                 'page'   => $session->get('mautic.category.page'),
   353|                 'bundle' => $bundle,
   354|             ];
   355|             return $this->postActionRedirect(
   356|                 [
   357|                     'returnUrl'       => $this->generateUrl('mautic_category_index', $viewParameters),
   358|                     'viewParameters'  => $viewParameters,
   359|                     'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   360|                     'passthroughVars' => [
   361|                         'activeLink'    => '#mautic_'.$bundle.'category_index',
   362|                         'mauticContent' => 'category',
   363|                         'closeModal'    => 1,
   364|                     ],
   365|                 ]
   366|             );
   367|         } else {
   368|             return $this->ajaxAction(
   369|                 $request,
   370|                 [
   371|                     'contentTemplate' => '@MauticCategory/Category/form.html.twig',
   372|                     'viewParameters'  => [
   373|                         'form'           => $form->createView(),
   374|                         'activeCategory' => $entity,
   375|                         'bundle'         => $bundle,
   376|                     ],
   377|                     'passthroughVars' => [
   378|                         'mauticContent' => 'category',
   379|                         'success'       => $success,
   380|                         'route'         => false,
   381|                     ],
   382|                 ]
   383|             );
   384|         }
   385|     }
   386|     /**
   387|      * Deletes the entity.
   388|      *
   389|      * @return Response
   390|      */
   391|     public function deleteAction(Request $request, $bundle, $objectId)
   392|     {
   393|         $session    = $request->getSession();
   394|         $page       = $session->get('mautic.category.page', 1);
   395|         $viewParams = [
   396|             'page'   => $page,
   397|             'bundle' => $bundle,
   398|         ];
   399|         $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
   400|         $flashes   = [];
   401|         $postActionVars = [
   402|             'returnUrl'       => $returnUrl,
   403|             'viewParameters'  => $viewParams,
   404|             'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   405|             'passthroughVars' => [
   406|                 'activeLink'    => 'mautic_'.$bundle.'category_index',
   407|                 'mauticContent' => 'category',
   408|             ],
   409|         ];
   410|         if (Request::METHOD_POST === $request->getMethod()) {
   411|             $model  = $this->getModel('category');
   412|             \assert($model instanceof CategoryModel);
   413|             $entity = $model->getEntity($objectId);
   414|             if (null === $entity) {
   415|                 $flashes[] = [
   416|                     'type'    => 'error',
   417|                     'msg'     => 'mautic.category.error.notfound',
   418|                     'msgVars' => ['%id%' => $objectId],
   419|                 ];
   420|             } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':delete')) {
   421|                 return $this->accessDenied();
   422|             } elseif ($model->isLocked($entity)) {
   423|                 return $this->isLocked($postActionVars, $entity, 'category.category');
   424|             }
   425|             try {
   426|                 $model->deleteEntity($entity);
   427|                 $flashes[] = [
   428|                     'type'    => 'notice',
   429|                     'msg'     => 'mautic.core.notice.deleted',
   430|                     'msgVars' => [
   431|                         '%name%' => $entity->getTitle(),
   432|                         '%id%'   => $objectId,
   433|                     ],
   434|                 ];
   435|             } catch (RecordCanNotBeDeletedException $exception) {
   436|                 $postActionVars['responseCode'] = Response::HTTP_UNPROCESSABLE_ENTITY;
   437|                 $flashes[]                      = [
   438|                     'type' => 'notice',
   439|                     'msg'  => $exception->getMessage(),
   440|                 ];
   441|             }
   442|         } // else don't do anything
   443|         return $this->postActionRedirect(
   444|             array_merge($postActionVars, [
   445|                 'flashes' => $flashes,
   446|             ])
   447|         );
   448|     }
   449|     /**
   450|      * Deletes a group of entities.
   451|      *
   452|      * @param string $bundle
   453|      */
   454|     public function batchDeleteAction(Request $request, $bundle): Response
   455|     {
   456|         $session    = $request->getSession();
   457|         $page       = $session->get('mautic.category.page', 1);
   458|         $viewParams = [
   459|             'page'   => $page,
   460|             'bundle' => $bundle,
   461|         ];
   462|         $returnUrl = $this->generateUrl('mautic_category_index', $viewParams);
   463|         $flashes   = [];
   464|         $postActionVars = [
   465|             'returnUrl'       => $returnUrl,
   466|             'viewParameters'  => $viewParams,
   467|             'contentTemplate' => 'Mautic\CategoryBundle\Controller\CategoryController::indexAction',
   468|             'passthroughVars' => [
   469|                 'activeLink'    => 'mautic_'.$bundle.'category_index',
   470|                 'mauticContent' => 'category',
   471|             ],
   472|         ];
   473|         if (Request::METHOD_POST === $request->getMethod()) {
   474|             $model = $this->getModel('category');
   475|             \assert($model instanceof CategoryModel);
   476|             $ids       = json_decode($request->query->get('ids', '{}'));
   477|             $deleteIds = [];
   478|             $deletedExceptions = [];
   479|             foreach ($ids as $objectId) {
   480|                 $entity = $model->getEntity($objectId);
   481|                 if (null === $entity) {
   482|                     $flashes[] = [
   483|                         'type'    => 'error',
   484|                         'msg'     => 'mautic.category.error.notfound',
   485|                         'msgVars' => ['%id%' => $objectId],
   486|                     ];
   487|                 } elseif (!$this->security->isGranted($model->getPermissionBase($bundle).':delete')) {
   488|                     $flashes[] = $this->accessDenied(true);
   489|                 } elseif ($model->isLocked($entity)) {
   490|                     $flashes[] = $this->isLocked($postActionVars, $entity, 'category', true);
   491|                 } else {
   492|                     try {
   493|                         $model->deleteEntity($entity);
   494|                         $deleteIds[] = $objectId;
   495|                     } catch (RecordCanNotBeDeletedException $exception) {
   496|                         $deletedExceptions[] = $exception;
   497|                     }
   498|                 }
   499|             }
   500|             if (!empty($deleteIds)) {
   501|                 $flashes[] = [
   502|                     'type'    => 'notice',
   503|                     'msg'     => 'mautic.category.notice.batch_deleted',
   504|                     'msgVars' => [
   505|                         '%count%' => count($deleteIds),
   506|                     ],
   507|                 ];
   508|             }
   509|             foreach ($deletedExceptions as $deletedException) {
   510|                 $flashes[] = [
   511|                     'type' => 'notice',
   512|                     'msg'  => $deletedException->getMessage(),
   513|                 ];
   514|             }
   515|         } // else don't do anything
   516|         return $this->postActionRedirect(
   517|             array_merge($postActionVars, [
   518|                 'flashes' => $flashes,
   519|             ])
   520|         );
   521|     }
   522|     private function getInFormValue(Request $request, string $method): int
   523|     {
   524|         $inForm = $request->get('inForm', 0);
   525|         if (Request::METHOD_POST == $method) {
   526|             $category_form = $request->request->all()['category_form'] ?? [];
   527|             $inForm        = $category_form['inForm'] ?? 0;
   528|         }
   529|         return (int) $inForm;
   530|     }
   531| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Entity/Category.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-237 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Entity;
     3| use Doctrine\ORM\Mapping as ORM;
     4| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     5| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     6| use Mautic\CoreBundle\Entity\FormEntity;
     7| use Mautic\CoreBundle\Entity\UuidInterface;
     8| use Mautic\CoreBundle\Entity\UuidTrait;
     9| use Symfony\Component\Serializer\Annotation\Groups;
    10| use Symfony\Component\Validator\Constraints\NotBlank;
    11| use Symfony\Component\Validator\Mapping\ClassMetadata;
    12| /**
    13|  * @ApiResource(
    14|  *   collectionOperations={
    15|  *     "get",
    16|  *     "post"={"security"="'category:categories:create'"}
    17|  *   },
    18|  *   itemOperations={
    19|  *     "get"={"security"="'category:categories:view'"},
    20|  *     "put"={"security"="'category:categories:edit'"},
    21|  *     "patch"={"security"="'category:categories:edit'"},
    22|  *     "delete"={"security"="'category:categories:delete'"},
    23|  *   },
    24|  *   attributes={
    25|  *     "normalization_context"={
    26|  *       "groups"={
    27|  *         "category:read"
    28|  *        },
    29|  *       "swagger_definition_name"="Read"
    30|  *     },
    31|  *     "denormalization_context"={
    32|  *       "groups"={
    33|  *         "category:write"
    34|  *       },
    35|  *       "swagger_definition_name"="Write"
    36|  *     }
    37|  *   }
    38|  * )
    39|  */
    40| class Category extends FormEntity implements UuidInterface
    41| {
    42|     use UuidTrait;
    43|     /**
    44|      * @var int
    45|      */
    46|     private $id;
    47|     /**
    48|      * @var string
    49|      */
    50|     private $title;
    51|     /**
    52|      * @var string|null
    53|      */
    54|     private $description;
    55|     /**
    56|      * @var string
    57|      */
    58|     private $alias;
    59|     /**
    60|      * @var string|null
    61|      */
    62|     private $color;
    63|     /**
    64|      * @var string
    65|      */
    66|     private $bundle;
    67|     public static function loadMetadata(ORM\ClassMetadata $metadata): void
    68|     {
    69|         $builder = new ClassMetadataBuilder($metadata);
    70|         $builder->setTable('categories')
    71|             ->setCustomRepositoryClass(CategoryRepository::class)
    72|             ->addIndex(['alias'], 'category_alias_search');
    73|         $builder->addIdColumns('title');
    74|         $builder->addField('alias', 'string');
    75|         $builder->createField('color', 'string')
    76|             ->nullable()
    77|             ->length(7)
    78|             ->build();
    79|         $builder->createField('bundle', 'string')
    80|             ->length(50)
    81|             ->build();
    82|         static::addUuidField($builder);
    83|     }
    84|     public static function loadValidatorMetadata(ClassMetadata $metadata): void
    85|     {
    86|         $metadata->addPropertyConstraint(
    87|             'title',
    88|             new NotBlank(
    89|                 [
    90|                     'message' => 'mautic.core.title.required',
    91|                 ]
    92|             )
    93|         );
    94|         $metadata->addPropertyConstraint(
    95|             'bundle',
    96|             new NotBlank(
    97|                 [
    98|                     'message' => 'mautic.core.value.required',
    99|                 ]
   100|             )
   101|         );
   102|     }
   103|     /**
   104|      * Prepares the metadata for API usage.
   105|      */
   106|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
   107|     {
   108|         $metadata->setGroupPrefix('category')
   109|             ->addListProperties(
   110|                 [
   111|                     'id',
   112|                     'title',
   113|                     'alias',
   114|                     'description',
   115|                     'color',
   116|                     'bundle',
   117|                 ]
   118|             )
   119|             ->build();
   120|     }
   121|     public function __clone()
   122|     {
   123|         $this->id = null;
   124|         parent::__clone();
   125|     }
   126|     /**
   127|      * Get id.
   128|      *
   129|      * @return int
   130|      */
   131|     public function getId()
   132|     {
   133|         return $this->id;
   134|     }
   135|     /**
   136|      * Set title.
   137|      *
   138|      * @param string $title
   139|      *
   140|      * @return Category
   141|      */
   142|     public function setTitle($title)
   143|     {
   144|         $this->isChanged('title', $title);
   145|         $this->title = $title;
   146|         return $this;
   147|     }
   148|     /**
   149|      * Get title.
   150|      *
   151|      * @return string
   152|      */
   153|     public function getTitle()
   154|     {
   155|         return $this->title;
   156|     }
   157|     /**
   158|      * Set alias.
   159|      *
   160|      * @param string $alias
   161|      *
   162|      * @return Category
   163|      */
   164|     public function setAlias($alias)
   165|     {
   166|         $this->isChanged('alias', $alias);
   167|         $this->alias = $alias;
   168|         return $this;
   169|     }
   170|     /**
   171|      * Get alias.
   172|      *
   173|      * @return string
   174|      */
   175|     public function getAlias()
   176|     {
   177|         return $this->alias;
   178|     }
   179|     /**
   180|      * Set description.
   181|      *
   182|      * @param string $description
   183|      *
   184|      * @return Category
   185|      */
   186|     public function setDescription($description)
   187|     {
   188|         $this->isChanged('description', $description);
   189|         $this->description = $description;
   190|         return $this;
   191|     }
   192|     /**
   193|      * Get description.
   194|      *
   195|      * @return string
   196|      */
   197|     public function getDescription()
   198|     {
   199|         return $this->description;
   200|     }
   201|     /**
   202|      * @param string $color
   203|      */
   204|     public function setColor($color): void
   205|     {
   206|         $this->isChanged('color', $color);
   207|         $this->color = $color;
   208|     }
   209|     /**
   210|      * Get color.
   211|      *
   212|      * @return string
   213|      */
   214|     public function getColor()
   215|     {
   216|         return $this->color;
   217|     }
   218|     /**
   219|      * Set bundle.
   220|      *
   221|      * @param string $bundle
   222|      */
   223|     public function setBundle($bundle): void
   224|     {
   225|         $this->isChanged('bundle', $bundle);
   226|         $this->bundle = $bundle;
   227|     }
   228|     /**
   229|      * Get bundle.
   230|      *
   231|      * @return string
   232|      */
   233|     public function getBundle()
   234|     {
   235|         return $this->bundle;
   236|     }
   237| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Event/CategoryTypeEntityEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\CategoryBundle\Event;
     4| use Mautic\CoreBundle\Event\CommonEvent;
     5| final class CategoryTypeEntityEvent extends CommonEvent
     6| {
     7|     /**
     8|      * @var array<mixed>
     9|      */
    10|     protected array $types = [];
    11|     /**
    12|      * Returns the array of Category Type Entity.
    13|      *
    14|      * @return array<class-string[]>
    15|      */
    16|     public function getCategoryTypeEntity(string $type): array
    17|     {
    18|         if ('global' === $type) {
    19|             return $this->types;
    20|         }
    21|         return [$this->types[$type]];
    22|     }
    23|     /**
    24|      * @param array<mixed>|null $data
    25|      */
    26|     public function addCategoryTypeEntity(string $type, ?array $data): void
    27|     {
    28|         if (!empty($data)) {
    29|             if (!isset($data['label'])) {
    30|                 $data['label'] = 'mautic.'.$type.'.'.$type;
    31|             }
    32|             $this->types[$type] = $data;
    33|         }
    34|     }
    35| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/EventListener/ButtonSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\EventListener;
     3| use Mautic\CoreBundle\CoreEvents;
     4| use Mautic\CoreBundle\Event\CustomButtonEvent;
     5| use Mautic\CoreBundle\Twig\Helper\ButtonHelper;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| use Symfony\Component\Routing\RouterInterface;
     8| use Symfony\Contracts\Translation\TranslatorInterface;
     9| class ButtonSubscriber implements EventSubscriberInterface
    10| {
    11|     public function __construct(
    12|         private RouterInterface $router,
    13|         private TranslatorInterface $translator,
    14|     ) {
    15|     }
    16|     public static function getSubscribedEvents(): array
    17|     {
    18|         return [
    19|             CoreEvents::VIEW_INJECT_CUSTOM_BUTTONS => ['injectContactBulkButtons', 0],
    20|         ];
    21|     }
    22|     public function injectContactBulkButtons(CustomButtonEvent $event): void
    23|     {
    24|         if (str_starts_with($event->getRoute(), 'mautic_contact_')) {
    25|             $event->addButton(
    26|                 [
    27|                     'attr' => [
    28|                         'class'       => 'btn btn-ghost btn-sm btn-nospin',
    29|                         'data-toggle' => 'ajaxmodal',
    30|                         'data-target' => '#MauticSharedModal',
    31|                         'href'        => $this->router->generate('mautic_category_batch_contact_view'),
    32|                         'data-header' => $this->translator->trans('mautic.lead.batch.categories'),
    33|                     ],
    34|                     'btnText'   => $this->translator->trans('mautic.lead.batch.categories'),
    35|                     'iconClass' => 'ri-folder-line',
    36|                 ],
    37|                 ButtonHelper::LOCATION_BULK_ACTIONS
    38|             );
    39|         }
    40|     }
    41| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/EventListener/CategorySubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-106 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\EventListener;
     3| use Mautic\CategoryBundle\CategoryEvents;
     4| use Mautic\CategoryBundle\Event\CategoryEvent;
     5| use Mautic\CategoryBundle\Event\CategoryTypeEntityEvent;
     6| use Mautic\CategoryBundle\Event\CategoryTypesEvent;
     7| use Mautic\CategoryBundle\Model\CategoryModel;
     8| use Mautic\CoreBundle\Exception\RecordCanNotBeDeletedException;
     9| use Mautic\CoreBundle\Helper\BundleHelper;
    10| use Mautic\CoreBundle\Helper\IpLookupHelper;
    11| use Mautic\CoreBundle\Model\AuditLogModel;
    12| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    13| use Symfony\Contracts\Translation\TranslatorInterface;
    14| class CategorySubscriber implements EventSubscriberInterface
    15| {
    16|     public function __construct(
    17|         private BundleHelper $bundleHelper,
    18|         private IpLookupHelper $ipLookupHelper,
    19|         private AuditLogModel $auditLogModel,
    20|         private CategoryModel $categoryModel,
    21|         private TranslatorInterface $translator,
    22|     ) {
    23|     }
    24|     public static function getSubscribedEvents(): array
    25|     {
    26|         return [
    27|             CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD => ['onCategoryBundleListBuild', 0],
    28|             CategoryEvents::CATEGORY_POST_SAVE            => ['onCategoryPostSave', 0],
    29|             CategoryEvents::CATEGORY_POST_DELETE          => ['onCategoryDelete', 0],
    30|             CategoryEvents::CATEGORY_PRE_DELETE           => ['onCategoryPreDelete', 0],
    31|             CategoryTypeEntityEvent::class                => ['onCategoryTypeEntity', 0],
    32|         ];
    33|     }
    34|     /**
    35|      * Add bundle to the category.
    36|      */
    37|     public function onCategoryBundleListBuild(CategoryTypesEvent $event): void
    38|     {
    39|         $bundles = $this->bundleHelper->getMauticBundles(true);
    40|         foreach ($bundles as $bundle) {
    41|             if (!empty($bundle['config']['categories'])) {
    42|                 foreach ($bundle['config']['categories'] as $type => $data) {
    43|                     $event->addCategoryType($type, $data['label'] ?? null);
    44|                 }
    45|             }
    46|         }
    47|     }
    48|     /**
    49|      * Add an entry to the audit log.
    50|      */
    51|     public function onCategoryPostSave(CategoryEvent $event): void
    52|     {
    53|         $category = $event->getCategory();
    54|         if ($details = $event->getChanges()) {
    55|             $log = [
    56|                 'bundle'    => 'category',
    57|                 'object'    => 'category',
    58|                 'objectId'  => $category->getId(),
    59|                 'action'    => ($event->isNew()) ? 'create' : 'update',
    60|                 'details'   => $details,
    61|                 'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    62|             ];
    63|             $this->auditLogModel->writeToLog($log);
    64|         }
    65|     }
    66|     /**
    67|      * Add a delete entry to the audit log.
    68|      */
    69|     public function onCategoryDelete(CategoryEvent $event): void
    70|     {
    71|         $category = $event->getCategory();
    72|         $log      = [
    73|             'bundle'    => 'category',
    74|             'object'    => 'category',
    75|             'objectId'  => $category->deletedId,
    76|             'action'    => 'delete',
    77|             'details'   => ['name' => $category->getTitle()],
    78|             'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    79|         ];
    80|         $this->auditLogModel->writeToLog($log);
    81|     }
    82|     public function onCategoryPreDelete(CategoryEvent $event): void
    83|     {
    84|         if ($usage = $this->categoryModel->getUsage($event->getCategory())) {
    85|             $message = $this->translator->trans(
    86|                 'mautic.category.is_in_use.delete',
    87|                 [
    88|                     '%entities%'     => implode(', ', array_map(fn ($entity): string => $this->translator->trans($entity['label']).' Id: '.$entity['id'], $usage)),
    89|                     '%categoryName%' => $event->getCategory()->getTitle(),
    90|                 ],
    91|                 'validators');
    92|             throw new RecordCanNotBeDeletedException($message);
    93|         }
    94|     }
    95|     public function onCategoryTypeEntity(CategoryTypeEntityEvent $event): void
    96|     {
    97|         $bundles = $this->bundleHelper->getMauticBundles(true);
    98|         foreach ($bundles as $bundle) {
    99|             if (!empty($bundle['config']['categories'])) {
   100|                 foreach ($bundle['config']['categories'] as $type => $data) {
   101|                     $event->addCategoryTypeEntity($type, $data);
   102|                 }
   103|             }
   104|         }
   105|     }
   106| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Form/Type/CategoryBundlesType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Form\Type;
     3| use Mautic\CategoryBundle\CategoryEvents;
     4| use Mautic\CategoryBundle\Event\CategoryTypesEvent;
     5| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
     6| use Symfony\Component\Form\AbstractType;
     7| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     8| use Symfony\Component\OptionsResolver\Options;
     9| use Symfony\Component\OptionsResolver\OptionsResolver;
    10| /**
    11|  * @extends AbstractType<mixed>
    12|  */
    13| class CategoryBundlesType extends AbstractType
    14| {
    15|     public function __construct(
    16|         private EventDispatcherInterface $dispatcher,
    17|     ) {
    18|     }
    19|     public function configureOptions(OptionsResolver $resolver): void
    20|     {
    21|         $resolver->setDefaults([
    22|             'choices' => function (Options $options): array {
    23|                 if ($this->dispatcher->hasListeners(CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD)) {
    24|                     $event = $this->dispatcher->dispatch(new CategoryTypesEvent(), CategoryEvents::CATEGORY_ON_BUNDLE_LIST_BUILD);
    25|                     $types = $event->getCategoryTypes();
    26|                 } else {
    27|                     $types = [];
    28|                 }
    29|                 return array_flip($types);
    30|             },
    31|             'expanded'          => false,
    32|             'multiple'          => false,
    33|             'required'          => false,
    34|         ]);
    35|     }
    36|     public function getBlockPrefix(): string
    37|     {
    38|         return 'category_bundles_form';
    39|     }
    40|     public function getParent(): ?string
    41|     {
    42|         return ChoiceType::class;
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Form/Type/CategoryListType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Form\Type;
     3| use Doctrine\ORM\EntityManager;
     4| use Mautic\CategoryBundle\Model\CategoryModel;
     5| use Mautic\CoreBundle\Form\DataTransformer\IdToEntityModelTransformer;
     6| use Symfony\Component\Form\AbstractType;
     7| use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
     8| use Symfony\Component\Form\FormBuilderInterface;
     9| use Symfony\Component\OptionsResolver\Options;
    10| use Symfony\Component\OptionsResolver\OptionsResolver;
    11| use Symfony\Component\Routing\RouterInterface;
    12| use Symfony\Contracts\Translation\TranslatorInterface;
    13| /**
    14|  * @extends AbstractType<mixed>
    15|  */
    16| class CategoryListType extends AbstractType
    17| {
    18|     public function __construct(
    19|         private EntityManager $em,
    20|         private TranslatorInterface $translator,
    21|         private CategoryModel $model,
    22|         private RouterInterface $router,
    23|     ) {
    24|     }
    25|     public function buildForm(FormBuilderInterface $builder, array $options): void
    26|     {
    27|         if (true === $options['return_entity']) {
    28|             $transformer = new IdToEntityModelTransformer($this->em, \Mautic\CategoryBundle\Entity\Category::class, 'id');
    29|             $builder->addModelTransformer($transformer);
    30|         }
    31|     }
    32|     public function configureOptions(OptionsResolver $resolver): void
    33|     {
    34|         $resolver->setDefaults([
    35|             'choices' => function (Options $options): array {
    36|                 $createNew  = $this->translator->trans('mautic.category.createnew');
    37|                 $categories = $this->model->getLookupResults($options['bundle'], '', 0);
    38|                 $choices    = [];
    39|                 foreach ($categories as $l) {
    40|                     $choices[$l['title']] = $l['id'];
    41|                 }
    42|                 $choices[$createNew] = 'new';
    43|                 return $choices;
    44|             },
    45|             'label'             => 'mautic.core.category',
    46|             'label_attr'        => ['class' => 'control-label'],
    47|             'multiple'          => false,
    48|             'placeholder'       => 'mautic.core.form.uncategorized',
    49|             'attr'              => function (Options $options): array {
    50|                 $modalHeader = $this->translator->trans('mautic.category.header.new');
    51|                 $newUrl      = $this->router->generate('mautic_category_action', [
    52|                     'objectAction' => 'new',
    53|                     'bundle'       => $options['bundle'],
    54|                     'inForm'       => 1,
    55|                 ]);
    56|                 return [
    57|                     'class'    => 'form-control category-select',
    58|                     'onchange' => "Mautic.loadAjaxModalBySelectValue(this, 'new', '{$newUrl}', '{$modalHeader}');",
    59|                 ];
    60|             },
    61|             'required'      => false,
    62|             'return_entity' => true,
    63|         ]);
    64|         $resolver->setRequired(['bundle']);
    65|     }
    66|     public function getBlockPrefix(): string
    67|     {
    68|         return 'category';
    69|     }
    70|     public function getParent(): ?string
    71|     {
    72|         return ChoiceType::class;
    73|     }
    74| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Form/Type/CategoryType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-134 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Form\Type;
     3| use Mautic\CategoryBundle\Entity\Category;
     4| use Mautic\CoreBundle\Form\EventListener\CleanFormSubscriber;
     5| use Mautic\CoreBundle\Form\EventListener\FormExitSubscriber;
     6| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     7| use Mautic\CoreBundle\Form\Type\YesNoButtonGroupType;
     8| use Symfony\Component\Form\AbstractType;
     9| use Symfony\Component\Form\Extension\Core\Type\HiddenType;
    10| use Symfony\Component\Form\Extension\Core\Type\TextType;
    11| use Symfony\Component\Form\FormBuilderInterface;
    12| use Symfony\Component\HttpFoundation\RequestStack;
    13| use Symfony\Component\OptionsResolver\Options;
    14| use Symfony\Component\OptionsResolver\OptionsResolver;
    15| /**
    16|  * @extends AbstractType<Category>
    17|  */
    18| class CategoryType extends AbstractType
    19| {
    20|     public function __construct(
    21|         private RequestStack $requestStack,
    22|     ) {
    23|     }
    24|     public function buildForm(FormBuilderInterface $builder, array $options): void
    25|     {
    26|         $builder->addEventSubscriber(new CleanFormSubscriber([]));
    27|         $builder->addEventSubscriber(new FormExitSubscriber('category.category', $options));
    28|         if (!$options['data']->getId()) {
    29|             if (true == $options['show_bundle_select']) {
    30|                 $selected = $this->requestStack->getSession()->get('mautic.category.type', 'category');
    31|                 $builder->add(
    32|                     'bundle',
    33|                     CategoryBundlesType::class,
    34|                     [
    35|                         'label'      => 'mautic.core.type',
    36|                         'label_attr' => ['class' => 'control-label'],
    37|                         'attr'       => ['class' => 'form-control'],
    38|                         'required'   => true,
    39|                         'data'       => $selected,
    40|                     ]
    41|                 );
    42|             } else {
    43|                 $builder->add(
    44|                     'bundle',
    45|                     HiddenType::class,
    46|                     [
    47|                         'data' => $options['bundle'],
    48|                     ]
    49|                 );
    50|             }
    51|         }
    52|         $builder->add(
    53|             'title',
    54|             TextType::class,
    55|             [
    56|                 'label'      => 'mautic.core.title',
    57|                 'label_attr' => ['class' => 'control-label'],
    58|                 'attr'       => ['class' => 'form-control'],
    59|             ]
    60|         );
    61|         $builder->add(
    62|             'description',
    63|             TextType::class,
    64|             [
    65|                 'label'      => 'mautic.core.description',
    66|                 'label_attr' => ['class' => 'control-label'],
    67|                 'attr'       => ['class' => 'form-control'],
    68|                 'required'   => false,
    69|             ]
    70|         );
    71|         $builder->add(
    72|             'alias',
    73|             TextType::class,
    74|             [
    75|                 'label'      => 'mautic.core.alias',
    76|                 'label_attr' => ['class' => 'control-label'],
    77|                 'attr'       => [
    78|                     'class'   => 'form-control',
    79|                     'tooltip' => 'mautic.category.form.alias.help',
    80|                 ],
    81|                 'required' => false,
    82|             ]
    83|         );
    84|         $builder->add(
    85|             'color',
    86|             TextType::class,
    87|             [
    88|                 'label'      => 'mautic.core.color',
    89|                 'label_attr' => ['class' => 'control-label'],
    90|                 'attr'       => [
    91|                     'class'       => 'form-control',
    92|                     'data-toggle' => 'color',
    93|                 ],
    94|                 'required' => false,
    95|             ]
    96|         );
    97|         $builder->add('isPublished', YesNoButtonGroupType::class, [
    98|             'label' => 'mautic.core.form.available',
    99|         ]);
   100|         $builder->add(
   101|             'inForm',
   102|             HiddenType::class,
   103|             [
   104|                 'mapped' => false,
   105|             ]
   106|         );
   107|         $builder->add('buttons', FormButtonsType::class,
   108|             [
   109|                 'apply_text' => false,
   110|             ]);
   111|         if (!empty($options['action'])) {
   112|             $builder->setAction($options['action']);
   113|         }
   114|     }
   115|     public function configureOptions(OptionsResolver $resolver): void
   116|     {
   117|         $resolver->setDefaults(
   118|             [
   119|                 'data_class'         => Category::class,
   120|                 'show_bundle_select' => false,
   121|                 'bundle'             => function (Options $options) {
   122|                     if (!$bundle = $options['data']->getBundle()) {
   123|                         $bundle = 'category';
   124|                     }
   125|                     return $bundle;
   126|                 },
   127|             ]
   128|         );
   129|     }
   130|     public function getBlockPrefix(): string
   131|     {
   132|         return 'category_form';
   133|     }
   134| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Model/CategoryModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-188 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Model;
     3| use Doctrine\ORM\EntityManager;
     4| use Mautic\CategoryBundle\CategoryEvents;
     5| use Mautic\CategoryBundle\Entity\Category;
     6| use Mautic\CategoryBundle\Entity\CategoryRepository;
     7| use Mautic\CategoryBundle\Event\CategoryEvent;
     8| use Mautic\CategoryBundle\Event\CategoryTypeEntityEvent;
     9| use Mautic\CategoryBundle\Form\Type\CategoryType;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Helper\UserHelper;
    12| use Mautic\CoreBundle\Model\FormModel;
    13| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    14| use Mautic\CoreBundle\Translation\Translator;
    15| use Psr\Log\LoggerInterface;
    16| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    17| use Symfony\Component\Form\FormFactoryInterface;
    18| use Symfony\Component\HttpFoundation\RequestStack;
    19| use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
    20| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    21| use Symfony\Contracts\EventDispatcher\Event;
    22| /**
    23|  * @extends FormModel<Category>
    24|  */
    25| class CategoryModel extends FormModel
    26| {
    27|     /**
    28|      * @var array<string,mixed[]>
    29|      */
    30|     private array $categoriesByBundleCache = [];
    31|     public function __construct(
    32|         protected RequestStack $requestStack,
    33|         EntityManager $em,
    34|         CorePermissions $security,
    35|         EventDispatcherInterface $dispatcher,
    36|         UrlGeneratorInterface $router,
    37|         Translator $translator,
    38|         UserHelper $userHelper,
    39|         LoggerInterface $mauticLogger,
    40|         CoreParametersHelper $coreParametersHelper,
    41|     ) {
    42|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    43|     }
    44|     public function getRepository(): CategoryRepository
    45|     {
    46|         $repository = $this->em->getRepository(Category::class);
    47|         \assert($repository instanceof CategoryRepository);
    48|         return $repository;
    49|     }
    50|     public function getNameGetter(): string
    51|     {
    52|         return 'getTitle';
    53|     }
    54|     public function getPermissionBase(string $bundle = null): string
    55|     {
    56|         if (null === $bundle) {
    57|             $bundle = $this->requestStack->getCurrentRequest()->get('bundle');
    58|         }
    59|         if ('global' === $bundle || empty($bundle)) {
    60|             $bundle = 'category';
    61|         }
    62|         return $bundle.':categories';
    63|     }
    64|     public function saveEntity($entity, $unlock = true): void
    65|     {
    66|         $alias = $entity->getAlias();
    67|         if (empty($alias)) {
    68|             $alias = $entity->getTitle();
    69|         }
    70|         $alias = $this->cleanAlias($alias, '', 0, '-');
    71|         $repo      = $this->getRepository();
    72|         $testAlias = $alias;
    73|         $bundle    = $entity->getBundle();
    74|         $count     = $repo->checkUniqueCategoryAlias($bundle, $testAlias, $entity);
    75|         $aliasTag  = $count;
    76|         while ($count) {
    77|             $testAlias = $alias.$aliasTag;
    78|             $count     = $repo->checkUniqueCategoryAlias($bundle, $testAlias, $entity);
    79|             ++$aliasTag;
    80|         }
    81|         if ($testAlias != $alias) {
    82|             $alias = $testAlias;
    83|         }
    84|         $entity->setAlias($alias);
    85|         parent::saveEntity($entity, $unlock);
    86|     }
    87|     /**
    88|      * @param string|null $action
    89|      * @param array       $options
    90|      */
    91|     public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
    92|     {
    93|         if (!$entity instanceof Category) {
    94|             throw new MethodNotAllowedHttpException(['Category']);
    95|         }
    96|         if (!empty($action)) {
    97|             $options['action'] = $action;
    98|         }
    99|         return $formFactory->create(CategoryType::class, $entity, $options);
   100|     }
   101|     /**
   102|      * Get a specific entity or generate a new one if id is empty.
   103|      */
   104|     public function getEntity($id = null): ?Category
   105|     {
   106|         if (null === $id) {
   107|             return new Category();
   108|         }
   109|         return parent::getEntity($id);
   110|     }
   111|     /**
   112|      * @throws MethodNotAllowedHttpException
   113|      */
   114|     protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
   115|     {
   116|         if (!$entity instanceof Category) {
   117|             throw new MethodNotAllowedHttpException(['Category']);
   118|         }
   119|         switch ($action) {
   120|             case 'pre_save':
   121|                 $name = CategoryEvents::CATEGORY_PRE_SAVE;
   122|                 break;
   123|             case 'post_save':
   124|                 $name = CategoryEvents::CATEGORY_POST_SAVE;
   125|                 break;
   126|             case 'pre_delete':
   127|                 $name = CategoryEvents::CATEGORY_PRE_DELETE;
   128|                 break;
   129|             case 'post_delete':
   130|                 $name = CategoryEvents::CATEGORY_POST_DELETE;
   131|                 break;
   132|             default:
   133|                 return null;
   134|         }
   135|         if ($this->dispatcher->hasListeners($name)) {
   136|             if (empty($event)) {
   137|                 $event = new CategoryEvent($entity, $isNew);
   138|                 $event->setEntityManager($this->em);
   139|             }
   140|             $this->dispatcher->dispatch($event, $name);
   141|             return $event;
   142|         } else {
   143|             return null;
   144|         }
   145|     }
   146|     /**
   147|      * Get list of entities for autopopulate fields.
   148|      *
   149|      * @param string $bundle
   150|      * @param string $filter
   151|      * @param int    $limit
   152|      *
   153|      * @return mixed[]
   154|      */
   155|     public function getLookupResults($bundle, $filter = '', $limit = 10): array
   156|     {
   157|         $key = $bundle.$filter.$limit;
   158|         if (!empty($this->categoriesByBundleCache[$key])) {
   159|             return $this->categoriesByBundleCache[$key];
   160|         }
   161|         return $this->categoriesByBundleCache[$key] = $this->getRepository()->getCategoryList($bundle, $filter, $limit, 0);
   162|     }
   163|     /**
   164|      * @return array<mixed>
   165|      */
   166|     public function getUsage(Category $category): array
   167|     {
   168|         $bundle = $category->getBundle();
   169|         $types = [];
   170|         if ($this->dispatcher->hasListeners(CategoryTypeEntityEvent::class)) {
   171|             $event = $this->dispatcher->dispatch(new CategoryTypeEntityEvent());
   172|             $types = $event->getCategoryTypeEntity($bundle);
   173|         }
   174|         $data = [];
   175|         foreach ($types as $type) {
   176|             $class     = $type['class'];
   177|             $resources = $this->em->getRepository($class)->findBy(['category' => $category->getId()]);
   178|             if (!$resources) {
   179|                 continue;
   180|             }
   181|             $data = array_merge(array_map(fn ($resource): array => [
   182|                 'label' => $type['label'],
   183|                 'id'    => $resource->getId(),
   184|             ], $resources), $data);
   185|         }
   186|         return $data;
   187|     }
   188| }


# ====================================================================
# FILE: app/bundles/CategoryBundle/Model/ContactActionModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| <?php
     2| namespace Mautic\CategoryBundle\Model;
     3| use Mautic\LeadBundle\Model\LeadModel;
     4| class ContactActionModel
     5| {
     6|     public function __construct(
     7|         private LeadModel $contactModel,
     8|     ) {
     9|     }
    10|     public function addContactsToCategories(array $contactIds, array $categoryIds): void
    11|     {
    12|         $contacts = $this->contactModel->getLeadsByIds($contactIds);
    13|         foreach ($contacts as $contact) {
    14|             if (!$this->contactModel->canEditContact($contact)) {
    15|                 continue;
    16|             }
    17|             $this->contactModel->addToCategory($contact, $categoryIds);
    18|         }
    19|     }
    20|     public function removeContactsFromCategories(array $contactIds, array $categoryIds): void
    21|     {
    22|         $contacts = $this->contactModel->getLeadsByIds($contactIds);
    23|         foreach ($contacts as $contact) {
    24|             if (!$this->contactModel->canEditContact($contact)) {
    25|                 continue;
    26|             }
    27|             $contactCategoryRelations = $this->contactModel->getLeadCategories($contact);
    28|             $relationsToDelete        = array_intersect($contactCategoryRelations, $categoryIds);
    29|             $this->contactModel->removeFromCategories($relationsToDelete);
    30|         }
    31|     }
    32| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Command/ProcessMarketingMessagesQueueCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-65 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Command;
     3| use Mautic\ChannelBundle\Model\MessageQueueModel;
     4| use Mautic\CoreBundle\Command\ModeratedCommand;
     5| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     6| use Mautic\CoreBundle\Helper\PathsHelper;
     7| use Symfony\Component\Console\Input\InputInterface;
     8| use Symfony\Component\Console\Input\InputOption;
     9| use Symfony\Component\Console\Output\OutputInterface;
    10| use Symfony\Contracts\Translation\TranslatorInterface;
    11| class ProcessMarketingMessagesQueueCommand extends ModeratedCommand
    12| {
    13|     public function __construct(
    14|         private TranslatorInterface $translator,
    15|         private MessageQueueModel $messageQueueModel,
    16|         PathsHelper $pathsHelper,
    17|         CoreParametersHelper $coreParametersHelper,
    18|     ) {
    19|         parent::__construct($pathsHelper, $coreParametersHelper);
    20|     }
    21|     protected function configure()
    22|     {
    23|         $this
    24|             ->setName('mautic:messages:send')
    25|             ->setAliases(
    26|                 [
    27|                     'mautic:campaigns:messagequeue',
    28|                     'mautic:campaigns:messages',
    29|                 ]
    30|             )
    31|             ->addOption(
    32|                 '--channel',
    33|                 '-c',
    34|                 InputOption::VALUE_OPTIONAL,
    35|                 'Channel to use for sending messages i.e. email, sms.',
    36|                 null
    37|             )
    38|             ->addOption('--channel-id', '-i', InputOption::VALUE_REQUIRED, 'The ID of the message i.e. email ID, sms ID.')
    39|             ->addOption('--message-id', '-m', InputOption::VALUE_REQUIRED, 'ID of a specific queued message');
    40|         parent::configure();
    41|     }
    42|     protected function execute(InputInterface $input, OutputInterface $output): int
    43|     {
    44|         $processed  = 0;
    45|         $channel    = $input->getOption('channel');
    46|         $channelId  = $input->getOption('channel-id');
    47|         $messageId  = $input->getOption('message-id');
    48|         $key        = $channel.$channelId.$messageId;
    49|         if (!$this->checkRunStatus($input, $output, $key)) {
    50|             return \Symfony\Component\Console\Command\Command::SUCCESS;
    51|         }
    52|         $output->writeln('<info>'.$this->translator->trans('mautic.campaign.command.process.messages').'</info>');
    53|         if ($messageId) {
    54|             if ($message = $this->messageQueueModel->getEntity($messageId)) {
    55|                 $processed = intval($this->messageQueueModel->processMessageQueue($message));
    56|             }
    57|         } else {
    58|             $processed = intval($this->messageQueueModel->sendMessages($channel, $channelId));
    59|         }
    60|         $output->writeln('<comment>'.$this->translator->trans('mautic.campaign.command.messages.sent', ['%events%' => $processed]).'</comment>'."\n");
    61|         $this->completeRun();
    62|         return \Symfony\Component\Console\Command\Command::SUCCESS;
    63|     }
    64|     protected static $defaultDescription = 'Process sending of messages queue.';
    65| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Command/SendChannelBroadcastCommand.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-151 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Command;
     3| use Mautic\ChannelBundle\ChannelEvents;
     4| use Mautic\ChannelBundle\Event\ChannelBroadcastEvent;
     5| use Mautic\CoreBundle\Command\ModeratedCommand;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| use Mautic\CoreBundle\Helper\PathsHelper;
     8| use Symfony\Component\Console\Helper\Table;
     9| use Symfony\Component\Console\Input\InputInterface;
    10| use Symfony\Component\Console\Input\InputOption;
    11| use Symfony\Component\Console\Output\OutputInterface;
    12| use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
    13| use Symfony\Contracts\Translation\TranslatorInterface;
    14| /**
    15|  * CLI Command to send a scheduled broadcast.
    16|  */
    17| class SendChannelBroadcastCommand extends ModeratedCommand
    18| {
    19|     public function __construct(
    20|         private TranslatorInterface $translator,
    21|         private EventDispatcherInterface $dispatcher,
    22|         PathsHelper $pathsHelper,
    23|         CoreParametersHelper $coreParametersHelper,
    24|     ) {
    25|         parent::__construct($pathsHelper, $coreParametersHelper);
    26|     }
    27|     protected function configure()
    28|     {
    29|         $this->setName('mautic:broadcasts:send')
    30|             ->setHelp(
    31|                 <<<'EOT'
    32|                 The <info>%command.name%</info> command is send a channel broadcast to pending contacts.
    33| <info>php %command.full_name% --channel=email --id=3</info>
    34| EOT
    35|             )
    36|             ->setDefinition(
    37|                 [
    38|                     new InputOption(
    39|                         'channel', 'c', InputOption::VALUE_OPTIONAL,
    40|                         'A specific channel to process broadcasts for pending contacts.'
    41|                     ),
    42|                     new InputOption(
    43|                         'id', 'i', InputOption::VALUE_OPTIONAL,
    44|                         'The ID for a specifc channel to process broadcasts for pending contacts.'
    45|                     ),
    46|                     new InputOption(
    47|                         'min-contact-id', null, InputOption::VALUE_OPTIONAL,
    48|                         'Min contact ID to filter recipients.'
    49|                     ),
    50|                     new InputOption(
    51|                         'max-contact-id', null, InputOption::VALUE_OPTIONAL,
    52|                         'Max contact ID to filter recipients.'
    53|                     ),
    54|                     new InputOption(
    55|                         'limit', 'l', InputOption::VALUE_OPTIONAL,
    56|                         'Limit how many contacts to load from database to process.'
    57|                     ),
    58|                     new InputOption(
    59|                         'batch', 'b', InputOption::VALUE_OPTIONAL,
    60|                         'Limit how many messages to send at once.'
    61|                     ),
    62|                 ]
    63|             )->addOption(
    64|                 '--thread-id',
    65|                 null,
    66|                 InputOption::VALUE_OPTIONAL,
    67|                 'The number of this current process if running multiple in parallel.'
    68|             )
    69|             ->addOption(
    70|                 '--max-threads',
    71|                 null,
    72|                 InputOption::VALUE_OPTIONAL,
    73|                 'The maximum number of processes you intend to run in parallel.'
    74|             );
    75|         parent::configure();
    76|     }
    77|     protected function execute(InputInterface $input, OutputInterface $output): int
    78|     {
    79|         $channel       = $input->getOption('channel');
    80|         $channelId     = $input->getOption('id');
    81|         $limit         = $input->getOption('limit');
    82|         $batch         = $input->getOption('batch');
    83|         $minContactId  = $input->getOption('min-contact-id');
    84|         $maxContactId  = $input->getOption('max-contact-id');
    85|         $threadId      = $input->getOption('thread-id');
    86|         $maxThreads    = $input->getOption('max-threads');
    87|         $key           = sprintf('%s-%s-%s-%s', $channel, $channelId, $threadId, $maxThreads);
    88|         if (is_numeric($limit)) {
    89|             $limit = (int) $limit;
    90|         }
    91|         if (is_numeric($batch)) {
    92|             $batch = (int) $batch;
    93|         }
    94|         if (is_numeric($minContactId)) {
    95|             $minContactId = (int) $minContactId;
    96|         }
    97|         if (is_numeric($maxContactId)) {
    98|             $maxContactId = (int) $maxContactId;
    99|         }
   100|         if (is_numeric($threadId)) {
   101|             $threadId = (int) $threadId;
   102|         }
   103|         if (is_numeric($maxThreads)) {
   104|             $maxThreads = (int) $maxThreads;
   105|         }
   106|         if ($threadId && $maxThreads) {
   107|             if ((int) $threadId > (int) $maxThreads) {
   108|                 $output->writeln('--thread-id cannot be larger than --max-thread');
   109|                 return \Symfony\Component\Console\Command\Command::FAILURE;
   110|             }
   111|         }
   112|         if (!$this->checkRunStatus($input, $output, $key)) {
   113|             return \Symfony\Component\Console\Command\Command::SUCCESS;
   114|         }
   115|         $event = new ChannelBroadcastEvent($channel, $channelId, $output);
   116|         if ($limit) {
   117|             $event->setLimit((int) $limit);
   118|         }
   119|         if ($batch) {
   120|             $event->setBatch((int) $batch);
   121|         }
   122|         if ($minContactId) {
   123|             $event->setMinContactIdFilter((int) $minContactId);
   124|         }
   125|         if ($maxContactId) {
   126|             $event->setMaxContactIdFilter((int) $maxContactId);
   127|         }
   128|         if ($threadId) {
   129|             $event->setThreadId((int) $threadId);
   130|         }
   131|         if ($maxThreads) {
   132|             $event->setMaxThreads((int) $maxThreads);
   133|         }
   134|         $this->dispatcher->dispatch($event, ChannelEvents::CHANNEL_BROADCAST);
   135|         $results = $event->getResults();
   136|         $rows = [];
   137|         foreach ($results as $channel => $counts) {
   138|             $rows[] = [$channel, $counts['success'], $counts['failed']];
   139|         }
   140|         $output->writeln('');
   141|         $output->writeln('');
   142|         $table = new Table($output);
   143|         $table
   144|             ->setHeaders([$this->translator->trans('mautic.core.channel'), $this->translator->trans('mautic.core.channel.broadcast_success_count'), $this->translator->trans('mautic.core.channel.broadcast_failed_count')])
   145|             ->setRows($rows);
   146|         $table->render();
   147|         $this->completeRun();
   148|         return \Symfony\Component\Console\Command\Command::SUCCESS;
   149|     }
   150|     protected static $defaultDescription = 'Process contacts pending to receive a channel broadcast.';
   151| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Config/config.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| <?php
     2| return [
     3|     'routes' => [
     4|         'main' => [
     5|             'mautic_message_index' => [
     6|                 'path'       => '/messages/{page}',
     7|                 'controller' => 'Mautic\ChannelBundle\Controller\MessageController::indexAction',
     8|             ],
     9|             'mautic_message_contacts' => [
    10|                 'path'       => '/messages/contacts/{objectId}/{channel}/{page}',
    11|                 'controller' => 'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
    12|             ],
    13|             'mautic_message_action' => [
    14|                 'path'       => '/messages/{objectAction}/{objectId}',
    15|                 'controller' => 'Mautic\ChannelBundle\Controller\MessageController::executeAction',
    16|             ],
    17|             'mautic_channel_batch_contact_set' => [
    18|                 'path'       => '/channels/batch/contact/set',
    19|                 'controller' => 'Mautic\ChannelBundle\Controller\BatchContactController::setAction',
    20|             ],
    21|             'mautic_channel_batch_contact_view' => [
    22|                 'path'       => '/channels/batch/contact/view',
    23|                 'controller' => 'Mautic\ChannelBundle\Controller\BatchContactController::indexAction',
    24|             ],
    25|         ],
    26|         'api' => [
    27|             'mautic_api_messagetandard' => [
    28|                 'standard_entity' => true,
    29|                 'name'            => 'messages',
    30|                 'path'            => '/messages',
    31|                 'controller'      => Mautic\ChannelBundle\Controller\Api\MessageApiController::class,
    32|             ],
    33|         ],
    34|         'public' => [
    35|         ],
    36|     ],
    37|     'menu' => [
    38|         'main' => [
    39|             'mautic.channel.messages' => [
    40|                 'route'    => 'mautic_message_index',
    41|                 'access'   => ['channel:messages:viewown', 'channel:messages:viewother'],
    42|                 'parent'   => 'mautic.core.channels',
    43|                 'priority' => 110,
    44|             ],
    45|         ],
    46|         'admin' => [
    47|         ],
    48|         'profile' => [
    49|         ],
    50|         'extra' => [
    51|         ],
    52|     ],
    53|     'categories' => [
    54|         'messages' => [
    55|             'class' => Mautic\ChannelBundle\Entity\Message::class,
    56|         ],
    57|     ],
    58|     'services' => [
    59|         'helpers' => [
    60|             'mautic.channel.helper.channel_list' => [
    61|                 'class'     => Mautic\ChannelBundle\Helper\ChannelListHelper::class,
    62|                 'arguments' => [
    63|                     'event_dispatcher',
    64|                     'translator',
    65|                 ],
    66|                 'alias' => 'channel',
    67|             ],
    68|         ],
    69|     ],
    70|     'parameters' => [
    71|     ],
    72| ];


# ====================================================================
# FILE: app/bundles/ChannelBundle/Controller/Api/MessageApiController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-82 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Controller\Api;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ApiBundle\Controller\CommonApiController;
     5| use Mautic\ApiBundle\Helper\EntityResultHelper;
     6| use Mautic\ChannelBundle\ChannelEvents;
     7| use Mautic\ChannelBundle\Entity\Message;
     8| use Mautic\ChannelBundle\Event\ChannelEvent;
     9| use Mautic\ChannelBundle\Model\MessageModel;
    10| use Mautic\CoreBundle\Factory\ModelFactory;
    11| use Mautic\CoreBundle\Helper\AppVersion;
    12| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    13| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    14| use Mautic\CoreBundle\Translation\Translator;
    15| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    16| use Symfony\Component\Form\FormFactoryInterface;
    17| use Symfony\Component\Form\FormInterface;
    18| use Symfony\Component\HttpFoundation\RequestStack;
    19| use Symfony\Component\Routing\RouterInterface;
    20| /**
    21|  * @extends CommonApiController<Message>
    22|  */
    23| class MessageApiController extends CommonApiController
    24| {
    25|     /**
    26|      * @var MessageModel|null
    27|      */
    28|     protected $model;
    29|     public function __construct(
    30|         CorePermissions $security,
    31|         Translator $translator,
    32|         EntityResultHelper $entityResultHelper,
    33|         RouterInterface $router,
    34|         FormFactoryInterface $formFactory,
    35|         AppVersion $appVersion,
    36|         private RequestStack $requestStack,
    37|         ManagerRegistry $doctrine,
    38|         ModelFactory $modelFactory,
    39|         EventDispatcherInterface $dispatcher,
    40|         CoreParametersHelper $coreParametersHelper,
    41|     ) {
    42|         $messageModel = $modelFactory->getModel('channel.message');
    43|         \assert($messageModel instanceof MessageModel);
    44|         $this->model            = $messageModel;
    45|         $this->entityClass      = Message::class;
    46|         $this->entityNameOne    = 'message';
    47|         $this->entityNameMulti  = 'messages';
    48|         $this->serializerGroups = ['messageDetails', 'messageChannelList', 'categoryList', 'publishDetails'];
    49|         parent::__construct($security, $translator, $entityResultHelper, $router, $formFactory, $appVersion, $requestStack, $doctrine, $modelFactory, $dispatcher, $coreParametersHelper);
    50|     }
    51|     protected function prepareParametersFromRequest(FormInterface $form, array &$params, object $entity = null, array $masks = [], array $fields = []): void
    52|     {
    53|         parent::prepareParametersFromRequest($form, $params, $entity, $masks);
    54|         if ('PATCH' === $this->requestStack->getCurrentRequest()->getMethod() && !isset($params['channels'])) {
    55|             return;
    56|         } elseif (!isset($params['channels'])) {
    57|             $params['channels'] = [];
    58|         }
    59|         $channels = $this->model->getChannels();
    60|         foreach ($channels as $channelType => $channel) {
    61|             if (!isset($params['channels'][$channelType])) {
    62|                 $params['channels'][$channelType] = ['isEnabled' => 0];
    63|             } else {
    64|                 $params['channels'][$channelType]['isEnabled'] = (int) $params['channels'][$channelType]['isEnabled'];
    65|             }
    66|             $params['channels'][$channelType]['channel'] = $channelType;
    67|         }
    68|     }
    69|     /**
    70|      * Load and set channel names to the response.
    71|      */
    72|     protected function preSerializeEntity(object $entity, string $action = 'view'): void
    73|     {
    74|         $event = $this->dispatcher->dispatch(new ChannelEvent(), ChannelEvents::ADD_CHANNEL);
    75|         foreach ($entity->getChannels() as $channel) {
    76|             $repository = $event->getRepositoryName($channel->getChannel());
    77|             $nameColumn = $event->getNameColumn($channel->getChannel());
    78|             $name       = $this->model->getChannelName($channel->getChannelId(), $repository, $nameColumn);
    79|             $channel->setChannelName($name);
    80|         }
    81|     }
    82| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Controller/BatchContactController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ChannelBundle\Model\ChannelActionModel;
     5| use Mautic\ChannelBundle\Model\FrequencyActionModel;
     6| use Mautic\CoreBundle\Controller\AbstractFormController;
     7| use Mautic\CoreBundle\Factory\ModelFactory;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Mautic\CoreBundle\Helper\UserHelper;
    10| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    11| use Mautic\CoreBundle\Service\FlashBag;
    12| use Mautic\CoreBundle\Translation\Translator;
    13| use Mautic\LeadBundle\Form\Type\ContactChannelsType;
    14| use Mautic\LeadBundle\Model\LeadModel;
    15| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    16| use Symfony\Component\HttpFoundation\JsonResponse;
    17| use Symfony\Component\HttpFoundation\Request;
    18| use Symfony\Component\HttpFoundation\RequestStack;
    19| class BatchContactController extends AbstractFormController
    20| {
    21|     public function __construct(
    22|         private ChannelActionModel $channelActionModel,
    23|         private FrequencyActionModel $frequencyActionModel,
    24|         private LeadModel $contactModel,
    25|         ManagerRegistry $doctrine,
    26|         ModelFactory $modelFactory,
    27|         UserHelper $userHelper,
    28|         CoreParametersHelper $coreParametersHelper,
    29|         EventDispatcherInterface $dispatcher,
    30|         Translator $translator,
    31|         FlashBag $flashBag,
    32|         RequestStack $requestStack,
    33|         CorePermissions $security,
    34|     ) {
    35|         parent::__construct($doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    36|     }
    37|     /**
    38|      * Execute the batch action.
    39|      */
    40|     public function setAction(Request $request): JsonResponse
    41|     {
    42|         $params = $request->get('contact_channels', []);
    43|         $ids    = empty($params['ids']) ? [] : json_decode($params['ids']);
    44|         if ($ids && is_array($ids)) {
    45|             $subscribedChannels = $params['subscribed_channels'] ?? [];
    46|             $preferredChannel   = $params['preferred_channel'] ?? null;
    47|             $this->channelActionModel->update($ids, $subscribedChannels);
    48|             $this->frequencyActionModel->update($ids, $params, $preferredChannel);
    49|             $this->addFlashMessage('mautic.lead.batch_leads_affected', [
    50|                 '%count%'     => count($ids),
    51|             ]);
    52|         } else {
    53|             $this->addFlashMessage('mautic.core.error.ids.missing');
    54|         }
    55|         return new JsonResponse([
    56|             'closeModal' => true,
    57|             'flashes'    => $this->getFlashContent(),
    58|         ]);
    59|     }
    60|     /**
    61|      * View for batch action.
    62|      */
    63|     public function indexAction(): \Symfony\Component\HttpFoundation\Response
    64|     {
    65|         $route = $this->generateUrl('mautic_channel_batch_contact_set');
    66|         return $this->delegateView([
    67|             'viewParameters' => [
    68|                 'form'         => $this->createForm(ContactChannelsType::class, [], [
    69|                     'action'        => $route,
    70|                     'channels'      => $this->contactModel->getPreferenceChannels(),
    71|                     'public_view'   => false,
    72|                     'save_button'   => true,
    73|                 ])->createView(),
    74|             ],
    75|             'contentTemplate' => '@MauticLead/Batch/channel.html.twig',
    76|             'passthroughVars' => [
    77|                 'activeLink'    => '#mautic_contact_index',
    78|                 'mauticContent' => 'leadBatch',
    79|                 'route'         => $route,
    80|             ],
    81|         ]);
    82|     }
    83| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Controller/MessageController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-273 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ChannelBundle\Entity\Channel;
     5| use Mautic\ChannelBundle\Model\MessageModel;
     6| use Mautic\CoreBundle\Controller\AbstractStandardFormController;
     7| use Mautic\CoreBundle\Factory\ModelFactory;
     8| use Mautic\CoreBundle\Factory\PageHelperFactoryInterface;
     9| use Mautic\CoreBundle\Helper\Chart\LineChart;
    10| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    11| use Mautic\CoreBundle\Helper\UserHelper;
    12| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    13| use Mautic\CoreBundle\Service\FlashBag;
    14| use Mautic\CoreBundle\Translation\Translator;
    15| use Mautic\FormBundle\Helper\FormFieldHelper;
    16| use Mautic\LeadBundle\Controller\EntityContactsTrait;
    17| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    18| use Symfony\Component\Form\Form;
    19| use Symfony\Component\Form\FormFactoryInterface;
    20| use Symfony\Component\Form\FormInterface;
    21| use Symfony\Component\Form\FormView;
    22| use Symfony\Component\HttpFoundation\Request;
    23| use Symfony\Component\HttpFoundation\RequestStack;
    24| use Symfony\Component\HttpFoundation\Response;
    25| class MessageController extends AbstractStandardFormController
    26| {
    27|     use EntityContactsTrait;
    28|     public function __construct(
    29|         FormFactoryInterface $formFactory,
    30|         FormFieldHelper $fieldHelper,
    31|         ManagerRegistry $doctrine,
    32|         ModelFactory $modelFactory,
    33|         UserHelper $userHelper,
    34|         CoreParametersHelper $coreParametersHelper,
    35|         EventDispatcherInterface $dispatcher,
    36|         Translator $translator,
    37|         FlashBag $flashBag,
    38|         private RequestStack $requestStack,
    39|         CorePermissions $security,
    40|     ) {
    41|         parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    42|     }
    43|     /**
    44|      * @return \Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
    45|      */
    46|     public function batchDeleteAction(Request $request)
    47|     {
    48|         return $this->batchDeleteStandard($request);
    49|     }
    50|     /**
    51|      * @return \Mautic\CoreBundle\Controller\Response|\Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
    52|      */
    53|     public function cloneAction(Request $request, $objectId)
    54|     {
    55|         return $this->cloneStandard($request, $objectId);
    56|     }
    57|     /**
    58|      * @param bool $ignorePost
    59|      *
    60|      * @return \Mautic\CoreBundle\Controller\Response|\Symfony\Component\HttpFoundation\JsonResponse
    61|      */
    62|     public function editAction(Request $request, $objectId, $ignorePost = false)
    63|     {
    64|         return $this->editStandard($request, $objectId, $ignorePost);
    65|     }
    66|     /**
    67|      * @param int $page
    68|      */
    69|     public function indexAction(Request $request, $page = 1): Response
    70|     {
    71|         return $this->indexStandard($request, $page);
    72|     }
    73|     public function newAction(Request $request): Response
    74|     {
    75|         return $this->newStandard($request);
    76|     }
    77|     /**
    78|      * @return array|\Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
    79|      */
    80|     public function viewAction(Request $request, $objectId)
    81|     {
    82|         return $this->viewStandard($request, $objectId, 'message', 'channel');
    83|     }
    84|     /**
    85|      * @return mixed[]
    86|      */
    87|     protected function getViewArguments(array $args, $action): array
    88|     {
    89|         /** @var MessageModel $model */
    90|         $model          = $this->getModel($this->getModelName());
    91|         $viewParameters = [];
    92|         switch ($action) {
    93|             case 'index':
    94|                 $viewParameters = [
    95|                     'headerTitle' => $this->translator->trans('mautic.channel.messages'),
    96|                     'listHeaders' => [
    97|                         [
    98|                             'text'  => 'mautic.core.channels',
    99|                             'class' => 'visible-md visible-lg',
   100|                         ],
   101|                     ],
   102|                     'listItemTemplate'  => '@MauticChannel/Message/list_item.html.twig',
   103|                     'enableCloneButton' => true,
   104|                 ];
   105|                 break;
   106|             case 'view':
   107|                 $message = $args['viewParameters']['item'];
   108|                 $returnUrl = $this->generateUrl(
   109|                     'mautic_message_action',
   110|                     [
   111|                         'objectAction' => 'view',
   112|                         'objectId'     => $message->getId(),
   113|                     ]
   114|                 );
   115|                 [$dateFrom, $dateTo]     = $this->getViewDateRange($this->requestStack->getCurrentRequest(), $message->getId(), $returnUrl, 'local', $dateRangeForm);
   116|                 $chart                   = new LineChart(null, $dateFrom, $dateTo);
   117|                 /** @var Channel[] $channels */
   118|                 $channels        = $model->getChannels();
   119|                 $messageChannels = $message->getChannels();
   120|                 $chart->setDataset(
   121|                     $this->translator->trans('mautic.core.all'),
   122|                     $model->getLeadStatsPost($message->getId(), $dateFrom, $dateTo)
   123|                 );
   124|                 $messagedLeads = [
   125|                     'all' => $this->forward(
   126|                         'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
   127|                         [
   128|                             'objectId'   => $message->getId(),
   129|                             'page'       => $this->requestStack->getCurrentRequest()->getSession()->get('mautic.'.$this->getSessionBase('all').'.contact.page', 1),
   130|                             'ignoreAjax' => true,
   131|                             'channel'    => 'all',
   132|                         ]
   133|                     )->getContent(),
   134|                 ];
   135|                 foreach ($messageChannels as $channel) {
   136|                     if ($channel->isEnabled() && isset($channels[$channel->getChannel()])) {
   137|                         $chart->setDataset(
   138|                             $channels[$channel->getChannel()]['label'],
   139|                             $model->getLeadStatsPost($message->getId(), $dateFrom, $dateTo, $channel->getChannel())
   140|                         );
   141|                         $messagedLeads[$channel->getChannel()] = $this->forward(
   142|                             'Mautic\ChannelBundle\Controller\MessageController::contactsAction',
   143|                             [
   144|                                 'objectId' => $message->getId(),
   145|                                 'page'     => $this->requestStack->getCurrentRequest()->getSession()->get(
   146|                                     'mautic.'.$this->getSessionBase($channel->getChannel()).'.contact.page',
   147|                                     1
   148|                                 ),
   149|                                 'ignoreAjax' => true,
   150|                                 'channel'    => $channel->getChannel(),
   151|                             ]
   152|                         )->getContent();
   153|                     }
   154|                 }
   155|                 $viewParameters = [
   156|                     'channels'        => $channels,
   157|                     'channelContents' => $model->getMessageChannels($message->getId()),
   158|                     'dateRangeForm'   => $dateRangeForm->createView(),
   159|                     'eventCounts'     => $chart->render(),
   160|                     'messagedLeads'   => $messagedLeads,
   161|                 ];
   162|                 break;
   163|             case 'new':
   164|             case 'edit':
   165|                 $viewParameters = [
   166|                     'channels' => $model->getChannels(),
   167|                 ];
   168|                 break;
   169|         }
   170|         $args['viewParameters'] = array_merge($args['viewParameters'], $viewParameters);
   171|         return $args;
   172|     }
   173|     /**
   174|      * @return \Symfony\Component\HttpFoundation\JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse
   175|      */
   176|     public function deleteAction(Request $request, $objectId)
   177|     {
   178|         return $this->deleteStandard($request, $objectId);
   179|     }
   180|     protected function getTemplateBase(): string
   181|     {
   182|         return '@MauticChannel/Message';
   183|     }
   184|     protected function getFormView(FormInterface $form, $view): FormView
   185|     {
   186|         return $form->createView();
   187|     }
   188|     protected function getJsLoadMethodPrefix(): string
   189|     {
   190|         return 'messages';
   191|     }
   192|     protected function getModelName(): string
   193|     {
   194|         return 'channel.message';
   195|     }
   196|     protected function getRouteBase(): string
   197|     {
   198|         return 'message';
   199|     }
   200|     /***
   201|      *
   202|      * @return string
   203|      */
   204|     protected function getSessionBase($objectId = null): string
   205|     {
   206|         return 'message'.(($objectId) ? '.'.$objectId : '');
   207|     }
   208|     protected function getTranslationBase(): string
   209|     {
   210|         return 'mautic.channel.message';
   211|     }
   212|     /**
   213|      * @param int $page
   214|      *
   215|      * @return JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
   216|      */
   217|     public function contactsAction(
   218|         Request $request,
   219|         PageHelperFactoryInterface $pageHelperFactory,
   220|         $objectId,
   221|         $channel,
   222|         $page = 1,
   223|     ) {
   224|         $filter = [];
   225|         if ('all' !== $channel) {
   226|             $returnUrl = $this->generateUrl(
   227|                 'mautic_message_action',
   228|                 [
   229|                     'objectAction' => 'view',
   230|                     'objectId'     => $objectId,
   231|                 ]
   232|             );
   233|             [$dateFrom, $dateTo] = $this->getViewDateRange($request, $objectId, $returnUrl, 'UTC');
   234|             $filter = [
   235|                 'channel' => $channel,
   236|                 [
   237|                     'col'  => 'entity.date_triggered',
   238|                     'expr' => 'between',
   239|                     'val'  => [
   240|                         $dateFrom->format('Y-m-d H:i:s'),
   241|                         $dateTo->format('Y-m-d H:i:s'),
   242|                     ],
   243|                 ],
   244|             ];
   245|         }
   246|         return $this->generateContactsGrid(
   247|             $request,
   248|             $pageHelperFactory,
   249|             $objectId,
   250|             $page,
   251|             'channel:messages:view',
   252|             'message.'.$channel,
   253|             'campaign_lead_event_log',
   254|             $channel,
   255|             null,
   256|             $filter,
   257|             [
   258|                 [
   259|                     'type'       => 'join',
   260|                     'from_alias' => 'entity',
   261|                     'table'      => 'campaign_events',
   262|                     'alias'      => 'event',
   263|                     'condition'  => "entity.event_id = event.id and event.channel = 'channel.message' and event.channel_id = ".(int) $objectId,
   264|                 ],
   265|             ],
   266|             null,
   267|             [
   268|                 'channel' => $channel ?: 'all',
   269|             ],
   270|             '.message-'.$channel
   271|         );
   272|     }
   273| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Entity/Channel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-214 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Entity;
     3| use Doctrine\DBAL\Types\Types;
     4| use Doctrine\ORM\Mapping\ClassMetadata;
     5| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     6| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     7| use Mautic\CoreBundle\Entity\CommonEntity;
     8| use Mautic\CoreBundle\Entity\UuidInterface;
     9| use Mautic\CoreBundle\Entity\UuidTrait;
    10| use Symfony\Component\Serializer\Annotation\Groups;
    11| /**
    12|  * @ApiResource(
    13|  *   attributes={
    14|  *     "security"="false",
    15|  *     "normalization_context"={
    16|  *       "groups"={
    17|  *         "channel:read"
    18|  *        },
    19|  *       "swagger_definition_name"="Read",
    20|  *       "api_included"={"message"}
    21|  *     },
    22|  *     "denormalization_context"={
    23|  *       "groups"={
    24|  *         "channel:write"
    25|  *       },
    26|  *       "swagger_definition_name"="Write"
    27|  *     }
    28|  *   }
    29|  * )
    30|  */
    31| class Channel extends CommonEntity implements UuidInterface
    32| {
    33|     use UuidTrait;
    34|     /**
    35|      * @var int
    36|      */
    37|     private $id;
    38|     /**
    39|      * @var string
    40|      */
    41|     private $channel;
    42|     /**
    43|      * @var int|null
    44|      */
    45|     private $channelId;
    46|     /**
    47|      * @var string
    48|      */
    49|     private $channelName;
    50|     /**
    51|      * @var Message
    52|      */
    53|     private $message;
    54|     /**
    55|      * @var array
    56|      */
    57|     private $properties = [];
    58|     /**
    59|      * @var bool
    60|      */
    61|     private $isEnabled = false;
    62|     public static function loadMetadata(ClassMetadata $metadata): void
    63|     {
    64|         $builder = new ClassMetadataBuilder($metadata);
    65|         $builder->setTable('message_channels')
    66|                 ->addIndex(['channel', 'channel_id'], 'channel_entity_index')
    67|                 ->addIndex(['channel', 'is_enabled'], 'channel_enabled_index')
    68|                 ->addUniqueConstraint(['message_id', 'channel'], 'channel_index');
    69|         $builder
    70|             ->addId()
    71|             ->addField('channel', 'string')
    72|             ->addNamedField('channelId', 'integer', 'channel_id', true)
    73|             ->addField('properties', Types::JSON)
    74|             ->createField('isEnabled', 'boolean')
    75|                 ->columnName('is_enabled')
    76|                 ->build();
    77|         $builder->createManyToOne('message', Message::class)
    78|                 ->addJoinColumn('message_id', 'id', false, false, 'CASCADE')
    79|                 ->inversedBy('channels')
    80|                 ->build();
    81|         static::addUuidField($builder);
    82|     }
    83|     /**
    84|      * Prepares the metadata for API usage.
    85|      */
    86|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
    87|     {
    88|         $metadata->setGroupPrefix('messageChannel')
    89|             ->addListProperties(
    90|                 [
    91|                     'id',
    92|                     'channel',
    93|                     'channelId',
    94|                     'channelName',
    95|                     'isEnabled',
    96|                 ]
    97|             )
    98|             ->addProperties(
    99|                 [
   100|                     'properties',
   101|                     'message',
   102|                 ]
   103|             )
   104|             ->build();
   105|     }
   106|     /**
   107|      * @return int
   108|      */
   109|     public function getId()
   110|     {
   111|         return $this->id;
   112|     }
   113|     /**
   114|      * @return string
   115|      */
   116|     public function getChannel()
   117|     {
   118|         return $this->channel;
   119|     }
   120|     /**
   121|      * @param string $channel
   122|      *
   123|      * @return Channel
   124|      */
   125|     public function setChannel($channel)
   126|     {
   127|         $this->channel = $channel;
   128|         return $this;
   129|     }
   130|     /**
   131|      * @return int
   132|      */
   133|     public function getChannelId()
   134|     {
   135|         return $this->channelId;
   136|     }
   137|     /**
   138|      * @param int $channelId
   139|      *
   140|      * @return Channel
   141|      */
   142|     public function setChannelId($channelId)
   143|     {
   144|         if (empty($channelId)) {
   145|             $channelId = null;
   146|         }
   147|         $this->channelId = $channelId;
   148|         return $this;
   149|     }
   150|     /**
   151|      * @return string
   152|      */
   153|     public function getChannelName()
   154|     {
   155|         return $this->channelName;
   156|     }
   157|     /**
   158|      * @param string $channelName
   159|      *
   160|      * @return Channel
   161|      */
   162|     public function setChannelName($channelName)
   163|     {
   164|         $this->channelName = $channelName;
   165|         return $this;
   166|     }
   167|     /**
   168|      * @return Message
   169|      */
   170|     public function getMessage()
   171|     {
   172|         return $this->message;
   173|     }
   174|     /**
   175|      * @return Channel
   176|      */
   177|     public function setMessage(Message $message)
   178|     {
   179|         $this->message = $message;
   180|         return $this;
   181|     }
   182|     /**
   183|      * @return array
   184|      */
   185|     public function getProperties()
   186|     {
   187|         return $this->properties;
   188|     }
   189|     /**
   190|      * @return Channel
   191|      */
   192|     public function setProperties(array $properties)
   193|     {
   194|         $this->properties = $properties;
   195|         return $this;
   196|     }
   197|     /**
   198|      * @return bool
   199|      */
   200|     public function isEnabled()
   201|     {
   202|         return $this->isEnabled;
   203|     }
   204|     /**
   205|      * @param bool $isEnabled
   206|      *
   207|      * @return Channel
   208|      */
   209|     public function setIsEnabled($isEnabled)
   210|     {
   211|         $this->isEnabled = $isEnabled;
   212|         return $this;
   213|     }
   214| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Entity/Message.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-249 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Entity;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Doctrine\ORM\Mapping\ClassMetadata;
     5| use Mautic\ApiBundle\Serializer\Driver\ApiMetadataDriver;
     6| use Mautic\CategoryBundle\Entity\Category;
     7| use Mautic\CoreBundle\Doctrine\Mapping\ClassMetadataBuilder;
     8| use Mautic\CoreBundle\Entity\FormEntity;
     9| use Mautic\CoreBundle\Entity\UuidInterface;
    10| use Mautic\CoreBundle\Entity\UuidTrait;
    11| use Symfony\Component\Serializer\Annotation\Groups;
    12| use Symfony\Component\Validator\Constraints\NotBlank;
    13| use Symfony\Component\Validator\Mapping\ClassMetadata as ValidationClassMetadata;
    14| /**
    15|  * @ApiResource(
    16|  *   attributes={
    17|  *     "security"="false",
    18|  *     "normalization_context"={
    19|  *       "groups"={
    20|  *         "message:read"
    21|  *        },
    22|  *       "swagger_definition_name"="Read",
    23|  *       "api_included"={"category", "channels"}
    24|  *     },
    25|  *     "denormalization_context"={
    26|  *       "groups"={
    27|  *         "message:write"
    28|  *       },
    29|  *       "swagger_definition_name"="Write"
    30|  *     }
    31|  *   }
    32|  * )
    33|  */
    34| class Message extends FormEntity implements UuidInterface
    35| {
    36|     use UuidTrait;
    37|     /**
    38|      * @var ?int
    39|      */
    40|     private $id;
    41|     /**
    42|      * @var string
    43|      */
    44|     private $name;
    45|     /**
    46|      * @var ?string
    47|      */
    48|     private $description;
    49|     /**
    50|      * @var ?\DateTimeInterface
    51|      */
    52|     private $publishUp;
    53|     /**
    54|      * @var ?\DateTimeInterface
    55|      */
    56|     private $publishDown;
    57|     /**
    58|      * @var ?Category
    59|      */
    60|     private $category;
    61|     /**
    62|      * @var ArrayCollection<int,Channel>
    63|      */
    64|     private $channels;
    65|     public function __clone()
    66|     {
    67|         $this->id = null;
    68|     }
    69|     public static function loadMetadata(ClassMetadata $metadata): void
    70|     {
    71|         $builder = new ClassMetadataBuilder($metadata);
    72|         $builder->setTable('messages')
    73|                 ->setCustomRepositoryClass(MessageRepository::class)
    74|                 ->addIndex(['date_added'], 'date_message_added');
    75|         $builder
    76|             ->addIdColumns()
    77|             ->addPublishDates()
    78|             ->addCategory();
    79|         $builder->createOneToMany('channels', Channel::class)
    80|             ->setIndexBy('channel')
    81|             ->orphanRemoval()
    82|             ->mappedBy('message')
    83|             ->cascadeMerge()
    84|             ->cascadePersist()
    85|             ->cascadeDetach()
    86|             ->build();
    87|         static::addUuidField($builder);
    88|     }
    89|     public static function loadValidatorMetadata(ValidationClassMetadata $metadata): void
    90|     {
    91|         $metadata->addPropertyConstraint('name', new NotBlank([
    92|             'message' => 'mautic.core.name.required',
    93|         ]));
    94|     }
    95|     public static function loadApiMetadata(ApiMetadataDriver $metadata): void
    96|     {
    97|         $metadata->setGroupPrefix('message')
    98|             ->addListProperties(
    99|                 [
   100|                     'id',
   101|                     'name',
   102|                     'description',
   103|                 ]
   104|             )
   105|             ->addProperties(
   106|                 [
   107|                     'publishUp',
   108|                     'publishDown',
   109|                     'channels',
   110|                     'category',
   111|                 ]
   112|             )
   113|             ->build();
   114|     }
   115|     public function __construct()
   116|     {
   117|         $this->channels = new ArrayCollection();
   118|     }
   119|     /**
   120|      * @return ?int
   121|      */
   122|     public function getId()
   123|     {
   124|         return $this->id;
   125|     }
   126|     /**
   127|      * @return ?string
   128|      */
   129|     public function getName()
   130|     {
   131|         return $this->name;
   132|     }
   133|     /**
   134|      * @param ?string $name
   135|      *
   136|      * @return Message
   137|      */
   138|     public function setName($name)
   139|     {
   140|         $this->isChanged('name', $name);
   141|         $this->name = $name;
   142|         return $this;
   143|     }
   144|     /**
   145|      * @return ?string
   146|      */
   147|     public function getDescription()
   148|     {
   149|         return $this->description;
   150|     }
   151|     /**
   152|      * @param ?string $description
   153|      *
   154|      * @return Message
   155|      */
   156|     public function setDescription($description)
   157|     {
   158|         $this->isChanged('description', $description);
   159|         $this->description = $description;
   160|         return $this;
   161|     }
   162|     /**
   163|      * @return ?\DateTimeInterface
   164|      */
   165|     public function getPublishUp()
   166|     {
   167|         return $this->publishUp;
   168|     }
   169|     /**
   170|      * @param ?\DateTime $publishUp
   171|      *
   172|      * @return Message
   173|      */
   174|     public function setPublishUp($publishUp)
   175|     {
   176|         $this->isChanged('publishUp', $publishUp);
   177|         $this->publishUp = $publishUp;
   178|         return $this;
   179|     }
   180|     /**
   181|      * @return ?\DateTimeInterface
   182|      */
   183|     public function getPublishDown()
   184|     {
   185|         return $this->publishDown;
   186|     }
   187|     /**
   188|      * @param ?\DateTime $publishDown
   189|      *
   190|      * @return Message
   191|      */
   192|     public function setPublishDown($publishDown)
   193|     {
   194|         $this->isChanged('publishDown', $publishDown);
   195|         $this->publishDown = $publishDown;
   196|         return $this;
   197|     }
   198|     /**
   199|      * @return ?Category
   200|      */
   201|     public function getCategory()
   202|     {
   203|         return $this->category;
   204|     }
   205|     /**
   206|      * @param ?Category $category
   207|      *
   208|      * @return Message
   209|      */
   210|     public function setCategory($category)
   211|     {
   212|         $this->isChanged('category', $category);
   213|         $this->category = $category;
   214|         return $this;
   215|     }
   216|     /**
   217|      * @return ArrayCollection<int,Channel>
   218|      */
   219|     public function getChannels()
   220|     {
   221|         return $this->channels;
   222|     }
   223|     /**
   224|      * @param ArrayCollection<int,Channel> $channels
   225|      *
   226|      * @return Message
   227|      */
   228|     public function setChannels($channels)
   229|     {
   230|         $this->isChanged('channels', $channels);
   231|         $this->channels = $channels;
   232|         return $this;
   233|     }
   234|     public function addChannel(Channel $channel): void
   235|     {
   236|         if (!$this->channels->contains($channel)) {
   237|             $channel->setMessage($this);
   238|             $this->isChanged('channels', $channel);
   239|             $this->channels[$channel->getChannel()] = $channel;
   240|         }
   241|     }
   242|     public function removeChannel(Channel $channel): void
   243|     {
   244|         if ($channel->getId()) {
   245|             $this->isChanged('channels', $channel->getId());
   246|         }
   247|         $this->channels->removeElement($channel);
   248|     }
   249| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Entity/MessageQueueRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-97 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Entity;
     3| use Doctrine\Common\Collections\Order;
     4| use Doctrine\DBAL\ArrayParameterType;
     5| use Mautic\CoreBundle\Entity\CommonRepository;
     6| use Mautic\LeadBundle\Entity\TimelineTrait;
     7| /**
     8|  * @extends CommonRepository<MessageQueue>
     9|  */
    10| class MessageQueueRepository extends CommonRepository
    11| {
    12|     use TimelineTrait;
    13|     public function findMessage($channel, $channelId, $leadId)
    14|     {
    15|         $results = $this->createQueryBuilder('mq')
    16|             ->where('IDENTITY(mq.lead) = :leadId')
    17|             ->andWhere('mq.channel = :channel')
    18|             ->andWhere('mq.channelId = :channelId')
    19|             ->setParameter('leadId', $leadId)
    20|             ->setParameter('channel', $channel)
    21|             ->setParameter('channelId', $channelId)
    22|             ->getQuery()
    23|             ->getResult();
    24|         return ($results) ? $results[0] : null;
    25|     }
    26|     /**
    27|      * @return array<int, MessageQueue>
    28|      */
    29|     public function getQueuedMessages($limit, $processStarted, $channel = null, $channelId = null)
    30|     {
    31|         $q = $this->createQueryBuilder('mq');
    32|         $q->where($q->expr()->eq('mq.success', ':success'))
    33|             ->andWhere($q->expr()->lt('mq.attempts', 'mq.maxAttempts'))
    34|             ->andWhere('mq.lastAttempt is null or mq.lastAttempt < :processStarted')
    35|             ->andWhere('mq.scheduledDate <= :processStarted')
    36|             ->setParameter('success', false, 'boolean')
    37|             ->setParameter('processStarted', $processStarted)
    38|             ->indexBy('mq', 'mq.id');
    39|         $q->orderBy('mq.priority, mq.scheduledDate', Order::Ascending->value);
    40|         if ($limit) {
    41|             $q->setMaxResults((int) $limit);
    42|         }
    43|         if ($channel) {
    44|             $q->andWhere($q->expr()->eq('mq.channel', ':channel'))
    45|                 ->setParameter('channel', $channel);
    46|             if ($channelId) {
    47|                 $q->andWhere($q->expr()->eq('mq.channelId', (int) $channelId));
    48|             }
    49|         }
    50|         return $q->getQuery()->getResult();
    51|     }
    52|     public function getQueuedChannelCount($channel, array $ids = null): int
    53|     {
    54|         $q = $this->getEntityManager()->getConnection()->createQueryBuilder();
    55|         $expr = $q->expr()->and(
    56|             $q->expr()->eq($this->getTableAlias().'.channel', ':channel'),
    57|             $q->expr()->neq($this->getTableAlias().'.status', ':status')
    58|         );
    59|         if (!empty($ids)) {
    60|             $expr = $expr->with(
    61|                 $q->expr()->in($this->getTableAlias().'.channel_id', $ids)
    62|             );
    63|         }
    64|         return (int) $q->select('count(*)')
    65|             ->from(MAUTIC_TABLE_PREFIX.'message_queue', $this->getTableAlias())
    66|             ->where($expr)
    67|             ->setParameter('channel', $channel)
    68|             ->setParameter('status', MessageQueue::STATUS_SENT)
    69|             ->setParameter('ids', $ids, ArrayParameterType::INTEGER)
    70|             ->executeQuery()
    71|             ->fetchOne();
    72|     }
    73|     /**
    74|      * Get a lead's point log.
    75|      *
    76|      * @param int|null $leadId
    77|      *
    78|      * @return array
    79|      */
    80|     public function getLeadTimelineEvents($leadId = null, array $options = [])
    81|     {
    82|         $query = $this->getEntityManager()->getConnection()->createQueryBuilder()
    83|             ->from(MAUTIC_TABLE_PREFIX.'message_queue', 'mq')
    84|             ->select('mq.id, mq.lead_id, mq.channel as channelName, mq.channel_id as channelId,
    85|             mq.priority as priority, mq.attempts, mq.success, mq.status, mq.date_published as dateAdded,
    86|             mq.scheduled_date as scheduledDate, mq.last_attempt as lastAttempt, mq.date_sent as dateSent');
    87|         if ($leadId) {
    88|             $query->where('mq.lead_id = '.(int) $leadId);
    89|         }
    90|         if (isset($options['search']) && $options['search']) {
    91|             $query->andWhere($query->expr()->or(
    92|                 $query->expr()->like('mq.channel', $query->expr()->literal('%'.$options['search'].'%'))
    93|             ));
    94|         }
    95|         return $this->getTimelineResults($query, $options, 'mq.channel', 'mq.date_published', [], ['dateAdded'], null, 'mq.id');
    96|     }
    97| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Event/ChannelBroadcastEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-161 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Event;
     3| use Symfony\Component\Console\Output\OutputInterface;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| class ChannelBroadcastEvent extends Event
     6| {
     7|     /**
     8|      * Number of contacts successfully processed and/or failed per channel.
     9|      *
    10|      * @var array
    11|      */
    12|     protected $results = [];
    13|     /**
    14|      * Min contact ID filter can be used for process parallelization.
    15|      *
    16|      * @var int
    17|      */
    18|     private $minContactIdFilter;
    19|     /**
    20|      * Max contact ID filter can be used for process parallelization.
    21|      *
    22|      * @var int
    23|      */
    24|     private $maxContactIdFilter;
    25|     /**
    26|      * How many contacts to load from the database.
    27|      */
    28|     private int $limit = 100;
    29|     /**
    30|      * How big batches to use to actually send.
    31|      */
    32|     private int $batch = 50;
    33|     private ?int $maxThreads = null;
    34|     private ?int $threadId = null;
    35|     public function __construct(
    36|         /**
    37|          * Specific channel.
    38|          */
    39|         protected ?string $channel,
    40|         /**
    41|          * Specific ID of a specific channel.
    42|          */
    43|         protected string|int|null $id,
    44|         protected OutputInterface $output,
    45|     ) {
    46|     }
    47|     /**
    48|      * @return mixed
    49|      */
    50|     public function getChannel()
    51|     {
    52|         return $this->channel;
    53|     }
    54|     /**
    55|      * @return mixed
    56|      */
    57|     public function getId()
    58|     {
    59|         return $this->id;
    60|     }
    61|     /**
    62|      * @param string $channelLabel
    63|      * @param int    $successCount
    64|      * @param int    $failedCount
    65|      */
    66|     public function setResults($channelLabel, $successCount, $failedCount = 0, array $failedRecipientsByList = []): void
    67|     {
    68|         $this->results[$channelLabel] = [
    69|             'success'                => (int) $successCount,
    70|             'failed'                 => (int) $failedCount,
    71|             'failedRecipientsByList' => $failedRecipientsByList,
    72|         ];
    73|     }
    74|     /**
    75|      * @return array
    76|      */
    77|     public function getResults()
    78|     {
    79|         return $this->results;
    80|     }
    81|     public function checkContext($channel): bool
    82|     {
    83|         if ($this->channel && $this->channel !== $channel) {
    84|             return false;
    85|         }
    86|         return true;
    87|     }
    88|     /**
    89|      * @return OutputInterface
    90|      */
    91|     public function getOutput()
    92|     {
    93|         return $this->output;
    94|     }
    95|     /**
    96|      * @param int $minContactIdFilter
    97|      */
    98|     public function setMinContactIdFilter($minContactIdFilter): void
    99|     {
   100|         $this->minContactIdFilter = $minContactIdFilter;
   101|     }
   102|     /**
   103|      * @return int|null
   104|      */
   105|     public function getMinContactIdFilter()
   106|     {
   107|         return $this->minContactIdFilter;
   108|     }
   109|     /**
   110|      * @param int $maxContactIdFilter
   111|      */
   112|     public function setMaxContactIdFilter($maxContactIdFilter): void
   113|     {
   114|         $this->maxContactIdFilter = $maxContactIdFilter;
   115|     }
   116|     /**
   117|      * @return int|null
   118|      */
   119|     public function getMaxContactIdFilter()
   120|     {
   121|         return $this->maxContactIdFilter;
   122|     }
   123|     /**
   124|      * @param int $limit
   125|      */
   126|     public function setLimit($limit): void
   127|     {
   128|         $this->limit = $limit;
   129|     }
   130|     public function getLimit(): int
   131|     {
   132|         return $this->limit;
   133|     }
   134|     /**
   135|      * @param int $batch
   136|      */
   137|     public function setBatch($batch): void
   138|     {
   139|         $this->batch = $batch;
   140|     }
   141|     public function getBatch(): int
   142|     {
   143|         return $this->batch;
   144|     }
   145|     public function getMaxThreads(): ?int
   146|     {
   147|         return $this->maxThreads;
   148|     }
   149|     public function setMaxThreads(?int $maxThreads): void
   150|     {
   151|         $this->maxThreads = $maxThreads;
   152|     }
   153|     public function getThreadId(): ?int
   154|     {
   155|         return $this->threadId;
   156|     }
   157|     public function setThreadId(?int $threadId): void
   158|     {
   159|         $this->threadId = $threadId;
   160|     }
   161| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Event/MessageQueueBatchProcessEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Event;
     3| use Mautic\ChannelBundle\Entity\MessageQueue;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| class MessageQueueBatchProcessEvent extends Event
     6| {
     7|     /**
     8|      * @param MessageQueue[] $messages
     9|      */
    10|     public function __construct(
    11|         private array $messages,
    12|         private $channel,
    13|         private $channelId,
    14|     ) {
    15|     }
    16|     public function checkContext($channel): bool
    17|     {
    18|         return $channel === $this->channel;
    19|     }
    20|     /**
    21|      * @return array
    22|      */
    23|     public function getMessages()
    24|     {
    25|         return $this->messages;
    26|     }
    27|     /**
    28|      * @return mixed
    29|      */
    30|     public function getChannel()
    31|     {
    32|         return $this->channel;
    33|     }
    34|     /**
    35|      * @return mixed
    36|      */
    37|     public function getChannelId()
    38|     {
    39|         return $this->channelId;
    40|     }
    41| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/ButtonSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\EventListener;
     3| use Mautic\CoreBundle\CoreEvents;
     4| use Mautic\CoreBundle\Event\CustomButtonEvent;
     5| use Mautic\CoreBundle\Twig\Helper\ButtonHelper;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| use Symfony\Component\Routing\RouterInterface;
     8| use Symfony\Contracts\Translation\TranslatorInterface;
     9| class ButtonSubscriber implements EventSubscriberInterface
    10| {
    11|     public function __construct(
    12|         private RouterInterface $router,
    13|         private TranslatorInterface $translator,
    14|     ) {
    15|     }
    16|     public static function getSubscribedEvents(): array
    17|     {
    18|         return [
    19|             CoreEvents::VIEW_INJECT_CUSTOM_BUTTONS => ['injectContactBulkButtons', 0],
    20|         ];
    21|     }
    22|     public function injectContactBulkButtons(CustomButtonEvent $event): void
    23|     {
    24|         if (str_starts_with($event->getRoute(), 'mautic_contact_')) {
    25|             $event->addButton(
    26|                 [
    27|                     'attr' => [
    28|                         'class'       => 'btn btn-ghost btn-sm btn-nospin',
    29|                         'data-toggle' => 'ajaxmodal',
    30|                         'data-target' => '#MauticSharedModal',
    31|                         'href'        => $this->router->generate('mautic_channel_batch_contact_view'),
    32|                         'data-header' => $this->translator->trans('mautic.lead.batch.channels'),
    33|                     ],
    34|                     'btnText'   => $this->translator->trans('mautic.lead.batch.channels'),
    35|                     'iconClass' => 'ri-remote-control-line',
    36|                 ],
    37|                 ButtonHelper::LOCATION_BULK_ACTIONS
    38|             );
    39|         }
    40|     }
    41| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/CampaignSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-186 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ChannelBundle\EventListener;
     4| use Doctrine\Common\Collections\ArrayCollection;
     5| use Mautic\CampaignBundle\CampaignEvents;
     6| use Mautic\CampaignBundle\Entity\Event;
     7| use Mautic\CampaignBundle\Entity\LeadEventLog;
     8| use Mautic\CampaignBundle\Event\CampaignBuilderEvent;
     9| use Mautic\CampaignBundle\Event\PendingEvent;
    10| use Mautic\CampaignBundle\EventCollector\Accessor\Event\ActionAccessor;
    11| use Mautic\CampaignBundle\EventCollector\EventCollector;
    12| use Mautic\CampaignBundle\Executioner\Dispatcher\ActionDispatcher;
    13| use Mautic\CampaignBundle\Executioner\Exception\NoContactsFoundException;
    14| use Mautic\ChannelBundle\ChannelEvents;
    15| use Mautic\ChannelBundle\Form\Type\MessageSendType;
    16| use Mautic\ChannelBundle\Model\MessageModel;
    17| use Mautic\ChannelBundle\PreferenceBuilder\PreferenceBuilder;
    18| use Psr\Log\LoggerInterface;
    19| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    20| use Symfony\Contracts\Translation\TranslatorInterface;
    21| class CampaignSubscriber implements EventSubscriberInterface
    22| {
    23|     private ?Event $pseudoEvent = null;
    24|     private ?ArrayCollection $mmLogs = null;
    25|     /**
    26|      * @var mixed[]
    27|      */
    28|     private array $messageChannels = [];
    29|     public function __construct(
    30|         private MessageModel $messageModel,
    31|         private ActionDispatcher $actionDispatcher,
    32|         private EventCollector $eventCollector,
    33|         private LoggerInterface $logger,
    34|         private TranslatorInterface $translator,
    35|     ) {
    36|     }
    37|     public static function getSubscribedEvents(): array
    38|     {
    39|         return [
    40|             CampaignEvents::CAMPAIGN_ON_BUILD       => ['onCampaignBuild', 0],
    41|             ChannelEvents::ON_CAMPAIGN_BATCH_ACTION => ['onCampaignTriggerAction', 0],
    42|         ];
    43|     }
    44|     public function onCampaignBuild(CampaignBuilderEvent $event): void
    45|     {
    46|         $channels  = $this->messageModel->getChannels();
    47|         $decisions = [];
    48|         foreach ($channels as $channel) {
    49|             if (isset($channel['campaignDecisionsSupported'])) {
    50|                 $decisions = $decisions + $channel['campaignDecisionsSupported'];
    51|             }
    52|         }
    53|         $action = [
    54|             'label'                  => 'mautic.channel.message.send.marketing.message',
    55|             'description'            => 'mautic.channel.message.send.marketing.message.descr',
    56|             'batchEventName'         => ChannelEvents::ON_CAMPAIGN_BATCH_ACTION,
    57|             'formType'               => MessageSendType::class,
    58|             'channel'                => 'channel.message',
    59|             'channelIdField'         => 'marketingMessage',
    60|             'connectionRestrictions' => [
    61|                 'target' => [
    62|                     'decision' => $decisions,
    63|                 ],
    64|             ],
    65|             'timelineTemplate'       => '@MauticChannel/SubscribedEvents/Timeline/index.html.twig',
    66|             'timelineTemplateVars'   => [
    67|                 'messageSettings' => $channels,
    68|             ],
    69|         ];
    70|         $event->addAction('message.send', $action);
    71|     }
    72|     /**
    73|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
    74|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
    75|      * @throws \ReflectionException
    76|      */
    77|     public function onCampaignTriggerAction(PendingEvent $pendingEvent): void
    78|     {
    79|         $this->pseudoEvent = clone $pendingEvent->getEvent();
    80|         $this->pseudoEvent->setCampaign($pendingEvent->getEvent()->getCampaign());
    81|         $this->mmLogs    = $pendingEvent->getPending();
    82|         $campaignEvent   = $pendingEvent->getEvent();
    83|         $properties      = $campaignEvent->getProperties();
    84|         $messageSettings = $this->messageModel->getChannels();
    85|         $id              = (int) $properties['marketingMessage'];
    86|         $pendingEvent->setChannel('channel.message', $id);
    87|         if (!isset($this->messageChannels[$id])) {
    88|             $this->messageChannels[$id] = $this->messageModel->getMessageChannels($id);
    89|         }
    90|         $preferenceBuilder = new PreferenceBuilder($this->mmLogs, $this->pseudoEvent, $this->messageChannels[$id], $this->logger);
    91|         $priority           = 1;
    92|         $channelPreferences = $preferenceBuilder->getChannelPreferences();
    93|         while ($priority <= count($this->messageChannels[$id])) {
    94|             foreach ($channelPreferences as $channel => $preferences) {
    95|                 if (!isset($messageSettings[$channel]['campaignAction'])) {
    96|                     continue;
    97|                 }
    98|                 $channelLogs = $preferences->getLogsByPriority($priority);
    99|                 if (!$channelLogs->count()) {
   100|                     continue;
   101|                 }
   102|                 $this->pseudoEvent->setEventType(Event::TYPE_ACTION)
   103|                     ->setType($messageSettings[$channel]['campaignAction']);
   104|                 $successfullyExecuted = $this->sendChannelMessage($channelLogs, $channel, $this->messageChannels[$id][$channel]);
   105|                 $this->passExecutedLogs($pendingEvent, $successfullyExecuted, $preferenceBuilder);
   106|             }
   107|             ++$priority;
   108|         }
   109|         $this->removeSuccessfulFromFailures($pendingEvent);
   110|         $pendingEvent->failRemainingPending($this->translator->trans('mautic.channel.message.failed'));
   111|     }
   112|     /**
   113|      * @param string $channel
   114|      *
   115|      * @return bool|ArrayCollection
   116|      *
   117|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogNotProcessedException
   118|      * @throws \Mautic\CampaignBundle\Executioner\Dispatcher\Exception\LogPassedAndFailedException
   119|      * @throws \ReflectionException
   120|      */
   121|     private function sendChannelMessage(ArrayCollection $logs, $channel, array $messageChannel)
   122|     {
   123|         /** @var ActionAccessor $config */
   124|         $config = $this->eventCollector->getEventConfig($this->pseudoEvent);
   125|         if ($channelIdField = $config->getChannelIdField()) {
   126|             $messageChannel['properties'][$channelIdField] = $messageChannel['channel_id'];
   127|         }
   128|         $this->pseudoEvent->setProperties($messageChannel['properties']);
   129|         $pendingEvent = new PendingEvent($config, $this->pseudoEvent, $logs);
   130|         $pendingEvent->setChannel('campaign.event', $messageChannel['channel_id']);
   131|         $this->actionDispatcher->dispatchEvent(
   132|             $config,
   133|             $this->pseudoEvent,
   134|             $logs,
   135|             $pendingEvent
   136|         );
   137|         $this->recordChannelMetadata($pendingEvent, $channel);
   138|         $success = $pendingEvent->getSuccessful();
   139|         $this->removePsuedoFailures($success);
   140|         unset($pendingEvent);
   141|         return $success;
   142|     }
   143|     private function passExecutedLogs(PendingEvent $pendingEvent, ArrayCollection $logs, PreferenceBuilder $channelPreferences): void
   144|     {
   145|         /** @var LeadEventLog $log */
   146|         foreach ($logs as $log) {
   147|             $channelPreferences->removeLogFromAllChannels($log);
   148|             $mmLog = $pendingEvent->findLogByContactId($log->getLead()->getId());
   149|             $pendingEvent->pass($mmLog);
   150|         }
   151|     }
   152|     /**
   153|      * @param ArrayCollection<int,LeadEventLog> $success
   154|      */
   155|     private function removePsuedoFailures(ArrayCollection $success): void
   156|     {
   157|         foreach ($success as $key => $log) {
   158|             if (!empty($log->getMetadata()['failed'])) {
   159|                 $success->remove($key);
   160|             }
   161|         }
   162|     }
   163|     private function removeSuccessfulFromFailures(PendingEvent $pendingEvent): void
   164|     {
   165|         $successfulKeys = $pendingEvent->getSuccessful()->getKeys();
   166|         foreach ($successfulKeys as $key) {
   167|             if ($pendingEvent->getFailures()->containsKey($key)) {
   168|                 $pendingEvent->getFailures()->remove($key);
   169|             }
   170|         }
   171|     }
   172|     private function recordChannelMetadata(PendingEvent $pendingEvent, string $channel): void
   173|     {
   174|         /** @var LeadEventLog $log */
   175|         foreach ($this->mmLogs as $log) {
   176|             try {
   177|                 $channelLog = $pendingEvent->findLogByContactId($log->getLead()->getId());
   178|                 if ($metadata = $channelLog->getMetadata()) {
   179|                     $log->appendToMetadata([$channel => $metadata]);
   180|                 }
   181|             } catch (NoContactsFoundException) {
   182|                 continue;
   183|             }
   184|         }
   185|     }
   186| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/LeadSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\EventListener;
     3| use Mautic\ChannelBundle\Entity\MessageQueueRepository;
     4| use Mautic\LeadBundle\Event\LeadTimelineEvent;
     5| use Mautic\LeadBundle\LeadEvents;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| use Symfony\Component\Routing\RouterInterface;
     8| use Symfony\Contracts\Translation\TranslatorInterface;
     9| class LeadSubscriber implements EventSubscriberInterface
    10| {
    11|     public function __construct(
    12|         private TranslatorInterface $translator,
    13|         private RouterInterface $router,
    14|         private MessageQueueRepository $messageQueueRepository,
    15|     ) {
    16|     }
    17|     public static function getSubscribedEvents(): array
    18|     {
    19|         return [
    20|             LeadEvents::TIMELINE_ON_GENERATE => ['onTimelineGenerate', 0],
    21|         ];
    22|     }
    23|     /**
    24|      * Compile events for the lead timeline.
    25|      */
    26|     public function onTimelineGenerate(LeadTimelineEvent $event): void
    27|     {
    28|         $eventTypeKey  = 'message.queue';
    29|         $eventTypeName = $this->translator->trans('mautic.message.queue');
    30|         $event->addEventType($eventTypeKey, $eventTypeName);
    31|         $event->addSerializerGroup('messageQueueList');
    32|         $label = $this->translator->trans('mautic.queued.channel');
    33|         if (!$event->isApplicable($eventTypeKey)) {
    34|             return;
    35|         }
    36|         $logs = $this->messageQueueRepository->getLeadTimelineEvents($event->getLeadId(), $event->getQueryOptions());
    37|         $event->addToCounter($eventTypeKey, $logs);
    38|         if (!$event->isEngagementCount()) {
    39|             foreach ($logs['results'] as $log) {
    40|                 $eventName = [
    41|                     'label' => $label.$log['channelName'].' '.$log['channelId'],
    42|                     'href'  => $this->router->generate('mautic_'.$log['channelName'].'_action', ['objectAction' => 'view', 'objectId' => $log['channelId']]),
    43|                 ];
    44|                 $event->addEvent(
    45|                     [
    46|                         'eventId'    => $eventTypeKey.$log['id'],
    47|                         'event'      => $eventTypeKey,
    48|                         'eventLabel' => $eventName,
    49|                         'eventType'  => $eventTypeName,
    50|                         'timestamp'  => $log['dateAdded'],
    51|                         'extra'      => [
    52|                             'log' => $log,
    53|                         ],
    54|                         'contentTemplate' => '@MauticChannel/SubscribedEvents/Timeline/queued_messages.html.twig',
    55|                         'icon'            => 'ri-question-answer-line',
    56|                         'contactId'       => $log['lead_id'],
    57|                     ]
    58|                 );
    59|             }
    60|         }
    61|     }
    62| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/MessageSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\EventListener;
     3| use Mautic\ChannelBundle\ChannelEvents;
     4| use Mautic\ChannelBundle\Event\MessageEvent;
     5| use Mautic\CoreBundle\Model\AuditLogModel;
     6| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     7| class MessageSubscriber implements EventSubscriberInterface
     8| {
     9|     public function __construct(
    10|         private AuditLogModel $auditLogModel,
    11|     ) {
    12|     }
    13|     public static function getSubscribedEvents(): array
    14|     {
    15|         return [
    16|             ChannelEvents::MESSAGE_POST_SAVE   => ['onPostSave', 0],
    17|             ChannelEvents::MESSAGE_POST_DELETE => ['onDelete', 0],
    18|         ];
    19|     }
    20|     /**
    21|      * Add an entry to the audit log.
    22|      */
    23|     public function onPostSave(MessageEvent $event): void
    24|     {
    25|         $entity = $event->getMessage();
    26|         if ($details = $event->getChanges()) {
    27|             $log = [
    28|                 'bundle'   => 'channel',
    29|                 'object'   => 'message',
    30|                 'objectId' => $entity->getId(),
    31|                 'action'   => ($event->isNew()) ? 'create' : 'update',
    32|                 'details'  => $details,
    33|             ];
    34|             $this->auditLogModel->writeToLog($log);
    35|         }
    36|     }
    37|     /**
    38|      * Add a delete entry to the audit log.
    39|      */
    40|     public function onDelete(MessageEvent $event): void
    41|     {
    42|         $entity = $event->getMessage();
    43|         $log    = [
    44|             'bundle'   => 'channel',
    45|             'object'   => 'message',
    46|             'objectId' => $entity->deletedId,
    47|             'action'   => 'delete',
    48|             'details'  => ['name' => $entity->getName()],
    49|         ];
    50|         $this->auditLogModel->writeToLog($log);
    51|     }
    52| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/ReportSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\EventListener;
     3| use Mautic\LeadBundle\Model\CompanyReportData;
     4| use Mautic\ReportBundle\Event\ReportBuilderEvent;
     5| use Mautic\ReportBundle\Event\ReportDataEvent;
     6| use Mautic\ReportBundle\Event\ReportGeneratorEvent;
     7| use Mautic\ReportBundle\ReportEvents;
     8| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
     9| use Symfony\Component\Routing\RouterInterface;
    10| class ReportSubscriber implements EventSubscriberInterface
    11| {
    12|     public const CONTEXT_MESSAGE_CHANNEL = 'message.channel';
    13|     public function __construct(
    14|         private CompanyReportData $companyReportData,
    15|         private RouterInterface $router,
    16|     ) {
    17|     }
    18|     public static function getSubscribedEvents(): array
    19|     {
    20|         return [
    21|             ReportEvents::REPORT_ON_BUILD    => ['onReportBuilder', 0],
    22|             ReportEvents::REPORT_ON_GENERATE => ['onReportGenerate', 0],
    23|             ReportEvents::REPORT_ON_DISPLAY  => ['onReportDisplay', 0],
    24|         ];
    25|     }
    26|     /**
    27|      * Add available tables and columns to the report builder lookup.
    28|      */
    29|     public function onReportBuilder(ReportBuilderEvent $event): void
    30|     {
    31|         if (!$event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
    32|             return;
    33|         }
    34|         $prefix  = 'mq.';
    35|         $columns = [
    36|             $prefix.'channel' => [
    37|                 'label' => 'mautic.message.queue.report.channel',
    38|                 'type'  => 'html',
    39|             ],
    40|             $prefix.'channel_id' => [
    41|                 'label' => 'mautic.message.queue.report.channel_id',
    42|                 'type'  => 'int',
    43|             ],
    44|             $prefix.'priority' => [
    45|                 'label' => 'mautic.message.queue.report.priority',
    46|                 'type'  => 'string',
    47|             ],
    48|             $prefix.'max_attempts' => [
    49|                 'label' => 'mautic.message.queue.report.max_attempts',
    50|                 'type'  => 'int',
    51|             ],
    52|             $prefix.'attempts' => [
    53|                 'label' => 'mautic.message.queue.report.attempts',
    54|                 'type'  => 'int',
    55|             ],
    56|             $prefix.'success' => [
    57|                 'label' => 'mautic.message.queue.report.success',
    58|                 'type'  => 'boolean',
    59|             ],
    60|             $prefix.'status' => [
    61|                 'label' => 'mautic.message.queue.report.status',
    62|                 'type'  => 'string',
    63|             ],
    64|             $prefix.'last_attempt' => [
    65|                 'label' => 'mautic.message.queue.report.last_attempt',
    66|                 'type'  => 'datetime',
    67|             ],
    68|             $prefix.'date_sent' => [
    69|                 'label' => 'mautic.message.queue.report.date_sent',
    70|                 'type'  => 'datetime',
    71|             ],
    72|             $prefix.'scheduled_date' => [
    73|                 'label' => 'mautic.message.queue.report.scheduled_date',
    74|                 'type'  => 'datetime',
    75|             ],
    76|             $prefix.'date_published' => [
    77|                 'label' => 'mautic.message.queue.report.date_published',
    78|                 'type'  => 'datetime',
    79|             ],
    80|         ];
    81|         $companyColumns = $this->companyReportData->getCompanyData();
    82|         $columns = array_merge(
    83|             $columns,
    84|             $event->getLeadColumns(),
    85|             $companyColumns
    86|         );
    87|         $event->addTable(
    88|             self::CONTEXT_MESSAGE_CHANNEL,
    89|             [
    90|                 'display_name' => 'mautic.message.queue',
    91|                 'columns'      => $columns,
    92|             ]
    93|         );
    94|     }
    95|     /**
    96|      * Initialize the QueryBuilder object to generate reports from.
    97|      */
    98|     public function onReportGenerate(ReportGeneratorEvent $event): void
    99|     {
   100|         if (!$event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
   101|             return;
   102|         }
   103|         $queryBuilder = $event->getQueryBuilder();
   104|         $queryBuilder->from(MAUTIC_TABLE_PREFIX.'message_queue', 'mq')
   105|             ->leftJoin('mq', MAUTIC_TABLE_PREFIX.'leads', 'l', 'l.id = mq.lead_id');
   106|         if ($this->companyReportData->eventHasCompanyColumns($event)) {
   107|             $event->addCompanyLeftJoin($queryBuilder);
   108|         }
   109|         $event->setQueryBuilder($queryBuilder);
   110|     }
   111|     public function onReportDisplay(ReportDataEvent $event): void
   112|     {
   113|         $data = $event->getData();
   114|         if ($event->checkContext([self::CONTEXT_MESSAGE_CHANNEL])) {
   115|             if (isset($data[0]['channel']) && isset($data[0]['channel_id'])) {
   116|                 foreach ($data as &$row) {
   117|                     $href = $this->router->generate('mautic_'.$row['channel'].'_action', ['objectAction' => 'view', 'objectId' => $row['channel_id']]);
   118|                     if (isset($row['channel'])) {
   119|                         $row['channel'] = '<a href="'.$href.'">'.$row['channel'].'</a>';
   120|                     }
   121|                     unset($row);
   122|                 }
   123|             }
   124|         }
   125|         $event->setData($data);
   126|         unset($data);
   127|     }
   128| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/EventListener/SearchSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ChannelBundle\EventListener;
     4| use Mautic\ChannelBundle\Model\MessageModel;
     5| use Mautic\CoreBundle\CoreEvents;
     6| use Mautic\CoreBundle\DTO\GlobalSearchFilterDTO;
     7| use Mautic\CoreBundle\Event\GlobalSearchEvent;
     8| use Mautic\CoreBundle\Service\GlobalSearch;
     9| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    10| class SearchSubscriber implements EventSubscriberInterface
    11| {
    12|     public function __construct(
    13|         private MessageModel $model,
    14|         private GlobalSearch $globalSearch,
    15|     ) {
    16|     }
    17|     public static function getSubscribedEvents(): array
    18|     {
    19|         return [
    20|             CoreEvents::GLOBAL_SEARCH => ['onGlobalSearch', 0],
    21|         ];
    22|     }
    23|     public function onGlobalSearch(GlobalSearchEvent $event): void
    24|     {
    25|         $results = $this->globalSearch->performSearch(
    26|             new GlobalSearchFilterDTO($event->getSearchString()),
    27|             $this->model,
    28|             '@MauticChannel/SubscribedEvents/Search/global.html.twig'
    29|         );
    30|         if (!empty($results)) {
    31|             $event->addResults('mautic.messages.header', $results);
    32|         }
    33|     }
    34| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Form/Type/MessageListType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Form\Type;
     3| use Mautic\CoreBundle\Form\Type\EntityLookupType;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\OptionsResolver\Options;
     6| use Symfony\Component\OptionsResolver\OptionsResolver;
     7| /**
     8|  * @extends AbstractType<mixed>
     9|  */
    10| class MessageListType extends AbstractType
    11| {
    12|     public function configureOptions(OptionsResolver $resolver): void
    13|     {
    14|         $resolver->setDefaults(
    15|             [
    16|                 'required'           => false,
    17|                 'modal_route'        => 'mautic_message_action',
    18|                 'model'              => 'channel.message',
    19|                 'multiple'           => true,
    20|                 'ajax_lookup_action' => function (Options $options): string {
    21|                     $query = [
    22|                         'is_published' => $options['is_published'],
    23|                     ];
    24|                     return 'channel:getLookupChoiceList&'.http_build_query($query);
    25|                 },
    26|                 'model_lookup_method' => 'getLookupResults',
    27|                 'lookup_arguments'    => fn (Options $options): array => [
    28|                     'type'    => 'channel.message',
    29|                     'filter'  => '$data',
    30|                     'limit'   => 0,
    31|                     'start'   => 0,
    32|                     'options' => [
    33|                         'is_published' => $options['is_published'],
    34|                     ],
    35|                 ],
    36|                 'is_published' => true,
    37|             ]
    38|         );
    39|     }
    40|     public function getParent(): ?string
    41|     {
    42|         return EntityLookupType::class;
    43|     }
    44| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Form/Type/MessageSendType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-86 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Form\Type;
     3| use Mautic\ChannelBundle\Model\MessageModel;
     4| use Symfony\Component\Form\AbstractType;
     5| use Symfony\Component\Form\Extension\Core\Type\ButtonType;
     6| use Symfony\Component\Form\FormBuilderInterface;
     7| use Symfony\Component\OptionsResolver\OptionsResolver;
     8| use Symfony\Component\Routing\RouterInterface;
     9| use Symfony\Component\Validator\Constraints\NotBlank;
    10| /**
    11|  * @extends AbstractType<mixed>
    12|  */
    13| class MessageSendType extends AbstractType
    14| {
    15|     public function __construct(
    16|         protected RouterInterface $router,
    17|         protected MessageModel $messageModel,
    18|     ) {
    19|     }
    20|     public function buildForm(FormBuilderInterface $builder, array $options): void
    21|     {
    22|         $builder->add(
    23|             'marketingMessage',
    24|             MessageListType::class,
    25|             [
    26|                 'label'       => 'mautic.channel.send.selectmessages',
    27|                 'label_attr'  => ['class' => 'control-label'],
    28|                 'multiple'    => false,
    29|                 'required'    => true,
    30|                 'constraints' => [
    31|                     new NotBlank(
    32|                         ['message' => 'mautic.channel.choosemessage.notblank']
    33|                     ),
    34|                 ],
    35|             ]
    36|         );
    37|         if (!empty($options['update_select'])) {
    38|             $windowUrl = $this->router->generate(
    39|                 'mautic_message_action',
    40|                 [
    41|                     'objectAction' => 'new',
    42|                     'contentOnly'  => 1,
    43|                     'updateSelect' => $options['update_select'],
    44|                 ]
    45|             );
    46|             $builder->add(
    47|                 'newMarketingMessageButton',
    48|                 ButtonType::class,
    49|                 [
    50|                     'attr' => [
    51|                         'class'   => 'btn btn-primary btn-nospin',
    52|                         'onclick' => 'Mautic.loadNewWindow({windowUrl: \''.$windowUrl.'\'})',
    53|                         'icon'    => 'ri-add-line',
    54|                     ],
    55|                     'label' => 'mautic.channel.create.new.message',
    56|                 ]
    57|             );
    58|             $windowUrlEdit = $this->router->generate(
    59|                 'mautic_message_action',
    60|                 [
    61|                     'objectAction' => 'edit',
    62|                     'objectId'     => 'messageId',
    63|                     'contentOnly'  => 1,
    64|                     'updateSelect' => $options['update_select'],
    65|                 ]
    66|             );
    67|             $builder->add(
    68|                 'editMessageButton',
    69|                 ButtonType::class,
    70|                 [
    71|                     'attr' => [
    72|                         'class'    => 'btn btn-primary btn-nospin',
    73|                         'onclick'  => 'Mautic.loadNewWindow({windowUrl: \''.$windowUrlEdit.'\'})',
    74|                         'disabled' => !isset($options['data']['message']),
    75|                         'icon'     => 'ri-edit-line',
    76|                     ],
    77|                     'label' => 'mautic.channel.send.edit.message',
    78|                 ]
    79|             );
    80|         }
    81|     }
    82|     public function configureOptions(OptionsResolver $resolver): void
    83|     {
    84|         $resolver->setDefined(['update_select']);
    85|     }
    86| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Form/Type/MessageType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-65 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Form\Type;
     3| use Mautic\ChannelBundle\Entity\Channel;
     4| use Mautic\ChannelBundle\Entity\Message;
     5| use Mautic\ChannelBundle\Model\MessageModel;
     6| use Mautic\CoreBundle\Form\Type\AbstractFormStandardType;
     7| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
     8| use Symfony\Component\Form\Extension\Core\Type\CollectionType;
     9| use Symfony\Component\Form\FormBuilderInterface;
    10| use Symfony\Component\OptionsResolver\OptionsResolver;
    11| use Symfony\Component\Validator\Constraints\Valid;
    12| class MessageType extends AbstractFormStandardType
    13| {
    14|     public function __construct(
    15|         protected MessageModel $model,
    16|         CorePermissions $security,
    17|     ) {
    18|         $this->security = $security;
    19|     }
    20|     public function buildForm(FormBuilderInterface $builder, array $options): void
    21|     {
    22|         $options = array_merge($options, ['model_name' => 'channel.message', 'permission_base' => 'channel:messages']);
    23|         parent::buildForm($builder, $options);
    24|         /** @var Message $message */
    25|         $message         = $options['data'];
    26|         $channels        = $this->model->getChannels();
    27|         $messageChannels = $message->getChannels();
    28|         foreach ($channels as $channelType => $channel) {
    29|             if (!isset($messageChannels[$channelType])) {
    30|                 $message->addChannel(
    31|                     (new Channel())
    32|                         ->setChannel($channelType)
    33|                         ->setMessage($message)
    34|                 );
    35|             }
    36|         }
    37|         $builder->add(
    38|             'channels',
    39|             CollectionType::class,
    40|             [
    41|                 'label'         => false,
    42|                 'allow_add'     => true,
    43|                 'allow_delete'  => false,
    44|                 'prototype'     => false,
    45|                 'entry_type'    => ChannelType::class,
    46|                 'by_reference'  => false,
    47|                 'entry_options' => [
    48|                     'channels' => $channels,
    49|                 ],
    50|                 'constraints' => [
    51|                     new Valid(),
    52|                 ],
    53|             ]
    54|         );
    55|     }
    56|     public function configureOptions(OptionsResolver $resolver): void
    57|     {
    58|         $resolver->setDefaults(
    59|             [
    60|                 'data_class'      => Message::class,
    61|                 'category_bundle' => 'messages',
    62|             ]
    63|         );
    64|     }
    65| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Helper/ChannelListHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Helper;
     3| use Mautic\ChannelBundle\ChannelEvents;
     4| use Mautic\ChannelBundle\Event\ChannelEvent;
     5| use Mautic\CoreBundle\Translation\Translator;
     6| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
     7| class ChannelListHelper
     8| {
     9|     /**
    10|      * @var array<string,string>
    11|      */
    12|     private array $channels = [];
    13|     /**
    14|      * @var array<string,string[]>
    15|      */
    16|     private array $featureChannels = [];
    17|     public function __construct(
    18|         private EventDispatcherInterface $dispatcher,
    19|         private Translator $translator,
    20|     ) {
    21|     }
    22|     /**
    23|      * Get contact channels.
    24|      */
    25|     public function getChannelList(): array
    26|     {
    27|         $channels = [];
    28|         foreach ($this->getChannels() as $channel => $details) {
    29|             $channelName            = isset($details['label']) ? $this->translator->trans($details['label']) : $this->getChannelLabel($channel);
    30|             $channels[$channelName] = $channel;
    31|         }
    32|         return $channels;
    33|     }
    34|     /**
    35|      * @param bool $listOnly
    36|      */
    37|     public function getFeatureChannels($features, $listOnly = false): array
    38|     {
    39|         $this->setupChannels();
    40|         if (!is_array($features)) {
    41|             $features = [$features];
    42|         }
    43|         $channels = [];
    44|         foreach ($features as $feature) {
    45|             $featureChannels = $this->featureChannels[$feature] ?? [];
    46|             $returnChannels  = [];
    47|             foreach ($featureChannels as $channel => $details) {
    48|                 if (!isset($details['label'])) {
    49|                     $featureChannels[$channel]['label'] = $this->getChannelLabel($channel);
    50|                 }
    51|                 if ($listOnly) {
    52|                     $returnChannels[$featureChannels[$channel]['label']] = $channel;
    53|                 } else {
    54|                     $returnChannels[$channel] = $featureChannels[$channel];
    55|                 }
    56|             }
    57|             unset($featureChannels);
    58|             $channels[$feature] = $returnChannels;
    59|         }
    60|         if (1 === count($features)) {
    61|             $channels = $channels[$features[0]];
    62|         }
    63|         return $channels;
    64|     }
    65|     /**
    66|      * @return array
    67|      */
    68|     public function getChannels()
    69|     {
    70|         $this->setupChannels();
    71|         return $this->channels;
    72|     }
    73|     public function getChannelLabel($channel): string
    74|     {
    75|         return match (true) {
    76|             $this->translator->hasId('mautic.channel.'.$channel)      => $this->translator->trans('mautic.channel.'.$channel),
    77|             $this->translator->hasId('mautic.'.$channel.'.'.$channel) => $this->translator->trans('mautic.'.$channel.'.'.$channel),
    78|             default                                                   => ucfirst($channel),
    79|         };
    80|     }
    81|     public function getName(): string
    82|     {
    83|         return 'chanel';
    84|     }
    85|     /**
    86|      * Setup channels.
    87|      *
    88|      * Done this way to avoid a circular dependency error with LeadModel
    89|      */
    90|     private function setupChannels(): void
    91|     {
    92|         if (!empty($this->channels)) {
    93|             return;
    94|         }
    95|         $event                 = $this->dispatcher->dispatch(new ChannelEvent(), ChannelEvents::ADD_CHANNEL);
    96|         $this->channels        = $event->getChannelConfigs();
    97|         $this->featureChannels = $event->getFeatureChannels();
    98|         unset($event);
    99|     }
   100| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Model/ChannelActionModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Model;
     3| use Mautic\LeadBundle\Entity\DoNotContact as DNC;
     4| use Mautic\LeadBundle\Entity\Lead;
     5| use Mautic\LeadBundle\Model\DoNotContact;
     6| use Mautic\LeadBundle\Model\LeadModel;
     7| use Symfony\Contracts\Translation\TranslatorInterface;
     8| class ChannelActionModel
     9| {
    10|     public function __construct(
    11|         private LeadModel $contactModel,
    12|         private DoNotContact $doNotContact,
    13|         private TranslatorInterface $translator,
    14|     ) {
    15|     }
    16|     /**
    17|      * Update channels and frequency rules.
    18|      */
    19|     public function update(array $contactIds, array $subscribedChannels): void
    20|     {
    21|         $contacts = $this->contactModel->getLeadsByIds($contactIds);
    22|         foreach ($contacts as $contact) {
    23|             if (!$this->contactModel->canEditContact($contact)) {
    24|                 continue;
    25|             }
    26|             $this->addChannels($contact, $subscribedChannels);
    27|             $this->removeChannels($contact, $subscribedChannels);
    28|         }
    29|     }
    30|     /**
    31|      * Add contact's channels.
    32|      * Only resubscribe if the contact did not opt out themselves.
    33|      */
    34|     private function addChannels(Lead $contact, array $subscribedChannels): void
    35|     {
    36|         $contactChannels = $this->contactModel->getContactChannels($contact);
    37|         foreach ($subscribedChannels as $subscribedChannel) {
    38|             if (!array_key_exists($subscribedChannel, $contactChannels)) {
    39|                 $contactable = $this->doNotContact->isContactable($contact, $subscribedChannel);
    40|                 if (DNC::UNSUBSCRIBED !== $contactable) {
    41|                     $this->doNotContact->removeDncForContact($contact->getId(), $subscribedChannel);
    42|                 }
    43|             }
    44|         }
    45|     }
    46|     /**
    47|      * Remove contact's channels.
    48|      */
    49|     private function removeChannels(Lead $contact, array $subscribedChannels): void
    50|     {
    51|         $allChannels = $this->contactModel->getPreferenceChannels();
    52|         $dncChannels = array_diff($allChannels, $subscribedChannels);
    53|         foreach ($dncChannels as $channel) {
    54|             $this->doNotContact->addDncForContact(
    55|                 $contact->getId(),
    56|                 $channel,
    57|                 DNC::MANUAL,
    58|                 $this->translator->trans('mautic.lead.event.donotcontact_manual')
    59|             );
    60|         }
    61|     }
    62| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Model/FrequencyActionModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Model;
     3| use Mautic\LeadBundle\Entity\FrequencyRule;
     4| use Mautic\LeadBundle\Entity\FrequencyRuleRepository;
     5| use Mautic\LeadBundle\Entity\Lead;
     6| use Mautic\LeadBundle\Model\LeadModel;
     7| class FrequencyActionModel
     8| {
     9|     public function __construct(
    10|         private LeadModel $contactModel,
    11|         private FrequencyRuleRepository $frequencyRuleRepository,
    12|     ) {
    13|     }
    14|     /**
    15|      * Update channels.
    16|      *
    17|      * @param string $preferredChannel
    18|      */
    19|     public function update(array $contactIds, array $params, $preferredChannel): void
    20|     {
    21|         $contacts = $this->contactModel->getLeadsByIds($contactIds);
    22|         foreach ($contacts as $contact) {
    23|             if (!$this->contactModel->canEditContact($contact)) {
    24|                 continue;
    25|             }
    26|             $this->updateFrequencyRules($contact, $params, $preferredChannel);
    27|         }
    28|     }
    29|     /**
    30|      * @param string $preferredChannel
    31|      */
    32|     private function updateFrequencyRules(Lead $contact, array $params, $preferredChannel): void
    33|     {
    34|         $frequencyRules = $contact->getFrequencyRules()->toArray();
    35|         $channels       = $this->contactModel->getPreferenceChannels();
    36|         foreach ($channels as $channel) {
    37|             if (is_null($preferredChannel)) {
    38|                 $preferredChannel = $channel;
    39|             }
    40|             $frequencyRule = $frequencyRules[$channel] ?? new FrequencyRule();
    41|             $frequencyRule->setChannel($channel);
    42|             $frequencyRule->setLead($contact);
    43|             if (!$frequencyRule->getDateAdded()) {
    44|                 $frequencyRule->setDateAdded(new \DateTime());
    45|             }
    46|             if (!empty($params['frequency_number_'.$channel]) && !empty($params['frequency_time_'.$channel])) {
    47|                 $frequencyRule->setFrequencyNumber($params['frequency_number_'.$channel]);
    48|                 $frequencyRule->setFrequencyTime($params['frequency_time_'.$channel]);
    49|             } else {
    50|                 $frequencyRule->setFrequencyNumber(null);
    51|                 $frequencyRule->setFrequencyTime(null);
    52|             }
    53|             if (!empty($params['contact_pause_start_date_'.$channel])) {
    54|                 $frequencyRule->setPauseFromDate(new \DateTime($params['contact_pause_start_date_'.$channel]));
    55|             }
    56|             if (!empty($params['contact_pause_end_date_'.$channel])) {
    57|                 $frequencyRule->setPauseToDate(new \DateTime($params['contact_pause_end_date_'.$channel]));
    58|             }
    59|             $frequencyRule->setPreferredChannel($preferredChannel === $channel);
    60|             $contact->addFrequencyRule($frequencyRule);
    61|             $this->frequencyRuleRepository->saveEntity($frequencyRule);
    62|         }
    63|     }
    64| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Model/MessageModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-231 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Model;
     3| use Doctrine\ORM\EntityManager;
     4| use Mautic\CampaignBundle\Model\CampaignModel;
     5| use Mautic\ChannelBundle\ChannelEvents;
     6| use Mautic\ChannelBundle\Entity\Message;
     7| use Mautic\ChannelBundle\Entity\MessageRepository;
     8| use Mautic\ChannelBundle\Event\MessageEvent;
     9| use Mautic\ChannelBundle\Form\Type\MessageType;
    10| use Mautic\ChannelBundle\Helper\ChannelListHelper;
    11| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    12| use Mautic\CoreBundle\Helper\UserHelper;
    13| use Mautic\CoreBundle\Model\AjaxLookupModelInterface;
    14| use Mautic\CoreBundle\Model\FormModel;
    15| use Mautic\CoreBundle\Model\GlobalSearchInterface;
    16| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    17| use Mautic\CoreBundle\Translation\Translator;
    18| use Psr\Log\LoggerInterface;
    19| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    20| use Symfony\Component\Form\FormFactoryInterface;
    21| use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
    22| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    23| use Symfony\Contracts\EventDispatcher\Event;
    24| /**
    25|  * @extends FormModel<Message>
    26|  *
    27|  * @implements AjaxLookupModelInterface<Message>
    28|  */
    29| class MessageModel extends FormModel implements AjaxLookupModelInterface, GlobalSearchInterface
    30| {
    31|     public const CHANNEL_FEATURE = 'marketing_messages';
    32|     protected static $channels;
    33|     public function __construct(
    34|         protected ChannelListHelper $channelListHelper,
    35|         protected CampaignModel $campaignModel,
    36|         EntityManager $em,
    37|         CorePermissions $security,
    38|         EventDispatcherInterface $dispatcher,
    39|         UrlGeneratorInterface $router,
    40|         Translator $translator,
    41|         UserHelper $userHelper,
    42|         LoggerInterface $mauticLogger,
    43|         CoreParametersHelper $coreParametersHelper,
    44|     ) {
    45|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    46|     }
    47|     /**
    48|      * @param Message $entity
    49|      * @param bool    $unlock
    50|      */
    51|     public function saveEntity($entity, $unlock = true): void
    52|     {
    53|         $isNew = $entity->isNew();
    54|         parent::saveEntity($entity, $unlock);
    55|         if (!$isNew) {
    56|             $channels = $entity->getChannels();
    57|             foreach ($channels as $channel) {
    58|                 $channel->setMessage($entity);
    59|             }
    60|             $this->getRepository()->saveEntities($channels);
    61|         }
    62|     }
    63|     public function getPermissionBase(): string
    64|     {
    65|         return 'channel:messages';
    66|     }
    67|     public function getRepository(): ?MessageRepository
    68|     {
    69|         return $this->em->getRepository(Message::class);
    70|     }
    71|     public function getEntity($id = null): ?Message
    72|     {
    73|         if (null === $id) {
    74|             return new Message();
    75|         }
    76|         return parent::getEntity($id);
    77|     }
    78|     /**
    79|      * @param object $entity
    80|      * @param array  $options
    81|      *
    82|      * @return \Symfony\Component\Form\FormInterface<mixed>
    83|      */
    84|     public function createForm($entity, FormFactoryInterface $formFactory, $action = null, $options = []): \Symfony\Component\Form\FormInterface
    85|     {
    86|         if (!empty($action)) {
    87|             $options['action'] = $action;
    88|         }
    89|         return $formFactory->create(MessageType::class, $entity, $options);
    90|     }
    91|     /**
    92|      * @return array
    93|      */
    94|     public function getChannels()
    95|     {
    96|         if (!self::$channels) {
    97|             $channels = $this->channelListHelper->getFeatureChannels(self::CHANNEL_FEATURE);
    98|             foreach ($channels as $channel => $config) {
    99|                 if (!isset($config['lookupFormType']) && !isset($config['propertiesFormType'])) {
   100|                     throw new \InvalidArgumentException('lookupFormType and/or propertiesFormType are required for channel '.$channel);
   101|                 }
   102|                 $label = match (true) {
   103|                     $this->translator->hasId('mautic.channel.'.$channel)      => $this->translator->trans('mautic.channel.'.$channel),
   104|                     $this->translator->hasId('mautic.'.$channel)              => $this->translator->trans('mautic.'.$channel),
   105|                     $this->translator->hasId('mautic.'.$channel.'.'.$channel) => $this->translator->trans('mautic.'.$channel.'.'.$channel),
   106|                     default                                                   => ucfirst($channel),
   107|                 };
   108|                 $config['label'] = $label;
   109|                 $channels[$channel] = $config;
   110|             }
   111|             self::$channels = $channels;
   112|         }
   113|         return self::$channels;
   114|     }
   115|     /**
   116|      * @param string $filter
   117|      * @param int    $limit
   118|      * @param int    $start
   119|      * @param array  $options
   120|      */
   121|     public function getLookupResults($type, $filter = '', $limit = 10, $start = 0, $options = []): array
   122|     {
   123|         $results = [];
   124|         switch ($type) {
   125|             case 'channel.message':
   126|                 $entities = $this->getRepository()->getMessageList(
   127|                     $filter,
   128|                     $limit,
   129|                     $start
   130|                 );
   131|                 foreach ($entities as $entity) {
   132|                     $results[] = [
   133|                         'label' => $entity['name'],
   134|                         'value' => $entity['id'],
   135|                     ];
   136|                 }
   137|                 break;
   138|         }
   139|         return $results;
   140|     }
   141|     public function getMessageChannels($messageId): array
   142|     {
   143|         return $this->getRepository()->getMessageChannels($messageId);
   144|     }
   145|     /**
   146|      * @return array
   147|      */
   148|     public function getChannelMessageByChannelId($channelId)
   149|     {
   150|         return $this->getRepository()->getChannelMessageByChannelId($channelId);
   151|     }
   152|     public function getLeadStatsPost($messageId, $dateFrom = null, $dateTo = null, $channel = null): array
   153|     {
   154|         $eventLog = $this->campaignModel->getCampaignLeadEventLogRepository();
   155|         return $eventLog->getChartQuery(
   156|             [
   157|                 'type'       => 'message.send',
   158|                 'dateFrom'   => $dateFrom,
   159|                 'dateTo'     => $dateTo,
   160|                 'channel'    => 'channel.message',
   161|                 'channelId'  => $messageId,
   162|                 'logChannel' => $channel,
   163|             ]
   164|         );
   165|     }
   166|     /**
   167|      * @return mixed
   168|      */
   169|     public function getMarketingMessagesEventLogs($messageId, $dateFrom = null, $dateTo = null)
   170|     {
   171|         $eventLog = $this->campaignModel->getCampaignLeadEventLogRepository();
   172|         return $eventLog->getEventLogs(['type' => 'message.send', 'dateFrom' => $dateFrom, 'dateTo' => $dateTo, 'channel' => 'message', 'channelId' => $messageId]);
   173|     }
   174|     /**
   175|      * Get the channel name from the database.
   176|      *
   177|      * @template T of object
   178|      *
   179|      * @param int             $id
   180|      * @param class-string<T> $entityName
   181|      * @param string          $nameColumn
   182|      *
   183|      * @return string|null
   184|      */
   185|     public function getChannelName($id, $entityName, $nameColumn = 'name')
   186|     {
   187|         if (!$id || !$entityName || !$nameColumn) {
   188|             return null;
   189|         }
   190|         $repo = $this->em->getRepository($entityName);
   191|         $qb   = $repo->createQueryBuilder('e')
   192|             ->select('e.'.$nameColumn)
   193|             ->where('e.id = :id')
   194|             ->setParameter('id', (int) $id);
   195|         $result = $qb->getQuery()->getOneOrNullResult();
   196|         return $result[$nameColumn] ?? null;
   197|     }
   198|     /**
   199|      * @throws MethodNotAllowedHttpException
   200|      */
   201|     protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
   202|     {
   203|         if (!$entity instanceof Message) {
   204|             throw new MethodNotAllowedHttpException(['Message']);
   205|         }
   206|         switch ($action) {
   207|             case 'pre_save':
   208|                 $name = ChannelEvents::MESSAGE_PRE_SAVE;
   209|                 break;
   210|             case 'post_save':
   211|                 $name = ChannelEvents::MESSAGE_POST_SAVE;
   212|                 break;
   213|             case 'pre_delete':
   214|                 $name = ChannelEvents::MESSAGE_PRE_DELETE;
   215|                 break;
   216|             case 'post_delete':
   217|                 $name = ChannelEvents::MESSAGE_POST_DELETE;
   218|                 break;
   219|             default:
   220|                 return null;
   221|         }
   222|         if ($this->dispatcher->hasListeners($name)) {
   223|             if (empty($event)) {
   224|                 $event = new MessageEvent($entity, $isNew);
   225|             }
   226|             $this->dispatcher->dispatch($event, $name);
   227|             return $event;
   228|         }
   229|         return null;
   230|     }
   231| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Model/MessageQueueModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-312 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\Model;
     3| use Doctrine\ORM\EntityManagerInterface;
     4| use Mautic\ChannelBundle\ChannelEvents;
     5| use Mautic\ChannelBundle\Entity\MessageQueue;
     6| use Mautic\ChannelBundle\Event\MessageQueueBatchProcessEvent;
     7| use Mautic\ChannelBundle\Event\MessageQueueEvent;
     8| use Mautic\ChannelBundle\Event\MessageQueueProcessEvent;
     9| use Mautic\CoreBundle\Helper\CoreParametersHelper;
    10| use Mautic\CoreBundle\Helper\UserHelper;
    11| use Mautic\CoreBundle\Model\FormModel;
    12| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    13| use Mautic\CoreBundle\Translation\Translator;
    14| use Mautic\LeadBundle\Entity\Lead;
    15| use Mautic\LeadBundle\Model\CompanyModel;
    16| use Mautic\LeadBundle\Model\LeadModel;
    17| use Psr\Log\LoggerInterface;
    18| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    19| use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
    20| use Symfony\Contracts\EventDispatcher\Event;
    21| /**
    22|  * @extends FormModel<MessageQueue>
    23|  */
    24| class MessageQueueModel extends FormModel
    25| {
    26|     /**
    27|      * @var string A default message reschedule interval
    28|      */
    29|     public const DEFAULT_RESCHEDULE_INTERVAL = 'PT15M';
    30|     public function __construct(
    31|         protected LeadModel $leadModel,
    32|         protected CompanyModel $companyModel,
    33|         CoreParametersHelper $coreParametersHelper,
    34|         EntityManagerInterface $em,
    35|         CorePermissions $security,
    36|         EventDispatcherInterface $dispatcher,
    37|         UrlGeneratorInterface $router,
    38|         Translator $translator,
    39|         UserHelper $userHelper,
    40|         LoggerInterface $mauticLogger,
    41|     ) {
    42|         parent::__construct($em, $security, $dispatcher, $router, $translator, $userHelper, $mauticLogger, $coreParametersHelper);
    43|     }
    44|     /**
    45|      * @return \Mautic\ChannelBundle\Entity\MessageQueueRepository
    46|      */
    47|     public function getRepository()
    48|     {
    49|         return $this->em->getRepository(MessageQueue::class);
    50|     }
    51|     /**
    52|      * @param int    $attempts
    53|      * @param int    $priority
    54|      * @param mixed  $messageQueue
    55|      * @param string $statTableName
    56|      * @param string $statContactColumn
    57|      * @param string $statSentColumn
    58|      */
    59|     public function processFrequencyRules(
    60|         array &$leads,
    61|         $channel,
    62|         $channelId,
    63|         $campaignEventId = null,
    64|         $attempts = 3,
    65|         $priority = MessageQueue::PRIORITY_NORMAL,
    66|         $messageQueue = null,
    67|         $statTableName = 'email_stats',
    68|         $statContactColumn = 'lead_id',
    69|         $statSentColumn = 'date_sent',
    70|     ): array {
    71|         $leadIds = array_keys($leads);
    72|         $leadIds = array_combine($leadIds, $leadIds);
    73|         /** @var \Mautic\LeadBundle\Entity\FrequencyRuleRepository $frequencyRulesRepo */
    74|         $frequencyRulesRepo     = $this->em->getRepository(\Mautic\LeadBundle\Entity\FrequencyRule::class);
    75|         $defaultFrequencyNumber = $this->coreParametersHelper->get($channel.'_frequency_number');
    76|         $defaultFrequencyTime   = $this->coreParametersHelper->get($channel.'_frequency_time');
    77|         $dontSendTo = $frequencyRulesRepo->getAppliedFrequencyRules(
    78|             $channel,
    79|             $leadIds,
    80|             $defaultFrequencyNumber,
    81|             $defaultFrequencyTime,
    82|             $statTableName,
    83|             $statContactColumn,
    84|             $statSentColumn
    85|         );
    86|         $queuedContacts = [];
    87|         foreach ($dontSendTo as $frequencyRuleMet) {
    88|             $scheduleInterval = new \DateInterval('P1'.substr($frequencyRuleMet['frequency_time'], 0, 1));
    89|             if ($messageQueue && isset($messageQueue[$frequencyRuleMet['lead_id']])) {
    90|                 $this->reschedule($messageQueue[$frequencyRuleMet['lead_id']], $scheduleInterval);
    91|             } else {
    92|                 $this->queue(
    93|                     [$leads[$frequencyRuleMet['lead_id']]],
    94|                     $channel,
    95|                     $channelId,
    96|                     $scheduleInterval,
    97|                     $attempts,
    98|                     $priority,
    99|                     $campaignEventId
   100|                 );
   101|             }
   102|             $queuedContacts[$frequencyRuleMet['lead_id']] = $frequencyRuleMet['lead_id'];
   103|             unset($leads[$frequencyRuleMet['lead_id']]);
   104|         }
   105|         return $queuedContacts;
   106|     }
   107|     /**
   108|      * Adds messages to the queue.
   109|      *
   110|      * @param array    $leads
   111|      * @param string   $channel
   112|      * @param int      $channelId
   113|      * @param int      $maxAttempts
   114|      * @param int      $priority
   115|      * @param int|null $campaignEventId
   116|      * @param array    $options
   117|      */
   118|     public function queue(
   119|         $leads,
   120|         $channel,
   121|         $channelId,
   122|         \DateInterval $scheduledInterval,
   123|         $maxAttempts = 1,
   124|         $priority = 1,
   125|         $campaignEventId = null,
   126|         $options = [],
   127|     ): bool {
   128|         $messageQueues = [];
   129|         $scheduledDate = (new \DateTime())->add($scheduledInterval);
   130|         foreach ($leads as $lead) {
   131|             $leadId = (is_array($lead)) ? $lead['id'] : $lead->getId();
   132|             if (!empty($this->getRepository()->findMessage($channel, $channelId, $leadId))) {
   133|                 continue;
   134|             }
   135|             $messageQueue = new MessageQueue();
   136|             if ($campaignEventId) {
   137|                 $messageQueue->setEvent($this->em->getReference(\Mautic\CampaignBundle\Entity\Event::class, $campaignEventId));
   138|             }
   139|             $messageQueue->setChannel($channel);
   140|             $messageQueue->setChannelId($channelId);
   141|             $messageQueue->setDatePublished(new \DateTime());
   142|             $messageQueue->setMaxAttempts($maxAttempts);
   143|             $messageQueue->setLead(
   144|                 ($lead instanceof Lead) ? $lead : $this->em->getReference(Lead::class, $leadId)
   145|             );
   146|             $messageQueue->setPriority($priority);
   147|             $messageQueue->setScheduledDate($scheduledDate);
   148|             $messageQueue->setOptions($options);
   149|             $messageQueues[] = $messageQueue;
   150|         }
   151|         if ($messageQueues) {
   152|             $this->saveEntities($messageQueues);
   153|             $messageQueueRepository = $this->getRepository();
   154|             $messageQueueRepository->detachEntities($messageQueues);
   155|         }
   156|         return true;
   157|     }
   158|     public function sendMessages($channel = null, $channelId = null): int
   159|     {
   160|         $processStarted = new \DateTime();
   161|         $limit          = 50;
   162|         $counter        = 0;
   163|         foreach ($this->getRepository()->getQueuedMessages($limit, $processStarted, $channel, $channelId) as $queue) {
   164|             $counter += $this->processMessageQueue($queue);
   165|             $event   = $queue->getEvent();
   166|             if ($event) {
   167|                 $this->em->detach($event);
   168|             }
   169|             $this->em->detach($queue);
   170|         }
   171|         return $counter;
   172|     }
   173|     public function processMessageQueue($queue): int
   174|     {
   175|         if (!is_array($queue)) {
   176|             if (!$queue instanceof MessageQueue) {
   177|                 throw new \InvalidArgumentException('$queue must be an instance of '.MessageQueue::class);
   178|             }
   179|             $queue = [$queue->getId() => $queue];
   180|         }
   181|         $counter   = 0;
   182|         $contacts  = [];
   183|         $byChannel = [];
   184|         /** @var MessageQueue $message */
   185|         foreach ($queue as $message) {
   186|             if ($message->getLead()) {
   187|                 $contacts[$message->getId()] = $message->getLead()->getId();
   188|             }
   189|         }
   190|         if (!empty($contacts)) {
   191|             $contactData = $this->leadModel->getRepository()->getContacts($contacts);
   192|             foreach ($contacts as $messageId => $contactId) {
   193|                 $queue[$messageId]->getLead()->setFields($contactData[$contactId]);
   194|             }
   195|         }
   196|         foreach ($queue as $key => $message) {
   197|             if (MessageQueue::STATUS_SENT == $message->getStatus()) {
   198|                 unset($queue[$key]);
   199|                 continue;
   200|             }
   201|             $messageChannel   = $message->getChannel();
   202|             $messageChannelId = $message->getChannelId();
   203|             if (!$messageChannelId) {
   204|                 $messageChannelId = 0;
   205|             }
   206|             if (!isset($byChannel[$messageChannel])) {
   207|                 $byChannel[$messageChannel] = [];
   208|             }
   209|             if (!isset($byChannel[$messageChannel][$messageChannelId])) {
   210|                 $byChannel[$messageChannel][$messageChannelId] = [];
   211|             }
   212|             $byChannel[$messageChannel][$messageChannelId][] = $message;
   213|         }
   214|         foreach ($byChannel as $messageChannel => $channelMessages) {
   215|             foreach ($channelMessages as $messageChannelId => $messages) {
   216|                 $event  = new MessageQueueBatchProcessEvent($messages, $messageChannel, $messageChannelId);
   217|                 $ignore = null;
   218|                 $this->dispatchEvent('process_batch_message_queue', $ignore, false, $event);
   219|             }
   220|         }
   221|         unset($byChannel);
   222|         foreach ($queue as $message) {
   223|             if (!$message->isProcessed()) {
   224|                 $event = new MessageQueueProcessEvent($message);
   225|                 $this->dispatchEvent('process_message_queue', $message, false, $event);
   226|             }
   227|             if ($message->isSuccess()) {
   228|                 ++$counter;
   229|                 $message->setSuccess();
   230|                 $message->setLastAttempt(new \DateTime());
   231|                 $message->setDateSent(new \DateTime());
   232|                 $message->setStatus(MessageQueue::STATUS_SENT);
   233|             } elseif ($message->isFailed()) {
   234|                 $this->reschedule($message, new \DateInterval(self::DEFAULT_RESCHEDULE_INTERVAL));
   235|             } // otherwise assume the listener did something such as rescheduling the message
   236|         }
   237|         $this->saveEntities($queue);
   238|         return $counter;
   239|     }
   240|     /**
   241|      * @param bool $persist
   242|      */
   243|     public function reschedule($message, \DateInterval $rescheduleInterval, $leadId = null, $channel = null, $channelId = null, $persist = false): void
   244|     {
   245|         if (!$message instanceof MessageQueue && $leadId && $channel && $channelId) {
   246|             $message = $this->getRepository()->findMessage($channel, $channelId, $leadId);
   247|             $persist = true;
   248|         }
   249|         if (!$message) {
   250|             return;
   251|         }
   252|         $message->setAttempts($message->getAttempts() + 1);
   253|         $message->setLastAttempt(new \DateTime());
   254|         $rescheduleTo = clone $message->getScheduledDate();
   255|         $rescheduleTo->add($rescheduleInterval);
   256|         $message->setScheduledDate($rescheduleTo);
   257|         $message->setStatus(MessageQueue::STATUS_RESCHEDULED);
   258|         if ($persist) {
   259|             $this->saveEntity($message);
   260|         }
   261|         $message->setProcessed();
   262|     }
   263|     /**
   264|      * @deprecated to be removed in 3.0; use reschedule method instead
   265|      *
   266|      * @param string $rescheduleInterval
   267|      * @param bool   $persist
   268|      */
   269|     public function rescheduleMessage($message, $rescheduleInterval = null, $leadId = null, $channel = null, $channelId = null, $persist = false): void
   270|     {
   271|         $rescheduleInterval = null == $rescheduleInterval ? self::DEFAULT_RESCHEDULE_INTERVAL : ('P'.$rescheduleInterval);
   272|         $this->reschedule($message, new \DateInterval($rescheduleInterval), $leadId, $channel, $channelId, $persist);
   273|     }
   274|     /**
   275|      * @param array $channelIds
   276|      */
   277|     public function getQueuedChannelCount($channel, $channelIds = []): int
   278|     {
   279|         return $this->getRepository()->getQueuedChannelCount($channel, $channelIds);
   280|     }
   281|     /**
   282|      * @param ?object $entity
   283|      *
   284|      * @throws \Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException
   285|      */
   286|     protected function dispatchEvent($action, &$entity, $isNew = false, Event $event = null): ?Event
   287|     {
   288|         switch ($action) {
   289|             case 'process_message_queue':
   290|                 $name = ChannelEvents::PROCESS_MESSAGE_QUEUE;
   291|                 break;
   292|             case 'process_batch_message_queue':
   293|                 $name = ChannelEvents::PROCESS_MESSAGE_QUEUE_BATCH;
   294|                 break;
   295|             case 'post_save':
   296|                 $name = ChannelEvents::MESSAGE_QUEUED;
   297|                 break;
   298|             default:
   299|                 return null;
   300|         }
   301|         if ($this->dispatcher->hasListeners($name)) {
   302|             if (empty($event)) {
   303|                 $event = new MessageQueueEvent($entity, $isNew);
   304|                 $event->setEntityManager($this->em);
   305|             }
   306|             $this->dispatcher->dispatch($event, $name);
   307|             return $event;
   308|         } else {
   309|             return null;
   310|         }
   311|     }
   312| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/PreferenceBuilder/ChannelPreferences.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\PreferenceBuilder;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| class ChannelPreferences
     7| {
     8|     /**
     9|      * @var ArrayCollection[]
    10|      */
    11|     private array $organizedByPriority = [];
    12|     public function __construct(
    13|         private Event $event,
    14|     ) {
    15|     }
    16|     /**
    17|      * @param int $priority
    18|      *
    19|      * @return $this
    20|      */
    21|     public function addPriority($priority)
    22|     {
    23|         $priority = (int) $priority;
    24|         if (!isset($this->organizedByPriority[$priority])) {
    25|             $this->organizedByPriority[$priority] = new ArrayCollection();
    26|         }
    27|         return $this;
    28|     }
    29|     /**
    30|      * @param int $priority
    31|      *
    32|      * @return $this
    33|      */
    34|     public function addLog(LeadEventLog $log, $priority)
    35|     {
    36|         $priority = (int) $priority;
    37|         $this->addPriority($priority);
    38|         $log = clone $log;
    39|         $log->setEvent($this->event);
    40|         $this->organizedByPriority[$priority]->set($log->getId(), $log);
    41|         return $this;
    42|     }
    43|     /**
    44|      * Removes a log from all prioritized groups.
    45|      *
    46|      * @return $this
    47|      */
    48|     public function removeLog(LeadEventLog $log)
    49|     {
    50|         foreach ($this->organizedByPriority as $logs) {
    51|             /** @var ArrayCollection<int, LeadEventLog> $logs */
    52|             $logs->remove($log->getId());
    53|         }
    54|         return $this;
    55|     }
    56|     /**
    57|      * @param int $priority
    58|      *
    59|      * @return ArrayCollection|LeadEventLog[]
    60|      */
    61|     public function getLogsByPriority($priority)
    62|     {
    63|         $priority = (int) $priority;
    64|         return $this->organizedByPriority[$priority] ?? new ArrayCollection();
    65|     }
    66| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/PreferenceBuilder/PreferenceBuilder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-87 ---
     1| <?php
     2| namespace Mautic\ChannelBundle\PreferenceBuilder;
     3| use Doctrine\Common\Collections\ArrayCollection;
     4| use Mautic\CampaignBundle\Entity\Event;
     5| use Mautic\CampaignBundle\Entity\LeadEventLog;
     6| use Mautic\LeadBundle\Entity\DoNotContact;
     7| use Psr\Log\LoggerInterface;
     8| class PreferenceBuilder
     9| {
    10|     /**
    11|      * @var ChannelPreferences[]
    12|      */
    13|     private array $channels = [];
    14|     public function __construct(
    15|         ArrayCollection $logs,
    16|         private Event $event,
    17|         array $channels,
    18|         private LoggerInterface $logger,
    19|     ) {
    20|         $this->buildRules($logs, $channels);
    21|     }
    22|     /**
    23|      * @return ChannelPreferences[]
    24|      */
    25|     public function getChannelPreferences()
    26|     {
    27|         return $this->channels;
    28|     }
    29|     public function removeLogFromAllChannels(LeadEventLog $log): void
    30|     {
    31|         foreach ($this->channels as $channelPreferences) {
    32|             $channelPreferences->removeLog($log);
    33|         }
    34|     }
    35|     /**
    36|      * @param string $channel
    37|      * @param int    $priority
    38|      */
    39|     private function addChannelRule($channel, array $rule, LeadEventLog $log, $priority): void
    40|     {
    41|         $channelPreferences = $this->getChannelPreferenceObject($channel, $priority);
    42|         if (DoNotContact::IS_CONTACTABLE !== $rule['dnc']) {
    43|             $log->appendToMetadata(
    44|                 [
    45|                     $channel => [
    46|                         'failed' => 1,
    47|                         'dnc'    => $rule['dnc'],
    48|                     ],
    49|                 ]
    50|             );
    51|             return;
    52|         }
    53|         $this->logger->debug("MARKETING MESSAGE: Set $channel as priority $priority for contact ID #".$log->getLead()->getId());
    54|         $channelPreferences->addLog($log, $priority);
    55|     }
    56|     /**
    57|      * @param string $channel
    58|      *
    59|      * @return ChannelPreferences
    60|      */
    61|     private function getChannelPreferenceObject($channel, $priority)
    62|     {
    63|         if (!isset($this->channels[$channel])) {
    64|             $this->channels[$channel] = new ChannelPreferences($this->event);
    65|         }
    66|         $this->channels[$channel]->addPriority($priority);
    67|         return $this->channels[$channel];
    68|     }
    69|     private function buildRules(ArrayCollection $logs, array $channels): void
    70|     {
    71|         /** @var LeadEventLog $log */
    72|         foreach ($logs as $log) {
    73|             $channelRules = $log->getLead()->getChannelRules();
    74|             $allChannels  = $channels;
    75|             $priority     = 1;
    76|             foreach ($channelRules as $channel => $rule) {
    77|                 $this->addChannelRule($channel, $rule, $log, $priority);
    78|                 ++$priority;
    79|                 unset($allChannels[$channel]);
    80|             }
    81|             foreach ($allChannels as $channel => $messageSettings) {
    82|                 $this->addChannelRule($channel, ['dnc' => DoNotContact::IS_CONTACTABLE], $log, $priority);
    83|                 ++$priority;
    84|             }
    85|         }
    86|     }
    87| }


# ====================================================================
# FILE: app/bundles/ChannelBundle/Twig/ChannelExtension.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ChannelBundle\Twig;
     4| use Mautic\ChannelBundle\Helper\ChannelListHelper;
     5| use Mautic\LeadBundle\Exception\UnknownDncReasonException;
     6| use Mautic\LeadBundle\Twig\Helper\DncReasonHelper;
     7| use Twig\Extension\AbstractExtension;
     8| use Twig\TwigFunction;
     9| class ChannelExtension extends AbstractExtension
    10| {
    11|     public function __construct(
    12|         private DncReasonHelper $dncReasonHelper,
    13|         private ChannelListHelper $channelListHelper,
    14|     ) {
    15|     }
    16|     /**
    17|      * @return TwigFunction[]
    18|      */
    19|     public function getFunctions(): array
    20|     {
    21|         return [
    22|             new TwigFunction('getChannelDncText', [$this, 'getChannelDncText']),
    23|             new TwigFunction('getChannelLabel', [$this, 'getChannelLabel']),
    24|         ];
    25|     }
    26|     public function getChannelDncText(int $reasonId): string
    27|     {
    28|         try {
    29|             return $this->dncReasonHelper->toText($reasonId);
    30|         } catch (UnknownDncReasonException $e) {
    31|             return $e->getMessage();
    32|         }
    33|     }
    34|     public function getChannelLabel(string $channel): string
    35|     {
    36|         return $this->channelListHelper->getChannelLabel($channel);
    37|     }
    38| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Assets/js/config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| Mautic.removeConfigValue = function(action, el) {
     2|     Mautic.executeAction(action, function(response) {
     3|     	if (response.success) {
     4|             mQuery(el).parent().addClass('hide');
     5|         }
     6| 	});
     7| };
     8| /**
     9|  *
    10|  * @returns string|false
    11|  */
    12| Mautic.parseQuery = function (query) {
    13|     var vars = query.split('&');
    14|     var queryString = {};
    15|     for (var i = 0; i < vars.length; i++) {
    16|         var pair = vars[i].split('=');
    17|         var key = decodeURIComponent(pair[0]);
    18|         var value = decodeURIComponent(pair[1]);
    19|         if (typeof queryString[key] === 'undefined') {
    20|             queryString[key] = decodeURIComponent(value);
    21|         } else if (typeof queryString[key] === 'string') {
    22|             var arr = [queryString[key], decodeURIComponent(value)];
    23|             queryString[key] = arr;
    24|         } else {
    25|             queryString[key].push(decodeURIComponent(value));
    26|         }
    27|     }
    28|     return queryString;
    29| }
    30| Mautic.parseUrlHashParameter = function(url) {
    31|     var url = url.split('#');
    32|     if ('undefined' != typeof url[1]) {
    33|         return url[1];
    34|     }
    35|     return false;
    36| }
    37| Mautic.observeConfigTabs = function() {
    38|     if (!mQuery('#config_coreconfig_last_shown_tab').length) {
    39|         return;
    40|     }
    41|     var parameters = Mautic.parseQuery(window.location.search.substr(1));
    42|     if ('undefined' != typeof parameters['tab']) {
    43|         mQuery('#config_coreconfig_last_shown_tab').val(parameters['tab']);
    44|         mQuery('a[data-toggle="tab"]').each(function (i, tab) {
    45|             if (mQuery(tab).attr('href') == ('#' + parameters['tab'])) {
    46|                 mQuery(tab).tab('show');
    47|             }
    48|         });
    49|     }
    50|     mQuery('a[data-toggle="tab"]').on('show.bs.tab', function (e) {
    51|         var tab = Mautic.parseUrlHashParameter(e.target.href);
    52|         if (tab) {
    53|             mQuery('#config_coreconfig_last_shown_tab').val(tab);
    54|         }
    55|     });
    56| }
    57| Mautic.resetEmailsToNotification = function(obj) {
    58|     const send_to_owner = obj.value;
    59|     if (parseInt(send_to_owner, 10) === 1)
    60|     {
    61|         mQuery(obj).closest('.panel-body').find('.notification_email_addresses').val('');
    62|     }
    63| };
    64| Mautic.configDsnTestExecute = function(element, action, key) {
    65|     const $button = mQuery(element),
    66|         $container = $button.closest('.config-dsn-container');
    67|     $container.find('.ri-loader-3-line').removeClass('hide');
    68|     Mautic.ajaxActionRequest(action, {key: key}, function(response) {
    69|         const theClass = (response.success) ? 'has-success' : 'has-error',
    70|             theMessage = response.message;
    71|         $container.find('.config-dsn-test-container').removeClass('has-success has-error').addClass(theClass);
    72|         $container.find('.help-block .status-msg').html(theMessage);
    73|         $container.find('.ri-loader-3-line').addClass('hide');
    74|     });
    75| };
    76| Mautic.configDsnTestDisable = function(element) {
    77|     const $container = mQuery(element).closest('.config-dsn-container');
    78|     $container.find('.help-block .status-msg').html('');
    79|     $container.find('.help-block .save-config-msg').removeClass('hide');
    80|     $container.find('.config-dsn-test-button').prop('disabled', true).addClass('disabled');
    81| };
    82| Mautic.showAnonymizeWarningMessage = function(anonymize_ip) {
    83|     if (mQuery(anonymize_ip).siblings('.toggle__label').attr('aria-checked') === 'true') {
    84|         mQuery('.anonymize_ip_address').addClass('hide');
    85|     } else {
    86|         mQuery('.anonymize_ip_address').removeClass('hide');
    87|     }
    88| };
    89| mQuery(Mautic.observeConfigTabs);


# ====================================================================
# FILE: app/bundles/ConfigBundle/Controller/ConfigController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-237 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Controller;
     3| use Mautic\ConfigBundle\ConfigEvents;
     4| use Mautic\ConfigBundle\Event\ConfigBuilderEvent;
     5| use Mautic\ConfigBundle\Event\ConfigEvent;
     6| use Mautic\ConfigBundle\Form\Type\ConfigType;
     7| use Mautic\ConfigBundle\Mapper\ConfigMapper;
     8| use Mautic\CoreBundle\Configurator\Configurator;
     9| use Mautic\CoreBundle\Controller\FormController;
    10| use Mautic\CoreBundle\Helper\BundleHelper;
    11| use Mautic\CoreBundle\Helper\CacheHelper;
    12| use Mautic\CoreBundle\Helper\EncryptionHelper;
    13| use Mautic\CoreBundle\Helper\PathsHelper;
    14| use Mautic\UserBundle\Entity\User;
    15| use Symfony\Component\Form\FormError;
    16| use Symfony\Component\HttpFoundation\JsonResponse;
    17| use Symfony\Component\HttpFoundation\Request;
    18| use Symfony\Component\HttpFoundation\Response;
    19| use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
    20| class ConfigController extends FormController
    21| {
    22|     /**
    23|      * Controller action for editing the application configuration.
    24|      *
    25|      * @return JsonResponse|Response
    26|      */
    27|     public function editAction(Request $request, BundleHelper $bundleHelper, Configurator $configurator, CacheHelper $cacheHelper, PathsHelper $pathsHelper, ConfigMapper $configMapper, TokenStorageInterface $tokenStorage)
    28|     {
    29|         if (!$this->user->isAdmin()) {
    30|             return $this->accessDenied();
    31|         }
    32|         $event      = new ConfigBuilderEvent($bundleHelper);
    33|         $dispatcher = $this->dispatcher;
    34|         $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
    35|         $fileFields = $event->getFileFields();
    36|         $formThemes = $event->getFormThemes();
    37|         $formConfigs = $configMapper->bindFormConfigsWithRealValues($event->getForms());
    38|         $this->mergeParamsWithLocal($formConfigs, $pathsHelper);
    39|         $action = $this->generateUrl('mautic_config_action', ['objectAction' => 'edit']);
    40|         $form   = $this->formFactory->create(
    41|             ConfigType::class,
    42|             $formConfigs,
    43|             [
    44|                 'action'     => $action,
    45|                 'fileFields' => $fileFields,
    46|             ]
    47|         );
    48|         $originalNormData = $form->getNormData();
    49|         $isWritable = $configurator->isFileWritable();
    50|         $openTab    = null;
    51|         if ('POST' == $request->getMethod()) {
    52|             if (!$cancelled = $this->isFormCancelled($form)) {
    53|                 $isValid = false;
    54|                 if ($isWritable && $isValid = $this->isFormValid($form)) {
    55|                     $post     = $request->request;
    56|                     /** @var mixed[] $formData */
    57|                     $formData = $form->getData();
    58|                     $configEvent = new ConfigEvent($formData, $post);
    59|                     $configEvent
    60|                         ->setOriginalNormData($originalNormData)
    61|                         ->setNormData($form->getNormData());
    62|                     $dispatcher->dispatch($configEvent, ConfigEvents::CONFIG_PRE_SAVE);
    63|                     $formValues = $configEvent->getConfig();
    64|                     $errors      = $configEvent->getErrors();
    65|                     $fieldErrors = $configEvent->getFieldErrors();
    66|                     if ($errors || $fieldErrors) {
    67|                         foreach ($errors as $message => $messageVars) {
    68|                             $form->addError(
    69|                                 new FormError($this->translator->trans($message, $messageVars, 'validators'))
    70|                             );
    71|                         }
    72|                         foreach ($fieldErrors as $key => $fields) {
    73|                             foreach ($fields as $field => $fieldError) {
    74|                                 $form[$key][$field]->addError(
    75|                                     new FormError($this->translator->trans($fieldError[0], $fieldError[1], 'validators'))
    76|                                 );
    77|                             }
    78|                         }
    79|                         $isValid = false;
    80|                     } else {
    81|                         $unsetIfEmpty = $configEvent->getPreservedFields();
    82|                         $unsetIfEmpty = array_merge($unsetIfEmpty, $fileFields);
    83|                         foreach ($formValues as $object) {
    84|                             $checkThese = array_intersect(array_keys($object), $unsetIfEmpty);
    85|                             foreach ($checkThese as $checkMe) {
    86|                                 if (empty($object[$checkMe])) {
    87|                                     unset($object[$checkMe]);
    88|                                 }
    89|                             }
    90|                             $configurator->mergeParameters($object);
    91|                         }
    92|                         try {
    93|                             $params = $configurator->getParameters();
    94|                             if (empty($params['secret_key'])) {
    95|                                 $configurator->mergeParameters(['secret_key' => EncryptionHelper::generateKey()]);
    96|                             }
    97|                             $configurator->write();
    98|                             $dispatcher->dispatch($configEvent, ConfigEvents::CONFIG_POST_SAVE);
    99|                             $this->addFlashMessage('mautic.config.config.notice.updated');
   100|                             $cacheHelper->refreshConfig();
   101|                             if (!empty($formData['coreconfig']['last_shown_tab'])) {
   102|                                 $openTab = $formData['coreconfig']['last_shown_tab'];
   103|                             }
   104|                         } catch (\RuntimeException $exception) {
   105|                             $this->addFlashMessage('mautic.config.config.error.not.updated', ['%exception%' => $exception->getMessage()], 'error');
   106|                         }
   107|                         $this->setLocale($request, $tokenStorage, $params);
   108|                     }
   109|                 } elseif (!$isWritable) {
   110|                     $form->addError(
   111|                         new FormError(
   112|                             $this->translator->trans('mautic.config.notwritable')
   113|                         )
   114|                     );
   115|                 }
   116|             }
   117|             if ($cancelled || $isValid) {
   118|                 if (!$cancelled && $this->isFormApplied($form)) {
   119|                     $redirectParameters = ['objectAction' => 'edit'];
   120|                     if ($openTab) {
   121|                         $redirectParameters['tab'] = $openTab;
   122|                     }
   123|                     return $this->delegateRedirect($this->generateUrl('mautic_config_action', $redirectParameters));
   124|                 } else {
   125|                     return $this->delegateRedirect($this->generateUrl('mautic_dashboard_index'));
   126|                 }
   127|             }
   128|         }
   129|         $tmpl = $request->isXmlHttpRequest() ? $request->get('tmpl', 'index') : 'index';
   130|         return $this->delegateView(
   131|             [
   132|                 'viewParameters' => [
   133|                     'tmpl'        => $tmpl,
   134|                     'security'    => $this->security,
   135|                     'form'        => $form->createView(),
   136|                     'formThemes'  => $formThemes,
   137|                     'formConfigs' => $formConfigs,
   138|                     'isWritable'  => $isWritable,
   139|                 ],
   140|                 'contentTemplate' => '@MauticConfig/Config/form.html.twig',
   141|                 'passthroughVars' => [
   142|                     'activeLink'    => '#mautic_config_index',
   143|                     'mauticContent' => 'config',
   144|                     'route'         => $this->generateUrl('mautic_config_action', ['objectAction' => 'edit']),
   145|                 ],
   146|             ]
   147|         );
   148|     }
   149|     /**
   150|      * @return array|JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
   151|      */
   152|     public function downloadAction(Request $request, BundleHelper $bundleHelper, $objectId)
   153|     {
   154|         if (!$this->user->isAdmin()) {
   155|             return $this->accessDenied();
   156|         }
   157|         $event      = new ConfigBuilderEvent($bundleHelper);
   158|         $dispatcher = $this->dispatcher;
   159|         $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
   160|         $fileFields = $event->getFileFields();
   161|         if (!in_array($objectId, $fileFields)) {
   162|             return $this->accessDenied();
   163|         }
   164|         $content  = $this->coreParametersHelper->get($objectId);
   165|         $filename = $request->get('filename', $objectId);
   166|         if ($decoded = base64_decode($content)) {
   167|             $response = new Response($decoded);
   168|             $response->headers->set('Content-Type', 'application/force-download');
   169|             $response->headers->set('Content-Type', 'application/octet-stream');
   170|             $response->headers->set('Content-Disposition', 'attachment; filename="'.$filename);
   171|             $response->headers->set('Expires', '0');
   172|             $response->headers->set('Cache-Control', 'must-revalidate');
   173|             $response->headers->set('Pragma', 'public');
   174|             return $response;
   175|         }
   176|         return $this->notFound();
   177|     }
   178|     /**
   179|      * @return array|JsonResponse|\Symfony\Component\HttpFoundation\RedirectResponse|Response
   180|      */
   181|     public function removeAction(BundleHelper $bundleHelper, Configurator $configurator, CacheHelper $cacheHelper, $objectId)
   182|     {
   183|         if (!$this->user->isAdmin()) {
   184|             return $this->accessDenied();
   185|         }
   186|         $success    = 0;
   187|         $event      = new ConfigBuilderEvent($bundleHelper);
   188|         $dispatcher = $this->dispatcher;
   189|         $dispatcher->dispatch($event, ConfigEvents::CONFIG_ON_GENERATE);
   190|         $fileFields = $event->getFileFields();
   191|         if (in_array($objectId, $fileFields)) {
   192|             $configurator->mergeParameters([$objectId => null]);
   193|             try {
   194|                 $configurator->write();
   195|                 $cacheHelper->refreshConfig();
   196|                 $success = 1;
   197|             } catch (\Exception) {
   198|             }
   199|         }
   200|         return new JsonResponse(['success' => $success]);
   201|     }
   202|     /**
   203|      * Merges default parameters from each subscribed bundle with the local (real) params.
   204|      */
   205|     private function mergeParamsWithLocal(array &$forms, PathsHelper $pathsHelper): void
   206|     {
   207|         $doNotChange     = $this->coreParametersHelper->get('mautic.security.restrictedConfigFields');
   208|         $localConfigFile = $pathsHelper->getLocalConfigurationFile();
   209|         $parameters = [];
   210|         include $localConfigFile;
   211|         /** @var mixed[] $parameters */
   212|         $localParams = $parameters;
   213|         foreach ($forms as &$form) {
   214|             foreach ($form['parameters'] as $key => $value) {
   215|                 if (in_array($key, $doNotChange)) {
   216|                     unset($form['parameters'][$key]);
   217|                 } elseif (array_key_exists($key, $localParams)) {// @phpstan-ignore function.impossibleType (Not sure what this is about)
   218|                     $paramValue               = $localParams[$key];
   219|                     $form['parameters'][$key] = $paramValue;
   220|                 }
   221|             }
   222|         }
   223|     }
   224|     /**
   225|      * @param array<string, string> $params
   226|      */
   227|     private function setLocale(Request $request, TokenStorageInterface $tokenStorage, array $params): void
   228|     {
   229|         $me = $tokenStorage->getToken()->getUser();
   230|         assert($me instanceof User);
   231|         $locale = $me->getLocale();
   232|         if (empty($locale)) {
   233|             $locale = $params['locale'] ?? $this->coreParametersHelper->get('locale');
   234|         }
   235|         $request->getSession()->set('_locale', $locale);
   236|     }
   237| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Controller/SysinfoController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Controller;
     3| use Doctrine\Persistence\ManagerRegistry;
     4| use Mautic\ConfigBundle\Model\SysinfoModel;
     5| use Mautic\CoreBundle\Controller\FormController;
     6| use Mautic\CoreBundle\Factory\ModelFactory;
     7| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     8| use Mautic\CoreBundle\Helper\UserHelper;
     9| use Mautic\CoreBundle\Security\Permissions\CorePermissions;
    10| use Mautic\CoreBundle\Service\FlashBag;
    11| use Mautic\CoreBundle\Translation\Translator;
    12| use Mautic\FormBundle\Helper\FormFieldHelper;
    13| use Symfony\Component\EventDispatcher\EventDispatcherInterface;
    14| use Symfony\Component\Form\FormFactoryInterface;
    15| use Symfony\Component\HttpFoundation\JsonResponse;
    16| use Symfony\Component\HttpFoundation\RequestStack;
    17| class SysinfoController extends FormController
    18| {
    19|     public function __construct(
    20|         FormFactoryInterface $formFactory,
    21|         FormFieldHelper $fieldHelper,
    22|         private SysinfoModel $sysinfoModel,
    23|         ManagerRegistry $doctrine,
    24|         ModelFactory $modelFactory,
    25|         UserHelper $userHelper,
    26|         CoreParametersHelper $coreParametersHelper,
    27|         EventDispatcherInterface $dispatcher,
    28|         Translator $translator,
    29|         FlashBag $flashBag,
    30|         RequestStack $requestStack,
    31|         CorePermissions $security,
    32|     ) {
    33|         parent::__construct($formFactory, $fieldHelper, $doctrine, $modelFactory, $userHelper, $coreParametersHelper, $dispatcher, $translator, $flashBag, $requestStack, $security);
    34|     }
    35|     /**
    36|      * @return JsonResponse|\Symfony\Component\HttpFoundation\Response
    37|      */
    38|     public function indexAction()
    39|     {
    40|         if (!$this->user->isAdmin() || $this->coreParametersHelper->get('sysinfo_disabled')) {
    41|             return $this->accessDenied();
    42|         }
    43|         return $this->delegateView([
    44|             'viewParameters' => [
    45|                 'phpInfo'         => $this->sysinfoModel->getPhpInfo(),
    46|                 'requirements'    => $this->sysinfoModel->getRequirements(),
    47|                 'recommendations' => $this->sysinfoModel->getRecommendations(),
    48|                 'folders'         => $this->sysinfoModel->getFolders(),
    49|                 'log'             => $this->sysinfoModel->getLogTail(200),
    50|                 'dbInfo'          => $this->sysinfoModel->getDbInfo(),
    51|             ],
    52|             'contentTemplate' => '@MauticConfig/Sysinfo/index.html.twig',
    53|             'passthroughVars' => [
    54|                 'activeLink'    => '#mautic_sysinfo_index',
    55|                 'mauticContent' => 'sysinfo',
    56|                 'route'         => $this->generateUrl('mautic_sysinfo_index'),
    57|             ],
    58|         ]);
    59|     }
    60| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Event/ConfigBuilderEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-102 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Event;
     3| use Mautic\CoreBundle\Helper\BundleHelper;
     4| use Symfony\Contracts\EventDispatcher\Event;
     5| class ConfigBuilderEvent extends Event
     6| {
     7|     /**
     8|      * @var mixed[]
     9|      */
    10|     private array $forms = [];
    11|     /**
    12|      * @var string[]
    13|      */
    14|     private array $formThemes = [
    15|         '@MauticConfig/FormTheme/_config_file_row.html.twig',
    16|         '@MauticConfig/FormTheme/dsn_row.html.twig',
    17|     ];
    18|     /**
    19|      * @var string[]
    20|      */
    21|     protected array $encodedFields = [];
    22|     public function __construct(
    23|         private BundleHelper $bundleHelper,
    24|     ) {
    25|     }
    26|     /**
    27|      * Set new form to the forms array.
    28|      *
    29|      * @return $this
    30|      */
    31|     public function addForm(array $form)
    32|     {
    33|         if (isset($form['formTheme'])) {
    34|             $this->formThemes[] = $form['formTheme'];
    35|         }
    36|         $this->forms[$form['formAlias']] = $form;
    37|         return $this;
    38|     }
    39|     /**
    40|      * Remove a form to the forms array.
    41|      *
    42|      * @param string $formAlias
    43|      */
    44|     public function removeForm($formAlias): bool
    45|     {
    46|         if (isset($this->forms[$formAlias])) {
    47|             unset($this->forms[$formAlias]);
    48|             return true;
    49|         }
    50|         return false;
    51|     }
    52|     /**
    53|      * Returns the forms array.
    54|      *
    55|      * @return array
    56|      */
    57|     public function getForms()
    58|     {
    59|         return $this->forms;
    60|     }
    61|     /**
    62|      * Returns the formThemes array.
    63|      *
    64|      * @return array
    65|      */
    66|     public function getFormThemes()
    67|     {
    68|         return $this->formThemes;
    69|     }
    70|     /**
    71|      * Get default parameters from config defined in bundles.
    72|      *
    73|      * @return array
    74|      */
    75|     public function getParametersFromConfig($bundle)
    76|     {
    77|         static $allBundles;
    78|         if (empty($allBundles)) {
    79|             $allBundles = $this->bundleHelper->getMauticBundles(true);
    80|         }
    81|         if (isset($allBundles[$bundle]) && $allBundles[$bundle]['config']['parameters']) {
    82|             return $allBundles[$bundle]['config']['parameters'];
    83|         } else {
    84|             return [];
    85|         }
    86|     }
    87|     /**
    88|      * @return $this
    89|      */
    90|     public function addFileFields($fields)
    91|     {
    92|         $this->encodedFields = array_merge($this->encodedFields, (array) $fields);
    93|         return $this;
    94|     }
    95|     /**
    96|      * @return array
    97|      */
    98|     public function getFileFields()
    99|     {
   100|         return $this->encodedFields;
   101|     }
   102| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Event/ConfigEvent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-173 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Event;
     3| use Mautic\CoreBundle\Event\CommonEvent;
     4| use Symfony\Component\HttpFoundation\File\UploadedFile;
     5| use Symfony\Component\HttpFoundation\ParameterBag;
     6| class ConfigEvent extends CommonEvent
     7| {
     8|     /**
     9|      * @var mixed[]
    10|      */
    11|     private array $preserve = [];
    12|     /**
    13|      * @var mixed[]
    14|      */
    15|     private array $errors = [];
    16|     /**
    17|      * @var mixed[]
    18|      */
    19|     private array $fieldErrors = [];
    20|     /**
    21|      * Data got from build form before update.
    22|      */
    23|     private ?array $originalNormData = null;
    24|     /**
    25|      * Data got from build form after update.
    26|      *
    27|      * @var array
    28|      */
    29|     private $normData;
    30|     /**
    31|      * @param mixed[]|null $config
    32|      */
    33|     public function __construct(
    34|         private ?array $config,
    35|         private ParameterBag $post,
    36|     ) {
    37|     }
    38|     /**
    39|      * Returns the config array.
    40|      *
    41|      * @param string $key
    42|      *
    43|      * @return array
    44|      */
    45|     public function getConfig($key = null)
    46|     {
    47|         if ($key) {
    48|             return $this->config[$key] ?? [];
    49|         }
    50|         return $this->config;
    51|     }
    52|     /**
    53|      * Sets the config array.
    54|      *
    55|      * @param string $key
    56|      */
    57|     public function setConfig(array $config, $key = null): void
    58|     {
    59|         if ($key) {
    60|             $this->config[$key] = $config;
    61|         } else {
    62|             $this->config = $config;
    63|         }
    64|     }
    65|     public function getPost(): ParameterBag
    66|     {
    67|         return $this->post;
    68|     }
    69|     /**
    70|      * Set fields such as passwords that will not overwrite existing values
    71|      * if the current is empty.
    72|      *
    73|      * @param array|string $fields
    74|      */
    75|     public function unsetIfEmpty($fields): void
    76|     {
    77|         if (!is_array($fields)) {
    78|             $fields = [$fields];
    79|         }
    80|         $this->preserve = array_merge($this->preserve, $fields);
    81|     }
    82|     /**
    83|      * Return array of fields to unset if empty so that existing values are not
    84|      * overwritten if empty.
    85|      *
    86|      * @return array
    87|      */
    88|     public function getPreservedFields()
    89|     {
    90|         return $this->preserve;
    91|     }
    92|     /**
    93|      * Set error message.
    94|      *
    95|      * @param string      $message     (untranslated)
    96|      * @param array       $messageVars for translation
    97|      * @param string|null $key
    98|      * @param string|null $field
    99|      *
   100|      * @return ConfigEvent
   101|      */
   102|     public function setError($message, $messageVars = [], $key = null, $field = null)
   103|     {
   104|         if (!empty($key) && !empty($field)) {
   105|             if (!isset($this->errors[$key])) {
   106|                 $this->fieldErrors[$key] = [];
   107|             }
   108|             $this->fieldErrors[$key][$field] = [
   109|                 $message,
   110|                 $messageVars,
   111|             ];
   112|             return $this;
   113|         }
   114|         $this->errors[$message] = $messageVars;
   115|         return $this;
   116|     }
   117|     /**
   118|      * Get error messages.
   119|      *
   120|      * @return array
   121|      */
   122|     public function getErrors()
   123|     {
   124|         return $this->errors;
   125|     }
   126|     /**
   127|      * @return array
   128|      */
   129|     public function getFieldErrors()
   130|     {
   131|         return $this->fieldErrors;
   132|     }
   133|     public function getFileContent(UploadedFile $file): string
   134|     {
   135|         $tmpFile = $file->getRealPath();
   136|         $content = trim(file_get_contents($tmpFile));
   137|         @unlink($tmpFile);
   138|         return $content;
   139|     }
   140|     public function encodeFileContents($content): string
   141|     {
   142|         return base64_encode($content);
   143|     }
   144|     /**
   145|      * @return array
   146|      */
   147|     public function getOriginalNormData()
   148|     {
   149|         return $this->originalNormData;
   150|     }
   151|     /**
   152|      * @return ConfigEvent
   153|      */
   154|     public function setOriginalNormData(array $normData)
   155|     {
   156|         $this->originalNormData = $normData;
   157|         return $this;
   158|     }
   159|     /**
   160|      * @return array
   161|      */
   162|     public function getNormData()
   163|     {
   164|         return $this->normData;
   165|     }
   166|     /**
   167|      * @param array $normData
   168|      */
   169|     public function setNormData($normData): void
   170|     {
   171|         $this->normData = $normData;
   172|     }
   173| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/EventListener/ConfigSubscriber.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\EventListener;
     3| use Mautic\ConfigBundle\ConfigEvents;
     4| use Mautic\ConfigBundle\Event\ConfigEvent;
     5| use Mautic\ConfigBundle\Service\ConfigChangeLogger;
     6| use Mautic\CoreBundle\Entity\AuditLogRepository;
     7| use Mautic\CoreBundle\Entity\IpAddressRepository;
     8| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     9| use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    10| class ConfigSubscriber implements EventSubscriberInterface
    11| {
    12|     public function __construct(
    13|         private ConfigChangeLogger $configChangeLogger,
    14|         private IpAddressRepository $ipAddressRepository,
    15|         private CoreParametersHelper $coreParametersHelper,
    16|         private AuditLogRepository $auditLogRepository,
    17|     ) {
    18|     }
    19|     public static function getSubscribedEvents(): array
    20|     {
    21|         return [
    22|             ConfigEvents::CONFIG_POST_SAVE => ['onConfigPostSave', 0],
    23|         ];
    24|     }
    25|     public function onConfigPostSave(ConfigEvent $event): void
    26|     {
    27|         if ($originalNormData = $event->getOriginalNormData()) {
    28|             $normData = $event->getNormData();
    29|             $this->configChangeLogger
    30|                 ->setOriginalNormData($originalNormData)
    31|                 ->log($normData);
    32|             if (!isset($originalNormData['trackingconfig']) && !isset($normData['trackingconfig'])) {
    33|                 return;
    34|             }
    35|             $oldAnonymizeIp = $originalNormData['trackingconfig']['parameters']['anonymize_ip'];
    36|             $newAnonymizeIp = $normData['trackingconfig']['anonymize_ip'];
    37|             if ($oldAnonymizeIp !== $newAnonymizeIp && $newAnonymizeIp && !$this->coreParametersHelper->get('anonymize_ip_address_in_background', false)) {
    38|                 $this->ipAddressRepository->anonymizeAllIpAddress();
    39|                 $this->auditLogRepository->anonymizeAllIpAddress();
    40|             }
    41|         }
    42|     }
    43| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/DataTransformer/DsnTransformer.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ConfigBundle\Form\DataTransformer;
     4| use Mautic\ConfigBundle\Form\Type\EscapeTransformer;
     5| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     6| use Mautic\CoreBundle\Helper\Dsn\Dsn;
     7| use Symfony\Component\Form\DataTransformerInterface;
     8| /**
     9|  * @implements DataTransformerInterface<string, array>
    10|  */
    11| class DsnTransformer implements DataTransformerInterface
    12| {
    13|     private const PASSWORD_MASK = '';
    14|     public function __construct(
    15|         private CoreParametersHelper $coreParametersHelper,
    16|         private EscapeTransformer $escapeTransformer,
    17|         private string $configKey,
    18|         private bool $allowEmpty,
    19|     ) {
    20|     }
    21|     /**
    22|      * @return array<string, mixed>
    23|      */
    24|     public function transform($value): array
    25|     {
    26|         $value = $this->escapeTransformer->transform((string) $value);
    27|         try {
    28|             $dsn = Dsn::fromString($value);
    29|         } catch (\InvalidArgumentException) {
    30|             return [];
    31|         }
    32|         return [
    33|             'scheme'   => $dsn->getScheme(),
    34|             'host'     => $dsn->getHost(),
    35|             'user'     => $dsn->getUser(),
    36|             'password' => $dsn->getPassword() ? self::PASSWORD_MASK : null,
    37|             'port'     => $dsn->getPort(),
    38|             'path'     => $dsn->getPath(),
    39|             'options'  => $dsn->getOptions(),
    40|         ];
    41|     }
    42|     /**
    43|      * @param array<string, mixed> $value
    44|      */
    45|     public function reverseTransform($value): string
    46|     {
    47|         if ($this->allowEmpty && !array_filter($value)) {
    48|             return '';
    49|         }
    50|         $value = $this->escapeTransformer->transform($value);
    51|         $dsn = new Dsn(
    52|             (string) $value['scheme'],
    53|             (string) $value['host'],
    54|             $value['user'],
    55|             $value['password'],
    56|             $value['port'] ? (int) $value['port'] : null,
    57|             $value['path'],
    58|             $value['options'],
    59|         );
    60|         if (self::PASSWORD_MASK === $dsn->getPassword()) {
    61|             $previousDsn = Dsn::fromString($this->coreParametersHelper->get($this->configKey));
    62|             $dsn         = $dsn->setPassword($previousDsn->getPassword());
    63|         }
    64|         return $this->escapeTransformer->reverseTransform((string) $dsn);
    65|     }
    66| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/DataTransformer/DsnTransformerFactory.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ConfigBundle\Form\DataTransformer;
     4| use Mautic\ConfigBundle\Form\Type\EscapeTransformer;
     5| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     6| class DsnTransformerFactory
     7| {
     8|     public function __construct(
     9|         private CoreParametersHelper $coreParametersHelper,
    10|         private EscapeTransformer $escapeTransformer,
    11|     ) {
    12|     }
    13|     public function create(string $configKey, bool $allowEmpty): DsnTransformer
    14|     {
    15|         return new DsnTransformer($this->coreParametersHelper, $this->escapeTransformer, $configKey, $allowEmpty);
    16|     }
    17| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/Helper/RestrictionHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Form\Helper;
     3| use Mautic\ConfigBundle\Mapper\Helper\RestrictionHelper as FieldHelper;
     4| use Symfony\Component\Form\FormInterface;
     5| use Symfony\Contracts\Translation\TranslatorInterface;
     6| class RestrictionHelper
     7| {
     8|     public const MODE_REMOVE = 'remove';
     9|     public const MODE_MASK   = 'mask';
    10|     /**
    11|      * @var string[]
    12|      */
    13|     private array $restrictedFields;
    14|     public function __construct(
    15|         private TranslatorInterface $translator,
    16|         array $restrictedFields,
    17|         private string $displayMode,
    18|     ) {
    19|         $this->restrictedFields = FieldHelper::prepareRestrictions($restrictedFields);
    20|     }
    21|     /**
    22|      * @param FormInterface<mixed> $childType
    23|      * @param FormInterface<mixed> $parentType
    24|      */
    25|     public function applyRestrictions(FormInterface $childType, FormInterface $parentType, array $restrictedFields = null): void
    26|     {
    27|         if (null === $restrictedFields) {
    28|             $restrictedFields = $this->restrictedFields;
    29|         }
    30|         $fieldName = $childType->getName();
    31|         if (array_key_exists($fieldName, $restrictedFields)) {
    32|             if (is_array($restrictedFields[$fieldName])) {
    33|                 foreach ($childType as $grandchild) {
    34|                     $this->applyRestrictions($grandchild, $childType, $restrictedFields[$fieldName]);
    35|                 }
    36|                 return;
    37|             }
    38|             $this->restrictField($childType, $parentType);
    39|         }
    40|     }
    41|     /**
    42|      * @param FormInterface<mixed> $childType
    43|      * @param FormInterface<mixed> $parentType
    44|      */
    45|     private function restrictField(FormInterface $childType, FormInterface $parentType): void
    46|     {
    47|         switch ($this->displayMode) {
    48|             case self::MODE_MASK:
    49|                 $parentType->add(
    50|                     $childType->getName(),
    51|                     $childType->getConfig()->getType()->getInnerType()::class,
    52|                     array_merge(
    53|                         $childType->getConfig()->getOptions(),
    54|                         [
    55|                             'required' => false,
    56|                             'mapped'   => false,
    57|                             'disabled' => true,
    58|                             'attr'     => array_merge($childType->getConfig()->getOptions()['attr'] ?? [], [
    59|                                 'placeholder' => $this->translator->trans('mautic.config.restricted'),
    60|                                 'readonly'    => true,
    61|                             ]),
    62|                         ]
    63|                     )
    64|                 );
    65|                 break;
    66|             case self::MODE_REMOVE:
    67|                 $parentType->remove($childType->getName());
    68|                 break;
    69|         }
    70|     }
    71| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/Type/ConfigFileType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-14 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Form\Type;
     3| use Symfony\Component\Form\AbstractType;
     4| use Symfony\Component\Form\Extension\Core\Type\FileType;
     5| /**
     6|  * @extends AbstractType<mixed>
     7|  */
     8| class ConfigFileType extends AbstractType
     9| {
    10|     public function getParent(): ?string
    11|     {
    12|         return FileType::class;
    13|     }
    14| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/Type/ConfigType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Form\Type;
     3| use Mautic\ConfigBundle\Form\Helper\RestrictionHelper;
     4| use Mautic\CoreBundle\Form\Type\FormButtonsType;
     5| use Symfony\Component\Form\AbstractType;
     6| use Symfony\Component\Form\FormBuilderInterface;
     7| use Symfony\Component\Form\FormEvent;
     8| use Symfony\Component\Form\FormEvents;
     9| use Symfony\Component\OptionsResolver\OptionsResolver;
    10| /**
    11|  * @extends AbstractType<mixed>
    12|  */
    13| class ConfigType extends AbstractType
    14| {
    15|     public function __construct(
    16|         private RestrictionHelper $restrictionHelper,
    17|         private EscapeTransformer $escapeTransformer,
    18|     ) {
    19|     }
    20|     public function buildForm(FormBuilderInterface $builder, array $options): void
    21|     {
    22|         if (isset($options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime'])
    23|             && 3600 === $options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime']
    24|         ) {
    25|             $options['data']['apiconfig']['parameters']['api_oauth2_access_token_lifetime'] = 60;
    26|         }
    27|         if (isset($options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime'])
    28|             && 1_209_600 === $options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime']
    29|         ) {
    30|             $options['data']['apiconfig']['parameters']['api_oauth2_refresh_token_lifetime'] = 14;
    31|         }
    32|         foreach ($options['data'] as $config) {
    33|             if (isset($config['formAlias']) && !empty($config['parameters'])) {
    34|                 $checkThese = array_intersect(array_keys($config['parameters']), $options['fileFields']);
    35|                 foreach ($checkThese as $checkMe) {
    36|                     unset($config['parameters'][$checkMe]);
    37|                 }
    38|                 $builder->add(
    39|                     $config['formAlias'],
    40|                     $config['formType'],
    41|                     [
    42|                         'data' => $config['parameters'],
    43|                     ]
    44|                 );
    45|                 $this->addTransformers($builder->get($config['formAlias']));
    46|             }
    47|         }
    48|         $builder->addEventListener(
    49|             FormEvents::PRE_SET_DATA,
    50|             function (FormEvent $event): void {
    51|                 $form = $event->getForm();
    52|                 foreach ($form as $configForm) {
    53|                     foreach ($configForm as $child) {
    54|                         $this->restrictionHelper->applyRestrictions($child, $configForm);
    55|                     }
    56|                 }
    57|             }
    58|         );
    59|         $builder->add(
    60|             'buttons',
    61|             FormButtonsType::class,
    62|             [
    63|                 'apply_onclick' => 'Mautic.activateBackdrop()',
    64|                 'save_onclick'  => 'Mautic.activateBackdrop()',
    65|             ]
    66|         );
    67|         if (!empty($options['action'])) {
    68|             $builder->setAction($options['action']);
    69|         }
    70|     }
    71|     public function configureOptions(OptionsResolver $resolver): void
    72|     {
    73|         $resolver->setDefaults(
    74|             [
    75|                 'fileFields' => [],
    76|             ]
    77|         );
    78|     }
    79|     private function addTransformers(FormBuilderInterface $builder): void
    80|     {
    81|         if (0 === $builder->count()) {
    82|             $builder->addModelTransformer($this->escapeTransformer);
    83|             return;
    84|         }
    85|         foreach ($builder as $childBuilder) {
    86|             $this->addTransformers($childBuilder);
    87|         }
    88|     }
    89| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Form/Type/DsnType.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-156 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Mautic\ConfigBundle\Form\Type;
     4| use Mautic\ConfigBundle\Form\DataTransformer\DsnTransformerFactory;
     5| use Mautic\CoreBundle\Form\Type\SortableListType;
     6| use Mautic\CoreBundle\Form\Type\StandAloneButtonType;
     7| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     8| use Mautic\CoreBundle\Helper\Dsn\Dsn;
     9| use Symfony\Component\Form\AbstractType;
    10| use Symfony\Component\Form\Extension\Core\Type\NumberType;
    11| use Symfony\Component\Form\Extension\Core\Type\TextType;
    12| use Symfony\Component\Form\FormBuilderInterface;
    13| use Symfony\Component\Form\FormInterface;
    14| use Symfony\Component\Form\FormView;
    15| use Symfony\Component\OptionsResolver\OptionsResolver;
    16| /**
    17|  * @extends AbstractType<array>
    18|  */
    19| class DsnType extends AbstractType
    20| {
    21|     public function __construct(
    22|         private DsnTransformerFactory $dsnTransformerFactory,
    23|         private CoreParametersHelper $coreParametersHelper,
    24|     ) {
    25|     }
    26|     /**
    27|      * @param FormBuilderInterface<array<mixed>|null> $builder
    28|      * @param array<string, mixed>                    $options
    29|      */
    30|     public function buildForm(FormBuilderInterface $builder, array $options): void
    31|     {
    32|         $name     = $builder->getName();
    33|         $onChange = 'Mautic.configDsnTestDisable(this)';
    34|         $attr     = [
    35|             'class'    => 'form-control',
    36|             'onchange' => $onChange,
    37|         ];
    38|         $builder->add(
    39|             'scheme',
    40|             TextType::class,
    41|             [
    42|                 'label'    => 'mautic.config.dsn.scheme',
    43|                 'required' => $options['required'],
    44|                 'attr'     => $attr,
    45|             ]
    46|         );
    47|         $builder->add(
    48|             'host',
    49|             TextType::class,
    50|             [
    51|                 'label'    => 'mautic.config.dsn.host',
    52|                 'required' => false,
    53|                 'attr'     => $attr,
    54|             ]
    55|         );
    56|         $builder->add(
    57|             'port',
    58|             NumberType::class,
    59|             [
    60|                 'label'    => 'mautic.config.dsn.port',
    61|                 'required' => false,
    62|                 'html5'    => true,
    63|                 'attr'     => $attr,
    64|             ]
    65|         );
    66|         $builder->add(
    67|             'user',
    68|             TextType::class,
    69|             [
    70|                 'label'    => 'mautic.config.dsn.user',
    71|                 'required' => false,
    72|                 'attr'     => $attr,
    73|             ]
    74|         );
    75|         $builder->add(
    76|             'password',
    77|             TextType::class,
    78|             [
    79|                 'label'    => 'mautic.config.dsn.password',
    80|                 'required' => false,
    81|                 'attr'     => $attr,
    82|             ]
    83|         );
    84|         $builder->add(
    85|             'path',
    86|             TextType::class,
    87|             [
    88|                 'label'    => 'mautic.config.dsn.path',
    89|                 'required' => false,
    90|                 'attr'     => $attr,
    91|             ]
    92|         );
    93|         $builder->add(
    94|             'options',
    95|             SortableListType::class,
    96|             [
    97|                 'required'        => false,
    98|                 'label'           => 'mautic.config.dsn.options',
    99|                 'attr'            => [
   100|                     'onchange' => $onChange,
   101|                 ],
   102|                 'option_required' => false,
   103|                 'with_labels'     => true,
   104|                 'key_value_pairs' => true,
   105|             ]
   106|         );
   107|         if ($options['test_button']['action'] && $this->getCurrentDsn($name)) {
   108|             $builder->add(
   109|                 'test_button',
   110|                 StandAloneButtonType::class,
   111|                 [
   112|                     'label'    => $options['test_button']['label'],
   113|                     'required' => false,
   114|                     'attr'     => [
   115|                         'class'   => 'btn btn-tertiary btn-sm config-dsn-test-button',
   116|                         'onclick' => sprintf('Mautic.configDsnTestExecute(this, "%s", "%s")', $options['test_button']['action'], $name),
   117|                     ],
   118|                 ]
   119|             );
   120|         }
   121|         $builder->addModelTransformer($this->dsnTransformerFactory->create($name, !$options['required']));
   122|     }
   123|     public function configureOptions(OptionsResolver $resolver): void
   124|     {
   125|         $resolver->setDefaults([
   126|             'label'         => false,
   127|             'error_mapping' => [
   128|                 '.' => 'scheme',
   129|             ],
   130|             'test_button'  => [
   131|                 'action'   => null,
   132|                 'label'    => null,
   133|             ],
   134|         ]);
   135|     }
   136|     /**
   137|      * @phpstan-ignore-next-line
   138|      */
   139|     public function finishView(FormView $view, FormInterface $form, array $options): void
   140|     {
   141|         $view->vars['currentDsn'] = $this->getCurrentDsn($form->getName());
   142|     }
   143|     private function getCurrentDsn(string $name): ?Dsn
   144|     {
   145|         $dsn = (string) $this->coreParametersHelper->get($name);
   146|         try {
   147|             $dsn = Dsn::fromString($dsn);
   148|         } catch (\InvalidArgumentException) {
   149|             return null;
   150|         }
   151|         if ($dsn->getPassword()) {
   152|             $dsn = $dsn->setPassword('SECRET');
   153|         }
   154|         return $dsn;
   155|     }
   156| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Mapper/ConfigMapper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Mapper;
     3| use Mautic\ConfigBundle\Exception\BadFormConfigException;
     4| use Mautic\ConfigBundle\Mapper\Helper\ConfigHelper;
     5| use Mautic\ConfigBundle\Mapper\Helper\RestrictionHelper;
     6| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     7| class ConfigMapper
     8| {
     9|     /**
    10|      * @var mixed[]
    11|      */
    12|     private array $restrictedParameters;
    13|     public function __construct(
    14|         private CoreParametersHelper $parametersHelper,
    15|         array $restrictedParameters = [],
    16|     ) {
    17|         $this->restrictedParameters = RestrictionHelper::prepareRestrictions($restrictedParameters);
    18|     }
    19|     /**
    20|      * @throws BadFormConfigException
    21|      */
    22|     public function bindFormConfigsWithRealValues(array $forms): array
    23|     {
    24|         foreach ($forms as $bundle => $config) {
    25|             if (!isset($config['parameters'])) {
    26|                 throw new BadFormConfigException();
    27|             }
    28|             $forms[$bundle]['parameters'] = $this->mergeWithLocalParameters($forms[$bundle]['parameters']);
    29|         }
    30|         return $forms;
    31|     }
    32|     /**
    33|      * Merges default parameters from each subscribed bundle with the local (real) params.
    34|      */
    35|     private function mergeWithLocalParameters(array $formParameters): array
    36|     {
    37|         $formParameters = RestrictionHelper::applyRestrictions($formParameters, $this->restrictedParameters);
    38|         foreach ($formParameters as $formKey => $defaultValue) {
    39|             $configValue = $this->parametersHelper->get($formKey);
    40|             if (null === $configValue) {
    41|                 continue;
    42|             }
    43|             if (is_array($configValue)) {
    44|                 $configValue = RestrictionHelper::applyRestrictions($configValue, $this->restrictedParameters, $formKey);
    45|                 $formParameters[$formKey] = ConfigHelper::bindNestedConfigValues($configValue, $defaultValue);
    46|                 continue;
    47|             }
    48|             $formParameters[$formKey] = $configValue;
    49|         }
    50|         return $formParameters;
    51|     }
    52| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Model/SysinfoModel.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-151 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Model;
     3| use Doctrine\DBAL\Connection;
     4| use Mautic\CoreBundle\Helper\CoreParametersHelper;
     5| use Mautic\CoreBundle\Helper\PathsHelper;
     6| use Mautic\CoreBundle\Loader\ParameterLoader;
     7| use Mautic\InstallBundle\Configurator\Step\CheckStep;
     8| use Mautic\InstallBundle\Install\InstallService;
     9| use Symfony\Contracts\Translation\TranslatorInterface;
    10| class SysinfoModel
    11| {
    12|     /**
    13|      * @var string|null
    14|      */
    15|     protected $phpInfo;
    16|     /**
    17|      * @var array<string,bool>|null
    18|      */
    19|     protected $folders;
    20|     public function __construct(
    21|         protected PathsHelper $pathsHelper,
    22|         protected CoreParametersHelper $coreParametersHelper,
    23|         private TranslatorInterface $translator,
    24|         protected Connection $connection,
    25|         private InstallService $installService,
    26|         private CheckStep $checkStep,
    27|     ) {
    28|     }
    29|     /**
    30|      * Method to get the PHP info.
    31|      *
    32|      * @return string
    33|      */
    34|     public function getPhpInfo()
    35|     {
    36|         if (!is_null($this->phpInfo)) {
    37|             return $this->phpInfo;
    38|         }
    39|         if (function_exists('phpinfo') && 'cli' !== php_sapi_name()) {
    40|             ob_start();
    41|             $currentTz = date_default_timezone_get();
    42|             date_default_timezone_set('UTC');
    43|             phpinfo(INFO_GENERAL | INFO_CONFIGURATION | INFO_MODULES);
    44|             $phpInfo = ob_get_contents();
    45|             ob_end_clean();
    46|             preg_match_all('#<body[^>]*>(.*)</body>#siU', $phpInfo, $output);
    47|             $output        = preg_replace('#<table[^>]*>#', '<table class="table table-striped">', $output[1][0]);
    48|             $output        = preg_replace('#(\w),(\w)#', '\1, \2', $output);
    49|             $output        = preg_replace('#<hr />#', '', $output);
    50|             $output        = str_replace('<div class="center">', '', $output);
    51|             $output        = preg_replace('#<tr class="h">(.*)<\/tr>#', '<thead><tr class="h">$1</tr></thead><tbody>', $output);
    52|             $output        = str_replace('</table>', '</tbody></table>', $output);
    53|             $output        = str_replace('</div>', '', $output);
    54|             $this->phpInfo = $output;
    55|             date_default_timezone_set($currentTz);
    56|         } elseif (function_exists('phpversion')) {
    57|             $this->phpInfo = $this->translator->trans('mautic.sysinfo.phpinfo.phpversion', ['%phpversion%' => phpversion()]);
    58|         } else {
    59|             $this->phpInfo = $this->translator->trans('mautic.sysinfo.phpinfo.missing');
    60|         }
    61|         return $this->phpInfo;
    62|     }
    63|     /**
    64|      * @return string[]
    65|      */
    66|     public function getRecommendations(): array
    67|     {
    68|         return $this->installService->checkOptionalSettings($this->checkStep);
    69|     }
    70|     /**
    71|      * @return string[]
    72|      */
    73|     public function getRequirements(): array
    74|     {
    75|         return $this->installService->checkRequirements($this->checkStep);
    76|     }
    77|     /**
    78|      * Method to get important folders with a writable flag.
    79|      *
    80|      * @return array
    81|      */
    82|     public function getFolders()
    83|     {
    84|         if (!is_null($this->folders)) {
    85|             return $this->folders;
    86|         }
    87|         $importantFolders = [
    88|             ParameterLoader::getLocalConfigFile($this->pathsHelper->getSystemPath('root').'/app'),
    89|             $this->coreParametersHelper->get('cache_path'),
    90|             $this->coreParametersHelper->get('log_path'),
    91|             $this->coreParametersHelper->get('upload_dir'),
    92|             $this->pathsHelper->getSystemPath('images', true),
    93|             $this->pathsHelper->getSystemPath('translations', true),
    94|         ];
    95|         foreach ($importantFolders as $folder) {
    96|             $folderPath = realpath($folder);
    97|             $folderKey  = $folderPath ?: $folder;
    98|             $isWritable = $folderPath && is_writable($folderPath);
    99|             $this->folders[$folderKey] = $isWritable;
   100|         }
   101|         return $this->folders;
   102|     }
   103|     /**
   104|      * Method to tail (a few last rows) of a file.
   105|      *
   106|      * @param int $lines
   107|      */
   108|     public function getLogTail($lines = 10): ?string
   109|     {
   110|         $log = $this->coreParametersHelper->get('log_path').'/mautic_'.MAUTIC_ENV.'-'.date('Y-m-d').'.php';
   111|         if (!file_exists($log)) {
   112|             return null;
   113|         }
   114|         return $this->tail($log, $lines);
   115|     }
   116|     public function getDbInfo(): array
   117|     {
   118|         return [
   119|             'version'  => $this->connection->executeQuery('SELECT VERSION()')->fetchOne(),
   120|             'driver'   => $this->connection->getParams()['driver'],
   121|             'platform' => $this->connection->getDatabasePlatform()::class,
   122|         ];
   123|     }
   124|     /**
   125|      * Method to tail (a few last rows) of a file.
   126|      *
   127|      * @param int $lines
   128|      * @param int $buffer
   129|      */
   130|     public function tail($filename, $lines = 10, $buffer = 4096): string
   131|     {
   132|         $f      = fopen($filename, 'rb');
   133|         $output = '';
   134|         fseek($f, -1, SEEK_END);
   135|         if ("\n" != fread($f, 1)) {
   136|             --$lines;
   137|         }
   138|         while (ftell($f) > 0 && $lines >= 0) {
   139|             $seek = min(ftell($f), $buffer);
   140|             fseek($f, -$seek, SEEK_CUR);
   141|             $output = ($chunk = fread($f, $seek)).$output;
   142|             fseek($f, -mb_strlen($chunk, '8bit'), SEEK_CUR);
   143|             $lines -= substr_count($chunk, "\n");
   144|         }
   145|         while ($lines++ < 0) {
   146|             $output = substr($output, strpos($output, "\n") + 1);
   147|         }
   148|         fclose($f);
   149|         return $output;
   150|     }
   151| }


# ====================================================================
# FILE: app/bundles/ConfigBundle/Service/ConfigChangeLogger.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-98 ---
     1| <?php
     2| namespace Mautic\ConfigBundle\Service;
     3| use Mautic\CoreBundle\Helper\IpLookupHelper;
     4| use Mautic\CoreBundle\Model\AuditLogModel;
     5| use Symfony\Component\HttpFoundation\File\UploadedFile;
     6| /**
     7|  * Compare normalized for data and log changes.
     8|  */
     9| class ConfigChangeLogger
    10| {
    11|     /**
    12|      * Keys to remove from log.
    13|      *
    14|      * @var string[]
    15|      */
    16|     private array $filterKeys = [
    17|         'transifex_password',
    18|         'mailer_is_owner',
    19|     ];
    20|     /**
    21|      * @var mixed[]|null
    22|      */
    23|     private ?array $originalNormData = null;
    24|     public function __construct(
    25|         private IpLookupHelper $ipLookupHelper,
    26|         private AuditLogModel $auditLogModel,
    27|     ) {
    28|     }
    29|     /**
    30|      * @return ConfigChangeLogger
    31|      */
    32|     public function setOriginalNormData(array $originalNormData)
    33|     {
    34|         $this->originalNormData = $originalNormData;
    35|         return $this;
    36|     }
    37|     /**
    38|      * Log changes if something was changed.
    39|      * Diff is based on form normalized data before and after post.
    40|      *
    41|      * @see Form::getNormData()
    42|      */
    43|     public function log(array $postNormData): void
    44|     {
    45|         if (null === $this->originalNormData) {
    46|             throw new \RuntimeException('Set original normalized data at first');
    47|         }
    48|         $originalData = $this->normalizeData($this->originalNormData);
    49|         $postData     = $this->filterData($this->normalizeData($postNormData));
    50|         $diff = [];
    51|         foreach ($postData as $key => $value) {
    52|             if (array_key_exists($key, $originalData) && $originalData[$key] != $value) {
    53|                 if ($value instanceof UploadedFile) {
    54|                     $value = $value->getFilename();
    55|                 }
    56|                 $diff[$key] = $value;
    57|             }
    58|         }
    59|         if (empty($diff)) {
    60|             return;
    61|         }
    62|         $log = [
    63|             'bundle'    => 'config',
    64|             'object'    => 'config',
    65|             'objectId'  => 0,
    66|             'action'    => 'update',
    67|             'details'   => $diff,
    68|             'ipAddress' => $this->ipLookupHelper->getIpAddressFromRequest(),
    69|         ];
    70|         $this->auditLogModel->writeToLog($log);
    71|     }
    72|     /**
    73|      * Some form data (AssetBundle) has 'parameters' inside array too.
    74|      * Normalize all.
    75|      */
    76|     private function normalizeData(array $data): array
    77|     {
    78|         $key = 'parameters';
    79|         $normData = [];
    80|         foreach ($data as $values) {
    81|             if (array_key_exists($key, $values)) {
    82|                 $normData = array_merge($normData, $values[$key]);
    83|             } else {
    84|                 $normData = array_merge($normData, $values);
    85|             }
    86|         }
    87|         return $normData;
    88|     }
    89|     /**
    90|      * Filter unused keys from post data.
    91|      */
    92|     private function filterData(array $data): array
    93|     {
    94|         $keys = $this->filterKeys;
    95|         return array_filter($data, fn ($key): bool => !in_array($key, $keys),
    96|             ARRAY_FILTER_USE_KEY);
    97|     }
    98| }

