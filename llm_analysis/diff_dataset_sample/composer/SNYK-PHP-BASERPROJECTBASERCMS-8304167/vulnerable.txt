# ====================================================================
# FILE: __assets/plugins/baser-core/config/bootstrap-4.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-294 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @since           baserCMS v 0.1.0
     9|  * @license         https://basercms.net/license/index.html
    10|  */
    11| use BaserCore\Service\BcFrontService;
    12| use BaserCore\Utility\BcUtil;
    13| require CORE_PATH . 'Baser' . DS . 'Config' . DS . 'paths.php';
    14| require BASER . 'basics.php';
    15| require BASER . 'Error' . DS . 'exceptions.php';
    16| /**
    17|  * Baserパス追加
    18|  */
    19| App::build([
    20|     'View' => [WWW_ROOT],
    21| ], App::PREPEND);
    22| App::build([
    23|     'Controller' => [BASER_CONTROLLERS],
    24|     'Model' => [BASER_MODELS],
    25|     'Model/Behavior' => [BASER_BEHAVIORS],
    26|     'Model/Datasource' => [BASER_DATASOURCE],
    27|     'Model/Datasource/Database' => [BASER_DATABASE],
    28|     'Controller/Component' => [BASER_COMPONENTS],
    29|     'Controller/Component/Auth' => [BASER_COMPONENTS . 'Auth' . DS],
    30|     'View' => [BASER_VIEWS],
    31|     'View/Helper' => [BASER_HELPERS],
    32|     'Plugin' => [BASER_PLUGINS],
    33|     'Vendor' => [BASER_VENDORS],
    34|     'Locale' => [BASER_LOCALES],
    35|     'Lib' => [BASER_LIBS],
    36|     'Console' => [BASER_CONSOLES],
    37|     'Console/Command' => [BASER_CONSOLES . 'Command' . DS],
    38| ], App::APPEND);
    39| App::build([
    40|     'Event' => [APP . 'Event', BASER_EVENTS],
    41|     'Routing' => [BASER . 'Routing' . DS],
    42|     'Routing/Filter' => [BASER . 'Routing' . DS . 'Filter' . DS],
    43|     'Routing/Route' => [BASER . 'Routing' . DS . 'Route' . DS],
    44|     'Configure' => [BASER . 'Configure' . DS],
    45|     'TestSuite' => [BASER_TEST_SUITE],
    46|     'TestSuite/Reporter' => [BASER_TEST_SUITE . 'Reporter' . DS],
    47|     'TestSuite/Fixture' => [BASER_TEST_SUITE . 'Fixture' . DS],
    48|     'Network' => [BASER . 'Network' . DS]
    49| ], App::REGISTER);
    50| /**
    51|  * ディスパッチャーフィルターを追加
    52|  */
    53| $filters = Configure::read('Dispatcher.filters');
    54| if (!is_array($filters)) {
    55|     $filters = [];
    56| }
    57| Configure::write('Dispatcher.filters',
    58|     array_merge(
    59|         $filters,
    60|         [
    61|             'BcAssetDispatcher',
    62|             'BcCacheDispatcher',
    63|             'BcRequestFilter',
    64|             'BcRedirectMainSiteFilter',
    65|             'BcRedirectSubSiteFilter'
    66|         ]
    67|     )
    68| );
    69| /**
    70|  * baserUrl取得
    71|  * BC_DEPLOY_PATTERN の定義より後に実行
    72|  */
    73| define('BC_BASE_URL', BcUtil::baseUrl());
    74| /**
    75|  * 静的ファイルの読み込みの場合はスキップ
    76|  */
    77| $assetRegex = '/^' . preg_quote(BC_BASE_URL, '/') . '.*?(css|js|img)' . '\/.+\.(js|css|gif|jpg|jpeg|png)$/';
    78| $assetRegexTheme = '/^' . preg_quote(BC_BASE_URL, '/') . 'theme\/[^\/]+?\/(css|js|img)' . '\/.+\.(js|css|gif|jpg|jpeg|png)$/';
    79| $nonAssets = '/^' . preg_quote(BC_BASE_URL . Configure::read('Routing.prefixes.0') . '/theme_files/edit/', '/') . '.*?(css|js|img)' . '\/.+\.(js|css|gif|jpg|jpeg|png)$/';
    80| $uri = @$_SERVER['REQUEST_URI'];
    81| if (preg_match($nonAssets, $uri) === 0) {
    82|     if (preg_match($assetRegex, $uri) || preg_match($assetRegexTheme, $uri)) {
    83|         Configure::write('BcRequest.asset', true);
    84|         App::uses('ClassRegistry', 'Utility');
    85|         $plugins = getEnablePlugins();
    86|         foreach($plugins as $plugin) {
    87|             CakePlugin::load($plugin['Plugin']['name']);
    88|             CakePlugin::load($plugin['Plugin']['name'], [
    89|                 'bootstrap' => file_exists(CakePlugin::path($plugin['Plugin']['name']) . 'Config' . DS . 'bootstrap.php')
    90|             ]);
    91|         }
    92|     }
    93| }
    94| /**
    95|  * クラスローダー設定
    96|  */
    97| App::uses('AppModel', 'Model');
    98| App::uses('BcAppModel', 'Model');
    99| App::uses('BcCache', 'Model/Behavior');
   100| App::uses('ClassRegistry', 'Utility');
   101| App::uses('Multibyte', 'I18n');
   102| App::uses('BcCsv', 'Model/Datasource/Database');
   103| App::uses('BcPostgres', 'Model/Datasource/Database');
   104| App::uses('BcSqlite', 'Model/Datasource/Database');
   105| App::uses('BcMysql', 'Model/Datasource/Database');
   106| App::uses('PhpReader', 'Configure');
   107| App::uses('CakeSession', 'Model/Datasource');
   108| App::uses('Folder', 'Utility');
   109| App::uses('File', 'Utility');
   110| App::uses('BcUtil', 'Lib');
   111| App::uses('BcControllerEventListener', 'Event');
   112| App::uses('BcModelEventListener', 'Event');
   113| App::uses('BcViewEventListener', 'Event');
   114| App::uses('BcHelperEventListener', 'Event');
   115| App::uses('BcManagerShell', 'Console/Command');
   116| App::uses('CakeRequest', 'Network');
   117| App::uses('BcSite', 'Lib');
   118| App::uses('BcAgent', 'Lib');
   119| App::uses('BcLang', 'Lib');
   120| /**
   121|  * 設定ファイル読み込み
   122|  * install.php で設定している為、一旦読み込んで再設定
   123|  */
   124| $baserSettings = [];
   125| $baserSettings['BcEnv'] = Configure::read('BcEnv');
   126| $baserSettings['BcApp'] = Configure::read('BcApp');
   127| Configure::config('baser', new PhpReader(BASER_CONFIGS));
   128| if (Configure::load('setting', 'baser') === false) {
   129|     $config = [];
   130|     include BASER_CONFIGS . 'setting.php';
   131|     Configure::write($config);
   132| }
   133| if (BcUtil::isInstalled() && $baserSettings) {
   134|     foreach($baserSettings as $key1 => $settings) {
   135|         if ($settings) {
   136|             foreach($settings as $key2 => $setting) {
   137|                 Configure::write($key1 . '.' . $key2, $setting);
   138|             }
   139|         }
   140|     }
   141| }
   142| /**
   143|  * セッション設定
   144|  */
   145| if (BcUtil::isInstalled()) {
   146|     require APP . 'Config' . DS . 'session.php';
   147| }
   148| /**
   149|  * パラメーター取得
   150|  */
   151| $parameter = getUrlParamFromEnv();
   152| if (BcUtil::isInstalled()) {
   153|     /**
   154|      * キャッシュ設定
   155|      */
   156|     $cacheEngine = Configure::read('BcCache.engine');
   157|     $cachePrefix = Configure::read('BcCache.prefix');
   158|     $cacheDuration = Configure::read('BcCache.duration');
   159|     Cache::config('_cake_model_', [
   160|         'engine' => $cacheEngine,
   161|         'prefix' => $cachePrefix . 'cake_model_',
   162|         'path' => CACHE . 'models' . DS,
   163|         'duration' => $cacheDuration
   164|     ]);
   165|     Cache::config('_cake_core_', [
   166|         'engine' => $cacheEngine,
   167|         'prefix' => $cachePrefix . 'cake_core_',
   168|         'path' => CACHE . 'persistent' . DS,
   169|         'duration' => $cacheDuration
   170|     ]);
   171|     Cache::config('_cake_data_', [
   172|         'engine' => $cacheEngine,
   173|         'path' => CACHE . 'datas',
   174|         'probability' => 100,
   175|         'prefix' => $cachePrefix . 'cake_data_',
   176|         'lock' => true,
   177|         'duration' => $cacheDuration
   178|     ]);
   179|     Cache::config('_cake_element_', [
   180|         'engine' => $cacheEngine,
   181|         'path' => CACHE . 'views',
   182|         'probability' => 100,
   183|         'lock' => true,
   184|         'duration' => Configure::read('BcCache.viewDuration')
   185|     ]);
   186|     Cache::config('_bc_env_', [
   187|         'engine' => $cacheEngine,
   188|         'probability' => 100,
   189|         'path' => CACHE . 'environment',
   190|         'prefix' => $cachePrefix . 'cake_env_',
   191|         'lock' => false,
   192|         'duration' => $cacheDuration
   193|     ]);
   194|     /**
   195|      * サイト基本設定を読み込む
   196|      * bootstrapではモデルのロードは行わないようにする為ここで読み込む
   197|      */
   198|     if (empty($_GET['requestview']) || $_GET['requestview'] != 'false') {
   199|         loadSiteConfig();
   200|     }
   201| }
   202| /**
   203|  * テーマヘルパーのパスを追加する
   204|  */
   205| if (BcUtil::isInstalled() || isConsole()) {
   206|     App::build([
   207|         'View/Helper' => [BASER_THEMES . Configure::read('BcSite.theme') . DS . 'Helper' . DS]
   208|     ], App::PREPEND);
   209| }
   210| /**
   211|  * プラグインをCake側で有効化
   212|  *
   213|  * カレントテーマのプラグインも読み込む
   214|  * サブサイトに適用されているプラグインも読み込む
   215|  */
   216| if (BcUtil::isInstalled() && !$isUpdater && !$isMaintenance) {
   217|     $sitesTable = \Cake\ORM\TableRegistry::getTableLocator()->get('BaserCore.Sites');
   218|     $sites = $sitesTable->find()->all();
   219|     $pluginPaths = [ROOT . DS . 'Plugin' . DS];
   220|     foreach($sites as $site) {
   221|         if ($site->theme) {
   222|             $pluginPaths[] = BASER_THEMES . $site->theme . DS . 'Plugin' . DS;
   223|         }
   224|     }
   225|     App::build(['Plugin' => $pluginPaths], App::PREPEND);
   226|     $plugins = getEnablePlugins();
   227|     foreach($plugins as $plugin) {
   228|         loadPlugin($plugin['Plugin']['name'], $plugin['Plugin']['priority']);
   229|     }
   230|     /**
   231|      * アセットの場合負荷を軽減するため以降の処理を終了
   232|      */
   233|     if (Configure::read('BcRequest.asset')) {
   234|         return;
   235|     }
   236|     /**
   237|      * イベント登録
   238|      */
   239|     App::uses('CakeEventManager', 'Event');
   240|     App::uses('BcControllerEventDispatcher', 'Event');
   241|     App::uses('BcModelEventDispatcher', 'Event');
   242|     App::uses('BcViewEventDispatcher', 'Event');
   243|     $CakeEvent = CakeEventManager::instance();
   244|     $CakeEvent->attach(new BcControllerEventDispatcher());
   245|     $CakeEvent->attach(new BcModelEventDispatcher());
   246|     $CakeEvent->attach(new BcViewEventDispatcher());
   247|     /**
   248|      * テーマの bootstrap を実行する
   249|      */
   250|     if (!BcUtil::isAdminSystem($parameter)) {
   251|         $themePath = WWW_ROOT . 'theme' . DS . Configure::read('BcSite.theme') . DS;
   252|         $themeBootstrap = $themePath . 'Config' . DS . 'bootstrap.php';
   253|         if (file_exists($themeBootstrap)) {
   254|             include $themeBootstrap;
   255|         }
   256|     }
   257| }
   258| /**
   259|  * メモリー設定
   260|  */
   261| $memoryLimit = (int)ini_get('memory_limit');
   262| if ($memoryLimit < 32 && $memoryLimit != -1) {
   263|     ini_set('memory_limit', '32M');
   264| }
   265| /**
   266|  * ロケール設定
   267|  * 指定しないと 日本語入りの basename 等が失敗する
   268|  */
   269| setlocale(LC_ALL, 'ja_JP.UTF-8');
   270| /**
   271|  * セッションスタート
   272|  */
   273| $Session = new CakeSession();
   274| $Session->start();
   275| /**
   276|  * Viewのキャッシュ設定・ログの設定
   277|  */
   278| if (Configure::read('debug') == 0) {
   279|     if (isset($_SESSION) && session_id()) {
   280|         if (isset($_SESSION['Auth'][Configure::read('BcPrefixAuth.Admin.sessionKey')])) {
   281|             Configure::write('Cache.check', false);
   282|         }
   283|     }
   284| } else {
   285|     Configure::write('Cache.check', false);
   286|     clearViewCache();
   287| }
   288| if (Configure::read('Cache.check')) {
   289|     $sites = \Cake\ORM\TableRegistry::getTableLocator()->get('BaserCore.Sites');
   290|     $site = $sites->findByUrl($_SERVER['REQUEST_URI']);
   291|     if ($site->use_subdomain) {
   292|         Configure::write('Cache.viewPrefix', $site->alias);
   293|     }
   294| }


# ====================================================================
# FILE: __assets/plugins/baser-core/config/paths-4.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-94 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @since           baserCMS v 0.1.0
     9|  * @license         https://basercms.net/license/index.html
    10|  */
    11| /**
    12|  * Baserディレクトリ名
    13|  */
    14| define('BASER', CORE_PATH . 'Baser' . DS);
    15| /**
    16|  * Baserコントローラーパス
    17|  */
    18| define('BASER_CONTROLLERS', BASER . 'Controller' . DS);
    19| /**
    20|  * Baserモデルパス
    21|  */
    22| define('BASER_MODELS', BASER . 'Model' . DS);
    23| /**
    24|  * Baserビューパス
    25|  */
    26| define('BASER_VIEWS', BASER . 'View' . DS);
    27| /**
    28|  * BaserVendorsパス
    29|  */
    30| define('BASER_VENDORS', BASER . 'Vendor' . DS);
    31| /**
    32|  * Baserコンポーネント
    33|  */
    34| define('BASER_COMPONENTS', BASER_CONTROLLERS . 'Component' . DS);
    35| /**
    36|  * Baserヘルパー
    37|  */
    38| define('BASER_HELPERS', BASER_VIEWS . 'Helper' . DS);
    39| /**
    40|  * Baserビヘイビア
    41|  */
    42| define('BASER_BEHAVIORS', BASER_MODELS . 'Behavior' . DS);
    43| /**
    44|  * Baserデータソース
    45|  */
    46| define('BASER_DATASOURCE', BASER_MODELS . 'Datasource' . DS);
    47| /**
    48|  * Baserデータベース
    49|  */
    50| define('BASER_DATABASE', BASER_DATASOURCE . 'Database' . DS);
    51| /**
    52|  * Baserプラグイン
    53|  */
    54| define('BASER_PLUGINS', BASER . 'Plugin' . DS);
    55| /**
    56|  * Baserコンフィグ
    57|  */
    58| define('BASER_CONFIGS', BASER . 'Config' . DS);
    59| /**
    60|  * BaserLocale
    61|  */
    62| define('BASER_LOCALES', BASER . 'Locale' . DS);
    63| /**
    64|  * BaserEvent
    65|  */
    66| define('BASER_EVENTS', BASER . 'Event' . DS);
    67| /**
    68|  * Baser Libs
    69|  */
    70| define('BASER_LIBS', BASER . 'Lib' . DS);
    71| /**
    72|  * Baser TestSuite
    73|  */
    74| define('BASER_TEST_SUITE', BASER_LIBS . 'TestSuite' . DS);
    75| /**
    76|  * Baser TestCase
    77|  */
    78| define('BASER_TEST_CASES', BASER . 'Test' . DS . 'Case');
    79| /**
    80|  * Baser Console
    81|  */
    82| define('BASER_CONSOLES', BASER . 'Console' . DS);
    83| /**
    84|  * Baser webroot
    85|  */
    86| define('BASER_WEBROOT', BASER . 'webroot' . DS);
    87| /**
    88|  * Baserテーマ
    89|  */
    90| if (is_dir(WWW_ROOT . 'theme')) {
    91|     define('BASER_THEMES', WWW_ROOT . 'theme' . DS);
    92| } elseif (is_dir(ROOT . DS . 'theme')) {
    93|     define('BASER_THEMES', ROOT . DS . 'theme' . DS);
    94| }


# ====================================================================
# FILE: __assets/plugins/baser-core/config/routes-4.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-70 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @since           baserCMS v 0.1.0
     9|  * @license         https://basercms.net/license/index.html
    10|  */
    11| use BaserCore\Utility\BcUtil;
    12| use Cake\Core\Configure;
    13| $isMaintenance = Configure::read('BcRequest.isMaintenance');
    14| $isUpdater = Configure::read('BcRequest.isUpdater');
    15| Configure::write('BcRequest.routerLoaded', true);
    16| /**
    17|  * vendors内の静的ファイルの読み込みの場合はスキップ
    18|  */
    19| if (Configure::read('BcRequest.asset') || $isMaintenance) {
    20|     return;
    21| }
    22| /**
    23|  * インストーラー
    24|  */
    25| if (!BcUtil::isInstalled()) {
    26|     Router::connect('/', ['controller' => 'installations', 'action' => 'index']);
    27|     Router::connect('/install', ['controller' => 'installations', 'action' => 'index']);
    28|     return;
    29| }
    30| App::uses('BaserPluginApp', 'Controller');
    31| App::uses('BaserPluginAppModel', 'Model');
    32| /**
    33|  * プラグイン
    34|  *
    35|  * コンテンツ管理ルーティングよりも優先させる為に先に記述
    36|  */
    37| $pluginMatch = [];
    38| $plugins = CakePlugin::loaded();
    39| if ($plugins) {
    40|     foreach($plugins as $key => $value) {
    41|         $plugins[$key] = Inflector::underscore($value);
    42|     }
    43|     $pluginMatch = ['plugin' => implode('|', $plugins)];
    44|     Router::connect("/:plugin/:controller/:action/*", [], $pluginMatch);
    45| }
    46| /**
    47|  * 名前付きパラメータを追加
    48|  */
    49| Router::connectNamed(['sortmode', 'num', 'page', 'sort', 'direction']);
    50| /**
    51|  * 認証プレフィックス
    52|  */
    53| $authPrefixes = Configure::read('BcPrefixAuth');
    54| if ($authPrefixes && is_array($authPrefixes)) {
    55|     foreach($authPrefixes as $prefix => $authPrefix) {
    56|         if (!empty($authPrefix['alias'])) {
    57|             $alias = $authPrefix['alias'];
    58|         } else {
    59|             $alias = $prefix;
    60|         }
    61|         Router::connect("/{$alias}", ['prefix' => $prefix, $prefix => true, 'controller' => 'dashboard', 'action' => 'index']);
    62|         if (CakePlugin::loaded()) {
    63|             Router::connect("/{$alias}/:plugin/:controller/:action/*", ['prefix' => $prefix, $prefix => true], $pluginMatch);
    64|             Router::connect("/{$alias}/:plugin/:controller/", ['prefix' => $prefix, $prefix => true], $pluginMatch);
    65|             Router::connect("/{$alias}/:plugin/:action/*", ['prefix' => $prefix, $prefix => true], $pluginMatch);
    66|         }
    67|         Router::connect("/{$alias}/:controller/:action/*", ['prefix' => $prefix, $prefix => true]);
    68|         Router::connect("/{$alias}/:controller/", ['prefix' => $prefix, $prefix => true]);
    69|     }
    70| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Controller/Component/BcEmailComponent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-323 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Controller\Component;
    12| use Cake\Controller\Component;
    13| /**
    14|  * Class BcEmailComponent
    15|  *
    16|  * Email 拡張モデル
    17|  *
    18|  * @package Baser.Controller.Component
    19|  */
    20| class BcEmailComponent extends Component
    21| {
    22|     /**
    23|      * プラグイン名
    24|      * CUSTOMIZE ADD 2011/05/07 ryuring
    25|      * プラグインのテンプレートを指定できるようにした
    26|      *
    27|      * @var string
    28|      */
    29|     public $plugin = null;
    30|     /**
    31|      * Send an email using the specified content, template and layout
    32|      *
    33|      * @param mixed $content Either an array of text lines, or a string with contents
    34|      * @param string $template Template to use when sending email
    35|      * @param string $layout Layout to use to enclose email body
    36|      * @return    boolean Success
    37|      * @access    public
    38|      */
    39|     public function send($content = null, $template = null, $layout = null)
    40|     {
    41|         $this->__createHeader();
    42|         if ($template) {
    43|             $this->template = $template;
    44|         }
    45|         if ($layout) {
    46|             $this->layout = $layout;
    47|         }
    48|         if (is_array($content)) {
    49|             $content = implode("\n", $content) . "\n";
    50|         }
    51|         $message = $this->__wrap($content);
    52|         if ($this->template === null) {
    53|             $message = $this->__formatMessage($message);
    54|         } else {
    55|             $message = $this->__renderTemplate($message);
    56|         }
    57|         $message = $this->___wrap($message);
    58|         $message[] = '';
    59|         foreach($message as $key => $line) {
    60|             $enc = mb_detect_encoding($line);
    61|             if (strtolower($this->charset) !== 'jis') {
    62|                 $line = mb_convert_kana($line, 'K', $enc);
    63|             }
    64|             $message[$key] = mb_convert_encoding($line, $this->charset, $enc);
    65|         }
    66|         $this->__message = $message;
    67|         if (!empty($this->attachments)) {
    68|             $this->__attachFiles();
    69|         }
    70|         if (!is_null($this->__boundary)) {
    71|             $this->__message[] = '';
    72|             $this->__message[] = '--' . $this->__boundary . '--';
    73|             $this->__message[] = '';
    74|         }
    75|         if ($this->_debug) {
    76|             return $this->__debug();
    77|         }
    78|         $__method = '__' . $this->delivery;
    79|         $sent = $this->$__method();
    80|         $this->__header = [];
    81|         $this->__message = [];
    82|         return $sent;
    83|     }
    84|     /**
    85|      * Wrap the message using EmailComponent::$lineLength
    86|      *
    87|      * @param string $message Message to wrap
    88|      * @return    string Wrapped message
    89|      */
    90|     private function __wrap($message)
    91|     {
    92|         $message = $this->__strip($message);
    93|         $message = str_replace(["\r\n", "\r"], "\n", $message);
    94|         $lines = explode("\n", $message);
    95|         return $this->___wrap($lines);
    96|     }
    97|     /**
    98|      * テンプレートを整形後に再度ラップする必要があるのでラップ処理の部分だけを分離
    99|      *
   100|      * @param array $lines
   101|      * @return array
   102|      */
   103|     private function ___wrap($lines)
   104|     {
   105|         $formatted = [];
   106|         if ($this->_lineLength !== null) {
   107|             trigger_error('_lineLength cannot be accessed please use lineLength', E_USER_WARNING);
   108|             $this->lineLength = $this->_lineLength;
   109|         }
   110|         foreach($lines as $line) {
   111|             if (substr($line, 0, 1) == '.') {
   112|                 $line = '.' . $line;
   113|             }
   114|             $enc = mb_detect_encoding($line);
   115|             $formatted = array_merge($formatted, $this->mbFold($line, $this->lineLength, $enc));
   116|         }
   117|         $formatted[] = '';
   118|         return $formatted;
   119|     }
   120|     /**
   121|      * Encode the specified string using the current charset
   122|      *
   123|      * @param string $subject String to encode
   124|      * @return    string    Encoded string
   125|      * @access    private
   126|      */
   127|     private function __encode($subject)
   128|     {
   129|         $subject = $this->__strip($subject);
   130|         if (strtolower($this->charset) !== 'iso-8859-15') {
   131|             $enc = mb_detect_encoding($subject);
   132|             $_enc = mb_internal_encoding();
   133|             mb_internal_encoding($enc);
   134|             /*
   135|               $start = "=?" . $this->charset . "?B?";
   136|               $end = "?=";
   137|               $spacer = $end . "\n " . $start;
   138|               $length = 75 - strlen($start) - strlen($end);
   139|               $length = $length - ($length % 4);
   140|               $subject = base64_encode($subject);
   141|               $subject = chunk_split($subject, $length, $spacer);
   142|               $spacer = preg_quote($spacer);
   143|               $subject = preg_replace("/" . $spacer . "$/", "", $subject);
   144|               $subject = $start . $subject . $end;
   145|              */
   146|             $subject = mb_encode_mimeheader($subject, $this->charset, 'B', Configure::read('BcEmail.lfcode'));
   147|             mb_internal_encoding($_enc);
   148|         }
   149|         return $subject;
   150|     }
   151|     /**
   152|      * マルチバイト文字を考慮したfolding(折り畳み)処理
   153|      *
   154|      * @param mixed $str foldingを行う文字列or文字列の配列
   155|      *                   文字列に改行が含まれている場合は改行位置でも分割される
   156|      * @param integer $width 一行の幅(バイト数)。4以上でなければならない
   157|      * @param string $encoding $strの文字エンコーディング
   158|      *                         省略した場合は内部文字エンコーディングを使用する
   159|      * @return array 一行ずつに分けた文字列の配列
   160|      *
   161|      * NOTE: いわゆる半角/全角といった見た目ではなく、
   162|      *       バイト数によって処理が行われるので、文字エンコーディングによって
   163|      *       結果が変わる可能性がある。
   164|      *
   165|      *       例えば半角カナはShift-JISでは1バイトだが、EUC-JPでは2バイトなので、
   166|      *       $width=10の場合Shift-JISなら10文字だが、EUC-JPでは5文字になる。
   167|      *
   168|      *       全角/半角といった見た目で処理をするにはmb_strwidth()を利用した
   169|      *       実装が必要となる。
   170|      *
   171|      * TODO: 日本語禁則処理(Japanese Hyphenation)
   172|      *       行頭禁則文字は濁点/半濁点の応用でいけるので
   173|      *       行末禁則文字の処理を加えれば対応できそう
   174|      *
   175|      *       ……と思ったけど、禁則文字が$widthを超える分だけ並んでたら
   176|      *       どうすればいいんだろう
   177|      *       禁則処理をした結果、桁あふれを起こす場合は禁則処理を無視して
   178|      *       強制的に$widthで改行する、とか？
   179|      */
   180|     public function mbFold($str, $width, $encoding = null)
   181|     {
   182|         assert('$width >= 4');
   183|         if (!isset($str)) {
   184|             return null;
   185|         }
   186|         if (!isset($encoding)) {
   187|             $encoding = mb_internal_encoding();
   188|         }
   189|         $strings = [];
   190|         foreach((array)$str as $s) {
   191|             $strings = array_merge($strings, preg_split('/\x0d\x0a|\x0d|\x0a/', $s));
   192|         }
   193|         $lines = [];
   194|         foreach($strings as $string) {
   195|             $len = mb_strlen($string, $encoding);
   196|             for($i = 0, $line = ''; $i < $len; $i++) {
   197|                 $char = mb_substr($string, $i, 1, $encoding);
   198|                 if ($i + 1 < $len) {
   199|                     $next = mb_substr($string, $i + 1, 1, $encoding);
   200|                     $uc = mb_convert_encoding($next, 'UCS-2', $encoding);
   201|                     if (in_array($uc, ["\x30\x99", "\x30\x9B", "\x30\x9C",
   202|                         "\xFF\x9E", "\xFF\x9F"])) {
   203|                         $char .= $next;
   204|                         $i++;
   205|                     }
   206|                 }
   207|                 if (strlen($line . $char) > $width) {
   208|                     $lines[] = $line;
   209|                     $line = $char;
   210|                 } else {
   211|                     $line .= $char;
   212|                 }
   213|             }
   214|             $lines[] = $line;    // 端数or空行
   215|         }
   216|         return $lines;
   217|     }
   218|     /**
   219|      * Format a string as an email address
   220|      *
   221|      * @param string $string String representing an email address
   222|      * @return string Email address suitable for email headers or smtp pipe
   223|      */
   224|     private function __formatAddress($string, $smtp = false)
   225|     {
   226|         $hasAlias = preg_match('/((.*)\s)?<(.+)>/', $string, $matches);
   227|         if ($smtp && $hasAlias) {
   228|             return $this->__strip('<' . $matches[3] . '>');
   229|         } elseif ($smtp) {
   230|             return $this->__strip('<' . $string . '>');
   231|         }
   232|         if ($hasAlias && !empty($matches[2])) {
   233|             return $this->__strip($this->__encode($matches[2]) . ' <' . $matches[3] . '>');
   234|         }
   235|         return $this->__strip($string);
   236|     }
   237|     /**
   238|      * Render the contents using the current layout and template.
   239|      *
   240|      * @param string $content Content to render
   241|      * @return array Email ready to be sent
   242|      */
   243|     private function __renderTemplate($content)
   244|     {
   245|         $viewClass = $this->Controller->viewClass;
   246|         if ($viewClass != 'View') {
   247|             if (strpos($viewClass, '.') !== false) {
   248|                 [$plugin, $viewClass] = explode('.', $viewClass);
   249|                 $viewClass = $viewClass . 'View';
   250|                 App::uses($viewClass, $plugin . '.View');
   251|             } else {
   252|                 $viewClass = $viewClass . 'View';
   253|             }
   254|             App::uses($viewClass, 'View');
   255|         }
   256|         $View = new $viewClass($this->Controller);
   257|         $View->layout = $this->layout;
   258|         $msg = [];
   259|         $layoutPath = $subDir = '';
   260|         if (!empty($this->layoutPath)) {
   261|             $layoutPath = $this->layoutPath . DS;
   262|         }
   263|         if (!empty($this->subDir)) {
   264|             $subDir = $this->subDir . DS;
   265|         }
   266|         $content = implode("\n", $content);
   267|         if ($this->sendAs === 'both') {
   268|             $htmlContent = $content;
   269|             if (!empty($this->attachments)) {
   270|                 $msg[] = '--' . $this->__boundary;
   271|                 $msg[] = 'Content-Type: multipart/alternative; boundary="alt-' . $this->__boundary . '"';
   272|                 $msg[] = '';
   273|             }
   274|             $msg[] = '--alt-' . $this->__boundary;
   275|             $msg[] = 'Content-Type: text/plain; charset=' . $this->charset;
   276|             $msg[] = 'Content-Transfer-Encoding: 7bit';
   277|             $msg[] = '';
   278|             $content = $View->element($subDir . 'Emails' . DS . 'text' . DS . $this->template, ['content' => $content]);
   279|             $View->layoutPath = $layoutPath . 'Emails' . DS . 'text';
   280|             $content = explode("\n", str_replace(["\r\n", "\r"], "\n", $View->renderLayout($content)));
   281|             $msg = array_merge($msg, $content);
   282|             $msg[] = '';
   283|             $msg[] = '--alt-' . $this->__boundary;
   284|             $msg[] = 'Content-Type: text/html; charset=' . $this->charset;
   285|             $msg[] = 'Content-Transfer-Encoding: 7bit';
   286|             $msg[] = '';
   287|             $htmlContent = $View->element($subDir . 'Emails' . DS . 'html' . DS . $this->template, ['content' => $htmlContent]);
   288|             $View->layoutPath = $layoutPath . 'Emails' . DS . 'html';
   289|             $htmlContent = explode("\n", str_replace(["\r\n", "\r"], "\n", $View->renderLayout($htmlContent)));
   290|             $msg = array_merge($msg, $htmlContent);
   291|             $msg[] = '';
   292|             $msg[] = '--alt-' . $this->__boundary . '--';
   293|             $msg[] = '';
   294|             ClassRegistry::removeObject('view');
   295|             return $msg;
   296|         }
   297|         if (!empty($this->attachments)) {
   298|             if ($this->sendAs === 'html') {
   299|                 $msg[] = '';
   300|                 $msg[] = '--' . $this->__boundary;
   301|                 $msg[] = 'Content-Type: text/html; charset=' . $this->charset;
   302|                 $msg[] = 'Content-Transfer-Encoding: 7bit';
   303|                 $msg[] = '';
   304|             } else {
   305|                 $msg[] = '--' . $this->__boundary;
   306|                 $msg[] = 'Content-Type: text/plain; charset=' . $this->charset;
   307|                 $msg[] = 'Content-Transfer-Encoding: 7bit';
   308|                 $msg[] = '';
   309|             }
   310|         }
   311|         if ($this->plugin) {
   312|             $options = ['content' => $content, 'plugin' => $this->plugin];
   313|         } else {
   314|             $options = ['content' => $content];
   315|         }
   316|         $content = $View->element($subDir . 'Emails' . DS . $this->sendAs . DS . $this->template, $options);
   317|         $View->layoutPath = $layoutPath . 'Emails' . DS . $this->sendAs;
   318|         $content = explode("\n", str_replace(["\r\n", "\r"], "\n", $View->renderLayout($content)));
   319|         $msg = array_merge($msg, $content);
   320|         ClassRegistry::removeObject('view');
   321|         return $msg;
   322|     }
   323| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Controller/Component/BcManagerComponent.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-453 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Controller\Component;
    12| use BaserCore\Utility\BcUtil;
    13| use Cake\Controller\Component;
    14| /**
    15|  * Class BcManagerComponent
    16|  *
    17|  * baser Manager コンポーネント
    18|  *
    19|  * @package Baser.Controller.Component
    20|  */
    21| class BcManagerComponent extends Component
    22| {
    23|     /**
    24|      * Controller
    25|      *
    26|      * @var Controller
    27|      */
    28|     public $Controller = null;
    29|     /**
    30|      * Startup
    31|      *
    32|      * @param Controller $controller
    33|      */
    34|     public function startup(Controller $controller)
    35|     {
    36|         parent::startup($controller);
    37|         $this->Controller = $controller;
    38|     }
    39|     /**
    40|      * baserCMSのインストール
    41|      *
    42|      * @param type $dbConfig
    43|      * @param type $adminUser
    44|      * @param type $adminPassword
    45|      * @param type $adminEmail
    46|      * @return boolean
    47|      */
    48|     public function install($siteUrl, $dbConfig, $adminUser = [], $baseUrl = '', $dbDataPattern = '')
    49|     {
    50|         if (!$dbDataPattern) {
    51|             $dbDataPattern = Configure::read('BcApp.defaultTheme') . '.default';
    52|         }
    53|         $result = true;
    54|         BcUtil::clearAllCache();
    55|         BcUtil::checkTmpFolders();
    56|         if ($dbConfig['datasource'] == 'sqlite' || $dbConfig['datasource'] == 'csv') {
    57|             switch($dbConfig['datasource']) {
    58|                 case 'sqlite':
    59|                     $dbFolderPath = APP . 'db' . DS . 'sqlite';
    60|                     break;
    61|                 case 'csv':
    62|                     $dbFolderPath = APP . 'db' . DS . 'csv';
    63|                     break;
    64|             }
    65|             $Folder = new Folder();
    66|             if (!is_writable($dbFolderPath) && !$Folder->create($dbFolderPath, 0777)) {
    67|                 $this->log(__d('baser_core', 'データベースの保存フォルダの作成に失敗しました。db フォルダの書き込み権限を見なおしてください。'));
    68|                 $result = false;
    69|             }
    70|         }
    71|         $securitySalt = $this->setSecuritySalt();
    72|         $securityCipherSeed = $this->setSecurityCipherSeed();
    73|         if (!$this->createInstallFile($securitySalt, $securityCipherSeed, $siteUrl)) {
    74|             $this->log(__d('baser_core', 'インストールファイル生成に失敗しました。設定フォルダの書き込み権限を見なおしてください。'));
    75|             $result = false;
    76|         }
    77|         if (!$this->createDatabaseConfig($dbConfig)) {
    78|             $this->log(__d('baser_core', 'データベースの設定ファイル生成に失敗しました。設定フォルダの書き込み権限を見なおしてください。'));
    79|             $result = false;
    80|         }
    81|         if (!$this->constructionDb($dbConfig, $dbDataPattern, Configure::read('BcApp.defaultAdminTheme'))) {
    82|             $this->log(__d('baser_core', 'データベースの初期化に失敗しました。データベースの設定を見なおしてください。'));
    83|             $result = false;
    84|         }
    85|         if ($adminUser) {
    86|             if (!$this->setAdminEmail($adminUser['email'])) {
    87|                 $this->log(__d('baser_core', 'サイト基本設定への管理者メールアドレスの設定処理が失敗しました。データベースの設定を見なおしてください。'));
    88|             }
    89|             $adminUser['password_1'] = $adminUser['password'];
    90|             $adminUser['password_2'] = $adminUser['password'];
    91|             if (!$this->addDefaultUser($adminUser)) {
    92|                 $this->log(__d('baser_core', '初期ユーザーの作成に失敗しました。データベースの設定を見なおしてください。'));
    93|                 $result = false;
    94|             }
    95|         }
    96|         if (!$this->executeDefaultUpdates($dbConfig)) {
    97|             $this->log(__d('baser_core', 'データベースのデータ更新に失敗しました。データベースの設定を見なおしてください。'));
    98|             $result = false;
    99|         }
   100|         if (!$this->installCorePlugin($dbConfig, $dbDataPattern)) {
   101|             $this->log(__d('baser_core', 'コアプラグインのインストールに失敗しました。'));
   102|             $result = false;
   103|         }
   104|         if (!$this->deployTheme()) {
   105|             $this->log(__d('baser_core', 'テーマの配置に失敗しました。テーマフォルダの書き込み権限を確認してください。'));
   106|             $result = false;
   107|         }
   108|         if (!$this->deployAdminAssets()) {
   109|             $this->log(__d('baser_core', '管理システムのアセットファイルの配置に失敗しました。テーマフォルダの書き込み権限を確認してください。'));
   110|         }
   111|         if (!$this->createDefaultFiles()) {
   112|             $this->log(__d('baser_core', 'アップロード用初期フォルダの作成に失敗しました。files フォルダの書き込み権限を確認してください。'));
   113|             $result = false;
   114|         }
   115|         if (!$this->deployEditorTemplateImage()) {
   116|             $this->log(__d('baser_core', 'エディタテンプレートイメージの配置に失敗しました。files フォルダの書き込み権限を確認してください。'));
   117|             $result = false;
   118|         }
   119|         loadSiteConfig();
   120|         $this->createPageTemplates();
   121|         return $result;
   122|     }
   123|     /**
   124|      * 設定ファイルをリセットする
   125|      *
   126|      * @return boolean
   127|      */
   128|     public function resetSetting()
   129|     {
   130|         $result = true;
   131|         if (file_exists(APP . 'Config' . DS . 'database.php')) {
   132|             if (!unlink(APP . 'Config' . DS . 'database.php')) {
   133|                 $result = false;
   134|             }
   135|         }
   136|         if (file_exists(APP . 'Config' . DS . 'install.php')) {
   137|             if (!unlink(APP . 'Config' . DS . 'install.php')) {
   138|                 $result = false;
   139|             }
   140|         }
   141|         return $result;
   142|     }
   143|     /**
   144|      * files フォルダを初期化する
   145|      *
   146|      * @return boolean
   147|      */
   148|     public function resetFiles()
   149|     {
   150|         return $this->resetEmptyFolder(WWW_ROOT . 'files');
   151|     }
   152|     /**
   153|      * 管理画面用のアセットフォルダ（img / js / css）を初期化する
   154|      *
   155|      * @return boolean
   156|      */
   157|     public function resetAdminAssets()
   158|     {
   159|         $paths = [
   160|             WWW_ROOT . 'img' . DS . 'admin',
   161|             WWW_ROOT . 'css' . DS . 'admin',
   162|             WWW_ROOT . 'js' . DS . 'admin'
   163|         ];
   164|         $result = true;
   165|         foreach($paths as $path) {
   166|             if (is_dir($path)) {
   167|                 $Folder = new Folder($path);
   168|                 if (!$Folder->delete()) {
   169|                     $result = false;
   170|                 }
   171|                 $Folder = null;
   172|             }
   173|         }
   174|         return $result;
   175|     }
   176|     /**
   177|      * empty ファイルを梱包したフォルダをリセットする
   178|      *
   179|      * empty ファイルを残して内包するファイルとフォルダを全て削除する
   180|      *
   181|      * @param string $path
   182|      * @return boolean
   183|      */
   184|     public function resetEmptyFolder($path)
   185|     {
   186|         $result = true;
   187|         $Folder = new Folder($path);
   188|         $files = $Folder->read(true, true, true);
   189|         $Folder = null;
   190|         if (!empty($files[0])) {
   191|             foreach($files[0] as $file) {
   192|                 $Folder = new Folder();
   193|                 if (!$Folder->delete($file)) {
   194|                     $result = false;
   195|                 }
   196|                 $Folder = null;
   197|             }
   198|         }
   199|         if (!empty($files[1])) {
   200|             foreach($files[1] as $file) {
   201|                 if (basename($file) != 'empty') {
   202|                     $Folder = new Folder();
   203|                     if (!$Folder->delete($file)) {
   204|                         $result = false;
   205|                     }
   206|                     $Folder = null;
   207|                 }
   208|             }
   209|         }
   210|         return $result;
   211|     }
   212|     /**
   213|      * baserCMSをリセットする
   214|      *
   215|      * @param array $dbConfig
   216|      */
   217|     public function reset($dbConfig)
   218|     {
   219|         $result = true;
   220|         if (BcUtil::isInstalled()) {
   221|             if (!$this->resetSetting()) {
   222|                 $result = false;
   223|                 $this->log(__d('baser_core', '設定ファイルを正常に初期化できませんでした。'));
   224|             }
   225|             if (!$this->deleteTables('default', $dbConfig)) {
   226|                 $result = false;
   227|                 $this->log(__d('baser_core', 'データベースを正常に初期化できませんでした。'));
   228|             }
   229|         }
   230|         if (!$this->resetTheme()) {
   231|             $result = false;
   232|             $this->log(__d('baser_core', 'テーマフォルダを初期化できませんでした。'));
   233|         }
   234|         if (!$this->resetPages()) {
   235|             $result = false;
   236|             $this->log(__d('baser_core', '固定ページテンプレートを初期化できませんでした。'));
   237|         }
   238|         if (!$this->resetFiles()) {
   239|             $result = false;
   240|             $this->log(__d('baser_core', 'files フォルダを初期化できませんでした。'));
   241|         }
   242|         if (!$this->resetAdminAssets()) {
   243|             $result = false;
   244|             $this->log(__d('baser_core', 'img / css / js フォルダを初期化できませんでした。'));
   245|         }
   246|         ClassRegistry::flush();
   247|         BcUtil::clearAllCache();
   248|         return $result;
   249|     }
   250|     /**
   251|      * テーマリセットする
   252|      *
   253|      * @return bool
   254|      */
   255|     public function resetTheme()
   256|     {
   257|         $Folder = new Folder(BASER_CONFIGS . 'theme');
   258|         $sources = $Folder->read()[0];
   259|         $result = true;
   260|         foreach($sources as $theme) {
   261|             $targetPath = WWW_ROOT . 'theme' . DS . $theme;
   262|             if (is_dir($targetPath)) {
   263|                 if (!$Folder->delete($targetPath)) {
   264|                     $result = false;
   265|                 }
   266|             }
   267|         }
   268|         return $result;
   269|     }
   270|     /**
   271|      * 固定ページテンプレートをリセットする
   272|      *
   273|      * @return bool
   274|      */
   275|     public function resetPages()
   276|     {
   277|         $Folder = new Folder(APP . 'View' . DS . 'Pages');
   278|         $files = $Folder->read(true, true, true);
   279|         $result = true;
   280|         foreach($files[0] as $file) {
   281|             if (!$Folder->delete($file)) {
   282|                 $result = false;
   283|             }
   284|         }
   285|         foreach($files[1] as $file) {
   286|             if (basename($file) != 'empty') {
   287|                 if (!@unlink($file)) {
   288|                     $result = false;
   289|                 }
   290|             }
   291|         }
   292|         return $result;
   293|     }
   294|     /**
   295|      * インストール設定を書き換える
   296|      *
   297|      * @param string $key
   298|      * @param string $value
   299|      * @return    boolean
   300|      * @access    public
   301|      */
   302|     public function setInstallSetting($key, $value)
   303|     {
   304|         /* install.php の編集 */
   305|         $setting = "Configure::write('" . $key . "', " . $value . ");\n";
   306|         $key = str_replace('.', '\.', $key);
   307|         $pattern = '/Configure\:\:write[\s]*\([\s]*\'' . $key . '\'[\s]*,[\s]*([^\s]*)[\s]*\);(\n|)/is';
   308|         $file = new File(APP . 'Config' . DS . 'install.php');
   309|         if (file_exists(APP . 'Config' . DS . 'install.php')) {
   310|             $data = $file->read();
   311|         } else {
   312|             $data = "<?php\n";
   313|         }
   314|         if (preg_match($pattern, $data)) {
   315|             $data = preg_replace($pattern, $setting, $data);
   316|         } else {
   317|             $data = $data . "\n" . $setting;
   318|         }
   319|         $return = $file->write($data);
   320|         $file->close();
   321|         return $return;
   322|     }
   323|     /**
   324|      * 環境チェック
   325|      *
   326|      * @return array
   327|      */
   328|     public function checkEnv()
   329|     {
   330|         if (function_exists('apache_get_modules')) {
   331|             $rewriteInstalled = in_array('mod_rewrite', apache_get_modules());
   332|         } else {
   333|             $rewriteInstalled = -1;
   334|         }
   335|         $status = [
   336|             'encoding' => mb_internal_encoding(),
   337|             'phpVersion' => phpversion(),
   338|             'phpMemory' => intval(ini_get('memory_limit')),
   339|             'safeModeOff' => !ini_get('safe_mode'),
   340|             'configDirWritable' => is_writable(APP . 'Config' . DS),
   341|             'pluginDirWritable' => is_writable(APP . 'Plugin' . DS),
   342|             'themeDirWritable' => is_writable(WWW_ROOT . 'theme'),
   343|             'filesDirWritable' => is_writable(WWW_ROOT . 'files'),
   344|             'imgDirWritable' => is_writable(WWW_ROOT . 'img'),
   345|             'jsDirWritable' => is_writable(WWW_ROOT . 'js'),
   346|             'cssDirWritable' => is_writable(WWW_ROOT . 'css'),
   347|             'imgAdminDirExists' => is_dir(WWW_ROOT . 'img' . DS . 'admin'),
   348|             'jsAdminDirExists' => is_dir(WWW_ROOT . 'js' . DS . 'admin'),
   349|             'cssAdminDirExists' => is_dir(WWW_ROOT . 'css' . DS . 'admin'),
   350|             'tmpDirWritable' => is_writable(TMP),
   351|             'pagesDirWritable' => is_writable(APP . 'View' . DS . 'Pages'),
   352|             'dbDirWritable' => is_writable(APP . 'db'),
   353|             'phpActualVersion' => preg_replace('/[a-z-]/', '', phpversion()),
   354|             'phpGd' => extension_loaded('gd'),
   355|             'phpPdo' => extension_loaded('pdo'),
   356|             'phpXml' => extension_loaded('xml'),
   357|             'apacheRewrite' => $rewriteInstalled,
   358|         ];
   359|         $check = [
   360|             'encodingOk' => (preg_match('/UTF-8/i', $status['encoding'])? true : false),
   361|             'gdOk' => $status['phpGd'],
   362|             'pdoOk' => $status['phpPdo'],
   363|             'xmlOk' => $status['phpXml'],
   364|             'phpVersionOk' => version_compare(preg_replace('/[a-z-]/', '', $status['phpVersion']), Configure::read('BcRequire.phpVersion'), '>='),
   365|             'phpMemoryOk' => ((($status['phpMemory'] >= Configure::read('BcRequire.phpMemory')) || $status['phpMemory'] == -1) === true)
   366|         ];
   367|         if (!$status['configDirWritable']) {
   368|             @chmod(APP . 'Config' . DS, 0777);
   369|             $status['configDirWritable'] = is_writable(APP . 'Config' . DS);
   370|         }
   371|         if (!$status['pluginDirWritable']) {
   372|             @chmod(APP . 'Plugin' . DS, 0777);
   373|             $status['pluginDirWritable'] = is_writable(APP . 'Plugin' . DS);
   374|         }
   375|         if (!$status['themeDirWritable']) {
   376|             @chmod(WWW_ROOT . 'theme', 0777);
   377|             $status['themeDirWritable'] = is_writable(WWW_ROOT . 'theme');
   378|         }
   379|         if (!$status['filesDirWritable']) {
   380|             @chmod(WWW_ROOT . 'files', 0777);
   381|             $status['filesDirWritable'] = is_writable(WWW_ROOT . 'files');
   382|         }
   383|         if (!$status['imgDirWritable']) {
   384|             @chmod(WWW_ROOT . 'img', 0777);
   385|             $status['imgDirWritable'] = is_writable(WWW_ROOT . 'img');
   386|         }
   387|         if (!$status['cssDirWritable']) {
   388|             @chmod(WWW_ROOT . 'css', 0777);
   389|             $status['cssDirWritable'] = is_writable(WWW_ROOT . 'css');
   390|         }
   391|         if (!$status['jsDirWritable']) {
   392|             @chmod(WWW_ROOT . 'js', 0777);
   393|             $status['jsDirWritable'] = is_writable(WWW_ROOT . 'js');
   394|         }
   395|         if (!$status['tmpDirWritable']) {
   396|             @chmod(TMP, 0777);
   397|             $status['tmpDirWritable'] = is_writable(TMP);
   398|         }
   399|         if (!$status['dbDirWritable']) {
   400|             @chmod(APP . 'db', 0777);
   401|             $status['dbDirWritable'] = is_writable(APP . 'db');
   402|         }
   403|         return $status + $check;
   404|     }
   405|     /**
   406|      * サイトルートの管理システム用アセットを削除する
   407|      *
   408|      * @return bool
   409|      */
   410|     public function deleteAdminAssets()
   411|     {
   412|         $viewPath = WWW_ROOT;
   413|         $css = $viewPath . 'css' . DS . 'admin';
   414|         $js = $viewPath . 'js' . DS . 'admin';
   415|         $img = $viewPath . 'img' . DS . 'admin';
   416|         $fonts = $viewPath . 'fonts' . DS . 'admin';
   417|         $result = true;
   418|         $Folder = new Folder();
   419|         if (!$Folder->delete($css)) {
   420|             $result = false;
   421|         }
   422|         if (!$Folder->delete($js)) {
   423|             $result = false;
   424|         }
   425|         if (!$Folder->delete($img)) {
   426|             $result = false;
   427|         }
   428|         if (!$Folder->delete($fonts)) {
   429|             $result = false;
   430|         }
   431|         return $result;
   432|     }
   433|     /**
   434|      * テーマに梱包されているプラグインをインストールする
   435|      *
   436|      * @param string $theme テーマ名
   437|      * @return bool
   438|      */
   439|     public function installThemesPlugins($theme)
   440|     {
   441|         $plugins = BcUtil::getThemesPlugins($theme);
   442|         $result = true;
   443|         if ($plugins) {
   444|             App::build(['Plugin' => array_merge([BASER_THEMES . $theme . DS . 'Plugin' . DS], App::path('Plugin'))]);
   445|             foreach($plugins as $plugin) {
   446|                 if (!$this->installPlugin($plugin)) {
   447|                     $result = false;
   448|                 }
   449|             }
   450|         }
   451|         return $result;
   452|     }
   453| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Event/CakeEventManager-4.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-302 ---
     1| <?php
     2| return;
     3| /**
     4|  * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
     5|  * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
     6|  *
     7|  * Licensed under The MIT License
     8|  * For full copyright and license information, please see the LICENSE.txt
     9|  * Redistributions of files must retain the above copyright notice.
    10|  *
    11|  * @copyright      Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    12|  * @link          https://cakephp.org CakePHP(tm) Project
    13|  * @package          Cake.Event
    14|  * @since          CakePHP(tm) v 2.1
    15|  * @license       https://opensource.org/licenses/mit-license.php MIT License
    16|  */
    17| App::uses('CakeEventListener', 'Event');
    18| App::uses('CakeEvent', 'Event'); // issue#1428 Reflection from CakePHP v 2.10.20
    19| /**
    20|  * The event manager is responsible for keeping track of event listeners, passing the correct
    21|  * data to them, and firing them in the correct order, when associated events are triggered. You
    22|  * can create multiple instances of this object to manage local events or keep a single instance
    23|  * and pass it around to manage all events in your app.
    24|  *
    25|  * @package Cake.Event
    26|  */
    27| class CakeEventManager
    28| {
    29|     /**
    30|      * The default priority queue value for new, attached listeners
    31|      *
    32|      * @var int
    33|      */
    34|     public static $defaultPriority = 10;
    35|     /**
    36|      * The globally available instance, used for dispatching events attached from any scope
    37|      *
    38|      * @var CakeEventManager
    39|      */
    40|     protected static $_generalManager = null;
    41|     /**
    42|      * List of listener callbacks associated to
    43|      *
    44|      * @var object
    45|      */
    46|     protected $_listeners = [];
    47|     /**
    48|      * Internal flag to distinguish a common manager from the singleton
    49|      *
    50|      * @var bool
    51|      */
    52|     protected $_isGlobal = false;
    53|     /**
    54|      * Returns the globally available instance of a CakeEventManager
    55|      * this is used for dispatching events attached from outside the scope
    56|      * other managers were created. Usually for creating hook systems or inter-class
    57|      * communication
    58|      *
    59|      * If called with the first parameter, it will be set as the globally available instance
    60|      *
    61|      * @param CakeEventManager $manager Optional event manager instance.
    62|      * @return CakeEventManager the global event manager
    63|      */
    64|     public static function instance($manager = null)
    65|     {
    66|         if ($manager instanceof CakeEventManager) {
    67|             static::$_generalManager = $manager;
    68|         }
    69|         if (empty(static::$_generalManager)) {
    70|             static::$_generalManager = new CakeEventManager();
    71|         }
    72|         static::$_generalManager->_isGlobal = true;
    73|         return static::$_generalManager;
    74|     }
    75|     /**
    76|      * Adds a new listener to an event. Listeners
    77|      *
    78|      * @param callable|CakeEventListener $callable PHP valid callback type or instance of CakeEventListener to be called
    79|      * when the event named with $eventKey is triggered. If a CakeEventListener instance is passed, then the `implementedEvents`
    80|      * method will be called on the object to register the declared events individually as methods to be managed by this class.
    81|      * It is possible to define multiple event handlers per event name.
    82|      *
    83|      * @param string $eventKey The event unique identifier name with which the callback will be associated. If $callable
    84|      * is an instance of CakeEventListener this argument will be ignored
    85|      *
    86|      * @param array $options used to set the `priority` and `passParams` flags to the listener.
    87|      * Priorities are handled like queues, and multiple attachments added to the same priority queue will be treated in
    88|      * the order of insertion. `passParams` means that the event data property will be converted to function arguments
    89|      * when the listener is called. If $called is an instance of CakeEventListener, this parameter will be ignored
    90|      *
    91|      * @return void
    92|      * @throws InvalidArgumentException When event key is missing or callable is not an
    93|      *   instance of CakeEventListener.
    94|      */
    95|     public function attach($callable, $eventKey = null, $options = [])
    96|     {
    97|         if (!$eventKey && !($callable instanceof CakeEventListener)) {
    98|             throw new InvalidArgumentException(__d('cake_dev', 'The eventKey variable is required'));
    99|         }
   100|         if ($callable instanceof CakeEventListener) {
   101|             $this->_attachSubscriber($callable);
   102|             return;
   103|         }
   104|         $options = $options + ['priority' => static::$defaultPriority, 'passParams' => false];
   105|         $this->_listeners[$eventKey][$options['priority']][] = [
   106|             'callable' => $callable,
   107|             'passParams' => $options['passParams'],
   108|         ];
   109|     }
   110|     /**
   111|      * Auxiliary function to attach all implemented callbacks of a CakeEventListener class instance
   112|      * as individual methods on this manager
   113|      *
   114|      * @param CakeEventListener $subscriber Event listener.
   115|      * @return void
   116|      */
   117|     protected function _attachSubscriber(CakeEventListener $subscriber)
   118|     {
   119|         foreach((array)$subscriber->implementedEvents() as $eventKey => $function) {
   120|             $options = [];
   121|             $method = $function;
   122|             if (is_array($function) && isset($function['callable'])) {
   123|                 [$method, $options] = $this->_extractCallable($function, $subscriber);
   124|             } elseif (is_array($function) && is_numeric(key($function))) {
   125|                 foreach($function as $f) {
   126|                     [$method, $options] = $this->_extractCallable($f, $subscriber);
   127|                     $this->attach($method, $eventKey, $options);
   128|                 }
   129|                 continue;
   130|             }
   131|             if (is_string($method)) {
   132|                 $method = [$subscriber, $function];
   133|             }
   134|             $this->attach($method, $eventKey, $options);
   135|         }
   136|     }
   137|     /**
   138|      * Auxiliary function to extract and return a PHP callback type out of the callable definition
   139|      * from the return value of the `implementedEvents` method on a CakeEventListener
   140|      *
   141|      * @param array $function the array taken from a handler definition for an event
   142|      * @param CakeEventListener $object The handler object
   143|      * @return callable
   144|      */
   145|     protected function _extractCallable($function, $object)
   146|     {
   147|         $method = $function['callable'];
   148|         $options = $function;
   149|         unset($options['callable']);
   150|         if (is_string($method)) {
   151|             $method = [$object, $method];
   152|         }
   153|         return [$method, $options];
   154|     }
   155|     /**
   156|      * Removes a listener from the active listeners.
   157|      *
   158|      * @param callable|CakeEventListener $callable any valid PHP callback type or an instance of CakeEventListener
   159|      * @param string $eventKey The event unique identifier name with which the callback has been associated
   160|      * @return void
   161|      */
   162|     public function detach($callable, $eventKey = null)
   163|     {
   164|         if ($callable instanceof CakeEventListener) {
   165|             return $this->_detachSubscriber($callable, $eventKey);
   166|         }
   167|         if (empty($eventKey)) {
   168|             foreach(array_keys($this->_listeners) as $eventKey) {
   169|                 $this->detach($callable, $eventKey);
   170|             }
   171|             return;
   172|         }
   173|         if (empty($this->_listeners[$eventKey])) {
   174|             return;
   175|         }
   176|         foreach($this->_listeners[$eventKey] as $priority => $callables) {
   177|             foreach($callables as $k => $callback) {
   178|                 if ($callback['callable'] === $callable) {
   179|                     unset($this->_listeners[$eventKey][$priority][$k]);
   180|                     break;
   181|                 }
   182|             }
   183|         }
   184|     }
   185|     /**
   186|      * Auxiliary function to help detach all listeners provided by an object implementing CakeEventListener
   187|      *
   188|      * @param CakeEventListener $subscriber the subscriber to be detached
   189|      * @param string $eventKey optional event key name to unsubscribe the listener from
   190|      * @return void
   191|      */
   192|     protected function _detachSubscriber(CakeEventListener $subscriber, $eventKey = null)
   193|     {
   194|         $events = (array)$subscriber->implementedEvents();
   195|         if (!empty($eventKey) && empty($events[$eventKey])) {
   196|             return;
   197|         } elseif (!empty($eventKey)) {
   198|             $events = [$eventKey => $events[$eventKey]];
   199|         }
   200|         foreach($events as $key => $function) {
   201|             if (is_array($function)) {
   202|                 if (is_numeric(key($function))) {
   203|                     foreach($function as $handler) {
   204|                         $handler = isset($handler['callable'])? $handler['callable'] : $handler;
   205|                         $this->detach([$subscriber, $handler], $key);
   206|                     }
   207|                     continue;
   208|                 }
   209|                 $function = $function['callable'];
   210|             }
   211|             $this->detach([$subscriber, $function], $key);
   212|         }
   213|     }
   214|     /**
   215|      * Dispatches a new event to all configured listeners
   216|      *
   217|      * @param string|\Cake\Event\Event $event the event key name or instance of CakeEvent
   218|      * @return CakeEvent
   219|      * @triggers $event
   220|      */
   221|     public function dispatch($event)
   222|     {
   223|         if (is_string($event)) {
   224|             $event = new CakeEvent($event);
   225|         }
   226|         $listeners = $this->listeners($event->name());
   227|         if (empty($listeners)) {
   228|             return $event;
   229|         }
   230|         foreach($listeners as $listener) {
   231|             if ($event->isStopped()) {
   232|                 break;
   233|             }
   234|             if ($listener['passParams'] === true) {
   235|                 $result = call_user_func_array($listener['callable'], $event->getData());
   236|             } else {
   237|                 $result = call_user_func($listener['callable'], $event);
   238|             }
   239|             if ($result === false) {
   240|                 $event->stopPropagation();
   241|             }
   242|             if (is_array($result) && array_key_exists(0, $result)) {
   243|                 $notNull = false;
   244|                 foreach($result as $key => $val) {
   245|                     if ($val !== null) {
   246|                         $notNull = true;
   247|                     }
   248|                 }
   249|                 if (!$notNull) {
   250|                     $result = null;
   251|                 }
   252|             }
   253|             if ($result !== null) {
   254|                 $event->setResult($result);
   255|             }
   256|         }
   257|         return $event;
   258|     }
   259|     /**
   260|      * Returns a list of all listeners for an eventKey in the order they should be called
   261|      *
   262|      * @param string $eventKey Event key.
   263|      * @return array
   264|      */
   265|     public function listeners($eventKey)
   266|     {
   267|         $localListeners = [];
   268|         $priorities = [];
   269|         if (!$this->_isGlobal) {
   270|             $localListeners = $this->prioritisedListeners($eventKey);
   271|             $localListeners = empty($localListeners)? [] : $localListeners;
   272|         }
   273|         $globalListeners = static::instance()->prioritisedListeners($eventKey);
   274|         $globalListeners = empty($globalListeners)? [] : $globalListeners;
   275|         $priorities = array_merge(array_keys($globalListeners), array_keys($localListeners));
   276|         $priorities = array_unique($priorities);
   277|         asort($priorities);
   278|         $result = [];
   279|         foreach($priorities as $priority) {
   280|             if (isset($globalListeners[$priority])) {
   281|                 $result = array_merge($result, $globalListeners[$priority]);
   282|             }
   283|             if (isset($localListeners[$priority])) {
   284|                 $result = array_merge($result, $localListeners[$priority]);
   285|             }
   286|         }
   287|         return $result;
   288|     }
   289|     /**
   290|      * Returns the listeners for the specified event key indexed by priority
   291|      *
   292|      * @param string $eventKey Event key.
   293|      * @return array
   294|      */
   295|     public function prioritisedListeners($eventKey)
   296|     {
   297|         if (empty($this->_listeners[$eventKey])) {
   298|             return [];
   299|         }
   300|         return $this->_listeners[$eventKey];
   301|     }
   302| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/Behavior/BcCacheBehavior.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-174 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Model\Behavior;
    12| use Cake\ORM\Behavior;
    13| /**
    14|  * Class BcCacheBehavior
    15|  *
    16|  * キャッシュビヘイビア
    17|  *
    18|  * @package Baser.Model.Behavior
    19|  */
    20| class BcCacheBehavior extends Behavior
    21| {
    22|     /**
    23|      * setup
    24|      *
    25|      * @param Model $model
    26|      * @param array $config
    27|      * @return void
    28|      */
    29|     public function setup(Model $model, $config = [])
    30|     {
    31|         if (!defined('CACHE_DATA_PATH')) {
    32|             $setting = Cache::config('_cake_data_');
    33|             if ($setting) {
    34|                 define('CACHE_DATA_PATH', $setting['settings']['path']);
    35|             }
    36|         }
    37|         $this->createCacheFolder($model);
    38|     }
    39|     /**
    40|      * キャッシュフォルダーを生成する
    41|      *
    42|      * @param Model $model
    43|      */
    44|     public function createCacheFolder(Model $model)
    45|     {
    46|         if (!defined('CACHE_DATA_PATH')) {
    47|             return;
    48|         }
    49|         $path = CACHE_DATA_PATH . $model->tablePrefix . $model->table;
    50|         if (!is_dir($path)) {
    51|             mkdir($path);
    52|             chmod($path, 0777);
    53|         }
    54|     }
    55|     /**
    56|      * キャッシュ処理
    57|      *
    58|      * @param Model $model
    59|      * @param int $expire
    60|      * @param string $method
    61|      * @return mixed
    62|      */
    63|     public function readCache(Model $model, $expire, $type, $query = [])
    64|     {
    65|         static $cacheData = [];
    66|         $tableName = $model->tablePrefix . $model->table;
    67|         if (!isset($query['recursive'])) {
    68|             $query['recursive'] = $model->recursive;
    69|         }
    70|         $cachekey = $tableName . '_' . $type . '_' . $expire . '_' . md5(serialize($query));
    71|         if (!$expire) {
    72|             if (isset($cacheData[$cachekey])) {
    73|                 return $cacheData[$cachekey];
    74|             }
    75|             if (!$db = ConnectionManager::getDataSource($model->useDbConfig)) {
    76|                 return false;
    77|             }
    78|             $results = $db->read($model, $query);
    79|             $cacheData[$cachekey] = $results;
    80|             return $results;
    81|         }
    82|         $this->changeCachePath($model->tablePrefix . $model->table);
    83|         $results = Cache::read($cachekey, '_cake_data_');
    84|         if ($results !== false) {
    85|             if ($results == "{false}") {
    86|                 $results = false;
    87|             }
    88|             return $results;
    89|         }
    90|         if (!$db = ConnectionManager::getDataSource($model->useDbConfig)) {
    91|             return false;
    92|         }
    93|         $results = $db->read($model, $query);
    94|         Cache::write($cachekey, ($results === false)? "{false}" : $results, '_cake_data_');
    95|         return $results;
    96|     }
    97|     /**
    98|      * データキャッシュのパスを指定する
    99|      *
   100|      * @param string $dir
   101|      */
   102|     public function changeCachePath($table)
   103|     {
   104|         if (!defined('CACHE_DATA_PATH')) {
   105|             return;
   106|         }
   107|         $path = CACHE_DATA_PATH;
   108|         $path .= $table . DS;
   109|         Cache::config('_cake_data_', ['path' => $path]);
   110|     }
   111|     /**
   112|      * キャッシュを削除する
   113|      *
   114|      * @param Model $model
   115|      * @return void
   116|      */
   117|     public function delCache(Model $model)
   118|     {
   119|         if (!defined('CACHE_DATA_PATH')) {
   120|             return;
   121|         }
   122|         $path = CACHE_DATA_PATH . $model->tablePrefix . $model->table;
   123|         $Folder = new Folder();
   124|         $Folder->delete($path);
   125|         $this->createCacheFolder($model);
   126|     }
   127|     /**
   128|      * afterSave
   129|      *
   130|      * @param Model $model
   131|      * @param boolean $created
   132|      * @return void
   133|      */
   134|     public function afterSave(Model $model, $created, $options = [])
   135|     {
   136|         $this->delAssockCache($model);
   137|     }
   138|     /**
   139|      * afterDelete
   140|      *
   141|      * @param Model $model
   142|      * @return void
   143|      */
   144|     public function afterDelete(Model $model)
   145|     {
   146|         $this->delAssockCache($model);
   147|     }
   148|     /**
   149|      * 関連モデルを含めてキャッシュを削除する
   150|      *
   151|      * @param Model $model
   152|      * @return void
   153|      * @todo 現在、3階層まで再帰対応。CakePHPのrecursiveの仕組み合わせたい
   154|      */
   155|     public function delAssockCache(Model $model, $recursive = 0)
   156|     {
   157|         $this->delCache($model);
   158|         if ($recursive <= 3) {
   159|             $recursive++;
   160|             $assocTypes = ['hasMany', 'hasOne', 'belongsTo', 'hasAndBelongsToMany'];
   161|             foreach($assocTypes as $assocType) {
   162|                 if ($model->{$assocType}) {
   163|                     foreach($model->{$assocType} as $assoc) {
   164|                         $className = $assoc['className'];
   165|                         [$plugin, $className] = pluginSplit($className);
   166|                         if (isset($model->{$className})) {
   167|                             $this->delAssockCache($model->{$className}, $recursive);
   168|                         }
   169|                     }
   170|                 }
   171|             }
   172|         }
   173|     }
   174| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/CakeSchema.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-648 ---
     1| <?php
     2| return;
     3| /**
     4|  * Schema database management for CakePHP.
     5|  *
     6|  * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
     7|  * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
     8|  *
     9|  * Licensed under The MIT License
    10|  * For full copyright and license information, please see the LICENSE.txt
    11|  * Redistributions of files must retain the above copyright notice.
    12|  *
    13|  * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    14|  * @link          https://cakephp.org CakePHP(tm) Project
    15|  * @package       Cake.Model
    16|  * @since         CakePHP(tm) v 1.2.0.5550
    17|  * @license       https://opensource.org/licenses/mit-license.php MIT License
    18|  */
    19| App::uses('Model', 'Model');
    20| App::uses('AppModel', 'Model');
    21| App::uses('ConnectionManager', 'Model');
    22| App::uses('File', 'Utility');
    23| /**
    24|  * Base Class for Schema management.
    25|  *
    26|  * @package       Cake.Model
    27|  */
    28| class CakeSchema extends CakeObject
    29| {
    30|     /**
    31|      * Name of the schema.
    32|      *
    33|      * @var string
    34|      */
    35|     public $name = null;
    36|     /**
    37|      * Path to write location.
    38|      *
    39|      * @var string
    40|      */
    41|     public $path = null;
    42|     /**
    43|      * File to write.
    44|      *
    45|      * @var string
    46|      */
    47|     public $file = 'schema.php';
    48|     /**
    49|      * Connection used for read.
    50|      *
    51|      * @var string
    52|      */
    53|     public $connection = 'default';
    54|     /**
    55|      * Plugin name.
    56|      *
    57|      * @var string
    58|      */
    59|     public $plugin = null;
    60|     /**
    61|      * Set of tables.
    62|      *
    63|      * @var array
    64|      */
    65|     public $tables = [];
    66|     /**
    67|      * Constructor
    68|      *
    69|      * @param array $options Optional load object properties.
    70|      */
    71|     public function __construct($options = [])
    72|     {
    73|         parent::__construct();
    74|         if (empty($options['name'])) {
    75|             $this->name = preg_replace('/schema$/i', '', get_class($this));
    76|         }
    77|         if (!empty($options['plugin'])) {
    78|             $this->plugin = $options['plugin'];
    79|         }
    80|         if (strtolower($this->name) === 'cake') {
    81|             $this->name = 'App';
    82|         }
    83|         if (empty($options['path'])) {
    84|             $this->path = CONFIG . 'Schema';
    85|         }
    86|         $options = array_merge(get_object_vars($this), $options);
    87|         $this->build($options);
    88|     }
    89|     /**
    90|      * Builds schema object properties.
    91|      *
    92|      * @param array $data Loaded object properties.
    93|      * @return void
    94|      */
    95|     public function build($data)
    96|     {
    97|         $file = null;
    98|         foreach($data as $key => $val) {
    99|             if (!empty($val)) {
   100|                 if (!in_array($key, ['plugin', 'name', 'path', 'file', 'connection', 'tables', '_log'])) {
   101|                     if ($key[0] === '_') {
   102|                         continue;
   103|                     }
   104|                     $this->tables[$key] = $val;
   105|                     unset($this->{$key});
   106|                 } elseif ($key !== 'tables') {
   107|                     if ($key === 'name' && $val !== $this->name && !isset($data['file'])) {
   108|                         $file = Inflector::underscore($val) . '.php';
   109|                     }
   110|                     $this->{$key} = $val;
   111|                 }
   112|             }
   113|         }
   114|         if (file_exists($this->path . DS . $file) && is_file($this->path . DS . $file)) {
   115|             $this->file = $file;
   116|         } elseif (!empty($this->plugin)) {
   117|             $this->path = CakePlugin::path($this->plugin) . 'Config' . DS . 'Schema';
   118|         }
   119|     }
   120|     /**
   121|      * Before callback to be implemented in subclasses.
   122|      *
   123|      * @param array $event Schema object properties.
   124|      * @return bool Should process continue.
   125|      */
   126|     public function before($event = [])
   127|     {
   128|         return true;
   129|     }
   130|     /**
   131|      * After callback to be implemented in subclasses.
   132|      *
   133|      * @param array $event Schema object properties.
   134|      * @return void
   135|      */
   136|     public function after($event = [])
   137|     {
   138|     }
   139|     /**
   140|      * Reads database and creates schema tables.
   141|      *
   142|      * @param array $options Schema object properties.
   143|      * @return array|bool Set of name and tables.
   144|      */
   145|     public function load($options = [])
   146|     {
   147|         if (is_string($options)) {
   148|             $options = ['path' => $options];
   149|         }
   150|         $this->build($options);
   151|         $class = $this->name . 'Schema';
   152|         if (!class_exists($class) && !$this->_requireFile($this->path, $this->file)) {
   153|             $class = Inflector::camelize(Inflector::slug(Configure::read('App.dir'))) . 'Schema';
   154|             if (!class_exists($class)) {
   155|                 $this->_requireFile($this->path, $this->file);
   156|             }
   157|         }
   158|         if (class_exists($class)) {
   159|             $Schema = new $class($options);
   160|             return $Schema;
   161|         }
   162|         return false;
   163|     }
   164|     /**
   165|      * Reads database and creates schema tables.
   166|      *
   167|      * Options
   168|      *
   169|      * - 'connection' - the db connection to use
   170|      * - 'name' - name of the schema
   171|      * - 'models' - a list of models to use, or false to ignore models
   172|      *
   173|      * @param array $options Schema object properties.
   174|      * @return array Array indexed by name and tables.
   175|      */
   176|     public function read($options = [])
   177|     {
   178|         $options = array_merge(
   179|             [
   180|                 'connection' => $this->connection,
   181|                 'name' => $this->name,
   182|                 'models' => true,
   183|             ],
   184|             $options
   185|         );
   186|         $db = ConnectionManager::getDataSource($options['connection']);
   187|         if (isset($this->plugin)) {
   188|             App::uses($this->plugin . 'AppModel', $this->plugin . '.Model');
   189|         }
   190|         $tables = [];
   191|         $currentTables = (array)$db->listSources();
   192|         $prefix = null;
   193|         if (isset($db->config['prefix'])) {
   194|             $prefix = $db->config['prefix'];
   195|         }
   196|         if (!is_array($options['models']) && $options['models'] !== false) {
   197|             if (isset($this->plugin)) {
   198|                 $options['models'] = App::objects($this->plugin . '.Model', null, false);
   199|             } else {
   200|                 $options['models'] = App::objects('Model');
   201|             }
   202|         }
   203|         if (is_array($options['models'])) {
   204|             foreach($options['models'] as $model) {
   205|                 $importModel = $model;
   206|                 $plugin = null;
   207|                 if ($model === 'AppModel') {
   208|                     continue;
   209|                 }
   210|                 if (isset($this->plugin)) {
   211|                     if ($model === $this->plugin . 'AppModel') {
   212|                         continue;
   213|                     }
   214|                     $importModel = $model;
   215|                     $plugin = $this->plugin . '.';
   216|                 }
   217|                 App::uses($importModel, $plugin . 'Model');
   218|                 if (!class_exists($importModel)) {
   219|                     continue;
   220|                 }
   221|                 $vars = get_class_vars($model);
   222|                 if (empty($vars['useDbConfig']) || $vars['useDbConfig'] != $options['connection']) {
   223|                     continue;
   224|                 }
   225|                 try {
   226|                     $Object = ClassRegistry::init(['class' => $model, 'ds' => $options['connection']]);
   227|                 } catch (CakeException $e) {
   228|                     continue;
   229|                 }
   230|                 if (!is_object($Object) || $Object->useTable === false) {
   231|                     continue;
   232|                 }
   233|                 $db = $Object->getDataSource();
   234|                 $fulltable = $table = $db->fullTableName($Object, false, false);
   235|                 if ($prefix && strpos($table, $prefix) !== 0) {
   236|                     continue;
   237|                 }
   238|                 if (!in_array($fulltable, $currentTables)) {
   239|                     continue;
   240|                 }
   241|                 $table = $this->_noPrefixTable($prefix, $table);
   242|                 $key = array_search($fulltable, $currentTables);
   243|                 if (empty($tables[$table])) {
   244|                     $tables[$table] = $this->_columns($Object);
   245|                     $tables[$table]['indexes'] = $db->index($Object);
   246|                     $tables[$table]['tableParameters'] = $db->readTableParameters($fulltable);
   247|                     unset($currentTables[$key]);
   248|                 }
   249|                 if (empty($Object->hasAndBelongsToMany)) {
   250|                     continue;
   251|                 }
   252|                 foreach($Object->hasAndBelongsToMany as $assocData) {
   253|                     if (isset($assocData['with'])) {
   254|                         $class = $assocData['with'];
   255|                     }
   256|                     if (!is_object($Object->$class)) {
   257|                         continue;
   258|                     }
   259|                     $withTable = $db->fullTableName($Object->$class, false, false);
   260|                     if ($prefix && strpos($withTable, $prefix) !== 0) {
   261|                         continue;
   262|                     }
   263|                     if (in_array($withTable, $currentTables)) {
   264|                         $key = array_search($withTable, $currentTables);
   265|                         $noPrefixWith = $this->_noPrefixTable($prefix, $withTable);
   266|                         $tables[$noPrefixWith] = $this->_columns($Object->$class);
   267|                         $tables[$noPrefixWith]['indexes'] = $db->index($Object->$class);
   268|                         $tables[$noPrefixWith]['tableParameters'] = $db->readTableParameters($withTable);
   269|                         unset($currentTables[$key]);
   270|                     }
   271|                 }
   272|             }
   273|         }
   274|         if (!empty($currentTables)) {
   275|             foreach($currentTables as $table) {
   276|                 if ($prefix) {
   277|                     if (strpos($table, $prefix) !== 0) {
   278|                         continue;
   279|                     }
   280|                     $table = $this->_noPrefixTable($prefix, $table);
   281|                 }
   282|                 $Object = new AppModel([
   283|                     'name' => Inflector::classify($table), 'table' => $table, 'ds' => $options['connection']
   284|                 ]);
   285|                 $systemTables = [
   286|                     'aros', 'acos', 'aros_acos', Configure::read('Session.table'), 'i18n'
   287|                 ];
   288|                 $fulltable = $db->fullTableName($Object, false, false);
   289|                 if (in_array($table, $systemTables)) {
   290|                     $tables[$Object->table] = $this->_columns($Object);
   291|                     $tables[$Object->table]['indexes'] = $db->index($Object);
   292|                     $tables[$Object->table]['tableParameters'] = $db->readTableParameters($fulltable);
   293|                 } elseif ($options['models'] === false) {
   294|                     $tables[$table] = $this->_columns($Object);
   295|                     $tables[$table]['indexes'] = $db->index($Object);
   296|                     $tables[$table]['tableParameters'] = $db->readTableParameters($fulltable);
   297|                 } else {
   298|                     $tables['missing'][$table] = $this->_columns($Object);
   299|                     $tables['missing'][$table]['indexes'] = $db->index($Object);
   300|                     $tables['missing'][$table]['tableParameters'] = $db->readTableParameters($fulltable);
   301|                 }
   302|             }
   303|         }
   304|         ksort($tables);
   305|         return ['name' => $options['name'], 'tables' => $tables];
   306|     }
   307|     /**
   308|      * Generate the schema code for a table.
   309|      *
   310|      * Takes a table name and $fields array and returns a completed,
   311|      * escaped variable declaration to be used in schema classes.
   312|      *
   313|      * @param string $table Table name you want returned.
   314|      * @param array $fields Array of field information to generate the table with.
   315|      * @return string Variable declaration for a schema class.
   316|      * @throws Exception
   317|      */
   318|     public function generateTable($table, $fields)
   319|     {
   320|         if (!preg_match('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $table)) {
   321|             throw new Exception("Invalid table name '{$table}'");
   322|         }
   323|         $out = "\tpublic \${$table} = array(\n";
   324|         if (is_array($fields)) {
   325|             $cols = [];
   326|             foreach($fields as $field => $value) {
   327|                 if ($field !== 'indexes' && $field !== 'tableParameters') {
   328|                     if (is_string($value)) {
   329|                         $type = $value;
   330|                         $value = ['type' => $type];
   331|                     }
   332|                     $value['type'] = addslashes($value['type']);
   333|                     $col = "\t\t'{$field}' => array('type' => '" . $value['type'] . "', ";
   334|                     unset($value['type']);
   335|                     $col .= implode(', ', $this->_values($value));
   336|                 } elseif ($field === 'indexes') {
   337|                     $col = "\t\t'indexes' => array(\n\t\t\t";
   338|                     $props = [];
   339|                     foreach((array)$value as $key => $index) {
   340|                         $props[] = "'{$key}' => array(" . implode(', ', $this->_values($index)) . ")";
   341|                     }
   342|                     $col .= implode(",\n\t\t\t", $props) . "\n\t\t";
   343|                 } elseif ($field === 'tableParameters') {
   344|                     $col = "\t\t'tableParameters' => array(";
   345|                     $props = $this->_values($value);
   346|                     $col .= implode(', ', $props);
   347|                 }
   348|                 $col .= ")";
   349|                 $cols[] = $col;
   350|             }
   351|             $out .= implode(",\n", $cols);
   352|         }
   353|         $out .= "\n\t);\n\n";
   354|         return $out;
   355|     }
   356|     /**
   357|      * Compares two sets of schemas.
   358|      *
   359|      * @param array|object $old Schema object or array.
   360|      * @param array|object $new Schema object or array.
   361|      * @return array Tables (that are added, dropped, or changed.)
   362|      */
   363|     public function compare($old, $new = null)
   364|     {
   365|         if (empty($new)) {
   366|             $new = $this;
   367|         }
   368|         if (is_array($new)) {
   369|             if (isset($new['tables'])) {
   370|                 $new = $new['tables'];
   371|             }
   372|         } else {
   373|             $new = $new->tables;
   374|         }
   375|         if (is_array($old)) {
   376|             if (isset($old['tables'])) {
   377|                 $old = $old['tables'];
   378|             }
   379|         } else {
   380|             $old = $old->tables;
   381|         }
   382|         $tables = [];
   383|         foreach($new as $table => $fields) {
   384|             if ($table === 'missing') {
   385|                 continue;
   386|             }
   387|             if (!array_key_exists($table, $old)) {
   388|                 $tables[$table]['create'] = $fields;
   389|             } else {
   390|                 $diff = $this->_arrayDiffAssoc($fields, $old[$table]);
   391|                 if (!empty($diff)) {
   392|                     $tables[$table]['add'] = $diff;
   393|                 }
   394|                 $diff = $this->_arrayDiffAssoc($old[$table], $fields);
   395|                 if (!empty($diff)) {
   396|                     $tables[$table]['drop'] = $diff;
   397|                 }
   398|             }
   399|             foreach($fields as $field => $value) {
   400|                 if (!empty($old[$table][$field])) {
   401|                     $diff = $this->_arrayDiffAssoc($value, $old[$table][$field]);
   402|                     if (empty($diff)) {
   403|                         $diff = $this->_arrayDiffAssoc($old[$table][$field], $value);
   404|                     }
   405|                     if (!empty($diff) && $field !== 'indexes' && $field !== 'tableParameters') {
   406|                         $tables[$table]['change'][$field] = array_merge($old[$table][$field], $diff);
   407|                     }
   408|                 }
   409|                 if (isset($tables[$table]['add'][$field]) && $field !== 'indexes' && $field !== 'tableParameters') {
   410|                     $wrapper = array_keys($fields);
   411|                     if ($column = array_search($field, $wrapper)) {
   412|                         if (isset($wrapper[$column - 1])) {
   413|                             $tables[$table]['add'][$field]['after'] = $wrapper[$column - 1];
   414|                         }
   415|                     }
   416|                 }
   417|             }
   418|             if (isset($old[$table]['indexes']) && isset($new[$table]['indexes'])) {
   419|                 $diff = $this->_compareIndexes($new[$table]['indexes'], $old[$table]['indexes']);
   420|                 if ($diff) {
   421|                     if (!isset($tables[$table])) {
   422|                         $tables[$table] = [];
   423|                     }
   424|                     if (isset($diff['drop'])) {
   425|                         $tables[$table]['drop']['indexes'] = $diff['drop'];
   426|                     }
   427|                     if ($diff && isset($diff['add'])) {
   428|                         $tables[$table]['add']['indexes'] = $diff['add'];
   429|                     }
   430|                 }
   431|             }
   432|             if (isset($old[$table]['tableParameters']) && isset($new[$table]['tableParameters'])) {
   433|                 $diff = $this->_compareTableParameters($new[$table]['tableParameters'], $old[$table]['tableParameters']);
   434|                 if ($diff) {
   435|                     $tables[$table]['change']['tableParameters'] = $diff;
   436|                 }
   437|             }
   438|         }
   439|         return $tables;
   440|     }
   441|     /**
   442|      * Extended array_diff_assoc noticing change from/to NULL values.
   443|      *
   444|      * It behaves almost the same way as array_diff_assoc except for NULL values: if
   445|      * one of the values is not NULL - change is detected. It is useful in situation
   446|      * where one value is strval('') ant other is strval(null) - in string comparing
   447|      * methods this results as EQUAL, while it is not.
   448|      *
   449|      * @param array $array1 Base array.
   450|      * @param array $array2 Corresponding array checked for equality.
   451|      * @return array Difference as array with array(keys => values) from input array
   452|      *     where match was not found.
   453|      */
   454|     protected function _arrayDiffAssoc($array1, $array2)
   455|     {
   456|         $difference = [];
   457|         foreach($array1 as $key => $value) {
   458|             if (!array_key_exists($key, $array2)) {
   459|                 $difference[$key] = $value;
   460|                 continue;
   461|             }
   462|             $correspondingValue = $array2[$key];
   463|             if (($value === null) !== ($correspondingValue === null)) {
   464|                 $difference[$key] = $value;
   465|                 continue;
   466|             }
   467|             if (is_bool($value) !== is_bool($correspondingValue)) {
   468|                 $difference[$key] = $value;
   469|                 continue;
   470|             }
   471|             if (is_array($value) && is_array($correspondingValue)) {
   472|                 continue;
   473|             }
   474|             if ($value === $correspondingValue) {
   475|                 continue;
   476|             }
   477|             $difference[$key] = $value;
   478|         }
   479|         return $difference;
   480|     }
   481|     /**
   482|      * Formats Schema columns from Model Object.
   483|      *
   484|      * @param array $values Options keys(type, null, default, key, length, extra).
   485|      * @return array Formatted values.
   486|      */
   487|     protected function _values($values)
   488|     {
   489|         $vals = [];
   490|         if (is_array($values)) {
   491|             foreach($values as $key => $val) {
   492|                 if (is_array($val)) {
   493|                     $vals[] = "'{$key}' => array(" . implode(", ", $this->_values($val)) . ")";
   494|                 } else {
   495|                     $val = var_export($val, true);
   496|                     if ($val === 'NULL') {
   497|                         $val = 'null';
   498|                     }
   499|                     if (!is_numeric($key)) {
   500|                         $vals[] = "'{$key}' => {$val}";
   501|                     } else {
   502|                         $vals[] = "{$val}";
   503|                     }
   504|                 }
   505|             }
   506|         }
   507|         return $vals;
   508|     }
   509|     /**
   510|      * Formats Schema columns from Model Object.
   511|      *
   512|      * @param array &$Obj model object.
   513|      * @return array Formatted columns.
   514|      */
   515|     protected function _columns(&$Obj)
   516|     {
   517|         $db = $Obj->getDataSource();
   518|         $fields = $Obj->schema(true);
   519|         $hasPrimaryAlready = false;
   520|         foreach($fields as $value) {
   521|             if (isset($value['key']) && $value['key'] === 'primary') {
   522|                 $hasPrimaryAlready = true;
   523|                 break;
   524|             }
   525|         }
   526|         $columns = [];
   527|         foreach($fields as $name => $value) {
   528|             if ($Obj->primaryKey === $name && !$hasPrimaryAlready && !isset($value['key'])) {
   529|                 $value['key'] = 'primary';
   530|             }
   531|             if (substr($value['type'], 0, 4) !== 'enum') {
   532|                 if (!isset($db->columns[$value['type']])) {
   533|                     trigger_error(__d('cake_dev', 'Schema generation error: invalid column type %s for %s.%s does not exist in DBO', $value['type'], $Obj->name, $name), E_USER_NOTICE);
   534|                     continue;
   535|                 } else {
   536|                     $defaultCol = $db->columns[$value['type']];
   537|                     if (isset($defaultCol['limit']) && $defaultCol['limit'] == $value['length']) {
   538|                         unset($value['length']);
   539|                     } elseif (isset($defaultCol['length']) && $defaultCol['length'] == $value['length']) {
   540|                         unset($value['length']);
   541|                     }
   542|                     unset($value['limit']);
   543|                 }
   544|             }
   545|             if (isset($value['default']) && ($value['default'] === '' || ($value['default'] === false && $value['type'] !== 'boolean'))) {
   546|                 unset($value['default']);
   547|             }
   548|             if (empty($value['length'])) {
   549|                 unset($value['length']);
   550|             }
   551|             if (empty($value['key'])) {
   552|                 unset($value['key']);
   553|             }
   554|             $columns[$name] = $value;
   555|         }
   556|         return $columns;
   557|     }
   558|     /**
   559|      * Compare two schema files table Parameters.
   560|      *
   561|      * @param array $new New indexes.
   562|      * @param array $old Old indexes.
   563|      * @return mixed False on failure, or an array of parameters to add & drop.
   564|      */
   565|     protected function _compareTableParameters($new, $old)
   566|     {
   567|         if (!is_array($new) || !is_array($old)) {
   568|             return false;
   569|         }
   570|         $change = $this->_arrayDiffAssoc($new, $old);
   571|         return $change;
   572|     }
   573|     /**
   574|      * Compare two schema indexes.
   575|      *
   576|      * @param array $new New indexes.
   577|      * @param array $old Old indexes.
   578|      * @return mixed False on failure or array of indexes to add and drop.
   579|      */
   580|     protected function _compareIndexes($new, $old)
   581|     {
   582|         if (!is_array($new) || !is_array($old)) {
   583|             return false;
   584|         }
   585|         $add = $drop = [];
   586|         $diff = $this->_arrayDiffAssoc($new, $old);
   587|         if (!empty($diff)) {
   588|             $add = $diff;
   589|         }
   590|         $diff = $this->_arrayDiffAssoc($old, $new);
   591|         if (!empty($diff)) {
   592|             $drop = $diff;
   593|         }
   594|         foreach($new as $name => $value) {
   595|             if (isset($old[$name])) {
   596|                 $newUnique = isset($value['unique'])? $value['unique'] : 0;
   597|                 $oldUnique = isset($old[$name]['unique'])? $old[$name]['unique'] : 0;
   598|                 $newColumn = $value['column'];
   599|                 $oldColumn = $old[$name]['column'];
   600|                 $diff = false;
   601|                 if ($newUnique != $oldUnique) {
   602|                     $diff = true;
   603|                 } elseif (is_array($newColumn) && is_array($oldColumn)) {
   604|                     $diff = ($newColumn !== $oldColumn);
   605|                 } elseif (is_string($newColumn) && is_string($oldColumn)) {
   606|                     $diff = ($newColumn != $oldColumn);
   607|                 } else {
   608|                     $diff = true;
   609|                 }
   610|                 if ($diff) {
   611|                     $drop[$name] = null;
   612|                     $add[$name] = $value;
   613|                 }
   614|             }
   615|         }
   616|         return array_filter(compact('add', 'drop'));
   617|     }
   618|     /**
   619|      * Trim the table prefix from the full table name, and return the prefix-less
   620|      * table.
   621|      *
   622|      * @param string $prefix Table prefix.
   623|      * @param string $table Full table name.
   624|      * @return string Prefix-less table name.
   625|      */
   626|     protected function _noPrefixTable($prefix, $table)
   627|     {
   628|         return preg_replace('/^' . preg_quote($prefix) . '/', '', $table);
   629|     }
   630|     /**
   631|      * Attempts to require the schema file specified.
   632|      *
   633|      * @param string $path Filesystem path to the file.
   634|      * @param string $file Filesystem basename of the file.
   635|      * @return bool True when a file was successfully included, false on failure.
   636|      */
   637|     protected function _requireFile($path, $file)
   638|     {
   639|         if (file_exists($path . DS . $file) && is_file($path . DS . $file)) {
   640|             require_once $path . DS . $file;
   641|             return true;
   642|         } elseif (file_exists($path . DS . 'schema.php') && is_file($path . DS . 'schema.php')) {
   643|             require_once $path . DS . 'schema.php';
   644|             return true;
   645|         }
   646|         return false;
   647|     }
   648| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/Datasource/Database/BcMysql.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Model\Datasource\Database;
    12| use Cake\Database\Driver\Mysql;
    13| /**
    14|  * Class BcMysql
    15|  *
    16|  * MySQL DBO拡張
    17|  *
    18|  */
    19| class BcMysql extends Mysql
    20| {
    21|     /**
    22|      * テーブル名のリネームステートメントを生成
    23|      *
    24|      * @param string $sourceName
    25|      * @param string $targetName
    26|      * @return string
    27|      */
    28|     public function buildRenameTable($sourceName, $targetName)
    29|     {
    30|         return "ALTER TABLE `" . $sourceName . "` RENAME `" . $targetName . "`";
    31|     }
    32| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/Datasource/Database/BcPostgres.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-262 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Model\Datasource\Database;
    12| use Cake\Database\Driver\Postgres;
    13| /**
    14|  * Class BcPostgres
    15|  *
    16|  * PostgreSQL DBO拡張
    17|  *
    18|  */
    19| class BcPostgres extends Postgres
    20| {
    21|     /**
    22|      * Returns an array of the fields in given table name.
    23|      *
    24|      * @param Model|string $model Name of database table to inspect
    25|      * @return array Fields in table. Keys are name and type
    26|      */
    27|     public function describe($model)
    28|     {
    29|         $table = $this->fullTableName($model, false, false);
    30|         $fields = $this->__describe($table);
    31|         $cols = null;
    32|         $hasPrimary = false;
    33|         if ($fields === null) {
    34|             /*$cols = $this->_execute(
    35|                 'SELECT DISTINCT table_schema AS schema,
    36|                     column_name AS name,
    37|                     data_type AS type,
    38|                     is_nullable AS null,
    39|                     column_default AS default,
    40|                     ordinal_position AS position,
    41|                     character_maximum_length AS char_length,
    42|                     character_octet_length AS oct_length,
    43|                     pg_get_serial_sequence(attr.attrelid::regclass::text, attr.attname) IS NOT NULL AS has_serial
    44|                 FROM information_schema.columns c
    45|                 INNER JOIN pg_catalog.pg_namespace ns ON (ns.nspname = table_schema)
    46|                 INNER JOIN pg_catalog.pg_class cl ON (cl.relnamespace = ns.oid AND cl.relname = table_name)
    47|                 LEFT JOIN pg_catalog.pg_attribute attr ON (cl.oid = attr.attrelid AND column_name = attr.attname)
    48|                 WHERE table_name = ? AND table_schema = ? AND table_catalog = ?
    49|                 ORDER BY ordinal_position',
    50|                 array($table, $this->config['schema'], $this->config['database'])
    51|             );*/
    52|             $cols = $this->_execute(
    53|                 "SELECT DISTINCT table_schema AS schema, column_name AS name, data_type AS type, udt_name AS udt, is_nullable AS null," .
    54|                 "column_default AS default, ordinal_position AS position, character_maximum_length AS char_length," .
    55|                 "character_octet_length AS oct_length FROM information_schema.columns " .
    56|                 "WHERE table_name = ? AND table_schema = ?  ORDER BY position",
    57|                 [$table, $this->config['schema']]
    58|             );
    59|             foreach($cols as $c) {
    60|                 $type = $c->type;
    61|                 if (!empty($c->oct_length) && $c->char_length === null) {
    62|                     if ($c->type === 'character varying') {
    63|                         $length = null;
    64|                         $type = 'text';
    65|                     } elseif ($c->type == 'text') {
    66|                         $length = null;
    67|                     } elseif ($c->type === 'uuid') {
    68|                         $type = 'uuid';
    69|                         $length = 36;
    70|                     } else {
    71|                         $length = (int)$c->oct_length;
    72|                     }
    73|                 } elseif (!empty($c->char_length)) {
    74|                     $length = (int)$c->char_length;
    75|                 } else {
    76|                     $length = $this->length($c->udt);
    77|                 }
    78|                 if (empty($length)) {
    79|                     $length = null;
    80|                 }
    81|                 $fields[$c->name] = [
    82|                     'type' => $this->column($type),
    83|                     'null' => ($c->null === 'NO'? false : true),
    84|                     'default' => preg_replace(
    85|                         "/^'(.*)'$/",
    86|                         "$1",
    87|                         preg_replace('/::[\w\s]+/', '', $c->default)
    88|                     ),
    89|                     'length' => $length,
    90|                 ];
    91|                 if (!$fields[$c->name]['length'] && $fields[$c->name]['type'] == 'integer') {
    92|                     $fields[$c->name]['length'] = 8;
    93|                 }
    94|                 if ($c->has_serial) {
    95|                     $fields[$c->name]['key'] = 'primary';
    96|                     $fields[$c->name]['length'] = 11;
    97|                     $hasPrimary = true;
    98|                 }
    99|                 if ($hasPrimary === false &&
   100|                     $model instanceof Model &&
   101|                     $c->name === $model->primaryKey
   102|                 ) {
   103|                     $fields[$c->name]['key'] = 'primary';
   104|                     if (
   105|                         $fields[$c->name]['type'] !== 'string' &&
   106|                         $fields[$c->name]['type'] !== 'uuid'
   107|                     ) {
   108|                         $fields[$c->name]['length'] = 11;
   109|                     }
   110|                 }
   111|                 if (
   112|                     $fields[$c->name]['default'] === 'NULL' ||
   113|                     $c->default === null ||
   114|                     preg_match('/nextval\([\'"]?([\w.]+)/', $c->default, $seq)
   115|                 ) {
   116|                     $fields[$c->name]['default'] = null;
   117|                     if (!empty($seq) && isset($seq[1])) {
   118|                         if (strpos($seq[1], '.') === false) {
   119|                             $sequenceName = $c->schema . '.' . $seq[1];
   120|                         } else {
   121|                             $sequenceName = $seq[1];
   122|                         }
   123|                         $this->_sequenceMap[$table][$c->name] = $sequenceName;
   124|                     }
   125|                 }
   126|                 if ($fields[$c->name]['type'] === 'timestamp' && $fields[$c->name]['default'] === '') {
   127|                     $fields[$c->name]['default'] = null;
   128|                 }
   129|                 if ($fields[$c->name]['type'] === 'boolean' && !empty($fields[$c->name]['default'])) {
   130|                     $fields[$c->name]['default'] = constant($fields[$c->name]['default']);
   131|                 }
   132|             }
   133|             $fields['sequence'] = $this->_sequenceMap;
   134|             $this->_cacheDescription($table, $fields);
   135|         }
   136|         unset($fields['sequence']);
   137|         if (isset($model->sequence)) {
   138|             $this->_sequenceMap[$table][$model->primaryKey] = $model->sequence;
   139|         }
   140|         if ($cols) {
   141|             $cols->closeCursor();
   142|         }
   143|         return $fields;
   144|     }
   145|     /**
   146|      * Gets the length of a database-native column description, or null if no length
   147|      *
   148|      * @param string $real Real database-layer column type (i.e. "varchar(255)")
   149|      * @return integer An integer representing the length of the column
   150|      */
   151|     public function length($real)
   152|     {
   153|         if (preg_match('/^int([0-9]+)$/', $real, $maches)) {
   154|             return intval($maches[1]);
   155|         }
   156|         $col = $real;
   157|         if (strpos($real, '(') !== false) {
   158|             [$col, $limit] = explode('(', $real);
   159|         }
   160|         if ($col === 'uuid') {
   161|             return 36;
   162|         }
   163|         return parent::length($real);
   164|     }
   165|     /**
   166|      * {@inheritDoc}
   167|      */
   168|     public function value($data, $column = null, $null = true)
   169|     {
   170|         $value = parent::value($data, $column, $null);
   171|         if ($column === 'uuid' && is_scalar($data) && $data === '') {
   172|             return 'NULL';
   173|         }
   174|         switch($column) {
   175|             case 'date':
   176|             case 'datetime':
   177|             case 'timestamp':
   178|             case 'time':
   179|                 if ($data === '0000-00-00 00:00:00') {
   180|                     return "'" . date('Y-m-d H:i:s', 0) . "'";
   181|                 }
   182|             case 'integer':
   183|                 if ($data === false) {
   184|                     return 'NULL';
   185|                 }
   186|         }
   187|         return $value;
   188|     }
   189|     /**
   190|      * テーブル名のリネームステートメントを生成
   191|      *
   192|      * @param string $sourceName
   193|      * @param string $targetName
   194|      * @return string
   195|      */
   196|     public function buildRenameTable($sourceName, $targetName)
   197|     {
   198|         return "ALTER TABLE " . $sourceName . " RENAME TO " . $targetName;
   199|     }
   200|     /**
   201|      * カラム名を変更する
   202|      *
   203|      * @param array $options [ table / new / old  ]
   204|      * @return boolean
   205|      */
   206|     public function renameColumn($options)
   207|     {
   208|         extract($options);
   209|         if (!isset($table) || !isset($new) || !isset($old)) {
   210|             return false;
   211|         }
   212|         $table = $this->config['prefix'] . $table;
   213|         $sql = 'ALTER TABLE "' . $table . '" RENAME "' . $old . '" TO "' . $new . '"';
   214|         return $this->execute($sql);
   215|     }
   216|     /**
   217|      * DboPostgresのdescribeメソッドを呼び出さずにキャッシュを読み込む為に利用
   218|      * Datasource::describe と同じ（一部ハック）
   219|      *
   220|      * @param Model|string $model
   221|      * @return array Array of Metadata for the $model
   222|      */
   223|     private function __describe($model)
   224|     {
   225|         if ($this->cacheSources === false) {
   226|             return null;
   227|         }
   228|         if (is_string($model)) {
   229|             $table = $model;
   230|         } else {
   231|             $table = $model->tablePrefix . $model->table;
   232|         }
   233|         if (isset($this->_descriptions[$table])) {
   234|             return $this->_descriptions[$table];
   235|         }
   236|         $cache = $this->_cacheDescription($table);
   237|         if ($cache !== null) {
   238|             if (!empty($cache['sequence'][$table])) {
   239|                 $this->_sequenceMap[$table] = $cache['sequence'][$table];
   240|             }
   241|             unset($cache['sequence']);
   242|             $this->_descriptions[$table] =& $cache;
   243|             return $cache;
   244|         }
   245|         return null;
   246|     }
   247|     /**
   248|      * シーケンスを更新する
   249|      */
   250|     public function updateSequence()
   251|     {
   252|         $tables = $this->listSources();
   253|         $result = true;
   254|         foreach($tables as $table) {
   255|             $sql = 'select setval(\'' . $this->getSequence($table) . '\', (select max(id) from ' . $table . '));';
   256|             if (!$this->execute($sql)) {
   257|                 $result = false;
   258|             }
   259|         }
   260|         return $result;
   261|     }
   262| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/Datasource/Database/BcSqlite.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-980 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\Model\Datasource\Database;
    12| use Cake\Database\Driver\Sqlite;
    13| /**
    14|  * Class BcSqlite
    15|  *
    16|  * SQLite DBO拡張
    17|  *
    18|  * @TODO 2014/07/04 ryuring
    19|  *        CakePHPの標準のものを移植しようとしたが全く使い物にならなかったので、
    20|  *        一旦、スルーして現行のものをそのまま利用する事にした。
    21|  *        listSourcesの取得で何故かエラーとなっていた。
    22|  * @package Baser.Model.Datasource.Database
    23|  */
    24| class BcSqlite extends Sqlite
    25| {
    26|     /**
    27|      * Enter description here...
    28|      *
    29|      * @var string
    30|      */
    31|     public $description = "SQLite3 DBO Driver";
    32|     /**
    33|      * Enter description here...
    34|      *
    35|      * @var string
    36|      */
    37|     public $startQuote = '"';
    38|     /**
    39|      * Enter description here...
    40|      *
    41|      * @var string
    42|      */
    43|     public $endQuote = '"';
    44|     /**
    45|      * Base configuration settings for SQLite3 driver
    46|      *
    47|      * @var array
    48|      */
    49|     protected $_baseConfig = [
    50|         'persistent' => false,
    51|         'database' => null,
    52|         'connect' => 'sqlite' //sqlite3 in pdo_sqlite is sqlite. sqlite2 is sqlite2
    53|     ];
    54|     /**
    55|      * SQLite3 column definition
    56|      *
    57|      * @var array
    58|      */
    59|     public $columns = [
    60|         'primary_key' => ['name' => 'integer primary key autoincrement'],
    61|         'string' => ['name' => 'varchar', 'limit' => '255'],
    62|         'text' => ['name' => 'text'],
    63|         'integer' => ['name' => 'integer', 'limit' => null, 'formatter' => 'intval'],
    64|         'float' => ['name' => 'float', 'formatter' => 'floatval'],
    65|         'datetime' => ['name' => 'datetime', 'format' => 'Y-m-d H:i:s', 'formatter' => 'date'],
    66|         'timestamp' => ['name' => 'timestamp', 'format' => 'Y-m-d H:i:s', 'formatter' => 'date'],
    67|         'time' => ['name' => 'time', 'format' => 'H:i:s', 'formatter' => 'date'],
    68|         'date' => ['name' => 'date', 'format' => 'Y-m-d', 'formatter' => 'date'],
    69|         'binary' => ['name' => 'blob'],
    70|         'boolean' => ['name' => 'boolean']
    71|     ];
    72|     public $last_error = null;
    73|     public $pdo_statement = null;
    74|     public $rows = null;
    75|     public $row_count = null;
    76|     /**
    77|      * Connects to the database using config['database'] as a filename.
    78|      *
    79|      * @param array $config Configuration array for connecting
    80|      * @return mixed
    81|      */
    82|     public function connect(): bool
    83|     {
    84|         $this->last_error = null;
    85|         $config = $this->config;
    86|         try {
    87|             $this->_connection = new PDO($config['connect'] . ':' . $config['database']);
    88|             $this->_connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    89|             $this->connected = is_object($this->_connection);
    90|         } catch (PDOException $e) {
    91|             $this->last_error = ['Error connecting to database.', $e->getMessage()];
    92|         }
    93|         return $this->connected;
    94|     }
    95|     /**
    96|      * Disconnects from database.
    97|      *
    98|      * @return boolean True if the database could be disconnected, else false
    99|      */
   100|     public function disconnect(): void
   101|     {
   102|         $this->_connection = null;
   103|         $this->connected = false;
   104|     }
   105|     /**
   106|      * Executes given SQL statement.
   107|      *
   108|      * @param string $sql SQL statement
   109|      * @return resource Result resource identifier
   110|      */
   111|     protected function _execute($sql, $params = [], $prepareOptions = [])
   112|     {
   113|         for($i = 0; $i < 2; $i++) {
   114|             try {
   115|                 $this->last_error = null;
   116|                 $this->pdo_statement = $this->_connection->query($sql);
   117|                 if (is_object($this->pdo_statement)) {
   118|                     $this->rows = $this->pdo_statement->fetchAll(PDO::FETCH_NUM);
   119|                     $this->row_count = count($this->rows);
   120|                     return $this->pdo_statement;
   121|                 }
   122|             } catch (PDOException $e) {
   123|                 if ($e->errorInfo[1] === 17) {
   124|                     continue;
   125|                 }
   126|                 $this->last_error = $e->getMessage();
   127|             }
   128|         }
   129|         return false;
   130|     }
   131|     /**
   132|      * Returns an array of tables in the database. If there are no tables, an error is raised and the application exits.
   133|      *
   134|      * @return array Array of tablenames in the database
   135|      */
   136|     public function listSources($data = null)
   137|     {
   138|         $db = $this->config['database'];
   139|         $this->config['database'] = basename($this->config['database']);
   140|         $cache = parent::listSources();
   141|         if ($cache != null) {
   142|             $this->config['database'] = $db;
   143|             return $cache;
   144|         }
   145|         $result = $this->fetchAll("SELECT name FROM sqlite_master WHERE type='table' AND name<>'sqlite_sequence' ORDER BY name;", false);
   146|         if (!$result || empty($result)) {
   147|             $this->config['database'] = $db;
   148|             return [];
   149|         } else {
   150|             $tables = [];
   151|             foreach($result as $table) {
   152|                 $tables[] = $table[0]['name'];
   153|             }
   154|             parent::listSources($tables);
   155|             $this->config['database'] = $db;
   156|             return $tables;
   157|         }
   158|         $this->config['database'] = $db;
   159|         return [];
   160|     }
   161|     /**
   162|      * Returns a quoted and escaped string of $data for use in an SQL statement.
   163|      *
   164|      * @param string $data String to be prepared for use in an SQL statement
   165|      * @param string $column
   166|      * @param int $safe
   167|      * @return string Quoted and escaped
   168|      */
   169|     public function value($data, $column = null, $safe = false)
   170|     {
   171|         if (($column == 'boolean' && ($data === "'0'" || $data === "'1'"))) {
   172|             return $data;
   173|         }
   174|         $parent = parent::value($data, $column, $safe);
   175|         if ($parent != null) {
   176|             return $parent;
   177|         }
   178|         if ($data === null) {
   179|             return 'NULL';
   180|         }
   181|         switch($column) {
   182|             case 'boolean':
   183|                 if ($data === '') {
   184|                     return 0;
   185|                 }
   186|                 $data = $this->boolean((bool)$data);
   187|                 break;
   188|             case 'integer';
   189|                 if ($data === '') {
   190|                     return 'NULL';
   191|                 }
   192|                 break;
   193|             case 'datetime':
   194|                 if ($data) {
   195|                     $data = trim(str_replace('/', '-', $data));
   196|                 }
   197|                 if ($data === '' || $data == '0000-00-00 00:00:00') {
   198|                     return "''";
   199|                 }
   200|                 break;
   201|             default:
   202|                 if ($data === '') {
   203|                     return "''";
   204|                 }
   205|                 $data = $this->_connection->quote($data);
   206|                 return $data;
   207|                 break;
   208|         }
   209|         return "'" . $data . "'";
   210|     }
   211|     /**
   212|      * Generates and executes an SQL UPDATE statement for given model, fields, and values.
   213|      *
   214|      * @param Model $model
   215|      * @param array $fields
   216|      * @param array $values
   217|      * @param mixed $conditions
   218|      * @return array
   219|      */
   220|     public function update(Model $model, $fields = null, $values = null, $conditions = null)
   221|     {
   222|         if (empty($values) && !empty($fields)) {
   223|             foreach($fields as $field => $value) {
   224|                 if (strpos($field, $model->alias . '.') !== false) {
   225|                     unset($fields[$field]);
   226|                     $field = str_replace($model->alias . '.', "", $field);
   227|                     $field = str_replace($model->alias . '.', "", $field);
   228|                     $fields[$field] = $value;
   229|                 }
   230|             }
   231|         }
   232|         return parent::update($model, $fields, $values, $conditions);
   233|     }
   234|     /**
   235|      * Begin a transaction
   236|      * TODO データベースがロックされてしまい正常に処理が実行されないのでとりあえず未実装とする
   237|      * ロックに関する原因については未解析
   238|      *
   239|      * @param string $model
   240|      * @return boolean True on success, false on fail
   241|      * (i.e. if the database/model does not support transactions).
   242|      */
   243|     public function begin()
   244|     {
   245|         return null;
   246|         /* if (parent::begin($model)) {
   247|           if ($this->_connection->beginTransaction()) {
   248|           $this->_transactionStarted = true;
   249|           return true;
   250|           }
   251|           }
   252|           return false; */
   253|     }
   254|     /**
   255|      * Commit a transaction
   256|      * TODO データベースがロックされてしまい正常に処理が実行されないのでとりあえず未実装とする
   257|      * ロックに関する原因については未解析
   258|      *
   259|      * @param unknown_type $model
   260|      * @return boolean True on success, false on fail
   261|      * (i.e. if the database/model does not support transactions,
   262|      * or a transaction has not started).
   263|      */
   264|     public function commit()
   265|     {
   266|         return null;
   267|         /* if (parent::commit($model)) {
   268|           $this->_transactionStarted = false;
   269|           return $this->_connection->commit();
   270|           }
   271|           return false; */
   272|     }
   273|     /**
   274|      * Rollback a transaction
   275|      * TODO データベースがロックされてしまい正常に処理が実行されないのでとりあえず未実装とする
   276|      * ロックに関する原因については未解析
   277|      *
   278|      * @param unknown_type $model
   279|      * @return boolean True on success, false on fail
   280|      * (i.e. if the database/model does not support transactions,
   281|      * or a transaction has not started).
   282|      */
   283|     public function rollback()
   284|     {
   285|         return null;
   286|         /* if (parent::rollback($model)) {
   287|           return $this->_connection->rollBack();
   288|           }
   289|           return false; */
   290|     }
   291|     /**
   292|      * Returns a formatted error message from previous database operation.
   293|      *
   294|      * @return string Error message
   295|      */
   296|     public function lastError(PDOStatement $query = null)
   297|     {
   298|         return $this->last_error;
   299|     }
   300|     /**
   301|      * Returns number of affected rows in previous database operation. If no previous operation exists, this returns false.
   302|      *
   303|      * @return integer Number of affected rows
   304|      */
   305|     public function lastAffected($source = null)
   306|     {
   307|         if ($this->_result) {
   308|             return $this->pdo_statement->rowCount();
   309|         }
   310|         return false;
   311|     }
   312|     /**
   313|      * Returns number of rows in previous resultset. If no previous resultset exists,
   314|      * this returns false.
   315|      *
   316|      * @return integer Number of rows in resultset
   317|      */
   318|     public function lastNumRows($source = null)
   319|     {
   320|         if ($this->pdo_statement) {
   321|             return $this->row_count;
   322|         }
   323|         return false;
   324|     }
   325|     /**
   326|      * Returns the ID generated from the previous INSERT operation.
   327|      *
   328|      * @return int
   329|      */
   330|     public function lastInsertId(?string $table = null, ?string $column = null)
   331|     {
   332|         return $this->_connection->lastInsertId($table);
   333|     }
   334|     /**
   335|      * Converts database-layer column types to basic types
   336|      *
   337|      * @param string $real Real database-layer column type (i.e. "varchar(255)")
   338|      * @return string Abstract column type (i.e. "string")
   339|      */
   340|     public function column($real)
   341|     {
   342|         if (is_array($real)) {
   343|             $col = $real['name'];
   344|             if (isset($real['limit'])) {
   345|                 $col .= '(' . $real['limit'] . ')';
   346|             }
   347|             return $col;
   348|         }
   349|         $col = strtolower(str_replace(')', '', $real));
   350|         $limit = null;
   351|         @list($col, $limit) = explode('(', $col);
   352|         if (in_array($col, ['text', 'integer', 'float', 'boolean', 'timestamp', 'date', 'datetime', 'time'])) {
   353|             return $col;
   354|         }
   355|         if (strpos($col, 'varchar') !== false || strpos($col, 'char') !== false) {
   356|             return 'string';
   357|         }
   358|         if (in_array($col, ['blob', 'clob'])) {
   359|             return 'binary';
   360|         }
   361|         if (strpos($col, 'numeric') !== false) {
   362|             return 'float';
   363|         }
   364|         return 'text';
   365|     }
   366|     /**
   367|      * Generate ResultSet
   368|      *
   369|      * @param mixed $results The results to modify.
   370|      * @return void
   371|      */
   372|     public function resultSet($results)
   373|     {
   374|         $this->results = $results;
   375|         $this->map = [];
   376|         $numFields = $results->columnCount();
   377|         $index = 0;
   378|         $j = 0;
   379|         $querystring = $results->queryString;
   380|         $selects = [];
   381|         if (stripos($querystring, 'SELECT') === 0 && stripos($querystring, 'FROM') > 0) {
   382|             $selectpart = substr($querystring, 7);
   383|             foreach(CakeText::tokenize($selectpart, ',', '(', ')') as $part) {
   384|                 $fromPos = stripos($part, ' FROM ');
   385|                 if ($fromPos !== false) {
   386|                     $selects[] = trim(substr($part, 0, $fromPos));
   387|                     break;
   388|                 }
   389|                 $selects[] = $part;
   390|             }
   391|         } elseif (strpos($querystring, 'PRAGMA table_info') === 0) {
   392|             $selects = ['cid', 'name', 'type', 'notnull', 'dflt_value', 'pk'];
   393|         } elseif (strpos($querystring, 'PRAGMA index_list') === 0) {
   394|             $selects = ['seq', 'name', 'unique'];
   395|         } elseif (strpos($querystring, 'PRAGMA index_info') === 0) {
   396|             $selects = ['seqno', 'cid', 'name'];
   397|         }
   398|         $columnMeta = [];
   399|         foreach($selects as $select) {
   400|             if (preg_match('/\bAS(?!.*\bAS\b)\s+(.*)/i', $select, $matches)) {
   401|                 $columnName = trim($matches[1], '"');
   402|             } else {
   403|                 $columnName = trim(str_replace('"', '', $select));
   404|             }
   405|             if (strpos($columnName, '.')) {
   406|                 [$table] = explode('.', $columnName);
   407|                 $table = preg_replace('/^DISTINCT\s+/', '', $table);
   408|                 if (empty($columnMeta[$table])) {
   409|                     $pdo_statement = $this->_connection->query('PRAGMA table_info(' . $this->config['prefix'] . Inflector::tableize($table) . ')');
   410|                     $fields = $pdo_statement->fetchAll(PDO::FETCH_ASSOC);
   411|                     foreach($fields as $field) {
   412|                         $columnMeta[$table][$field['name']] = $field;
   413|                     }
   414|                 }
   415|             }
   416|         }
   417|         while($j < $numFields) {
   418|             if (!isset($selects[$j])) {
   419|                 $j++;
   420|                 continue;
   421|             }
   422|             if (preg_match('/\bAS(?!.*\bAS\b)\s+(.*)/i', $selects[$j], $matches)) {
   423|                 $columnName = trim($matches[1], '"');
   424|             } else {
   425|                 $columnName = trim(str_replace('"', '', $selects[$j]));
   426|             }
   427|             if (strpos($selects[$j], 'DISTINCT') === 0) {
   428|                 $columnName = str_ireplace('DISTINCT', '', $columnName);
   429|             }
   430|             $metaType = false;
   431|             try {
   432|                 $metaData = (array)$results->getColumnMeta($j);
   433|                 if (!empty($metaData['sqlite:decl_type'])) {
   434|                     $metaType = trim($metaData['sqlite:decl_type']);
   435|                 }
   436|                 if (!$metaType) {
   437|                     if (strpos($columnName, '.')) {
   438|                         [$table, $column] = explode('.', $columnName);
   439|                         if (!empty($columnMeta[$table][$column]['type'])) {
   440|                             $metaType = $columnMeta[$table][$column]['type'];
   441|                         }
   442|                     }
   443|                 }
   444|             } catch (Exception $e) {
   445|             }
   446|             if (strpos($columnName, '.')) {
   447|                 $parts = explode('.', $columnName);
   448|                 $this->map[$index++] = [trim($parts[0]), trim($parts[1]), $metaType];
   449|             } else {
   450|                 $this->map[$index++] = [0, $columnName, $metaType];
   451|             }
   452|             $j++;
   453|         }
   454|     }
   455|     /**
   456|      * Fetches the next row from the current result set
   457|      *
   458|      * @return unknown
   459|      */
   460|     public function fetchResult()
   461|     {
   462|         if (count($this->rows)) {
   463|             $row = array_shift($this->rows);
   464|             $resultRow = [];
   465|             $i = 0;
   466|             foreach($row as $index => $field) {
   467|                 if (isset($this->map[$index]) && $this->map[$index] != "") {
   468|                     [$table, $column, $type] = $this->map[$index];
   469|                     $resultRow[$table][$column] = $row[$index];
   470|                     if ($type === 'boolean' && $row[$index] !== null) {
   471|                         $resultRow[$table][$column] = $this->boolean($resultRow[$table][$column]);
   472|                     }
   473|                 } else {
   474|                     $resultRow[0][str_replace('"', '', $index)] = $row[$index];
   475|                 }
   476|                 $i++;
   477|             }
   478|             return $resultRow;
   479|         } else {
   480|             return false;
   481|         }
   482|     }
   483|     /**
   484|      * Returns a limit statement in the correct format for the particular database.
   485|      *
   486|      * @param integer $limit Limit of results returned
   487|      * @param integer $offset Offset from which to start results
   488|      * @return string SQL limit/offset statement
   489|      */
   490|     public function limit($limit, $offset = null)
   491|     {
   492|         if ($limit) {
   493|             $rt = '';
   494|             if (!strpos(strtolower($limit), 'limit') || strpos(strtolower($limit), 'limit') === 0) {
   495|                 $rt = ' LIMIT';
   496|             }
   497|             $rt .= ' ' . $limit;
   498|             if ($offset) {
   499|                 $rt .= ' OFFSET ' . $offset;
   500|             }
   501|             return $rt;
   502|         }
   503|         return null;
   504|     }
   505|     /**
   506|      * Generate a database-native column schema string
   507|      *
   508|      * @param array $column An array structured like the following: array('name'=>'value', 'type'=>'value'[, options]),
   509|      * where options can be 'default', 'length', or 'key'.
   510|      * @return string
   511|      */
   512|     public function buildColumn($column)
   513|     {
   514|         $name = $type = null;
   515|         $column = array_merge(['null' => true], $column);
   516|         extract($column);
   517|         if (empty($name) || empty($type)) {
   518|             trigger_error('Column name or type not defined in schema', E_USER_WARNING);
   519|             return null;
   520|         }
   521|         if (!isset($this->columns[$type])) {
   522|             trigger_error("Column type {$type} does not exist", E_USER_WARNING);
   523|             return null;
   524|         }
   525|         $real = $this->columns[$type];
   526|         if (isset($column['key']) && $column['key'] == 'primary') {
   527|             $out = $this->name($name) . ' ' . $this->columns['primary_key']['name'];
   528|         } else {
   529|             $out = $this->name($name) . ' ' . $real['name'];
   530|             if (isset($real['limit']) || isset($real['length']) || isset($column['limit']) || isset($column['length'])) {
   531|                 if (isset($column['length'])) {
   532|                     $length = $column['length'];
   533|                 } elseif (isset($column['limit'])) {
   534|                     $length = $column['limit'];
   535|                 } elseif (isset($real['length'])) {
   536|                     $length = $real['length'];
   537|                 } else {
   538|                     $length = $real['limit'];
   539|                 }
   540|                 $out .= '(' . $length . ')';
   541|             }
   542|             if (isset($column['key']) && $column['key'] == 'primary') {
   543|                 $out .= ' NOT NULL';
   544|             } elseif (isset($column['default']) && isset($column['null']) && $column['null'] == false) {
   545|                 $out .= ' DEFAULT ' . $this->value($column['default'], $type) . ' NOT NULL';
   546|             } elseif (isset($column['default'])) {
   547|                 $out .= ' DEFAULT ' . $this->value($column['default'], $type);
   548|             } elseif (isset($column['null']) && $column['null'] == true) {
   549|                 $out .= ' DEFAULT NULL';
   550|             } elseif (isset($column['null']) && $column['null'] == false) {
   551|                 $out .= ' NOT NULL';
   552|             }
   553|         }
   554|         return $out;
   555|     }
   556|     /**
   557|      * Removes redundant primary key indexes, as they are handled in the column def of the key.
   558|      *
   559|      * @param array $indexes
   560|      * @param string $table
   561|      * @return string
   562|      */
   563|     public function buildIndex($indexes, $table = null)
   564|     {
   565|         $join = [];
   566|         foreach($indexes as $name => $value) {
   567|             if ($name == 'PRIMARY') {
   568|                 continue;
   569|             } else {
   570|                 $out = 'CREATE ';
   571|                 if (!empty($value['unique'])) {
   572|                     $out .= 'UNIQUE ';
   573|                 }
   574|                 if (is_array($value['column'])) {
   575|                     $value['column'] = join(', ', array_map([&$this, 'name'], $value['column']));
   576|                 } else {
   577|                     $value['column'] = $this->name($value['column']);
   578|                 }
   579|                 $out .= "INDEX {$name} ON {$table}({$value['column']});";
   580|             }
   581|             $join[] = $out;
   582|         }
   583|         return $join;
   584|     }
   585|     /**
   586|      * Overrides DboSource::renderStatement to handle schema generation with SQLite3-style indexes
   587|      *
   588|      * @param string $type
   589|      * @param array $data
   590|      * @return string
   591|      */
   592|     public function renderStatement($type, $data)
   593|     {
   594|         switch(strtolower($type)) {
   595|             case 'schema':
   596|                 extract($data);
   597|                 foreach(['columns', 'indexes'] as $var) {
   598|                     if (is_array(${$var})) {
   599|                         ${$var} = "\t" . join(",\n\t", array_filter(${$var}));
   600|                     }
   601|                 }
   602|                 return "CREATE TABLE {$table} (\n{$columns});\n{$indexes}";
   603|                 break;
   604|             default:
   605|                 return parent::renderStatement($type, $data);
   606|                 break;
   607|         }
   608|     }
   609|     /**
   610|      * PDO deals in objects, not resources, so overload accordingly.
   611|      */
   612|     public function hasResult()
   613|     {
   614|         return is_object($this->_result);
   615|     }
   616|     /**
   617|      * Generate a MySQL Alter Table syntax for the given Schema comparison
   618|      *
   619|      * @param array $compare Result of a CakeSchema::compare()
   620|      * @return array Array of alter statements to make.
   621|      */
   622|     public function alterSchema($compare, $table = null)
   623|     {
   624|         if (!is_array($compare)) {
   625|             return false;
   626|         }
   627|         $out = '';
   628|         $colList = [];
   629|         foreach($compare as $curTable => $types) {
   630|             $indexes = [];
   631|             if (!$table || $table == $curTable) {
   632|                 $out .= 'ALTER TABLE ' . $this->fullTableName($curTable) . " \n";
   633|                 foreach($types as $type => $column) {
   634|                     if (isset($column['indexes'])) {
   635|                         $indexes[$type] = $column['indexes'];
   636|                         unset($column['indexes']);
   637|                     }
   638|                     switch($type) {
   639|                         case 'add':
   640|                             foreach($column as $field => $col) {
   641|                                 $col['name'] = $field;
   642|                                 $alter = 'ADD ' . $this->buildColumn($col);
   643|                                 $colList[] = $alter;
   644|                             }
   645|                             break;
   646|                         case 'drop':
   647|                             foreach($column as $field => $col) {
   648|                                 $col['name'] = $field;
   649|                                 $colList[] = 'DROP ' . $this->name($field);
   650|                             }
   651|                             break;
   652|                         case 'change':
   653|                             foreach($column as $field => $col) {
   654|                                 if (!isset($col['name'])) {
   655|                                     $col['name'] = $field;
   656|                                 }
   657|                                 $colList[] = 'CHANGE ' . $this->name($field) . ' ' . $this->buildColumn($col);
   658|                             }
   659|                             break;
   660|                     }
   661|                 }
   662|                 $colList = array_merge($colList, $this->_alterIndexes($curTable, $indexes));
   663|                 $out .= "\t" . implode(",\n\t", $colList) . ";\n\n";
   664|             }
   665|         }
   666|         return $out;
   667|     }
   668|     /**
   669|      * Overrides DboSource::index to handle SQLite indexe introspection
   670|      * Returns an array of the indexes in given table name.
   671|      *
   672|      * @param string $model Name of model to inspect
   673|      * @return array Fields in table. Keys are column and unique
   674|      */
   675|     public function index($model)
   676|     {
   677|         $index = [];
   678|         $table = $this->fullTableName($model, false, false);
   679|         if ($table) {
   680|             $tableInfo = $this->query('PRAGMA table_info(' . $table . ')');
   681|             $primary = [];
   682|             foreach($tableInfo as $info) {
   683|                 if (!empty($info[0]['pk'])) {
   684|                     $primary = ['PRIMARY' => ['unique' => true, 'column' => $info[0]['name']]];
   685|                 }
   686|             }
   687|             $indexes = $this->query('PRAGMA index_list(' . $table . ')');
   688|             foreach($indexes as $i => $info) {
   689|                 $key = array_pop($info);
   690|                 $keyInfo = $this->query('PRAGMA index_info("' . $key['name'] . '")');
   691|                 foreach($keyInfo as $keyCol) {
   692|                     if (!isset($index[$key['name']])) {
   693|                         $col = [];
   694|                         $index[$key['name']]['column'] = $keyCol[0]['name'];
   695|                         $index[$key['name']]['unique'] = intval($key['unique'] == 1);
   696|                     } else {
   697|                         if (!is_array($index[$key['name']]['column'])) {
   698|                             $col[] = $index[$key['name']]['column'];
   699|                         }
   700|                         $col[] = $keyCol[0]['name'];
   701|                         $index[$key['name']]['column'] = $col;
   702|                     }
   703|                 }
   704|             }
   705|             $index = am($primary, $index);
   706|         }
   707|         return $index;
   708|     }
   709|     /**
   710|      * Generate index alteration statements for a table.
   711|      * TODO 未サポート
   712|      *
   713|      * @param string $table Table to alter indexes for
   714|      * @param array $new Indexes to add and drop
   715|      * @return array Index alteration statements
   716|      */
   717|     protected function _alterIndexes($table, $indexes)
   718|     {
   719|         return [];
   720|     }
   721|     /**
   722|      * テーブル構造を変更する
   723|      *
   724|      * @param array $options [ new / old ]
   725|      * @return boolean
   726|      */
   727|     public function alterTable($options)
   728|     {
   729|         extract($options);
   730|         if (!isset($old) || !isset($new)) {
   731|             return false;
   732|         }
   733|         $Schema = ClassRegistry::init('CakeSchema');
   734|         $Schema->connection = $this->configKeyName;
   735|         $compare = $Schema->compare($old, $new);
   736|         if (!$compare) {
   737|             return false;
   738|         }
   739|         $result = true;
   740|         foreach($compare as $table => $types) {
   741|             if (!$types) {
   742|                 return false;
   743|             }
   744|             foreach($types as $type => $fields) {
   745|                 if (!$fields) {
   746|                     continue;
   747|                 }
   748|                 foreach($fields as $fieldName => $column) {
   749|                     switch($type) {
   750|                         case 'add':
   751|                             if (!$this->addColumn(['field' => $fieldName, 'table' => $table, 'column' => $column])) {
   752|                                 $reuslt = false;
   753|                             }
   754|                             break;
   755|                         case 'change':
   756|                             $reuslt = false;
   757|                             /* if(!$this->changeColumn(array('field'=>$fieldName,'table'=>$table, 'column'=>$column))){
   758|                               return false;
   759|                               } */
   760|                             break;
   761|                         case 'drop':
   762|                             if (!$this->dropColumn(['field' => $fieldName, 'table' => $table])) {
   763|                                 $reuslt = false;
   764|                             }
   765|                             break;
   766|                     }
   767|                 }
   768|             }
   769|         }
   770|         return $result;
   771|     }
   772|     /**
   773|      * テーブル名のリネームステートメントを生成
   774|      *
   775|      * @param string $sourceName
   776|      * @param string $targetName
   777|      * @return string
   778|      */
   779|     public function buildRenameTable($sourceName, $targetName)
   780|     {
   781|         return "ALTER TABLE " . $sourceName . " RENAME TO " . $targetName;
   782|     }
   783|     /**
   784|      * カラムを変更する
   785|      *
   786|      * @param array $options [ table / new / old ]
   787|      * @return boolean
   788|      */
   789|     public function renameColumn($options)
   790|     {
   791|         extract($options);
   792|         if (!isset($table) || !isset($new) || !isset($old)) {
   793|             return false;
   794|         }
   795|         $prefix = $this->config['prefix'];
   796|         $_table = $table;
   797|         $model = Inflector::classify(Inflector::singularize($table));
   798|         $table = $prefix . $table;
   799|         $Schema = ClassRegistry::init('CakeSchema');
   800|         $Schema->connection = $this->configKeyName;
   801|         $schema = $Schema->read(['models' => [$model]]);
   802|         if (!empty($schema['tables'][$_table])) {
   803|             $schema = $schema['tables'][$_table];
   804|         } else {
   805|             $schema = $schema['tables']['missing'][$_table];
   806|         }
   807|         if (!$schema) {
   808|             return false;
   809|         }
   810|         $this->execute('BEGIN TRANSACTION;');
   811|         if (!$this->renameTable(['old' => $_table, 'new' => $_table . '_temp'])) {
   812|             $this->execute('ROLLBACK;');
   813|             return false;
   814|         }
   815|         $newSchema = [];
   816|         foreach($schema as $key => $field) {
   817|             if ($key == $old) {
   818|                 $key = $new;
   819|             }
   820|             $newSchema[$key] = $field;
   821|         }
   822|         if (!$this->createTable(['schema' => $newSchema, 'table' => $_table])) {
   823|             $this->execute('ROLLBACK;');
   824|             return false;
   825|         }
   826|         unset($schema['indexes']);
   827|         $sql = 'INSERT INTO ' . $table . ' SELECT ' . $this->_convertCsvFieldsFromSchema($schema) . ' FROM ' . $table . '_temp';
   828|         $sql = str_replace($old, $old . ' AS ' . $new, $sql);
   829|         if (!$this->execute($sql)) {
   830|             $this->execute('ROLLBACK;');
   831|             return false;
   832|         }
   833|         if (!$this->execute('DROP TABLE ' . $table . '_temp')) {
   834|             $this->execute('ROLLBACK;');
   835|             return false;
   836|         }
   837|         $this->execute('COMMIT;');
   838|         return true;
   839|     }
   840|     /**
   841|      * カラムを削除する
   842|      *
   843|      * @param array $options [ table / field / prefix ]
   844|      * @return boolean
   845|      */
   846|     public function dropColumn($options)
   847|     {
   848|         extract($options);
   849|         if (!isset($table) || !isset($field)) {
   850|             return false;
   851|         }
   852|         if (!isset($prefix)) {
   853|             $prefix = $this->config['prefix'];
   854|         }
   855|         $_table = $table;
   856|         $model = Inflector::classify(Inflector::singularize($table));
   857|         $table = $prefix . $table;
   858|         $Schema = ClassRegistry::init('CakeSchema');
   859|         $Schema->connection = $this->configKeyName;
   860|         $schema = $this->readSchema($_table);
   861|         $schema = $schema['tables'][$_table];
   862|         $this->execute('BEGIN TRANSACTION;');
   863|         if (!$this->renameTable(['old' => $_table, 'new' => $_table . '_temp'])) {
   864|             $this->execute('ROLLBACK;');
   865|             return false;
   866|         }
   867|         unset($schema[$field]);
   868|         if (!$this->createTable(['schema' => $schema, 'table' => $_table])) {
   869|             $this->execute('ROLLBACK;');
   870|             return false;
   871|         }
   872|         unset($schema['indexes']);
   873|         if (!$this->_moveData($table . '_temp', $table, $schema)) {
   874|             $this->execute('ROLLBACK;');
   875|             return false;
   876|         }
   877|         if (!$this->execute('DROP TABLE ' . $table . '_temp')) {
   878|             $this->execute('ROLLBACK;');
   879|             return false;
   880|         }
   881|         $this->execute('COMMIT;');
   882|         return true;
   883|     }
   884|     /**
   885|      * テーブルからテーブルへデータを移動する
   886|      * @param string $sourceTableName
   887|      * @param string $targetTableName
   888|      * @param array $schema
   889|      * @return booelan
   890|      */
   891|     protected function _moveData($sourceTableName, $targetTableName, $schema)
   892|     {
   893|         $sql = 'INSERT INTO ' . $targetTableName . ' SELECT ' . $this->_convertCsvFieldsFromSchema($schema) . ' FROM ' . $sourceTableName;
   894|         return $this->execute($sql);
   895|     }
   896|     /**
   897|      * スキーマ情報よりCSV形式のフィールドリストを取得する
   898|      * @param array $schema
   899|      * @return string
   900|      */
   901|     protected function _convertCsvFieldsFromSchema($schema)
   902|     {
   903|         $fields = '';
   904|         foreach($schema as $key => $field) {
   905|             if ($key != 'tableParameters') {
   906|                 $fields .= '"' . $key . '",';
   907|             }
   908|         }
   909|         return substr($fields, 0, strlen($fields) - 1);
   910|     }
   911|     /**
   912|      * Returns an array of the fields in given table name.
   913|      *
   914|      * @param string $tableName Name of database table to inspect
   915|      * @return array Fields in table. Keys are name and type
   916|      */
   917|     public function describe($model)
   918|     {
   919|         $cache = $this->__describe($model);
   920|         if ($cache != null) {
   921|             return $cache;
   922|         }
   923|         $fields = [];
   924|         $result = $this->fetchAll('PRAGMA table_info(' . $model->tablePrefix . $model->table . ')');
   925|         foreach($result as $column) {
   926|             $fields[$column[0]['name']] = [
   927|                 'type' => $this->column($column[0]['type']),
   928|                 'null' => !$column[0]['notnull'],
   929|                 'default' => $column[0]['dflt_value'],
   930|                 'length' => ($column[0]['type'])? $this->length($column[0]['type']) : ''
   931|             ];
   932|             if (in_array($fields[$column[0]['name']]['type'], ['timestamp', 'datetime']) && strtoupper($fields[$column[0]['name']]['default']) === 'CURRENT_TIMESTAMP') {
   933|                 $fields[$column[0]['name']]['default'] = null;
   934|             }
   935|             if ($fields[$column[0]['name']]['default'] == 'NULL') {
   936|                 $fields[$column[0]['name']]['default'] = null;
   937|             }
   938|             /*if ($fields[$column[0]['name']]['type'] == 'boolean' && $fields[$column[0]['name']]['default'] == "'1'") {
   939|                 $fields[$column[0]['name']]['default'] = 1;
   940|             } elseif ($fields[$column[0]['name']]['type'] == 'boolean' && $fields[$column[0]['name']]['default'] == "'0'") {
   941|                 $fields[$column[0]['name']]['default'] = 0;
   942|             }*/
   943|             if ($column[0]['pk'] == 1) {
   944|                 $fields[$column[0]['name']] = [
   945|                     'type' => $fields[$column[0]['name']]['type'],
   946|                     'null' => false,
   947|                     'default' => $column[0]['dflt_value'],
   948|                     'key' => $this->index['PRI'],
   949|                     'length' => 8
   950|                 ];
   951|             }
   952|         }
   953|         $this->_cacheDescription($model->tablePrefix . $model->table, $fields);
   954|         return $fields;
   955|     }
   956|     /**
   957|      * Returns a Model description (metadata) or null if none found.
   958|      * DboSQlite3のdescribeメソッドを呼び出さずにキャッシュを読み込む為に利用
   959|      * Datasource::describe と同じ
   960|      *
   961|      * @param Model $model
   962|      * @return mixed
   963|      */
   964|     private function __describe($model)
   965|     {
   966|         if ($this->cacheSources === false) {
   967|             return null;
   968|         }
   969|         $table = $this->fullTableName($model, false);
   970|         if (isset($this->__descriptions[$table])) {
   971|             return $this->__descriptions[$table];
   972|         }
   973|         $cache = $this->_cacheDescription($table);
   974|         if ($cache !== null) {
   975|             $this->__descriptions[$table] = $cache;
   976|             return $cache;
   977|         }
   978|         return null;
   979|     }
   980| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Model/Datasource/Database/DboSource.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3931 ---
     1| <?php
     2| return;
     3| /**
     4|  * baserCMS :  Based Website Development Project <https://basercms.net>
     5|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     6|  *
     7|  * @copyright     Copyright (c) NPO baser foundation
     8|  * @link          https://basercms.net baserCMS Project
     9|  * @since         5.0.0
    10|  * @license       https://basercms.net/license/index.html MIT License
    11|  */
    12| /**
    13|  * DboSource
    14|  *
    15|  * Creates DBO-descendant objects from a given db connection configuration
    16|  *
    17|  */
    18| class DboSource extends DataSource
    19| {
    20|     /**
    21|      * Description string for this Database Data Source.
    22|      *
    23|      * @var string
    24|      */
    25|     public $description = "Database Data Source";
    26|     /**
    27|      * index definition, standard cake, primary, index, unique
    28|      *
    29|      * @var array
    30|      */
    31|     public $index = ['PRI' => 'primary', 'MUL' => 'index', 'UNI' => 'unique'];
    32|     /**
    33|      * Database keyword used to assign aliases to identifiers.
    34|      *
    35|      * @var string
    36|      */
    37|     public $alias = 'AS ';
    38|     /**
    39|      * Caches result from query parsing operations. Cached results for both DboSource::name() and DboSource::fields()
    40|      * will be stored here.
    41|      *
    42|      * Method caching uses `md5` (by default) to construct cache keys. If you have problems with collisions,
    43|      * try a different hashing algorithm by overriding DboSource::cacheMethodHasher or set DboSource::$cacheMethods to false.
    44|      *
    45|      * @var array
    46|      */
    47|     public static $methodCache = [];
    48|     /**
    49|      * Whether or not to cache the results of DboSource::name() and DboSource::fields() into the memory cache.
    50|      * Set to false to disable the use of the memory cache.
    51|      *
    52|      * @var bool
    53|      */
    54|     public $cacheMethods = true;
    55|     /**
    56|      * Flag to support nested transactions. If it is set to false, you will be able to use
    57|      * the transaction methods (begin/commit/rollback), but just the global transaction will
    58|      * be executed.
    59|      *
    60|      * @var bool
    61|      */
    62|     public $useNestedTransactions = false;
    63|     /**
    64|      * Print full query debug info?
    65|      *
    66|      * @var bool
    67|      */
    68|     public $fullDebug = false;
    69|     /**
    70|      * String to hold how many rows were affected by the last SQL operation.
    71|      *
    72|      * @var string
    73|      */
    74|     public $affected = null;
    75|     /**
    76|      * Number of rows in current resultset
    77|      *
    78|      * @var int
    79|      */
    80|     public $numRows = null;
    81|     /**
    82|      * Time the last query took
    83|      *
    84|      * @var int
    85|      */
    86|     public $took = null;
    87|     /**
    88|      * Result
    89|      *
    90|      * @var array|PDOStatement
    91|      */
    92|     protected $_result = null;
    93|     /**
    94|      * Queries count.
    95|      *
    96|      * @var int
    97|      */
    98|     protected $_queriesCnt = 0;
    99|     /**
   100|      * Total duration of all queries.
   101|      *
   102|      * @var int
   103|      */
   104|     protected $_queriesTime = null;
   105|     /**
   106|      * Log of queries executed by this DataSource
   107|      *
   108|      * @var array
   109|      */
   110|     protected $_queriesLog = [];
   111|     /**
   112|      * Maximum number of items in query log
   113|      *
   114|      * This is to prevent query log taking over too much memory.
   115|      *
   116|      * @var int
   117|      */
   118|     protected $_queriesLogMax = 200;
   119|     /**
   120|      * Caches serialized results of executed queries
   121|      *
   122|      * @var array
   123|      */
   124|     protected $_queryCache = [];
   125|     /**
   126|      * A reference to the physical connection of this DataSource
   127|      *
   128|      * @var array
   129|      */
   130|     protected $_connection = null;
   131|     /**
   132|      * The DataSource configuration key name
   133|      *
   134|      * @var string
   135|      */
   136|     public $configKeyName = null;
   137|     /**
   138|      * The starting character that this DataSource uses for quoted identifiers.
   139|      *
   140|      * @var string
   141|      */
   142|     public $startQuote = null;
   143|     /**
   144|      * The ending character that this DataSource uses for quoted identifiers.
   145|      *
   146|      * @var string
   147|      */
   148|     public $endQuote = null;
   149|     /**
   150|      * The set of valid SQL operations usable in a WHERE statement
   151|      *
   152|      * @var array
   153|      */
   154|     protected $_sqlOps = ['like', 'ilike', 'rlike', 'or', 'not', 'in', 'between', 'regexp', 'similar to'];
   155|     /**
   156|      * The set of valid SQL boolean operations usable in a WHERE statement
   157|      *
   158|      * @var array
   159|      */
   160|     protected $_sqlBoolOps = ['and', 'or', 'not', 'and not', 'or not', 'xor', '||', '&&'];
   161|     /**
   162|      * Indicates the level of nested transactions
   163|      *
   164|      * @var int
   165|      */
   166|     protected $_transactionNesting = 0;
   167|     /**
   168|      * Default fields that are used by the DBO
   169|      *
   170|      * @var array
   171|      */
   172|     protected $_queryDefaults = [
   173|         'conditions' => [],
   174|         'fields' => null,
   175|         'table' => null,
   176|         'alias' => null,
   177|         'order' => null,
   178|         'limit' => null,
   179|         'joins' => [],
   180|         'group' => null,
   181|         'offset' => null,
   182|         'having' => null,
   183|         'lock' => null,
   184|     ];
   185|     /**
   186|      * Separator string for virtualField composition
   187|      *
   188|      * @var string
   189|      */
   190|     public $virtualFieldSeparator = '__';
   191|     /**
   192|      * List of table engine specific parameters used on table creating
   193|      *
   194|      * @var array
   195|      */
   196|     public $tableParameters = [];
   197|     /**
   198|      * List of engine specific additional field parameters used on table creating
   199|      *
   200|      * @var array
   201|      */
   202|     public $fieldParameters = [];
   203|     /**
   204|      * Indicates whether there was a change on the cached results on the methods of this class
   205|      * This will be used for storing in a more persistent cache
   206|      *
   207|      * @var bool
   208|      */
   209|     protected $_methodCacheChange = false;
   210|     /**
   211|      * Map of the columns contained in a result.
   212|      *
   213|      * @var array
   214|      */
   215|     public $map = [];
   216|     /**
   217|      * Constructor
   218|      *
   219|      * @param array $config Array of configuration information for the Datasource.
   220|      * @param bool $autoConnect Whether or not the datasource should automatically connect.
   221|      * @throws MissingConnectionException when a connection cannot be made.
   222|      */
   223|     public function __construct($config = null, $autoConnect = true)
   224|     {
   225|         if (!isset($config['prefix'])) {
   226|             $config['prefix'] = '';
   227|         }
   228|         parent::__construct($config);
   229|         $this->fullDebug = Configure::read('debug') > 1;
   230|         if (!$this->enabled()) {
   231|             throw new MissingConnectionException([
   232|                 'class' => get_class($this),
   233|                 'message' => __d('cake_dev', 'Selected driver is not enabled'),
   234|                 'enabled' => false
   235|             ]);
   236|         }
   237|         if ($autoConnect) {
   238|             $this->connect();
   239|         }
   240|     }
   241|     /**
   242|      * Connects to the database.
   243|      *
   244|      * @return bool
   245|      */
   246|     public function connect()
   247|     {
   248|         return $this->connected;
   249|     }
   250|     /**
   251|      * Reconnects to database server with optional new settings
   252|      *
   253|      * @param array $config An array defining the new configuration settings
   254|      * @return bool True on success, false on failure
   255|      */
   256|     public function reconnect($config = [])
   257|     {
   258|         $this->disconnect();
   259|         $this->setConfig($config);
   260|         $this->_sources = null;
   261|         return $this->connect();
   262|     }
   263|     /**
   264|      * Disconnects from database.
   265|      *
   266|      * @return bool Always true
   267|      */
   268|     public function disconnect()
   269|     {
   270|         if ($this->_result instanceof PDOStatement) {
   271|             $this->_result->closeCursor();
   272|         }
   273|         $this->_connection = null;
   274|         $this->connected = false;
   275|         return true;
   276|     }
   277|     /**
   278|      * Get the underlying connection object.
   279|      *
   280|      * @return PDO
   281|      */
   282|     public function getConnection()
   283|     {
   284|         return $this->_connection;
   285|     }
   286|     /**
   287|      * Gets the version string of the database server
   288|      *
   289|      * @return string The database version
   290|      */
   291|     public function getVersion()
   292|     {
   293|         return $this->_connection->getAttribute(PDO::ATTR_SERVER_VERSION);
   294|     }
   295|     /**
   296|      * Returns a quoted and escaped string of $data for use in an SQL statement.
   297|      *
   298|      * @param string $data String to be prepared for use in an SQL statement
   299|      * @param string $column The column datatype into which this data will be inserted.
   300|      * @param bool $null Column allows NULL values
   301|      * @return string Quoted and escaped data
   302|      */
   303|     public function value($data, $column = null, $null = true)
   304|     {
   305|         if (is_array($data) && !empty($data)) {
   306|             return array_map(
   307|                 [&$this, 'value'],
   308|                 $data, array_fill(0, count($data), $column)
   309|             );
   310|         } elseif (is_object($data) && isset($data->type, $data->value)) {
   311|             if ($data->type === 'identifier') {
   312|                 return $this->name($data->value);
   313|             } elseif ($data->type === 'expression') {
   314|                 return $data->value;
   315|             }
   316|         } elseif (in_array($data, ['{$__cakeID__$}', '{$__cakeForeignKey__$}'], true)) {
   317|             return $data;
   318|         }
   319|         if ($data === null || (is_array($data) && empty($data))) {
   320|             return 'NULL';
   321|         }
   322|         if (empty($column)) {
   323|             $column = $this->introspectType($data);
   324|         }
   325|         $isStringEnum = false;
   326|         if (strpos($column, "enum") === 0) {
   327|             $firstValue = null;
   328|             if (preg_match("/(enum\()(.*)(\))/i", $column, $acceptingValues)) {
   329|                 $values = explode(",", $acceptingValues[2]);
   330|                 $firstValue = $values[0];
   331|             }
   332|             if (is_string($firstValue)) {
   333|                 $isStringEnum = true;
   334|             }
   335|         }
   336|         switch($column) {
   337|             case 'binary':
   338|                 return $this->_connection->quote($data, PDO::PARAM_LOB);
   339|             case 'boolean':
   340|                 return $this->_connection->quote($this->boolean($data, true), PDO::PARAM_BOOL);
   341|             case 'string':
   342|             case 'text':
   343|                 return $this->_connection->quote($data, PDO::PARAM_STR);
   344|             default:
   345|                 if ($data === '') {
   346|                     return $null? 'NULL' : '""';
   347|                 }
   348|                 if (is_float($data)) {
   349|                     return str_replace(',', '.', strval($data));
   350|                 }
   351|                 if (((is_int($data) || $data === '0') || (
   352|                             is_numeric($data) &&
   353|                             strpos($data, ',') === false &&
   354|                             $data[0] != '0' &&
   355|                             strpos($data, 'e') === false)
   356|                     ) && !$isStringEnum
   357|                 ) {
   358|                     return $data;
   359|                 }
   360|                 return $this->_connection->quote($data);
   361|         }
   362|     }
   363|     /**
   364|      * Returns an object to represent a database identifier in a query. Expression objects
   365|      * are not sanitized or escaped.
   366|      *
   367|      * @param string $identifier A SQL expression to be used as an identifier
   368|      * @return stdClass An object representing a database identifier to be used in a query
   369|      */
   370|     public function identifier($identifier)
   371|     {
   372|         $obj = new stdClass();
   373|         $obj->type = 'identifier';
   374|         $obj->value = $identifier;
   375|         return $obj;
   376|     }
   377|     /**
   378|      * Returns an object to represent a database expression in a query. Expression objects
   379|      * are not sanitized or escaped.
   380|      *
   381|      * @param string $expression An arbitrary SQL expression to be inserted into a query.
   382|      * @return stdClass An object representing a database expression to be used in a query
   383|      */
   384|     public function expression($expression)
   385|     {
   386|         $obj = new stdClass();
   387|         $obj->type = 'expression';
   388|         $obj->value = $expression;
   389|         return $obj;
   390|     }
   391|     /**
   392|      * Executes given SQL statement.
   393|      *
   394|      * @param string $sql SQL statement
   395|      * @param array $params Additional options for the query.
   396|      * @return mixed Resource or object representing the result set, or false on failure
   397|      */
   398|     public function rawQuery($sql, $params = [])
   399|     {
   400|         $this->took = $this->numRows = false;
   401|         return $this->execute($sql, [], $params);
   402|     }
   403|     /**
   404|      * Queries the database with given SQL statement, and obtains some metadata about the result
   405|      * (rows affected, timing, any errors, number of rows in resultset). The query is also logged.
   406|      * If Configure::read('debug') is set, the log is shown all the time, else it is only shown on errors.
   407|      *
   408|      * ### Options
   409|      *
   410|      * - log - Whether or not the query should be logged to the memory log.
   411|      *
   412|      * @param string $sql SQL statement
   413|      * @param array $options The options for executing the query.
   414|      * @param array $params values to be bound to the query.
   415|      * @return mixed Resource or object representing the result set, or false on failure
   416|      */
   417|     public function execute($sql, $options = [], $params = [])
   418|     {
   419|         $options += ['log' => $this->fullDebug];
   420|         $t = microtime(true);
   421|         $this->_result = $this->_execute($sql, $params);
   422|         if ($options['log']) {
   423|             $this->took = round((microtime(true) - $t) * 1000, 0);
   424|             $this->numRows = $this->affected = $this->lastAffected();
   425|             $this->logQuery($sql, $params);
   426|         }
   427|         return $this->_result;
   428|     }
   429|     /**
   430|      * Executes given SQL statement.
   431|      *
   432|      * @param string $sql SQL statement
   433|      * @param array $params list of params to be bound to query
   434|      * @param array $prepareOptions Options to be used in the prepare statement
   435|      * @return mixed PDOStatement if query executes with no problem, true as the result of a successful, false on error
   436|      * query returning no rows, such as a CREATE statement, false otherwise
   437|      * @throws PDOException
   438|      */
   439|     protected function _execute($sql, $params = [], $prepareOptions = [])
   440|     {
   441|         $sql = trim($sql);
   442|         if (preg_match('/^(?:CREATE|ALTER|DROP)\s+(?:TABLE|INDEX)/i', $sql)) {
   443|             $statements = array_filter(explode(';', $sql));
   444|             if (count($statements) > 1) {
   445|                 $result = array_map([$this, '_execute'], $statements);
   446|                 return array_search(false, $result) === false;
   447|             }
   448|         }
   449|         try {
   450|             $query = $this->_connection->prepare($sql, $prepareOptions);
   451|             $query->setFetchMode(PDO::FETCH_LAZY);
   452|             if (!$query->execute($params)) {
   453|                 $this->_result = $query;
   454|                 $query->closeCursor();
   455|                 return false;
   456|             }
   457|             if (!$query->columnCount()) {
   458|                 $query->closeCursor();
   459|                 if (!$query->rowCount()) {
   460|                     return true;
   461|                 }
   462|             }
   463|             return $query;
   464|         } catch (PDOException $e) {
   465|             if (isset($query->queryString)) {
   466|                 $e->queryString = $query->queryString;
   467|             } else {
   468|                 $e->queryString = $sql;
   469|             }
   470|             throw $e;
   471|         }
   472|     }
   473|     /**
   474|      * Returns a formatted error message from previous database operation.
   475|      *
   476|      * @param PDOStatement $query the query to extract the error from if any
   477|      * @return string Error message with error number
   478|      */
   479|     public function lastError(PDOStatement $query = null)
   480|     {
   481|         if ($query) {
   482|             $error = $query->errorInfo();
   483|         } else {
   484|             $error = $this->_connection->errorInfo();
   485|         }
   486|         if (empty($error[2])) {
   487|             return null;
   488|         }
   489|         return $error[1] . ': ' . $error[2];
   490|     }
   491|     /**
   492|      * Returns number of affected rows in previous database operation. If no previous operation exists,
   493|      * this returns false.
   494|      *
   495|      * @param mixed $source The source to check.
   496|      * @return int Number of affected rows
   497|      */
   498|     public function lastAffected($source = null)
   499|     {
   500|         if ($this->hasResult()) {
   501|             return $this->_result->rowCount();
   502|         }
   503|         return 0;
   504|     }
   505|     /**
   506|      * Returns number of rows in previous resultset. If no previous resultset exists,
   507|      * this returns false.
   508|      *
   509|      * @param mixed $source Not used
   510|      * @return int Number of rows in resultset
   511|      */
   512|     public function lastNumRows($source = null)
   513|     {
   514|         return $this->lastAffected();
   515|     }
   516|     /**
   517|      * DataSource Query abstraction
   518|      *
   519|      * @return resource Result resource identifier.
   520|      */
   521|     public function query()
   522|     {
   523|         $args = func_get_args();
   524|         $fields = null;
   525|         $order = null;
   526|         $limit = null;
   527|         $page = null;
   528|         $recursive = null;
   529|         if (count($args) === 1) {
   530|             return $this->fetchAll($args[0]);
   531|         } elseif (count($args) > 1 && preg_match('/^find(\w*)By(.+)/', $args[0], $matches)) {
   532|             $params = $args[1];
   533|             $findType = lcfirst($matches[1]);
   534|             $field = Inflector::underscore($matches[2]);
   535|             $or = (strpos($field, '_or_') !== false);
   536|             if ($or) {
   537|                 $field = explode('_or_', $field);
   538|             } else {
   539|                 $field = explode('_and_', $field);
   540|             }
   541|             $off = count($field) - 1;
   542|             if (isset($params[1 + $off])) {
   543|                 $fields = $params[1 + $off];
   544|             }
   545|             if (isset($params[2 + $off])) {
   546|                 $order = $params[2 + $off];
   547|             }
   548|             if (!array_key_exists(0, $params)) {
   549|                 return false;
   550|             }
   551|             $c = 0;
   552|             $conditions = [];
   553|             foreach($field as $f) {
   554|                 $conditions[$args[2]->alias . '.' . $f] = $params[$c++];
   555|             }
   556|             if ($or) {
   557|                 $conditions = ['OR' => $conditions];
   558|             }
   559|             if ($findType !== 'first' && $findType !== '') {
   560|                 if (isset($params[3 + $off])) {
   561|                     $limit = $params[3 + $off];
   562|                 }
   563|                 if (isset($params[4 + $off])) {
   564|                     $page = $params[4 + $off];
   565|                 }
   566|                 if (isset($params[5 + $off])) {
   567|                     $recursive = $params[5 + $off];
   568|                 }
   569|                 return $args[2]->find($findType, compact('conditions', 'fields', 'order', 'limit', 'page', 'recursive'));
   570|             }
   571|             if (isset($params[3 + $off])) {
   572|                 $recursive = $params[3 + $off];
   573|             }
   574|             return $args[2]->find('first', compact('conditions', 'fields', 'order', 'recursive'));
   575|         }
   576|         if (isset($args[1]) && $args[1] === true) {
   577|             return $this->fetchAll($args[0], true);
   578|         } elseif (isset($args[1]) && !is_array($args[1])) {
   579|             return $this->fetchAll($args[0], false);
   580|         } elseif (isset($args[1]) && is_array($args[1])) {
   581|             if (isset($args[2])) {
   582|                 $cache = $args[2];
   583|             } else {
   584|                 $cache = true;
   585|             }
   586|             return $this->fetchAll($args[0], $args[1], ['cache' => $cache]);
   587|         }
   588|     }
   589|     /**
   590|      * Builds a map of the columns contained in a result
   591|      *
   592|      * @param PDOStatement $results The results to format.
   593|      * @return void
   594|      */
   595|     public function resultSet($results)
   596|     {
   597|     }
   598|     /**
   599|      * Returns a row from current resultset as an array
   600|      *
   601|      * @param string $sql Some SQL to be executed.
   602|      * @return array The fetched row as an array
   603|      */
   604|     public function fetchRow($sql = null)
   605|     {
   606|         if (is_string($sql) && strlen($sql) > 5 && !$this->execute($sql)) {
   607|             return null;
   608|         }
   609|         if ($this->hasResult()) {
   610|             $this->resultSet($this->_result);
   611|             $resultRow = $this->fetchResult();
   612|             if (isset($resultRow[0])) {
   613|                 $this->fetchVirtualField($resultRow);
   614|             }
   615|             return $resultRow;
   616|         }
   617|         return null;
   618|     }
   619|     /**
   620|      * Returns an array of all result rows for a given SQL query.
   621|      *
   622|      * Returns false if no rows matched.
   623|      *
   624|      * ### Options
   625|      *
   626|      * - `cache` - Returns the cached version of the query, if exists and stores the result in cache.
   627|      *   This is a non-persistent cache, and only lasts for a single request. This option
   628|      *   defaults to true. If you are directly calling this method, you can disable caching
   629|      *   by setting $options to `false`
   630|      *
   631|      * @param string $sql SQL statement
   632|      * @param array|bool $params Either parameters to be bound as values for the SQL statement,
   633|      *  or a boolean to control query caching.
   634|      * @param array $options additional options for the query.
   635|      * @return bool|array Array of resultset rows, or false if no rows matched
   636|      */
   637|     public function fetchAll($sql, $params = [], $options = [])
   638|     {
   639|         if (is_string($options)) {
   640|             $options = ['modelName' => $options];
   641|         }
   642|         if (is_bool($params)) {
   643|             $options['cache'] = $params;
   644|             $params = [];
   645|         }
   646|         $options += ['cache' => true];
   647|         $cache = $options['cache'];
   648|         if ($cache && ($cached = $this->getQueryCache($sql, $params)) !== false) {
   649|             return $cached;
   650|         }
   651|         $result = $this->execute($sql, [], $params);
   652|         if ($result) {
   653|             $out = [];
   654|             if ($this->hasResult()) {
   655|                 $first = $this->fetchRow();
   656|                 if ($first) {
   657|                     $out[] = $first;
   658|                 }
   659|                 while($item = $this->fetchResult()) {
   660|                     if (isset($item[0])) {
   661|                         $this->fetchVirtualField($item);
   662|                     }
   663|                     $out[] = $item;
   664|                 }
   665|             }
   666|             if (!is_bool($result) && $cache) {
   667|                 $this->_writeQueryCache($sql, $out, $params);
   668|             }
   669|             if (empty($out) && is_bool($this->_result)) {
   670|                 return $this->_result;
   671|             }
   672|             return $out;
   673|         }
   674|         return false;
   675|     }
   676|     /**
   677|      * Fetches the next row from the current result set
   678|      *
   679|      * @return bool
   680|      */
   681|     public function fetchResult()
   682|     {
   683|         return false;
   684|     }
   685|     /**
   686|      * Modifies $result array to place virtual fields in model entry where they belongs to
   687|      *
   688|      * @param array &$result Reference to the fetched row
   689|      * @return void
   690|      */
   691|     public function fetchVirtualField(&$result)
   692|     {
   693|         if (isset($result[0]) && is_array($result[0])) {
   694|             foreach($result[0] as $field => $value) {
   695|                 if (strpos($field, $this->virtualFieldSeparator) === false) {
   696|                     continue;
   697|                 }
   698|                 [$alias, $virtual] = explode($this->virtualFieldSeparator, $field);
   699|                 if (!ClassRegistry::isKeySet($alias)) {
   700|                     return;
   701|                 }
   702|                 $Model = ClassRegistry::getObject($alias);
   703|                 if ($Model->isVirtualField($virtual)) {
   704|                     $result[$alias][$virtual] = $value;
   705|                     unset($result[0][$field]);
   706|                 }
   707|             }
   708|             if (empty($result[0])) {
   709|                 unset($result[0]);
   710|             }
   711|         }
   712|     }
   713|     /**
   714|      * Returns a single field of the first of query results for a given SQL query, or false if empty.
   715|      *
   716|      * @param string $name The name of the field to get.
   717|      * @param string $sql The SQL query.
   718|      * @return mixed Value of field read, or false if not found.
   719|      */
   720|     public function field($name, $sql)
   721|     {
   722|         $data = $this->fetchRow($sql);
   723|         if (empty($data[$name])) {
   724|             return false;
   725|         }
   726|         return $data[$name];
   727|     }
   728|     /**
   729|      * Empties the method caches.
   730|      * These caches are used by DboSource::name() and DboSource::conditions()
   731|      *
   732|      * @return void
   733|      */
   734|     public function flushMethodCache()
   735|     {
   736|         $this->_methodCacheChange = true;
   737|         static::$methodCache = [];
   738|     }
   739|     /**
   740|      * Cache a value into the methodCaches. Will respect the value of DboSource::$cacheMethods.
   741|      * Will retrieve a value from the cache if $value is null.
   742|      *
   743|      * If caching is disabled and a write is attempted, the $value will be returned.
   744|      * A read will either return the value or null.
   745|      *
   746|      * @param string $method Name of the method being cached.
   747|      * @param string $key The key name for the cache operation.
   748|      * @param mixed $value The value to cache into memory.
   749|      * @return mixed Either null on failure, or the value if its set.
   750|      */
   751|     public function cacheMethod($method, $key, $value = null)
   752|     {
   753|         if ($this->cacheMethods === false) {
   754|             return $value;
   755|         }
   756|         if (!$this->_methodCacheChange && empty(static::$methodCache)) {
   757|             static::$methodCache = (array)Cache::read('method_cache', '_cake_core_');
   758|         }
   759|         if ($value === null) {
   760|             return (isset(static::$methodCache[$method][$key]))? static::$methodCache[$method][$key] : null;
   761|         }
   762|         if (!$this->cacheMethodFilter($method, $key, $value)) {
   763|             return $value;
   764|         }
   765|         $this->_methodCacheChange = true;
   766|         return static::$methodCache[$method][$key] = $value;
   767|     }
   768|     /**
   769|      * Filters to apply to the results of `name` and `fields`. When the filter for a given method does not return `true`
   770|      * then the result is not added to the memory cache.
   771|      *
   772|      * Some examples:
   773|      *
   774|      * ```
   775|      * // For method fields, do not cache values that contain floats
   776|      * if ($method === 'fields') {
   777|      *    $hasFloat = preg_grep('/(\d+)?\.\d+/', $value);
   778|      *
   779|      *    return count($hasFloat) === 0;
   780|      * }
   781|      *
   782|      * return true;
   783|      * ```
   784|      *
   785|      * ```
   786|      * // For method name, do not cache values that have the name created
   787|      * if ($method === 'name') {
   788|      *    return preg_match('/^`created`$/', $value) !== 1;
   789|      * }
   790|      *
   791|      * return true;
   792|      * ```
   793|      *
   794|      * ```
   795|      * // For method name, do not cache values that have the key 472551d38e1f8bbc78d7dfd28106166f
   796|      * if ($key === '472551d38e1f8bbc78d7dfd28106166f') {
   797|      *    return false;
   798|      * }
   799|      *
   800|      * return true;
   801|      * ```
   802|      *
   803|      * @param string $method Name of the method being cached.
   804|      * @param string $key The key name for the cache operation.
   805|      * @param mixed $value The value to cache into memory.
   806|      * @return bool Whether or not to cache
   807|      */
   808|     public function cacheMethodFilter($method, $key, $value)
   809|     {
   810|         return true;
   811|     }
   812|     /**
   813|      * Hashes a given value.
   814|      *
   815|      * Method caching uses `md5` (by default) to construct cache keys. If you have problems with collisions,
   816|      * try a different hashing algorithm or set DboSource::$cacheMethods to false.
   817|      *
   818|      * @param string $value Value to hash
   819|      * @return string Hashed value
   820|      * @see http://php.net/manual/en/function.hash-algos.php
   821|      * @see http://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed
   822|      */
   823|     public function cacheMethodHasher($value)
   824|     {
   825|         return md5($value);
   826|     }
   827|     /**
   828|      * Returns a quoted name of $data for use in an SQL statement.
   829|      * Strips fields out of SQL functions before quoting.
   830|      *
   831|      * Results of this method are stored in a memory cache. This improves performance, but
   832|      * because the method uses a hashing algorithm it can have collisions.
   833|      * Setting DboSource::$cacheMethods to false will disable the memory cache.
   834|      *
   835|      * @param mixed $data Either a string with a column to quote. An array of columns to quote or an
   836|      *   object from DboSource::expression() or DboSource::identifier()
   837|      * @return string SQL field
   838|      */
   839|     public function name($data)
   840|     {
   841|         if (is_object($data) && isset($data->type)) {
   842|             return $data->value;
   843|         }
   844|         if ($data === '*') {
   845|             return '*';
   846|         }
   847|         if (is_array($data)) {
   848|             foreach($data as $i => $dataItem) {
   849|                 $data[$i] = $this->name($dataItem);
   850|             }
   851|             return $data;
   852|         }
   853|         $cacheKey = $this->cacheMethodHasher($this->startQuote . $data . $this->endQuote);
   854|         if ($return = $this->cacheMethod(__FUNCTION__, $cacheKey)) {
   855|             return $return;
   856|         }
   857|         $data = trim($data);
   858|         if (preg_match('/^[\w-]+(?:\.[^ \*]*)*$/', $data)) { // string, string.string
   859|             if (strpos($data, '.') === false) { // string
   860|                 return $this->cacheMethod(__FUNCTION__, $cacheKey, $this->startQuote . $data . $this->endQuote);
   861|             }
   862|             $items = explode('.', $data);
   863|             return $this->cacheMethod(__FUNCTION__, $cacheKey,
   864|                 $this->startQuote . implode($this->endQuote . '.' . $this->startQuote, $items) . $this->endQuote
   865|             );
   866|         }
   867|         if (preg_match('/^[\w-]+\.\*$/', $data)) { // string.*
   868|             return $this->cacheMethod(__FUNCTION__, $cacheKey,
   869|                 $this->startQuote . str_replace('.*', $this->endQuote . '.*', $data)
   870|             );
   871|         }
   872|         if (preg_match('/^([\w-]+)\((.*)\)$/', $data, $matches)) { // Functions
   873|             return $this->cacheMethod(__FUNCTION__, $cacheKey,
   874|                 $matches[1] . '(' . $this->name($matches[2]) . ')'
   875|             );
   876|         }
   877|         if (preg_match('/^([\w-]+(\.[\w-]+|\(.*\))*)\s+' . preg_quote($this->alias) . '\s*([\w-]+)$/i', $data, $matches)) {
   878|             return $this->cacheMethod(
   879|                 __FUNCTION__, $cacheKey,
   880|                 preg_replace(
   881|                     '/\s{2,}/', ' ', $this->name($matches[1]) . ' ' . $this->alias . ' ' . $this->name($matches[3])
   882|                 )
   883|             );
   884|         }
   885|         if (preg_match('/^[\w\-_\s]*[\w\-_]+/', $data)) {
   886|             return $this->cacheMethod(__FUNCTION__, $cacheKey, $this->startQuote . $data . $this->endQuote);
   887|         }
   888|         return $this->cacheMethod(__FUNCTION__, $cacheKey, $data);
   889|     }
   890|     /**
   891|      * Checks if the source is connected to the database.
   892|      *
   893|      * @return bool True if the database is connected, else false
   894|      */
   895|     public function isConnected()
   896|     {
   897|         if ($this->_connection === null) {
   898|             $connected = false;
   899|         } else {
   900|             try {
   901|                 $connected = $this->_connection->query('SELECT 1');
   902|             } catch (Exception $e) {
   903|                 $connected = false;
   904|             }
   905|         }
   906|         $this->connected = !empty($connected);
   907|         return $this->connected;
   908|     }
   909|     /**
   910|      * Checks if the result is valid
   911|      *
   912|      * @return bool True if the result is valid else false
   913|      */
   914|     public function hasResult()
   915|     {
   916|         return $this->_result instanceof PDOStatement;
   917|     }
   918|     /**
   919|      * Get the query log as an array.
   920|      *
   921|      * @param bool $sorted Get the queries sorted by time taken, defaults to false.
   922|      * @param bool $clear If True the existing log will cleared.
   923|      * @return array Array of queries run as an array
   924|      */
   925|     public function getLog($sorted = false, $clear = true)
   926|     {
   927|         if ($sorted) {
   928|             $log = sortByKey($this->_queriesLog, 'took', 'desc', SORT_NUMERIC);
   929|         } else {
   930|             $log = $this->_queriesLog;
   931|         }
   932|         if ($clear) {
   933|             $this->_queriesLog = [];
   934|         }
   935|         return ['log' => $log, 'count' => $this->_queriesCnt, 'time' => $this->_queriesTime];
   936|     }
   937|     /**
   938|      * Outputs the contents of the queries log. If in a non-CLI environment the sql_log element
   939|      * will be rendered and output. If in a CLI environment, a plain text log is generated.
   940|      *
   941|      * @param bool $sorted Get the queries sorted by time taken, defaults to false.
   942|      * @return void
   943|      */
   944|     public function showLog($sorted = false)
   945|     {
   946|         $log = $this->getLog($sorted, false);
   947|         if (empty($log['log'])) {
   948|             return;
   949|         }
   950|         if (PHP_SAPI !== 'cli') {
   951|             $controller = null;
   952|             $View = new View($controller, false);
   953|             $View->set('sqlLogs', [$this->configKeyName => $log]);
   954|             echo $View->element('sql_dump', ['_forced_from_dbo_' => true]);
   955|         } else {
   956|             foreach($log['log'] as $k => $i) {
   957|                 print (($k + 1) . ". {$i['query']}\n");
   958|             }
   959|         }
   960|     }
   961|     /**
   962|      * Log given SQL query.
   963|      *
   964|      * @param string $sql SQL statement
   965|      * @param array $params Values binded to the query (prepared statements)
   966|      * @return void
   967|      */
   968|     public function logQuery($sql, $params = [])
   969|     {
   970|         $this->_queriesCnt++;
   971|         $this->_queriesTime += $this->took;
   972|         $this->_queriesLog[] = [
   973|             'query' => $sql,
   974|             'params' => $params,
   975|             'affected' => $this->affected,
   976|             'numRows' => $this->numRows,
   977|             'took' => $this->took
   978|         ];
   979|         if (count($this->_queriesLog) > $this->_queriesLogMax) {
   980|             array_shift($this->_queriesLog);
   981|         }
   982|     }
   983|     /**
   984|      * Gets full table name including prefix
   985|      *
   986|      * @param Model|string $model Either a Model object or a string table name.
   987|      * @param bool $quote Whether you want the table name quoted.
   988|      * @param bool $schema Whether you want the schema name included.
   989|      * @return string Full quoted table name
   990|      */
   991|     public function fullTableName($model, $quote = true, $schema = true)
   992|     {
   993|         if (is_object($model)) {
   994|             $schemaName = $model->schemaName;
   995|             $table = $model->tablePrefix . $model->table;
   996|         } elseif (!empty($this->config['prefix']) && strpos($model, $this->config['prefix']) !== 0) {
   997|             $table = $this->config['prefix'] . strval($model);
   998|         } else {
   999|             $table = strval($model);
  1000|         }
  1001|         if ($schema && !isset($schemaName)) {
  1002|             $schemaName = $this->getSchemaName();
  1003|         }
  1004|         if ($quote) {
  1005|             if ($schema && !empty($schemaName)) {
  1006|                 if (strstr($table, '.') === false) {
  1007|                     return $this->name($schemaName) . '.' . $this->name($table);
  1008|                 }
  1009|             }
  1010|             return $this->name($table);
  1011|         }
  1012|         if ($schema && !empty($schemaName)) {
  1013|             if (strstr($table, '.') === false) {
  1014|                 return $schemaName . '.' . $table;
  1015|             }
  1016|         }
  1017|         return $table;
  1018|     }
  1019|     /**
  1020|      * The "C" in CRUD
  1021|      *
  1022|      * Creates new records in the database.
  1023|      *
  1024|      * @param Model $Model Model object that the record is for.
  1025|      * @param array $fields An array of field names to insert. If null, $Model->data will be
  1026|      *   used to generate field names.
  1027|      * @param array $values An array of values with keys matching the fields. If null, $Model->data will
  1028|      *   be used to generate values.
  1029|      * @return bool Success
  1030|      */
  1031|     public function create(Model $Model, $fields = null, $values = null)
  1032|     {
  1033|         $id = null;
  1034|         if (!$fields) {
  1035|             unset($fields, $values);
  1036|             $fields = array_keys($Model->data);
  1037|             $values = array_values($Model->data);
  1038|         }
  1039|         $count = count($fields);
  1040|         for($i = 0; $i < $count; $i++) {
  1041|             $schema = $Model->schema();
  1042|             $valueInsert[] = $this->value($values[$i], $Model->getColumnType($fields[$i]), isset($schema[$fields[$i]]['null'])? $schema[$fields[$i]]['null'] : true);
  1043|             $fieldInsert[] = $this->name($fields[$i]);
  1044|             if ($fields[$i] === $Model->primaryKey) {
  1045|                 $id = $values[$i];
  1046|             }
  1047|         }
  1048|         $query = [
  1049|             'table' => $this->fullTableName($Model),
  1050|             'fields' => implode(', ', $fieldInsert),
  1051|             'values' => implode(', ', $valueInsert)
  1052|         ];
  1053|         if ($this->execute($this->renderStatement('create', $query))) {
  1054|             if (empty($id)) {
  1055|                 $id = $this->lastInsertId($this->fullTableName($Model, false, false), $Model->primaryKey);
  1056|             }
  1057|             $Model->setInsertID($id);
  1058|             $Model->id = $id;
  1059|             return true;
  1060|         }
  1061|         $Model->onError();
  1062|         return false;
  1063|     }
  1064|     /**
  1065|      * The "R" in CRUD
  1066|      *
  1067|      * Reads record(s) from the database.
  1068|      *
  1069|      * @param Model $Model A Model object that the query is for.
  1070|      * @param array $queryData An array of queryData information containing keys similar to Model::find().
  1071|      * @param int $recursive Number of levels of association
  1072|      * @return mixed boolean false on error/failure. An array of results on success.
  1073|      */
  1074|     public function read(Model $Model, $queryData = [], $recursive = null)
  1075|     {
  1076|         $queryData = $this->_scrubQueryData($queryData);
  1077|         $array = ['callbacks' => $queryData['callbacks']];
  1078|         if ($recursive === null && isset($queryData['recursive'])) {
  1079|             $recursive = $queryData['recursive'];
  1080|         }
  1081|         if ($recursive !== null) {
  1082|             $modelRecursive = $Model->recursive;
  1083|             $Model->recursive = $recursive;
  1084|         }
  1085|         if (!empty($queryData['fields'])) {
  1086|             $noAssocFields = true;
  1087|             $queryData['fields'] = $this->fields($Model, null, $queryData['fields']);
  1088|         } else {
  1089|             $noAssocFields = false;
  1090|             $queryData['fields'] = $this->fields($Model);
  1091|         }
  1092|         if ($Model->recursive === -1) {
  1093|             $associations = [];
  1094|         } else {
  1095|             $associations = $Model->associations();
  1096|             if ($Model->recursive === 0) {
  1097|                 unset($associations[2], $associations[3]);
  1098|             }
  1099|         }
  1100|         $originalJoins = $queryData['joins'];
  1101|         $queryData['joins'] = [];
  1102|         $linkedModels = [];
  1103|         foreach($associations as $type) {
  1104|             if ($type !== 'hasOne' && $type !== 'belongsTo') {
  1105|                 continue;
  1106|             }
  1107|             foreach($Model->{$type} as $assoc => $assocData) {
  1108|                 $LinkModel = $Model->{$assoc};
  1109|                 if ($Model->useDbConfig !== $LinkModel->useDbConfig) {
  1110|                     continue;
  1111|                 }
  1112|                 if ($noAssocFields) {
  1113|                     $assocData['fields'] = false;
  1114|                 }
  1115|                 $external = isset($assocData['external']);
  1116|                 if ($this->generateAssociationQuery($Model, $LinkModel, $type, $assoc, $assocData, $queryData, $external) === true) {
  1117|                     $linkedModels[$type . '/' . $assoc] = true;
  1118|                 }
  1119|             }
  1120|         }
  1121|         if (!empty($originalJoins)) {
  1122|             $queryData['joins'] = array_merge($queryData['joins'], $originalJoins);
  1123|         }
  1124|         $query = $this->buildAssociationQuery($Model, $queryData);
  1125|         $resultSet = $this->fetchAll($query, $Model->cacheQueries);
  1126|         unset($query);
  1127|         if ($resultSet === false) {
  1128|             $Model->onError();
  1129|             return false;
  1130|         }
  1131|         $filtered = [];
  1132|         if ($Model->recursive > -1) {
  1133|             $joined = [];
  1134|             if (isset($queryData['joins'][0]['alias'])) {
  1135|                 $joined[$Model->alias] = (array)Hash::extract($queryData['joins'], '{n}.alias');
  1136|             }
  1137|             foreach($associations as $type) {
  1138|                 foreach($Model->{$type} as $assoc => $assocData) {
  1139|                     $LinkModel = $Model->{$assoc};
  1140|                     if (!isset($linkedModels[$type . '/' . $assoc])) {
  1141|                         $db = $Model->useDbConfig === $LinkModel->useDbConfig? $this : $LinkModel->getDataSource();
  1142|                     } elseif ($Model->recursive > 1) {
  1143|                         $db = $this;
  1144|                     }
  1145|                     if (isset($db) && method_exists($db, 'queryAssociation')) {
  1146|                         $stack = [$assoc];
  1147|                         $stack['_joined'] = $joined;
  1148|                         $db->queryAssociation($Model, $LinkModel, $type, $assoc, $assocData, $array, true, $resultSet, $Model->recursive - 1, $stack);
  1149|                         unset($db);
  1150|                         if ($type === 'hasMany' || $type === 'hasAndBelongsToMany') {
  1151|                             $filtered[] = $assoc;
  1152|                         }
  1153|                     }
  1154|                 }
  1155|             }
  1156|         }
  1157|         if ($queryData['callbacks'] === true || $queryData['callbacks'] === 'after') {
  1158|             $this->_filterResults($resultSet, $Model, $filtered);
  1159|         }
  1160|         if ($recursive !== null) {
  1161|             $Model->recursive = $modelRecursive;
  1162|         }
  1163|         return $resultSet;
  1164|     }
  1165|     /**
  1166|      * Passes association results through afterFind filters of the corresponding model.
  1167|      *
  1168|      * The primary model is always excluded, because the filtering is later done by Model::_filterResults().
  1169|      *
  1170|      * @param array &$resultSet Reference of resultset to be filtered.
  1171|      * @param Model $Model Instance of model to operate against.
  1172|      * @param array $filtered List of classes already filtered, to be skipped.
  1173|      * @return array Array of results that have been filtered through $Model->afterFind.
  1174|      */
  1175|     protected function _filterResults(&$resultSet, Model $Model, $filtered = [])
  1176|     {
  1177|         if (!is_array($resultSet)) {
  1178|             return [];
  1179|         }
  1180|         $current = reset($resultSet);
  1181|         if (!is_array($current)) {
  1182|             return [];
  1183|         }
  1184|         $keys = array_diff(array_keys($current), $filtered, [$Model->alias]);
  1185|         $filtering = [];
  1186|         foreach($keys as $className) {
  1187|             if (!isset($Model->{$className}) || !is_object($Model->{$className})) {
  1188|                 continue;
  1189|             }
  1190|             $LinkedModel = $Model->{$className};
  1191|             $filtering[] = $className;
  1192|             foreach($resultSet as $key => &$result) {
  1193|                 $data = $LinkedModel->afterFind([[$className => $result[$className]]], false);
  1194|                 if (isset($data[0][$className])) {
  1195|                     $result[$className] = $data[0][$className];
  1196|                 } else {
  1197|                     unset($resultSet[$key]);
  1198|                 }
  1199|             }
  1200|         }
  1201|         return $filtering;
  1202|     }
  1203|     /**
  1204|      * Passes association results through afterFind filters of the corresponding model.
  1205|      *
  1206|      * Similar to DboSource::_filterResults(), but this filters only specified models.
  1207|      * The primary model can not be specified, because this call DboSource::_filterResults() internally.
  1208|      *
  1209|      * @param array &$resultSet Reference of resultset to be filtered.
  1210|      * @param Model $Model Instance of model to operate against.
  1211|      * @param array $toBeFiltered List of classes to be filtered.
  1212|      * @return array Array of results that have been filtered through $Model->afterFind.
  1213|      */
  1214|     protected function _filterResultsInclusive(&$resultSet, Model $Model, $toBeFiltered = [])
  1215|     {
  1216|         $exclude = [];
  1217|         if (is_array($resultSet)) {
  1218|             $current = reset($resultSet);
  1219|             if (is_array($current)) {
  1220|                 $exclude = array_diff(array_keys($current), $toBeFiltered);
  1221|             }
  1222|         }
  1223|         return $this->_filterResults($resultSet, $Model, $exclude);
  1224|     }
  1225|     /**
  1226|      * Queries associations.
  1227|      *
  1228|      * Used to fetch results on recursive models.
  1229|      *
  1230|      * - 'hasMany' associations with no limit set:
  1231|      *    Fetch, filter and merge is done recursively for every level.
  1232|      *
  1233|      * - 'hasAndBelongsToMany' associations:
  1234|      *    Fetch and filter is done unaffected by the (recursive) level set.
  1235|      *
  1236|      * @param Model $Model Primary Model object.
  1237|      * @param Model $LinkModel Linked model object.
  1238|      * @param string $type Association type, one of the model association types ie. hasMany.
  1239|      * @param string $association Association name.
  1240|      * @param array $assocData Association data.
  1241|      * @param array &$queryData An array of queryData information containing keys similar to Model::find().
  1242|      * @param bool $external Whether or not the association query is on an external datasource.
  1243|      * @param array &$resultSet Existing results.
  1244|      * @param int $recursive Number of levels of association.
  1245|      * @param array $stack A list with joined models.
  1246|      * @return mixed
  1247|      * @throws CakeException when results cannot be created.
  1248|      */
  1249|     public function queryAssociation(Model $Model, Model $LinkModel, $type, $association, $assocData, &$queryData, $external, &$resultSet, $recursive, $stack)
  1250|     {
  1251|         if (isset($stack['_joined'])) {
  1252|             $joined = $stack['_joined'];
  1253|             unset($stack['_joined']);
  1254|         }
  1255|         $queryTemplate = $this->generateAssociationQuery($Model, $LinkModel, $type, $association, $assocData, $queryData, $external);
  1256|         if (empty($queryTemplate)) {
  1257|             return null;
  1258|         }
  1259|         if (!is_array($resultSet)) {
  1260|             throw new CakeException(__d('cake_dev', 'Error in Model %s', get_class($Model)));
  1261|         }
  1262|         if ($type === 'hasMany' && empty($assocData['limit']) && !empty($assocData['foreignKey'])) {
  1263|             $assocIds = [];
  1264|             foreach($resultSet as $result) {
  1265|                 $assocIds[] = $this->insertQueryData('{$__cakeID__$}', $result, $association, $Model, $stack);
  1266|             }
  1267|             $assocIds = array_filter($assocIds);
  1268|             $assocResultSet = [];
  1269|             if (!empty($assocIds)) {
  1270|                 $assocResultSet = $this->_fetchHasMany($Model, $queryTemplate, $assocIds);
  1271|             }
  1272|             if ($recursive > 0 && !empty($assocResultSet) && is_array($assocResultSet)) {
  1273|                 foreach($LinkModel->associations() as $type1) {
  1274|                     foreach($LinkModel->{$type1} as $assoc1 => $assocData1) {
  1275|                         $DeepModel = $LinkModel->{$assoc1};
  1276|                         $tmpStack = $stack;
  1277|                         $tmpStack[] = $assoc1;
  1278|                         $db = $LinkModel->useDbConfig === $DeepModel->useDbConfig? $this : $DeepModel->getDataSource();
  1279|                         $db->queryAssociation($LinkModel, $DeepModel, $type1, $assoc1, $assocData1, $queryData, true, $assocResultSet, $recursive - 1, $tmpStack);
  1280|                     }
  1281|                 }
  1282|             }
  1283|             if ($queryData['callbacks'] === true || $queryData['callbacks'] === 'after') {
  1284|                 $this->_filterResultsInclusive($assocResultSet, $Model, [$association]);
  1285|             }
  1286|             return $this->_mergeHasMany($resultSet, $assocResultSet, $association, $Model);
  1287|         } elseif ($type === 'hasAndBelongsToMany') {
  1288|             $assocIds = [];
  1289|             foreach($resultSet as $result) {
  1290|                 $assocIds[] = $this->insertQueryData('{$__cakeID__$}', $result, $association, $Model, $stack);
  1291|             }
  1292|             $assocIds = array_filter($assocIds);
  1293|             $assocResultSet = [];
  1294|             if (!empty($assocIds)) {
  1295|                 $assocResultSet = $this->_fetchHasAndBelongsToMany($Model, $queryTemplate, $assocIds, $association);
  1296|             }
  1297|             $habtmAssocData = $Model->hasAndBelongsToMany[$association];
  1298|             $foreignKey = $habtmAssocData['foreignKey'];
  1299|             $joinKeys = [$foreignKey, $habtmAssocData['associationForeignKey']];
  1300|             [$with, $habtmFields] = $Model->joinModel($habtmAssocData['with'], $joinKeys);
  1301|             $habtmFieldsCount = count($habtmFields);
  1302|             if ($queryData['callbacks'] === true || $queryData['callbacks'] === 'after') {
  1303|                 $this->_filterResultsInclusive($assocResultSet, $Model, [$association, $with]);
  1304|             }
  1305|         }
  1306|         $modelAlias = $Model->alias;
  1307|         $primaryKey = $Model->primaryKey;
  1308|         $selfJoin = ($Model->name === $LinkModel->name);
  1309|         foreach($resultSet as &$row) {
  1310|             if ($type === 'hasOne' || $type === 'belongsTo' || $type === 'hasMany') {
  1311|                 $assocResultSet = [];
  1312|                 $prefetched = false;
  1313|                 if (($type === 'hasOne' || $type === 'belongsTo') &&
  1314|                     isset($row[$LinkModel->alias], $joined[$Model->alias]) &&
  1315|                     in_array($LinkModel->alias, $joined[$Model->alias])
  1316|                 ) {
  1317|                     $joinedData = Hash::filter($row[$LinkModel->alias]);
  1318|                     if (!empty($joinedData)) {
  1319|                         $assocResultSet[0] = [$LinkModel->alias => $row[$LinkModel->alias]];
  1320|                     }
  1321|                     $prefetched = true;
  1322|                 } else {
  1323|                     $query = $this->insertQueryData($queryTemplate, $row, $association, $Model, $stack);
  1324|                     if ($query !== false) {
  1325|                         $assocResultSet = $this->fetchAll($query, $Model->cacheQueries);
  1326|                     }
  1327|                 }
  1328|             }
  1329|             if (!empty($assocResultSet) && is_array($assocResultSet)) {
  1330|                 if ($recursive > 0) {
  1331|                     foreach($LinkModel->associations() as $type1) {
  1332|                         foreach($LinkModel->{$type1} as $assoc1 => $assocData1) {
  1333|                             $DeepModel = $LinkModel->{$assoc1};
  1334|                             if ($type1 === 'belongsTo' ||
  1335|                                 ($type === 'belongsTo' && $DeepModel->alias === $modelAlias) ||
  1336|                                 ($DeepModel->alias !== $modelAlias)
  1337|                             ) {
  1338|                                 $tmpStack = $stack;
  1339|                                 $tmpStack[] = $assoc1;
  1340|                                 $db = $LinkModel->useDbConfig === $DeepModel->useDbConfig? $this : $DeepModel->getDataSource();
  1341|                                 $db->queryAssociation($LinkModel, $DeepModel, $type1, $assoc1, $assocData1, $queryData, true, $assocResultSet, $recursive - 1, $tmpStack);
  1342|                             }
  1343|                         }
  1344|                     }
  1345|                 }
  1346|                 if ($type === 'hasAndBelongsToMany') {
  1347|                     $merge = [];
  1348|                     foreach($assocResultSet as $data) {
  1349|                         if (isset($data[$with]) && $data[$with][$foreignKey] === $row[$modelAlias][$primaryKey]) {
  1350|                             if ($habtmFieldsCount <= 2) {
  1351|                                 unset($data[$with]);
  1352|                             }
  1353|                             $merge[] = $data;
  1354|                         }
  1355|                     }
  1356|                     if (empty($merge) && !isset($row[$association])) {
  1357|                         $row[$association] = $merge;
  1358|                     } else {
  1359|                         $this->_mergeAssociation($row, $merge, $association, $type);
  1360|                     }
  1361|                 } else {
  1362|                     if (!$prefetched && $LinkModel->useConsistentAfterFind) {
  1363|                         if ($queryData['callbacks'] === true || $queryData['callbacks'] === 'after') {
  1364|                             $this->_filterResultsInclusive($assocResultSet, $Model, [$association]);
  1365|                         }
  1366|                     }
  1367|                     $this->_mergeAssociation($row, $assocResultSet, $association, $type, $selfJoin);
  1368|                 }
  1369|                 if ($type !== 'hasAndBelongsToMany' && isset($row[$association]) && !$prefetched && !$LinkModel->useConsistentAfterFind) {
  1370|                     $row[$association] = $LinkModel->afterFind($row[$association], false);
  1371|                 }
  1372|             } else {
  1373|                 $tempArray[0][$association] = false;
  1374|                 $this->_mergeAssociation($row, $tempArray, $association, $type, $selfJoin);
  1375|             }
  1376|         }
  1377|     }
  1378|     /**
  1379|      * Fetch 'hasMany' associations.
  1380|      *
  1381|      * This is just a proxy to maintain BC.
  1382|      *
  1383|      * @param Model $Model Primary model object.
  1384|      * @param string $query Association query template.
  1385|      * @param array $ids Array of IDs of associated records.
  1386|      * @return array Association results.
  1387|      * @see DboSource::_fetchHasMany()
  1388|      */
  1389|     public function fetchAssociated(Model $Model, $query, $ids)
  1390|     {
  1391|         return $this->_fetchHasMany($Model, $query, $ids);
  1392|     }
  1393|     /**
  1394|      * Fetch 'hasMany' associations.
  1395|      *
  1396|      * @param Model $Model Primary model object.
  1397|      * @param string $query Association query template.
  1398|      * @param array $ids Array of IDs of associated records.
  1399|      * @return array Association results.
  1400|      */
  1401|     protected function _fetchHasMany(Model $Model, $query, $ids)
  1402|     {
  1403|         $ids = array_unique($ids);
  1404|         if (count($ids) > 1) {
  1405|             $query = str_replace('= ({$__cakeID__$}', 'IN ({$__cakeID__$}', $query);
  1406|         }
  1407|         $query = str_replace('{$__cakeID__$}', implode(', ', $ids), $query);
  1408|         return $this->fetchAll($query, $Model->cacheQueries);
  1409|     }
  1410|     /**
  1411|      * Fetch 'hasAndBelongsToMany' associations.
  1412|      *
  1413|      * @param Model $Model Primary model object.
  1414|      * @param string $query Association query.
  1415|      * @param array $ids Array of IDs of associated records.
  1416|      * @param string $association Association name.
  1417|      * @return array Association results.
  1418|      */
  1419|     protected function _fetchHasAndBelongsToMany(Model $Model, $query, $ids, $association)
  1420|     {
  1421|         $ids = array_unique($ids);
  1422|         if (count($ids) > 1) {
  1423|             $query = str_replace('{$__cakeID__$}', '(' . implode(', ', $ids) . ')', $query);
  1424|             $query = str_replace('= (', 'IN (', $query);
  1425|         } else {
  1426|             $query = str_replace('{$__cakeID__$}', $ids[0], $query);
  1427|         }
  1428|         $query = str_replace(' WHERE 1 = 1', '', $query);
  1429|         return $this->fetchAll($query, $Model->cacheQueries);
  1430|     }
  1431|     /**
  1432|      * Merge the results of 'hasMany' associations.
  1433|      *
  1434|      * Note: this function also deals with the formatting of the data.
  1435|      *
  1436|      * @param array &$resultSet Data to merge into.
  1437|      * @param array $assocResultSet Data to merge.
  1438|      * @param string $association Name of Model being merged.
  1439|      * @param Model $Model Model being merged onto.
  1440|      * @return void
  1441|      */
  1442|     protected function _mergeHasMany(&$resultSet, $assocResultSet, $association, Model $Model)
  1443|     {
  1444|         $modelAlias = $Model->alias;
  1445|         $primaryKey = $Model->primaryKey;
  1446|         $foreignKey = $Model->hasMany[$association]['foreignKey'];
  1447|         $mergedByFK = [];
  1448|         if (is_array($assocResultSet)) {
  1449|             foreach($assocResultSet as $data) {
  1450|                 $fk = $data[$association][$foreignKey];
  1451|                 if (!array_key_exists($fk, $mergedByFK)) {
  1452|                     $mergedByFK[$fk] = [];
  1453|                 }
  1454|                 if (count($data) > 1) {
  1455|                     $data = array_merge($data[$association], $data);
  1456|                     unset($data[$association]);
  1457|                     foreach($data as $key => $name) {
  1458|                         if (is_numeric($key)) {
  1459|                             $data[$association][] = $name;
  1460|                             unset($data[$key]);
  1461|                         }
  1462|                     }
  1463|                     $mergedByFK[$fk][] = $data;
  1464|                 } else {
  1465|                     $mergedByFK[$fk][] = $data[$association];
  1466|                 }
  1467|             }
  1468|         }
  1469|         foreach($resultSet as &$result) {
  1470|             if (!isset($result[$modelAlias])) {
  1471|                 continue;
  1472|             }
  1473|             $merged = [];
  1474|             $pk = $result[$modelAlias][$primaryKey];
  1475|             if (isset($mergedByFK[$pk])) {
  1476|                 $merged = $mergedByFK[$pk];
  1477|             }
  1478|             $result = Hash::mergeDiff($result, [$association => $merged]);
  1479|         }
  1480|     }
  1481|     /**
  1482|      * Merge association of merge into data
  1483|      *
  1484|      * @param array &$data The data to merge.
  1485|      * @param array &$merge The data to merge.
  1486|      * @param string $association The association name to merge.
  1487|      * @param string $type The type of association
  1488|      * @param bool $selfJoin Whether or not this is a self join.
  1489|      * @return void
  1490|      */
  1491|     protected function _mergeAssociation(&$data, &$merge, $association, $type, $selfJoin = false)
  1492|     {
  1493|         if (isset($merge[0]) && !isset($merge[0][$association])) {
  1494|             $association = Inflector::pluralize($association);
  1495|         }
  1496|         $dataAssociation =& $data[$association];
  1497|         if ($type === 'belongsTo' || $type === 'hasOne') {
  1498|             if (isset($merge[$association])) {
  1499|                 $dataAssociation = $merge[$association][0];
  1500|             } else {
  1501|                 if (!empty($merge[0][$association])) {
  1502|                     foreach($merge[0] as $assoc => $data2) {
  1503|                         if ($assoc !== $association) {
  1504|                             $merge[0][$association][$assoc] = $data2;
  1505|                         }
  1506|                     }
  1507|                 }
  1508|                 if (!isset($dataAssociation)) {
  1509|                     $dataAssociation = [];
  1510|                     if ($merge[0][$association]) {
  1511|                         $dataAssociation = $merge[0][$association];
  1512|                     }
  1513|                 } else {
  1514|                     if (is_array($merge[0][$association])) {
  1515|                         $mergeAssocTmp = [];
  1516|                         foreach($dataAssociation as $k => $v) {
  1517|                             if (!is_array($v)) {
  1518|                                 $dataAssocTmp[$k] = $v;
  1519|                             }
  1520|                         }
  1521|                         foreach($merge[0][$association] as $k => $v) {
  1522|                             if (!is_array($v)) {
  1523|                                 $mergeAssocTmp[$k] = $v;
  1524|                             }
  1525|                         }
  1526|                         $dataKeys = array_keys($data);
  1527|                         $mergeKeys = array_keys($merge[0]);
  1528|                         if ($mergeKeys[0] === $dataKeys[0] || $mergeKeys === $dataKeys) {
  1529|                             $dataAssociation[$association] = $merge[0][$association];
  1530|                         } else {
  1531|                             $diff = Hash::diff($dataAssocTmp, $mergeAssocTmp);
  1532|                             $dataAssociation = array_merge($merge[0][$association], $diff);
  1533|                         }
  1534|                     } elseif ($selfJoin && array_key_exists($association, $merge[0])) {
  1535|                         $dataAssociation = array_merge($dataAssociation, [$association => []]);
  1536|                     }
  1537|                 }
  1538|             }
  1539|         } else {
  1540|             if (isset($merge[0][$association]) && $merge[0][$association] === false) {
  1541|                 if (!isset($dataAssociation)) {
  1542|                     $dataAssociation = [];
  1543|                 }
  1544|             } else {
  1545|                 foreach($merge as $row) {
  1546|                     $insert = [];
  1547|                     if (count($row) === 1) {
  1548|                         $insert = $row[$association];
  1549|                     } elseif (isset($row[$association])) {
  1550|                         $insert = array_merge($row[$association], $row);
  1551|                         unset($insert[$association]);
  1552|                     }
  1553|                     if (empty($dataAssociation) || (isset($dataAssociation) && !in_array($insert, $dataAssociation, true))) {
  1554|                         $dataAssociation[] = $insert;
  1555|                     }
  1556|                 }
  1557|             }
  1558|         }
  1559|     }
  1560|     /**
  1561|      * Prepares fields required by an SQL statement.
  1562|      *
  1563|      * When no fields are set, all the $Model fields are returned.
  1564|      *
  1565|      * @param Model $Model The model to prepare.
  1566|      * @param array $queryData An array of queryData information containing keys similar to Model::find().
  1567|      * @return array Array containing SQL fields.
  1568|      */
  1569|     public function prepareFields(Model $Model, $queryData)
  1570|     {
  1571|         if (empty($queryData['fields'])) {
  1572|             $queryData['fields'] = $this->fields($Model);
  1573|         } elseif (!empty($Model->hasMany) && $Model->recursive > -1) {
  1574|             $assocFields = $this->fields($Model, null, "{$Model->alias}.{$Model->primaryKey}");
  1575|             $passedFields = $queryData['fields'];
  1576|             if (count($passedFields) > 1 ||
  1577|                 (strpos($passedFields[0], $assocFields[0]) === false && !preg_match('/^[a-z]+\(/i', $passedFields[0]))
  1578|             ) {
  1579|                 $queryData['fields'] = array_merge($passedFields, $assocFields);
  1580|             }
  1581|         }
  1582|         return array_unique($queryData['fields']);
  1583|     }
  1584|     /**
  1585|      * Builds an SQL statement.
  1586|      *
  1587|      * This is merely a convenient wrapper to DboSource::buildStatement().
  1588|      *
  1589|      * @param Model $Model The model to build an association query for.
  1590|      * @param array $queryData An array of queryData information containing keys similar to Model::find().
  1591|      * @return string String containing an SQL statement.
  1592|      * @see DboSource::buildStatement()
  1593|      */
  1594|     public function buildAssociationQuery(Model $Model, $queryData)
  1595|     {
  1596|         $queryData = $this->_scrubQueryData($queryData);
  1597|         return $this->buildStatement(
  1598|             [
  1599|                 'fields' => $this->prepareFields($Model, $queryData),
  1600|                 'table' => $this->fullTableName($Model),
  1601|                 'alias' => $Model->alias,
  1602|                 'limit' => $queryData['limit'],
  1603|                 'offset' => $queryData['offset'],
  1604|                 'joins' => $queryData['joins'],
  1605|                 'conditions' => $queryData['conditions'],
  1606|                 'order' => $queryData['order'],
  1607|                 'group' => $queryData['group'],
  1608|                 'having' => $queryData['having'],
  1609|                 'lock' => $queryData['lock'],
  1610|             ],
  1611|             $Model
  1612|         );
  1613|     }
  1614|     /**
  1615|      * Generates a query or part of a query from a single model or two associated models.
  1616|      *
  1617|      * Builds a string containing an SQL statement template.
  1618|      *
  1619|      * @param Model $Model Primary Model object.
  1620|      * @param Model|null $LinkModel Linked model object.
  1621|      * @param string $type Association type, one of the model association types ie. hasMany.
  1622|      * @param string $association Association name.
  1623|      * @param array $assocData Association data.
  1624|      * @param array &$queryData An array of queryData information containing keys similar to Model::find().
  1625|      * @param bool $external Whether or not the association query is on an external datasource.
  1626|      * @return mixed
  1627|      *   String representing a query.
  1628|      *   True, when $external is false and association $type is 'hasOne' or 'belongsTo'.
  1629|      */
  1630|     public function generateAssociationQuery(Model $Model, $LinkModel, $type, $association, $assocData, &$queryData, $external)
  1631|     {
  1632|         $assocData = $this->_scrubQueryData($assocData);
  1633|         $queryData = $this->_scrubQueryData($queryData);
  1634|         if ($LinkModel === null) {
  1635|             return $this->buildStatement(
  1636|                 [
  1637|                     'fields' => array_unique($queryData['fields']),
  1638|                     'table' => $this->fullTableName($Model),
  1639|                     'alias' => $Model->alias,
  1640|                     'limit' => $queryData['limit'],
  1641|                     'offset' => $queryData['offset'],
  1642|                     'joins' => $queryData['joins'],
  1643|                     'conditions' => $queryData['conditions'],
  1644|                     'order' => $queryData['order'],
  1645|                     'group' => $queryData['group']
  1646|                 ],
  1647|                 $Model
  1648|             );
  1649|         }
  1650|         if ($external && !empty($assocData['finderQuery'])) {
  1651|             return $assocData['finderQuery'];
  1652|         }
  1653|         if ($type === 'hasMany' || $type === 'hasAndBelongsToMany') {
  1654|             if (empty($assocData['offset']) && !empty($assocData['page'])) {
  1655|                 $assocData['offset'] = ($assocData['page'] - 1) * $assocData['limit'];
  1656|             }
  1657|         }
  1658|         switch($type) {
  1659|             case 'hasOne':
  1660|             case 'belongsTo':
  1661|                 $conditions = $this->_mergeConditions(
  1662|                     $assocData['conditions'],
  1663|                     $this->getConstraint($type, $Model, $LinkModel, $association, array_merge($assocData, compact('external')))
  1664|                 );
  1665|                 if ($external) {
  1666|                     if ($Model->name !== $LinkModel->name) {
  1667|                         $modelAlias = $Model->alias;
  1668|                         foreach($conditions as $key => $condition) {
  1669|                             if (is_numeric($key) && strpos($condition, $modelAlias . '.') !== false) {
  1670|                                 unset($conditions[$key]);
  1671|                             }
  1672|                         }
  1673|                     }
  1674|                     $query = array_merge($assocData, [
  1675|                         'conditions' => $conditions,
  1676|                         'table' => $this->fullTableName($LinkModel),
  1677|                         'fields' => $this->fields($LinkModel, $association, $assocData['fields']),
  1678|                         'alias' => $association,
  1679|                         'group' => null
  1680|                     ]);
  1681|                 } else {
  1682|                     $join = [
  1683|                         'table' => $LinkModel,
  1684|                         'alias' => $association,
  1685|                         'type' => isset($assocData['type'])? $assocData['type'] : 'LEFT',
  1686|                         'conditions' => trim($this->conditions($conditions, true, false, $Model))
  1687|                     ];
  1688|                     $fields = [];
  1689|                     if ($assocData['fields'] !== false) {
  1690|                         $fields = $this->fields($LinkModel, $association, $assocData['fields']);
  1691|                     }
  1692|                     $queryData['fields'] = array_merge($this->prepareFields($Model, $queryData), $fields);
  1693|                     if (!empty($assocData['order'])) {
  1694|                         $queryData['order'][] = $assocData['order'];
  1695|                     }
  1696|                     if (!in_array($join, $queryData['joins'], true)) {
  1697|                         $queryData['joins'][] = $join;
  1698|                     }
  1699|                     return true;
  1700|                 }
  1701|                 break;
  1702|             case 'hasMany':
  1703|                 $assocData['fields'] = $this->fields($LinkModel, $association, $assocData['fields']);
  1704|                 if (!empty($assocData['foreignKey'])) {
  1705|                     $assocData['fields'] = array_merge($assocData['fields'], $this->fields($LinkModel, $association, ["{$association}.{$assocData['foreignKey']}"]));
  1706|                 }
  1707|                 $query = [
  1708|                     'conditions' => $this->_mergeConditions($this->getConstraint('hasMany', $Model, $LinkModel, $association, $assocData), $assocData['conditions']),
  1709|                     'fields' => array_unique($assocData['fields']),
  1710|                     'table' => $this->fullTableName($LinkModel),
  1711|                     'alias' => $association,
  1712|                     'order' => $assocData['order'],
  1713|                     'limit' => $assocData['limit'],
  1714|                     'offset' => $assocData['offset'],
  1715|                     'group' => null
  1716|                 ];
  1717|                 break;
  1718|             case 'hasAndBelongsToMany':
  1719|                 $joinFields = [];
  1720|                 $joinAssoc = null;
  1721|                 if (isset($assocData['with']) && !empty($assocData['with'])) {
  1722|                     $joinKeys = [$assocData['foreignKey'], $assocData['associationForeignKey']];
  1723|                     [$with, $joinFields] = $Model->joinModel($assocData['with'], $joinKeys);
  1724|                     $joinTbl = $Model->{$with};
  1725|                     $joinAlias = $joinTbl;
  1726|                     if (is_array($joinFields) && !empty($joinFields)) {
  1727|                         $joinAssoc = $joinAlias = $joinTbl->alias;
  1728|                         $joinFields = $this->fields($joinTbl, $joinAlias, $joinFields);
  1729|                     } else {
  1730|                         $joinFields = [];
  1731|                     }
  1732|                 } else {
  1733|                     $joinTbl = $assocData['joinTable'];
  1734|                     $joinAlias = $this->fullTableName($assocData['joinTable']);
  1735|                 }
  1736|                 $query = [
  1737|                     'conditions' => $assocData['conditions'],
  1738|                     'limit' => $assocData['limit'],
  1739|                     'offset' => $assocData['offset'],
  1740|                     'table' => $this->fullTableName($LinkModel),
  1741|                     'alias' => $association,
  1742|                     'fields' => array_merge($this->fields($LinkModel, $association, $assocData['fields']), $joinFields),
  1743|                     'order' => $assocData['order'],
  1744|                     'group' => null,
  1745|                     'joins' => [[
  1746|                         'table' => $joinTbl,
  1747|                         'alias' => $joinAssoc,
  1748|                         'conditions' => $this->getConstraint('hasAndBelongsToMany', $Model, $LinkModel, $joinAlias, $assocData, $association)
  1749|                     ]]
  1750|                 ];
  1751|                 break;
  1752|         }
  1753|         if (isset($query)) {
  1754|             return $this->buildStatement($query, $Model);
  1755|         }
  1756|         return null;
  1757|     }
  1758|     /**
  1759|      * Returns a conditions array for the constraint between two models.
  1760|      *
  1761|      * @param string $type Association type.
  1762|      * @param Model $Model Primary Model object.
  1763|      * @param Model $LinkModel Linked model object.
  1764|      * @param string $association Association name.
  1765|      * @param array $assocData Association data.
  1766|      * @param string $association2 HABTM association name.
  1767|      * @return array Conditions array defining the constraint between $Model and $LinkModel.
  1768|      */
  1769|     public function getConstraint($type, Model $Model, Model $LinkModel, $association, $assocData, $association2 = null)
  1770|     {
  1771|         $assocData += ['external' => false];
  1772|         if (empty($assocData['foreignKey'])) {
  1773|             return [];
  1774|         }
  1775|         switch($type) {
  1776|             case 'hasOne':
  1777|                 if ($assocData['external']) {
  1778|                     return [
  1779|                         "{$association}.{$assocData['foreignKey']}" => '{$__cakeID__$}'
  1780|                     ];
  1781|                 } else {
  1782|                     return [
  1783|                         "{$association}.{$assocData['foreignKey']}" => $this->identifier("{$Model->alias}.{$Model->primaryKey}")
  1784|                     ];
  1785|                 }
  1786|             case 'belongsTo':
  1787|                 if ($assocData['external']) {
  1788|                     return [
  1789|                         "{$association}.{$LinkModel->primaryKey}" => '{$__cakeForeignKey__$}'
  1790|                     ];
  1791|                 } else {
  1792|                     return [
  1793|                         "{$Model->alias}.{$assocData['foreignKey']}" => $this->identifier("{$association}.{$LinkModel->primaryKey}")
  1794|                     ];
  1795|                 }
  1796|             case 'hasMany':
  1797|                 return ["{$association}.{$assocData['foreignKey']}" => ['{$__cakeID__$}']];
  1798|             case 'hasAndBelongsToMany':
  1799|                 return [
  1800|                     [
  1801|                         "{$association}.{$assocData['foreignKey']}" => '{$__cakeID__$}'
  1802|                     ],
  1803|                     [
  1804|                         "{$association}.{$assocData['associationForeignKey']}" => $this->identifier("{$association2}.{$LinkModel->primaryKey}")
  1805|                     ]
  1806|                 ];
  1807|         }
  1808|         return [];
  1809|     }
  1810|     /**
  1811|      * Builds and generates a JOIN condition from an array. Handles final clean-up before conversion.
  1812|      *
  1813|      * @param array $join An array defining a JOIN condition in a query.
  1814|      * @return string An SQL JOIN condition to be used in a query.
  1815|      * @see DboSource::renderJoinStatement()
  1816|      * @see DboSource::buildStatement()
  1817|      */
  1818|     public function buildJoinStatement($join)
  1819|     {
  1820|         $data = array_merge([
  1821|             'type' => null,
  1822|             'alias' => null,
  1823|             'table' => 'join_table',
  1824|             'conditions' => '',
  1825|         ], $join);
  1826|         if (!empty($data['alias'])) {
  1827|             $data['alias'] = $this->alias . $this->name($data['alias']);
  1828|         }
  1829|         if (!empty($data['conditions'])) {
  1830|             $data['conditions'] = trim($this->conditions($data['conditions'], true, false));
  1831|         }
  1832|         if (!empty($data['table']) && (!is_string($data['table']) || strpos($data['table'], '(') !== 0)) {
  1833|             $data['table'] = $this->fullTableName($data['table']);
  1834|         }
  1835|         return $this->renderJoinStatement($data);
  1836|     }
  1837|     /**
  1838|      * Builds and generates an SQL statement from an array. Handles final clean-up before conversion.
  1839|      *
  1840|      * @param array $query An array defining an SQL query.
  1841|      * @param Model $Model The model object which initiated the query.
  1842|      * @return string An executable SQL statement.
  1843|      * @see DboSource::renderStatement()
  1844|      */
  1845|     public function buildStatement($query, Model $Model)
  1846|     {
  1847|         $query = array_merge($this->_queryDefaults, $query);
  1848|         if (!empty($query['joins'])) {
  1849|             $count = count($query['joins']);
  1850|             for($i = 0; $i < $count; $i++) {
  1851|                 if (is_array($query['joins'][$i])) {
  1852|                     $query['joins'][$i] = $this->buildJoinStatement($query['joins'][$i]);
  1853|                 }
  1854|             }
  1855|         }
  1856|         return $this->renderStatement('select', [
  1857|             'conditions' => $this->conditions($query['conditions'], true, true, $Model),
  1858|             'fields' => implode(', ', $query['fields']),
  1859|             'table' => $query['table'],
  1860|             'alias' => $this->alias . $this->name($query['alias']),
  1861|             'order' => $this->order($query['order'], 'ASC', $Model),
  1862|             'limit' => $this->limit($query['limit'], $query['offset']),
  1863|             'joins' => implode(' ', $query['joins']),
  1864|             'group' => $this->group($query['group'], $Model),
  1865|             'having' => $this->having($query['having'], true, $Model),
  1866|             'lock' => $this->getLockingHint($query['lock']),
  1867|         ]);
  1868|     }
  1869|     /**
  1870|      * Renders a final SQL JOIN statement
  1871|      *
  1872|      * @param array $data The data to generate a join statement for.
  1873|      * @return string
  1874|      */
  1875|     public function renderJoinStatement($data)
  1876|     {
  1877|         if (strtoupper($data['type']) === 'CROSS' || empty($data['conditions'])) {
  1878|             return "{$data['type']} JOIN {$data['table']} {$data['alias']}";
  1879|         }
  1880|         return trim("{$data['type']} JOIN {$data['table']} {$data['alias']} ON ({$data['conditions']})");
  1881|     }
  1882|     /**
  1883|      * Renders a final SQL statement by putting together the component parts in the correct order
  1884|      *
  1885|      * @param string $type type of query being run. e.g select, create, update, delete, schema, alter.
  1886|      * @param array $data Array of data to insert into the query.
  1887|      * @return string|null Rendered SQL expression to be run, otherwise null.
  1888|      */
  1889|     public function renderStatement($type, $data)
  1890|     {
  1891|         extract($data);
  1892|         $aliases = null;
  1893|         switch(strtolower($type)) {
  1894|             case 'select':
  1895|                 $having = !empty($having)? " $having" : '';
  1896|                 $lock = !empty($lock)? " $lock" : '';
  1897|                 return trim("SELECT {$fields} FROM {$table} {$alias} {$joins} {$conditions} {$group}{$having} {$order} {$limit}{$lock}");
  1898|             case 'create':
  1899|                 return "INSERT INTO {$table} ({$fields}) VALUES ({$values})";
  1900|             case 'update':
  1901|                 if (!empty($alias)) {
  1902|                     $aliases = "{$this->alias}{$alias} {$joins} ";
  1903|                 }
  1904|                 return trim("UPDATE {$table} {$aliases}SET {$fields} {$conditions}");
  1905|             case 'delete':
  1906|                 if (!empty($alias)) {
  1907|                     $aliases = "{$this->alias}{$alias} {$joins} ";
  1908|                 }
  1909|                 return trim("DELETE {$alias} FROM {$table} {$aliases}{$conditions}");
  1910|             case 'schema':
  1911|                 foreach(['columns', 'indexes', 'tableParameters'] as $var) {
  1912|                     if (is_array(${$var})) {
  1913|                         ${$var} = "\t" . implode(",\n\t", array_filter(${$var}));
  1914|                     } else {
  1915|                         ${$var} = '';
  1916|                     }
  1917|                 }
  1918|                 if (trim($indexes) !== '') {
  1919|                     $columns .= ',';
  1920|                 }
  1921|                 return "CREATE TABLE {$table} (\n{$columns}{$indexes}) {$tableParameters};";
  1922|             case 'alter':
  1923|                 return null;
  1924|         }
  1925|     }
  1926|     /**
  1927|      * Merges a mixed set of string/array conditions.
  1928|      *
  1929|      * @param mixed $query The query to merge conditions for.
  1930|      * @param mixed $assoc The association names.
  1931|      * @return array
  1932|      */
  1933|     protected function _mergeConditions($query, $assoc)
  1934|     {
  1935|         if (empty($assoc)) {
  1936|             return $query;
  1937|         }
  1938|         if (is_array($query)) {
  1939|             return array_merge((array)$assoc, $query);
  1940|         }
  1941|         if (!empty($query)) {
  1942|             $query = [$query];
  1943|             if (is_array($assoc)) {
  1944|                 $query = array_merge($query, $assoc);
  1945|             } else {
  1946|                 $query[] = $assoc;
  1947|             }
  1948|             return $query;
  1949|         }
  1950|         return $assoc;
  1951|     }
  1952|     /**
  1953|      * Generates and executes an SQL UPDATE statement for given model, fields, and values.
  1954|      * For databases that do not support aliases in UPDATE queries.
  1955|      *
  1956|      * @param Model $Model The model to update.
  1957|      * @param array $fields The fields to update
  1958|      * @param array $values The values fo the fields.
  1959|      * @param mixed $conditions The conditions for the update. When non-empty $values will not be quoted.
  1960|      * @return bool Success
  1961|      */
  1962|     public function update(Model $Model, $fields = [], $values = null, $conditions = null)
  1963|     {
  1964|         if (!$values) {
  1965|             $combined = $fields;
  1966|         } else {
  1967|             $combined = array_combine($fields, $values);
  1968|         }
  1969|         $fields = implode(', ', $this->_prepareUpdateFields($Model, $combined, empty($conditions)));
  1970|         $alias = $joins = null;
  1971|         $table = $this->fullTableName($Model);
  1972|         $conditions = $this->_matchRecords($Model, $conditions);
  1973|         if ($conditions === false) {
  1974|             return false;
  1975|         }
  1976|         $query = compact('table', 'alias', 'joins', 'fields', 'conditions');
  1977|         if (!$this->execute($this->renderStatement('update', $query))) {
  1978|             $Model->onError();
  1979|             return false;
  1980|         }
  1981|         return true;
  1982|     }
  1983|     /**
  1984|      * Quotes and prepares fields and values for an SQL UPDATE statement
  1985|      *
  1986|      * @param Model $Model The model to prepare fields for.
  1987|      * @param array $fields The fields to update.
  1988|      * @param bool $quoteValues If values should be quoted, or treated as SQL snippets
  1989|      * @param bool $alias Include the model alias in the field name
  1990|      * @return array Fields and values, quoted and prepared
  1991|      */
  1992|     protected function _prepareUpdateFields(Model $Model, $fields, $quoteValues = true, $alias = false)
  1993|     {
  1994|         $quotedAlias = $this->startQuote . $Model->alias . $this->endQuote;
  1995|         $schema = $Model->schema();
  1996|         $updates = [];
  1997|         foreach($fields as $field => $value) {
  1998|             if ($alias && strpos($field, '.') === false) {
  1999|                 $quoted = $Model->escapeField($field);
  2000|             } elseif (!$alias && strpos($field, '.') !== false) {
  2001|                 $quoted = $this->name(str_replace($quotedAlias . '.', '', str_replace(
  2002|                     $Model->alias . '.', '', $field
  2003|                 )));
  2004|             } else {
  2005|                 $quoted = $this->name($field);
  2006|             }
  2007|             if ($value === null) {
  2008|                 $updates[] = $quoted . ' = NULL';
  2009|                 continue;
  2010|             }
  2011|             $update = $quoted . ' = ';
  2012|             if ($quoteValues) {
  2013|                 $update .= $this->value($value, $Model->getColumnType($field), isset($schema[$field]['null'])? $schema[$field]['null'] : true);
  2014|             } elseif ($Model->getColumnType($field) === 'boolean' && (is_int($value) || is_bool($value))) {
  2015|                 $update .= $this->boolean($value, true);
  2016|             } elseif (!$alias) {
  2017|                 $update .= str_replace($quotedAlias . '.', '', str_replace(
  2018|                     $Model->alias . '.', '', $value
  2019|                 ));
  2020|             } else {
  2021|                 $update .= $value;
  2022|             }
  2023|             $updates[] = $update;
  2024|         }
  2025|         return $updates;
  2026|     }
  2027|     /**
  2028|      * Generates and executes an SQL DELETE statement.
  2029|      * For databases that do not support aliases in UPDATE queries.
  2030|      *
  2031|      * @param Model $Model The model to delete from
  2032|      * @param mixed $conditions The conditions to use. If empty the model's primary key will be used.
  2033|      * @return bool Success
  2034|      */
  2035|     public function delete(Model $Model, $conditions = null)
  2036|     {
  2037|         $alias = $joins = null;
  2038|         $table = $this->fullTableName($Model);
  2039|         $conditions = $this->_matchRecords($Model, $conditions);
  2040|         if ($conditions === false) {
  2041|             return false;
  2042|         }
  2043|         if ($this->execute($this->renderStatement('delete', compact('alias', 'table', 'joins', 'conditions'))) === false) {
  2044|             $Model->onError();
  2045|             return false;
  2046|         }
  2047|         return true;
  2048|     }
  2049|     /**
  2050|      * Gets a list of record IDs for the given conditions. Used for multi-record updates and deletes
  2051|      * in databases that do not support aliases in UPDATE/DELETE queries.
  2052|      *
  2053|      * @param Model $Model The model to find matching records for.
  2054|      * @param mixed $conditions The conditions to match against.
  2055|      * @return array List of record IDs
  2056|      */
  2057|     protected function _matchRecords(Model $Model, $conditions = null)
  2058|     {
  2059|         if ($conditions === true) {
  2060|             $conditions = $this->conditions(true);
  2061|         } elseif ($conditions === null) {
  2062|             $conditions = $this->conditions($this->defaultConditions($Model, $conditions, false), true, true, $Model);
  2063|         } else {
  2064|             $noJoin = true;
  2065|             foreach($conditions as $field => $value) {
  2066|                 $originalField = $field;
  2067|                 if (strpos($field, '.') !== false) {
  2068|                     [, $field] = explode('.', $field);
  2069|                     $field = ltrim($field, $this->startQuote);
  2070|                     $field = rtrim($field, $this->endQuote);
  2071|                 }
  2072|                 if (!$Model->hasField($field)) {
  2073|                     $noJoin = false;
  2074|                     break;
  2075|                 }
  2076|                 if ($field !== $originalField) {
  2077|                     $conditions[$field] = $value;
  2078|                     unset($conditions[$originalField]);
  2079|                 }
  2080|             }
  2081|             if ($noJoin === true) {
  2082|                 return $this->conditions($conditions);
  2083|             }
  2084|             $idList = $Model->find('all', [
  2085|                 'fields' => "{$Model->alias}.{$Model->primaryKey}",
  2086|                 'conditions' => $conditions
  2087|             ]);
  2088|             if (empty($idList)) {
  2089|                 return false;
  2090|             }
  2091|             $conditions = $this->conditions([
  2092|                 $Model->primaryKey => Hash::extract($idList, "{n}.{$Model->alias}.{$Model->primaryKey}")
  2093|             ]);
  2094|         }
  2095|         return $conditions;
  2096|     }
  2097|     /**
  2098|      * Returns an array of SQL JOIN conditions from a model's associations.
  2099|      *
  2100|      * @param Model $Model The model to get joins for.2
  2101|      * @return array
  2102|      */
  2103|     protected function _getJoins(Model $Model)
  2104|     {
  2105|         $join = [];
  2106|         $joins = array_merge($Model->getAssociated('hasOne'), $Model->getAssociated('belongsTo'));
  2107|         foreach($joins as $assoc) {
  2108|             if (!isset($Model->{$assoc})) {
  2109|                 continue;
  2110|             }
  2111|             $LinkModel = $Model->{$assoc};
  2112|             if ($Model->useDbConfig !== $LinkModel->useDbConfig) {
  2113|                 continue;
  2114|             }
  2115|             $assocData = $Model->getAssociated($assoc);
  2116|             $join[] = $this->buildJoinStatement([
  2117|                 'table' => $LinkModel,
  2118|                 'alias' => $assoc,
  2119|                 'type' => isset($assocData['type'])? $assocData['type'] : 'LEFT',
  2120|                 'conditions' => trim($this->conditions(
  2121|                     $this->_mergeConditions($assocData['conditions'], $this->getConstraint($assocData['association'], $Model, $LinkModel, $assoc, $assocData)),
  2122|                     true,
  2123|                     false,
  2124|                     $Model
  2125|                 ))
  2126|             ]);
  2127|         }
  2128|         return $join;
  2129|     }
  2130|     /**
  2131|      * Returns an SQL calculation, i.e. COUNT() or MAX()
  2132|      *
  2133|      * @param Model $Model The model to get a calculated field for.
  2134|      * @param string $func Lowercase name of SQL function, i.e. 'count' or 'max'
  2135|      * @param array $params Function parameters (any values must be quoted manually)
  2136|      * @return string An SQL calculation function
  2137|      */
  2138|     public function calculate(Model $Model, $func, $params = [])
  2139|     {
  2140|         $params = (array)$params;
  2141|         switch(strtolower($func)) {
  2142|             case 'count':
  2143|                 if (!isset($params[0])) {
  2144|                     $params[0] = '*';
  2145|                 }
  2146|                 if (!isset($params[1])) {
  2147|                     $params[1] = 'count';
  2148|                 }
  2149|                 if ($Model->isVirtualField($params[0])) {
  2150|                     $arg = $this->_quoteFields($Model->getVirtualField($params[0]));
  2151|                 } else {
  2152|                     $arg = $this->name($params[0]);
  2153|                 }
  2154|                 return 'COUNT(' . $arg . ') AS ' . $this->name($params[1]);
  2155|             case 'max':
  2156|             case 'min':
  2157|                 if (!isset($params[1])) {
  2158|                     $params[1] = $params[0];
  2159|                 }
  2160|                 if ($Model->isVirtualField($params[0])) {
  2161|                     $arg = $this->_quoteFields($Model->getVirtualField($params[0]));
  2162|                 } else {
  2163|                     $arg = $this->name($params[0]);
  2164|                 }
  2165|                 return strtoupper($func) . '(' . $arg . ') AS ' . $this->name($params[1]);
  2166|         }
  2167|     }
  2168|     /**
  2169|      * Deletes all the records in a table and resets the count of the auto-incrementing
  2170|      * primary key, where applicable.
  2171|      *
  2172|      * @param Model|string $table A string or model class representing the table to be truncated
  2173|      * @return bool SQL TRUNCATE TABLE statement, false if not applicable.
  2174|      */
  2175|     public function truncate($table)
  2176|     {
  2177|         return $this->execute('TRUNCATE TABLE ' . $this->fullTableName($table));
  2178|     }
  2179|     /**
  2180|      * Check if the server support nested transactions
  2181|      *
  2182|      * @return bool
  2183|      */
  2184|     public function nestedTransactionSupported()
  2185|     {
  2186|         return false;
  2187|     }
  2188|     /**
  2189|      * Begin a transaction
  2190|      *
  2191|      * @return bool True on success, false on fail
  2192|      * (i.e. if the database/model does not support transactions,
  2193|      * or a transaction has not started).
  2194|      */
  2195|     public function begin()
  2196|     {
  2197|         if ($this->_transactionStarted) {
  2198|             if ($this->nestedTransactionSupported()) {
  2199|                 return $this->_beginNested();
  2200|             }
  2201|             $this->_transactionNesting++;
  2202|             return $this->_transactionStarted;
  2203|         }
  2204|         $this->_transactionNesting = 0;
  2205|         if ($this->fullDebug) {
  2206|             $this->took = $this->numRows = $this->affected = false;
  2207|             $this->logQuery('BEGIN');
  2208|         }
  2209|         return $this->_transactionStarted = $this->_connection->beginTransaction();
  2210|     }
  2211|     /**
  2212|      * Begin a nested transaction
  2213|      *
  2214|      * @return bool
  2215|      */
  2216|     protected function _beginNested()
  2217|     {
  2218|         $query = 'SAVEPOINT LEVEL' . ++$this->_transactionNesting;
  2219|         if ($this->fullDebug) {
  2220|             $this->took = $this->numRows = $this->affected = false;
  2221|             $this->logQuery($query);
  2222|         }
  2223|         $this->_connection->exec($query);
  2224|         return true;
  2225|     }
  2226|     /**
  2227|      * Commit a transaction
  2228|      *
  2229|      * @return bool True on success, false on fail
  2230|      * (i.e. if the database/model does not support transactions,
  2231|      * or a transaction has not started).
  2232|      */
  2233|     public function commit()
  2234|     {
  2235|         if (!$this->_transactionStarted) {
  2236|             return false;
  2237|         }
  2238|         if ($this->_transactionNesting === 0) {
  2239|             if ($this->fullDebug) {
  2240|                 $this->took = $this->numRows = $this->affected = false;
  2241|                 $this->logQuery('COMMIT');
  2242|             }
  2243|             $this->_transactionStarted = false;
  2244|             return $this->_connection->commit();
  2245|         }
  2246|         if ($this->nestedTransactionSupported()) {
  2247|             return $this->_commitNested();
  2248|         }
  2249|         $this->_transactionNesting--;
  2250|         return true;
  2251|     }
  2252|     /**
  2253|      * Commit a nested transaction
  2254|      *
  2255|      * @return bool
  2256|      */
  2257|     protected function _commitNested()
  2258|     {
  2259|         $query = 'RELEASE SAVEPOINT LEVEL' . $this->_transactionNesting--;
  2260|         if ($this->fullDebug) {
  2261|             $this->took = $this->numRows = $this->affected = false;
  2262|             $this->logQuery($query);
  2263|         }
  2264|         $this->_connection->exec($query);
  2265|         return true;
  2266|     }
  2267|     /**
  2268|      * Rollback a transaction
  2269|      *
  2270|      * @return bool True on success, false on fail
  2271|      * (i.e. if the database/model does not support transactions,
  2272|      * or a transaction has not started).
  2273|      */
  2274|     public function rollback()
  2275|     {
  2276|         if (!$this->_transactionStarted) {
  2277|             return false;
  2278|         }
  2279|         if ($this->_transactionNesting === 0) {
  2280|             if ($this->fullDebug) {
  2281|                 $this->took = $this->numRows = $this->affected = false;
  2282|                 $this->logQuery('ROLLBACK');
  2283|             }
  2284|             $this->_transactionStarted = false;
  2285|             return $this->_connection->rollBack();
  2286|         }
  2287|         if ($this->nestedTransactionSupported()) {
  2288|             return $this->_rollbackNested();
  2289|         }
  2290|         $this->_transactionNesting--;
  2291|         return true;
  2292|     }
  2293|     /**
  2294|      * Rollback a nested transaction
  2295|      *
  2296|      * @return bool
  2297|      */
  2298|     protected function _rollbackNested()
  2299|     {
  2300|         $query = 'ROLLBACK TO SAVEPOINT LEVEL' . $this->_transactionNesting--;
  2301|         if ($this->fullDebug) {
  2302|             $this->took = $this->numRows = $this->affected = false;
  2303|             $this->logQuery($query);
  2304|         }
  2305|         $this->_connection->exec($query);
  2306|         return true;
  2307|     }
  2308|     /**
  2309|      * Returns the ID generated from the previous INSERT operation.
  2310|      *
  2311|      * @param mixed $source The source to get an id for.
  2312|      * @return mixed
  2313|      */
  2314|     public function lastInsertId($source = null)
  2315|     {
  2316|         return $this->_connection->lastInsertId();
  2317|     }
  2318|     /**
  2319|      * Creates a default set of conditions from the model if $conditions is null/empty.
  2320|      * If conditions are supplied then they will be returned. If a model doesn't exist and no conditions
  2321|      * were provided either null or false will be returned based on what was input.
  2322|      *
  2323|      * @param Model $Model The model to get conditions for.
  2324|      * @param string|array|bool $conditions Array of conditions, conditions string, null or false. If an array of conditions,
  2325|      *   or string conditions those conditions will be returned. With other values the model's existence will be checked.
  2326|      *   If the model doesn't exist a null or false will be returned depending on the input value.
  2327|      * @param bool $useAlias Use model aliases rather than table names when generating conditions
  2328|      * @return mixed Either null, false, $conditions or an array of default conditions to use.
  2329|      * @see DboSource::update()
  2330|      * @see DboSource::conditions()
  2331|      */
  2332|     public function defaultConditions(Model $Model, $conditions, $useAlias = true)
  2333|     {
  2334|         if (!empty($conditions)) {
  2335|             return $conditions;
  2336|         }
  2337|         $exists = $Model->exists($Model->getID());
  2338|         if (!$exists && ($conditions !== null || !empty($Model->__safeUpdateMode))) {
  2339|             return false;
  2340|         } elseif (!$exists) {
  2341|             return null;
  2342|         }
  2343|         $alias = $Model->alias;
  2344|         if (!$useAlias) {
  2345|             $alias = $this->fullTableName($Model, false);
  2346|         }
  2347|         return ["{$alias}.{$Model->primaryKey}" => $Model->getID()];
  2348|     }
  2349|     /**
  2350|      * Returns a key formatted like a string Model.fieldname(i.e. Post.title, or Country.name)
  2351|      *
  2352|      * @param Model $Model The model to get a key for.
  2353|      * @param string $key The key field.
  2354|      * @param string $assoc The association name.
  2355|      * @return string
  2356|      */
  2357|     public function resolveKey(Model $Model, $key, $assoc = null)
  2358|     {
  2359|         if (strpos('.', $key) !== false) {
  2360|             return $this->name($Model->alias) . '.' . $this->name($key);
  2361|         }
  2362|         return $key;
  2363|     }
  2364|     /**
  2365|      * Private helper method to remove query metadata in given data array.
  2366|      *
  2367|      * @param array $data The data to scrub.
  2368|      * @return array
  2369|      */
  2370|     protected function _scrubQueryData($data)
  2371|     {
  2372|         static $base = null;
  2373|         if ($base === null) {
  2374|             $base = array_fill_keys(['conditions', 'fields', 'joins', 'order', 'limit', 'offset', 'group'], []);
  2375|             $base['having'] = null;
  2376|             $base['lock'] = null;
  2377|             $base['callbacks'] = null;
  2378|         }
  2379|         return (array)$data + $base;
  2380|     }
  2381|     /**
  2382|      * Converts model virtual fields into sql expressions to be fetched later
  2383|      *
  2384|      * @param Model $Model The model to get virtual fields for.
  2385|      * @param string $alias Alias table name
  2386|      * @param array $fields virtual fields to be used on query
  2387|      * @return array
  2388|      */
  2389|     protected function _constructVirtualFields(Model $Model, $alias, $fields)
  2390|     {
  2391|         $virtual = [];
  2392|         foreach($fields as $field) {
  2393|             $virtualField = $this->name($alias . $this->virtualFieldSeparator . $field);
  2394|             $virtualFieldExpression = $Model->getVirtualField($field);
  2395|             if (is_object($virtualFieldExpression) && $virtualFieldExpression->type == 'expression') {
  2396|                 $expression = $virtualFieldExpression->value;
  2397|             } else {
  2398|                 $expression = $this->_quoteFields($virtualFieldExpression);
  2399|             }
  2400|             $virtual[] = '(' . $expression . ") {$this->alias} {$virtualField}";
  2401|         }
  2402|         return $virtual;
  2403|     }
  2404|     /**
  2405|      * Generates the fields list of an SQL query.
  2406|      *
  2407|      * @param Model $Model The model to get fields for.
  2408|      * @param string $alias Alias table name
  2409|      * @param mixed $fields The provided list of fields.
  2410|      * @param bool $quote If false, returns fields array unquoted
  2411|      * @return array
  2412|      */
  2413|     public function fields(Model $Model, $alias = null, $fields = [], $quote = true)
  2414|     {
  2415|         if (empty($alias)) {
  2416|             $alias = $Model->alias;
  2417|         }
  2418|         $virtualFields = $Model->getVirtualField();
  2419|         $cacheKey = [
  2420|             $alias,
  2421|             get_class($Model),
  2422|             $Model->alias,
  2423|             $virtualFields,
  2424|             $fields,
  2425|             $quote,
  2426|             ConnectionManager::getSourceName($this),
  2427|             $Model->schemaName,
  2428|             $Model->table
  2429|         ];
  2430|         $cacheKey = $this->cacheMethodHasher(serialize($cacheKey));
  2431|         if ($return = $this->cacheMethod(__FUNCTION__, $cacheKey)) {
  2432|             return $return;
  2433|         }
  2434|         $allFields = empty($fields);
  2435|         if ($allFields) {
  2436|             $fields = array_keys($Model->schema());
  2437|         } elseif (!is_array($fields)) {
  2438|             $fields = CakeText::tokenize($fields);
  2439|         }
  2440|         $fields = array_values(array_filter($fields));
  2441|         $allFields = $allFields || in_array('*', $fields) || in_array($Model->alias . '.*', $fields);
  2442|         $virtual = [];
  2443|         if (!empty($virtualFields)) {
  2444|             $virtualKeys = array_keys($virtualFields);
  2445|             foreach($virtualKeys as $field) {
  2446|                 $virtualKeys[] = $Model->alias . '.' . $field;
  2447|             }
  2448|             $virtual = ($allFields)? $virtualKeys : array_intersect($virtualKeys, $fields);
  2449|             foreach($virtual as $i => $field) {
  2450|                 if (strpos($field, '.') !== false) {
  2451|                     $virtual[$i] = str_replace($Model->alias . '.', '', $field);
  2452|                 }
  2453|                 $fields = array_diff($fields, [$field]);
  2454|             }
  2455|             $fields = array_values($fields);
  2456|         }
  2457|         if (!$quote) {
  2458|             if (!empty($virtual)) {
  2459|                 $fields = array_merge($fields, $this->_constructVirtualFields($Model, $alias, $virtual));
  2460|             }
  2461|             return $fields;
  2462|         }
  2463|         $count = count($fields);
  2464|         if ($count >= 1 && !in_array($fields[0], ['*', 'COUNT(*)'])) {
  2465|             for($i = 0; $i < $count; $i++) {
  2466|                 if (is_string($fields[$i]) && in_array($fields[$i], $virtual)) {
  2467|                     unset($fields[$i]);
  2468|                     continue;
  2469|                 }
  2470|                 if (is_object($fields[$i]) && isset($fields[$i]->type) && $fields[$i]->type === 'expression') {
  2471|                     $fields[$i] = $fields[$i]->value;
  2472|                 } elseif (preg_match('/^\(.*\)\s' . $this->alias . '.*/i', $fields[$i])) {
  2473|                     continue;
  2474|                 } elseif (!preg_match('/^.+\\(.*\\)/', $fields[$i])) {
  2475|                     $prepend = '';
  2476|                     if (strpos($fields[$i], 'DISTINCT') !== false) {
  2477|                         $prepend = 'DISTINCT ';
  2478|                         $fields[$i] = trim(str_replace('DISTINCT', '', $fields[$i]));
  2479|                     }
  2480|                     $dot = strpos($fields[$i], '.');
  2481|                     if ($dot === false) {
  2482|                         $prefix = !(
  2483|                             strpos($fields[$i], ' ') !== false ||
  2484|                             strpos($fields[$i], '(') !== false
  2485|                         );
  2486|                         $fields[$i] = $this->name(($prefix? $alias . '.' : '') . $fields[$i]);
  2487|                     } else {
  2488|                         if (strpos($fields[$i], ',') === false) {
  2489|                             $build = explode('.', $fields[$i]);
  2490|                             if (!Hash::numeric($build)) {
  2491|                                 $fields[$i] = $this->name(implode('.', $build));
  2492|                             }
  2493|                         }
  2494|                     }
  2495|                     $fields[$i] = $prepend . $fields[$i];
  2496|                 } elseif (preg_match('/\(([\.\w]+)\)/', $fields[$i], $field)) {
  2497|                     if (isset($field[1])) {
  2498|                         if (strpos($field[1], '.') === false) {
  2499|                             $field[1] = $this->name($alias . '.' . $field[1]);
  2500|                         } else {
  2501|                             $field[0] = explode('.', $field[1]);
  2502|                             if (!Hash::numeric($field[0])) {
  2503|                                 $field[0] = implode('.', array_map([&$this, 'name'], $field[0]));
  2504|                                 $fields[$i] = preg_replace('/\(' . $field[1] . '\)/', '(' . $field[0] . ')', $fields[$i], 1);
  2505|                             }
  2506|                         }
  2507|                     }
  2508|                 }
  2509|             }
  2510|         }
  2511|         if (!empty($virtual)) {
  2512|             $fields = array_merge($fields, $this->_constructVirtualFields($Model, $alias, $virtual));
  2513|         }
  2514|         return $this->cacheMethod(__FUNCTION__, $cacheKey, array_unique($fields));
  2515|     }
  2516|     /**
  2517|      * Creates a WHERE clause by parsing given conditions data. If an array or string
  2518|      * conditions are provided those conditions will be parsed and quoted. If a boolean
  2519|      * is given it will be integer cast as condition. Null will return 1 = 1.
  2520|      *
  2521|      * Results of this method are stored in a memory cache. This improves performance, but
  2522|      * because the method uses a hashing algorithm it can have collisions.
  2523|      * Setting DboSource::$cacheMethods to false will disable the memory cache.
  2524|      *
  2525|      * @param mixed $conditions Array or string of conditions, or any value.
  2526|      * @param bool $quoteValues If true, values should be quoted
  2527|      * @param bool $where If true, "WHERE " will be prepended to the return value
  2528|      * @param Model $Model A reference to the Model instance making the query
  2529|      * @return string SQL fragment
  2530|      */
  2531|     public function conditions($conditions, $quoteValues = true, $where = true, Model $Model = null)
  2532|     {
  2533|         $clause = $out = '';
  2534|         if ($where) {
  2535|             $clause = ' WHERE ';
  2536|         }
  2537|         if (is_array($conditions) && !empty($conditions)) {
  2538|             $out = $this->conditionKeysToString($conditions, $quoteValues, $Model);
  2539|             if (empty($out)) {
  2540|                 return $clause . ' 1 = 1';
  2541|             }
  2542|             return $clause . implode(' AND ', $out);
  2543|         }
  2544|         if (is_bool($conditions)) {
  2545|             return $clause . (int)$conditions . ' = 1';
  2546|         }
  2547|         if (empty($conditions) || trim($conditions) === '') {
  2548|             return $clause . '1 = 1';
  2549|         }
  2550|         $clauses = '/^WHERE\\x20|^GROUP\\x20BY\\x20|^HAVING\\x20|^ORDER\\x20BY\\x20/i';
  2551|         if (preg_match($clauses, $conditions)) {
  2552|             $clause = '';
  2553|         }
  2554|         $conditions = $this->_quoteFields($conditions);
  2555|         return $clause . $conditions;
  2556|     }
  2557|     /**
  2558|      * Creates a WHERE clause by parsing given conditions array. Used by DboSource::conditions().
  2559|      *
  2560|      * @param array $conditions Array or string of conditions
  2561|      * @param bool $quoteValues If true, values should be quoted
  2562|      * @param Model $Model A reference to the Model instance making the query
  2563|      * @return string SQL fragment
  2564|      */
  2565|     public function conditionKeysToString($conditions, $quoteValues = true, Model $Model = null)
  2566|     {
  2567|         $out = [];
  2568|         $data = $columnType = null;
  2569|         foreach($conditions as $key => $value) {
  2570|             $join = ' AND ';
  2571|             $not = null;
  2572|             if (is_array($value)) {
  2573|                 $valueInsert = (
  2574|                     !empty($value) &&
  2575|                     (substr_count($key, '?') === count($value) || substr_count($key, ':') === count($value))
  2576|                 );
  2577|             }
  2578|             if (is_numeric($key) && empty($value)) {
  2579|                 continue;
  2580|             } elseif (is_numeric($key) && is_string($value)) {
  2581|                 $out[] = $this->_quoteFields($value);
  2582|             } elseif ((is_numeric($key) && is_array($value)) || in_array(strtolower(trim($key)), $this->_sqlBoolOps)) {
  2583|                 if (in_array(strtolower(trim($key)), $this->_sqlBoolOps)) {
  2584|                     $join = ' ' . strtoupper($key) . ' ';
  2585|                 } else {
  2586|                     $key = $join;
  2587|                 }
  2588|                 $value = $this->conditionKeysToString($value, $quoteValues, $Model);
  2589|                 if (strpos($join, 'NOT') !== false) {
  2590|                     if (strtoupper(trim($key)) === 'NOT') {
  2591|                         $key = 'AND ' . trim($key);
  2592|                     }
  2593|                     $not = 'NOT ';
  2594|                 }
  2595|                 if (empty($value)) {
  2596|                     continue;
  2597|                 }
  2598|                 if (empty($value[1])) {
  2599|                     if ($not) {
  2600|                         $out[] = $not . '(' . $value[0] . ')';
  2601|                     } else {
  2602|                         $out[] = $value[0];
  2603|                     }
  2604|                 } else {
  2605|                     $out[] = '(' . $not . '(' . implode(') ' . strtoupper($key) . ' (', $value) . '))';
  2606|                 }
  2607|             } else {
  2608|                 if (is_object($value) && isset($value->type)) {
  2609|                     if ($value->type === 'identifier') {
  2610|                         $data .= $this->name($key) . ' = ' . $this->name($value->value);
  2611|                     } elseif ($value->type === 'expression') {
  2612|                         if (is_numeric($key)) {
  2613|                             $data .= $value->value;
  2614|                         } else {
  2615|                             $data .= $this->name($key) . ' = ' . $value->value;
  2616|                         }
  2617|                     }
  2618|                 } elseif (is_array($value) && !empty($value) && !$valueInsert) {
  2619|                     $keys = array_keys($value);
  2620|                     if ($keys === array_values($keys)) {
  2621|                         if (count($value) === 1 && !preg_match('/\s+(?:NOT|IN|\!=)$/', $key)) {
  2622|                             $data = $this->_quoteFields($key) . ' = (';
  2623|                             if ($quoteValues) {
  2624|                                 if ($Model !== null) {
  2625|                                     $columnType = $Model->getColumnType($key);
  2626|                                 }
  2627|                                 $data .= implode(', ', $this->value($value, $columnType));
  2628|                             }
  2629|                             $data .= ')';
  2630|                         } else {
  2631|                             $data = $this->_parseKey($key, $value, $Model);
  2632|                         }
  2633|                     } else {
  2634|                         $ret = $this->conditionKeysToString($value, $quoteValues, $Model);
  2635|                         if (count($ret) > 1) {
  2636|                             $data = '(' . implode(') AND (', $ret) . ')';
  2637|                         } elseif (isset($ret[0])) {
  2638|                             $data = $ret[0];
  2639|                         }
  2640|                     }
  2641|                 } elseif (is_numeric($key) && !empty($value)) {
  2642|                     $data = $this->_quoteFields($value);
  2643|                 } else {
  2644|                     $data = $this->_parseKey(trim($key), $value, $Model);
  2645|                 }
  2646|                 if ($data) {
  2647|                     $out[] = $data;
  2648|                     $data = null;
  2649|                 }
  2650|             }
  2651|         }
  2652|         return $out;
  2653|     }
  2654|     /**
  2655|      * Extracts a Model.field identifier and an SQL condition operator from a string, formats
  2656|      * and inserts values, and composes them into an SQL snippet.
  2657|      *
  2658|      * @param string $key An SQL key snippet containing a field and optional SQL operator
  2659|      * @param mixed $value The value(s) to be inserted in the string
  2660|      * @param Model $Model Model object initiating the query
  2661|      * @return string
  2662|      */
  2663|     protected function _parseKey($key, $value, Model $Model = null)
  2664|     {
  2665|         $operatorMatch = '/^(((' . implode(')|(', $this->_sqlOps);
  2666|         $operatorMatch .= ')\\x20?)|<[>=]?(?![^>]+>)\\x20?|[>=!]{1,3}(?!<)\\x20?)/is';
  2667|         $bound = (strpos($key, '?') !== false || (is_array($value) && strpos($key, ':') !== false));
  2668|         $key = trim($key);
  2669|         if (strpos($key, ' ') === false) {
  2670|             $operator = '=';
  2671|         } else {
  2672|             [$key, $operator] = explode(' ', $key, 2);
  2673|             if (!preg_match($operatorMatch, trim($operator)) && strpos($operator, ' ') !== false) {
  2674|                 $key = $key . ' ' . $operator;
  2675|                 $split = strrpos($key, ' ');
  2676|                 $operator = substr($key, $split);
  2677|                 $key = substr($key, 0, $split);
  2678|             }
  2679|         }
  2680|         $virtual = false;
  2681|         $type = null;
  2682|         if ($Model !== null) {
  2683|             if ($Model->isVirtualField($key)) {
  2684|                 $virtualField = $Model->getVirtualField($key);
  2685|                 if (is_object($virtualField) && $virtualField->type == 'expression') {
  2686|                     $key = $virtualField->value;
  2687|                 } else {
  2688|                     $key = $this->_quoteFields($virtualField);
  2689|                 }
  2690|                 $virtual = true;
  2691|             }
  2692|             $type = $Model->getColumnType($key);
  2693|         }
  2694|         $null = $value === null || (is_array($value) && empty($value));
  2695|         if (strtolower($operator) === 'not') {
  2696|             $data = $this->conditionKeysToString(
  2697|                 [$operator => [$key => $value]], true, $Model
  2698|             );
  2699|             return $data[0];
  2700|         }
  2701|         $value = $this->value($value, $type);
  2702|         if (!$virtual && $key !== '?') {
  2703|             $isKey = (
  2704|                 strpos($key, '(') !== false ||
  2705|                 strpos($key, ')') !== false ||
  2706|                 strpos($key, '|') !== false ||
  2707|                 strpos($key, '->') !== false
  2708|             );
  2709|             $key = $isKey? $this->_quoteFields($key) : $this->name($key);
  2710|         }
  2711|         if ($bound) {
  2712|             return CakeText::insert($key . ' ' . trim($operator), $value);
  2713|         }
  2714|         if (!preg_match($operatorMatch, trim($operator))) {
  2715|             $operator .= is_array($value)? ' IN' : ' =';
  2716|         }
  2717|         $operator = trim($operator);
  2718|         if (is_array($value)) {
  2719|             $value = implode(', ', $value);
  2720|             switch($operator) {
  2721|                 case '=':
  2722|                     $operator = 'IN';
  2723|                     break;
  2724|                 case '!=':
  2725|                 case '<>':
  2726|                     $operator = 'NOT IN';
  2727|                     break;
  2728|             }
  2729|             $value = "({$value})";
  2730|         } elseif ($null || $value === 'NULL') {
  2731|             switch($operator) {
  2732|                 case '=':
  2733|                     $operator = 'IS';
  2734|                     break;
  2735|                 case '!=':
  2736|                 case '<>':
  2737|                     $operator = 'IS NOT';
  2738|                     break;
  2739|             }
  2740|         }
  2741|         if ($virtual) {
  2742|             return "({$key}) {$operator} {$value}";
  2743|         }
  2744|         return "{$key} {$operator} {$value}";
  2745|     }
  2746|     /**
  2747|      * Quotes Model.fields
  2748|      *
  2749|      * @param string $conditions The conditions to quote.
  2750|      * @return string or false if no match
  2751|      */
  2752|     protected function _quoteFields($conditions)
  2753|     {
  2754|         $start = $end = null;
  2755|         $original = $conditions;
  2756|         if (!empty($this->startQuote)) {
  2757|             $start = preg_quote($this->startQuote);
  2758|         }
  2759|         if (!empty($this->endQuote)) {
  2760|             $end = preg_quote($this->endQuote);
  2761|         }
  2762|         $conditions = str_replace([$start, $end], '', $conditions);
  2763|         $conditions = preg_replace_callback(
  2764|             '/(?:[\'\"][^\'\"\\\]*(?:\\\.[^\'\"\\\]*)*[\'\"])|([a-z0-9_][a-z0-9\\-_]*\\.[a-z0-9_][a-z0-9_\\-]*[a-z0-9_])|([a-z0-9_][a-z0-9_\\-]*)(?=->)/i',
  2765|             [&$this, '_quoteMatchedField'],
  2766|             $conditions
  2767|         );
  2768|         $conditions = preg_replace(
  2769|             '/(\s[a-z0-9\\-_.' . $start . $end . ']*' . $end . ')\s+AS\s+([a-z0-9\\-_]+)/i',
  2770|             '\1 AS ' . $this->startQuote . '\2' . $this->endQuote,
  2771|             $conditions
  2772|         );
  2773|         if ($conditions !== null) {
  2774|             return $conditions;
  2775|         }
  2776|         return $original;
  2777|     }
  2778|     /**
  2779|      * Auxiliary function to quote matches `Model.fields` from a preg_replace_callback call
  2780|      *
  2781|      * @param string $match matched string
  2782|      * @return string quoted string
  2783|      */
  2784|     protected function _quoteMatchedField($match)
  2785|     {
  2786|         if (is_numeric($match[0])) {
  2787|             return $match[0];
  2788|         }
  2789|         return $this->name($match[0]);
  2790|     }
  2791|     /**
  2792|      * Returns a limit statement in the correct format for the particular database.
  2793|      *
  2794|      * @param int $limit Limit of results returned
  2795|      * @param int $offset Offset from which to start results
  2796|      * @return string SQL limit/offset statement
  2797|      */
  2798|     public function limit($limit, $offset = null)
  2799|     {
  2800|         if ($limit) {
  2801|             $rt = ' LIMIT';
  2802|             if ($offset) {
  2803|                 $rt .= sprintf(' %u,', $offset);
  2804|             }
  2805|             $rt .= sprintf(' %u', $limit);
  2806|             return $rt;
  2807|         }
  2808|         return null;
  2809|     }
  2810|     /**
  2811|      * Returns an ORDER BY clause as a string.
  2812|      *
  2813|      * @param array|string $keys Field reference, as a key (i.e. Post.title)
  2814|      * @param string $direction Direction (ASC or DESC)
  2815|      * @param Model $Model Model reference (used to look for virtual field)
  2816|      * @return string ORDER BY clause
  2817|      */
  2818|     public function order($keys, $direction = 'ASC', Model $Model = null)
  2819|     {
  2820|         if (!is_array($keys)) {
  2821|             $keys = [$keys];
  2822|         }
  2823|         $keys = array_filter($keys);
  2824|         $result = [];
  2825|         while(!empty($keys)) {
  2826|             $key = key($keys);
  2827|             $dir = current($keys);
  2828|             array_shift($keys);
  2829|             if (is_numeric($key)) {
  2830|                 $key = $dir;
  2831|                 $dir = $direction;
  2832|             }
  2833|             if (is_string($key) && strpos($key, ',') !== false && !preg_match('/\(.+\,.+\)/', $key)) {
  2834|                 $key = array_map('trim', explode(',', $key));
  2835|             }
  2836|             if (is_array($key)) {
  2837|                 $key = array_reverse($key, true);
  2838|                 foreach($key as $k => $v) {
  2839|                     if (is_numeric($k)) {
  2840|                         array_unshift($keys, $v);
  2841|                     } else {
  2842|                         $keys = [$k => $v] + $keys;
  2843|                     }
  2844|                 }
  2845|                 continue;
  2846|             } elseif (is_object($key) && isset($key->type) && $key->type === 'expression') {
  2847|                 $result[] = $key->value;
  2848|                 continue;
  2849|             }
  2850|             if (preg_match('/\\x20(ASC|DESC).*/i', $key, $_dir)) {
  2851|                 $dir = $_dir[0];
  2852|                 $key = preg_replace('/\\x20(ASC|DESC).*/i', '', $key);
  2853|             }
  2854|             $key = trim($key);
  2855|             if ($Model !== null) {
  2856|                 if ($Model->isVirtualField($key)) {
  2857|                     $key = '(' . $this->_quoteFields($Model->getVirtualField($key)) . ')';
  2858|                 }
  2859|                 [$alias] = pluginSplit($key);
  2860|                 if ($alias !== $Model->alias && is_object($Model->{$alias}) && $Model->{$alias}->isVirtualField($key)) {
  2861|                     $key = '(' . $this->_quoteFields($Model->{$alias}->getVirtualField($key)) . ')';
  2862|                 }
  2863|             }
  2864|             if (strpos($key, '.')) {
  2865|                 $key = preg_replace_callback('/([a-zA-Z0-9_-]{1,})\\.([a-zA-Z0-9_-]{1,})/', [&$this, '_quoteMatchedField'], $key);
  2866|             }
  2867|             if (!preg_match('/\s/', $key) && strpos($key, '.') === false) {
  2868|                 $key = $this->name($key);
  2869|             }
  2870|             $key .= ' ' . trim($dir);
  2871|             $result[] = $key;
  2872|         }
  2873|         if (!empty($result)) {
  2874|             return ' ORDER BY ' . implode(', ', $result);
  2875|         }
  2876|         return '';
  2877|     }
  2878|     /**
  2879|      * Create a GROUP BY SQL clause.
  2880|      *
  2881|      * @param string|array $fields Group By fields
  2882|      * @param Model $Model The model to get group by fields for.
  2883|      * @return string Group By clause or null.
  2884|      */
  2885|     public function group($fields, Model $Model = null)
  2886|     {
  2887|         if (empty($fields)) {
  2888|             return null;
  2889|         }
  2890|         if (!is_array($fields)) {
  2891|             $fields = [$fields];
  2892|         }
  2893|         if ($Model !== null) {
  2894|             foreach($fields as $index => $key) {
  2895|                 if ($Model->isVirtualField($key)) {
  2896|                     $fields[$index] = '(' . $Model->getVirtualField($key) . ')';
  2897|                 }
  2898|             }
  2899|         }
  2900|         $fields = implode(', ', $fields);
  2901|         return ' GROUP BY ' . $this->_quoteFields($fields);
  2902|     }
  2903|     /**
  2904|      * Create a HAVING SQL clause.
  2905|      *
  2906|      * @param mixed $fields Array or string of conditions
  2907|      * @param bool $quoteValues If true, values should be quoted
  2908|      * @param Model $Model A reference to the Model instance making the query
  2909|      * @return string|null HAVING clause or null
  2910|      */
  2911|     public function having($fields, $quoteValues = true, Model $Model = null)
  2912|     {
  2913|         if (!$fields) {
  2914|             return null;
  2915|         }
  2916|         return ' HAVING ' . $this->conditions($fields, $quoteValues, false, $Model);
  2917|     }
  2918|     /**
  2919|      * Returns a locking hint for the given mode.
  2920|      *
  2921|      * Currently, this method only returns FOR UPDATE when the mode is set to true.
  2922|      *
  2923|      * @param mixed $mode Lock mode
  2924|      * @return string|null FOR UPDATE clause or null
  2925|      */
  2926|     public function getLockingHint($mode)
  2927|     {
  2928|         if ($mode !== true) {
  2929|             return null;
  2930|         }
  2931|         return ' FOR UPDATE';
  2932|     }
  2933|     /**
  2934|      * Disconnects database, kills the connection and says the connection is closed.
  2935|      *
  2936|      * @return void
  2937|      */
  2938|     public function close()
  2939|     {
  2940|         $this->disconnect();
  2941|     }
  2942|     /**
  2943|      * Checks if the specified table contains any record matching specified SQL
  2944|      *
  2945|      * @param Model $Model Model to search
  2946|      * @param string $sql SQL WHERE clause (condition only, not the "WHERE" part)
  2947|      * @return bool True if the table has a matching record, else false
  2948|      */
  2949|     public function hasAny(Model $Model, $sql)
  2950|     {
  2951|         $sql = $this->conditions($sql);
  2952|         $table = $this->fullTableName($Model);
  2953|         $alias = $this->alias . $this->name($Model->alias);
  2954|         $where = $sql? "{$sql}" : ' WHERE 1 = 1';
  2955|         $id = $Model->escapeField();
  2956|         $out = $this->fetchRow("SELECT COUNT({$id}) {$this->alias}count FROM {$table} {$alias}{$where}");
  2957|         if (is_array($out)) {
  2958|             return $out[0]['count'];
  2959|         }
  2960|         return false;
  2961|     }
  2962|     /**
  2963|      * Gets the length of a database-native column description, or null if no length
  2964|      *
  2965|      * @param string $real Real database-layer column type (i.e. "varchar(255)")
  2966|      * @return mixed An integer or string representing the length of the column, or null for unknown length.
  2967|      */
  2968|     public function length($real)
  2969|     {
  2970|         preg_match('/([\w\s]+)(?:\((.+?)\))?(\sunsigned)?/i', $real, $result);
  2971|         $types = [
  2972|             'int' => 1, 'tinyint' => 1, 'smallint' => 1, 'mediumint' => 1, 'integer' => 1, 'bigint' => 1
  2973|         ];
  2974|         $type = $length = null;
  2975|         if (isset($result[1])) {
  2976|             $type = $result[1];
  2977|         }
  2978|         if (isset($result[2])) {
  2979|             $length = $result[2];
  2980|         }
  2981|         $sign = isset($result[3]);
  2982|         $isFloat = in_array($type, ['dec', 'decimal', 'float', 'numeric', 'double']);
  2983|         if ($isFloat && strpos($length, ',') !== false) {
  2984|             return $length;
  2985|         }
  2986|         if ($length === null) {
  2987|             return null;
  2988|         }
  2989|         if (isset($types[$type])) {
  2990|             return (int)$length;
  2991|         }
  2992|         if (in_array($type, ['enum', 'set'])) {
  2993|             return null;
  2994|         }
  2995|         return (int)$length;
  2996|     }
  2997|     /**
  2998|      * Translates between PHP boolean values and Database (faked) boolean values
  2999|      *
  3000|      * @param mixed $data Value to be translated
  3001|      * @param bool $quote Whether or not the field should be cast to a string.
  3002|      * @return string|bool Converted boolean value
  3003|      */
  3004|     public function boolean($data, $quote = false)
  3005|     {
  3006|         if ($quote) {
  3007|             return !empty($data)? '1' : '0';
  3008|         }
  3009|         return !empty($data);
  3010|     }
  3011|     /**
  3012|      * Inserts multiple values into a table
  3013|      *
  3014|      * @param string $table The table being inserted into.
  3015|      * @param array $fields The array of field/column names being inserted.
  3016|      * @param array $values The array of values to insert. The values should
  3017|      *   be an array of rows. Each row should have values keyed by the column name.
  3018|      *   Each row must have the values in the same order as $fields.
  3019|      * @return bool
  3020|      */
  3021|     public function insertMulti($table, $fields, $values)
  3022|     {
  3023|         $table = $this->fullTableName($table);
  3024|         $holder = implode(',', array_fill(0, count($fields), '?'));
  3025|         $fields = implode(', ', array_map([&$this, 'name'], $fields));
  3026|         $pdoMap = [
  3027|             'integer' => PDO::PARAM_INT,
  3028|             'float' => PDO::PARAM_STR,
  3029|             'boolean' => PDO::PARAM_BOOL,
  3030|             'string' => PDO::PARAM_STR,
  3031|             'text' => PDO::PARAM_STR
  3032|         ];
  3033|         $columnMap = [];
  3034|         $sql = "INSERT INTO {$table} ({$fields}) VALUES ({$holder})";
  3035|         $statement = $this->_connection->prepare($sql);
  3036|         $this->begin();
  3037|         foreach($values[key($values)] as $key => $val) {
  3038|             $type = $this->introspectType($val);
  3039|             $columnMap[$key] = $pdoMap[$type];
  3040|         }
  3041|         foreach($values as $value) {
  3042|             $i = 1;
  3043|             foreach($value as $col => $val) {
  3044|                 $statement->bindValue($i, $val, $columnMap[$col]);
  3045|                 $i += 1;
  3046|             }
  3047|             $t = microtime(true);
  3048|             $statement->execute();
  3049|             $statement->closeCursor();
  3050|             if ($this->fullDebug) {
  3051|                 $this->took = round((microtime(true) - $t) * 1000, 0);
  3052|                 $this->numRows = $this->affected = $statement->rowCount();
  3053|                 $this->logQuery($sql, $value);
  3054|             }
  3055|         }
  3056|         return $this->commit();
  3057|     }
  3058|     /**
  3059|      * Reset a sequence based on the MAX() value of $column. Useful
  3060|      * for resetting sequences after using insertMulti().
  3061|      *
  3062|      * This method should be implemented by datasources that require sequences to be used.
  3063|      *
  3064|      * @param string $table The name of the table to update.
  3065|      * @param string $column The column to use when resetting the sequence value.
  3066|      * @return bool Success.
  3067|      */
  3068|     public function resetSequence($table, $column)
  3069|     {
  3070|     }
  3071|     /**
  3072|      * Returns an array of the indexes in given datasource name.
  3073|      *
  3074|      * @param string $model Name of model to inspect
  3075|      * @return array Fields in table. Keys are column and unique
  3076|      */
  3077|     public function index($model)
  3078|     {
  3079|         return [];
  3080|     }
  3081|     /**
  3082|      * Generate a database-native schema for the given Schema object
  3083|      *
  3084|      * @param CakeSchema $schema An instance of a subclass of CakeSchema
  3085|      * @param string $tableName Optional. If specified only the table name given will be generated.
  3086|      *   Otherwise, all tables defined in the schema are generated.
  3087|      * @return string
  3088|      */
  3089|     public function createSchema($schema, $tableName = null)
  3090|     {
  3091|         if (!$schema instanceof CakeSchema) {
  3092|             trigger_error(__d('cake_dev', 'Invalid schema object'), E_USER_WARNING);
  3093|             return null;
  3094|         }
  3095|         $out = '';
  3096|         foreach($schema->tables as $curTable => $columns) {
  3097|             if (!$tableName || $tableName === $curTable) {
  3098|                 $cols = $indexes = $tableParameters = [];
  3099|                 $primary = null;
  3100|                 $table = $this->fullTableName($curTable);
  3101|                 $primaryCount = 0;
  3102|                 foreach($columns as $col) {
  3103|                     if (isset($col['key']) && $col['key'] === 'primary') {
  3104|                         $primaryCount++;
  3105|                     }
  3106|                 }
  3107|                 foreach($columns as $name => $col) {
  3108|                     if (is_string($col)) {
  3109|                         $col = ['type' => $col];
  3110|                     }
  3111|                     $isPrimary = isset($col['key']) && $col['key'] === 'primary';
  3112|                     if ($isPrimary && $primaryCount > 1) {
  3113|                         unset($col['key']);
  3114|                         $isPrimary = false;
  3115|                     }
  3116|                     if ($isPrimary) {
  3117|                         $primary = $name;
  3118|                     }
  3119|                     if ($name !== 'indexes' && $name !== 'tableParameters') {
  3120|                         $col['name'] = $name;
  3121|                         if (!isset($col['type'])) {
  3122|                             $col['type'] = 'string';
  3123|                         }
  3124|                         $cols[] = $this->buildColumn($col);
  3125|                     } elseif ($name === 'indexes') {
  3126|                         $indexes = array_merge($indexes, $this->buildIndex($col, $table));
  3127|                     } elseif ($name === 'tableParameters') {
  3128|                         $tableParameters = array_merge($tableParameters, $this->buildTableParameters($col, $table));
  3129|                     }
  3130|                 }
  3131|                 if (!isset($columns['indexes']['PRIMARY']) && !empty($primary)) {
  3132|                     $col = ['PRIMARY' => ['column' => $primary, 'unique' => 1]];
  3133|                     $indexes = array_merge($indexes, $this->buildIndex($col, $table));
  3134|                 }
  3135|                 $columns = $cols;
  3136|                 $out .= $this->renderStatement('schema', compact('table', 'columns', 'indexes', 'tableParameters')) . "\n\n";
  3137|             }
  3138|         }
  3139|         return $out;
  3140|     }
  3141|     /**
  3142|      * Generate an alter syntax from CakeSchema::compare()
  3143|      *
  3144|      * @param mixed $compare The comparison data.
  3145|      * @param string $table The table name.
  3146|      * @return bool
  3147|      */
  3148|     public function alterSchema($compare, $table = null)
  3149|     {
  3150|         return false;
  3151|     }
  3152|     /**
  3153|      * Generate a "drop table" statement for the given Schema object
  3154|      *
  3155|      * @param CakeSchema $schema An instance of a subclass of CakeSchema
  3156|      * @param string $table Optional. If specified only the table name given will be generated.
  3157|      *   Otherwise, all tables defined in the schema are generated.
  3158|      * @return string
  3159|      */
  3160|     public function dropSchema(CakeSchema $schema, $table = null)
  3161|     {
  3162|         $out = '';
  3163|         if ($table && array_key_exists($table, $schema->tables)) {
  3164|             return $this->_dropTable($table) . "\n";
  3165|         } elseif ($table) {
  3166|             return $out;
  3167|         }
  3168|         foreach(array_keys($schema->tables) as $curTable) {
  3169|             $out .= $this->_dropTable($curTable) . "\n";
  3170|         }
  3171|         return $out;
  3172|     }
  3173|     /**
  3174|      * Generate a "drop table" statement for a single table
  3175|      *
  3176|      * @param type $table Name of the table to drop
  3177|      * @return string Drop table SQL statement
  3178|      */
  3179|     protected function _dropTable($table)
  3180|     {
  3181|         return 'DROP TABLE ' . $this->fullTableName($table) . ";";
  3182|     }
  3183|     /**
  3184|      * Generate a database-native column schema string
  3185|      *
  3186|      * @param array $column An array structured like the following: array('name' => 'value', 'type' => 'value'[, options]),
  3187|      *   where options can be 'default', 'length', or 'key'.
  3188|      * @return string
  3189|      */
  3190|     public function buildColumn($column)
  3191|     {
  3192|         $name = $type = null;
  3193|         extract(array_merge(['null' => true], $column));
  3194|         if (empty($name) || empty($type)) {
  3195|             trigger_error(__d('cake_dev', 'Column name or type not defined in schema'), E_USER_WARNING);
  3196|             return null;
  3197|         }
  3198|         if (!isset($this->columns[$type]) && substr($type, 0, 4) !== 'enum') {
  3199|             trigger_error(__d('cake_dev', 'Column type %s does not exist', $type), E_USER_WARNING);
  3200|             return null;
  3201|         }
  3202|         if (substr($type, 0, 4) === 'enum') {
  3203|             $out = $this->name($name) . ' ' . $type;
  3204|         } else {
  3205|             $real = $this->columns[$type];
  3206|             $out = $this->name($name) . ' ' . $real['name'];
  3207|             if (isset($column['length'])) {
  3208|                 $length = $column['length'];
  3209|             } elseif (isset($column['limit'])) {
  3210|                 $length = $column['limit'];
  3211|             } elseif (isset($real['length'])) {
  3212|                 $length = $real['length'];
  3213|             } elseif (isset($real['limit'])) {
  3214|                 $length = $real['limit'];
  3215|             }
  3216|             if (isset($length)) {
  3217|                 $out .= '(' . $length . ')';
  3218|             }
  3219|         }
  3220|         if (($column['type'] === 'integer' || $column['type'] === 'float') && isset($column['default']) && $column['default'] === '') {
  3221|             $column['default'] = null;
  3222|         }
  3223|         $out = $this->_buildFieldParameters($out, $column, 'beforeDefault');
  3224|         if (isset($column['key']) && $column['key'] === 'primary' && ($type === 'integer' || $type === 'biginteger')) {
  3225|             $out .= ' ' . $this->columns['primary_key']['name'];
  3226|         } elseif (isset($column['key']) && $column['key'] === 'primary') {
  3227|             $out .= ' NOT NULL';
  3228|         } elseif (isset($column['default']) && isset($column['null']) && $column['null'] === false) {
  3229|             $out .= ' DEFAULT ' . $this->value($column['default'], $type) . ' NOT NULL';
  3230|         } elseif (isset($column['default'])) {
  3231|             $out .= ' DEFAULT ' . $this->value($column['default'], $type);
  3232|         } elseif ($type !== 'timestamp' && !empty($column['null'])) {
  3233|             $out .= ' DEFAULT NULL';
  3234|         } elseif ($type === 'timestamp' && !empty($column['null'])) {
  3235|             $out .= ' NULL';
  3236|         } elseif (isset($column['null']) && $column['null'] === false) {
  3237|             $out .= ' NOT NULL';
  3238|         }
  3239|         if (in_array($type, ['timestamp', 'datetime']) && isset($column['default']) && strtolower($column['default']) === 'current_timestamp') {
  3240|             $out = str_replace(["'CURRENT_TIMESTAMP'", "'current_timestamp'"], 'CURRENT_TIMESTAMP', $out);
  3241|         }
  3242|         return $this->_buildFieldParameters($out, $column, 'afterDefault');
  3243|     }
  3244|     /**
  3245|      * Build the field parameters, in a position
  3246|      *
  3247|      * @param string $columnString The partially built column string
  3248|      * @param array $columnData The array of column data.
  3249|      * @param string $position The position type to use. 'beforeDefault' or 'afterDefault' are common
  3250|      * @return string a built column with the field parameters added.
  3251|      */
  3252|     protected function _buildFieldParameters($columnString, $columnData, $position)
  3253|     {
  3254|         foreach($this->fieldParameters as $paramName => $value) {
  3255|             if (isset($columnData[$paramName]) && $value['position'] == $position) {
  3256|                 if (isset($value['options']) && !in_array($columnData[$paramName], $value['options'], true)) {
  3257|                     continue;
  3258|                 }
  3259|                 if (isset($value['types']) && !in_array($columnData['type'], $value['types'], true)) {
  3260|                     continue;
  3261|                 }
  3262|                 $val = $columnData[$paramName];
  3263|                 if ($value['quote']) {
  3264|                     $val = $this->value($val);
  3265|                 }
  3266|                 $columnString .= ' ' . $value['value'] . (empty($value['noVal'])? $value['join'] . $val : '');
  3267|             }
  3268|         }
  3269|         return $columnString;
  3270|     }
  3271|     /**
  3272|      * Format indexes for create table.
  3273|      *
  3274|      * @param array $indexes The indexes to build
  3275|      * @param string $table The table name.
  3276|      * @return array
  3277|      */
  3278|     public function buildIndex($indexes, $table = null)
  3279|     {
  3280|         $join = [];
  3281|         foreach($indexes as $name => $value) {
  3282|             $out = '';
  3283|             if ($name === 'PRIMARY') {
  3284|                 $out .= 'PRIMARY ';
  3285|                 $name = null;
  3286|             } else {
  3287|                 if (!empty($value['unique'])) {
  3288|                     $out .= 'UNIQUE ';
  3289|                 }
  3290|                 $name = $this->startQuote . $name . $this->endQuote;
  3291|             }
  3292|             if (is_array($value['column'])) {
  3293|                 $out .= 'KEY ' . $name . ' (' . implode(', ', array_map([&$this, 'name'], $value['column'])) . ')';
  3294|             } else {
  3295|                 $out .= 'KEY ' . $name . ' (' . $this->name($value['column']) . ')';
  3296|             }
  3297|             $join[] = $out;
  3298|         }
  3299|         return $join;
  3300|     }
  3301|     /**
  3302|      * Read additional table parameters
  3303|      *
  3304|      * @param string $name The table name to read.
  3305|      * @return array
  3306|      */
  3307|     public function readTableParameters($name)
  3308|     {
  3309|         $parameters = [];
  3310|         if (method_exists($this, 'listDetailedSources')) {
  3311|             $currentTableDetails = $this->listDetailedSources($name);
  3312|             foreach($this->tableParameters as $paramName => $parameter) {
  3313|                 if (!empty($parameter['column']) && !empty($currentTableDetails[$parameter['column']])) {
  3314|                     $parameters[$paramName] = $currentTableDetails[$parameter['column']];
  3315|                 }
  3316|             }
  3317|         }
  3318|         return $parameters;
  3319|     }
  3320|     /**
  3321|      * Format parameters for create table
  3322|      *
  3323|      * @param array $parameters The parameters to create SQL for.
  3324|      * @param string $table The table name.
  3325|      * @return array
  3326|      */
  3327|     public function buildTableParameters($parameters, $table = null)
  3328|     {
  3329|         $result = [];
  3330|         foreach($parameters as $name => $value) {
  3331|             if (isset($this->tableParameters[$name])) {
  3332|                 if ($this->tableParameters[$name]['quote']) {
  3333|                     $value = $this->value($value);
  3334|                 }
  3335|                 $result[] = $this->tableParameters[$name]['value'] . $this->tableParameters[$name]['join'] . $value;
  3336|             }
  3337|         }
  3338|         return $result;
  3339|     }
  3340|     /**
  3341|      * Guesses the data type of an array
  3342|      *
  3343|      * @param string $value The value to introspect for type data.
  3344|      * @return string
  3345|      */
  3346|     public function introspectType($value)
  3347|     {
  3348|         if (!is_array($value)) {
  3349|             if (is_bool($value)) {
  3350|                 return 'boolean';
  3351|             }
  3352|             if (is_float($value) && (float)$value === $value) {
  3353|                 return 'float';
  3354|             }
  3355|             if (is_int($value) && (int)$value === $value) {
  3356|                 return 'integer';
  3357|             }
  3358|             if (is_string($value) && strlen($value) > 255) {
  3359|                 return 'text';
  3360|             }
  3361|             return 'string';
  3362|         }
  3363|         $isAllFloat = $isAllInt = true;
  3364|         $containsInt = $containsString = false;
  3365|         foreach($value as $valElement) {
  3366|             $valElement = trim($valElement);
  3367|             if (!is_float($valElement) && !preg_match('/^[\d]+\.[\d]+$/', $valElement)) {
  3368|                 $isAllFloat = false;
  3369|             } else {
  3370|                 continue;
  3371|             }
  3372|             if (!is_int($valElement) && !preg_match('/^[\d]+$/', $valElement)) {
  3373|                 $isAllInt = false;
  3374|             } else {
  3375|                 $containsInt = true;
  3376|                 continue;
  3377|             }
  3378|             $containsString = true;
  3379|         }
  3380|         if ($isAllFloat) {
  3381|             return 'float';
  3382|         }
  3383|         if ($isAllInt) {
  3384|             return 'integer';
  3385|         }
  3386|         if ($containsInt && !$containsString) {
  3387|             return 'integer';
  3388|         }
  3389|         return 'string';
  3390|     }
  3391|     /**
  3392|      * Empties the query caches.
  3393|      *
  3394|      * @return void
  3395|      */
  3396|     public function flushQueryCache()
  3397|     {
  3398|         $this->_queryCache = [];
  3399|     }
  3400|     /**
  3401|      * Writes a new key for the in memory sql query cache
  3402|      *
  3403|      * @param string $sql SQL query
  3404|      * @param mixed $data result of $sql query
  3405|      * @param array $params query params bound as values
  3406|      * @return void
  3407|      */
  3408|     protected function _writeQueryCache($sql, $data, $params = [])
  3409|     {
  3410|         if (preg_match('/^\s*select/i', $sql)) {
  3411|             $this->_queryCache[$sql][serialize($params)] = $data;
  3412|         }
  3413|     }
  3414|     /**
  3415|      * Returns the result for a sql query if it is already cached
  3416|      *
  3417|      * @param string $sql SQL query
  3418|      * @param array $params query params bound as values
  3419|      * @return mixed results for query if it is cached, false otherwise
  3420|      */
  3421|     public function getQueryCache($sql, $params = [])
  3422|     {
  3423|         if (isset($this->_queryCache[$sql]) && preg_match('/^\s*select/i', $sql)) {
  3424|             $serialized = serialize($params);
  3425|             if (isset($this->_queryCache[$sql][$serialized])) {
  3426|                 return $this->_queryCache[$sql][$serialized];
  3427|             }
  3428|         }
  3429|         return false;
  3430|     }
  3431|     /**
  3432|      * Used for storing in cache the results of the in-memory methodCache
  3433|      */
  3434|     public function __destruct()
  3435|     {
  3436|         if ($this->_methodCacheChange) {
  3437|             Cache::write('method_cache', static::$methodCache, '_cake_core_');
  3438|         }
  3439|         parent::__destruct();
  3440|     }
  3441|     /**
  3442|      * スキーマファイルを利用してテーブルを生成する
  3443|      *
  3444|      * @param array $options path は必須
  3445|      * @param pass $path
  3446|      * @return boolean
  3447|      */
  3448|     public function loadSchema($options)
  3449|     {
  3450|         App::uses('CakeSchema', 'Model');
  3451|         $options = array_merge([
  3452|             'dropField' => true,
  3453|             'oldSchemaPath' => ''
  3454|         ], $options);
  3455|         extract($options);
  3456|         if (!isset($type)) {
  3457|             return false;
  3458|         }
  3459|         if (!isset($file)) {
  3460|             if (isset($table)) {
  3461|                 $file = $table . '.php';
  3462|             } elseif (isset($model)) {
  3463|                 $file = Inflector::tableize($model) . '.php';
  3464|             } elseif (isset($name)) {
  3465|                 $file = Inflector::underscore($name) . '.php';
  3466|             } else {
  3467|                 return false;
  3468|             }
  3469|         }
  3470|         if (!isset($name)) {
  3471|             if (isset($table)) {
  3472|                 $name = Inflector::camelize($table);
  3473|             } elseif (isset($model)) {
  3474|                 $name = Inflector::pluralize($model);
  3475|             } elseif (isset($file)) {
  3476|                 $name = basename(Inflector::classify($file), '.php');
  3477|             } else {
  3478|                 return false;
  3479|             }
  3480|         }
  3481|         switch($type) {
  3482|             case 'create':
  3483|                 try {
  3484|                     $result = $this->createTableBySchema(['path' => $path . $file]);
  3485|                 } catch (Exception $e) {
  3486|                     $this->log($e->getMessage());
  3487|                     $result = false;
  3488|                 }
  3489|                 return $result;
  3490|                 break;
  3491|             case 'alter':
  3492|                 if (!$oldSchemaPath) {
  3493|                     $current = $path . basename($file, '.php') . '_current.php';
  3494|                     if (!$this->writeCurrentSchema($current)) {
  3495|                         return false;
  3496|                     }
  3497|                 } else {
  3498|                     $current = $oldSchemaPath;
  3499|                 }
  3500|                 try {
  3501|                     $result = $this->alterTableBySchema(['oldPath' => $current, 'newPath' => $path . $file, 'dropField' => $dropField]);
  3502|                 } catch (Exception $e) {
  3503|                     $this->log($e->getMessage());
  3504|                     $result = false;
  3505|                 }
  3506|                 if (!$oldSchemaPath) {
  3507|                     unlink($current);
  3508|                 }
  3509|                 return $result;
  3510|                 break;
  3511|             case 'drop':
  3512|                 try {
  3513|                     $result = $this->dropTableBySchema(['path' => $path . $file]);
  3514|                 } catch (Exception $e) {
  3515|                     $this->log($e->getMessage());
  3516|                     $result = false;
  3517|                 }
  3518|                 return $result;
  3519|                 break;
  3520|         }
  3521|         return false;
  3522|     }
  3523|     /**
  3524|      * 現在の接続のスキーマを生成する
  3525|      *
  3526|      * @param string $filename 保存先のフルパス
  3527|      * @return boolean
  3528|      */
  3529|     public function writeCurrentSchema($filename)
  3530|     {
  3531|         $this->cacheSources = false;
  3532|         $file = basename($filename);
  3533|         $path = dirname($filename);
  3534|         $name = basename(Inflector::classify(basename($file)), '.php');
  3535|         $Schema = ClassRegistry::init('CakeSchema');
  3536|         $Schema->connection = $this->configKeyName;
  3537|         if (empty($path)) {
  3538|             $path = $Schema->path;
  3539|         }
  3540|         $tables = $this->listSources();
  3541|         $models = [];
  3542|         $tableList = getTableList();
  3543|         foreach($tables as $table) {
  3544|             if ((!empty($tableList['core']) && in_array($table, $tableList['core'])) || (!empty($tableList['plugin']) && in_array($table, $tableList['plugin']))) {
  3545|                 $models[] = Inflector::classify(Inflector::singularize(str_replace($this->config['prefix'], '', $table)));
  3546|             }
  3547|         }
  3548|         return $this->writeSchema(['name' => $name, 'model' => $models, 'path' => $path, 'file' => $file]);
  3549|     }
  3550|     /**
  3551|      * スキーマファイルからテーブルを生成する
  3552|      *
  3553|      * @param array $options [ path ]
  3554|      * @return boolean
  3555|      */
  3556|     public function createTableBySchema($options)
  3557|     {
  3558|         extract($options);
  3559|         if (!isset($path)) {
  3560|             return false;
  3561|         }
  3562|         $dir = dirname($path);
  3563|         $file = basename($path);
  3564|         if (!isset($name)) {
  3565|             $name = basename(Inflector::classify($file), '.php');
  3566|         }
  3567|         $CakeSchema = ClassRegistry::init('CakeSchema');
  3568|         $CakeSchema->connection = $this->configKeyName;
  3569|         $schema = $CakeSchema->load(['name' => $name, 'path' => $dir, 'file' => $file]);
  3570|         if (!$schema) {
  3571|             return false;
  3572|         }
  3573|         return $this->createTable(['schema' => $schema]);
  3574|     }
  3575|     /**
  3576|      * スキーマファイルからテーブル構造を変更する
  3577|      *
  3578|      * @param array $options [ oldPath / newPath ]
  3579|      * @return boolean
  3580|      */
  3581|     public function alterTableBySchema($options)
  3582|     {
  3583|         $options = array_merge(['dropField' => true], $options);
  3584|         extract($options);
  3585|         if (!isset($oldPath) || !isset($newPath)) {
  3586|             return false;
  3587|         }
  3588|         $oldDir = dirname($oldPath);
  3589|         $newDir = dirname($newPath);
  3590|         $oldFile = basename($oldPath);
  3591|         $newFile = basename($newPath);
  3592|         if (!isset($oldName)) {
  3593|             $oldName = basename(Inflector::classify($oldFile), '.php');
  3594|         }
  3595|         if (!isset($newName)) {
  3596|             $newName = basename(Inflector::classify($newFile), '.php');
  3597|         }
  3598|         $Schema = ClassRegistry::init('CakeSchema');
  3599|         $Schema->connection = $this->configKeyName;
  3600|         $old = $Schema->load(['name' => $oldName, 'path' => $oldDir, 'file' => $oldFile]);
  3601|         $new = $Schema->load(['name' => $newName, 'path' => $newDir, 'file' => $newFile]);
  3602|         if (!$old || !$new) {
  3603|             return false;
  3604|         }
  3605|         return $this->alterTable(['old' => $old, 'new' => $new, 'dropField' => $dropField]);
  3606|     }
  3607|     /**
  3608|      * スキーマファイルからテーブルを削除する
  3609|      *
  3610|      * @param string $oldName
  3611|      * @param string $newName
  3612|      * @return boolean
  3613|      */
  3614|     public function dropTableBySchema($options)
  3615|     {
  3616|         extract($options);
  3617|         if (!isset($path)) {
  3618|             return false;
  3619|         }
  3620|         $dir = dirname($path);
  3621|         $file = basename($path);
  3622|         if (!isset($name)) {
  3623|             $name = basename(Inflector::classify($file), '.php');
  3624|         }
  3625|         $CakeSchema = ClassRegistry::init('CakeSchema');
  3626|         $CakeSchema->connection = $this->configKeyName;
  3627|         $schema = $CakeSchema->load(['name' => $name, 'path' => $dir, 'file' => $file]);
  3628|         return $this->dropTable(['schema' => $schema]);
  3629|     }
  3630|     /**
  3631|      * テーブルを作成する
  3632|      *
  3633|      * @param array $options [ schema / table ]
  3634|      * @return boolean
  3635|      */
  3636|     public function createTable($options)
  3637|     {
  3638|         extract($options);
  3639|         if (!isset($schema)) {
  3640|             return false;
  3641|         }
  3642|         if (is_array($schema)) {
  3643|             if (empty($table)) {
  3644|                 return false;
  3645|             }
  3646|             $name = Inflector::pluralize(Inflector::classify($table));
  3647|             $options = ['name' => $name,
  3648|                 'connection' => $this->configKeyName,
  3649|                 $table => $schema];
  3650|             $schema = new CakeSchema($options);
  3651|         }
  3652|         $return = true;
  3653|         if ($schema) {
  3654|             $sql = $this->createSchema($schema);
  3655|             if ($return = $this->execute($sql)) {
  3656|                 if (method_exists($schema, 'after')) {
  3657|                     $schema->after(['create' => strtolower($schema->name), 'errors' => null]);
  3658|                 }
  3659|             }
  3660|         }
  3661|         clearCache(null, 'models');
  3662|         return $return;
  3663|     }
  3664|     /**
  3665|      * テーブル構造を変更する
  3666|      *
  3667|      * @param array $options [ new / old ]
  3668|      * @return boolean
  3669|      */
  3670|     public function alterTable($options)
  3671|     {
  3672|         $options = array_merge(['dropField' => true], $options);
  3673|         extract($options);
  3674|         if (!isset($old) || !isset($new)) {
  3675|             return false;
  3676|         }
  3677|         $Schema = ClassRegistry::init('CakeSchema');
  3678|         $Schema->connection = $this->configKeyName;
  3679|         $compare = $Schema->compare($old, $new);
  3680|         if (!$dropField) {
  3681|             foreach($compare as $table => $alter) {
  3682|                 foreach($alter as $method => $field) {
  3683|                     if ($method == 'drop') {
  3684|                         unset($compare[$table]['drop']);
  3685|                         break;
  3686|                     }
  3687|                 }
  3688|             }
  3689|         }
  3690|         $sql = $this->alterSchema($compare);
  3691|         if ($sql) {
  3692|             $return = $this->execute($sql);
  3693|             clearCache(null, 'models');
  3694|             return $return;
  3695|         } else {
  3696|             return false;
  3697|         }
  3698|     }
  3699|     /**
  3700|      * テーブルを削除する
  3701|      *
  3702|      * @param array $options [ schema / table ]
  3703|      * @return boolean
  3704|      */
  3705|     public function dropTable($options)
  3706|     {
  3707|         extract($options);
  3708|         if (!isset($schema) && !isset($table)) {
  3709|             return false;
  3710|         }
  3711|         if (!isset($schema)) {
  3712|             $schema = $this->readSchema($table);
  3713|             if (isset($schema['tables'][$table])) {
  3714|                 $schema = $schema['tables'][$table];
  3715|             } else {
  3716|                 return false;
  3717|             }
  3718|         }
  3719|         if (is_array($schema)) {
  3720|             $name = Inflector::pluralize(Inflector::classify($table));
  3721|             $options = ['name' => $name,
  3722|                 'connection' => $this->configKeyName,
  3723|                 $table => $schema];
  3724|             $schema = new CakeSchema($options);
  3725|         }
  3726|         $return = true;
  3727|         if ($schema) {
  3728|             $cr = ClassRegistry::getInstance();
  3729|             $sql = $this->dropSchema($schema);
  3730|             $cr = ClassRegistry::getInstance();
  3731|             $return = $this->execute($sql);
  3732|         }
  3733|         clearCache(null, 'models');
  3734|         return $return;
  3735|     }
  3736|     /**
  3737|      * テーブル名をリネームする
  3738|      *
  3739|      * @param string $oldName
  3740|      * @param array $options [ old / new ]
  3741|      * @return boolean
  3742|      */
  3743|     public function renameTable($options)
  3744|     {
  3745|         extract($options);
  3746|         if (!isset($new) || !isset($old)) {
  3747|             return false;
  3748|         }
  3749|         $new = $this->config['prefix'] . $new;
  3750|         $old = $this->config['prefix'] . $old;
  3751|         $sql = $this->buildRenameTable($old, $new);
  3752|         return $this->execute($sql);
  3753|     }
  3754|     /**
  3755|      * カラムを追加する
  3756|      *
  3757|      * @param array $options [ table / column ]
  3758|      * @return boolean
  3759|      */
  3760|     public function addColumn($options)
  3761|     {
  3762|         extract($options);
  3763|         if (!isset($table) || !isset($column)) {
  3764|             return false;
  3765|         }
  3766|         if (!isset($column['name'])) {
  3767|             if (isset($field)) {
  3768|                 $column['name'] = $field;
  3769|             } else {
  3770|                 return false;
  3771|             }
  3772|         }
  3773|         $old = $this->readSchema($table);
  3774|         if (isset($old['tables'][$table][$field])) {
  3775|             return false;
  3776|         }
  3777|         $new = $old;
  3778|         $fields = [];
  3779|         foreach($new['tables'][$table] as $key => $value) {
  3780|             if ($key !== 'indexes' && $key !== 'tableParameters') {
  3781|                 $fields[$key] = $value;
  3782|             }
  3783|         }
  3784|         $fields[$field] = $column;
  3785|         if (!empty($new['tables'][$table]['indexes'])) {
  3786|             $fields['indexes'] = $new['tables'][$table]['indexes'];
  3787|         }
  3788|         if (isset($new['tables'][$table]['tableParameters'])) {
  3789|             $fields['tableParameters'] = $new['tables'][$table]['tableParameters'];
  3790|         }
  3791|         $new['tables'][$table] = $fields;
  3792|         $CakeSchema = ClassRegistry::init('CakeSchema');
  3793|         $CakeSchema->connection = $this->configKeyName;
  3794|         $compare = $CakeSchema->compare($old, $new);
  3795|         $sql = $this->alterSchema($compare);
  3796|         return $this->execute($sql);
  3797|     }
  3798|     /**
  3799|      * カラムを変更する
  3800|      *
  3801|      * @param array $options [ table / column / field ]
  3802|      * @return boolean
  3803|      */
  3804|     public function changeColumn($options)
  3805|     {
  3806|         extract($options);
  3807|         if (!isset($table) || !isset($column)) {
  3808|             return false;
  3809|         }
  3810|         if (!isset($field)) {
  3811|             if (isset($column['name'])) {
  3812|                 $field = $column['name'];
  3813|             } else {
  3814|                 return false;
  3815|             }
  3816|         }
  3817|         $old = $this->readSchema($table);
  3818|         if (!isset($old['tables'][$table][$field])) {
  3819|             return false;
  3820|         }
  3821|         $new = $old;
  3822|         $new['tables'][$table][$field] = $column;
  3823|         $CakeSchema = ClassRegistry::init('CakeSchema');
  3824|         $CakeSchema->connection = $this->configKeyName;
  3825|         $compare = $CakeSchema->compare($old, $new);
  3826|         $sql = $this->alterSchema($compare);
  3827|         return $this->execute($sql);
  3828|     }
  3829|     /**
  3830|      * カラムを削除する
  3831|      *
  3832|      * @param array $options [ table / field ]
  3833|      * @return boolean
  3834|      */
  3835|     public function dropColumn($options)
  3836|     {
  3837|         extract($options);
  3838|         if (!isset($table) || !isset($field)) {
  3839|             return false;
  3840|         }
  3841|         $old = $this->readSchema($table);
  3842|         if (!isset($old['tables'][$table][$field])) {
  3843|             return false;
  3844|         }
  3845|         $new = $old;
  3846|         unset($new['tables'][$table][$field]);
  3847|         $CakeSchema = ClassRegistry::init('CakeSchema');
  3848|         $CakeSchema->connection = $this->configKeyName;
  3849|         $compare = $CakeSchema->compare($old, $new);
  3850|         $sql = $this->alterSchema($compare);
  3851|         return $this->execute($sql);
  3852|     }
  3853|     /**
  3854|      * カラム名を変更する
  3855|      *
  3856|      * @param array $options [ table / new / old ]
  3857|      * @return boolean
  3858|      */
  3859|     public function renameColumn($options)
  3860|     {
  3861|         extract($options);
  3862|         if (!isset($table) || !isset($new) || !isset($old)) {
  3863|             return false;
  3864|         }
  3865|         $column['name'] = $new;
  3866|         $options = ['field' => $old, 'table' => $table, 'column' => $column];
  3867|         return $this->changeColumn($options);
  3868|     }
  3869|     /**
  3870|      * テーブル名のリネームステートメントを生成
  3871|      *
  3872|      * @param string $sourceName
  3873|      * @param string $targetName
  3874|      * @return string
  3875|      */
  3876|     public function buildRenameTable($sourceName, $targetName)
  3877|     {
  3878|         return "ALTER TABLE " . $sourceName . " RENAME " . $targetName;
  3879|     }
  3880|     /**
  3881|      * データベースよりスキーマ情報を読み込む
  3882|      *
  3883|      * @param string $table
  3884|      * @param array $options オプション
  3885|      *  `cache` キャッシュ利用
  3886|      *  `plugin` プラグイン指定
  3887|      * @return array $schema
  3888|      */
  3889|     public function readSchema($table, $options = [])
  3890|     {
  3891|         if (is_array($options)) {
  3892|             $options = array_merge([
  3893|                 'cache' => false,
  3894|                 'plugin' => null
  3895|             ], $options);
  3896|         } else {
  3897|             $options['cache'] = $options;
  3898|             $plugin = null;
  3899|         }
  3900|         if (!$options['cache']) {
  3901|             $this->cacheSources = false;
  3902|             ClassRegistry::flush();
  3903|         }
  3904|         $tables = $this->listSources();
  3905|         if (!in_array($this->config['prefix'] . $table, $tables)) {
  3906|             return false;
  3907|         }
  3908|         $CakeSchema = ClassRegistry::init([
  3909|             'class' => 'CakeSchema',
  3910|             'plugin' => $options['plugin']
  3911|         ]);
  3912|         $CakeSchema->connection = $this->configKeyName;
  3913|         $model = Inflector::classify(Inflector::singularize($table));
  3914|         ClassRegistry::init($model);
  3915|         if (!class_exists($model)) {
  3916|             $model = false;
  3917|         } else {
  3918|             $model = [$model];
  3919|         }
  3920|         $schema = $CakeSchema->read(['models' => $model]);
  3921|         ClassRegistry::flush();
  3922|         if ($this->configKeyName != 'default' && !empty($schema['tables']['missing'])) {
  3923|             return [
  3924|                 'name' => $schema['name'],
  3925|                 'tables' => $schema['tables']['missing']
  3926|             ];
  3927|         } else {
  3928|             return $schema;
  3929|         }
  3930|     }
  3931| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/Network/CakeRequest.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1176 ---
     1| <?php
     2| return;
     3| /**
     4|  * CakeRequest
     5|  *
     6|  * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
     7|  * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
     8|  *
     9|  * Licensed under The MIT License
    10|  * For full copyright and license information, please see the LICENSE.txt
    11|  * Redistributions of files must retain the above copyright notice.
    12|  *
    13|  * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
    14|  * @link          https://cakephp.org CakePHP(tm) Project
    15|  * @since         CakePHP(tm) v 2.0
    16|  * @license       https://opensource.org/licenses/mit-license.php MIT License
    17|  */
    18| App::uses('Hash', 'Utility');
    19| /**
    20|  * A class that helps wrap Request information and particulars about a single request.
    21|  * Provides methods commonly used to introspect on the request headers and request body.
    22|  *
    23|  * Has both an Array and Object interface. You can access framework parameters using indexes:
    24|  *
    25|  * `$request['controller']` or `$request->controller`.
    26|  *
    27|  * @package       Cake.Network
    28|  */
    29| class CakeRequest implements ArrayAccess
    30| {
    31|     /**
    32|      * Array of parameters parsed from the URL.
    33|      *
    34|      * @var array
    35|      */
    36|     public $params = [
    37|         'plugin' => null,
    38|         'controller' => null,
    39|         'action' => null,
    40|         'named' => [],
    41|         'pass' => [],
    42|     ];
    43|     /**
    44|      * Array of POST data. Will contain form data as well as uploaded files.
    45|      * Inputs prefixed with 'data' will have the data prefix removed. If there is
    46|      * overlap between an input prefixed with data and one without, the 'data' prefixed
    47|      * value will take precedence.
    48|      *
    49|      * @var array
    50|      */
    51|     public $data = [];
    52|     /**
    53|      * Array of querystring arguments
    54|      *
    55|      * @var array
    56|      */
    57|     public $query = [];
    58|     /**
    59|      * The URL string used for the request.
    60|      *
    61|      * @var string
    62|      */
    63|     public $url;
    64|     /**
    65|      * Base URL path.
    66|      *
    67|      * @var string
    68|      */
    69|     public $base = false;
    70|     /**
    71|      * webroot path segment for the request.
    72|      *
    73|      * @var string
    74|      */
    75|     public $webroot = '/';
    76|     /**
    77|      * The full address to the current request
    78|      *
    79|      * @var string
    80|      */
    81|     public $here = null;
    82|     /**
    83|      * The built in detectors used with `is()` can be modified with `addDetector()`.
    84|      *
    85|      * There are several ways to specify a detector, see CakeRequest::addDetector() for the
    86|      * various formats and ways to define detectors.
    87|      *
    88|      * @var array
    89|      */
    90|     protected $_detectors = [
    91|         'get' => ['env' => 'REQUEST_METHOD', 'value' => 'GET'],
    92|         'patch' => ['env' => 'REQUEST_METHOD', 'value' => 'PATCH'],
    93|         'post' => ['env' => 'REQUEST_METHOD', 'value' => 'POST'],
    94|         'put' => ['env' => 'REQUEST_METHOD', 'value' => 'PUT'],
    95|         'delete' => ['env' => 'REQUEST_METHOD', 'value' => 'DELETE'],
    96|         'head' => ['env' => 'REQUEST_METHOD', 'value' => 'HEAD'],
    97|         'options' => ['env' => 'REQUEST_METHOD', 'value' => 'OPTIONS'],
    98|         'ssl' => ['env' => 'HTTPS', 'value' => 1],
    99|         'ajax' => ['env' => 'HTTP_X_REQUESTED_WITH', 'value' => 'XMLHttpRequest'],
   100|         'flash' => ['env' => 'HTTP_USER_AGENT', 'pattern' => '/^(Shockwave|Adobe) Flash/'],
   101|         'mobile' => ['env' => 'HTTP_USER_AGENT', 'options' => [
   102|             'Android', 'AvantGo', 'BB10', 'BlackBerry', 'DoCoMo', 'Fennec', 'iPod', 'iPhone', 'iPad',
   103|             'J2ME', 'MIDP', 'NetFront', 'Nokia', 'Opera Mini', 'Opera Mobi', 'PalmOS', 'PalmSource',
   104|             'portalmmm', 'Plucker', 'ReqwirelessWeb', 'SonyEricsson', 'Symbian', 'UP\\.Browser',
   105|             'webOS', 'Windows CE', 'Windows Phone OS', 'Xiino'
   106|         ]],
   107|         'requested' => ['param' => 'requested', 'value' => 1],
   108|         'json' => ['accept' => ['application/json'], 'param' => 'ext', 'value' => 'json'],
   109|         'xml' => ['accept' => ['application/xml', 'text/xml'], 'param' => 'ext', 'value' => 'xml'],
   110|     ];
   111|     /**
   112|      * Copy of php://input. Since this stream can only be read once in most SAPI's
   113|      * keep a copy of it so users don't need to know about that detail.
   114|      *
   115|      * @var string
   116|      */
   117|     protected $_input = '';
   118|     /**
   119|      * Constructor
   120|      *
   121|      * @param string $url Trimmed URL string to use. Should not contain the application base path.
   122|      * @param bool $parseEnvironment Set to false to not auto parse the environment. ie. GET, POST and FILES.
   123|      */
   124|     public function __construct($url = null, $parseEnvironment = true)
   125|     {
   126|         $this->_base();
   127|         if (empty($url)) {
   128|             $url = $this->_url();
   129|         }
   130|         if ($url[0] === '/') {
   131|             $url = substr($url, 1);
   132|         }
   133|         $this->url = $url;
   134|         if ($parseEnvironment) {
   135|             $this->_processPost();
   136|             $this->_processGet();
   137|             $this->_processFiles();
   138|         }
   139|         $this->here = $this->base . '/' . $this->url;
   140|     }
   141|     /**
   142|      * process the post data and set what is there into the object.
   143|      * processed data is available at `$this->data`
   144|      *
   145|      * Will merge POST vars prefixed with `data`, and ones without
   146|      * into a single array. Variables prefixed with `data` will overwrite those without.
   147|      *
   148|      * If you have mixed POST values be careful not to make any top level keys numeric
   149|      * containing arrays. Hash::merge() is used to merge data, and it has possibly
   150|      * unexpected behavior in this situation.
   151|      *
   152|      * @return void
   153|      */
   154|     protected function _processPost()
   155|     {
   156|         if ($_POST) {
   157|             $this->data = $_POST;
   158|         } elseif (($this->is('put') || $this->is('delete')) &&
   159|             strpos($this->contentType(), 'application/x-www-form-urlencoded') === 0
   160|         ) {
   161|             $data = $this->_readInput();
   162|             parse_str($data, $this->data);
   163|         }
   164|         if (ini_get('magic_quotes_gpc') === '1') {
   165|             $this->data = stripslashes_deep($this->data);
   166|         }
   167|         $override = null;
   168|         if (env('HTTP_X_HTTP_METHOD_OVERRIDE')) {
   169|             $this->data['_method'] = env('HTTP_X_HTTP_METHOD_OVERRIDE');
   170|             $override = $this->data['_method'];
   171|         }
   172|         $isArray = is_array($this->data);
   173|         if ($isArray && isset($this->data['_method'])) {
   174|             if (!empty($_SERVER)) {
   175|                 $_SERVER['REQUEST_METHOD'] = $this->data['_method'];
   176|             } else {
   177|                 $_ENV['REQUEST_METHOD'] = $this->data['_method'];
   178|             }
   179|             $override = $this->data['_method'];
   180|             unset($this->data['_method']);
   181|         }
   182|         if ($override && !in_array($override, ['POST', 'PUT', 'PATCH', 'DELETE'])) {
   183|             $this->data = [];
   184|         }
   185|         if ($isArray && isset($this->data['data'])) {
   186|             $data = $this->data['data'];
   187|             if (count($this->data) <= 1) {
   188|                 $this->data = $data;
   189|             } else {
   190|                 unset($this->data['data']);
   191|                 $this->data = Hash::merge($this->data, $data);
   192|             }
   193|         }
   194|     }
   195|     /**
   196|      * Process the GET parameters and move things into the object.
   197|      *
   198|      * @return void
   199|      */
   200|     protected function _processGet()
   201|     {
   202|         if (ini_get('magic_quotes_gpc') === '1') {
   203|             $query = stripslashes_deep($_GET);
   204|         } else {
   205|             $query = $_GET;
   206|         }
   207|         $unsetUrl = '/' . str_replace(['.', ' '], '_', rawurldecode($this->url));
   208|         unset($query[$unsetUrl]);
   209|         unset($query[$this->base . $unsetUrl]);
   210|         if (strpos($this->url, '?') !== false) {
   211|             [$this->url, $querystr] = explode('?', $this->url);
   212|             parse_str($querystr, $queryArgs);
   213|             $query += $queryArgs;
   214|         }
   215|         if (isset($this->params['url'])) {
   216|             $query = array_merge($this->params['url'], $query);
   217|         }
   218|         $this->query = $query;
   219|     }
   220|     /**
   221|      * Get the request uri. Looks in PATH_INFO first, as this is the exact value we need prepared
   222|      * by PHP. Following that, REQUEST_URI, PHP_SELF, HTTP_X_REWRITE_URL and argv are checked in that order.
   223|      * Each of these server variables have the base path, and query strings stripped off
   224|      *
   225|      * @return string URI The CakePHP request path that is being accessed.
   226|      */
   227|     protected function _url()
   228|     {
   229|         $uri = '';
   230|         if (!empty($_SERVER['PATH_INFO'])) {
   231|             return $_SERVER['PATH_INFO'];
   232|         } elseif (isset($_SERVER['REQUEST_URI']) && strpos($_SERVER['REQUEST_URI'], '://') === false) {
   233|             $uri = $_SERVER['REQUEST_URI'];
   234|         } elseif (isset($_SERVER['REQUEST_URI'])) {
   235|             $qPosition = strpos($_SERVER['REQUEST_URI'], '?');
   236|             if ($qPosition !== false && strpos($_SERVER['REQUEST_URI'], '://') > $qPosition) {
   237|                 $uri = $_SERVER['REQUEST_URI'];
   238|             } else {
   239|                 if (strpos($_SERVER['REQUEST_URI'], Configure::read('App.fullBaseUrl')) === 0) {
   240|                     $uri = substr($_SERVER['REQUEST_URI'], strlen(Configure::read('App.fullBaseUrl')));
   241|                 } else {
   242|                     $uri = $_SERVER['REQUEST_URI'];
   243|                 }
   244|             }
   245|         } elseif (isset($_SERVER['PHP_SELF']) && isset($_SERVER['SCRIPT_NAME'])) {
   246|             $uri = str_replace($_SERVER['SCRIPT_NAME'], '', $_SERVER['PHP_SELF']);
   247|         } elseif (isset($_SERVER['HTTP_X_REWRITE_URL'])) {
   248|             $uri = $_SERVER['HTTP_X_REWRITE_URL'];
   249|         } elseif ($var = env('argv')) {
   250|             $uri = $var[0];
   251|         }
   252|         if (Configure::read('App.baseUrl')) {
   253|             $dir = dirname($this->base);
   254|             if (strpos($uri, $dir) === 0) {
   255|             }
   256|         }
   257|         $base = str_replace('/index.php', '', $this->base);
   258|         if (strlen($base) > 0 && strpos($uri, $base) === 0) {
   259|             $uri = substr($uri, strlen($base));
   260|         }
   261|         if (strpos($uri, '?') !== false) {
   262|             [$uri] = explode('?', $uri, 2);
   263|         }
   264|         if (empty($uri) || $uri === '/' || $uri === '//' || $uri === '/index.php') {
   265|             $uri = '/';
   266|         }
   267|         $endsWithIndex = '/webroot/index.php';
   268|         $endsWithLength = strlen($endsWithIndex);
   269|         if (strlen($uri) >= $endsWithLength &&
   270|             substr($uri, -$endsWithLength) === $endsWithIndex
   271|         ) {
   272|             $uri = '/';
   273|         }
   274|         return $uri;
   275|     }
   276|     /**
   277|      * Returns a base URL and sets the proper webroot
   278|      *
   279|      * If CakePHP is called with index.php in the URL even though
   280|      * URL Rewriting is activated (and thus not needed) it swallows
   281|      * the unnecessary part from $base to prevent issue #3318.
   282|      *
   283|      * @return string Base URL
   284|      */
   285|     protected function _base()
   286|     {
   287|         $dir = $webroot = null;
   288|         $config = Configure::read('App');
   289|         extract($config);
   290|         if (!isset($base)) {
   291|             $base = $this->base;
   292|         }
   293|         if ($base !== false) {
   294|             $this->webroot = $base . '/';
   295|             return $this->base = $base;
   296|         }
   297|         if (empty($baseUrl)) {
   298|             $base = dirname(env('PHP_SELF'));
   299|             $base = preg_replace('#/+#', '/', $base);
   300|             $indexPos = strpos($base, '/webroot/index.php');
   301|             if ($indexPos !== false) {
   302|                 $base = substr($base, 0, $indexPos) . '/webroot';
   303|             }
   304|             if ($webroot === 'webroot' && $webroot === basename($base)) {
   305|                 $base = dirname($base);
   306|             }
   307|             if ($dir === 'app' && $dir === basename($base)) {
   308|                 $base = dirname($base);
   309|             }
   310|             if ($base === DS || $base === '.') {
   311|                 $base = '';
   312|             }
   313|             $base = implode('/', array_map('rawurlencode', explode('/', $base)));
   314|             $this->webroot = $base . '/';
   315|             return $this->base = $base;
   316|         }
   317|         $file = '/' . basename($baseUrl);
   318|         $base = dirname($baseUrl);
   319|         if ($base === DS || $base === '.') {
   320|             $base = '';
   321|         }
   322|         $this->webroot = $base . '/';
   323|         $docRoot = env('DOCUMENT_ROOT');
   324|         $docRootContainsWebroot = strpos($docRoot, $dir . DS . $webroot);
   325|         if ((!empty($base) || !$docRootContainsWebroot)) {
   326|             if (strpos($this->webroot, '/' . $dir . '/') === false) {
   327|                 $this->webroot .= $dir . '/';
   328|             }
   329|             if (strpos($this->webroot, '/' . $webroot . '/') === false) {
   330|                 $this->webroot .= $webroot . '/';
   331|             }
   332|         }
   333|         return $this->base = $base . $file;
   334|     }
   335|     /**
   336|      * Process $_FILES and move things into the object.
   337|      *
   338|      * @return void
   339|      */
   340|     protected function _processFiles()
   341|     {
   342|         if (isset($_FILES) && is_array($_FILES)) {
   343|             foreach($_FILES as $name => $data) {
   344|                 if ($name !== 'data') {
   345|                     $this->params['form'][$name] = $data;
   346|                 }
   347|             }
   348|         }
   349|         if (isset($_FILES['data'])) {
   350|             foreach($_FILES['data'] as $key => $data) {
   351|                 $this->_processFileData('', $data, $key);
   352|             }
   353|         }
   354|     }
   355|     /**
   356|      * Recursively walks the FILES array restructuring the data
   357|      * into something sane and useable.
   358|      *
   359|      * @param string $path The dot separated path to insert $data into.
   360|      * @param array $data The data to traverse/insert.
   361|      * @param string $field The terminal field name, which is the top level key in $_FILES.
   362|      * @return void
   363|      */
   364|     protected function _processFileData($path, $data, $field)
   365|     {
   366|         foreach($data as $key => $fields) {
   367|             $newPath = $key;
   368|             if (strlen($path) > 0) {
   369|                 $newPath = $path . '.' . $key;
   370|             }
   371|             if (is_array($fields)) {
   372|                 $this->_processFileData($newPath, $fields, $field);
   373|             } else {
   374|                 $newPath .= '.' . $field;
   375|                 $this->data = Hash::insert($this->data, $newPath, $fields);
   376|             }
   377|         }
   378|     }
   379|     /**
   380|      * Get the content type used in this request.
   381|      *
   382|      * @return string
   383|      */
   384|     public function contentType()
   385|     {
   386|         $type = env('CONTENT_TYPE');
   387|         if ($type) {
   388|             return $type;
   389|         }
   390|         return env('HTTP_CONTENT_TYPE');
   391|     }
   392|     /**
   393|      * Get the IP the client is using, or says they are using.
   394|      *
   395|      * @param bool $safe Use safe = false when you think the user might manipulate their HTTP_CLIENT_IP
   396|      *   header. Setting $safe = false will also look at HTTP_X_FORWARDED_FOR
   397|      * @return string The client IP.
   398|      */
   399|     public function clientIp($safe = true)
   400|     {
   401|         if (!$safe && env('HTTP_X_FORWARDED_FOR')) {
   402|             $ipaddr = preg_replace('/(?:,.*)/', '', env('HTTP_X_FORWARDED_FOR'));
   403|         } elseif (!$safe && env('HTTP_CLIENT_IP')) {
   404|             $ipaddr = env('HTTP_CLIENT_IP');
   405|         } else {
   406|             $ipaddr = env('REMOTE_ADDR');
   407|         }
   408|         return trim($ipaddr);
   409|     }
   410|     /**
   411|      * Returns the referer that referred this request.
   412|      *
   413|      * @param bool $local Attempt to return a local address. Local addresses do not contain hostnames.
   414|      * @return string The referring address for this request.
   415|      */
   416|     public function referer($local = false)
   417|     {
   418|         $ref = env('HTTP_REFERER');
   419|         $base = Configure::read('App.fullBaseUrl') . $this->webroot;
   420|         if (!empty($ref) && !empty($base)) {
   421|             if ($local && strpos($ref, $base) === 0) {
   422|                 $ref = substr($ref, strlen($base));
   423|                 if (!strlen($ref) || strpos($ref, '//') === 0) {
   424|                     $ref = '/';
   425|                 }
   426|                 if ($ref[0] !== '/') {
   427|                     $ref = '/' . $ref;
   428|                 }
   429|                 return $ref;
   430|             } elseif (!$local) {
   431|                 return $ref;
   432|             }
   433|         }
   434|         return '/';
   435|     }
   436|     /**
   437|      * Missing method handler, handles wrapping older style isAjax() type methods
   438|      *
   439|      * @param string $name The method called
   440|      * @param array $params Array of parameters for the method call
   441|      * @return mixed
   442|      * @throws CakeException when an invalid method is called.
   443|      */
   444|     public function __call($name, $params)
   445|     {
   446|         if (strpos($name, 'is') === 0) {
   447|             $type = strtolower(substr($name, 2));
   448|             return $this->is($type);
   449|         }
   450|         throw new CakeException(__d('cake_dev', 'Method %s does not exist', $name));
   451|     }
   452|     /**
   453|      * Magic get method allows access to parsed routing parameters directly on the object.
   454|      *
   455|      * Allows access to `$this->params['controller']` via `$this->controller`
   456|      *
   457|      * @param string $name The property being accessed.
   458|      * @return mixed Either the value of the parameter or null.
   459|      */
   460|     public function __get($name)
   461|     {
   462|         if (isset($this->params[$name])) {
   463|             return $this->params[$name];
   464|         }
   465|         return null;
   466|     }
   467|     /**
   468|      * Magic isset method allows isset/empty checks
   469|      * on routing parameters.
   470|      *
   471|      * @param string $name The property being accessed.
   472|      * @return bool Existence
   473|      */
   474|     public function __isset($name)
   475|     {
   476|         return isset($this->params[$name]);
   477|     }
   478|     /**
   479|      * Check whether or not a Request is a certain type.
   480|      *
   481|      * Uses the built in detection rules as well as additional rules
   482|      * defined with CakeRequest::addDetector(). Any detector can be called
   483|      * as `is($type)` or `is$Type()`.
   484|      *
   485|      * @param string|string[] $type The type of request you want to check. If an array
   486|      *   this method will return true if the request matches any type.
   487|      * @return bool Whether or not the request is the type you are checking.
   488|      */
   489|     public function is($type)
   490|     {
   491|         if (is_array($type)) {
   492|             foreach($type as $_type) {
   493|                 if ($this->is($_type)) {
   494|                     return true;
   495|                 }
   496|             }
   497|             return false;
   498|         }
   499|         $type = strtolower($type);
   500|         if (!isset($this->_detectors[$type])) {
   501|             return false;
   502|         }
   503|         $detect = $this->_detectors[$type];
   504|         if (isset($detect['env']) && $this->_environmentDetector($detect)) {
   505|             return true;
   506|         }
   507|         if (isset($detect['header']) && $this->_headerDetector($detect)) {
   508|             return true;
   509|         }
   510|         if (isset($detect['accept']) && $this->_acceptHeaderDetector($detect)) {
   511|             return true;
   512|         }
   513|         if (isset($detect['param']) && $this->_paramDetector($detect)) {
   514|             return true;
   515|         }
   516|         if (isset($detect['callback']) && is_callable($detect['callback'])) {
   517|             return call_user_func($detect['callback'], $this);
   518|         }
   519|         return false;
   520|     }
   521|     /**
   522|      * Detects if a URL extension is present.
   523|      *
   524|      * @param array $detect Detector options array.
   525|      * @return bool Whether or not the request is the type you are checking.
   526|      */
   527|     protected function _extensionDetector($detect)
   528|     {
   529|         if (is_string($detect['extension'])) {
   530|             $detect['extension'] = [$detect['extension']];
   531|         }
   532|         if (in_array($this->params['ext'], $detect['extension'])) {
   533|             return true;
   534|         }
   535|         return false;
   536|     }
   537|     /**
   538|      * Detects if a specific accept header is present.
   539|      *
   540|      * @param array $detect Detector options array.
   541|      * @return bool Whether or not the request is the type you are checking.
   542|      */
   543|     protected function _acceptHeaderDetector($detect)
   544|     {
   545|         $acceptHeaders = explode(',', (string)env('HTTP_ACCEPT'));
   546|         foreach($detect['accept'] as $header) {
   547|             if (in_array($header, $acceptHeaders)) {
   548|                 return true;
   549|             }
   550|         }
   551|         return false;
   552|     }
   553|     /**
   554|      * Detects if a specific header is present.
   555|      *
   556|      * @param array $detect Detector options array.
   557|      * @return bool Whether or not the request is the type you are checking.
   558|      */
   559|     protected function _headerDetector($detect)
   560|     {
   561|         foreach($detect['header'] as $header => $value) {
   562|             $header = env('HTTP_' . strtoupper($header));
   563|             if (!is_null($header)) {
   564|                 if (!is_string($value) && !is_bool($value) && is_callable($value)) {
   565|                     return call_user_func($value, $header);
   566|                 }
   567|                 return ($header === $value);
   568|             }
   569|         }
   570|         return false;
   571|     }
   572|     /**
   573|      * Detects if a specific request parameter is present.
   574|      *
   575|      * @param array $detect Detector options array.
   576|      * @return bool Whether or not the request is the type you are checking.
   577|      */
   578|     protected function _paramDetector($detect)
   579|     {
   580|         $key = $detect['param'];
   581|         if (isset($detect['value'])) {
   582|             $value = $detect['value'];
   583|             return isset($this->params[$key])? $this->params[$key] == $value : false;
   584|         }
   585|         if (isset($detect['options'])) {
   586|             return isset($this->params[$key])? in_array($this->params[$key], $detect['options']) : false;
   587|         }
   588|         return false;
   589|     }
   590|     /**
   591|      * Detects if a specific environment variable is present.
   592|      *
   593|      * @param array $detect Detector options array.
   594|      * @return bool Whether or not the request is the type you are checking.
   595|      */
   596|     protected function _environmentDetector($detect)
   597|     {
   598|         if (isset($detect['env'])) {
   599|             if (isset($detect['value'])) {
   600|                 return env($detect['env']) == $detect['value'];
   601|             }
   602|             if (isset($detect['pattern'])) {
   603|                 return (bool)preg_match($detect['pattern'], env($detect['env']));
   604|             }
   605|             if (isset($detect['options'])) {
   606|                 $pattern = '/' . implode('|', $detect['options']) . '/i';
   607|                 return (bool)preg_match($pattern, env($detect['env']));
   608|             }
   609|         }
   610|         return false;
   611|     }
   612|     /**
   613|      * Check that a request matches all the given types.
   614|      *
   615|      * Allows you to test multiple types and union the results.
   616|      * See CakeRequest::is() for how to add additional types and the
   617|      * built-in types.
   618|      *
   619|      * @param array $types The types to check.
   620|      * @return bool Success.
   621|      * @see CakeRequest::is()
   622|      */
   623|     public function isAll(array $types)
   624|     {
   625|         foreach($types as $type) {
   626|             if (!$this->is($type)) {
   627|                 return false;
   628|             }
   629|         }
   630|         return true;
   631|     }
   632|     /**
   633|      * Add a new detector to the list of detectors that a request can use.
   634|      * There are several different formats and types of detectors that can be set.
   635|      *
   636|      * ### Environment value comparison
   637|      *
   638|      * An environment value comparison, compares a value fetched from `env()` to a known value
   639|      * the environment value is equality checked against the provided value.
   640|      *
   641|      * e.g `addDetector('post', array('env' => 'REQUEST_METHOD', 'value' => 'POST'))`
   642|      *
   643|      * ### Pattern value comparison
   644|      *
   645|      * Pattern value comparison allows you to compare a value fetched from `env()` to a regular expression.
   646|      *
   647|      * e.g `addDetector('iphone', array('env' => 'HTTP_USER_AGENT', 'pattern' => '/iPhone/i'));`
   648|      *
   649|      * ### Option based comparison
   650|      *
   651|      * Option based comparisons use a list of options to create a regular expression. Subsequent calls
   652|      * to add an already defined options detector will merge the options.
   653|      *
   654|      * e.g `addDetector('mobile', array('env' => 'HTTP_USER_AGENT', 'options' => array('Fennec')));`
   655|      *
   656|      * ### Callback detectors
   657|      *
   658|      * Callback detectors allow you to provide a 'callback' type to handle the check. The callback will
   659|      * receive the request object as its only parameter.
   660|      *
   661|      * e.g `addDetector('custom', array('callback' => array('SomeClass', 'somemethod')));`
   662|      *
   663|      * ### Request parameter detectors
   664|      *
   665|      * Allows for custom detectors on the request parameters.
   666|      *
   667|      * e.g `addDetector('requested', array('param' => 'requested', 'value' => 1)`
   668|      *
   669|      * You can also make parameter detectors that accept multiple values
   670|      * using the `options` key. This is useful when you want to check
   671|      * if a request parameter is in a list of options.
   672|      *
   673|      * `addDetector('extension', array('param' => 'ext', 'options' => array('pdf', 'csv'))`
   674|      *
   675|      * @param string $name The name of the detector.
   676|      * @param array $options The options for the detector definition. See above.
   677|      * @return void
   678|      */
   679|     public function addDetector($name, $options)
   680|     {
   681|         $name = strtolower($name);
   682|         if (isset($this->_detectors[$name]) && isset($options['options'])) {
   683|             $options = Hash::merge($this->_detectors[$name], $options);
   684|         }
   685|         $this->_detectors[$name] = $options;
   686|     }
   687|     /**
   688|      * Add parameters to the request's parsed parameter set. This will overwrite any existing parameters.
   689|      * This modifies the parameters available through `$request->params`.
   690|      *
   691|      * @param array $params Array of parameters to merge in
   692|      * @return self
   693|      */
   694|     public function addParams($params)
   695|     {
   696|         $this->params = array_merge($this->params, (array)$params);
   697|         return $this;
   698|     }
   699|     /**
   700|      * Add paths to the requests' paths vars. This will overwrite any existing paths.
   701|      * Provides an easy way to modify, here, webroot and base.
   702|      *
   703|      * @param array $paths Array of paths to merge in
   704|      * @return self
   705|      */
   706|     public function addPaths($paths)
   707|     {
   708|         foreach(['webroot', 'here', 'base'] as $element) {
   709|             if (isset($paths[$element])) {
   710|                 $this->{$element} = $paths[$element];
   711|             }
   712|         }
   713|         return $this;
   714|     }
   715|     /**
   716|      * Get the value of the current requests URL. Will include named parameters and querystring arguments.
   717|      *
   718|      * @param bool $base Include the base path, set to false to trim the base path off.
   719|      * @return string the current request URL including query string args.
   720|      */
   721|     public function here($base = true)
   722|     {
   723|         $url = $this->here;
   724|         if (!empty($this->query)) {
   725|             $url .= '?' . http_build_query($this->query, null, '&');
   726|         }
   727|         if (!$base) {
   728|             $url = preg_replace('/^' . preg_quote($this->base, '/') . '/', '', $url, 1);
   729|         }
   730|         return $url;
   731|     }
   732|     /**
   733|      * Read an HTTP header from the Request information.
   734|      *
   735|      * @param string $name Name of the header you want.
   736|      * @return mixed Either false on no header being set or the value of the header.
   737|      */
   738|     public static function header($name)
   739|     {
   740|         $httpName = 'HTTP_' . strtoupper(str_replace('-', '_', $name));
   741|         if (isset($_SERVER[$httpName])) {
   742|             return $_SERVER[$httpName];
   743|         }
   744|         if (isset($_SERVER[$name])) {
   745|             return $_SERVER[$name];
   746|         }
   747|         return false;
   748|     }
   749|     /**
   750|      * Get the HTTP method used for this request.
   751|      * There are a few ways to specify a method.
   752|      *
   753|      * - If your client supports it you can use native HTTP methods.
   754|      * - You can set the HTTP-X-Method-Override header.
   755|      * - You can submit an input with the name `_method`
   756|      *
   757|      * Any of these 3 approaches can be used to set the HTTP method used
   758|      * by CakePHP internally, and will effect the result of this method.
   759|      *
   760|      * @return string The name of the HTTP method used.
   761|      */
   762|     public function method()
   763|     {
   764|         return env('REQUEST_METHOD');
   765|     }
   766|     /**
   767|      * Get the host that the request was handled on.
   768|      *
   769|      * @param bool $trustProxy Whether or not to trust the proxy host.
   770|      * @return string
   771|      */
   772|     public function host($trustProxy = false)
   773|     {
   774|         if ($trustProxy) {
   775|             return env('HTTP_X_FORWARDED_HOST');
   776|         }
   777|         return Configure::read('BcEnv.host');
   778|     }
   779|     /**
   780|      * Get the domain name and include $tldLength segments of the tld.
   781|      *
   782|      * @param int $tldLength Number of segments your tld contains. For example: `example.com` contains 1 tld.
   783|      *   While `example.co.uk` contains 2.
   784|      * @return string Domain name without subdomains.
   785|      */
   786|     public function domain($tldLength = 1)
   787|     {
   788|         $segments = explode('.', $this->host());
   789|         $domain = array_slice($segments, -1 * ($tldLength + 1));
   790|         return implode('.', $domain);
   791|     }
   792|     /**
   793|      * Get the subdomains for a host.
   794|      *
   795|      * @param int $tldLength Number of segments your tld contains. For example: `example.com` contains 1 tld.
   796|      *   While `example.co.uk` contains 2.
   797|      * @return array An array of subdomains.
   798|      */
   799|     public function subdomains($tldLength = 1)
   800|     {
   801|         $segments = explode('.', $this->host());
   802|         return array_slice($segments, 0, -1 * ($tldLength + 1));
   803|     }
   804|     /**
   805|      * Find out which content types the client accepts or check if they accept a
   806|      * particular type of content.
   807|      *
   808|      * #### Get all types:
   809|      *
   810|      * `$this->request->accepts();`
   811|      *
   812|      * #### Check for a single type:
   813|      *
   814|      * `$this->request->accepts('application/json');`
   815|      *
   816|      * This method will order the returned content types by the preference values indicated
   817|      * by the client.
   818|      *
   819|      * @param string $type The content type to check for. Leave null to get all types a client accepts.
   820|      * @return mixed Either an array of all the types the client accepts or a boolean if they accept the
   821|      *   provided type.
   822|      */
   823|     public function accepts($type = null)
   824|     {
   825|         $raw = $this->parseAccept();
   826|         $accept = [];
   827|         foreach($raw as $types) {
   828|             $accept = array_merge($accept, $types);
   829|         }
   830|         if ($type === null) {
   831|             return $accept;
   832|         }
   833|         return in_array($type, $accept);
   834|     }
   835|     /**
   836|      * Parse the HTTP_ACCEPT header and return a sorted array with content types
   837|      * as the keys, and pref values as the values.
   838|      *
   839|      * Generally you want to use CakeRequest::accept() to get a simple list
   840|      * of the accepted content types.
   841|      *
   842|      * @return array An array of prefValue => array(content/types)
   843|      */
   844|     public function parseAccept()
   845|     {
   846|         return $this->_parseAcceptWithQualifier($this->header('accept'));
   847|     }
   848|     /**
   849|      * Get the languages accepted by the client, or check if a specific language is accepted.
   850|      *
   851|      * Get the list of accepted languages:
   852|      *
   853|      * ``` CakeRequest::acceptLanguage(); ```
   854|      *
   855|      * Check if a specific language is accepted:
   856|      *
   857|      * ``` CakeRequest::acceptLanguage('es-es'); ```
   858|      *
   859|      * @param string $language The language to test.
   860|      * @return mixed If a $language is provided, a boolean. Otherwise the array of accepted languages.
   861|      */
   862|     public static function acceptLanguage($language = null)
   863|     {
   864|         $raw = static::_parseAcceptWithQualifier(static::header('Accept-Language'));
   865|         $accept = [];
   866|         foreach($raw as $languages) {
   867|             foreach($languages as &$lang) {
   868|                 if (strpos($lang, '_')) {
   869|                     $lang = str_replace('_', '-', $lang);
   870|                 }
   871|                 $lang = strtolower($lang);
   872|             }
   873|             $accept = array_merge($accept, $languages);
   874|         }
   875|         if ($language === null) {
   876|             return $accept;
   877|         }
   878|         return in_array(strtolower($language), $accept);
   879|     }
   880|     /**
   881|      * Parse Accept* headers with qualifier options.
   882|      *
   883|      * Only qualifiers will be extracted, any other accept extensions will be
   884|      * discarded as they are not frequently used.
   885|      *
   886|      * @param string $header Header to parse.
   887|      * @return array
   888|      */
   889|     protected static function _parseAcceptWithQualifier($header)
   890|     {
   891|         $accept = [];
   892|         $header = explode(',', $header);
   893|         foreach(array_filter($header) as $value) {
   894|             $prefValue = '1.0';
   895|             $value = trim($value);
   896|             $semiPos = strpos($value, ';');
   897|             if ($semiPos !== false) {
   898|                 $params = explode(';', $value);
   899|                 $value = trim($params[0]);
   900|                 foreach($params as $param) {
   901|                     $qPos = strpos($param, 'q=');
   902|                     if ($qPos !== false) {
   903|                         $prefValue = substr($param, $qPos + 2);
   904|                     }
   905|                 }
   906|             }
   907|             if (!isset($accept[$prefValue])) {
   908|                 $accept[$prefValue] = [];
   909|             }
   910|             if ($prefValue) {
   911|                 $accept[$prefValue][] = $value;
   912|             }
   913|         }
   914|         krsort($accept);
   915|         return $accept;
   916|     }
   917|     /**
   918|      * Provides a read accessor for `$this->query`. Allows you
   919|      * to use a syntax similar to `CakeSession` for reading URL query data.
   920|      *
   921|      * @param string $name Query string variable name
   922|      * @return mixed The value being read
   923|      */
   924|     public function query($name)
   925|     {
   926|         return Hash::get($this->query, $name);
   927|     }
   928|     /**
   929|      * Provides a read/write accessor for `$this->data`. Allows you
   930|      * to use a syntax similar to `CakeSession` for reading post data.
   931|      *
   932|      * ## Reading values.
   933|      *
   934|      * `$request->data('Post.title');`
   935|      *
   936|      * When reading values you will get `null` for keys/values that do not exist.
   937|      *
   938|      * ## Writing values
   939|      *
   940|      * `$request->data('Post.title', 'New post!');`
   941|      *
   942|      * You can write to any value, even paths/keys that do not exist, and the arrays
   943|      * will be created for you.
   944|      *
   945|      * @param string $name Dot separated name of the value to read/write, one or more args.
   946|      * @return mixed|self Either the value being read, or $this so you can chain consecutive writes.
   947|      */
   948|     public function data($name)
   949|     {
   950|         $args = func_get_args();
   951|         if (count($args) === 2) {
   952|             $this->data = Hash::insert($this->data, $name, $args[1]);
   953|             return $this;
   954|         }
   955|         return Hash::get($this->data, $name);
   956|     }
   957|     /**
   958|      * Safely access the values in $this->params.
   959|      *
   960|      * @param string $name The name of the parameter to get.
   961|      * @return mixed The value of the provided parameter. Will
   962|      *   return false if the parameter doesn't exist or is falsey.
   963|      */
   964|     public function param($name)
   965|     {
   966|         $args = func_get_args();
   967|         if (count($args) === 2) {
   968|             $this->params = Hash::insert($this->params, $name, $args[1]);
   969|             return $this;
   970|         }
   971|         if (!isset($this->params[$name])) {
   972|             return Hash::get($this->params, $name, false);
   973|         }
   974|         return $this->params[$name];
   975|     }
   976|     /**
   977|      * Read data from `php://input`. Useful when interacting with XML or JSON
   978|      * request body content.
   979|      *
   980|      * Getting input with a decoding function:
   981|      *
   982|      * `$this->request->input('json_decode');`
   983|      *
   984|      * Getting input using a decoding function, and additional params:
   985|      *
   986|      * `$this->request->input('Xml::build', array('return' => 'DOMDocument'));`
   987|      *
   988|      * Any additional parameters are applied to the callback in the order they are given.
   989|      *
   990|      * @param string $callback A decoding callback that will convert the string data to another
   991|      *     representation. Leave empty to access the raw input data. You can also
   992|      *     supply additional parameters for the decoding callback using var args, see above.
   993|      * @return mixed The decoded/processed request data.
   994|      */
   995|     public function input($callback = null)
   996|     {
   997|         $input = $this->_readInput();
   998|         $args = func_get_args();
   999|         if (!empty($args)) {
  1000|             $callback = array_shift($args);
  1001|             array_unshift($args, $input);
  1002|             return call_user_func_array($callback, $args);
  1003|         }
  1004|         return $input;
  1005|     }
  1006|     /**
  1007|      * Modify data originally from `php://input`. Useful for altering json/xml data
  1008|      * in middleware or DispatcherFilters before it gets to RequestHandlerComponent
  1009|      *
  1010|      * @param string $input A string to replace original parsed data from input()
  1011|      * @return void
  1012|      */
  1013|     public function setInput($input)
  1014|     {
  1015|         $this->_input = $input;
  1016|     }
  1017|     /**
  1018|      * Allow only certain HTTP request methods. If the request method does not match
  1019|      * a 405 error will be shown and the required "Allow" response header will be set.
  1020|      *
  1021|      * Example:
  1022|      *
  1023|      * $this->request->allowMethod('post', 'delete');
  1024|      * or
  1025|      * $this->request->allowMethod(array('post', 'delete'));
  1026|      *
  1027|      * If the request would be GET, response header "Allow: POST, DELETE" will be set
  1028|      * and a 405 error will be returned.
  1029|      *
  1030|      * @param string|array $methods Allowed HTTP request methods.
  1031|      * @return bool true
  1032|      * @throws MethodNotAllowedException
  1033|      */
  1034|     public function allowMethod($methods)
  1035|     {
  1036|         if (!is_array($methods)) {
  1037|             $methods = func_get_args();
  1038|         }
  1039|         foreach($methods as $method) {
  1040|             if ($this->is($method)) {
  1041|                 return true;
  1042|             }
  1043|         }
  1044|         $allowed = strtoupper(implode(', ', $methods));
  1045|         $e = new MethodNotAllowedException();
  1046|         $e->responseHeader('Allow', $allowed);
  1047|         throw $e;
  1048|     }
  1049|     /**
  1050|      * Alias of CakeRequest::allowMethod() for backwards compatibility.
  1051|      *
  1052|      * @param string|array $methods Allowed HTTP request methods.
  1053|      * @return bool true
  1054|      * @throws MethodNotAllowedException
  1055|      * @see CakeRequest::allowMethod()
  1056|      * @deprecated 3.0.0 Since 2.5, use CakeRequest::allowMethod() instead.
  1057|      */
  1058|     public function onlyAllow($methods)
  1059|     {
  1060|         if (!is_array($methods)) {
  1061|             $methods = func_get_args();
  1062|         }
  1063|         return $this->allowMethod($methods);
  1064|     }
  1065|     /**
  1066|      * Read data from php://input, mocked in tests.
  1067|      *
  1068|      * @return string contents of php://input
  1069|      */
  1070|     protected function _readInput()
  1071|     {
  1072|         if (empty($this->_input)) {
  1073|             $fh = fopen('php://input', 'r');
  1074|             $content = stream_get_contents($fh);
  1075|             fclose($fh);
  1076|             $this->_input = $content;
  1077|         }
  1078|         return $this->_input;
  1079|     }
  1080|     /**
  1081|      * Array access read implementation
  1082|      *
  1083|      * @param string $name Name of the key being accessed.
  1084|      * @return mixed
  1085|      */
  1086|     public function offsetGet($name)
  1087|     {
  1088|         if (isset($this->params[$name])) {
  1089|             return $this->params[$name];
  1090|         }
  1091|         if ($name === 'url') {
  1092|             return $this->query;
  1093|         }
  1094|         if ($name === 'data') {
  1095|             return $this->data;
  1096|         }
  1097|         return null;
  1098|     }
  1099|     /**
  1100|      * Array access write implementation
  1101|      *
  1102|      * @param string $name Name of the key being written
  1103|      * @param mixed $value The value being written.
  1104|      * @return void
  1105|      */
  1106|     public function offsetSet($name, $value)
  1107|     {
  1108|         $this->params[$name] = $value;
  1109|     }
  1110|     /**
  1111|      * Array access isset() implementation
  1112|      *
  1113|      * @param string $name thing to check.
  1114|      * @return bool
  1115|      */
  1116|     public function offsetExists($name)
  1117|     {
  1118|         if ($name === 'url' || $name === 'data') {
  1119|             return true;
  1120|         }
  1121|         return isset($this->params[$name]);
  1122|     }
  1123|     /**
  1124|      * Array access unset() implementation
  1125|      *
  1126|      * @param string $name Name to unset.
  1127|      * @return void
  1128|      */
  1129|     public function offsetUnset($name)
  1130|     {
  1131|         unset($this->params[$name]);
  1132|     }
  1133|     /**
  1134|      * 現在のURLを正規化して取得する
  1135|      *
  1136|      * $this->request->here は、ビューキャッシュの命名規則に影響する為、
  1137|      * CacheHelper 等で、このメソッドを利用する事で、同一ページによる複数キャッシュの生成を防ぐ
  1138|      *
  1139|      * （例）
  1140|      * /news/ → /news/index
  1141|      * /company/ → /company/index
  1142|      *
  1143|      * @return string
  1144|      */
  1145|     public function normalizedHere()
  1146|     {
  1147|         $here = $this->here;
  1148|         if (!BcUtil::isAdminSystem() && $this->params['controller'] == 'pages') {
  1149|             if (!empty($this->params['pass']) && $this->params['pass'][count($this->params['pass']) - 1] == 'index' && !preg_match('/\/index$/', $here)) {
  1150|                 if (preg_match('/\/$/', $here)) {
  1151|                     $here .= 'index';
  1152|                 } else {
  1153|                     $here .= '/index';
  1154|                 }
  1155|             }
  1156|             $here = preg_replace('/\.html$/', '', $here);
  1157|         } else {
  1158|             if ($this->action == 'index') {
  1159|                 [$here,] = explode('?', $here);
  1160|                 if (!empty($this->params['pass'])) {
  1161|                     foreach($this->params['pass'] as $pass) {
  1162|                         $here = preg_replace('/\/' . $pass . '$/', '', $here);
  1163|                     }
  1164|                 }
  1165|                 if (!preg_match('/\/index$/', $here)) {
  1166|                     if (preg_match('/\/$/', $here)) {
  1167|                         $here .= 'index';
  1168|                     } else {
  1169|                         $here .= '/index';
  1170|                     }
  1171|                 }
  1172|             }
  1173|         }
  1174|         return $here;
  1175|     }
  1176| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/View/BcAppView.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-391 ---
     1| <?php
     2| return;
     3| /**
     4|  * baserCMS :  Based Website Development Project <https://basercms.net>
     5|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     6|  *
     7|  * @copyright     Copyright (c) NPO baser foundation
     8|  * @link          https://basercms.net baserCMS Project
     9|  * @since         5.0.0
    10|  * @license       https://basercms.net/license/index.html MIT License
    11|  */
    12| /**
    13|  * view 拡張クラス
    14|  *
    15|  * @package Baser.View
    16|  * @property \BcAdminHelper $BcAdmin
    17|  * @property \BcArrayHelper $BcArray
    18|  * @property \BcBaserHelper $BcBaser
    19|  * @property \BcCacheHelper $BcCache
    20|  * @property \BcCkeditorHelper $BcCkeditor
    21|  * @property \BcContentsHelper $BcContents
    22|  * @property \BcCsvHelper $BcCsv
    23|  * @property \BcFormHelper $BcForm
    24|  * @property \BcFormTableHelper $BcFormTable
    25|  * @property \BcFreezeHelper $BcFreeze
    26|  * @property \BcGooglemapsHelper $BcGooglemaps
    27|  * @property \BcHtmlHelper $BcHtml
    28|  * @property \BcLayoutHelper $BcLayout
    29|  * @property \BcListTableHelper $BcListTable
    30|  * @property \BcMobileHelper $BcMobile
    31|  * @property \BcPageHelper $BcPage
    32|  * @property \BcSearchBoxHelper $BcSearchBox
    33|  * @property \BcSmartphoneHelper $BcSmartphone
    34|  * @property \BcTextHelper $BcText
    35|  * @property \BcTimeHelper $BcTime
    36|  * @property \BcUploadHelper $BcUpload
    37|  * @property \BcWidgetAreaHelper $BcWidgetArea
    38|  * @property \BcXmlHelper $BcXml
    39|  * @property \BlogHelper $Blog
    40|  * @property \FeedHelper $Feed
    41|  * @property \MaildataHelper $Maildata
    42|  * @property \MailfieldHelper $Mailfield
    43|  * @property \MailformHelper $Mailform
    44|  * @property \MailHelper $Mail
    45|  * @property \UploaderHelper $Uploader
    46|  */
    47| class BcAppView extends View
    48| {
    49|     /**
    50|      * ページタイトル
    51|      *
    52|      * @var string
    53|      */
    54|     public $pageTitle = null;
    55|     /**
    56|      * エレメントキャッシュ
    57|      *
    58|      * @var string
    59|      */
    60|     public $elementCache = '_cake_element_';
    61|     /**
    62|      * テンプレートファイル一覧出力用
    63|      * デバッグモード２で利用
    64|      * @var array
    65|      */
    66|     protected $_viewFilesLog = [];
    67|     /**
    68|      * List of variables to collect from the associated controller
    69|      *
    70|      * @var array
    71|      */
    72|     protected $_passedVars = [
    73|         'viewVars', 'autoLayout', 'ext', 'helpers', 'view', 'layout', 'name', 'theme',
    74|         'layoutPath', 'viewPath', 'request', 'plugin', 'passedArgs', 'cacheAction',
    75|         'subDir', 'adminTheme', 'pageTitle', 'content', 'site'
    76|     ];
    77|     /**
    78|      * Return all possible paths to find view files in order
    79|      *
    80|      * @param string $plugin Optional plugin name to scan for view files.
    81|      * @param boolean $cached Set to true to force a refresh of view paths.
    82|      * @return array paths
    83|      */
    84|     protected function _paths($plugin = null, $cached = true)
    85|     {
    86|         if ($plugin === null && $cached === true && !empty($this->_paths)) {
    87|             return $this->_paths;
    88|         }
    89|         $paths = [];
    90|         $viewPaths = App::path('View');
    91|         $corePaths = array_merge(App::core('View'), App::core('Console/Templates/skel/View'));
    92|         if (!empty($plugin)) {
    93|             $count = count($viewPaths);
    94|             for($i = 0; $i < $count; $i++) {
    95|                 if (!in_array($viewPaths[$i], $corePaths)) {
    96|                     $paths[] = $viewPaths[$i] . 'Plugin' . DS . $plugin . DS;
    97|                 }
    98|             }
    99|             $paths = array_merge($paths, App::path('View', $plugin));
   100|         }
   101|         $paths = array_unique(array_merge($paths, $viewPaths));
   102|         $adminThemePaths = [];
   103|         $webroot = Configure::read('App.www_root');
   104|         if (!empty($this->adminTheme)) {
   105|             foreach($paths as $path) {
   106|                 if (strpos($path, DS . 'Plugin' . DS) === false) {
   107|                     if ($plugin) {
   108|                         $adminThemePaths[] = $path . 'Themed' . DS . $this->adminTheme . DS . 'Plugin' . DS . $plugin . DS;
   109|                     }
   110|                     $adminThemePaths[] = $path . 'Themed' . DS . $this->adminTheme . DS;
   111|                 }
   112|             }
   113|             $adminThemePaths = array_merge([$webroot . 'theme' . DS . $this->adminTheme . DS], $adminThemePaths);
   114|         }
   115|         if (!empty($this->theme)) {
   116|             $themePaths = [];
   117|             foreach($paths as $path) {
   118|                 if (strpos($path, DS . 'Plugin' . DS) === false) {
   119|                     if ($plugin) {
   120|                         $themePaths[] = $path . 'Themed' . DS . $this->theme . DS . 'Plugin' . DS . $plugin . DS;
   121|                     }
   122|                     $themePaths[] = $path . 'Themed' . DS . $this->theme . DS;
   123|                 }
   124|             }
   125|             $themePaths = array_merge([$webroot . 'theme' . DS . $this->theme . DS], $themePaths);
   126|             $paths = array_merge($themePaths, $adminThemePaths, $paths);
   127|         }
   128|         $baserPaths = [];
   129|         foreach($paths as $key => $path) {
   130|             if (strpos($path, BASER) !== false) {
   131|                 unset($paths[$key]);
   132|                 $baserPaths[] = $path;
   133|             }
   134|         }
   135|         $paths = array_merge($paths, $baserPaths);
   136|         $paths = array_merge($paths, $corePaths);
   137|         if ($plugin !== null) {
   138|             return $paths;
   139|         }
   140|         return $this->_paths = $paths;
   141|     }
   142|     /**
   143|      * Returns filename of given action's template file (.ctp) as a string.
   144|      * CamelCased action names will be under_scored! This means that you can have
   145|      * LongActionNames that refer to long_action_names.ctp views.
   146|      *
   147|      * @param string $name Controller action to find template filename for
   148|      * @return string Template filename
   149|      * @throws MissingViewException when a view file could not be found.
   150|      */
   151|     protected function _getViewFileName($name = null)
   152|     {
   153|         $subDir = null;
   154|         if (!is_null($this->subDir)) {
   155|             $subDir = $this->subDir . DS;
   156|         }
   157|         if ($name === null) {
   158|             $name = $this->view;
   159|         }
   160|         $prefix = '';
   161|         if (!empty($this->request->getParam('prefix'))) {
   162|             $prefix = $this->request->getParam('prefix');
   163|         }
   164|         if ($prefix && preg_match('/^' . $prefix . '_/', $name)) {
   165|             $name = str_replace($prefix . '_', '', $name);
   166|         } elseif (preg_match('/^admin_/', $name)) {
   167|             $name = str_replace('admin_', '', $name);
   168|         }
   169|         $name = str_replace('/', DS, $name);
   170|         [$plugin, $name] = $this->pluginSplit($name);
   171|         if ($this->name == 'CakeError' && preg_match('/^Errors\/?/', $this->viewPath)) {
   172|             $subDir = $this->subDir . DS;
   173|             $this->subDir = null;
   174|             if ($this->layoutPath == 'rss') {
   175|                 $this->layoutPath = null;
   176|                 $this->viewPath = 'Errors';
   177|                 $this->response->type('html');
   178|             }
   179|             $exception = $this->get('error');
   180|             if ($exception && $exception instanceof MissingConnectionException) {
   181|                 $this->layout = 'missing_connection';
   182|             }
   183|         }
   184|         $event = $this->dispatchLayerEvent('beforeGetViewFileName', ['name' => $name], ['class' => '', 'plugin' => '']);
   185|         if ($event !== false) {
   186|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   187|         }
   188|         $event = $this->dispatchLayerEvent('beforeGetViewFileName', ['name' => $name]);
   189|         if ($event !== false) {
   190|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   191|         }
   192|         if (strpos($name, DS) === false && $name[0] !== '.') {
   193|             $name = [
   194|                 $this->viewPath . DS . $subDir . Inflector::underscore($name),
   195|                 $this->viewPath . DS . Inflector::underscore($name),
   196|             ];
   197|         } elseif (strpos($name, DS) !== false) {
   198|             if ($name[0] === DS || $name[1] === ':') {
   199|                 if (is_file($name)) {
   200|                     return $name;
   201|                 }
   202|                 $name = trim($name, DS);
   203|             } elseif ($name[0] === '.') {
   204|                 $name = substr($name, 3);
   205|                 /*
   206|                 } elseif (!$plugin || $this->viewPath !== $this->name) {
   207|                     $name = $this->viewPath . DS . $subDir . $name;
   208|                 */
   209|             } else {
   210|                 $name = [
   211|                     $this->viewPath . DS . $subDir . $name,
   212|                     $this->viewPath . DS . $name
   213|                 ];
   214|             }
   215|         }
   216|         $paths = $this->_paths($plugin);
   217|         $exts = $this->_getExtensions();
   218|         /*
   219|         foreach ($exts as $ext) {
   220|             foreach ($paths as $path) {
   221|                 if (file_exists($path . $name . $ext)) {
   222|                     return $path . $name . $ext;
   223|                   }
   224|               }
   225|         }
   226|         */
   227|         if (is_array($name)) {
   228|             $names = $name;
   229|         } else {
   230|             $names[] = $name;
   231|         }
   232|         foreach($names as $name) {
   233|             foreach($paths as $path) {
   234|                 foreach($exts as $ext) {
   235|                     if (file_exists($path . $name . $ext)) {
   236|                         return $path . $name . $ext;
   237|                     }
   238|                 }
   239|             }
   240|         }
   241|         $defaultPath = $paths[0];
   242|         if ($this->plugin) {
   243|             $pluginPaths = App::path('plugins');
   244|             foreach($paths as $path) {
   245|                 if (strpos($path, $pluginPaths[0]) === 0) {
   246|                     $defaultPath = $path;
   247|                     break;
   248|                 }
   249|             }
   250|         }
   251|         throw new MissingViewException(['file' => $defaultPath . $name . $this->ext]);
   252|     }
   253|     /**
   254|      * Finds an element filename, returns false on failure.
   255|      *
   256|      * @param string $name The name of the element to find.
   257|      * @return mixed Either a string to the element filename or false when one can't be found.
   258|      */
   259|     protected function _getElementFileName($name)
   260|     {
   261|         $event = $this->dispatchLayerEvent('beforeGetElementFileName', ['name' => $name], ['class' => '', 'plugin' => '']);
   262|         if ($event !== false) {
   263|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   264|         }
   265|         $event = $this->dispatchLayerEvent('beforeGetElementFileName', ['name' => $name]);
   266|         if ($event !== false) {
   267|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   268|         }
   269|         [$plugin, $name] = $this->pluginSplit($name);
   270|         $names = [$name];
   271|         if ($this->subDir) {
   272|             if (preg_match('/^\.\.\/([^\/]+)\/(.+)$/', $name, $matches)) {
   273|                 $name = '..' . DS . $matches[1] . DS . $this->subDir . DS . $matches[2];
   274|             } else {
   275|                 $name = $this->subDir . DS . $name;
   276|             }
   277|             array_unshift($names, $name);
   278|         }
   279|         $paths = $this->_paths($plugin);
   280|         $exts = $this->_getExtensions();
   281|         /*foreach ($exts as $ext) {
   282|             foreach ($paths as $path) {
   283|                 if (file_exists($path . 'Elements' . DS . $name . $ext)) {
   284|                     return $path . 'Elements' . DS . $name . $ext;
   285|                 }
   286|             }
   287|         }*/
   288|         foreach($names as $name) {
   289|             foreach($exts as $ext) {
   290|                 foreach($paths as $path) {
   291|                     if (file_exists($path . 'Elements' . DS . $name . $ext)) {
   292|                         return $path . 'Elements' . DS . $name . $ext;
   293|                     }
   294|                 }
   295|             }
   296|         }
   297|         return false;
   298|     }
   299|     /**
   300|      * Returns layout filename for this template as a string.
   301|      *
   302|      * @param string $name The name of the layout to find.
   303|      * @return string Filename for layout file (.ctp).
   304|      * @throws MissingLayoutException when a layout cannot be located
   305|      */
   306|     protected function _getLayoutFileName($name = null)
   307|     {
   308|         if ($name === null) {
   309|             $name = $this->layout;
   310|         }
   311|         $subDir = null;
   312|         $event = $this->dispatchLayerEvent('beforeGetLayoutFileName', ['name' => $name], ['class' => '', 'plugin' => '']);
   313|         if ($event !== false) {
   314|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   315|         }
   316|         $event = $this->dispatchLayerEvent('beforeGetLayoutFileName', ['name' => $name]);
   317|         if ($event !== false) {
   318|             $name = ($event->getResult() === null || $event->getResult() === true)? $event->getData('name') : $event->getResult();
   319|         }
   320|         if (!is_null($this->layoutPath)) {
   321|             $subDir = $this->layoutPath . DS;
   322|         }
   323|         [$plugin, $name] = $this->pluginSplit($name);
   324|         $paths = $this->_paths($plugin);
   325|         $files = [
   326|             'Layouts' . DS . $subDir . $name,
   327|             'Layouts' . DS . $name
   328|         ];
   329|         $exts = $this->_getExtensions();
   330|         /*
   331|         foreach ($exts as $ext) {
   332|             foreach ($paths as $path) {
   333|                 if (file_exists($path . $file . $ext)) {
   334|                     return $path . $file . $ext;
   335|                 }
   336|             }
   337|         }
   338|         */
   339|         foreach($files as $file) {
   340|             foreach($paths as $path) {
   341|                 foreach($exts as $ext) {
   342|                     if (file_exists($path . $file . $ext)) {
   343|                         return $path . $file . $ext;
   344|                     }
   345|                 }
   346|             }
   347|         }
   348|         throw new MissingLayoutException(['file' => $paths[0] . $file . $this->ext]);
   349|     }
   350|     /**
   351|      * Get the extensions that view files can use.
   352|      *
   353|      * @return array Array of extensions view files use.
   354|      */
   355|     protected function _getExtensions()
   356|     {
   357|         $this->ext = Configure::read('BcApp.templateExt');
   358|         $exts = [$this->ext];
   359|         if ($this->ext !== '.ctp') {
   360|             $exts[] = '.ctp';
   361|         }
   362|         return $exts;
   363|     }
   364|     /**
   365|      * Sandbox method to evaluate a template / view script in.
   366|      *
   367|      * @param string $viewFn Filename of the view
   368|      * @param array $dataForView Data to include in rendered view.
   369|      *    If empty the current View::$viewVars will be used.
   370|      * @return string Rendered output
   371|      */
   372|     public function evaluate($viewFile, $dataForView)
   373|     {
   374|         return $this->_evaluate($viewFile, $dataForView);
   375|     }
   376|     /**
   377|      * Sandbox method to evaluate a template / view script in.
   378|      *
   379|      * @param string $viewFile Filename of the view
   380|      * @param array $dataForView Data to include in rendered view.
   381|      *    If empty the current View::$viewVars will be used.
   382|      * @return string Rendered output
   383|      */
   384|     protected function _evaluate($viewFile, $dataForView)
   385|     {
   386|         if (Configure::read('debug') > 1) {
   387|             $this->_viewFilesLog[] = $viewFile;
   388|         }
   389|         return parent::_evaluate($viewFile, $dataForView);
   390|     }
   391| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/View/Helper/BcCacheHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-94 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) NPO baser foundation <https://baserfoundation.org/>
     5|  *
     6|  * @copyright     Copyright (c) NPO baser foundation
     7|  * @link          https://basercms.net baserCMS Project
     8|  * @since         5.0.0
     9|  * @license       https://basercms.net/license/index.html MIT License
    10|  */
    11| namespace BaserCore\View\Helper;
    12| use BaserCore\Event\BcEventDispatcherTrait;
    13| use Cake\View\Helper;
    14| /**
    15|  * CacheHelper helps create full page view caching.
    16|  *
    17|  * When using CacheHelper you don't call any of its methods, they are all automatically
    18|  * called by View, and use the $cacheAction settings set in the controller.
    19|  *
    20|  * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/cache.html
    21|  */
    22| class BcCacheHelper extends Helper
    23| {
    24|     /**
    25|      * Trait
    26|      */
    27|     use BcEventDispatcherTrait;
    28|     /**
    29|      * Write a cached version of the file
    30|      *
    31|      * @param string $content view content to write to a cache file.
    32|      * @param string $timestamp Duration to set for cache file.
    33|      * @param bool $useCallbacks Whether to include statements in cached file which
    34|      *   run callbacks.
    35|      * @return bool success of caching view.
    36|      */
    37|     protected function _writeFile($content, $timestamp, $useCallbacks = false)
    38|     {
    39|         $now = time();
    40|         if (is_numeric($timestamp)) {
    41|             $cacheTime = $now + $timestamp;
    42|         } else {
    43|             $cacheTime = strtotime($timestamp, $now);
    44|         }
    45|         $path = $this->request->normalizedHere();
    46|         if ($path === '/') {
    47|             $path = 'home';
    48|         }
    49|         $prefix = Configure::read('Cache.viewPrefix');
    50|         if ($prefix) {
    51|             $path = $prefix . '_' . $path;
    52|         }
    53|         $cache = strtolower(Inflector::slug($path));
    54|         if (empty($cache)) {
    55|             return;
    56|         }
    57|         $cache = $cache . '.php';
    58|         $file = '<!--cachetime:' . $cacheTime . '--><?php';
    59|         if (empty($this->_View->plugin)) {
    60|             $file .= "
    61| 			App::uses('{$this->_View->name}Controller', 'Controller');
    62| 			";
    63|         } else {
    64|             $file .= "
    65| 			App::uses('{$this->_View->plugin}AppController', '{$this->_View->plugin}.Controller');
    66| 			App::uses('{$this->_View->name}Controller', '{$this->_View->plugin}.Controller');
    67| 			";
    68|         }
    69|         $file .= '
    70| 				$request = unserialize(base64_decode(\'' . base64_encode(serialize($this->request)) . '\'));
    71| 				$response->type(\'' . $this->_View->response->type() . '\');
    72| 				$controller = new ' . $this->_View->name . 'Controller($request, $response);
    73| 				$controller->plugin = $this->plugin = \'' . $this->_View->plugin . '\';
    74| 				$controller->helpers = $this->helpers = unserialize(base64_decode(\'' . base64_encode(serialize($this->_View->helpers)) . '\'));
    75| 				$controller->layout = $this->layout = \'' . $this->_View->layout . '\';
    76| 				$controller->theme = $this->theme = \'' . $this->_View->theme . '\';
    77| 				$controller->viewVars = unserialize(base64_decode(\'' . base64_encode(serialize($this->_View->viewVars)) . '\'));
    78| 				Router::setRequestInfo($controller->request);
    79| 				$this->request = $request;';
    80|         if ($useCallbacks) {
    81|             $file .= '
    82| 				$controller->constructClasses();
    83| 				$controller->startupProcess();';
    84|         }
    85|         $file .= '
    86| 				$this->viewVars = $controller->viewVars;
    87| 				$this->loadHelpers();
    88| 				extract($this->viewVars, EXTR_SKIP);
    89| 		?>';
    90|         $content = preg_replace("/(<\\?xml)/", "<?php echo '$1'; ?>", $content);
    91|         $file .= $content;
    92|         return cache('views' . DS . $cache, $file, $timestamp);
    93|     }
    94| }


# ====================================================================
# FILE: __assets/plugins/baser-core/src/basics.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-498 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @package         Baser
     9|  * @since           baserCMS v 0.1.0
    10|  * @license         https://basercms.net/license/index.html
    11|  */
    12| use Cake\Cache\Cache;
    13| use Cake\Utility\Text;
    14| use Cake\Filesystem\File;
    15| use Cake\Filesystem\Folder;
    16| use Cake\Utility\Inflector;
    17| use BaserCore\Utility\BcUtil;
    18| /**
    19|  * baserCMS共通関数
    20|  *
    21|  * baser/config/bootstrapより呼び出される
    22|  *
    23|  * @package         Baser
    24|  */
    25| /**
    26|  * リビジョンを取得する
    27|  * @param string    baserCMS形式のバージョン表記　（例）baserCMS 1.5.3.1600 beta
    28|  * @return string   リビジョン番号
    29|  */
    30| function revision($version)
    31| {
    32|     return preg_replace("/baserCMS [0-9]+?\.[0-9]+?\.[0-9]+?\.([0-9]*)[\sa-z]*/is", "$1", $version);
    33| }
    34| /**
    35|  * 環境変数よりURLパラメータを取得する
    36|  *
    37|  * ＊ プレフィックスは除外する
    38|  * ＊ GETパラメーターは除外する
    39|  *
    40|  * 《注意》
    41|  * bootstrap 実行後でのみ利用可
    42|  */
    43| function getUrlParamFromEnv()
    44| {
    45|     $url = getUrlFromEnv();
    46|     $url = preg_replace('/^\//', '', $url);
    47|     if (strpos($url, '?') !== false) {
    48|         [$url] = explode('?', $url);
    49|     }
    50|     return $url;
    51| }
    52| /**
    53|  * 環境変数よりURLを取得する
    54|  *
    55|  * スマートURLオフ＆bootstrapのタイミングでは、$_GET['url']が取得できてない為、それをカバーする為に利用する
    56|  * ＊ 先頭のスラッシュは除外する
    57|  * ＊ baseUrlは除外する
    58|  *
    59|  */
    60| function getUrlFromEnv()
    61| {
    62|     if (!empty($_GET['url'])) {
    63|         return preg_replace('/^\//', '', $_GET['url']);
    64|     }
    65|     if (!isset($_SERVER['REQUEST_URI'])) {
    66|         return;
    67|     } else {
    68|         $requestUri = $_SERVER['REQUEST_URI'];
    69|     }
    70|     $appBaseUrl = Configure::read('App.baseUrl');
    71|     $parameter = '';
    72|     if ($appBaseUrl) {
    73|         $base = dirname($appBaseUrl);
    74|         if (strpos($requestUri, $appBaseUrl) !== false) {
    75|             $parameter = str_replace($appBaseUrl, '', $requestUri);
    76|         } else {
    77|             $parameter = str_replace($base . '/', '', $requestUri);
    78|         }
    79|     } else {
    80|         if (strpos($requestUri, '?')) {
    81|             $aryRequestUri = explode('?', $requestUri);
    82|             $requestUri = $aryRequestUri[0];
    83|         }
    84|         if (preg_match('/^' . str_replace('/', '\/', BcUtil::baseUrl()) . '/is', $requestUri)) {
    85|             $parameter = preg_replace('/^' . str_replace('/', '\/', BcUtil::baseUrl()) . '/is', '', $requestUri);
    86|         } else {
    87|             $parameter = $requestUri;
    88|         }
    89|     }
    90|     return preg_replace('/^\//', '', $parameter);
    91| }
    92| /**
    93|  * モバイルプレフィックスは除外したURLを取得する
    94|  *
    95|  * MEMO: BcRequest.(agent).aliasは廃止
    96|  *
    97|  * @param CakeRequest $Request
    98|  * @return type
    99|  */
   100| function getPureUrl($Request)
   101| {
   102|     if (!$Request) {
   103|         $Request = new CakeRequest();
   104|     }
   105|     $url = $Request->url;
   106|     if ($url === false) {
   107|         $url = '';
   108|     }
   109|     if (strpos($url, '?') !== false) {
   110|         [$url] = explode('?', $url);
   111|     }
   112|     return $url;
   113| }
   114| /**
   115|  * Viewキャッシュを削除する
   116|  * URLを指定しない場合は全てのViewキャッシュを削除する
   117|  * 全て削除する場合、標準の関数clearCacheだとemptyファイルまで削除されてしまい、
   118|  * 開発時に不便なのでFolderクラスで削除
   119|  *
   120|  * @param    $url
   121|  * @return    void
   122|  * @access    public
   123|  */
   124| function clearViewCache($url = null, $ext = '.php')
   125| {
   126|     $url = preg_replace('/^\/mobile\//is', '/m/', $url);
   127|     if ($url == '/' || $url == '/index' || $url == '/index.html' || $url == '/m/' || $url == '/m/index' || $url == '/m/index.html') {
   128|         $homes = ['index', 'index_html'];
   129|         foreach($homes as $home) {
   130|             if (preg_match('/^\/m/is', $url)) {
   131|                 if ($home) {
   132|                     $home = 'm_' . $home;
   133|                 } else {
   134|                     $home = 'm';
   135|                 }
   136|             } elseif (preg_match('/^\/s/is', $url)) {
   137|                 if ($home) {
   138|                     $home = 's_' . $home;
   139|                 } else {
   140|                     $home = 's';
   141|                 }
   142|             }
   143|             $baseUrl = BcUtil::baseUrl();
   144|             if ($baseUrl) {
   145|                 $baseUrl = str_replace(['/', '.'], '_', $baseUrl);
   146|                 $baseUrl = preg_replace('/^_/', '', $baseUrl);
   147|                 $baseUrl = preg_replace('/_$/', '', $baseUrl);
   148|                 if ($home) {
   149|                     $home = $baseUrl . $home;
   150|                 } else {
   151|                     $home = $baseUrl;
   152|                 }
   153|             } elseif (!$home) {
   154|                 $home = 'home';
   155|             }
   156|             clearCache($home);
   157|         }
   158|     } elseif ($url) {
   159|         if (preg_match('/\/index$/', $url)) {
   160|             clearCache(strtolower(Text::slug($url)), 'views', $ext);
   161|             $url = preg_replace('/\/index$/', '', $url);
   162|             clearCache(strtolower(Text::slug($url)), 'views', $ext);
   163|         } else {
   164|             clearCache(strtolower(Text::slug($url)), 'views', $ext);
   165|         }
   166|     } else {
   167|         $folder = new Folder(CACHE . 'views' . DS);
   168|         $files = $folder->read(true, true);
   169|         foreach($files[1] as $file) {
   170|             if ($file != 'empty') {
   171|                 @unlink(CACHE . 'views' . DS . $file);
   172|             }
   173|         }
   174|     }
   175| }
   176| /**
   177|  * データキャッシュを削除する
   178|  */
   179| function clearDataCache()
   180| {
   181|     App::import('Core', 'Folder');
   182|     $folder = new Folder(CACHE . 'datas' . DS);
   183|     $files = $folder->read(true, true, true);
   184|     foreach($files[1] as $file) {
   185|         @unlink($file);
   186|     }
   187|     $Folder = new Folder();
   188|     foreach($files[0] as $folder) {
   189|         $Folder->delete($folder);
   190|     }
   191| }
   192| /**
   193|  * キャッシュファイルを全て削除する
   194|  */
   195| function clearAllCache()
   196| {
   197|     Cache::clear(false, '_cake_core_');
   198|     Cache::clear(false, '_cake_model_');
   199|     Cache::clear(false, '_bc_env_');
   200|     clearCache();
   201|     clearDataCache();
   202| }
   203| /**
   204|  * DBセッティングが存在するかチェックする
   205|  *
   206|  * @param string $name
   207|  * @return mixed DatabaseConfig Or false
   208|  */
   209| function getDbConfig($name = 'default')
   210| {
   211|     if (file_exists(APP . 'Config' . DS . 'database.php')) {
   212|         require_once APP . 'Config' . DS . 'database.php';
   213|         $dbConfig = new DATABASE_CONFIG();
   214|         if (!empty($dbConfig->{$name}['datasource'])) {
   215|             return $dbConfig->{$name};
   216|         }
   217|     }
   218|     return false;
   219| }
   220| /**
   221|  * 配列を再帰的に上書きする
   222|  * 二つまで
   223|  * @param array $a
   224|  * @param array $b
   225|  * @return    array
   226|  */
   227| function amr($a, $b)
   228| {
   229|     foreach($b as $k => $v) {
   230|         if (is_array($v)) {
   231|             if (isset($a[$k])) {
   232|                 $a[$k] = amr($a[$k], $v);
   233|                 continue;
   234|             }
   235|         }
   236|         if (!is_array($a)) {
   237|             $a = [$a];
   238|         }
   239|         $a[$k] = $v;
   240|     }
   241|     return $a;
   242| }
   243| /**
   244|  * 利用可能なプラグインのリストを取得する
   245|  *
   246|  * ClassRegistry::removeObject('Plugin'); で一旦 Plugin オブジェクトを削除
   247|  * エラーの際も呼び出される事があるので、テーブルが実際に存在するかチェックする
   248|  *
   249|  * @return array
   250|  */
   251| function getEnablePlugins()
   252| {
   253|     $enablePlugins = [];
   254|     if (!Configure::read('Cache.disable') && Configure::read('debug') == 0) {
   255|         $enablePlugins = Cache::read('enable_plugins', '_bc_env_');
   256|     }
   257|     if (!$enablePlugins) {
   258|         try {
   259|             $Plugin = ClassRegistry::init('Plugin');   // ConnectionManager の前に呼出さないとエラーとなる
   260|         } catch (Exception $ex) {
   261|             return [];
   262|         }
   263|         $db = ConnectionManager::getDataSource('default');
   264|         $sources = $db->listSources();
   265|         $pluginTable = $db->config['prefix'] . 'plugins';
   266|         $enablePlugins = [];
   267|         if (!is_array($sources) || in_array(strtolower($pluginTable), array_map('strtolower', $sources))) {
   268|             $enablePlugins = $Plugin->find('all', ['conditions' => ['Plugin.status' => true], 'order' => 'Plugin.priority']);
   269|             ClassRegistry::removeObject('Plugin');
   270|             if ($enablePlugins) {
   271|                 foreach($enablePlugins as $key => $enablePlugin) {
   272|                     $pluginExists = false;
   273|                     foreach(App::path('plugins') as $path) {
   274|                         if (is_dir($path . $enablePlugin['Plugin']['name'])) {
   275|                             $pluginExists = true;
   276|                         }
   277|                         $underscored = Inflector::underscore($enablePlugin['Plugin']['name']);
   278|                         if (is_dir($path . $underscored)) {
   279|                             $pluginExists = true;
   280|                         }
   281|                     }
   282|                     if (!$pluginExists) {
   283|                         unset($enablePlugins[$key]);
   284|                     }
   285|                 }
   286|                 if (!Configure::read('Cache.disable')) {
   287|                     Cache::write('enable_plugins', $enablePlugins, '_bc_env_');
   288|                 }
   289|             }
   290|         }
   291|     }
   292|     return $enablePlugins;
   293| }
   294| /**
   295|  * アップデートのURLを記載したメールを送信する
   296|  */
   297| function sendUpdateMail()
   298| {
   299|     $bcSite = Configure::read('BcSite');
   300|     $bcSite['update_id'] = CakeText::uuid();
   301|     $SiteConfig = ClassRegistry::init('SiteConfig');
   302|     $SiteConfig->saveKeyValue(['SiteConfig' => $bcSite]);
   303|     ClassRegistry::removeObject('SiteConfig');
   304|     $BcEmail = new BcEmailComponent();
   305|     if (!empty($bcSite['mail_encode'])) {
   306|         $encode = $bcSite['mail_encode'];
   307|     } else {
   308|         $encode = 'ISO-2022-JP';
   309|     }
   310|     $BcEmail->charset = $encode;
   311|     $BcEmail->sendAs = 'text';
   312|     $BcEmail->lineLength = 105;
   313|     if (!empty($bcSite['smtp_host'])) {
   314|         $BcEmail->delivery = 'smtp';
   315|         $BcEmail->smtpOptions = ['host' => $bcSite['smtp_host'],
   316|             'port' => 25,
   317|             'timeout' => 30,
   318|             'username' => ($bcSite['smtp_user'])? $bcSite['smtp_user'] : null,
   319|             'password' => ($bcSite['smtp_password'])? $bcSite['smtp_password'] : null];
   320|     } else {
   321|         $BcEmail->delivery = "mail";
   322|     }
   323|     $BcEmail->to = $bcSite['email'];
   324|     $BcEmail->subject = __d('baser_core', 'baserCMSアップデート');
   325|     $BcEmail->from = $bcSite['name'] . ' <' . $bcSite['email'] . '>';
   326|     $message = [];
   327|     $message[] = __d('baser_core', '下記のURLよりbaserCMSのアップデートを完了してください。');
   328|     $message[] = \BaserCore\Utility\BcUtil::topLevelUrl(false) . BcUtil::baseUrl() . 'updaters/index/' . $bcSite['update_id'];
   329|     $BcEmail->send($message);
   330| }
   331| /**
   332|  * 展開出力
   333|  *
   334|  * デバッグレベルが 0 の時でも強制的に出力する
   335|  *
   336|  * @param mixed $var
   337|  * @return void
   338|  */
   339| function p($var)
   340| {
   341|     $debug = Configure::read('debug');
   342|     if ($debug < 1) {
   343|         Configure::write('debug', 1);
   344|     }
   345|     $calledFrom = debug_backtrace();
   346|     echo '<strong style="font-size:10px">' . substr(str_replace(ROOT, '', $calledFrom[0]['file']), 1) . '</strong>';
   347|     echo '<span style="font-size:10px"> (line <strong>' . $calledFrom[0]['line'] . '</strong>)</span>';
   348|     debug($var, true, false);
   349|     if ($debug < 1) {
   350|         Configure::write('debug', $debug);
   351|     }
   352| }
   353| /**
   354|  * データベースのドライバー名を取得する
   355|  *
   356|  * @param string $dbConfigKeyName
   357|  * @return string
   358|  */
   359| function getDbDriver($dbConfigKeyName = 'default')
   360| {
   361|     $db = ConnectionManager::getDataSource($dbConfigKeyName);
   362|     return $db->config['datasource'];
   363| }
   364| /**
   365|  * Constructs associative array from pairs of arguments.
   366|  *
   367|  * Example:
   368|  *
   369|  * `aa('a','b')`
   370|  *
   371|  * Would return:
   372|  *
   373|  * `array('a'=>'b')`
   374|  *
   375|  * @return array Associative array
   376|  * @link http://book.cakephp.org/view/695/aa
   377|  */
   378| function aa()
   379| {
   380|     $args = func_get_args();
   381|     $argc = count($args);
   382|     for($i = 0; $i < $argc; $i++) {
   383|         if ($i + 1 < $argc) {
   384|             $a[$args[$i]] = $args[$i + 1];
   385|         } else {
   386|             $a[$args[$i]] = null;
   387|         }
   388|         $i++;
   389|     }
   390|     return $a;
   391| }
   392| /**
   393|  * プラグインを読み込む
   394|  *
   395|  * @param string $plugin
   396|  * @return bool
   397|  */
   398| function loadPlugin($plugin, $priority)
   399| {
   400|     if (CakePlugin::loaded($plugin)) {
   401|         return true;
   402|     }
   403|     try {
   404|         CakePlugin::load($plugin);
   405|     } catch (Exception $e) {
   406|         return false;
   407|     }
   408|     $pluginPath = CakePlugin::path($plugin);
   409|     $config = [
   410|         'bootstrap' => file_exists($pluginPath . 'Config' . DS . 'bootstrap.php'),
   411|         'routes' => file_exists($pluginPath . 'Config' . DS . 'routes.php')
   412|     ];
   413|     CakePlugin::load($plugin, $config);
   414|     if (file_exists($pluginPath . 'Config' . DS . 'setting.php')) {
   415|         try {
   416|             Configure::load($plugin . '.setting');
   417|         } catch (Exception $ex) {
   418|         }
   419|     }
   420|     return true;
   421| }
   422| /**
   423|  * 後方互換のための非推奨メッセージを生成する
   424|  *
   425|  * @param string $target 非推奨の対象
   426|  * @param string $since 非推奨となったバージョン
   427|  * @param string $remove 削除予定のバージョン
   428|  * @param string $note その他特記事項
   429|  * @return string 非推奨メッセージ
   430|  */
   431| function deprecatedMessage($target, $since, $remove = null, $note = null)
   432| {
   433|     if (Configure::read('debug') == 0) {
   434|         return;
   435|     }
   436|     $message = sprintf(__d('baser_core', '%s は、バージョン %s より非推奨となりました。'), $target, $since);
   437|     if ($remove) {
   438|         $message .= sprintf(__d('baser_core', 'バージョン %s で削除される予定です。'), $remove);
   439|     }
   440|     if ($note) {
   441|         $message .= $note;
   442|     }
   443|     return $message;
   444| }
   445| /**
   446|  * パーセントエンコーディングされないURLセーフなbase64エンコード
   447|  *
   448|  * base64エンコード時でに出てくる記号 +(プラス) , /(スラッシュ) , =(イコール)
   449|  * このbase64エンコードした値をさらにURLのパラメータで使うためにURLエンコードすると
   450|  * パーセントエンコーディングされてしまいます。
   451|  * そのため、このメソッドではパーセントエンコーディングされないURLセーフな
   452|  * base64エンコードを行います。
   453|  *
   454|  * @param string $val 対象文字列
   455|  * @return string
   456|  */
   457| function base64UrlsafeEncode($val)
   458| {
   459|     $val = base64_encode($val);
   460|     return str_replace(['+', '/', '='], ['_', '-', '.'], $val);
   461| }
   462| /**
   463|  * パーセントエンコーディングされないURLセーフなbase64デコード
   464|  *
   465|  * @param string $val 対象文字列
   466|  * @return string
   467|  */
   468| function base64UrlsafeDecode($val)
   469| {
   470|     $val = str_replace(['_', '-', '.'], ['+', '/', '='], $val);
   471|     return base64_decode($val);
   472| }
   473| /**
   474|  * 時刻の有効性チェックを行う
   475|  *
   476|  * @param $hour
   477|  * @param $min
   478|  * @param $sec
   479|  * @return bool
   480|  */
   481| function checktime($hour, $min, $sec = null)
   482| {
   483|     $hour = (int)$hour;
   484|     if ($hour < 0 || $hour > 23) {
   485|         return false;
   486|     }
   487|     $min = (int)$min;
   488|     if ($min < 0 || $min > 59) {
   489|         return false;
   490|     }
   491|     if ($sec) {
   492|         $sec = (int)$sec;
   493|         if ($sec < 0 || $sec > 59) {
   494|             return false;
   495|         }
   496|     }
   497|     return true;
   498| }


# ====================================================================
# FILE: __assets/plugins/bc-admin-third/templates/Admin/element/footer-4.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @package         Baser.View
     9|  * @since           baserCMS v 2.0.0
    10|  * @license         https://basercms.net/license/index.html
    11|  */
    12| /**
    13|  * [ADMIN] フッター
    14|  */
    15| ?>
    16| <div id="Footer" class="bca-footer"
    17|      data-loggedin="<?php if (BcUtil::isAdminUser()): ?>true<?php else: ?>false<?php endif; ?>">
    18|   <?php if (BcUtil::isAdminUser()): //ログイン後 ?>
    19|     <div class="bca-footer__inner--full">
    20|       <div class="bca-footer__main">
    21|         <div class="bca-footer__baser-version">baserCMS <strong><?php echo h($baserVersion) ?></strong></div>
    22|         <ul class="bca-footer__banner">
    23|           <li
    24|             class="bca-footer__banner__item"><?php $this->BcBaser->link($this->BcBaser->getImg('baser.power.gif', ['alt' => 'baserCMS Power']), 'https://basercms.net/', ['target' => '_blank', 'title' => 'baserCMS Power']) ?></li>
    25|           <li
    26|             class="bca-footer__banner__item"><?php $this->BcBaser->link($this->BcBaser->getImg('cake.power.gif', ['alt' => 'CakePHP Power']), 'https://cakephp.org/', ['target' => '_blank', 'title' => 'CakePHP Power']) ?></li>
    27|         </ul>
    28|       </div>
    29|       <div class="bca-footer__sub">
    30|         <div class="bca-footer__copyright">Copyright &copy; baserCMS Users
    31|           Community <?php $this->BcBaser->copyYear(2009) ?> All rights reserved.
    32|         </div>
    33|       </div>
    34|     </div>
    35|   <?php else: //未ログイン ?>
    36|     <div class="bca-footer__inner">
    37|       <div class="bca-footer__header">
    38|         <?php $this->BcBaser->link($this->BcBaser->getImg('admin/logo_icon.svg', ['alt' => '', 'class' => 'bca-footer__logo']), ['controller' => 'dashboard', 'action' => 'index']) ?>
    39|         <div class="bca-footer__baser-version">baserCMS</div>
    40|       </div>
    41|       <ul class="bca-footer__sns">
    42|         <li class="bca-footer__sns__item"><a href="http://www.facebook.com/basercms" target="_blank"
    43|                                              class="bca-footer__sns__link bca-footer__sns__link--facebook">Facebook</a>
    44|         </li>
    45|         <li class="bca-footer__sns__item"><a href="http://twitter.com/basercms" target="_blank"
    46|                                              class="bca-footer__sns__link bca-footer__sns__link--twitter">Twitter</a>
    47|         </li>
    48|       </ul>
    49|       <ul class="bca-footer__links">
    50|         <li class="bca-footer__links__item"><a href="https://basercms.net/"
    51|                                                target="_blank"><?php echo __d('baser_core', 'baserCMS 公式サイト') ?></a>
    52|         </li>
    53|         <li class="bca-footer__links__item"><a href="https://basercms.net/community/index"
    54|                                                target="_blank"><?php echo __d('baser_core', 'baserCMS ユーザーコミュニティ') ?></a>
    55|         </li>
    56|         <li class="bca-footer__links__item"><a href="https://forum.basercms.net/"
    57|                                                target="_blank"><?php echo __d('baser_core', 'baserCMS ユーザーズフォーラム') ?></a>
    58|         </li>
    59|         <li class="bca-footer__links__item"><a href="https://github.com/baserproject/basercms"
    60|                                                target="_blank"><?php echo __d('baser_core', 'baserCMS GitHub') ?></a>
    61|         </li>
    62|       </ul>
    63|       <ul class="bca-footer__banner">
    64|         <li
    65|           class="bca-footer__banner__item"><?php $this->BcBaser->link($this->BcBaser->getImg('baser.power.gif', ['alt' => 'baserCMS Power']), 'https://basercms.net/', ['target' => '_blank', 'title' => 'baserCMS Power']) ?></li>
    66|         <li
    67|           class="bca-footer__banner__item"><?php $this->BcBaser->link($this->BcBaser->getImg('cake.power.gif', ['alt' => 'CakePHP Power']), 'https://cakephp.org/', ['target' => '_blank', 'title' => 'CakePHP Power']) ?></li>
    68|       </ul>
    69|       <div class="bca-footer__copyright">Copyright &copy; baserCMS Users
    70|         Community <?php $this->BcBaser->copyYear(2009) ?> All rights reserved.
    71|       </div>
    72|     </div>
    73|   <?php endif; ?>
    74|   <!-- / #Footer --></div>


# ====================================================================
# FILE: __assets/plugins/bc-blog/config/init.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @package         Blog.Config
     9|  * @since           baserCMS v 0.1.0
    10|  * @license         https://basercms.net/license/index.html
    11|  */
    12| /**
    13|  * ブログインストーラー
    14|  *
    15|  * @package            Blog.Config
    16|  */
    17| /**
    18|  * データベース初期化
    19|  */
    20| $this->Plugin->initDb('BcBlog');
    21| /**
    22|  * ブログ記事の投稿日を更新
    23|  */
    24| $BlogPost = ClassRegistry::init('BcBlog.BlogPost');
    25| $BlogPost->contentSaving = false;
    26| $datas = $BlogPost->find('all', ['recursive' => -1]);
    27| if ($datas) {
    28|     $ret = true;
    29|     foreach ($datas as $data) {
    30|         $data['BlogPost']['posts_date'] = date('Y-m-d H:i:s');
    31|         unset($data['BlogPost']['eye_catch']);
    32|         $BlogPost->set($data);
    33|         if (!$BlogPost->save($data)) {
    34|             $ret = false;
    35|         }
    36|     }
    37| }


# ====================================================================
# FILE: __assets/plugins/bc-mail/config/init.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @package         Mail.Config
     9|  * @since           baserCMS v 0.1.0
    10|  * @license         https://basercms.net/license/index.html
    11|  */
    12| /**
    13|  * データベース初期化
    14|  */
    15| $this->Plugin->initDb('BcMail');
    16| /**
    17|  * メッセージテーブル構築
    18|  */
    19| App::uses('MailMessage', 'BcMail.Model');
    20| $MailMessage = new MailMessage();
    21| $MailMessage->reconstructionAll();
    22| /**
    23|  * 必要フォルダ初期化
    24|  */
    25| $filesPath = WWW_ROOT . 'files';
    26| $savePath = $filesPath . DS . 'mail';
    27| $limitedPath = $savePath . DS . 'limited';
    28| if (is_writable($filesPath) && !is_dir($savePath)) {
    29|     mkdir($savePath);
    30| }
    31| if (!is_writable($savePath)) {
    32|     chmod($savePath, 0777);
    33| }
    34| if (is_writable($savePath) && !is_dir($limitedPath)) {
    35|     mkdir($limitedPath);
    36| }
    37| if (!is_writable($limitedPath)) {
    38|     chmod($limitedPath, 0777);
    39| }
    40| if (is_writable($limitedPath)) {
    41|     $File = new File($limitedPath . DS . '.htaccess');
    42|     $htaccess = "Order allow,deny\nDeny from all";
    43|     $File->write($htaccess);
    44|     $File->close();
    45| }


# ====================================================================
# FILE: __assets/plugins/bc-uploader/config/init.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| <?php
     2| /**
     3|  * baserCMS :  Based Website Development Project <https://basercms.net>
     4|  * Copyright (c) baserCMS Users Community <https://basercms.net/community/>
     5|  *
     6|  * @copyright       Copyright (c) baserCMS Users Community
     7|  * @link            https://basercms.net baserCMS Project
     8|  * @package         Uploader.Config
     9|  * @since           baserCMS v 3.0.10
    10|  * @license         https://basercms.net/license/index.html
    11|  */
    12| /**
    13|  * データベース初期化
    14|  */
    15| $this->Plugin->initDb('BcUploader');
    16| /**
    17|  * 必要フォルダ初期化
    18|  */
    19| $filesPath = WWW_ROOT . 'files';
    20| $savePath = $filesPath . DS . 'uploads';
    21| $limitedPath = $savePath . DS . 'limited';
    22| if (is_writable($filesPath) && !is_dir($savePath)) {
    23|     mkdir($savePath);
    24| }
    25| if (!is_writable($savePath)) {
    26|     chmod($savePath, 0777);
    27| }
    28| if (is_writable($savePath) && !is_dir($limitedPath)) {
    29|     mkdir($limitedPath);
    30| }
    31| if (!is_writable($limitedPath)) {
    32|     chmod($limitedPath, 0777);
    33| }
    34| if (is_writable($limitedPath)) {
    35|     $File = new File($limitedPath . DS . '.htaccess');
    36|     $htaccess = "Order allow,deny\nDeny from all";
    37|     $File->write($htaccess);
    38|     $File->close();
    39| }

