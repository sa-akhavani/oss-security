# ====================================================================
# FILE: lib/jamf.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| require 'English'
     2| require 'json'
     3| require 'yaml'
     4| require 'pathname'
     5| require 'time'
     6| require 'singleton'
     7| require 'open-uri'
     8| require 'ipaddr'
     9| require 'base64'
    10| require 'shellwords'
    11| require 'digest'
    12| require 'open3'
    13| require 'plist'
    14| require 'immutable-struct'
    15| require 'jamf/configuration'
    16| require 'jamf/exceptions'
    17| require 'jamf/utility'
    18| require 'jamf/validate'
    19| require 'jamf/version'
    20| require 'jamf/compatibility'
    21| require 'jamf/ruby_extensions'
    22| require 'jamf/api/connection'
    23| module Jamf
    24|   MINIMUM_RUBY_VERSION = '2.3'.freeze
    25|   if Gem::Version.new(RUBY_VERSION) < Gem::Version.new(MINIMUM_RUBY_VERSION)
    26|     raise "Can't use the JAMF module, ruby itself must be version #{MINIMUM_RUBY_VERSION} or greater."
    27|   end
    28|   autoload :JSONObject, 'jamf/api/base_classes/json_object'
    29|   autoload :Resource, 'jamf/api/base_classes/resource'
    30|   autoload :SingletonResource, 'jamf/api/base_classes/singleton_resource'
    31|   autoload :CollectionResource, 'jamf/api/base_classes/collection_resource'
    32|   autoload :Prestage, 'jamf/api/base_classes/prestage'
    33|   autoload :ChangeLog, 'jamf/api/mixins/change_log'


# ====================================================================
# FILE: lib/jamf/client.rb
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 36-124 ---
    36|       @url =~ %r{(https?)://(.+):(\d+)/}
    37|       @protocol = Regexp.last_match(1)
    38|       @server = Regexp.last_match(2)
    39|       @port = Regexp.last_match(3)
    40|       @url
    41|     end
    42|     def self.jss_server
    43|       jss_url
    44|       @server
    45|     end
    46|     def self.jss_protocol
    47|       jss_url
    48|       @protocol
    49|     end
    50|     def self.jss_port
    51|       jss_url
    52|       @port
    53|     end
    54|     def self.jamf_plist
    55|       return {} unless JAMF_PLIST.file?
    56|       JSS.parse_plist JAMF_PLIST
    57|     end
    58|     def self.receipts
    59|       raise JSS::NoSuchItemError, "The JAMF Receipts folder doesn't exist on this computer." unless RECEIPTS_FOLDER.exist?
    60|       RECEIPTS_FOLDER.children.select(&:file?)
    61|     end
    62|     def self.jss_available?
    63|       run_jamf :checkJSSConnection, '-retry 1'
    64|       $CHILD_STATUS.exitstatus.zero?
    65|     end
    66|     def self.jss_record
    67|       JSS::Computer.fetch udid: udid
    68|     rescue JSS::NoSuchItemError
    69|       nil
    70|     end
    71|     def self.udid
    72|       hardware_data['platform_UUID']
    73|     end
    74|     def self.serial_number
    75|       hardware_data['serial_number']
    76|     end
    77|     def self.hardware_data
    78|       raw = `/usr/sbin/system_profiler SPHardwareDataType -xml 2>/dev/null`
    79|       JSS.parse_plist(raw)[0]['_items'][0]
    80|     end
    81|     def self.console_users
    82|       output = `#{CONSOLE_USERS_SCUTIL_CMD}`
    83|       userlines = output.lines.select { |l| l =~ /SessionUserNameKey\s*:/ }
    84|       userlines.map! { |ul| ul.split(':').last.strip }
    85|       userlines.reject { |un| un == ROOT_USER }
    86|     end
    87|     def self.primary_console_user
    88|       `#{CONSOLE_USERS_SCUTIL_CMD}` =~ /^\s*Name : (\S+)$/
    89|       user = Regexp.last_match(1)
    90|       user == LOGINWINDOW_USER ? nil : user
    91|     end
    92|     def self.console_user
    93|       primary_console_user
    94|     end
    95|     def self.self_service_users
    96|       ss_userlines = `#{PS_USER_COMM}`.lines.select { |l| l.include? SELF_SERVICE_EXECUTABLE_END }
    97|       ss_userlines.map { |ssl| ssl.split(' ').first }
    98|     end
    99|     def self.do_not_disturb?(user = nil)
   100|       home = user ? homedir(user) : Dir.home
   101|       myudid = udid
   102|       nc_prefs_file = Pathname.new "#{home}/#{USER_PREFS_BYHOST_FOLDER}/com.apple.notificationcenterui.#{myudid}.plist"
   103|       return nil unless nc_prefs_file.readable?
   104|       JSS.parse_plist(nc_prefs_file)['doNotDisturb']
   105|     end
   106|     def self.homedir(user)
   107|       dir = `/usr/bin/dscl . -read /Users/#{user} NFSHomeDirectory 2>/dev/null`.chomp.split(': ').last
   108|       dir ? Pathname.new(dir) : nil
   109|     end
   110|     def self.script_running_via_policy?
   111|       root_ps_lines = `ps -u root -x -o pid -o ppid -o user -o command`.lines
   112|       parent_pid, _parent_user, parent_command = parent_pid_user_and_cmd Process.pid, root_ps_lines
   113|       return false unless parent_pid
   114|       until parent_command =~ POLICY_SCRIPT_CMD_RE || parent_pid.nil?
   115|         parent_pid, _parent_user, parent_command = parent_pid_user_and_cmd parent_pid, root_ps_lines
   116|         return false if parent_pid.zero?
   117|       end
   118|       return false if parent_pid.nil?
   119|       until parent_command =~ POLICY_CMD_RE || parent_pid.nil?
   120|         parent_pid, _parent_user, parent_command = parent_pid_user_and_cmd parent_pid, root_ps_lines
   121|         return false if parent_pid.zero?
   122|       end
   123|       !parent_pid.nil?
   124|     end


# ====================================================================
# FILE: lib/jamf/client/management_action.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 14-48 ---
    14|       management_action(msg, title: title, subtitle: subtitle, delay: delay)
    15|     end
    16|     private_class_method
    17|     def self.force_alerts
    18|       orig_flags = {}
    19|       console_users.each do |user|
    20|         orig_flags[user] = set_mgmt_action_ncprefs_flags user, NC_ALERT_STYLE_FLAGS, hup: false
    21|       end
    22|       system HUP_NOTIF_CTR_CMD unless orig_flags.empty?
    23|       sleep 1
    24|       orig_flags
    25|     end
    26|     def self.restore_alerts(orig_flags)
    27|       orig_flags.each do |user, flags|
    28|         set_mgmt_action_ncprefs_flags user, flags, hup: false
    29|       end
    30|       system HUP_NOTIF_CTR_CMD unless orig_flags.empty?
    31|     end
    32|     def self.set_mgmt_action_ncprefs_flags(user, flags, hup: true)
    33|       plist = Pathname.new "/Users/#{user}/Library/Preferences/#{NCPREFS_DOMAIN}.plist"
    34|       prefs = JSS.parse_plist plist
    35|       mgmt_action_setting = prefs['apps'].select { |a| a['bundle-id'] == MGMT_ACTION_BUNDLE_ID }.first
    36|       if mgmt_action_setting
    37|         orig_flags = mgmt_action_setting['flags']
    38|         mgmt_action_setting['flags'] = flags
    39|       else
    40|         orig_flags = flags
    41|         prefs['apps'] << { 'bundle-id' => MGMT_ACTION_BUNDLE_ID, 'flags' => flags }
    42|       end
    43|       plist.open('w') { |f| f.write prefs.to_plist }
    44|       system HUP_NOTIF_CTR_CMD if hup
    45|       orig_flags
    46|     end
    47|   end # class Client
    48| end # module


# ====================================================================
# FILE: lib/jamf/composer.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 5-56 ---
     5|     PKG_BUNDLE_ID_PFX = 'ruby-jss-composer'.freeze
     6|     HDI_UTIL = '/usr/bin/hdiutil'.freeze
     7|     DEFAULT_OUT_DIR = Pathname.new '/Users/Shared'
     8|     def self.mk_pkg(name, version, root, opts = {})
     9|       raise NoSuchItemError, "Missing pkgbuild tool. Please make sure you're running 10.8 or later." unless PKGBUILD.executable?
    10|       opts[:out_dir] ||= DEFAULT_OUT_DIR
    11|       opts[:bundle_id_prefix] ||= PKG_BUNDLE_ID_PFX
    12|       pkg_filename = name.end_with?('.pkg') ? name : name + '.pkg'
    13|       pkg_id = opts[:pkg_id]
    14|       pkg_id ||= opts[:bundle_id_prefix] + '.' + name
    15|       pkg_out = "#{opts[:out_dir]}/#{pkg_filename}"
    16|       pkg_ownership = opts[:preserve_ownership] ? 'preserve' : 'recommended'
    17|       if opts[:signing_identity]
    18|         signing = "--sign '#{opts[:signing_identity]}'"
    19|         signing << " #{opts[:signing_options]}" if opts[:signing_options]
    20|       else
    21|         signing = ''
    22|       end # if opts[:signing_identity]
    23|       comp_plist_out = Pathname.new "/tmp/#{PKG_BUNDLE_ID_PFX}-#{pkg_filename}.plist"
    24|       system "#{PKGBUILD} --analyze --root '#{root}' '#{comp_plist_out}'"
    25|       comp_plist = Plist.parse_xml comp_plist_out.read
    26|       if comp_plist[0].nil?
    27|         comp_plist_arg = ''
    28|       else
    29|         comp_plist.each do |bndl|
    30|           bndl.delete 'ChildBundles' if bndl['ChildBundles']
    31|           bndl['BundleOverwriteAction'] = 'upgrade'
    32|           bndl['BundleIsVersionChecked'] = false
    33|           bndl['BundleIsRelocatable'] = false
    34|           bndl['BundleHasStrictIdentifier'] = false
    35|         end
    36|         comp_plist_out.open('w') { |f| f.write comp_plist.to_plist }
    37|         comp_plist_arg = "--component-plist '#{comp_plist_out}'"
    38|       end
    39|       begin
    40|         it_built = system "#{PKGBUILD} --identifier '#{pkg_id}' --version '#{version}' --ownership #{pkg_ownership} --install-location / --root '#{root}' #{signing} #{comp_plist_arg} '#{pkg_out}' "
    41|         raise 'There was an error building the .pkg' unless it_built
    42|       ensure
    43|         comp_plist_out.delete if comp_plist_out.exist?
    44|       end
    45|       Pathname.new pkg_out
    46|     end # mk_dot_pkg
    47|     def self.mk_dmg(name, root, out_dir = DEFAULT_OUT_DIR)
    48|       dmg_filename = "#{name}.dmg"
    49|       dmg_vol = name
    50|       dmg_out = Pathname.new "#{out_dir}/#{dmg_filename}"
    51|       if dmg_out.exist?
    52|         mv_to = dmg_out.dirname + "#{dmg_out.basename}.#{Time.now.strftime('%Y%m%d%H%M%S')}"
    53|         dmg_out.rename mv_to
    54|       end # if dmg out exist
    55|       system "#{HDI_UTIL} create -volname '#{dmg_vol}' -scrub -srcfolder '#{root}' '#{dmg_out}'"
    56|       raise 'There was an error building the .dmg' unless $?.exitstatus.zero?


# ====================================================================
# FILE: lib/jamf/utility.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 40-92 ---
    40|     end
    41|     req_regexps.each { |re| return true if os_to_check =~ re }
    42|     false
    43|   end
    44|   def self.to_s_and_a(somedata)
    45|     case somedata
    46|     when nil
    47|       valstr = ''
    48|       valarr = []
    49|     when String
    50|       valstr = somedata
    51|       valarr = somedata.split(/,\s*/)
    52|     when Array
    53|       valstr = somedata.join ', '
    54|       valarr = somedata
    55|     else
    56|       raise Jamf::InvalidDataError, 'Input must be a comma-separated String or an Array of Strings'
    57|     end # case
    58|     { stringform: valstr, arrayform: valarr }
    59|   end # to_s_and_a
    60|   def self.parse_plist(plist)
    61|     case plist
    62|     when String
    63|       return Plist.parse_xml plist if plist.include? '</plist>'
    64|       plist = Pathname.new plist
    65|     when Pathname
    66|       true
    67|     else
    68|       raise ArgumentError, 'Argument must be a path (as a Pathname or String) or a String of XML'
    69|     end # case plist
    70|     raise Jamf::MissingDataError, "No such file: #{plist}" unless plist.file?
    71|     Plist.parse_xml `/usr/libexec/PlistBuddy -x -c print #{Shellwords.escape(plist.to_s)}`.force_encoding('UTF-8')
    72|   end # parse_plist
    73|   def self.parse_time(a_datetime)
    74|     return nil if NIL_DATES.include? a_datetime
    75|     the_dt = DateTime.parse(a_datetime.to_s)
    76|     usec = (the_dt.sec_fraction * 60 * 60 * 24 * (10**6)).to_i
    77|     the_dt = DateTime.new(the_dt.year, the_dt.month, the_dt.day, the_dt.hour, the_dt.min, the_dt.sec, Jamf::TIME_ZONE_OFFSET) if the_dt.offset.zero?
    78|     Time.at the_dt.strftime('%s').to_i, usec
    79|   end # parse_time
    80|   def self.epoch_to_time(epoch)
    81|     return nil if NIL_DATES.include? epoch
    82|     Time.at(epoch.to_i / 1000.0)
    83|   end # parse_date
    84|   def self.api_object_class(name)
    85|     klass = api_object_names[name.downcase.to_sym]
    86|     raise Jamf::InvalidDataError, "Unknown API Object Class: #{name}" unless klass
    87|     klass
    88|   end
    89|   def self.api_object_names
    90|     return @api_object_names if @api_object_names
    91|     @api_object_names ||= {}
    92|     JSS.constants.each do |const|


# ====================================================================
# FILE: lib/jss.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|   if Gem::Version.new(RUBY_VERSION) < Gem::Version.new(MINIMUM_RUBY_VERSION)
     4|     raise "Can't use the JSS module, ruby itself must be version #{MINIMUM_RUBY_VERSION} or greater."
     5|   end
     6|   require 'date'
     7|   require 'singleton'
     8|   require 'pathname'
     9|   require 'fileutils'
    10|   require 'open-uri'
    11|   require 'ipaddr'
    12|   require 'rexml/document'
    13|   require 'base64'
    14|   require 'shellwords'
    15|   require 'digest'
    16|   require 'yaml'
    17|   require 'open3'
    18|   require 'English'
    19|   require 'json'
    20|   require 'digest'
    21|   require 'faraday'
    22|   require 'faraday_middleware'
    23|   require 'plist'
    24|   require 'immutable-struct'
    25|   require 'recursive-open-struct'
    26|   MINIMUM_SERVER_VERSION = '10.4.0'.freeze
    27|   TIME_ZONE_OFFSET =  Rational(Time.now.utc_offset, 60 * 60 * 24)
    28|   TRUE_FALSE = [true, false].freeze
    29|   NIL_DATES = [0, nil, '', '0'].freeze
    30|   BLANK = ''.freeze
    31|   @@stdin_lines = nil
    32|   module Composer; end
    33|   module Creatable; end
    34|   module FileUpload; end
    35|   module Locatable; end
    36|   module Matchable; end
    37|   module Purchasable; end
    38|   module Updatable; end
    39|   module Extendable; end
    40|   module SelfServable; end
    41|   module Categorizable; end
    42|   module VPPable; end
    43|   module Sitable; end


# ====================================================================
# FILE: lib/jss/api_connection.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 251-290 ---
   251|       if SSL_PORTS.include? args[:port]
   252|         args[:use_ssl] = true unless args[:use_ssl] == false
   253|       end
   254|       return unless args[:use_ssl]
   255|       args[:verify_ssl] = args[:verify_cert] != false
   256|       args[:ssl_version] ||= DFT_SSL_VERSION
   257|       @ssl_options = {
   258|         verify: args[:verify_ssl],
   259|         version: args[:ssl_version]
   260|       }
   261|     end
   262|     def handle_http_error
   263|       return if @last_http_response.success?
   264|       case @last_http_response.status
   265|       when 404
   266|         err = JSS::NoSuchItemError
   267|         msg = 'Not Found'
   268|       when 409
   269|         err = JSS::ConflictError
   270|         @last_http_response.body =~ /<p>(The server has not .*?)(<|$)/m
   271|         msg = Regexp.last_match(1)
   272|       when 400
   273|         err = JSS::BadRequestError
   274|         @last_http_response.body =~ %r{>Bad Request</p>\n<p>(.*?)</p>\n<p>You can get technical detail}m
   275|         msg = Regexp.last_match(1)
   276|       when 401
   277|         err = JSS::AuthorizationError
   278|         msg = 'You are not authorized to do that.'
   279|       when (500..599)
   280|         err = JSS::APIRequestError
   281|         msg = 'There was an internal server error'
   282|       else
   283|         err = JSS::APIRequestError
   284|         msg = "There was a error processing your request, status: #{@last_http_response.status}"
   285|       end
   286|       raise err, msg
   287|     end
   288|     def create_connection(pw)
   289|       Faraday.new(@rest_url, ssl: @ssl_options) do |cnx|
   290|         cnx.basic_auth @user, pw


# ====================================================================
# FILE: lib/jss/api_object/configuration_profile.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 14-62 ---
    14|     CATEGORY_SUBSET = :general
    15|     CATEGORY_DATA_TYPE = Hash
    16|     attr_reader :description
    17|     attr_reader :uuid
    18|     attr_reader :redeploy_on_update
    19|     attr_reader :payloads
    20|     def initialize(args = {})
    21|       super
    22|       @description = @main_subset[:description]
    23|       @uuid = @main_subset[:uuid]
    24|       @redeploy_on_update = @main_subset[:redeploy_on_update]
    25|       @payloads = @main_subset[:payloads]
    26|     end
    27|     def description=(new_val)
    28|       new_val = new_val.strip
    29|       return nil if @self_service_description == new_val
    30|       @description = new_val
    31|       @need_to_update = true
    32|     end # @param new_val[String] how should this be distributed to clients?
    33|     def parsed_payloads
    34|       Plist.parse_xml @payloads
    35|     end
    36|     def payload_content
    37|       parsed_payloads['PayloadContent']
    38|     end
    39|     def payload_content=(new_content)
    40|       payload_plist_data = parsed_payloads
    41|       payload_plist_data['PayloadContent'] = new_content
    42|       @payloads = payload_plist_data.to_plist
    43|       @need_to_update = true
    44|       @update_payloads = true
    45|     end
    46|     def payload_types
    47|       payload_content.map { |p| p['PayloadType'] }
    48|     end
    49|     def update(redeploy_to_all: false)
    50|       @redeploy_on_update = redeploy_to_all ? REDEPLOY_ALL : REDEPLOY_NEWLY_ASSIGNED
    51|       super()
    52|       @redeploy_on_update = REDEPLOY_NEWLY_ASSIGNED
    53|       @update_payloads = nil
    54|     end
    55|     def save(redeploy_to_all: false)
    56|       if @in_jss
    57|         raise JSS::UnsupportedError, 'Updating this object in the JSS is currently not supported by ruby-jss' unless updatable?
    58|         update redeploy_to_all: redeploy_to_all
    59|       else
    60|         raise JSS::UnsupportedError, 'Creating this object in the JSS is currently not supported by ruby-jss' unless creatable?
    61|         create
    62|       end


# ====================================================================
# FILE: lib/jss/api_object/network_segment.rb
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 117-166 ---
   117|       @netboot_server = @init_data[:netboot_server]
   118|       @override_buildings = @init_data[:override_buildings]
   119|       @override_departments = @init_data[:override_departments]
   120|       @swu_server = @init_data[:swu_server]
   121|       @url = @init_data[:url]
   122|     end # init
   123|     def range
   124|       @starting_address..@ending_address
   125|     end
   126|     def overlap?(other_segment)
   127|       raise TypeError, 'Argument must be a JSS::NetworkSegment' unless \
   128|         other_segment.is_a? JSS::NetworkSegment
   129|       other_range = other_segment.range
   130|       range.include?(other_range.begin) || range.include?(other_range.end)
   131|     end
   132|     def include?(thing)
   133|       if thing.is_a? JSS::NetworkSegment
   134|         @starting_address <= thing.range.begin && @ending_address >= thing.range.end
   135|       else
   136|         thing = IPAddr.new thing.to_s
   137|         range.include? thing
   138|       end
   139|     end
   140|     def ==(other)
   141|       raise TypeError, 'Argument must be a JSS::NetworkSegment' unless \
   142|         other.is_a? JSS::NetworkSegment
   143|       range == other.range
   144|     end
   145|     def building=(newval)
   146|       new = 
   147|         if newval.to_s.empty?
   148|           JSS::BLANK
   149|         else
   150|           id = JSS::Building.valid_id newval
   151|           raise JSS::MissingDataError, "No building matching '#{newval}'" unless id
   152|           JSS::Building.map_all_ids_to(:name)[id]
   153|         end
   154|       @building = new
   155|       @need_to_update = true
   156|     end
   157|     def override_buildings=(newval)
   158|       raise JSS::InvalidDataError, 'New value must be boolean true or false' unless JSS::TRUE_FALSE.include? newval
   159|       @override_buildings = newval
   160|       @need_to_update = true
   161|     end
   162|     def department=(newval)
   163|       new =
   164|         if newval.to_s.empty?
   165|           JSS::BLANK
   166|         else

# --- HUNK 2: Lines 172-224 ---
   172|       @need_to_update = true
   173|     end
   174|     def override_departments=(newval)
   175|       raise JSS::InvalidDataError, 'New value must be boolean true or false' unless JSS::TRUE_FALSE.include? newval
   176|       @override_departments = newval
   177|       @need_to_update = true
   178|     end
   179|     def distribution_point=(newval)
   180|       new =
   181|         if newval.to_s.empty?
   182|           JSS::BLANK
   183|         else
   184|           id = JSS::DistributionPoint.valid_id newval
   185|           raise JSS::MissingDataError, "No distribution_point matching '#{newval}' in the JSS" unless id
   186|           JSS::DistributionPoint.map_all_ids_to(:name)[id]
   187|         end
   188|       @distribution_point = new
   189|       @need_to_update = true
   190|     end
   191|     def netboot_server=(newval)
   192|       new = 
   193|         if newval.to_s.empty?
   194|           JSS::BLANK
   195|         else
   196|           id = JSS::NetBootServer.valid_id newval
   197|           raise JSS::MissingDataError, "No netboot_server matching '#{newval}' in the JSS" unless id
   198|           JSS::NetbootServer.map_all_ids_to(:name)[id]
   199|         end
   200|       @netboot_server = new
   201|       @need_to_update = true
   202|     end
   203|     def swu_server=(newval)
   204|       new = 
   205|         if newval.to_s.empty?
   206|           JSS::BLANK
   207|         else
   208|           id = JSS::SoftwareUpdateServer.valid_id newval
   209|           raise JSS::MissingDataError, "No swu_server matching '#{newval}' in the JSS" unless id
   210|           JSS::SoftwareUpdateServer.map_all_ids_to(:name)[id]
   211|         end
   212|       @swu_server = new
   213|       @need_to_update = true
   214|     end
   215|     def starting_address=(newval)
   216|       self.class.validate_ip_range(newval, @ending_address)
   217|       @starting_address = IPAddr.new newval.to_s
   218|       @need_to_update = true
   219|     end
   220|     def ending_address=(newval)
   221|       self.class.validate_ip_range(@starting_address, newval)
   222|       @ending_address = IPAddr.new newval.to_s
   223|       @need_to_update = true
   224|     end


# ====================================================================
# FILE: lib/jss/api_object/policy.rb
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 146-185 ---
   146|       0 => 'Zero',
   147|       1 => 'One',
   148|       2 => 'Two',
   149|       3 => 'Three',
   150|       6 => 'Six'
   151|     }.freeze
   152|     LOG_FLUSH_INTERVAL_PERIODS = {
   153|       day: 'Days',
   154|       days: 'Days',
   155|       week: 'Weeks',
   156|       weeks: 'Weeks',
   157|       month: 'Months',
   158|       months: 'Months',
   159|       year: 'Years',
   160|       years: 'Years'
   161|     }.freeze
   162|     OBJECT_HISTORY_OBJECT_TYPE = 3
   163|     SITE_SUBSET = :general
   164|     CATEGORY_SUBSET = :general
   165|     CATEGORY_DATA_TYPE = Hash
   166|     def self.flush_logs(policy, older_than: 0, period: :days, computers: [], api: JSS.api)
   167|       orig_timeout = api.cnx.options.timeout
   168|       pol_id = valid_id policy
   169|       raise JSS::NoSuchItemError, "No Policy identified by '#{policy}'." unless pol_id
   170|       older_than = LOG_FLUSH_INTERVAL_INTEGERS[older_than]
   171|       raise JSS::InvalidDataError, "older_than must be one of these integers: #{LOG_FLUSH_INTERVAL_INTEGERS.keys.join ', '}" unless older_than
   172|       period = LOG_FLUSH_INTERVAL_PERIODS[period]
   173|       raise JSS::InvalidDataError, "period must be one of these symbols: :#{LOG_FLUSH_INTERVAL_PERIODS.keys.join ', :'}" unless period
   174|       computers = [computers] unless computers.is_a? Array
   175|       api.timeout = 1800 unless orig_timeout && orig_timeout > 1800
   176|       return api.delete_rsrc "#{LOG_FLUSH_RSRC}/policy/id/#{pol_id}/interval/#{older_than}+#{period}" if computers.empty?
   177|       flush_logs_for_specific_computers pol_id, older_than, period, computers, api
   178|     ensure
   179|       api.timeout = orig_timeout
   180|     end
   181|     def self.flush_logs_for_specific_computers(pol_id, older_than, period, computers, api)
   182|       xml_doc = REXML::Document.new JSS::APIConnection::XML_HEADER
   183|       lf = xml_doc.add_element 'logflush'
   184|       lf.add_element('log').text = 'policy'
   185|       lf.add_element('log_id').text = pol_id.to_s

# --- HUNK 2: Lines 610-649 ---
   610|         name: name,
   611|         priority: SCRIPT_PRIORITIES[opts[:priority]],
   612|         parameter4: opts[:parameter4],
   613|         parameter5: opts[:parameter5],
   614|         parameter6: opts[:parameter6],
   615|         parameter7: opts[:parameter7],
   616|         parameter8: opts[:parameter8],
   617|         parameter9: opts[:parameter9],
   618|         parameter10: opts[:parameter10],
   619|         parameter11: opts[:parameter11]
   620|       }
   621|       @scripts.insert opts[:position], script_data
   622|       @need_to_update = true
   623|       @scripts
   624|     end
   625|     def remove_script(identifier)
   626|       removed = @scripts.delete_if { |s| s[:id] == identifier || s[:name] == identifier }
   627|       @need_to_update = true if removed
   628|       removed
   629|     end
   630|     def directory_binding_ids
   631|       @directory_bindings.map { |p| p[:id] }
   632|     end
   633|     def directory_binding_names
   634|       @directory_bindings.map { |p| p[:name] }
   635|     end
   636|     def add_directory_binding(identifier, **opts)
   637|       id = validate_directory_binding_opts identifier, opts
   638|       return nil if @directory_bindings.map { |s| s[:id] }.include? id
   639|       name = JSS::DirectoryBinding.map_all_ids_to(:name, api: @api)[id]
   640|       directory_binding_data = {
   641|         id: id,
   642|         name: name
   643|       }
   644|       @directory_bindings.insert opts[:position], directory_binding_data
   645|       @need_to_update = true
   646|       @directory_bindings
   647|     end
   648|     def remove_directory_binding(identifier)
   649|       removed = @directory_bindings.delete_if { |s| s[:id] == identifier || s[:name] == identifier }


# ====================================================================
# FILE: lib/jss/api_object/script.rb
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 2-51 ---
     2|   class Script < JSS::APIObject
     3|     include JSS::Creatable
     4|     include JSS::Updatable
     5|     include JSS::Categorizable
     6|     RSRC_BASE = 'scripts'.freeze
     7|     RSRC_LIST_KEY = :scripts
     8|     RSRC_OBJECT_KEY = :script
     9|     DIST_POINT_SCRIPTS_FOLDER = 'Scripts'.freeze
    10|     PRIORITIES = ['Before', 'After', 'At Reboot'].freeze
    11|     DEFAULT_PRIORITY = 'After'.freeze
    12|     PARAMETER_KEYS = [:parameter4, :parameter5, :parameter6, :parameter7, :parameter8, :parameter9, :parameter10, :parameter11].freeze
    13|     OBJECT_HISTORY_OBJECT_TYPE = 91
    14|     CATEGORY_SUBSET = :top
    15|     CATEGORY_DATA_TYPE = String
    16|     attr_reader :filename
    17|     attr_reader :os_requirements
    18|     attr_reader :priority
    19|     attr_reader :info
    20|     attr_reader :notes
    21|     attr_reader :parameters
    22|     attr_reader :script_contents
    23|     def initialize(args = {})
    24|       super
    25|       @filename = @init_data[:filename] || @name
    26|       @info = @init_data[:info]
    27|       @notes = @init_data[:notes]
    28|       @os_requirements = @init_data[:os_requirements] ? JSS.to_s_and_a(@init_data[:os_requirements])[:arrayform] : []
    29|       @parameters = @init_data[:parameters] ? @init_data[:parameters] : {}
    30|       @priority = @init_data[:priority] || DEFAULT_PRIORITY
    31|       @script_contents = @init_data[:script_contents]
    32|     end # initialize
    33|     def filename=(new_val)
    34|       new_val = nil if new_val == ''
    35|       new_val = @name unless new_val
    36|       return nil if new_val == @filename
    37|       @filename = new_val
    38|       @need_to_update = true
    39|     end # filename=
    40|     def name=(new_val)
    41|       new_val = new_val.to_s
    42|       return if new_val == @name
    43|       raise JSS::MissingDataError, "Name can't be empty" if new_val.empty?
    44|       raise JSS::AlreadyExistsError, "A script already exists with the name '#{new_val}'" if JSS::Script.all_names.include? new_val
    45|       @filename = new_val if @filename == @name
    46|       @name = new_val
    47|       @rest_rsrc = "#{RSRC_BASE}/name/#{CGI.escape @name.to_s}" if @rest_rsrc.include? '/name/'
    48|       @need_to_update = true
    49|     end # name=
    50|     def os_requirements=(new_val)
    51|       new_val = [] if new_val.to_s.empty?

# --- HUNK 2: Lines 83-230 ---
    83|     end # notes=
    84|     def parameters=(new_val)
    85|       return nil if new_val == @parameters
    86|       new_val = {} if new_val.nil? || (new_val == '')
    87|       raise JSS::InvalidDataError, ':parameters must be a Hash with keys :parameter4 thru :parameter11' unless \
    88|         new_val.is_a?(Hash) && ((new_val.keys & PARAMETER_KEYS) == new_val.keys)
    89|       new_val.each do |_k, v|
    90|         raise JSS::InvalidDataError, ':parameter values must be strings or nil' unless v.nil? || v.is_a?(String)
    91|       end
    92|       @parameters = new_val
    93|       @need_to_update = true
    94|     end # parameters=
    95|     def set_parameter(param_num, new_val)
    96|       raise JSS::NoSuchItemError, 'Parameter numbers must be from 4-11' unless (4..11).cover? param_num
    97|       pkey = "parameter#{param_num}".to_sym
    98|       raise JSS::InvalidDataError, 'parameter values must be strings or nil' unless new_val.nil? || new_val.is_a?(String)
    99|       return nil if new_val == @parameters[pkey]
   100|       @parameters[pkey] = new_val
   101|       @need_to_update = true
   102|     end
   103|     def script_contents=(new_val)
   104|       new_code = case new_val
   105|                  when String
   106|                    if new_val.start_with? '/'
   107|                      Pathname.new(new_val).read
   108|                    else
   109|                      new_val
   110|                    end # if
   111|                  when Pathname
   112|                    new_val.read
   113|                  else
   114|                    raise JSS::InvalidDataError, 'New code must be a String (path or code) or Pathname instance'
   115|                  end # case
   116|       raise JSS::InvalidDataError, "Script contents must start with '#!'" unless new_code.start_with? '#!'
   117|       @script_contents = new_code
   118|       @need_to_update = true
   119|     end
   120|     def upload_master_file(rw_pw, unmount = true)
   121|       raise JSS::MissingDataError, 'No code specified. Use #code= first.' if @script_contents.nil? || @script_contents.empty?
   122|       mdp = JSS::DistributionPoint.master_distribution_point
   123|       raise JSS::InvaldDatatError, 'Incorrect password for read-write access to master distribution point.' unless mdp.check_pw :rw, rw_pw
   124|       destination = mdp.mount(rw_pw, :rw) + "#{DIST_POINT_SCRIPTS_FOLDER}/#{@filename}"
   125|       destination.save @script_contents
   126|       mdp.unmount if unmount
   127|     end # upload
   128|     def delete_master_file(rw_pw, unmount = true)
   129|       file = JSS::DistributionPoint.master_distribution_point.mount(rw_pw, :rw) + "#{DIST_POINT_SCRIPTS_FOLDER}/#{@filename}"
   130|       if file.exist?
   131|         file.delete
   132|         did_it = true
   133|       else
   134|         did_it = false
   135|       end # if exists
   136|       JSS::DistributionPoint.master_distribution_point.unmount if unmount
   137|       did_it
   138|     end
   139|     def run(opts = {})
   140|       opts[:target] ||= '/'
   141|       opts[:p1] ||= @parameters[:parameter4]
   142|       opts[:p2] ||= @parameters[:parameter5]
   143|       opts[:p3] ||= @parameters[:parameter6]
   144|       opts[:p4] ||= @parameters[:parameter7]
   145|       opts[:p5] ||= @parameters[:parameter8]
   146|       opts[:p6] ||= @parameters[:parameter9]
   147|       opts[:p7] ||= @parameters[:parameter10]
   148|       opts[:p8] ||= @parameters[:parameter11]
   149|       dp_mount_pt = nil
   150|       delete_exec = false
   151|       begin
   152|         if @script_contents && !@script_contents.empty?
   153|           script_path = JSS::Client::DOWNLOADS_FOLDER
   154|           executable = script_path + @filename
   155|           executable.jss_touch
   156|           executable.chmod 0o700
   157|           executable.jss_save @script_contents
   158|           delete_exec = true
   159|         else
   160|           dist_point = JSS::DistributionPoint.my_distribution_point api: @api
   161|           if dist_point.http_downloads_enabled
   162|             script_path = dist_point.http_url + "/#{DIST_POINT_SCRIPTS_FOLDER}/"
   163|           else
   164|             dp_mount_pt = dist_point.mount opts[:ro_pw]
   165|             script_path = (dp_mount_pt + DIST_POINT_SCRIPTS_FOLDER)
   166|           end # if http enabled
   167|         end # if @script_contents and (not @script_contents.empty?)
   168|         command_arry = ['-script', @filename, '-path', script_path.to_s]
   169|         command_arry << '-target'
   170|         command_arry << opts[:target].to_s
   171|         command_arry << '-computerName' if opts[:computer_name]
   172|         command_arry << opts[:computer_name] if opts[:computer_name]
   173|         command_arry << '-username' if opts[:username]
   174|         command_arry << opts[:username] if opts[:username]
   175|         command_arry << '-p1' if opts[:p1]
   176|         command_arry << opts[:p1] if opts[:p1]
   177|         command_arry << '-p2' if opts[:p2]
   178|         command_arry << opts[:p2] if opts[:p2]
   179|         command_arry << '-p3' if opts[:p3]
   180|         command_arry << opts[:p3] if opts[:p3]
   181|         command_arry << '-p4' if opts[:p4]
   182|         command_arry << opts[:p4] if opts[:p4]
   183|         command_arry << '-p5' if opts[:p5]
   184|         command_arry << opts[:p5] if opts[:p5]
   185|         command_arry << '-p6' if opts[:p6]
   186|         command_arry << opts[:p6] if opts[:p6]
   187|         command_arry << '-p7' if opts[:p7]
   188|         command_arry << opts[:p7] if opts[:p7]
   189|         command_arry << '-p8' if opts[:p8]
   190|         command_arry << opts[:p8] if opts[:p8]
   191|         command_arry << '-verbose' if opts[:verbose]
   192|         command = command_arry.shelljoin
   193|         jamf_output =  JSS::Client.run_jamf 'runScript', command, opts[:show_output]
   194|         jamf_output =~ /^.*Script exit code: (\d+)(\D|$)/
   195|         script_exitstatus = Regexp.last_match(1).to_i
   196|       ensure
   197|         executable.delete if delete_exec && executable.exist?
   198|         dist_point.unmount if dp_mount_pt && dp_mount_pt.mountpoint? && opts[:unmount]
   199|       end # begin/ensure
   200|       [script_exitstatus, jamf_output]
   201|     end # def run
   202|     alias oses os_requirements
   203|     alias oses= os_requirements=
   204|     alias code script_contents
   205|     alias code= script_contents=
   206|     alias contents script_contents
   207|     alias contents= script_contents=
   208|     private
   209|     def rest_xml
   210|       doc = REXML::Document.new
   211|       scpt = doc.add_element 'script'
   212|       scpt.add_element('filename').text = @filename
   213|       scpt.add_element('id').text = @id
   214|       scpt.add_element('info').text = @info
   215|       scpt.add_element('name').text = @name
   216|       scpt.add_element('notes').text = @notes
   217|       scpt.add_element('os_requirements').text = JSS.to_s_and_a(@os_requirements)[:stringform]
   218|       scpt.add_element('priority').text = @priority
   219|       add_category_to_xml(doc)
   220|       if @parameters.empty?
   221|         scpt.add_element('parameters').text = nil
   222|       else
   223|         pars = scpt.add_element('parameters')
   224|         PARAMETER_KEYS.each { |p| pars.add_element(p.to_s).text = @parameters[p] }
   225|       end
   226|       scpt.add_element('script_contents_encoded').text = Base64.encode64(@script_contents)
   227|       doc.to_s
   228|     end # rest xml
   229|   end # class Script
   230| end # module


# ====================================================================
# FILE: lib/jss/api_object/user.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 11-51 ---
    11|     OBJECT_HISTORY_OBJECT_TYPE = 53
    12|     attr_reader :full_name
    13|     attr_reader :email
    14|     attr_reader :phone_number
    15|     attr_reader :position
    16|     attr_reader :ldap_server
    17|     attr_reader :ldap_sever_id
    18|     attr_reader :sites
    19|     attr_reader :computers
    20|     attr_reader :peripherals
    21|     attr_reader :mobile_devices
    22|     attr_reader :vpp_assignments
    23|     attr_reader :total_vpp_code_count
    24|     def initialize (args = {})
    25|       super
    26|       @full_name = @init_data[:full_name]
    27|       @email = @init_data[:email]
    28|       @phone_number = @init_data[:phone_number]
    29|       @position = @init_data[:position]
    30|       @ldap_server = JSS::APIObject.get_name @init_data[:ldap_server]
    31|       @ldap_server_id = @init_data[:ldap_server][:id]
    32|       @sites = @init_data[:sites] ? @init_data[:sites]  : []
    33|       if @init_data[:links]
    34|         @computers = @init_data[:links][:computers]
    35|         @peripherals = @init_data[:links][:peripherals]
    36|         @mobile_devices = @init_data[:links][:mobile_devices]
    37|         @vpp_assignments = @init_data[:links][:vpp_assignments]
    38|         @total_vpp_code_count = @init_data[:links][:total_vpp_code_count]
    39|       end
    40|     end
    41|     def full_name= (new_val)
    42|       @full_name = new_val
    43|       @need_to_update = true
    44|     end
    45|     def email= (new_val)
    46|       @email = new_val
    47|       @need_to_update = true
    48|     end
    49|     def phone_number= (new_val)
    50|       @phone_number = new_val
    51|       @need_to_update = true


# ====================================================================
# FILE: lib/jss/client/management_action.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 23-48 ---
    23|       sleep 1
    24|       orig_flags
    25|     end
    26|     def self.restore_alerts(orig_flags)
    27|       orig_flags.each do |user, flags|
    28|         set_mgmt_action_ncprefs_flags user, flags, hup: false
    29|       end
    30|       system HUP_NOTIF_CTR_CMD unless orig_flags.empty?
    31|     end
    32|     def self.set_mgmt_action_ncprefs_flags(user, flags, hup: true)
    33|       plist = Pathname.new "/Users/#{user}/Library/Preferences/#{NCPREFS_DOMAIN}.plist"
    34|       prefs = JSS.parse_plist plist
    35|       mgmt_action_setting = prefs['apps'].select { |a| a['bundle-id'] == MGMT_ACTION_BUNDLE_ID }.first
    36|       if mgmt_action_setting
    37|         orig_flags = mgmt_action_setting['flags']
    38|         mgmt_action_setting['flags'] = flags
    39|       else
    40|         orig_flags = flags
    41|         prefs['apps'] << { 'bundle-id' => MGMT_ACTION_BUNDLE_ID, 'flags' => flags }
    42|       end
    43|       plist.open('w') { |f| f.write prefs.to_plist }
    44|       system HUP_NOTIF_CTR_CMD if hup
    45|       orig_flags
    46|     end
    47|   end # class Client
    48| end # module


# ====================================================================
# FILE: lib/jss/composer.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 5-56 ---
     5|     PKG_BUNDLE_ID_PFX = 'ruby-jss-composer'.freeze
     6|     HDI_UTIL = '/usr/bin/hdiutil'.freeze
     7|     DEFAULT_OUT_DIR = Pathname.new '/Users/Shared'
     8|     def self.mk_pkg(name, version, root, opts = {})
     9|       raise NoSuchItemError, "Missing pkgbuild tool. Please make sure you're running 10.8 or later." unless PKGBUILD.executable?
    10|       opts[:out_dir] ||= DEFAULT_OUT_DIR
    11|       opts[:bundle_id_prefix] ||= PKG_BUNDLE_ID_PFX
    12|       pkg_filename = name.end_with?('.pkg') ? name : name + '.pkg'
    13|       pkg_id = opts[:pkg_id]
    14|       pkg_id ||= opts[:bundle_id_prefix] + '.' + name
    15|       pkg_out = "#{opts[:out_dir]}/#{pkg_filename}"
    16|       pkg_ownership = opts[:preserve_ownership] ? 'preserve' : 'recommended'
    17|       if opts[:signing_identity]
    18|         signing = "--sign '#{opts[:signing_identity]}'"
    19|         signing << " #{opts[:signing_options]}" if opts[:signing_options]
    20|       else
    21|         signing = ''
    22|       end # if opts[:signing_identity]
    23|       comp_plist_out = Pathname.new "/tmp/#{PKG_BUNDLE_ID_PFX}-#{pkg_filename}.plist"
    24|       system "#{PKGBUILD} --analyze --root '#{root}' '#{comp_plist_out}'"
    25|       comp_plist = Plist.parse_xml comp_plist_out.read
    26|       if comp_plist[0].nil?
    27|         comp_plist_arg = ''
    28|       else
    29|         comp_plist.each do |bndl|
    30|           bndl.delete 'ChildBundles' if bndl['ChildBundles']
    31|           bndl['BundleOverwriteAction'] = 'upgrade'
    32|           bndl['BundleIsVersionChecked'] = false
    33|           bndl['BundleIsRelocatable'] = false
    34|           bndl['BundleHasStrictIdentifier'] = false
    35|         end
    36|         comp_plist_out.open('w') { |f| f.write comp_plist.to_plist }
    37|         comp_plist_arg = "--component-plist '#{comp_plist_out}'"
    38|       end
    39|       begin
    40|         it_built = system "#{PKGBUILD} --identifier '#{pkg_id}' --version '#{version}' --ownership #{pkg_ownership} --install-location / --root '#{root}' #{signing} #{comp_plist_arg} '#{pkg_out}'"
    41|         raise 'There was an error building the .pkg' unless it_built
    42|       ensure
    43|         comp_plist_out.delete if comp_plist_out.exist?
    44|       end
    45|       Pathname.new pkg_out
    46|     end # mk_dot_pkg
    47|     def self.mk_dmg(name, root, out_dir = DEFAULT_OUT_DIR)
    48|       dmg_filename = "#{name}.dmg"
    49|       dmg_vol = name
    50|       dmg_out = Pathname.new "#{out_dir}/#{dmg_filename}"
    51|       if dmg_out.exist?
    52|         mv_to = dmg_out.dirname + "#{dmg_out.basename}.#{Time.now.strftime('%Y%m%d%H%M%S')}"
    53|         dmg_out.rename mv_to
    54|       end # if dmg out exist
    55|       system "#{HDI_UTIL} create -volname '#{dmg_vol}' -scrub -srcfolder '#{root}' '#{dmg_out}'"
    56|       raise 'There was an error building the .dmg' unless $?.exitstatus.zero?


# ====================================================================
# FILE: lib/jss/utility.rb
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-140 ---
     1| module JSS
     2|   OS_TEN_MAXS = {
     3|       2 => 8,
     4|       3 => 9,
     5|       4 => 11,
     6|       5 => 8,
     7|       6 => 8,
     8|       7 => 5,
     9|       8 => 5,
    10|       9 => 5,
    11|       10 => 5,
    12|       11 => 6,
    13|       12 => 6,
    14|       13 => 6,
    15|       14 => 6,
    16|       15 => 7,
    17|       16 => 12
    18|     }
    19|   MAC_OS_MAXS = {
    20|     11 => 12,
    21|     12 => 12,
    22|     13 => 12,
    23|     14 => 12,
    24|     15 => 12,
    25|     16 => 12,
    26|     17 => 12,
    27|     18 => 12,
    28|     19 => 12,
    29|     20 => 12
    30|   }
    31|   def self.expand_min_os(min_os)
    32|     min_os = min_os.delete '>='
    33|     major, minor, maint = min_os.split('.')
    34|     maint = 'x' if maint.nil? || maint == '0'
    35|     ok_oses = []
    36|     if major == '11'
    37|       major = '10'
    38|       maint = minor
    39|       minor = '16'
    40|     end
    41|     if major == '10'
    42|       if maint == 'x'
    43|         ok_oses << min_os
    44|       else
    45|         max_maint_for_minor = OS_TEN_MAXS[minor.to_i]
    46|         (maint.to_i..max_maint_for_minor).each do |m|
    47|           ok_oses << "#{major}.#{minor}.#{m}"
    48|         end # each m
    49|       end
    50|       ((minor.to_i + 1)..16).each do |v|
    51|         ok_oses << "#{major}.#{v}.x"
    52|       end # each v
    53|       major = '11'
    54|       minor = minor == '16' ? maint : 'x'
    55|     end # if major == 10
    56|     if minor == 'x'
    57|       ok_oses << "#{major}.#{minor}"
    58|     else
    59|       max_minor_for_major = MAC_OS_MAXS[major.to_i]
    60|       (minor.to_i..max_minor_for_major).each do |m|
    61|         ok_oses << "#{major}.#{m}"
    62|       end # each m
    63|     end # if minor == x
    64|     ((major.to_i + 1)..MAC_OS_MAXS.keys.max).each do |v|
    65|       ok_oses << "#{v}.x"
    66|     end # each v
    67|     ok_oses
    68|   end
    69|   def self.processor_ok?(requirement, processor = nil)
    70|     return true if requirement.to_s.empty? || requirement =~ /none/i
    71|     processor ||= `/usr/bin/uname -p`
    72|     requirement == (processor.to_s.include?('86') ? 'x86' : 'ppc')
    73|   end
    74|   def self.os_ok?(requirement, os_to_check = nil)
    75|     return true if requirement.to_s =~ /none/i
    76|     return true if requirement.to_s == 'n'
    77|     requirement = JSS.to_s_and_a(requirement)[:arrayform]
    78|     return true if requirement.empty?
    79|     os_to_check ||= `/usr/bin/sw_vers -productVersion`.chomp
    80|     req_regexps = requirement.map do |r|
    81|       if r.end_with?('.x')
    82|         /^#{r.chomp('.x').gsub('.', '\.')}\.?\d*$/
    83|       elsif r =~ /^\d+\.\d+$/
    84|         /^#{r.gsub('.', '\.')}(.0)?$/
    85|       else
    86|         /^#{r.gsub('.', '\.')}$/
    87|       end
    88|     end
    89|     req_regexps.each { |re| return true if os_to_check =~ re }
    90|     false
    91|   end
    92|   def self.to_s_and_a(somedata)
    93|     case somedata
    94|     when nil
    95|       valstr = ''
    96|       valarr = []
    97|     when String
    98|       valstr = somedata
    99|       valarr = somedata.split(/,\s*/)
   100|     when Array
   101|       valstr = somedata.join ', '
   102|       valarr = somedata
   103|     else
   104|       raise JSS::InvalidDataError, 'Input must be a comma-separated String or an Array of Strings'
   105|     end # case
   106|     { stringform: valstr, arrayform: valarr }
   107|   end # to_s_and_a
   108|   def self.parse_plist(plist)
   109|     case plist
   110|     when String
   111|       return Plist.parse_xml plist if plist.include? '</plist>'
   112|       plist = Pathname.new plist
   113|     when Pathname
   114|       true
   115|     else
   116|       raise ArgumentError, 'Argument must be a path (as a Pathname or String) or a String of XML'
   117|     end # case plist
   118|     raise JSS::MissingDataError, "No such file: #{plist}" unless plist.file?
   119|     Plist.parse_xml `/usr/libexec/PlistBuddy -x -c print #{Shellwords.escape(plist.to_s)}`.force_encoding('UTF-8')
   120|   end # parse_plist
   121|   def self.parse_time(a_datetime)
   122|     return nil if NIL_DATES.include? a_datetime
   123|     the_dt = DateTime.parse(a_datetime.to_s)
   124|     usec = (the_dt.sec_fraction * 60 * 60 * 24 * (10**6)).to_i
   125|     the_dt = DateTime.new(the_dt.year, the_dt.month, the_dt.day, the_dt.hour, the_dt.min, the_dt.sec, JSS::TIME_ZONE_OFFSET) if the_dt.offset.zero?
   126|     Time.at the_dt.strftime('%s').to_i, usec
   127|   end # parse_time
   128|   def self.parse_datetime(a_datetime)
   129|     parse_time(a_datetime)
   130|   end
   131|   def self.epoch_to_time(epoch)
   132|     return nil if NIL_DATES.include? epoch
   133|     Time.at(epoch.to_i / 1000.0)
   134|   end # parse_date
   135|   def self.api_object_class(name)
   136|     klass = api_object_names[name.downcase.to_sym]
   137|     raise JSS::InvalidDataError, "Unknown API Object Class: #{name}" unless klass
   138|     klass
   139|   end
   140|   def self.api_object_names


# ====================================================================
# FILE: lib/jss/version.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3 ---
     1| module JSS
     2|   VERSION = '1.5.3'.freeze
     3| end # module

