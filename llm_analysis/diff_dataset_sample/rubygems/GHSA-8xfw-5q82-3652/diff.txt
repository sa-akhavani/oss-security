--- a//dev/null
+++ b/app/controllers/spree/user_passwords_controller.rb
@@ -0,0 +1,37 @@
+class Spree::UserPasswordsController < Devise::PasswordsController
+  helper 'spree/base'
+  include Spree::Core::ControllerHelpers::Auth
+  include Spree::Core::ControllerHelpers::Common
+  include Spree::Core::ControllerHelpers::Order
+  include Spree::Core::ControllerHelpers::Store
+  if defined?(SpreeI18n::ControllerLocaleHelper)
+    include SpreeI18n::ControllerLocaleHelper
+  end
+  before_action :set_current_order
+  def create
+    self.resource = resource_class.send_reset_password_instructions(params[resource_name])
+    if resource.errors.empty?
+      set_flash_message(:notice, :send_instructions) if is_navigational_format?
+      respond_with resource, location: spree.login_path
+    else
+      respond_with_navigational(resource) { render :new }
+    end
+  end
+  def update
+    if params[:spree_user][:password].blank?
+      self.resource = resource_class.new
+      resource.reset_password_token = params[:spree_user][:reset_password_token]
+      set_flash_message(:error, :cannot_be_blank)
+      render :edit
+    else
+      super
+    end
+  end
+  protected
+  def translation_scope
+    'devise.user_passwords'
+  end
+  def new_session_path(resource_name)
+    spree.send("new_#{resource_name}_session_path")
+  end
+end

--- a//dev/null
+++ b/app/controllers/spree/user_sessions_controller.rb
@@ -0,0 +1,64 @@
+class Spree::UserSessionsController < Devise::SessionsController
+  helper 'spree/base'
+  include Spree::Core::ControllerHelpers::Auth
+  include Spree::Core::ControllerHelpers::Common
+  include Spree::Core::ControllerHelpers::Order
+  include Spree::Core::ControllerHelpers::Store
+  if defined?(SpreeI18n::ControllerLocaleHelper)
+    include SpreeI18n::ControllerLocaleHelper
+  end
+  before_action :set_current_order
+  def create
+    authenticate_spree_user!
+    if spree_user_signed_in?
+      respond_to do |format|
+        format.html {
+          flash[:success] = Spree.t(:logged_in_succesfully)
+          redirect_back_or_default(after_sign_in_redirect(spree_current_user))
+        }
+        format.js {
+          render json: { user: spree_current_user,
+                           ship_address: spree_current_user.ship_address,
+                           bill_address: spree_current_user.bill_address }.to_json
+        }
+      end
+    else
+      respond_to do |format|
+        format.html {
+          flash.now[:error] = t('devise.failure.invalid')
+          render :new
+        }
+        format.js {
+          render json: { error: t('devise.failure.invalid') }, status: :unprocessable_entity
+        }
+      end
+    end
+  end
+  protected
+  def translation_scope
+    'devise.user_sessions'
+  end
+  private
+  def accurate_title
+    Spree.t(:login)
+  end
+  def redirect_back_or_default(default)
+    redirect_to(session["spree_user_return_to"] || default)
+    session["spree_user_return_to"] = nil
+  end
+  def after_sign_in_redirect(resource_or_scope)
+    stored_location_for(resource_or_scope) || account_path
+  end
+  def respond_to_on_destroy
+    respond_to do |format|
+      format.all { head :no_content }
+      format.any(*navigational_formats) { redirect_to after_sign_out_redirect(resource_name) }
+    end
+  end
+  def after_sign_out_redirect(resource_or_scope)
+    scope = Devise::Mapping.find_scope!(resource_or_scope)
+    router_name = Devise.mappings[scope].router_name
+    context = router_name ? send(router_name) : self
+    context.respond_to?(:login_path) ? context.login_path : "/"
+  end
+end

--- a/lib/controllers/frontend/spree/users_controller.rb
+++ b/lib/controllers/frontend/spree/users_controller.rb
@@ -1,34 +1,30 @@
 class Spree::UsersController < Spree::StoreController
   before_action :set_current_order, except: :show
+  prepend_before_action :load_object, only: [:show, :edit, :update]
   prepend_before_action :authorize_actions, only: :new
   include Spree::Core::ControllerHelpers
   def show
-    load_object
     @orders = @user.orders.complete.order('completed_at desc')
-  end
-  def edit
-    load_object
   end
   def create
     @user = Spree.user_class.new(user_params)
     if @user.save
       if current_order
         session[:guest_token] = nil
       end
       redirect_back_or_default(root_url)
     else
       render :new
     end
   end
   def update
-    load_object
     if @user.update(user_params)
       if params[:user][:password].present?
         Spree.user_class.reset_password_by_token(params[:user])
         if Spree::Auth::Config[:signout_after_password_change]
           sign_in(@user, event: :authentication)
         else
           bypass_sign_in(@user)
         end
       end
       redirect_to spree.account_url, notice: Spree.t(:account_updated)

--- a//dev/null
+++ b/lib/generators/spree/auth/install/install_generator.rb
@@ -0,0 +1,28 @@
+module Spree
+  module Auth
+    module Generators
+      class InstallGenerator < Rails::Generators::Base
+        class_option :migrate, type: :boolean, default: true, banner: 'Migrate the database'
+        def self.source_paths
+          paths = superclass.source_paths
+          paths << File.expand_path('../templates', __FILE__)
+          paths.flatten
+        end
+        def generate_devise_key
+          return if ENV['CI']
+          template 'config/initializers/devise.rb', 'config/initializers/devise.rb'
+        end
+        def add_migrations
+          run 'bundle exec rake railties:install:migrations FROM=spree_auth'
+        end
+        def run_migrations
+         if options[:migrate]
+           run 'bundle exec rake db:migrate VERBOSE=false'
+         else
+           puts "Skiping rake db:migrate, don't forget to run it!"
+         end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/admin/orders_controller_spec.rb
@@ -0,0 +1,13 @@
+module Spree
+  module Admin
+    RSpec.describe OrdersController, type: :controller do
+      stub_authorization!
+      context '#authorize_admin' do
+        it 'grants access to users with an admin role' do
+          get :new
+          expect(response).to redirect_to spree.cart_admin_order_path(Order.last)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/admin/user_sessions_controller_spec.rb
@@ -0,0 +1,13 @@
+RSpec.describe Spree::Admin::UserSessionsController, type: :controller do
+  before { @request.env['devise.mapping'] = Devise.mappings[:spree_user] }
+  describe '#authorization_failure' do
+    subject { get :authorization_failure }
+    context 'user signed in' do
+      before { allow(controller).to receive(:spree_current_user) { build_stubbed(:user) } }
+      it { is_expected.to render_template 'authorization_failure' }
+    end
+    context 'user not signed in' do
+      it { is_expected.to redirect_to spree.admin_login_path }
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/checkout_controller_spec.rb
@@ -0,0 +1,138 @@
+RSpec.describe Spree::CheckoutController, type: :controller do
+  let(:order) { create(:order_with_totals, email: nil, user: nil) }
+  let(:user)  { build(:user, spree_api_key: 'fake') }
+  let(:token) { 'some_token' }
+  before do
+    allow(controller).to receive(:current_order) { order }
+    allow(order).to receive(:confirmation_required?) { true }
+  end
+  context '#edit' do
+    context 'when registration step enabled' do
+      before do
+        allow(controller).to receive(:check_authorization)
+        Spree::Auth::Config.set(registration_step: true)
+      end
+      context 'when authenticated as registered user' do
+        before { allow(controller).to receive(:spree_current_user) { user } }
+        it 'proceeds to the first checkout step' do
+          get :edit, params: { state: 'address' }
+          expect(response).to render_template :edit
+        end
+      end
+      context 'when authenticated as guest' do
+        it 'redirects to registration step' do
+          get :edit, params: { state: 'address' }
+          expect(response).to redirect_to spree.checkout_registration_path
+        end
+      end
+    end
+    context 'when registration step disabled' do
+      before do
+        Spree::Auth::Config.set(registration_step: false)
+        allow(controller).to receive(:check_authorization)
+      end
+      context 'when authenticated as registered' do
+        before { allow(controller).to receive(:spree_current_user) { user } }
+        it 'proceeds to the first checkout step' do
+          get :edit, params: { state: 'address' }
+          expect(response).to render_template :edit
+        end
+      end
+      context 'when authenticated as guest' do
+        it 'proceeds to the first checkout step' do
+          get :edit, params: { state: 'address' }
+          expect(response).to render_template :edit
+        end
+      end
+    end
+  end
+  context '#update' do
+    context 'when in the confirm state' do
+      before do
+        order.update_column(:email, 'spree@example.com')
+        order.update_column(:state, 'confirm')
+        allow(order).to receive(:payment_required?) { false }
+      end
+      context 'with a token' do
+        before do
+          if Spree.version.to_f > 3.6
+            allow(order).to receive(:token) { 'ABC' }
+          else
+            allow(order).to receive(:guest_token) { 'ABC' }
+          end
+        end
+        it 'redirects to the tokenized order view' do
+          if Spree.version.to_f > 3.6
+            request.cookie_jar.signed[:token] = 'ABC'
+          else
+            request.cookie_jar.signed[:guest_token] = 'ABC'
+          end
+          post :update, params: { state: 'confirm' }
+          expect(response).to redirect_to spree.order_path(order)
+        end
+      end
+      context 'with a registered user' do
+        before do
+          allow(controller).to receive(:spree_current_user) { user }
+          allow(order).to receive(:user) { user }
+          if Spree.version.to_f > 3.6
+            allow(order).to receive(:token) { nil }
+          else
+            allow(order).to receive(:guest_token) { nil }
+          end
+        end
+        it 'redirects to the standard order view' do
+          post :update, params: { state: 'confirm' }
+          expect(response).to redirect_to spree.order_path(order)
+        end
+      end
+    end
+  end
+  context '#registration' do
+    it 'does not check registration' do
+      allow(controller).to receive(:check_authorization)
+      expect(controller).not_to receive(:check_registration)
+      get :registration
+    end
+    it 'checks if the user is authorized for :edit' do
+      expect(controller).to receive(:authorize!).with(:edit, order, token)
+      if Spree.version.to_f > 3.6
+        request.cookie_jar.signed[:token] = token
+      else
+        request.cookie_jar.signed[:guest_token] = token
+      end
+      get :registration, params: {}
+    end
+  end
+  context '#update_registration' do
+    let(:user) { build(:user) }
+    it 'does not check registration' do
+      controller.stub :check_authorization
+      order.stub update: true
+      controller.should_not_receive :check_registration
+      put :update_registration, params: { order: {} }
+    end
+    it 'renders the registration view if unable to save' do
+      allow(controller).to receive(:check_authorization)
+      put :update_registration, params: { order: { email: 'invalid' } }
+      expect(flash[:error]).to eq I18n.t(:email_is_invalid, scope: [:errors, :messages])
+      expect(response).to render_template :registration
+    end
+    it 'redirects to the checkout_path after saving' do
+      allow(order).to receive(:update) { true }
+      allow(controller).to receive(:check_authorization)
+      put :update_registration, params: { order: { email: 'jobs@spreecommerce.com' } }
+      expect(response).to redirect_to spree.checkout_state_path(:address)
+    end
+    it 'checks if the user is authorized for :edit' do
+      if Spree.version.to_f > 3.6
+        request.cookie_jar.signed[:token] = token
+      else
+        request.cookie_jar.signed[:guest_token] = token
+      end
+      allow(order).to receive(:update) { true }
+      expect(controller).to receive(:authorize!).with(:edit, order, token)
+      put :update_registration, params: { order: { email: 'jobs@spreecommerce.com' } }
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/products_controller_spec.rb
@@ -0,0 +1,23 @@
+RSpec.describe Spree::ProductsController, type: :controller do
+  let!(:product) { create(:product, available_on: 1.year.from_now) }
+  let!(:user) { build_stubbed(:user, spree_api_key: 'fake') }
+  subject(:request) { get :show, params: { id: product.to_param }}
+  before do
+    allow(controller).to receive(:before_save_new_order)
+    allow(controller).to receive(:spree_current_user) { user }
+  end
+  it 'allows admins to view non-active products' do
+    allow(user).to receive(:has_spree_role?) { true }
+    request
+    expect(response.status).to eq(200)
+  end
+  it 'cannot view non-active products' do
+    allow(user).to receive(:has_spree_role?) { false }
+    if Spree.version.to_f > 3.4
+      expect { request }.to raise_error(ActiveRecord::RecordNotFound)
+    else
+      request
+      expect(response.status).to eq(404)
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/user_passwords_controller_spec.rb
@@ -0,0 +1,38 @@
+RSpec.describe Spree::UserPasswordsController, type: :controller do
+  let(:token) { 'some_token' }
+  before { @request.env['devise.mapping'] = Devise.mappings[:spree_user] }
+  describe 'GET edit' do
+    context 'when the user token has not been specified' do
+      it 'redirects to the new session path' do
+        get :edit
+        expect(response).to redirect_to(
+          'http://test.host/user/spree_user/sign_in'
+        )
+      end
+      it 'flashes an error' do
+        get :edit
+        expect(flash[:alert]).to include(
+          "You can't access this page without coming from a password reset " \
+          'email'
+        )
+      end
+    end
+    context 'when the user token has been specified' do
+      it 'does something' do
+        get :edit, params: { reset_password_token: token }
+        expect(response.code).to eq('200')
+      end
+    end
+  end
+  context '#update' do
+    context 'when updating password with blank password' do
+      it 'shows error flash message, sets spree_user with token and re-displays password edit form' do
+        put :update, params: { spree_user: { password: '', password_confirmation: '', reset_password_token: token } }
+        expect(assigns(:spree_user).is_a?(Spree::User)).to eq true
+        expect(assigns(:spree_user).reset_password_token).to eq token
+        expect(flash[:error]).to eq I18n.t(:cannot_be_blank, scope: [:devise, :user_passwords, :spree_user])
+        expect(response).to render_template :edit
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/user_sessions_controller_spec.rb
@@ -0,0 +1,160 @@
+RSpec.describe Spree::UserSessionsController, type: :controller do
+  let(:user) { create(:user) }
+  before { @request.env['devise.mapping'] = Devise.mappings[:spree_user] }
+  context "#create" do
+    context "using correct login information" do
+      if Gem.loaded_specs['spree_core'].version >= Gem::Version.create('3.7.0')
+        context 'with a token present' do
+          before do
+            request.cookie_jar.signed[:token] = 'ABC'
+          end
+          it 'assigns orders with the correct token and no user present' do
+            order = create(:order, email: user.email, token: 'ABC', user_id: nil, created_by_id: nil)
+            post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+            order.reload
+            expect(order.user_id).to eq user.id
+            expect(order.created_by_id).to eq user.id
+          end
+          it 'assigns orders with the correct token and no user or email present' do
+            order = create(:order, token: 'ABC', user_id: nil, created_by_id: nil)
+            post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+            order.reload
+            expect(order.user_id).to eq user.id
+            expect(order.created_by_id).to eq user.id
+          end
+          it 'does not assign completed orders' do
+            order = create(:order, email: user.email, token: 'ABC',
+                           user_id: nil, created_by_id: nil,
+                           completed_at: 1.minute.ago)
+            post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+            order.reload
+            expect(order.user_id).to be_nil
+            expect(order.created_by_id).to be_nil
+          end
+          it 'does not assign orders with an existing user' do
+            order = create(:order, token: 'ABC', user_id: 200)
+            post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+            expect(order.reload.user_id).to eq 200
+          end
+          it 'does not assign orders with a different token' do
+            order = create(:order, token: 'DEF', user_id: nil, created_by_id: nil)
+            post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+            expect(order.reload.user_id).to be_nil
+          end
+        end
+      end
+      context 'with a guest token present' do
+        before do
+          if Spree.version.to_f > 3.6
+            request.cookie_jar.signed[:token] = 'ABC'
+          else
+            request.cookie_jar.signed[:guest_token] = 'ABC'
+          end
+        end
+        it 'assigns orders with the correct token and no user present' do
+          if Spree.version.to_f > 3.6
+            order = create(:order, email: user.email, token: 'ABC', user_id: nil, created_by_id: nil)
+          else
+            order = create(:order, email: user.email, guest_token: 'ABC', user_id: nil, created_by_id: nil)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          order.reload
+          expect(order.user_id).to eq user.id
+          expect(order.created_by_id).to eq user.id
+        end
+        it 'assigns orders with the correct token and no user or email present' do
+          if Spree.version.to_f > 3.6
+            order = create(:order, token: 'ABC', user_id: nil, created_by_id: nil)
+          else
+            order = create(:order, guest_token: 'ABC', user_id: nil, created_by_id: nil)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          order.reload
+          expect(order.user_id).to eq user.id
+          expect(order.created_by_id).to eq user.id
+        end
+        it 'does not assign completed orders' do
+          if Spree.version.to_f > 3.6
+            order = create(:order, email: user.email, token: 'ABC',
+                           user_id: nil, created_by_id: nil,
+                           completed_at: 1.minute.ago)
+          else
+            order = create(:order, email: user.email, guest_token: 'ABC',
+                           user_id: nil, created_by_id: nil,
+                           completed_at: 1.minute.ago)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          order.reload
+          expect(order.user_id).to be_nil
+          expect(order.created_by_id).to be_nil
+        end
+        it 'does not assign orders with an existing user' do
+          if Spree.version.to_f > 3.6
+              order = create(:order, token: 'ABC', user_id: 200)
+          else
+              order = create(:order, guest_token: 'ABC', user_id: 200)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          expect(order.reload.user_id).to eq 200
+        end
+        it 'does not assign orders with a different token' do
+          if Spree.version.to_f > 3.6
+              order = create(:order, token: 'DEF', user_id: nil, created_by_id: nil)
+          else
+              order = create(:order, guest_token: 'DEF', user_id: nil, created_by_id: nil)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          expect(order.reload.user_id).to be_nil
+        end
+      end
+      context 'with a guest_token from a pre-3.7 version of Spree present' do
+        before do
+          request.cookie_jar.signed[:guest_token] = 'ABC'
+          request.cookie_jar.signed[:token] = 'DEF'
+        end
+        it 'assigns the correct token attribute for the order' do 
+          if Spree.version.to_f > 3.6
+            order = create(:order, email: user.email, token: 'ABC', user_id: nil, created_by_id: nil)
+          else
+            order = create(:order, email: user.email, guest_token: 'ABC', user_id: nil, created_by_id: nil)
+          end
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          order.reload
+          expect(order.user_id).to eq user.id
+          expect(order.created_by_id).to eq user.id
+        end 
+      end
+      context "and html format is used" do
+        it "redirects to account path after signing in" do
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }}
+          expect(response).to redirect_to spree.account_path
+        end
+      end
+      context "and js format is used" do
+        it "returns a json with ship and bill address" do
+          post :create, params: { spree_user: { email: user.email, password: 'secret' }, format: 'js' }
+          parsed = ActiveSupport::JSON.decode(response.body)
+          expect(parsed).to have_key("user")
+          expect(parsed).to have_key("ship_address")
+          expect(parsed).to have_key("bill_address")
+        end
+      end
+    end
+    context "using incorrect login information" do
+      context "and html format is used" do
+        it "renders new template again with errors" do
+          post :create, params: { spree_user: { email: user.email, password: 'wrong' }}
+          expect(response).to render_template('new')
+          expect(flash[:error]).to eq I18n.t(:'devise.failure.invalid')
+        end
+      end
+      context "and js format is used" do
+        it "returns a json with the error" do
+          post :create, params: { spree_user: { email: user.email, password: 'wrong' }, format: 'js' }
+          parsed = ActiveSupport::JSON.decode(response.body)
+          expect(parsed).to have_key("error")
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/spree/users_controller_spec.rb
@@ -0,0 +1,32 @@
+RSpec.describe Spree::UsersController, type: :controller do
+  let(:admin_user) { create(:user) }
+  let(:user) { create(:user) }
+  let(:role) { create(:role) }
+  before { allow(controller).to receive(:spree_current_user) { user } }
+  context '#load_object' do
+    it 'redirects to signup path if user is not found' do
+      allow(controller).to receive(:spree_current_user) { nil }
+      put :update, params: { user: { email: 'foobar@example.com' } }
+      expect(response).to redirect_to spree.login_path
+    end
+  end
+  context '#create' do
+    it 'creates a new user' do
+      post :create, params: { user: { email: 'foobar@example.com', password: 'foobar123', password_confirmation: 'foobar123' } }
+      expect(assigns[:user].new_record?).to be false
+    end
+  end
+  context '#update' do
+    context 'when updating own account' do
+      it 'performs update' do
+        put :update, params: { user: { email: 'mynew@email-address.com' } }
+        expect(assigns[:user].email).to eq 'mynew@email-address.com'
+        expect(response).to redirect_to spree.account_url(only_path: true)
+      end
+    end
+    it 'does not update roles' do
+      put :update, params: { user: { spree_role_ids: [role.id] }}
+      expect(assigns[:user].spree_roles).to_not include role
+    end
+  end
+end

--- a//dev/null
+++ b/spec/features/account_spec.rb
@@ -0,0 +1,46 @@
+RSpec.feature 'Accounts', type: :feature do
+  describe 'editing', js: true do
+    before do
+      allow_bypass_sign_in
+    end
+    scenario 'can edit an admin user' do
+      user = create(:admin_user, email: 'admin@person.com', password: 'password', password_confirmation: 'password')
+      visit spree.login_path
+      fill_in 'Email', with: user.email
+      fill_in 'Password', with: user.password
+      click_button 'Log in'
+      show_user_account
+      expect(page).to have_text 'admin@person.com'
+    end
+    scenario 'can edit a new user' do
+      visit spree.signup_path
+      fill_in 'Email', with: 'email@person.com'
+      fill_in 'Password', with: 'password'
+      fill_in 'Password Confirmation', with: 'password'
+      click_button 'Sign Up'
+      show_user_account
+      expect(page).to have_text 'email@person.com'
+      find('a.account-page-user-info-item-title-edit').click
+      fill_in 'Password', with: 'foobar'
+      fill_in 'Password Confirmation', with: 'foobar'
+      click_button 'Update'
+      expect(page).to have_text 'email@person.com'
+      expect(page).to have_text 'Account updated'
+    end
+    scenario 'can edit an existing user account' do
+      user = create(:user, email: 'email@person.com', password: 'secret', password_confirmation: 'secret')
+      visit spree.login_path
+      fill_in 'Email', with: user.email
+      fill_in 'Password', with: user.password
+      click_button 'Log in'
+      show_user_account
+      expect(page).to have_text 'email@person.com'
+      find('a.account-page-user-info-item-title-edit').click
+      fill_in 'Password', with: 'foobar'
+      fill_in 'Password Confirmation', with: 'foobar'
+      click_button 'Update'
+      expect(page).to have_text 'email@person.com'
+      expect(page).to have_text 'Account updated'
+    end
+  end
+end

--- a//dev/null
+++ b/spec/features/admin/password_reset_spec.rb
@@ -0,0 +1,19 @@
+RSpec.feature 'Admin - Reset Password', type: :feature do
+  background do
+    ActionMailer::Base.default_url_options[:host] = 'http://example.com'
+  end
+  scenario 'allows a user to supply an email for the password reset' do
+    user = create(:user, email: 'foobar@example.com', password: 'secret', password_confirmation: 'secret')
+    visit spree.admin_login_path
+    click_link 'Forgot password?'
+    fill_in 'Email', with: 'foobar@example.com'
+    click_button 'Reset my password'
+    expect(page).to have_text 'You will receive an email with instructions'
+  end
+  scenario 'shows errors if no email is supplied' do
+    visit spree.admin_login_path
+    click_link 'Forgot password?'
+    click_button 'Reset my password'
+    expect(page).to have_text "Email can't be blank"
+  end
+end

--- a//dev/null
+++ b/spec/features/admin/sign_in_spec.rb
@@ -0,0 +1,35 @@
+RSpec.feature 'Admin - Sign In', type: :feature do
+  background do
+    @user = create(:user, email: 'email@person.com')
+    visit spree.admin_login_path
+  end
+  scenario 'asks user to sign in' do
+    visit spree.admin_path
+    expect(page).not_to have_text 'Authorization Failure'
+  end
+  scenario 'lets a user sign in successfully', js: true do
+    log_in(email: @user.email, password: 'secret')
+    show_user_menu
+    expect(page).not_to have_text 'Login'
+    expect(page).to have_text 'LOG OUT'
+    expect(current_path).to eq '/account'
+  end
+  scenario 'shows validation errors' do
+    fill_in 'Email', with: @user.email
+    fill_in 'Password', with: 'wrong_password'
+    click_button 'Login'
+    expect(page).to have_text 'Invalid email or password'
+    expect(page).to have_button 'Login'
+  end
+  scenario 'allows a user to access a restricted page after logging in' do
+    user = create(:admin_user, email: 'admin@person.com')
+    visit spree.admin_path
+    fill_in 'Email', with: user.email
+    fill_in 'Password', with: 'secret'
+    click_button 'Log in'
+    within '.user-menu' do
+      expect(page).to have_text 'admin@person.com'
+    end
+    expect(current_path).to eq '/admin/orders'
+  end
+end

--- a//dev/null
+++ b/spec/features/admin/sign_out_spec.rb
@@ -0,0 +1,18 @@
+RSpec.feature 'Admin - Sign Out', type: :feature do
+  given!(:user) do
+   create :user, email: 'email@person.com'
+  end
+  background do
+    visit spree.admin_login_path
+    fill_in 'Email', with: user.email
+    fill_in 'Password', with: 'secret'
+    check 'Remember me'
+    click_button 'Login'
+  end
+  scenario 'allows a signed in user to logout', js: true do
+    log_out
+    visit spree.admin_login_path
+    expect(page).to have_button 'Login'
+    expect(page).not_to have_text 'Logout'
+  end
+end

--- a//dev/null
+++ b/spec/features/admin_permissions_spec.rb
@@ -0,0 +1,38 @@
+RSpec.feature 'Admin Permissions', type: :feature do
+  context 'orders' do
+    background do
+      user = create(:admin_user, email: 'admin@person.com', password: 'password', password_confirmation: 'password')
+      Spree::Ability.register_ability(AbilityDecorator)
+      visit spree.login_path
+      fill_in 'Email', with: user.email
+      fill_in 'Password', with: user.password
+      click_button 'Log in'
+    end
+    context 'admin is restricted from accessing orders' do
+      scenario 'can not list orders' do
+        visit spree.admin_orders_path
+        expect(page).to have_text 'Authorization Failure'
+      end
+      scenario 'can not edit orders' do
+        create(:order, number: 'R123')
+        visit spree.edit_admin_order_path('R123')
+        expect(page).to have_text 'Authorization Failure'
+      end
+      scenario 'can not new orders' do
+        visit spree.new_admin_order_path
+        expect(page).to have_text 'Authorization Failure'
+      end
+    end
+    context "admin is restricted from accessing an order's customer details" do
+      given(:order) { create(:order_with_totals) }
+      scenario 'can not list customer details for an order' do
+        visit spree.admin_order_customer_path(order)
+        expect(page).to have_text 'Authorization Failure'
+      end
+      scenario "can not edit an order's customer details" do
+        visit spree.edit_admin_order_customer_path(order)
+        expect(page).to have_text 'Authorization Failure'
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/spec/features/change_email_spec.rb
@@ -0,0 +1,16 @@
+RSpec.feature 'Change email', type: :feature do
+  background do
+    allow_bypass_sign_in
+    user = create(:user, email: 'old@spree.com', password: 'secret')
+    log_in(email: user.email, password: 'secret')
+    visit spree.edit_account_path
+  end
+  scenario 'work with correct password', js: true do
+    fill_in 'user_email', with: 'tests@example.com'
+    fill_in 'user_password', with: 'password'
+    fill_in 'user_password_confirmation', with: 'password'
+    click_button 'Update'
+    expect(page).to have_text 'Account updated'
+    expect(page).to have_text 'tests@example.com'
+  end
+end

--- a//dev/null
+++ b/spec/features/order_spec.rb
@@ -0,0 +1,36 @@
+RSpec.feature 'Orders', :js, type: :feature do
+  scenario 'allow a user to view their cart at any time' do
+    visit spree.cart_path
+    expect(page).to have_text 'Your cart is empty'
+  end
+  scenario 'merge incomplete orders from different sessions' do
+    ror_mug = create(:product, name: 'RoR Mug')
+    ror_shirt = create(:product, name: 'RoR Shirt')
+    user = create(:user, email: 'email@person.com', password: 'password', password_confirmation: 'password')
+    using_session('first') do
+      add_to_cart ror_mug
+      visit spree.login_path
+      fill_in 'Email', with: user.email
+      fill_in 'Password', with: user.password
+      click_button 'Log in'
+      visit spree.cart_path
+      expect(page).to have_text 'RoR Mug'
+    end
+    using_session('second') do
+      add_to_cart ror_shirt
+      visit spree.login_path
+      fill_in 'Email', with: user.email
+      fill_in 'Password', with: user.password
+      click_button 'Log in'
+      visit spree.cart_path
+      expect(page).to have_text 'RoR Mug'
+      expect(page).to have_text 'RoR Shirt'
+    end
+    using_session('first') do
+      visit spree.root_path
+      visit spree.cart_path
+      expect(page).to have_text 'RoR Mug'
+      expect(page).to have_text 'RoR Shirt'
+    end
+  end
+end

--- a//dev/null
+++ b/spec/features/password_reset_spec.rb
@@ -0,0 +1,19 @@
+RSpec.feature 'Reset Password', type: :feature do
+  background do
+    ActionMailer::Base.default_url_options[:host] = 'http://example.com'
+  end
+  scenario 'allow a user to supply an email for the password reset' do
+    user = create(:user, email: 'foobar@example.com', password: 'secret', password_confirmation: 'secret')
+    visit spree.login_path
+    click_link 'Forgot password?'
+    fill_in 'Email', with: 'foobar@example.com'
+    click_button 'Reset my password'
+    expect(page).to have_text 'You will receive an email with instructions'
+  end
+  scenario 'shows errors if no email is supplied' do
+    visit spree.login_path
+    click_link 'Forgot password?'
+    click_button 'Reset my password'
+    expect(page).to have_text "Email can't be blank"
+  end
+end

--- a//dev/null
+++ b/spec/features/sign_in_spec.rb
@@ -0,0 +1,42 @@
+RSpec.feature 'Sign In', type: :feature do
+  background do
+    @user = create(:user, email: 'email@person.com', password: 'secret', password_confirmation: 'secret')
+    visit spree.login_path
+  end
+  scenario 'ask user to sign in' do
+    visit spree.admin_path
+    expect(page).not_to have_text 'Authorization Failure'
+  end
+  scenario 'let a user sign in successfully', js: true do
+    log_in(email: @user.email, password: @user.password)
+    show_user_menu
+    expect(page).not_to have_text 'Login'
+    expect(page).to have_text 'LOG OUT'
+    expect(current_path).to eq '/account'
+  end
+  scenario 'show validation erros' do
+    fill_in 'Email', with: @user.email
+    fill_in 'Password', with: 'wrong_password'
+    click_button 'Log in'
+    expect(page).to have_text 'Invalid email or password'
+    expect(page).to have_text 'Log in'
+  end
+  scenario 'allow a user to access a restricted page after logging in' do
+    user = create(:admin_user, email: 'admin@person.com', password: 'password', password_confirmation: 'password')
+    visit spree.admin_path
+    fill_in 'Email', with: user.email
+    fill_in 'Password', with: user.password
+    click_button 'Log in'
+    within '.user-menu' do
+      expect(page).to have_text 'admin@person.com'
+    end
+    expect(current_path).to eq '/admin/orders'
+  end
+  xit "should store the user previous location" do
+    visit spree.account_path
+    fill_in "Email", with: @user.email
+    fill_in "Password", with: @user.password
+    click_button "Login"
+    expect(current_path).to eq "/account"
+  end
+end

--- a//dev/null
+++ b/spec/features/sign_out_spec.rb
@@ -0,0 +1,34 @@
+RSpec.feature 'Sign Out', type: :feature, js: true do
+  given!(:user) do
+    create(:user,
+          email: 'email@person.com',
+          password: 'secret',
+          password_confirmation: 'secret')
+  end
+  background do
+    log_in(email: user.email, password: user.password)
+  end
+  scenario 'allow a signed in user to logout' do
+    log_out
+    visit spree.root_path
+    show_user_menu
+    expect(page).to have_link 'LOG IN'
+    expect(page).not_to have_link 'LOG OUT'
+  end
+  describe 'before_logout' do
+    let!(:mug)        { create(:product_in_stock, name: 'RoR Mug') }
+    let!(:shirt)      { create(:product, name: 'RoR Shirt') }
+    let!(:other_user) { create(:user) }
+    it 'clears token cookies' do
+      add_to_cart(mug) do
+        find('.close').click
+      end
+      log_out
+      find('#link-to-cart').click
+      expect(page).to have_text Spree.t(:your_cart_is_empty)
+      log_in(email: other_user.email, password: user.password)
+      find('#link-to-cart').click
+      expect(page).to have_text Spree.t(:your_cart_is_empty)
+    end
+  end
+end

--- a//dev/null
+++ b/spec/mailers/user_mailer_spec.rb
@@ -0,0 +1,33 @@
+RSpec.describe Spree::UserMailer, type: :mailer do
+  let(:user) { create(:user) }
+  let(:store) { Spree::Store.default }
+  describe '#reset_password_instructions' do
+    describe 'message contents' do
+      before do
+        @message = described_class.reset_password_instructions(user, 'token goes here')
+      end
+      context 'subject includes' do
+        it 'translated devise instructions' do
+          expect(@message.subject).to include(
+            I18n.t(:subject, scope: [:devise, :mailer, :reset_password_instructions])
+          )
+        end
+        it 'Spree site name' do
+          expect(@message.subject).to include store.name
+        end
+      end
+      context 'body includes' do
+        it 'password reset url' do
+          expect(@message.body.raw_source).to include "http://#{store.url}/user/spree_user/password/edit"
+        end
+      end
+    end
+    describe 'legacy support for User object' do
+      it 'sends an email' do
+        expect {
+          described_class.reset_password_instructions(user, 'token goes here').deliver_now
+        }.to change(ActionMailer::Base.deliveries, :size).by(1)
+      end
+    end
+  end
+end

--- a/spec/requests/spree/frontend/user_update_spec.rb
+++ b//dev/null
@@ -1,26 +0,0 @@
-RSpec.feature 'User update', type: :request do
-  context 'CSRF protection' do
-    %i[exception reset_session null_session].each do |strategy|
-      around do |example|
-        controller = Spree::UsersController
-        old_allow_forgery_protection_value = controller.allow_forgery_protection
-        old_forgery_protection_strategy = controller.forgery_protection_strategy
-        controller.skip_forgery_protection
-        controller.allow_forgery_protection = true
-        controller.protect_from_forgery with: strategy
-        example.run
-        controller.allow_forgery_protection = old_allow_forgery_protection_value
-        controller.forgery_protection_strategy = old_forgery_protection_strategy
-      end
-      it "is not possible to take account over with the #{strategy} forgery protection strategy" do
-        user = create(:user, email: 'legit@mail.com', password: 'password')
-        post '/login', params: "spree_user[email]=legit@mail.com&spree_user[password]=password"
-        begin
-          put '/users/123456', params: 'user[email]=hacked@example.com'
-        rescue
-        end
-        expect(user.reload.email).to eq('legit@mail.com')
-      end
-    end
-  end
-end

--- a//dev/null
+++ b/spec/spec_helper.rb
@@ -0,0 +1,37 @@
+require 'simplecov'
+SimpleCov.start 'rails'
+ENV['RAILS_ENV'] ||= 'test'
+require File.expand_path('../dummy/config/environment', __FILE__)
+require 'rspec/rails'
+require 'shoulda-matchers'
+require 'ffaker'
+require 'pry'
+require 'spree/testing_support/auth_helpers'
+require 'spree/testing_support/checkout_helpers'
+require 'spree/testing_support/authorization_helpers'
+require 'spree/testing_support/capybara_ext'
+require 'spree/testing_support/controller_requests'
+require 'spree/testing_support/factories'
+require 'spree/testing_support/url_helpers'
+RSpec.configure do |config|
+  config.filter_run focus: true
+  config.infer_spec_type_from_file_location!
+  config.raise_errors_for_deprecations!
+  config.run_all_when_everything_filtered = true
+  config.use_transactional_fixtures = false
+  config.mock_with :rspec do |mock|
+    mock.syntax = [:should, :expect]
+  end
+  config.order = :random
+  Kernel.srand(config.seed)
+  config.before(:each) do
+    allow(RSpec::Rails::ViewRendering::EmptyTemplateHandler)
+      .to receive(:call)
+      .and_return(%("")) if Rails.gem_version >= Gem::Version.new('6.0.0.beta1')
+    create(:store)
+  end
+  config.include Spree::TestingSupport::AuthHelpers, type: :feature
+  config.include Spree::TestingSupport::CheckoutHelpers, type: :feature
+  config.include Spree::TestingSupport::UrlHelpers
+end
+Dir[File.join(File.dirname(__FILE__), 'support/**/*.rb')].each { |f| require f }

--- a//dev/null
+++ b/spec/support/add_to_cart.rb
@@ -0,0 +1,20 @@
+def add_to_cart(product)
+  visit spree.product_path(product)
+  if Spree.version.to_f > 3.6
+    expect(page).to have_selector('form#add-to-cart-form')
+    expect(page).to have_selector('button#add-to-cart-button')
+    wait_for_condition do
+      expect(page.find('#add-to-cart-button').disabled?).to eq(false)
+    end
+  end
+  click_button 'Add To Cart'
+  wait_for_condition do
+    expect(page).to have_content(Spree.t(:added_to_cart))
+  end
+  if block_given?
+    yield
+  else
+    click_link 'View cart'
+    expect(page).to have_content 'YOUR SHOPPING BAG'
+  end
+end

--- a//dev/null
+++ b/spec/support/authentication_helpers.rb
@@ -0,0 +1,13 @@
+module AuthenticationHelpers
+  def sign_in_as!(user)
+    visit '/login'
+    fill_in 'Email', with: user.email
+    fill_in 'Password', with: 'secret'
+    click_button 'Log in'
+  end
+end
+RSpec.configure do |config|
+  config.include AuthenticationHelpers, type: :feature
+  config.include Devise::Test::ControllerHelpers, type: :controller
+  config.include Rack::Test::Methods, type: :feature
+end

--- a//dev/null
+++ b/spec/support/capybara.rb
@@ -0,0 +1,20 @@
+require 'capybara/rspec'
+require 'capybara-screenshot'
+require 'capybara-screenshot/rspec'
+require 'capybara/rails'
+require 'selenium/webdriver'
+RSpec.configure do
+  Capybara.register_driver :chrome do |app|
+    Selenium::WebDriver.logger.level = :error
+    Capybara::Selenium::Driver.new app,
+      browser: :chrome,
+      options: Selenium::WebDriver::Chrome::Options.new(
+        args: %w[headless disable-gpu window-size=1920,1080 --enable-features=NetworkService,NetworkServiceInProcess --disable-features=VizDisplayCompositor],
+        log_level: :error
+      )
+  end
+  Capybara.javascript_driver = :chrome
+  Capybara::Screenshot.register_driver(:chrome) do |driver, path|
+    driver.browser.save_screenshot(path)
+  end
+end
