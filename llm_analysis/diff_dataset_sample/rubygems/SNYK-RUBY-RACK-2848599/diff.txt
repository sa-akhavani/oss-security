--- a//dev/null
+++ b/lib/rack.rb
@@ -0,0 +1,118 @@
+require_relative 'rack/version'
+module Rack
+  HTTP_HOST         = 'HTTP_HOST'
+  HTTP_PORT         = 'HTTP_PORT'
+  HTTP_VERSION      = 'HTTP_VERSION'
+  HTTPS             = 'HTTPS'
+  PATH_INFO         = 'PATH_INFO'
+  REQUEST_METHOD    = 'REQUEST_METHOD'
+  REQUEST_PATH      = 'REQUEST_PATH'
+  SCRIPT_NAME       = 'SCRIPT_NAME'
+  QUERY_STRING      = 'QUERY_STRING'
+  SERVER_PROTOCOL   = 'SERVER_PROTOCOL'
+  SERVER_NAME       = 'SERVER_NAME'
+  SERVER_PORT       = 'SERVER_PORT'
+  CACHE_CONTROL     = 'Cache-Control'
+  EXPIRES           = 'Expires'
+  CONTENT_LENGTH    = 'Content-Length'
+  CONTENT_TYPE      = 'Content-Type'
+  SET_COOKIE        = 'Set-Cookie'
+  TRANSFER_ENCODING = 'Transfer-Encoding'
+  HTTP_COOKIE       = 'HTTP_COOKIE'
+  ETAG              = 'ETag'
+  GET     = 'GET'
+  POST    = 'POST'
+  PUT     = 'PUT'
+  PATCH   = 'PATCH'
+  DELETE  = 'DELETE'
+  HEAD    = 'HEAD'
+  OPTIONS = 'OPTIONS'
+  LINK    = 'LINK'
+  UNLINK  = 'UNLINK'
+  TRACE   = 'TRACE'
+  RACK_VERSION                        = 'rack.version'
+  RACK_TEMPFILES                      = 'rack.tempfiles'
+  RACK_ERRORS                         = 'rack.errors'
+  RACK_LOGGER                         = 'rack.logger'
+  RACK_INPUT                          = 'rack.input'
+  RACK_SESSION                        = 'rack.session'
+  RACK_SESSION_OPTIONS                = 'rack.session.options'
+  RACK_SHOWSTATUS_DETAIL              = 'rack.showstatus.detail'
+  RACK_MULTITHREAD                    = 'rack.multithread'
+  RACK_MULTIPROCESS                   = 'rack.multiprocess'
+  RACK_RUNONCE                        = 'rack.run_once'
+  RACK_URL_SCHEME                     = 'rack.url_scheme'
+  RACK_HIJACK                         = 'rack.hijack'
+  RACK_IS_HIJACK                      = 'rack.hijack?'
+  RACK_HIJACK_IO                      = 'rack.hijack_io'
+  RACK_RECURSIVE_INCLUDE              = 'rack.recursive.include'
+  RACK_MULTIPART_BUFFER_SIZE          = 'rack.multipart.buffer_size'
+  RACK_MULTIPART_TEMPFILE_FACTORY     = 'rack.multipart.tempfile_factory'
+  RACK_REQUEST_FORM_INPUT             = 'rack.request.form_input'
+  RACK_REQUEST_FORM_HASH              = 'rack.request.form_hash'
+  RACK_REQUEST_FORM_VARS              = 'rack.request.form_vars'
+  RACK_REQUEST_COOKIE_HASH            = 'rack.request.cookie_hash'
+  RACK_REQUEST_COOKIE_STRING          = 'rack.request.cookie_string'
+  RACK_REQUEST_QUERY_HASH             = 'rack.request.query_hash'
+  RACK_REQUEST_QUERY_STRING           = 'rack.request.query_string'
+  RACK_METHODOVERRIDE_ORIGINAL_METHOD = 'rack.methodoverride.original_method'
+  RACK_SESSION_UNPACKED_COOKIE_DATA   = 'rack.session.unpacked_cookie_data'
+  autoload :Builder, "rack/builder"
+  autoload :BodyProxy, "rack/body_proxy"
+  autoload :Cascade, "rack/cascade"
+  autoload :Chunked, "rack/chunked"
+  autoload :CommonLogger, "rack/common_logger"
+  autoload :ConditionalGet, "rack/conditional_get"
+  autoload :Config, "rack/config"
+  autoload :ContentLength, "rack/content_length"
+  autoload :ContentType, "rack/content_type"
+  autoload :ETag, "rack/etag"
+  autoload :Events, "rack/events"
+  autoload :File, "rack/file"
+  autoload :Files, "rack/files"
+  autoload :Deflater, "rack/deflater"
+  autoload :Directory, "rack/directory"
+  autoload :ForwardRequest, "rack/recursive"
+  autoload :Handler, "rack/handler"
+  autoload :Head, "rack/head"
+  autoload :Lint, "rack/lint"
+  autoload :Lock, "rack/lock"
+  autoload :Logger, "rack/logger"
+  autoload :MediaType, "rack/media_type"
+  autoload :MethodOverride, "rack/method_override"
+  autoload :Mime, "rack/mime"
+  autoload :NullLogger, "rack/null_logger"
+  autoload :Recursive, "rack/recursive"
+  autoload :Reloader, "rack/reloader"
+  autoload :RewindableInput, "rack/rewindable_input"
+  autoload :Runtime, "rack/runtime"
+  autoload :Sendfile, "rack/sendfile"
+  autoload :Server, "rack/server"
+  autoload :ShowExceptions, "rack/show_exceptions"
+  autoload :ShowStatus, "rack/show_status"
+  autoload :Static, "rack/static"
+  autoload :TempfileReaper, "rack/tempfile_reaper"
+  autoload :URLMap, "rack/urlmap"
+  autoload :Utils, "rack/utils"
+  autoload :Multipart, "rack/multipart"
+  autoload :MockRequest, "rack/mock"
+  autoload :MockResponse, "rack/mock"
+  autoload :Request, "rack/request"
+  autoload :Response, "rack/response"
+  module Auth
+    autoload :Basic, "rack/auth/basic"
+    autoload :AbstractRequest, "rack/auth/abstract/request"
+    autoload :AbstractHandler, "rack/auth/abstract/handler"
+    module Digest
+      autoload :MD5, "rack/auth/digest/md5"
+      autoload :Nonce, "rack/auth/digest/nonce"
+      autoload :Params, "rack/auth/digest/params"
+      autoload :Request, "rack/auth/digest/request"
+    end
+  end
+  module Session
+    autoload :Cookie, "rack/session/cookie"
+    autoload :Pool, "rack/session/pool"
+    autoload :Memcache, "rack/session/memcache"
+  end
+end

--- a//dev/null
+++ b/lib/rack/auth/abstract/request.rb
@@ -0,0 +1,32 @@
+module Rack
+  module Auth
+    class AbstractRequest
+      def initialize(env)
+        @env = env
+      end
+      def request
+        @request ||= Request.new(@env)
+      end
+      def provided?
+        !authorization_key.nil? && valid?
+      end
+      def valid?
+        !@env[authorization_key].nil?
+      end
+      def parts
+        @parts ||= @env[authorization_key].split(' ', 2)
+      end
+      def scheme
+        @scheme ||= parts.first && parts.first.downcase
+      end
+      def params
+        @params ||= parts.last
+      end
+      private
+      AUTHORIZATION_KEYS = ['HTTP_AUTHORIZATION', 'X-HTTP_AUTHORIZATION', 'X_HTTP_AUTHORIZATION']
+      def authorization_key
+        @authorization_key ||= AUTHORIZATION_KEYS.detect { |key| @env.has_key?(key) }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/auth/basic.rb
@@ -0,0 +1,37 @@
+require_relative 'abstract/handler'
+require_relative 'abstract/request'
+require 'base64'
+module Rack
+  module Auth
+    class Basic < AbstractHandler
+      def call(env)
+        auth = Basic::Request.new(env)
+        return unauthorized unless auth.provided?
+        return bad_request unless auth.basic?
+        if valid?(auth)
+          env['REMOTE_USER'] = auth.username
+          return @app.call(env)
+        end
+        unauthorized
+      end
+      private
+      def challenge
+        'Basic realm="%s"' % realm
+      end
+      def valid?(auth)
+        @authenticator.call(*auth.credentials)
+      end
+      class Request < Auth::AbstractRequest
+        def basic?
+          "basic" == scheme && credentials.length == 2
+        end
+        def credentials
+          @credentials ||= Base64.decode64(params).split(':', 2)
+        end
+        def username
+          credentials.first
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/auth/digest/md5.rb
@@ -0,0 +1,91 @@
+require_relative '../abstract/handler'
+require_relative 'request'
+require_relative 'params'
+require_relative 'nonce'
+require 'digest/md5'
+module Rack
+  module Auth
+    module Digest
+      class MD5 < AbstractHandler
+        attr_accessor :opaque
+        attr_writer :passwords_hashed
+        def initialize(app, realm = nil, opaque = nil, &authenticator)
+          @passwords_hashed = nil
+          if opaque.nil? and realm.respond_to? :values_at
+            realm, opaque, @passwords_hashed = realm.values_at :realm, :opaque, :passwords_hashed
+          end
+          super(app, realm, &authenticator)
+          @opaque = opaque
+        end
+        def passwords_hashed?
+          !!@passwords_hashed
+        end
+        def call(env)
+          auth = Request.new(env)
+          unless auth.provided?
+            return unauthorized
+          end
+          if !auth.digest? || !auth.correct_uri? || !valid_qop?(auth)
+            return bad_request
+          end
+          if valid?(auth)
+            if auth.nonce.stale?
+              return unauthorized(challenge(stale: true))
+            else
+              env['REMOTE_USER'] = auth.username
+              return @app.call(env)
+            end
+          end
+          unauthorized
+        end
+        private
+        QOP = 'auth'
+        def params(hash = {})
+          Params.new do |params|
+            params['realm'] = realm
+            params['nonce'] = Nonce.new.to_s
+            params['opaque'] = H(opaque)
+            params['qop'] = QOP
+            hash.each { |k, v| params[k] = v }
+          end
+        end
+        def challenge(hash = {})
+          "Digest #{params(hash)}"
+        end
+        def valid?(auth)
+          valid_opaque?(auth) && valid_nonce?(auth) && valid_digest?(auth)
+        end
+        def valid_qop?(auth)
+          QOP == auth.qop
+        end
+        def valid_opaque?(auth)
+          H(opaque) == auth.opaque
+        end
+        def valid_nonce?(auth)
+          auth.nonce.valid?
+        end
+        def valid_digest?(auth)
+          pw = @authenticator.call(auth.username)
+          pw && Rack::Utils.secure_compare(digest(auth, pw), auth.response)
+        end
+        def md5(data)
+          ::Digest::MD5.hexdigest(data)
+        end
+        alias :H :md5
+        def KD(secret, data)
+          H "#{secret}:#{data}"
+        end
+        def A1(auth, password)
+          "#{auth.username}:#{auth.realm}:#{password}"
+        end
+        def A2(auth)
+          "#{auth.method}:#{auth.uri}"
+        end
+        def digest(auth, password)
+          password_hash = passwords_hashed? ? password : H(A1(auth, password))
+          KD password_hash, "#{auth.nonce}:#{auth.nc}:#{auth.cnonce}:#{QOP}:#{H A2(auth)}"
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/auth/digest/request.rb
@@ -0,0 +1,34 @@
+require_relative '../abstract/request'
+require_relative 'params'
+require_relative 'nonce'
+module Rack
+  module Auth
+    module Digest
+      class Request < Auth::AbstractRequest
+        def method
+          @env[RACK_METHODOVERRIDE_ORIGINAL_METHOD] || @env[REQUEST_METHOD]
+        end
+        def digest?
+          "digest" == scheme
+        end
+        def correct_uri?
+          request.fullpath == uri
+        end
+        def nonce
+          @nonce ||= Nonce.parse(params['nonce'])
+        end
+        def params
+          @params ||= Params.parse(parts.last)
+        end
+        def respond_to?(sym, *)
+          super or params.has_key? sym.to_s
+        end
+        def method_missing(sym, *args)
+          return super unless params.has_key?(key = sym.to_s)
+          return params[key] if args.size == 0
+          raise ArgumentError, "wrong number of arguments (#{args.size} for 0)"
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/body_proxy.rb
@@ -0,0 +1,28 @@
+module Rack
+  class BodyProxy
+    def initialize(body, &block)
+      @body = body
+      @block = block
+      @closed = false
+    end
+    def respond_to_missing?(method_name, include_all = false)
+      super or @body.respond_to?(method_name, include_all)
+    end
+    def close
+      return if @closed
+      @closed = true
+      begin
+        @body.close if @body.respond_to? :close
+      ensure
+        @block.call
+      end
+    end
+    def closed?
+      @closed
+    end
+    def method_missing(method_name, *args, &block)
+      @body.__send__(method_name, *args, &block)
+    end
+    ruby2_keywords(:method_missing) if respond_to?(:ruby2_keywords, true)
+  end
+end

--- a//dev/null
+++ b/lib/rack/builder.rb
@@ -0,0 +1,76 @@
+module Rack
+  class Builder
+    UTF_8_BOM = '\xef\xbb\xbf'
+    def self.parse_file(config, opts = Server::Options.new)
+      if config.end_with?('.ru')
+        return self.load_file(config, opts)
+      else
+        require config
+        app = Object.const_get(::File.basename(config, '.rb').split('_').map(&:capitalize).join(''))
+        return app, {}
+      end
+    end
+    def self.load_file(path, opts = Server::Options.new)
+      options = {}
+      cfgfile = ::File.read(path)
+      cfgfile.slice!(/\A#{UTF_8_BOM}/) if cfgfile.encoding == Encoding::UTF_8
+      if cfgfile[/^#\\(.*)/] && opts
+        warn "Parsing options from the first comment line is deprecated!"
+        options = opts.parse! $1.split(/\s+/)
+      end
+      cfgfile.sub!(/^__END__\n.*\Z/m, '')
+      app = new_from_string cfgfile, path
+      return app, options
+    end
+    def self.new_from_string(builder_script, file = "(rackup)")
+      binding, builder = TOPLEVEL_BINDING.eval('Rack::Builder.new.instance_eval { [binding, self] }')
+      eval builder_script, binding, file
+      builder.to_app
+    end
+    def initialize(default_app = nil, &block)
+      @use, @map, @run, @warmup, @freeze_app = [], nil, default_app, nil, false
+      instance_eval(&block) if block_given?
+    end
+    def self.app(default_app = nil, &block)
+      self.new(default_app, &block).to_app
+    end
+    def use(middleware, *args, &block)
+      if @map
+        mapping, @map = @map, nil
+        @use << proc { |app| generate_map(app, mapping) }
+      end
+      @use << proc { |app| middleware.new(app, *args, &block) }
+    end
+    ruby2_keywords(:use) if respond_to?(:ruby2_keywords, true)
+    def run(app)
+      @run = app
+    end
+    def warmup(prc = nil, &block)
+      @warmup = prc || block
+    end
+    def map(path, &block)
+      @map ||= {}
+      @map[path] = block
+    end
+    def freeze_app
+      @freeze_app = true
+    end
+    def to_app
+      app = @map ? generate_map(@run, @map) : @run
+      fail "missing run or map statement" unless app
+      app.freeze if @freeze_app
+      app = @use.reverse.inject(app) { |a, e| e[a].tap { |x| x.freeze if @freeze_app } }
+      @warmup.call(app) if @warmup
+      app
+    end
+    def call(env)
+      to_app.call(env)
+    end
+    private
+    def generate_map(default_app, mapping)
+      mapped = default_app ? { '/' => default_app } : {}
+      mapping.each { |r, b| mapped[r] = self.class.new(default_app, &b).to_app }
+      URLMap.new(mapped)
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/cascade.rb
@@ -0,0 +1,31 @@
+module Rack
+  class Cascade
+    NotFound = [404, { CONTENT_TYPE => "text/plain" }, []]
+    attr_reader :apps
+    def initialize(apps, cascade_for = [404, 405])
+      @apps = []
+      apps.each { |app| add app }
+      @cascade_for = {}
+      [*cascade_for].each { |status| @cascade_for[status] = true }
+    end
+    def call(env)
+      return [404, { CONTENT_TYPE => "text/plain" }, []] if @apps.empty?
+      result = nil
+      last_body = nil
+      @apps.each do |app|
+        last_body.close if last_body.respond_to? :close
+        result = app.call(env)
+        return result unless @cascade_for.include?(result[0].to_i)
+        last_body = result[2]
+      end
+      result
+    end
+    def add(app)
+      @apps << app
+    end
+    def include?(app)
+      @apps.include?(app)
+    end
+    alias_method :<<, :add
+  end
+end

--- a//dev/null
+++ b/lib/rack/chunked.rb
@@ -0,0 +1,64 @@
+module Rack
+  class Chunked
+    include Rack::Utils
+    class Body
+      TERM = "\r\n"
+      TAIL = "0#{TERM}"
+      def initialize(body)
+        @body = body
+      end
+      def each(&block)
+        term = TERM
+        @body.each do |chunk|
+          size = chunk.bytesize
+          next if size == 0
+          yield [size.to_s(16), term, chunk.b, term].join
+        end
+        yield TAIL
+        yield_trailers(&block)
+        yield term
+      end
+      def close
+        @body.close if @body.respond_to?(:close)
+      end
+      private
+      def yield_trailers
+      end
+    end
+    class TrailerBody < Body
+      private
+      def yield_trailers
+        @body.trailers.each_pair do |k, v|
+          yield "#{k}: #{v}\r\n"
+        end
+      end
+    end
+    def initialize(app)
+      @app = app
+    end
+    def chunkable_version?(ver)
+      case ver
+      when 'HTTP/1.0', nil, 'HTTP/0.9'
+        false
+      else
+        true
+      end
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      headers = HeaderHash[headers]
+      if chunkable_version?(env[SERVER_PROTOCOL]) &&
+         !STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) &&
+         !headers[CONTENT_LENGTH] &&
+         !headers[TRANSFER_ENCODING]
+        headers[TRANSFER_ENCODING] = 'chunked'
+        if headers['Trailer']
+          body = TrailerBody.new(body)
+        else
+          body = Body.new(body)
+        end
+      end
+      [status, headers, body]
+    end
+  end
+end

--- a/lib/rack/common_logger.rb
+++ b/lib/rack/common_logger.rb
@@ -20,21 +20,20 @@
         env["REMOTE_USER"] || "-",
         Time.now.strftime("%d/%b/%Y:%H:%M:%S %z"),
         env[REQUEST_METHOD],
         env[SCRIPT_NAME],
         env[PATH_INFO],
         env[QUERY_STRING].empty? ? "" : "?#{env[QUERY_STRING]}",
         env[SERVER_PROTOCOL],
         status.to_s[0..3],
         length,
         Utils.clock_time - began_at ]
-      msg.gsub!(/[^[:print:]\n]/) { |c| "\\x#{c.ord}" }
       logger = @logger || env[RACK_ERRORS]
       if logger.respond_to?(:write)
         logger.write(msg)
       else
         logger << msg
       end
     end
     def extract_content_length(headers)
       value = headers[CONTENT_LENGTH]
       !value || value.to_s == '0' ? '-' : value

--- a//dev/null
+++ b/lib/rack/conditional_get.rb
@@ -0,0 +1,46 @@
+module Rack
+  class ConditionalGet
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      case env[REQUEST_METHOD]
+      when "GET", "HEAD"
+        status, headers, body = @app.call(env)
+        headers = Utils::HeaderHash[headers]
+        if status == 200 && fresh?(env, headers)
+          status = 304
+          headers.delete(CONTENT_TYPE)
+          headers.delete(CONTENT_LENGTH)
+          original_body = body
+          body = Rack::BodyProxy.new([]) do
+            original_body.close if original_body.respond_to?(:close)
+          end
+        end
+        [status, headers, body]
+      else
+        @app.call(env)
+      end
+    end
+  private
+    def fresh?(env, headers)
+      if none_match = env['HTTP_IF_NONE_MATCH']
+        etag_matches?(none_match, headers)
+      elsif (modified_since = env['HTTP_IF_MODIFIED_SINCE']) && (modified_since = to_rfc2822(modified_since))
+        modified_since?(modified_since, headers)
+      end
+    end
+    def etag_matches?(none_match, headers)
+      headers['ETag'] == none_match
+    end
+    def modified_since?(modified_since, headers)
+      last_modified = to_rfc2822(headers['Last-Modified']) and
+        modified_since >= last_modified
+    end
+    def to_rfc2822(since)
+      if since && since.length >= 16
+        Time.rfc2822(since) rescue nil
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/content_length.rb
@@ -0,0 +1,24 @@
+module Rack
+  class ContentLength
+    include Rack::Utils
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      headers = HeaderHash[headers]
+      if !STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) &&
+         !headers[CONTENT_LENGTH] &&
+         !headers[TRANSFER_ENCODING]
+        obody = body
+        body, length = [], 0
+        obody.each { |part| body << part; length += part.bytesize }
+        body = BodyProxy.new(body) do
+          obody.close if obody.respond_to?(:close)
+        end
+        headers[CONTENT_LENGTH] = length.to_s
+      end
+      [status, headers, body]
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/content_type.rb
@@ -0,0 +1,16 @@
+module Rack
+  class ContentType
+    include Rack::Utils
+    def initialize(app, content_type = "text/html")
+      @app, @content_type = app, content_type
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      headers = Utils::HeaderHash[headers]
+      unless STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i)
+        headers[CONTENT_TYPE] ||= @content_type
+      end
+      [status, headers, body]
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/deflater.rb
@@ -0,0 +1,78 @@
+require "zlib"
+require "time"  # for Time.httpdate
+module Rack
+  class Deflater
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    def initialize(app, options = {})
+      @app = app
+      @condition = options[:if]
+      @compressible_types = options[:include]
+      @sync = options.fetch(:sync, true)
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      headers = Utils::HeaderHash[headers]
+      unless should_deflate?(env, status, headers, body)
+        return [status, headers, body]
+      end
+      request = Request.new(env)
+      encoding = Utils.select_best_encoding(%w(gzip identity),
+                                            request.accept_encoding)
+      vary = headers["Vary"].to_s.split(",").map(&:strip)
+      unless vary.include?("*") || vary.include?("Accept-Encoding")
+        headers["Vary"] = vary.push("Accept-Encoding").join(",")
+      end
+      case encoding
+      when "gzip"
+        headers['Content-Encoding'] = "gzip"
+        headers.delete(CONTENT_LENGTH)
+        mtime = headers["Last-Modified"]
+        mtime = Time.httpdate(mtime).to_i if mtime
+        [status, headers, GzipStream.new(body, mtime, @sync)]
+      when "identity"
+        [status, headers, body]
+      when nil
+        message = "An acceptable encoding for the requested resource #{request.fullpath} could not be found."
+        bp = Rack::BodyProxy.new([message]) { body.close if body.respond_to?(:close) }
+        [406, { CONTENT_TYPE => "text/plain", CONTENT_LENGTH => message.length.to_s }, bp]
+      end
+    end
+    class GzipStream
+      def initialize(body, mtime, sync)
+        @body = body
+        @mtime = mtime
+        @sync = sync
+      end
+      def each(&block)
+        @writer = block
+        gzip = ::Zlib::GzipWriter.new(self)
+        gzip.mtime = @mtime if @mtime
+        @body.each { |part|
+          next if part.empty?
+          gzip.write(part)
+          gzip.flush if @sync
+        }
+      ensure
+        gzip.close
+      end
+      def write(data)
+        @writer.call(data)
+      end
+      def close
+        @body.close if @body.respond_to?(:close)
+      end
+    end
+    private
+    def should_deflate?(env, status, headers, body)
+      if Utils::STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) ||
+          /\bno-transform\b/.match?(headers['Cache-Control'].to_s) ||
+          headers['Content-Encoding']&.!~(/\bidentity\b/)
+        return false
+      end
+      return false if @compressible_types && !(headers.has_key?('Content-Type') && @compressible_types.include?(headers['Content-Type'][/[^;]*/]))
+      return false if @condition && !@condition.call(env, status, headers, body)
+      return false if headers[CONTENT_LENGTH] == '0'
+      true
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/directory.rb
@@ -0,0 +1,142 @@
+require 'time'
+module Rack
+  class Directory
+    DIR_FILE = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>\n"
+    DIR_PAGE_HEADER = <<-PAGE
+<html><head>
+  <title>%s</title>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
+  <style type='text/css'>
+table { width:100%%; }
+.name { text-align:left; }
+.size, .mtime { text-align:right; }
+.type { width:11em; }
+.mtime { width:15em; }
+  </style>
+</head><body>
+<h1>%s</h1>
+<hr />
+<table>
+  <tr>
+    <th class='name'>Name</th>
+    <th class='size'>Size</th>
+    <th class='type'>Type</th>
+    <th class='mtime'>Last Modified</th>
+  </tr>
+    PAGE
+    DIR_PAGE_FOOTER = <<-PAGE
+</table>
+<hr />
+</body></html>
+    PAGE
+    class DirectoryBody < Struct.new(:root, :path, :files)
+      def each
+        show_path = Utils.escape_html(path.sub(/^#{root}/, ''))
+        yield(DIR_PAGE_HEADER % [ show_path, show_path ])
+        unless path.chomp('/') == root
+          yield(DIR_FILE % DIR_FILE_escape(files.call('..')))
+        end
+        Dir.foreach(path) do |basename|
+          next if basename.start_with?('.')
+          next unless f = files.call(basename)
+          yield(DIR_FILE % DIR_FILE_escape(f))
+        end
+        yield(DIR_PAGE_FOOTER)
+      end
+      private
+      def DIR_FILE_escape(htmls)
+        htmls.map { |e| Utils.escape_html(e) }
+      end
+    end
+    attr_reader :root
+    def initialize(root, app = nil)
+      @root = ::File.expand_path(root)
+      @app = app || Files.new(@root)
+      @head = Head.new(method(:get))
+    end
+    def call(env)
+      @head.call env
+    end
+    def get(env)
+      script_name = env[SCRIPT_NAME]
+      path_info = Utils.unescape_path(env[PATH_INFO])
+      if client_error_response = check_bad_request(path_info) || check_forbidden(path_info)
+        client_error_response
+      else
+        path = ::File.join(@root, path_info)
+        list_path(env, path, path_info, script_name)
+      end
+    end
+    def check_bad_request(path_info)
+      return if Utils.valid_path?(path_info)
+      body = "Bad Request\n"
+      [400, { CONTENT_TYPE => "text/plain",
+        CONTENT_LENGTH => body.bytesize.to_s,
+        "X-Cascade" => "pass" }, [body]]
+    end
+    def check_forbidden(path_info)
+      return unless path_info.include? ".."
+      return if ::File.expand_path(::File.join(@root, path_info)).start_with?(@root)
+      body = "Forbidden\n"
+      [403, { CONTENT_TYPE => "text/plain",
+        CONTENT_LENGTH => body.bytesize.to_s,
+        "X-Cascade" => "pass" }, [body]]
+    end
+    def list_directory(path_info, path, script_name)
+      url_head = (script_name.split('/') + path_info.split('/')).map do |part|
+        Utils.escape_path part
+      end
+      body = DirectoryBody.new(@root, path, ->(basename) do
+        stat = stat(::File.join(path, basename))
+        next unless stat
+        url = ::File.join(*url_head + [Utils.escape_path(basename)])
+        mtime = stat.mtime.httpdate
+        if stat.directory?
+          type = 'directory'
+          size = '-'
+          url << '/'
+          if basename == '..'
+            basename = 'Parent Directory'
+          else
+            basename << '/'
+          end
+        else
+          type = Mime.mime_type(::File.extname(basename))
+          size = filesize_format(stat.size)
+        end
+        [ url, basename, size, type, mtime ]
+      end)
+      [ 200, { CONTENT_TYPE => 'text/html; charset=utf-8' }, body ]
+    end
+    def stat(path)
+      ::File.stat(path)
+    rescue Errno::ENOENT, Errno::ELOOP
+      return nil
+    end
+    def list_path(env, path, path_info, script_name)
+      if (stat = stat(path)) && stat.readable?
+        return @app.call(env) if stat.file?
+        return list_directory(path_info, path, script_name) if stat.directory?
+      end
+      entity_not_found(path_info)
+    end
+    def entity_not_found(path_info)
+      body = "Entity not found: #{path_info}\n"
+      [404, { CONTENT_TYPE => "text/plain",
+        CONTENT_LENGTH => body.bytesize.to_s,
+        "X-Cascade" => "pass" }, [body]]
+    end
+    FILESIZE_FORMAT = [
+      ['%.1fT', 1 << 40],
+      ['%.1fG', 1 << 30],
+      ['%.1fM', 1 << 20],
+      ['%.1fK', 1 << 10],
+    ]
+    def filesize_format(int)
+      FILESIZE_FORMAT.each do |format, size|
+        return format % (int.to_f / size) if int >= size
+      end
+      "#{int}B"
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/etag.rb
@@ -0,0 +1,51 @@
+require_relative '../rack'
+require 'digest/sha2'
+module Rack
+  class ETag
+    ETAG_STRING = Rack::ETAG
+    DEFAULT_CACHE_CONTROL = "max-age=0, private, must-revalidate"
+    def initialize(app, no_cache_control = nil, cache_control = DEFAULT_CACHE_CONTROL)
+      @app = app
+      @cache_control = cache_control
+      @no_cache_control = no_cache_control
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      if etag_status?(status) && etag_body?(body) && !skip_caching?(headers)
+        original_body = body
+        digest, new_body = digest_body(body)
+        body = Rack::BodyProxy.new(new_body) do
+          original_body.close if original_body.respond_to?(:close)
+        end
+        headers[ETAG_STRING] = %(W/"#{digest}") if digest
+      end
+      unless headers[CACHE_CONTROL]
+        if digest
+          headers[CACHE_CONTROL] = @cache_control if @cache_control
+        else
+          headers[CACHE_CONTROL] = @no_cache_control if @no_cache_control
+        end
+      end
+      [status, headers, body]
+    end
+    private
+      def etag_status?(status)
+        status == 200 || status == 201
+      end
+      def etag_body?(body)
+        !body.respond_to?(:to_path)
+      end
+      def skip_caching?(headers)
+        headers.key?(ETAG_STRING) || headers.key?('Last-Modified')
+      end
+      def digest_body(body)
+        parts = []
+        digest = nil
+        body.each do |part|
+          parts << part
+          (digest ||= Digest::SHA256.new) << part unless part.empty?
+        end
+        [digest && digest.hexdigest.byteslice(0, 32), parts]
+      end
+  end
+end

--- a//dev/null
+++ b/lib/rack/events.rb
@@ -0,0 +1,77 @@
+module Rack
+  class Events
+    module Abstract
+      def on_start(req, res)
+      end
+      def on_commit(req, res)
+      end
+      def on_send(req, res)
+      end
+      def on_finish(req, res)
+      end
+      def on_error(req, res, e)
+      end
+    end
+    class EventedBodyProxy < Rack::BodyProxy # :nodoc:
+      attr_reader :request, :response
+      def initialize(body, request, response, handlers, &block)
+        super(body, &block)
+        @request  = request
+        @response = response
+        @handlers = handlers
+      end
+      def each
+        @handlers.reverse_each { |handler| handler.on_send request, response }
+        super
+      end
+    end
+    class BufferedResponse < Rack::Response::Raw # :nodoc:
+      attr_reader :body
+      def initialize(status, headers, body)
+        super(status, headers)
+        @body = body
+      end
+      def to_a; [status, headers, body]; end
+    end
+    def initialize(app, handlers)
+      @app      = app
+      @handlers = handlers
+    end
+    def call(env)
+      request = make_request env
+      on_start request, nil
+      begin
+        status, headers, body = @app.call request.env
+        response = make_response status, headers, body
+        on_commit request, response
+      rescue StandardError => e
+        on_error request, response, e
+        on_finish request, response
+        raise
+      end
+      body = EventedBodyProxy.new(body, request, response, @handlers) do
+        on_finish request, response
+      end
+      [response.status, response.headers, body]
+    end
+    private
+    def on_error(request, response, e)
+      @handlers.reverse_each { |handler| handler.on_error request, response, e }
+    end
+    def on_commit(request, response)
+      @handlers.reverse_each { |handler| handler.on_commit request, response }
+    end
+    def on_start(request, response)
+      @handlers.each { |handler| handler.on_start request, nil }
+    end
+    def on_finish(request, response)
+      @handlers.reverse_each { |handler| handler.on_finish request, response }
+    end
+    def make_request(env)
+      Rack::Request.new env
+    end
+    def make_response(status, headers, body)
+      BufferedResponse.new status, headers, body
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/file.rb
@@ -0,0 +1,4 @@
+require_relative 'files'
+module Rack
+  File = Files
+end

--- a//dev/null
+++ b/lib/rack/files.rb
@@ -0,0 +1,156 @@
+require 'time'
+module Rack
+  class Files
+    ALLOWED_VERBS = %w[GET HEAD OPTIONS]
+    ALLOW_HEADER = ALLOWED_VERBS.join(', ')
+    MULTIPART_BOUNDARY = 'AaB03x'
+    def self.method_added(name)
+      if name == :response_body
+        raise "#{self.class}\#response_body is no longer supported."
+      end
+      super
+    end
+    attr_reader :root
+    def initialize(root, headers = {}, default_mime = 'text/plain')
+      @root = (::File.expand_path(root) if root)
+      @headers = headers
+      @default_mime = default_mime
+      @head = Rack::Head.new(lambda { |env| get env })
+    end
+    def call(env)
+      @head.call env
+    end
+    def get(env)
+      request = Rack::Request.new env
+      unless ALLOWED_VERBS.include? request.request_method
+        return fail(405, "Method Not Allowed", { 'Allow' => ALLOW_HEADER })
+      end
+      path_info = Utils.unescape_path request.path_info
+      return fail(400, "Bad Request") unless Utils.valid_path?(path_info)
+      clean_path_info = Utils.clean_path_info(path_info)
+      path = ::File.join(@root, clean_path_info)
+      available = begin
+        ::File.file?(path) && ::File.readable?(path)
+      rescue SystemCallError
+        false
+      end
+      if available
+        serving(request, path)
+      else
+        fail(404, "File not found: #{path_info}")
+      end
+    end
+    def serving(request, path)
+      if request.options?
+        return [200, { 'Allow' => ALLOW_HEADER, CONTENT_LENGTH => '0' }, []]
+      end
+      last_modified = ::File.mtime(path).httpdate
+      return [304, {}, []] if request.get_header('HTTP_IF_MODIFIED_SINCE') == last_modified
+      headers = { "Last-Modified" => last_modified }
+      mime_type = mime_type path, @default_mime
+      headers[CONTENT_TYPE] = mime_type if mime_type
+      headers.merge!(@headers) if @headers
+      status = 200
+      size = filesize path
+      ranges = Rack::Utils.get_byte_ranges(request.get_header('HTTP_RANGE'), size)
+      if ranges.nil?
+        ranges = [0..size - 1]
+      elsif ranges.empty?
+        response = fail(416, "Byte range unsatisfiable")
+        response[1]["Content-Range"] = "bytes */#{size}"
+        return response
+      elsif ranges.size >= 1
+        partial_content = true
+        if ranges.size == 1
+          range = ranges[0]
+          headers["Content-Range"] = "bytes #{range.begin}-#{range.end}/#{size}"
+        else
+          headers[CONTENT_TYPE] = "multipart/byteranges; boundary=#{MULTIPART_BOUNDARY}"
+        end
+        status = 206
+        body = BaseIterator.new(path, ranges, mime_type: mime_type, size: size)
+        size = body.bytesize
+      end
+      headers[CONTENT_LENGTH] = size.to_s
+      if request.head?
+        body = []
+      elsif !partial_content
+        body = Iterator.new(path, ranges, mime_type: mime_type, size: size)
+      end
+      [status, headers, body]
+    end
+    class BaseIterator
+      attr_reader :path, :ranges, :options
+      def initialize(path, ranges, options)
+        @path = path
+        @ranges = ranges
+        @options = options
+      end
+      def each
+        ::File.open(path, "rb") do |file|
+          ranges.each do |range|
+            yield multipart_heading(range) if multipart?
+            each_range_part(file, range) do |part|
+              yield part
+            end
+          end
+          yield "\r\n--#{MULTIPART_BOUNDARY}--\r\n" if multipart?
+        end
+      end
+      def bytesize
+        size = ranges.inject(0) do |sum, range|
+          sum += multipart_heading(range).bytesize if multipart?
+          sum += range.size
+        end
+        size += "\r\n--#{MULTIPART_BOUNDARY}--\r\n".bytesize if multipart?
+        size
+      end
+      def close; end
+      private
+      def multipart?
+        ranges.size > 1
+      end
+      def multipart_heading(range)
+<<-EOF
+\r
+--#{MULTIPART_BOUNDARY}\r
+Content-Type: #{options[:mime_type]}\r
+Content-Range: bytes #{range.begin}-#{range.end}/#{options[:size]}\r
+\r
+EOF
+      end
+      def each_range_part(file, range)
+        file.seek(range.begin)
+        remaining_len = range.end - range.begin + 1
+        while remaining_len > 0
+          part = file.read([8192, remaining_len].min)
+          break unless part
+          remaining_len -= part.length
+          yield part
+        end
+      end
+    end
+    class Iterator < BaseIterator
+      alias :to_path :path
+    end
+    private
+    def fail(status, body, headers = {})
+      body += "\n"
+      [
+        status,
+        {
+          CONTENT_TYPE   => "text/plain",
+          CONTENT_LENGTH => body.size.to_s,
+          "X-Cascade" => "pass"
+        }.merge!(headers),
+        [body]
+      ]
+    end
+    def mime_type(path, default_mime)
+      Mime.mime_type(::File.extname(path), default_mime)
+    end
+    def filesize(path)
+      ::File.size?(path) || ::File.read(path).bytesize
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/cgi.rb
@@ -0,0 +1,50 @@
+module Rack
+  module Handler
+    class CGI
+      def self.run(app, **options)
+        $stdin.binmode
+        serve app
+      end
+      def self.serve(app)
+        env = ENV.to_hash
+        env.delete "HTTP_CONTENT_LENGTH"
+        env[SCRIPT_NAME] = ""  if env[SCRIPT_NAME] == "/"
+        env.update(
+          RACK_VERSION      => Rack::VERSION,
+          RACK_INPUT        => Rack::RewindableInput.new($stdin),
+          RACK_ERRORS       => $stderr,
+          RACK_MULTITHREAD  => false,
+          RACK_MULTIPROCESS => true,
+          RACK_RUNONCE      => true,
+          RACK_URL_SCHEME   => ["yes", "on", "1"].include?(ENV[HTTPS]) ? "https" : "http"
+        )
+        env[QUERY_STRING] ||= ""
+        env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
+        env[REQUEST_PATH] ||= "/"
+        status, headers, body = app.call(env)
+        begin
+          send_headers status, headers
+          send_body body
+        ensure
+          body.close  if body.respond_to? :close
+        end
+      end
+      def self.send_headers(status, headers)
+        $stdout.print "Status: #{status}\r\n"
+        headers.each { |k, vs|
+          vs.split("\n").each { |v|
+            $stdout.print "#{k}: #{v}\r\n"
+          }
+        }
+        $stdout.print "\r\n"
+        $stdout.flush
+      end
+      def self.send_body(body)
+        body.each { |part|
+          $stdout.print part
+          $stdout.flush
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/fastcgi.rb
@@ -0,0 +1,85 @@
+require 'fcgi'
+require 'socket'
+if defined? FCGI::Stream
+  class FCGI::Stream
+    alias _rack_read_without_buffer read
+    def read(n, buffer = nil)
+      buf = _rack_read_without_buffer n
+      buffer.replace(buf.to_s)  if buffer
+      buf
+    end
+  end
+end
+module Rack
+  module Handler
+    class FastCGI
+      def self.run(app, **options)
+        if options[:File]
+          STDIN.reopen(UNIXServer.new(options[:File]))
+        elsif options[:Port]
+          STDIN.reopen(TCPServer.new(options[:Host], options[:Port]))
+        end
+        FCGI.each { |request|
+          serve request, app
+        }
+      end
+      def self.valid_options
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+        {
+          "Host=HOST" => "Hostname to listen on (default: #{default_host})",
+          "Port=PORT" => "Port to listen on (default: 8080)",
+          "File=PATH" => "Creates a Domain socket at PATH instead of a TCP socket. Ignores Host and Port if set.",
+        }
+      end
+      def self.serve(request, app)
+        env = request.env
+        env.delete "HTTP_CONTENT_LENGTH"
+        env[SCRIPT_NAME] = ""  if env[SCRIPT_NAME] == "/"
+        rack_input = RewindableInput.new(request.in)
+        env.update(
+          RACK_VERSION      => Rack::VERSION,
+          RACK_INPUT        => rack_input,
+          RACK_ERRORS       => request.err,
+          RACK_MULTITHREAD  => false,
+          RACK_MULTIPROCESS => true,
+          RACK_RUNONCE      => false,
+          RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http"
+        )
+        env[QUERY_STRING] ||= ""
+        env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
+        env[REQUEST_PATH] ||= "/"
+        env.delete "CONTENT_TYPE"  if env["CONTENT_TYPE"] == ""
+        env.delete "CONTENT_LENGTH"  if env["CONTENT_LENGTH"] == ""
+        begin
+          status, headers, body = app.call(env)
+          begin
+            send_headers request.out, status, headers
+            send_body request.out, body
+          ensure
+            body.close  if body.respond_to? :close
+          end
+        ensure
+          rack_input.close
+          request.finish
+        end
+      end
+      def self.send_headers(out, status, headers)
+        out.print "Status: #{status}\r\n"
+        headers.each { |k, vs|
+          vs.split("\n").each { |v|
+            out.print "#{k}: #{v}\r\n"
+          }
+        }
+        out.print "\r\n"
+        out.flush
+      end
+      def self.send_body(out, body)
+        body.each { |part|
+          out.print part
+          out.flush
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/lsws.rb
@@ -0,0 +1,55 @@
+require 'lsapi'
+module Rack
+  module Handler
+    class LSWS
+      def self.run(app, **options)
+        while LSAPI.accept != nil
+          serve app
+        end
+      end
+      def self.serve(app)
+        env = ENV.to_hash
+        env.delete "HTTP_CONTENT_LENGTH"
+        env[SCRIPT_NAME] = "" if env[SCRIPT_NAME] == "/"
+        rack_input = RewindableInput.new($stdin.read.to_s)
+        env.update(
+          RACK_VERSION      => Rack::VERSION,
+          RACK_INPUT        => rack_input,
+          RACK_ERRORS       => $stderr,
+          RACK_MULTITHREAD  => false,
+          RACK_MULTIPROCESS => true,
+          RACK_RUNONCE      => false,
+          RACK_URL_SCHEME   => ["yes", "on", "1"].include?(ENV[HTTPS]) ? "https" : "http"
+        )
+        env[QUERY_STRING] ||= ""
+        env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
+        env[REQUEST_PATH] ||= "/"
+        status, headers, body = app.call(env)
+        begin
+          send_headers status, headers
+          send_body body
+        ensure
+          body.close if body.respond_to? :close
+        end
+      ensure
+        rack_input.close
+      end
+      def self.send_headers(status, headers)
+        print "Status: #{status}\r\n"
+        headers.each { |k, vs|
+          vs.split("\n").each { |v|
+            print "#{k}: #{v}\r\n"
+          }
+        }
+        print "\r\n"
+        STDOUT.flush
+      end
+      def self.send_body(body)
+        body.each { |part|
+          print part
+          STDOUT.flush
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/scgi.rb
@@ -0,0 +1,60 @@
+require 'scgi'
+require 'stringio'
+module Rack
+  module Handler
+    class SCGI < ::SCGI::Processor
+      attr_accessor :app
+      def self.run(app, **options)
+        options[:Socket] = UNIXServer.new(options[:File]) if options[:File]
+        new(options.merge(app: app,
+                          host: options[:Host],
+                          port: options[:Port],
+                          socket: options[:Socket])).listen
+      end
+      def self.valid_options
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+        {
+          "Host=HOST" => "Hostname to listen on (default: #{default_host})",
+          "Port=PORT" => "Port to listen on (default: 8080)",
+        }
+      end
+      def initialize(settings = {})
+        @app = settings[:app]
+        super(settings)
+      end
+      def process_request(request, input_body, socket)
+        env = Hash[request]
+        env.delete "HTTP_CONTENT_TYPE"
+        env.delete "HTTP_CONTENT_LENGTH"
+        env[REQUEST_PATH], env[QUERY_STRING] = env["REQUEST_URI"].split('?', 2)
+        env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
+        env[PATH_INFO] = env[REQUEST_PATH]
+        env[QUERY_STRING] ||= ""
+        env[SCRIPT_NAME] = ""
+        rack_input = StringIO.new(input_body)
+        rack_input.set_encoding(Encoding::BINARY)
+        env.update(
+          RACK_VERSION      => Rack::VERSION,
+          RACK_INPUT        => rack_input,
+          RACK_ERRORS       => $stderr,
+          RACK_MULTITHREAD  => true,
+          RACK_MULTIPROCESS => true,
+          RACK_RUNONCE      => false,
+          RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http"
+        )
+        status, headers, body = app.call(env)
+        begin
+          socket.write("Status: #{status}\r\n")
+          headers.each do |k, vs|
+            vs.split("\n").each { |v| socket.write("#{k}: #{v}\r\n")}
+          end
+          socket.write("\r\n")
+          body.each {|s| socket.write(s)}
+        ensure
+          body.close if body.respond_to? :close
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/thin.rb
@@ -0,0 +1,35 @@
+require "thin"
+require "thin/server"
+require "thin/logging"
+require "thin/backends/tcp_server"
+module Rack
+  module Handler
+    class Thin
+      def self.run(app, **options)
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+        if block_given?
+          host = options.delete(:Host) || default_host
+          port = options.delete(:Port) || 8080
+          args = [host, port, app, options]
+          args.pop if ::Thin::VERSION::MAJOR < 1 && ::Thin::VERSION::MINOR < 8
+          server = ::Thin::Server.new(*args)
+          yield server
+          server.start
+        else
+          options[:address] = options[:Host] || default_host
+          options[:port] = options[:Port] || 8080
+          ::Thin::Controllers::Controller.new(options).start
+        end
+      end
+      def self.valid_options
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+        {
+          "Host=HOST" => "Hostname to listen on (default: #{default_host})",
+          "Port=PORT" => "Port to listen on (default: 8080)",
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/handler/webrick.rb
@@ -0,0 +1,105 @@
+require 'webrick'
+require 'stringio'
+class WEBrick::HTTPResponse
+  attr_accessor :rack
+  alias _rack_setup_header setup_header
+  def setup_header
+    app_chunking = rack && @header['transfer-encoding'] == 'chunked'
+    @chunked = app_chunking if app_chunking
+    _rack_setup_header
+    @chunked = false if app_chunking
+  end
+end
+module Rack
+  module Handler
+    class WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
+      def self.run(app, **options)
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : nil
+        if !options[:BindAddress] || options[:Host]
+          options[:BindAddress] = options.delete(:Host) || default_host
+        end
+        options[:Port] ||= 8080
+        if options[:SSLEnable]
+          require 'webrick/https'
+        end
+        @server = ::WEBrick::HTTPServer.new(options)
+        @server.mount "/", Rack::Handler::WEBrick, app
+        yield @server  if block_given?
+        @server.start
+      end
+      def self.valid_options
+        environment  = ENV['RACK_ENV'] || 'development'
+        default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+        {
+          "Host=HOST" => "Hostname to listen on (default: #{default_host})",
+          "Port=PORT" => "Port to listen on (default: 8080)",
+        }
+      end
+      def self.shutdown
+        if @server
+          @server.shutdown
+          @server = nil
+        end
+      end
+      def initialize(server, app)
+        super server
+        @app = app
+      end
+      def service(req, res)
+        res.rack = true
+        env = req.meta_vars
+        env.delete_if { |k, v| v.nil? }
+        rack_input = StringIO.new(req.body.to_s)
+        rack_input.set_encoding(Encoding::BINARY)
+        env.update(
+          RACK_VERSION      => Rack::VERSION,
+          RACK_INPUT        => rack_input,
+          RACK_ERRORS       => $stderr,
+          RACK_MULTITHREAD  => true,
+          RACK_MULTIPROCESS => false,
+          RACK_RUNONCE      => false,
+          RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http",
+          RACK_IS_HIJACK    => true,
+          RACK_HIJACK       => lambda { raise NotImplementedError, "only partial hijack is supported."},
+          RACK_HIJACK_IO    => nil
+        )
+        env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
+        env[QUERY_STRING] ||= ""
+        unless env[PATH_INFO] == ""
+          path, n = req.request_uri.path, env[SCRIPT_NAME].length
+          env[PATH_INFO] = path[n, path.length - n]
+        end
+        env[REQUEST_PATH] ||= [env[SCRIPT_NAME], env[PATH_INFO]].join
+        status, headers, body = @app.call(env)
+        begin
+          res.status = status.to_i
+          io_lambda = nil
+          headers.each { |k, vs|
+            if k == RACK_HIJACK
+              io_lambda = vs
+            elsif k.downcase == "set-cookie"
+              res.cookies.concat vs.split("\n")
+            else
+              res[k] = vs.split("\n").join(", ")
+            end
+          }
+          if io_lambda
+            rd, wr = IO.pipe
+            res.body = rd
+            res.chunked = true
+            io_lambda.call wr
+          elsif body.respond_to?(:to_path)
+            res.body = ::File.open(body.to_path, 'rb')
+          else
+            body.each { |part|
+              res.body << part
+            }
+          end
+        ensure
+          body.close  if body.respond_to? :close
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/head.rb
@@ -0,0 +1,19 @@
+module Rack
+  class Head
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      if env[REQUEST_METHOD] == HEAD
+        [
+          status, headers, Rack::BodyProxy.new([]) do
+            body.close if body.respond_to? :close
+          end
+        ]
+      else
+        [status, headers, body]
+      end
+    end
+  end
+end

--- a/lib/rack/lint.rb
+++ b/lib/rack/lint.rb
@@ -127,21 +127,21 @@
       }
       assert("rack.version must be an Array, was #{env[RACK_VERSION].class}") {
         env[RACK_VERSION].kind_of? Array
       }
       assert("rack.url_scheme unknown: #{env[RACK_URL_SCHEME].inspect}") {
         %w[http https].include?(env[RACK_URL_SCHEME])
       }
       check_input env[RACK_INPUT]
       check_error env[RACK_ERRORS]
       check_hijack env
-      assert("REQUEST_METHOD unknown: #{env[REQUEST_METHOD].dump}") {
+      assert("REQUEST_METHOD unknown: #{env[REQUEST_METHOD]}") {
         env[REQUEST_METHOD] =~ /\A[0-9A-Za-z!\#$%&'*+.^_`|~-]+\z/
       }
       assert("SCRIPT_NAME must start with /") {
         !env.include?(SCRIPT_NAME) ||
         env[SCRIPT_NAME] == "" ||
         env[SCRIPT_NAME] =~ /\A\//
       }
       assert("PATH_INFO must start with /") {
         !env.include?(PATH_INFO) ||
         env[PATH_INFO] == "" ||

--- a//dev/null
+++ b/lib/rack/lobster.rb
@@ -0,0 +1,58 @@
+require 'zlib'
+module Rack
+  class Lobster
+    LobsterString = Zlib::Inflate.inflate("eJx9kEEOwyAMBO99xd7MAcytUhPlJyj2
+    P6jy9i4k9EQyGAnBarEXeCBqSkntNXsi/ZCvC48zGQoZKikGrFMZvgS5ZHd+aGWVuWwhVF0
+    t1drVmiR42HcWNz5w3QanT+2gIvTVCiE1lm1Y0eU4JGmIIbaKwextKn8rvW+p5PIwFl8ZWJ
+    I8jyiTlhTcYXkekJAzTyYN6E08A+dk8voBkAVTJQ==".delete("\n ").unpack("m*")[0])
+    LambdaLobster = lambda { |env|
+      if env[QUERY_STRING].include?("flip")
+        lobster = LobsterString.split("\n").
+          map { |line| line.ljust(42).reverse }.
+          join("\n")
+        href = "?"
+      else
+        lobster = LobsterString
+        href = "?flip"
+      end
+      content = ["<title>Lobstericious!</title>",
+                 "<pre>", lobster, "</pre>",
+                 "<a href='#{href}'>flip!</a>"]
+      length = content.inject(0) { |a, e| a + e.size }.to_s
+      [200, { CONTENT_TYPE => "text/html", CONTENT_LENGTH => length }, content]
+    }
+    def call(env)
+      req = Request.new(env)
+      if req.GET["flip"] == "left"
+        lobster = LobsterString.split("\n").map do |line|
+          line.ljust(42).reverse.
+            gsub('\\', 'TEMP').
+            gsub('/', '\\').
+            gsub('TEMP', '/').
+            gsub('{', '}').
+            gsub('(', ')')
+        end.join("\n")
+        href = "?flip=right"
+      elsif req.GET["flip"] == "crash"
+        raise "Lobster crashed"
+      else
+        lobster = LobsterString
+        href = "?flip=left"
+      end
+      res = Response.new
+      res.write "<title>Lobstericious!</title>"
+      res.write "<pre>"
+      res.write lobster
+      res.write "</pre>"
+      res.write "<p><a href='#{href}'>flip!</a></p>"
+      res.write "<p><a href='?flip=crash'>crash!</a></p>"
+      res.finish
+    end
+  end
+end
+if $0 == __FILE__
+  require_relative '../rack'
+  Rack::Server.start(
+    app: Rack::ShowExceptions.new(Rack::Lint.new(Rack::Lobster.new)), Port: 9292
+  )
+end

--- a//dev/null
+++ b/lib/rack/lock.rb
@@ -0,0 +1,24 @@
+require 'thread'
+module Rack
+  class Lock
+    def initialize(app, mutex = Mutex.new)
+      @app, @mutex = app, mutex
+    end
+    def call(env)
+      @mutex.lock
+      @env = env
+      @old_rack_multithread = env[RACK_MULTITHREAD]
+      begin
+        response = @app.call(env.merge!(RACK_MULTITHREAD => false))
+        returned = response << BodyProxy.new(response.pop) { unlock }
+      ensure
+        unlock unless returned
+      end
+    end
+    private
+    def unlock
+      @mutex.unlock
+      @env[RACK_MULTITHREAD] = @old_rack_multithread
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/mock.rb
@@ -0,0 +1,182 @@
+require 'uri'
+require 'stringio'
+require_relative '../rack'
+require 'cgi/cookie'
+module Rack
+  class MockRequest
+    class FatalWarning < RuntimeError
+    end
+    class FatalWarner
+      def puts(warning)
+        raise FatalWarning, warning
+      end
+      def write(warning)
+        raise FatalWarning, warning
+      end
+      def flush
+      end
+      def string
+        ""
+      end
+    end
+    DEFAULT_ENV = {
+      RACK_VERSION      => Rack::VERSION,
+      RACK_INPUT        => StringIO.new,
+      RACK_ERRORS       => StringIO.new,
+      RACK_MULTITHREAD  => true,
+      RACK_MULTIPROCESS => true,
+      RACK_RUNONCE      => false,
+    }.freeze
+    def initialize(app)
+      @app = app
+    end
+    def get(uri, opts = {})     request(GET, uri, opts)     end
+    def post(uri, opts = {})    request(POST, uri, opts)    end
+    def put(uri, opts = {})     request(PUT, uri, opts)     end
+    def patch(uri, opts = {})   request(PATCH, uri, opts)   end
+    def delete(uri, opts = {})  request(DELETE, uri, opts)  end
+    def head(uri, opts = {})    request(HEAD, uri, opts)    end
+    def options(uri, opts = {}) request(OPTIONS, uri, opts) end
+    def request(method = GET, uri = "", opts = {})
+      env = self.class.env_for(uri, opts.merge(method: method))
+      if opts[:lint]
+        app = Rack::Lint.new(@app)
+      else
+        app = @app
+      end
+      errors = env[RACK_ERRORS]
+      status, headers, body = app.call(env)
+      MockResponse.new(status, headers, body, errors)
+    ensure
+      body.close if body.respond_to?(:close)
+    end
+    def self.parse_uri_rfc2396(uri)
+      @parser ||= URI::Parser.new
+      @parser.parse(uri)
+    end
+    def self.env_for(uri = "", opts = {})
+      uri = parse_uri_rfc2396(uri)
+      uri.path = "/#{uri.path}" unless uri.path[0] == ?/
+      env = DEFAULT_ENV.dup
+      env[REQUEST_METHOD]  = (opts[:method] ? opts[:method].to_s.upcase : GET).b
+      env[SERVER_NAME]     = (uri.host || "example.org").b
+      env[SERVER_PORT]     = (uri.port ? uri.port.to_s : "80").b
+      env[QUERY_STRING]    = (uri.query.to_s).b
+      env[PATH_INFO]       = ((!uri.path || uri.path.empty?) ? "/" : uri.path).b
+      env[RACK_URL_SCHEME] = (uri.scheme || "http").b
+      env[HTTPS]           = (env[RACK_URL_SCHEME] == "https" ? "on" : "off").b
+      env[SCRIPT_NAME] = opts[:script_name] || ""
+      if opts[:fatal]
+        env[RACK_ERRORS] = FatalWarner.new
+      else
+        env[RACK_ERRORS] = StringIO.new
+      end
+      if params = opts[:params]
+        if env[REQUEST_METHOD] == GET
+          params = Utils.parse_nested_query(params) if params.is_a?(String)
+          params.update(Utils.parse_nested_query(env[QUERY_STRING]))
+          env[QUERY_STRING] = Utils.build_nested_query(params)
+        elsif !opts.has_key?(:input)
+          opts["CONTENT_TYPE"] = "application/x-www-form-urlencoded"
+          if params.is_a?(Hash)
+            if data = Rack::Multipart.build_multipart(params)
+              opts[:input] = data
+              opts["CONTENT_LENGTH"] ||= data.length.to_s
+              opts["CONTENT_TYPE"] = "multipart/form-data; boundary=#{Rack::Multipart::MULTIPART_BOUNDARY}"
+            else
+              opts[:input] = Utils.build_nested_query(params)
+            end
+          else
+            opts[:input] = params
+          end
+        end
+      end
+      empty_str = String.new
+      opts[:input] ||= empty_str
+      if String === opts[:input]
+        rack_input = StringIO.new(opts[:input])
+      else
+        rack_input = opts[:input]
+      end
+      rack_input.set_encoding(Encoding::BINARY)
+      env[RACK_INPUT] = rack_input
+      env["CONTENT_LENGTH"] ||= env[RACK_INPUT].size.to_s if env[RACK_INPUT].respond_to?(:size)
+      opts.each { |field, value|
+        env[field] = value  if String === field
+      }
+      env
+    end
+  end
+  class MockResponse < Rack::Response
+    class << self
+      alias [] new
+    end
+    attr_reader :original_headers, :cookies
+    attr_accessor :errors
+    def initialize(status, headers, body, errors = StringIO.new(""))
+      @original_headers = headers
+      @errors           = errors.string if errors.respond_to?(:string)
+      @cookies = parse_cookies_from_header
+      super(body, status, headers)
+      buffered_body!
+    end
+    def =~(other)
+      body =~ other
+    end
+    def match(other)
+      body.match other
+    end
+    def body
+      buffer = String.new
+      super.each do |chunk|
+        buffer << chunk
+      end
+      return buffer
+    end
+    def empty?
+      [201, 204, 304].include? status
+    end
+    def cookie(name)
+      cookies.fetch(name, nil)
+    end
+    private
+    def parse_cookies_from_header
+      cookies = Hash.new
+      if original_headers.has_key? 'Set-Cookie'
+        set_cookie_header = original_headers.fetch('Set-Cookie')
+        set_cookie_header.split("\n").each do |cookie|
+          cookie_name, cookie_filling = cookie.split('=', 2)
+          cookie_attributes = identify_cookie_attributes cookie_filling
+          parsed_cookie = CGI::Cookie.new(
+            'name' => cookie_name.strip,
+            'value' => cookie_attributes.fetch('value'),
+            'path' => cookie_attributes.fetch('path', nil),
+            'domain' => cookie_attributes.fetch('domain', nil),
+            'expires' => cookie_attributes.fetch('expires', nil),
+            'secure' => cookie_attributes.fetch('secure', false)
+          )
+          cookies.store(cookie_name, parsed_cookie)
+        end
+      end
+      cookies
+    end
+    def identify_cookie_attributes(cookie_filling)
+      cookie_bits = cookie_filling.split(';')
+      cookie_attributes = Hash.new
+      cookie_attributes.store('value', cookie_bits[0].strip)
+      cookie_bits.each do |bit|
+        if bit.include? '='
+          cookie_attribute, attribute_value = bit.split('=')
+          cookie_attributes.store(cookie_attribute.strip, attribute_value.strip)
+          if cookie_attribute.include? 'max-age'
+            cookie_attributes.store('expires', Time.now + attribute_value.strip.to_i)
+          end
+        end
+        if bit.include? 'secure'
+          cookie_attributes.store('secure', true)
+        end
+      end
+      cookie_attributes
+    end
+  end
+end

--- a/lib/rack/multipart.rb
+++ b/lib/rack/multipart.rb
@@ -2,21 +2,22 @@
 module Rack
   module Multipart
     autoload :UploadedFile, 'rack/multipart/uploaded_file'
     autoload :Generator, 'rack/multipart/generator'
     EOL = "\r\n"
     MULTIPART_BOUNDARY = "AaB03x"
     MULTIPART = %r|\Amultipart/.*boundary=\"?([^\";,]+)\"?|ni
     TOKEN = /[^\s()<>,;:\\"\/\[\]?=]+/
     CONDISP = /Content-Disposition:\s*#{TOKEN}\s*/i
     VALUE = /"(?:\\"|[^"])*"|#{TOKEN}/
-    BROKEN = /^#{CONDISP}.*;\s*filename=(#{VALUE})/i
+    BROKEN_QUOTED = /^#{CONDISP}.*;\s*filename="(.*?)"(?:\s*$|\s*;\s*#{TOKEN}=)/i
+    BROKEN_UNQUOTED = /^#{CONDISP}.*;\s*filename=(#{TOKEN})/i
     MULTIPART_CONTENT_TYPE = /Content-Type: (.*)#{EOL}/ni
     MULTIPART_CONTENT_DISPOSITION = /Content-Disposition:.*;\s*name=(#{VALUE})/ni
     MULTIPART_CONTENT_ID = /Content-ID:\s*([^#{EOL}]*)/ni
     ATTRIBUTE_CHAR = %r{[^ \t\v\n\r)(><@,;:\\"/\[\]?='*%]}
     ATTRIBUTE = /#{ATTRIBUTE_CHAR}+/
     SECTION = /\*[0-9]+/
     REGULAR_PARAMETER_NAME = /#{ATTRIBUTE}#{SECTION}?/
     REGULAR_PARAMETER = /(#{REGULAR_PARAMETER_NAME})=(#{VALUE})/
     EXTENDED_OTHER_NAME = /#{ATTRIBUTE}\*[1-9][0-9]*\*/
     EXTENDED_OTHER_VALUE = /%[0-9a-fA-F]{2}|#{ATTRIBUTE_CHAR}/

--- a//dev/null
+++ b/lib/rack/multipart/generator.rb
@@ -0,0 +1,83 @@
+module Rack
+  module Multipart
+    class Generator
+      def initialize(params, first = true)
+        @params, @first = params, first
+        if @first && !@params.is_a?(Hash)
+          raise ArgumentError, "value must be a Hash"
+        end
+      end
+      def dump
+        return nil if @first && !multipart?
+        return flattened_params unless @first
+        flattened_params.map do |name, file|
+          if file.respond_to?(:original_filename)
+            if file.path
+              ::File.open(file.path, 'rb') do |f|
+                f.set_encoding(Encoding::BINARY)
+                content_for_tempfile(f, file, name)
+              end
+            else
+              content_for_tempfile(file, file, name)
+            end
+          else
+            content_for_other(file, name)
+          end
+        end.join << "--#{MULTIPART_BOUNDARY}--\r"
+      end
+      private
+      def multipart?
+        query = lambda { |value|
+          case value
+          when Array
+            value.any?(&query)
+          when Hash
+            value.values.any?(&query)
+          when Rack::Multipart::UploadedFile
+            true
+          end
+        }
+        @params.values.any?(&query)
+      end
+      def flattened_params
+        @flattened_params ||= begin
+          h = Hash.new
+          @params.each do |key, value|
+            k = @first ? key.to_s : "[#{key}]"
+            case value
+            when Array
+              value.map { |v|
+                Multipart.build_multipart(v, false).each { |subkey, subvalue|
+                  h["#{k}[]#{subkey}"] = subvalue
+                }
+              }
+            when Hash
+              Multipart.build_multipart(value, false).each { |subkey, subvalue|
+                h[k + subkey] = subvalue
+              }
+            else
+              h[k] = value
+            end
+          end
+          h
+        end
+      end
+      def content_for_tempfile(io, file, name)
+        length = ::File.stat(file.path).size if file.path
+        filename = "; filename=\"#{Utils.escape(file.original_filename)}\"" if file.original_filename
+<<-EOF
+--#{MULTIPART_BOUNDARY}\r
+Content-Disposition: form-data; name="#{name}"#{filename}\r
+Content-Type: #{file.content_type}\r
+EOF
+      end
+      def content_for_other(file, name)
+<<-EOF
+--#{MULTIPART_BOUNDARY}\r
+Content-Disposition: form-data; name="#{name}"\r
+\r
+EOF
+      end
+    end
+  end
+end

--- a/lib/rack/multipart/parser.rb
+++ b/lib/rack/multipart/parser.rb
@@ -230,23 +230,22 @@
       def get_filename(head)
         filename = nil
         case head
         when RFC2183
           params = Hash[*head.scan(DISPPARM).flat_map(&:compact)]
           if filename = params['filename']
             filename = $1 if filename =~ /^"(.*)"$/
           elsif filename = params['filename*']
             encoding, _, filename = filename.split("'", 3)
           end
-        when BROKEN
+        when BROKEN_QUOTED, BROKEN_UNQUOTED
           filename = $1
-          filename = $1 if filename =~ /^"(.*)"$/
         end
         return unless filename
         if filename.scan(/%.?.?/).all? { |s| /%[0-9a-fA-F]{2}/.match?(s) }
           filename = Utils.unescape_path(filename)
         end
         filename.scrub!
         if filename !~ /\\[^\\"]/
           filename = filename.gsub(/\\(.)/, '\1')
         end
         if encoding

--- a//dev/null
+++ b/lib/rack/multipart/uploaded_file.rb
@@ -0,0 +1,32 @@
+module Rack
+  module Multipart
+    class UploadedFile
+      attr_reader :original_filename
+      attr_accessor :content_type
+      def initialize(filepath = nil, ct = "text/plain", bin = false,
+                     path: filepath, content_type: ct, binary: bin, filename: nil, io: nil)
+        if io
+          @tempfile = io
+          @original_filename = filename
+        else
+          raise "#{path} file does not exist" unless ::File.exist?(path)
+          @original_filename = filename || ::File.basename(path)
+          @tempfile = Tempfile.new([@original_filename, ::File.extname(path)], encoding: Encoding::BINARY)
+          @tempfile.binmode if binary
+          FileUtils.copy_file(path, @tempfile.path)
+        end
+        @content_type = content_type
+      end
+      def path
+        @tempfile.path if @tempfile.respond_to?(:path)
+      end
+      alias_method :local_path, :path
+      def respond_to?(*args)
+        super or @tempfile.respond_to?(*args)
+      end
+      def method_missing(method_name, *args, &block) #:nodoc:
+        @tempfile.__send__(method_name, *args, &block)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/query_parser.rb
@@ -0,0 +1,142 @@
+module Rack
+  class QueryParser
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    DEFAULT_SEP = /[&;] */n
+    COMMON_SEP = { ";" => /[;] */n, ";," => /[;,] */n, "&" => /[&] */n }
+    class ParameterTypeError < TypeError; end
+    class InvalidParameterError < ArgumentError; end
+    def self.make_default(key_space_limit, param_depth_limit)
+      new Params, key_space_limit, param_depth_limit
+    end
+    attr_reader :key_space_limit, :param_depth_limit
+    def initialize(params_class, key_space_limit, param_depth_limit)
+      @params_class = params_class
+      @key_space_limit = key_space_limit
+      @param_depth_limit = param_depth_limit
+    end
+    def parse_query(qs, d = nil, &unescaper)
+      unescaper ||= method(:unescape)
+      params = make_params
+      (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|
+        next if p.empty?
+        k, v = p.split('=', 2).map!(&unescaper)
+        if cur = params[k]
+          if cur.class == Array
+            params[k] << v
+          else
+            params[k] = [cur, v]
+          end
+        else
+          params[k] = v
+        end
+      end
+      return params.to_h
+    end
+    def parse_nested_query(qs, d = nil)
+      params = make_params
+      unless qs.nil? || qs.empty?
+        (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|
+          k, v = p.split('=', 2).map! { |s| unescape(s) }
+          normalize_params(params, k, v, param_depth_limit)
+        end
+      end
+      return params.to_h
+    rescue ArgumentError => e
+      raise InvalidParameterError, e.message, e.backtrace
+    end
+    def normalize_params(params, name, v, depth)
+      raise RangeError if depth <= 0
+      name =~ %r(\A[\[\]]*([^\[\]]+)\]*)
+      k = $1 || ''
+      after = $' || ''
+      if k.empty?
+        if !v.nil? && name == "[]"
+          return Array(v)
+        else
+          return
+        end
+      end
+      if after == ''
+        params[k] = v
+      elsif after == "["
+        params[name] = v
+      elsif after == "[]"
+        params[k] ||= []
+        raise ParameterTypeError, "expected Array (got #{params[k].class.name}) for param `#{k}'" unless params[k].is_a?(Array)
+        params[k] << v
+      elsif after =~ %r(^\[\]\[([^\[\]]+)\]$) || after =~ %r(^\[\](.+)$)
+        child_key = $1
+        params[k] ||= []
+        raise ParameterTypeError, "expected Array (got #{params[k].class.name}) for param `#{k}'" unless params[k].is_a?(Array)
+        if params_hash_type?(params[k].last) && !params_hash_has_key?(params[k].last, child_key)
+          normalize_params(params[k].last, child_key, v, depth - 1)
+        else
+          params[k] << normalize_params(make_params, child_key, v, depth - 1)
+        end
+      else
+        params[k] ||= make_params
+        raise ParameterTypeError, "expected Hash (got #{params[k].class.name}) for param `#{k}'" unless params_hash_type?(params[k])
+        params[k] = normalize_params(params[k], after, v, depth - 1)
+      end
+      params
+    end
+    def make_params
+      @params_class.new @key_space_limit
+    end
+    def new_space_limit(key_space_limit)
+      self.class.new @params_class, key_space_limit, param_depth_limit
+    end
+    def new_depth_limit(param_depth_limit)
+      self.class.new @params_class, key_space_limit, param_depth_limit
+    end
+    private
+    def params_hash_type?(obj)
+      obj.kind_of?(@params_class)
+    end
+    def params_hash_has_key?(hash, key)
+      return false if /\[\]/.match?(key)
+      key.split(/[\[\]]+/).inject(hash) do |h, part|
+        next h if part == ''
+        return false unless params_hash_type?(h) && h.key?(part)
+        h[part]
+      end
+      true
+    end
+    def unescape(s)
+      Utils.unescape(s)
+    end
+    class Params
+      def initialize(limit)
+        @limit  = limit
+        @size   = 0
+        @params = {}
+      end
+      def [](key)
+        @params[key]
+      end
+      def []=(key, value)
+        @size += key.size if key && !@params.key?(key)
+        raise RangeError, 'exceeded available parameter key space' if @size > @limit
+        @params[key] = value
+      end
+      def key?(key)
+        @params.key?(key)
+      end
+      def to_h
+        @params.each do |key, value|
+          case value
+          when self
+            @params[key] = @params
+          when Params
+            @params[key] = value.to_h
+          when Array
+            value.map! { |v| v.kind_of?(Params) ? v.to_h : v }
+          else
+          end
+        end
+        @params
+      end
+      alias_method :to_params_hash, :to_h
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/recursive.rb
@@ -0,0 +1,42 @@
+require 'uri'
+module Rack
+  class ForwardRequest < Exception
+    attr_reader :url, :env
+    def initialize(url, env = {})
+      @url = URI(url)
+      @env = env
+      @env[PATH_INFO]       = @url.path
+      @env[QUERY_STRING]    = @url.query  if @url.query
+      @env[HTTP_HOST]       = @url.host   if @url.host
+      @env[HTTP_PORT]       = @url.port   if @url.port
+      @env[RACK_URL_SCHEME] = @url.scheme if @url.scheme
+      super "forwarding to #{url}"
+    end
+  end
+  class Recursive
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      dup._call(env)
+    end
+    def _call(env)
+      @script_name = env[SCRIPT_NAME]
+      @app.call(env.merge(RACK_RECURSIVE_INCLUDE => method(:include)))
+    rescue ForwardRequest => req
+      call(env.merge(req.env))
+    end
+    def include(env, path)
+      unless path.index(@script_name) == 0 && (path[@script_name.size] == ?/ ||
+                                               path[@script_name.size].nil?)
+        raise ArgumentError, "can only include below #{@script_name}, not #{path}"
+      end
+      env = env.merge(PATH_INFO => path,
+                      SCRIPT_NAME => @script_name,
+                      REQUEST_METHOD => GET,
+                      "CONTENT_LENGTH" => "0", "CONTENT_TYPE" => "",
+                      RACK_INPUT => StringIO.new(""))
+      @app.call(env)
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/reloader.rb
@@ -0,0 +1,73 @@
+require 'pathname'
+module Rack
+  class Reloader
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    def initialize(app, cooldown = 10, backend = Stat)
+      @app = app
+      @cooldown = cooldown
+      @last = (Time.now - cooldown)
+      @cache = {}
+      @mtimes = {}
+      @reload_mutex = Mutex.new
+      extend backend
+    end
+    def call(env)
+      if @cooldown and Time.now > @last + @cooldown
+        if Thread.list.size > 1
+          @reload_mutex.synchronize{ reload! }
+        else
+          reload!
+        end
+        @last = Time.now
+      end
+      @app.call(env)
+    end
+    def reload!(stderr = $stderr)
+      rotation do |file, mtime|
+        previous_mtime = @mtimes[file] ||= mtime
+        safe_load(file, mtime, stderr) if mtime > previous_mtime
+      end
+    end
+    def safe_load(file, mtime, stderr = $stderr)
+      load(file)
+      stderr.puts "#{self.class}: reloaded `#{file}'"
+      file
+    rescue LoadError, SyntaxError => ex
+      stderr.puts ex
+    ensure
+      @mtimes[file] = mtime
+    end
+    module Stat
+      def rotation
+        files = [$0, *$LOADED_FEATURES].uniq
+        paths = ['./', *$LOAD_PATH].uniq
+        files.map{|file|
+          next if /\.(so|bundle)$/.match?(file) # cannot reload compiled files
+          found, stat = figure_path(file, paths)
+          next unless found && stat && mtime = stat.mtime
+          @cache[file] = found
+          yield(found, mtime)
+        }.compact
+      end
+      def figure_path(file, paths)
+        found = @cache[file]
+        found = file if !found and Pathname.new(file).absolute?
+        found, stat = safe_stat(found)
+        return found, stat if found
+        paths.find do |possible_path|
+          path = ::File.join(possible_path, file)
+          found, stat = safe_stat(path)
+          return ::File.expand_path(found), stat if found
+        end
+        return false, false
+      end
+      def safe_stat(file)
+        return unless file
+        stat = ::File.stat(file)
+        return file, stat if stat.file?
+      rescue Errno::ENOENT, Errno::ENOTDIR, Errno::ESRCH
+        @cache.delete(file) and false
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/request.rb
@@ -0,0 +1,407 @@
+module Rack
+  class Request
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    class << self
+      attr_accessor :ip_filter
+    end
+    self.ip_filter = lambda { |ip| /\A127\.0\.0\.1\Z|\A(10|172\.(1[6-9]|2[0-9]|30|31)|192\.168)\.|\A::1\Z|\Afd[0-9a-f]{2}:.+|\Alocalhost\Z|\Aunix\Z|\Aunix:/i.match?(ip) }
+    ALLOWED_SCHEMES = %w(https http).freeze
+    SCHEME_WHITELIST = ALLOWED_SCHEMES
+    if Object.respond_to?(:deprecate_constant)
+      deprecate_constant :SCHEME_WHITELIST
+    end
+    def initialize(env)
+      @params = nil
+      super(env)
+    end
+    def params
+      @params ||= super
+    end
+    def update_param(k, v)
+      super
+      @params = nil
+    end
+    def delete_param(k)
+      v = super
+      @params = nil
+      v
+    end
+    module Env
+      attr_reader :env
+      def initialize(env)
+        @env = env
+        super()
+      end
+      def has_header?(name)
+        @env.key? name
+      end
+      def get_header(name)
+        @env[name]
+      end
+      def fetch_header(name, &block)
+        @env.fetch(name, &block)
+      end
+      def each_header(&block)
+        @env.each(&block)
+      end
+      def set_header(name, v)
+        @env[name] = v
+      end
+      def add_header(key, v)
+        if v.nil?
+          get_header key
+        elsif has_header? key
+          set_header key, "#{get_header key},#{v}"
+        else
+          set_header key, v
+        end
+      end
+      def delete_header(name)
+        @env.delete name
+      end
+      def initialize_copy(other)
+        @env = other.env.dup
+      end
+    end
+    module Helpers
+      FORM_DATA_MEDIA_TYPES = [
+        'application/x-www-form-urlencoded',
+        'multipart/form-data'
+      ]
+      PARSEABLE_DATA_MEDIA_TYPES = [
+        'multipart/related',
+        'multipart/mixed'
+      ]
+      DEFAULT_PORTS = { 'http' => 80, 'https' => 443, 'coffee' => 80 }
+      HTTP_X_FORWARDED_FOR = 'HTTP_X_FORWARDED_FOR'
+      HTTP_X_FORWARDED_HOST = 'HTTP_X_FORWARDED_HOST'
+      HTTP_X_FORWARDED_SCHEME = 'HTTP_X_FORWARDED_SCHEME'
+      HTTP_X_FORWARDED_PROTO = 'HTTP_X_FORWARDED_PROTO'
+      HTTP_X_FORWARDED_PORT = 'HTTP_X_FORWARDED_PORT'
+      HTTP_X_FORWARDED_SSL = 'HTTP_X_FORWARDED_SSL'
+      def body;            get_header(RACK_INPUT)                         end
+      def script_name;     get_header(SCRIPT_NAME).to_s                   end
+      def script_name=(s); set_header(SCRIPT_NAME, s.to_s)                end
+      def path_info;       get_header(PATH_INFO).to_s                     end
+      def path_info=(s);   set_header(PATH_INFO, s.to_s)                  end
+      def request_method;  get_header(REQUEST_METHOD)                     end
+      def query_string;    get_header(QUERY_STRING).to_s                  end
+      def content_length;  get_header('CONTENT_LENGTH')                   end
+      def logger;          get_header(RACK_LOGGER)                        end
+      def user_agent;      get_header('HTTP_USER_AGENT')                  end
+      def multithread?;    get_header(RACK_MULTITHREAD)                   end
+      def referer;         get_header('HTTP_REFERER')                     end
+      alias referrer referer
+      def session
+        fetch_header(RACK_SESSION) do |k|
+          set_header RACK_SESSION, default_session
+        end
+      end
+      def session_options
+        fetch_header(RACK_SESSION_OPTIONS) do |k|
+          set_header RACK_SESSION_OPTIONS, {}
+        end
+      end
+      def delete?;  request_method == DELETE  end
+      def get?;     request_method == GET     end
+      def head?;    request_method == HEAD    end
+      def options?; request_method == OPTIONS end
+      def link?;    request_method == LINK    end
+      def patch?;   request_method == PATCH   end
+      def post?;    request_method == POST    end
+      def put?;     request_method == PUT     end
+      def trace?;   request_method == TRACE   end
+      def unlink?;  request_method == UNLINK  end
+      def scheme
+        if get_header(HTTPS) == 'on'
+          'https'
+        elsif get_header(HTTP_X_FORWARDED_SSL) == 'on'
+          'https'
+        elsif forwarded_scheme
+          forwarded_scheme
+        else
+          get_header(RACK_URL_SCHEME)
+        end
+      end
+      def authority
+        forwarded_authority || host_authority || server_authority
+      end
+      def server_authority
+        host = self.server_name
+        port = self.server_port
+        if host
+          if port
+            "#{host}:#{port}"
+          else
+            host
+          end
+        end
+      end
+      def server_name
+        get_header(SERVER_NAME)
+      end
+      def server_port
+        if port = get_header(SERVER_PORT)
+          Integer(port)
+        end
+      end
+      def cookies
+        hash = fetch_header(RACK_REQUEST_COOKIE_HASH) do |key|
+          set_header(key, {})
+        end
+        string = get_header(HTTP_COOKIE)
+        unless string == get_header(RACK_REQUEST_COOKIE_STRING)
+          hash.replace Utils.parse_cookies_header(string)
+          set_header(RACK_REQUEST_COOKIE_STRING, string)
+        end
+        hash
+      end
+      def content_type
+        content_type = get_header('CONTENT_TYPE')
+        content_type.nil? || content_type.empty? ? nil : content_type
+      end
+      def xhr?
+        get_header("HTTP_X_REQUESTED_WITH") == "XMLHttpRequest"
+      end
+      def host_authority
+        get_header(HTTP_HOST)
+      end
+      def host_with_port(authority = self.authority)
+        host, _, port = split_authority(authority)
+        if port == DEFAULT_PORTS[self.scheme]
+          host
+        else
+          authority
+        end
+      end
+      def host
+        split_authority(self.authority)[0]
+      end
+      def hostname
+        split_authority(self.authority)[1]
+      end
+      def port
+        if authority = self.authority
+          _, _, port = split_authority(self.authority)
+          if port
+            return port
+          end
+        end
+        if forwarded_port = self.forwarded_port
+          return forwarded_port.first
+        end
+        if scheme = self.scheme
+          if port = DEFAULT_PORTS[self.scheme]
+            return port
+          end
+        end
+        self.server_port
+      end
+      def forwarded_for
+        if value = get_header(HTTP_X_FORWARDED_FOR)
+          split_header(value).map do |authority|
+            split_authority(wrap_ipv6(authority))[1]
+          end
+        end
+      end
+      def forwarded_port
+        if value = get_header(HTTP_X_FORWARDED_PORT)
+          split_header(value).map(&:to_i)
+        end
+      end
+      def forwarded_authority
+        if value = get_header(HTTP_X_FORWARDED_HOST)
+          wrap_ipv6(split_header(value).first)
+        end
+      end
+      def ssl?
+        scheme == 'https' || scheme == 'wss'
+      end
+      def ip
+        remote_addrs = split_header(get_header('REMOTE_ADDR'))
+        remote_addrs = reject_trusted_ip_addresses(remote_addrs)
+        if remote_addrs.any?
+          remote_addrs.first
+        else
+          forwarded_ips = self.forwarded_for
+          reject_trusted_ip_addresses(forwarded_ips).last || forwarded_ips.first || get_header("REMOTE_ADDR")
+        end
+      end
+      def media_type
+        MediaType.type(content_type)
+      end
+      def media_type_params
+        MediaType.params(content_type)
+      end
+      def content_charset
+        media_type_params['charset']
+      end
+      def form_data?
+        type = media_type
+        meth = get_header(RACK_METHODOVERRIDE_ORIGINAL_METHOD) || get_header(REQUEST_METHOD)
+        (meth == POST && type.nil?) || FORM_DATA_MEDIA_TYPES.include?(type)
+      end
+      def parseable_data?
+        PARSEABLE_DATA_MEDIA_TYPES.include?(media_type)
+      end
+      def GET
+        if get_header(RACK_REQUEST_QUERY_STRING) == query_string
+          get_header(RACK_REQUEST_QUERY_HASH)
+        else
+          query_hash = parse_query(query_string, '&;')
+          set_header(RACK_REQUEST_QUERY_STRING, query_string)
+          set_header(RACK_REQUEST_QUERY_HASH, query_hash)
+        end
+      end
+      def POST
+        if get_header(RACK_INPUT).nil?
+          raise "Missing rack.input"
+        elsif get_header(RACK_REQUEST_FORM_INPUT) == get_header(RACK_INPUT)
+          get_header(RACK_REQUEST_FORM_HASH)
+        elsif form_data? || parseable_data?
+          unless set_header(RACK_REQUEST_FORM_HASH, parse_multipart)
+            form_vars = get_header(RACK_INPUT).read
+            form_vars.slice!(-1) if form_vars.end_with?("\0")
+            set_header RACK_REQUEST_FORM_VARS, form_vars
+            set_header RACK_REQUEST_FORM_HASH, parse_query(form_vars, '&')
+            get_header(RACK_INPUT).rewind
+          end
+          set_header RACK_REQUEST_FORM_INPUT, get_header(RACK_INPUT)
+          get_header RACK_REQUEST_FORM_HASH
+        else
+          {}
+        end
+      end
+      def params
+        self.GET.merge(self.POST)
+      end
+      def update_param(k, v)
+        found = false
+        if self.GET.has_key?(k)
+          found = true
+          self.GET[k] = v
+        end
+        if self.POST.has_key?(k)
+          found = true
+          self.POST[k] = v
+        end
+        unless found
+          self.GET[k] = v
+        end
+      end
+      def delete_param(k)
+        post_value, get_value = self.POST.delete(k), self.GET.delete(k)
+        post_value || get_value
+      end
+      def base_url
+        "#{scheme}://#{host_with_port}"
+      end
+      def url
+        base_url + fullpath
+      end
+      def path
+        script_name + path_info
+      end
+      def fullpath
+        query_string.empty? ? path : "#{path}?#{query_string}"
+      end
+      def accept_encoding
+        parse_http_accept_header(get_header("HTTP_ACCEPT_ENCODING"))
+      end
+      def accept_language
+        parse_http_accept_header(get_header("HTTP_ACCEPT_LANGUAGE"))
+      end
+      def trusted_proxy?(ip)
+        Rack::Request.ip_filter.call(ip)
+      end
+      def [](key)
+        if $VERBOSE
+          warn("Request#[] is deprecated and will be removed in a future version of Rack. Please use request.params[] instead")
+        end
+        params[key.to_s]
+      end
+      def []=(key, value)
+        if $VERBOSE
+          warn("Request#[]= is deprecated and will be removed in a future version of Rack. Please use request.params[]= instead")
+        end
+        params[key.to_s] = value
+      end
+      def values_at(*keys)
+        keys.map { |key| params[key] }
+      end
+      private
+      def default_session; {}; end
+      def wrap_ipv6(host)
+        if !host.start_with?('[') && host.count(':') > 1
+          "[#{host}]"
+        else
+          host
+        end
+      end
+      def parse_http_accept_header(header)
+        header.to_s.split(/\s*,\s*/).map do |part|
+          attribute, parameters = part.split(/\s*;\s*/, 2)
+          quality = 1.0
+          if parameters and /\Aq=([\d.]+)/ =~ parameters
+            quality = $1.to_f
+          end
+          [attribute, quality]
+        end
+      end
+      def query_parser
+        Utils.default_query_parser
+      end
+      def parse_query(qs, d = '&')
+        query_parser.parse_nested_query(qs, d)
+      end
+      def parse_multipart
+        Rack::Multipart.extract_multipart(self, query_parser)
+      end
+      def split_header(value)
+        value ? value.strip.split(/[,\s]+/) : []
+      end
+      AUTHORITY = /
+        (?<host>
+          (\[(?<ip6>.*)\])
+          |
+          (?<ip4>[\d\.]+)
+          |
+          (?<name>[a-zA-Z0-9\.\-]+)
+        )
+        (:(?<port>\d+))?
+      /x
+      private_constant :AUTHORITY
+      def split_authority(authority)
+        if match = AUTHORITY.match(authority)
+          if address = match[:ip6]
+            return match[:host], address, match[:port]&.to_i
+          else
+            return match[:host], match[:host], match[:port]&.to_i
+          end
+        end
+        return authority, authority, nil
+      end
+      def reject_trusted_ip_addresses(ip_addresses)
+        ip_addresses.reject { |ip| trusted_proxy?(ip) }
+      end
+      def forwarded_scheme
+        allowed_scheme(get_header(HTTP_X_FORWARDED_SCHEME)) ||
+        allowed_scheme(extract_proto_header(get_header(HTTP_X_FORWARDED_PROTO)))
+      end
+      def allowed_scheme(header)
+        header if ALLOWED_SCHEMES.include?(header)
+      end
+      def extract_proto_header(header)
+        if header
+          if (comma_index = header.index(','))
+            header[0, comma_index]
+          else
+            header
+          end
+        end
+      end
+    end
+    include Env
+    include Helpers
+  end
+end

--- a//dev/null
+++ b/lib/rack/response.rb
@@ -0,0 +1,210 @@
+require 'time'
+module Rack
+  class Response
+    def self.[](status, headers, body)
+      self.new(body, status, headers)
+    end
+    CHUNKED = 'chunked'
+    STATUS_WITH_NO_ENTITY_BODY = Utils::STATUS_WITH_NO_ENTITY_BODY
+    attr_accessor :length, :status, :body
+    attr_reader :headers
+    alias header headers
+    def initialize(body = nil, status = 200, headers = {})
+      @status = status.to_i
+      @headers = Utils::HeaderHash[headers]
+      @writer = self.method(:append)
+      @block = nil
+      if body.nil?
+        @body = []
+        @buffered = true
+        @length = 0
+      elsif body.respond_to?(:to_str)
+        @body = [body]
+        @buffered = true
+        @length = body.to_str.bytesize
+      else
+        @body = body
+        @buffered = false
+        @length = 0
+      end
+      yield self if block_given?
+    end
+    def redirect(target, status = 302)
+      self.status = status
+      self.location = target
+    end
+    def chunked?
+      CHUNKED == get_header(TRANSFER_ENCODING)
+    end
+    def finish(&block)
+      if STATUS_WITH_NO_ENTITY_BODY[status.to_i]
+        delete_header CONTENT_TYPE
+        delete_header CONTENT_LENGTH
+        close
+        return [@status, @headers, []]
+      else
+        if block_given?
+          @block = block
+          return [@status, @headers, self]
+        else
+          return [@status, @headers, @body]
+        end
+      end
+    end
+    alias to_a finish           # For *response
+    def each(&callback)
+      @body.each(&callback)
+      @buffered = true
+      if @block
+        @writer = callback
+        @block.call(self)
+      end
+    end
+    def write(chunk)
+      buffered_body!
+      @writer.call(chunk.to_s)
+    end
+    def close
+      @body.close if @body.respond_to?(:close)
+    end
+    def empty?
+      @block == nil && @body.empty?
+    end
+    def has_header?(key);   headers.key? key;   end
+    def get_header(key);    headers[key];       end
+    def set_header(key, v); headers[key] = v;   end
+    def delete_header(key); headers.delete key; end
+    alias :[] :get_header
+    alias :[]= :set_header
+    module Helpers
+      def invalid?;             status < 100 || status >= 600;        end
+      def informational?;       status >= 100 && status < 200;        end
+      def successful?;          status >= 200 && status < 300;        end
+      def redirection?;         status >= 300 && status < 400;        end
+      def client_error?;        status >= 400 && status < 500;        end
+      def server_error?;        status >= 500 && status < 600;        end
+      def ok?;                  status == 200;                        end
+      def created?;             status == 201;                        end
+      def accepted?;            status == 202;                        end
+      def no_content?;          status == 204;                        end
+      def moved_permanently?;   status == 301;                        end
+      def bad_request?;         status == 400;                        end
+      def unauthorized?;        status == 401;                        end
+      def forbidden?;           status == 403;                        end
+      def not_found?;           status == 404;                        end
+      def method_not_allowed?;  status == 405;                        end
+      def precondition_failed?; status == 412;                        end
+      def unprocessable?;       status == 422;                        end
+      def redirect?;            [301, 302, 303, 307, 308].include? status; end
+      def include?(header)
+        has_header? header
+      end
+      def add_header(key, v)
+        if v.nil?
+          get_header key
+        elsif has_header? key
+          set_header key, "#{get_header key},#{v}"
+        else
+          set_header key, v
+        end
+      end
+      def content_type
+        get_header CONTENT_TYPE
+      end
+      def content_type=(content_type)
+        set_header CONTENT_TYPE, content_type
+      end
+      def media_type
+        MediaType.type(content_type)
+      end
+      def media_type_params
+        MediaType.params(content_type)
+      end
+      def content_length
+        cl = get_header CONTENT_LENGTH
+        cl ? cl.to_i : cl
+      end
+      def location
+        get_header "Location"
+      end
+      def location=(location)
+        set_header "Location", location
+      end
+      def set_cookie(key, value)
+        cookie_header = get_header SET_COOKIE
+        set_header SET_COOKIE, ::Rack::Utils.add_cookie_to_header(cookie_header, key, value)
+      end
+      def delete_cookie(key, value = {})
+        set_header SET_COOKIE, ::Rack::Utils.add_remove_cookie_to_header(get_header(SET_COOKIE), key, value)
+      end
+      def set_cookie_header
+        get_header SET_COOKIE
+      end
+      def set_cookie_header=(v)
+        set_header SET_COOKIE, v
+      end
+      def cache_control
+        get_header CACHE_CONTROL
+      end
+      def cache_control=(v)
+        set_header CACHE_CONTROL, v
+      end
+      def do_not_cache!
+        set_header CACHE_CONTROL, "no-cache, must-revalidate"
+        set_header EXPIRES, Time.now.httpdate
+      end
+      def cache!(duration = 3600, directive: "public")
+        unless headers[CACHE_CONTROL] =~ /no-cache/
+          set_header CACHE_CONTROL, "#{directive}, max-age=#{duration}"
+          set_header EXPIRES, (Time.now + duration).httpdate
+        end
+      end
+      def etag
+        get_header ETAG
+      end
+      def etag=(v)
+        set_header ETAG, v
+      end
+    protected
+      def buffered_body!
+        return if @buffered
+        if @body.is_a?(Array)
+          @body = @body.compact
+          @body.each do |part|
+            @length += part.to_s.bytesize
+          end
+        else
+          body = @body
+          @body = Array.new
+          body.each do |part|
+            @writer.call(part.to_s)
+          end
+          body.close if body.respond_to?(:close)
+        end
+        @buffered = true
+      end
+      def append(chunk)
+        @body << chunk
+        unless chunked?
+          @length += chunk.bytesize
+          set_header(CONTENT_LENGTH, @length.to_s)
+        end
+        return chunk
+      end
+    end
+    include Helpers
+    class Raw
+      include Helpers
+      attr_reader :headers
+      attr_accessor :status
+      def initialize(status, headers)
+        @status = status
+        @headers = headers
+      end
+      def has_header?(key);   headers.key? key;   end
+      def get_header(key);    headers[key];       end
+      def set_header(key, v); headers[key] = v;   end
+      def delete_header(key); headers.delete key; end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/rewindable_input.rb
@@ -0,0 +1,62 @@
+require 'tempfile'
+module Rack
+  class RewindableInput
+    def initialize(io)
+      @io = io
+      @rewindable_io = nil
+      @unlinked = false
+    end
+    def gets
+      make_rewindable unless @rewindable_io
+      @rewindable_io.gets
+    end
+    def read(*args)
+      make_rewindable unless @rewindable_io
+      @rewindable_io.read(*args)
+    end
+    def each(&block)
+      make_rewindable unless @rewindable_io
+      @rewindable_io.each(&block)
+    end
+    def rewind
+      make_rewindable unless @rewindable_io
+      @rewindable_io.rewind
+    end
+    def close
+      if @rewindable_io
+        if @unlinked
+          @rewindable_io.close
+        else
+          @rewindable_io.close!
+        end
+        @rewindable_io = nil
+      end
+    end
+    private
+    def make_rewindable
+      @rewindable_io = Tempfile.new('RackRewindableInput')
+      @rewindable_io.chmod(0000)
+      @rewindable_io.set_encoding(Encoding::BINARY) if @rewindable_io.respond_to?(:set_encoding)
+      @rewindable_io.binmode
+      if filesystem_has_posix_semantics?
+        raise 'Unlink failed. IO closed.' if @rewindable_io.closed?
+        @unlinked = true
+      end
+      buffer = "".dup
+      while @io.read(1024 * 4, buffer)
+        entire_buffer_written_out = false
+        while !entire_buffer_written_out
+          written = @rewindable_io.write(buffer)
+          entire_buffer_written_out = written == buffer.bytesize
+          if !entire_buffer_written_out
+            buffer.slice!(0 .. written - 1)
+          end
+        end
+      end
+      @rewindable_io.rewind
+    end
+    def filesystem_has_posix_semantics?
+      RUBY_PLATFORM !~ /(mswin|mingw|cygwin|java)/
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/runtime.rb
@@ -0,0 +1,21 @@
+module Rack
+  class Runtime
+    FORMAT_STRING = "%0.6f" # :nodoc:
+    HEADER_NAME = "X-Runtime" # :nodoc:
+    def initialize(app, name = nil)
+      @app = app
+      @header_name = HEADER_NAME
+      @header_name += "-#{name}" if name
+    end
+    def call(env)
+      start_time = Utils.clock_time
+      status, headers, body = @app.call(env)
+      headers = Utils::HeaderHash[headers]
+      request_time = Utils.clock_time - start_time
+      unless headers.key?(@header_name)
+        headers[@header_name] = FORMAT_STRING % request_time
+      end
+      [status, headers, body]
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/sendfile.rb
@@ -0,0 +1,60 @@
+module Rack
+  class Sendfile
+    def initialize(app, variation = nil, mappings = [])
+      @app = app
+      @variation = variation
+      @mappings = mappings.map do |internal, external|
+        [/^#{internal}/i, external]
+      end
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      if body.respond_to?(:to_path)
+        case type = variation(env)
+        when 'X-Accel-Redirect'
+          path = ::File.expand_path(body.to_path)
+          if url = map_accel_path(env, path)
+            headers[CONTENT_LENGTH] = '0'
+            headers[type] = ::Rack::Utils.escape_path(url).gsub('?', '%3F')
+            obody = body
+            body = Rack::BodyProxy.new([]) do
+              obody.close if obody.respond_to?(:close)
+            end
+          else
+            env[RACK_ERRORS].puts "X-Accel-Mapping header missing"
+          end
+        when 'X-Sendfile', 'X-Lighttpd-Send-File'
+          path = ::File.expand_path(body.to_path)
+          headers[CONTENT_LENGTH] = '0'
+          headers[type] = path
+          obody = body
+          body = Rack::BodyProxy.new([]) do
+            obody.close if obody.respond_to?(:close)
+          end
+        when '', nil
+        else
+          env[RACK_ERRORS].puts "Unknown x-sendfile variation: '#{type}'.\n"
+        end
+      end
+      [status, headers, body]
+    end
+    private
+    def variation(env)
+      @variation ||
+        env['sendfile.type'] ||
+        env['HTTP_X_SENDFILE_TYPE']
+    end
+    def map_accel_path(env, path)
+      if mapping = @mappings.find { |internal, _| internal =~ path }
+        path.sub(*mapping)
+      elsif mapping = env['HTTP_X_ACCEL_MAPPING']
+        mapping.split(',').map(&:strip).each do |m|
+          internal, external = m.split('=', 2).map(&:strip)
+          new_path = path.sub(/^#{internal}/i, external)
+          return new_path unless path == new_path
+        end
+        path
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/server.rb
@@ -0,0 +1,321 @@
+require 'optparse'
+require 'fileutils'
+module Rack
+  class Server
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    class Options
+      def parse!(args)
+        options = {}
+        opt_parser = OptionParser.new("", 24, '  ') do |opts|
+          opts.banner = "Usage: rackup [ruby options] [rack options] [rackup config]"
+          opts.separator ""
+          opts.separator "Ruby options:"
+          lineno = 1
+          opts.on("-e", "--eval LINE", "evaluate a LINE of code") { |line|
+            eval line, TOPLEVEL_BINDING, "-e", lineno
+            lineno += 1
+          }
+          opts.on("-d", "--debug", "set debugging flags (set $DEBUG to true)") {
+            options[:debug] = true
+          }
+          opts.on("-w", "--warn", "turn warnings on for your script") {
+            options[:warn] = true
+          }
+          opts.on("-q", "--quiet", "turn off logging") {
+            options[:quiet] = true
+          }
+          opts.on("-I", "--include PATH",
+                  "specify $LOAD_PATH (may be used more than once)") { |path|
+            (options[:include] ||= []).concat(path.split(":"))
+          }
+          opts.on("-r", "--require LIBRARY",
+                  "require the library, before executing your script") { |library|
+            (options[:require] ||= []) << library
+          }
+          opts.separator ""
+          opts.separator "Rack options:"
+          opts.on("-b", "--builder BUILDER_LINE", "evaluate a BUILDER_LINE of code as a builder script") { |line|
+            options[:builder] = line
+          }
+          opts.on("-s", "--server SERVER", "serve using SERVER (thin/puma/webrick)") { |s|
+            options[:server] = s
+          }
+          opts.on("-o", "--host HOST", "listen on HOST (default: localhost)") { |host|
+            options[:Host] = host
+          }
+          opts.on("-p", "--port PORT", "use PORT (default: 9292)") { |port|
+            options[:Port] = port
+          }
+          opts.on("-O", "--option NAME[=VALUE]", "pass VALUE to the server as option NAME. If no VALUE, sets it to true. Run '#{$0} -s SERVER -h' to get a list of options for SERVER") { |name|
+            name, value = name.split('=', 2)
+            value = true if value.nil?
+            options[name.to_sym] = value
+          }
+          opts.on("-E", "--env ENVIRONMENT", "use ENVIRONMENT for defaults (default: development)") { |e|
+            options[:environment] = e
+          }
+          opts.on("-D", "--daemonize", "run daemonized in the background") { |d|
+            options[:daemonize] = d ? true : false
+          }
+          opts.on("-P", "--pid FILE", "file to store PID") { |f|
+            options[:pid] = ::File.expand_path(f)
+          }
+          opts.separator ""
+          opts.separator "Profiling options:"
+          opts.on("--heap HEAPFILE", "Build the application, then dump the heap to HEAPFILE") do |e|
+            options[:heapfile] = e
+          end
+          opts.on("--profile PROFILE", "Dump CPU or Memory profile to PROFILE (defaults to a tempfile)") do |e|
+            options[:profile_file] = e
+          end
+          opts.on("--profile-mode MODE", "Profile mode (cpu|wall|object)") do |e|
+            { cpu: true, wall: true, object: true }.fetch(e.to_sym) do
+              raise OptionParser::InvalidOption, "unknown profile mode: #{e}"
+            end
+            options[:profile_mode] = e.to_sym
+          end
+          opts.separator ""
+          opts.separator "Common options:"
+          opts.on_tail("-h", "-?", "--help", "Show this message") do
+            puts opts
+            puts handler_opts(options)
+            exit
+          end
+          opts.on_tail("--version", "Show version") do
+            puts "Rack #{Rack.version} (Release: #{Rack.release})"
+            exit
+          end
+        end
+        begin
+          opt_parser.parse! args
+        rescue OptionParser::InvalidOption => e
+          warn e.message
+          abort opt_parser.to_s
+        end
+        options[:config] = args.last if args.last && !args.last.empty?
+        options
+      end
+      def handler_opts(options)
+        begin
+          info = []
+          server = Rack::Handler.get(options[:server]) || Rack::Handler.default
+          if server && server.respond_to?(:valid_options)
+            info << ""
+            info << "Server-specific options for #{server.name}:"
+            has_options = false
+            server.valid_options.each do |name, description|
+              next if /^(Host|Port)[^a-zA-Z]/.match?(name.to_s) # ignore handler's host and port options, we do our own.
+              info << "  -O %-21s %s" % [name, description]
+              has_options = true
+            end
+            return "" if !has_options
+          end
+          info.join("\n")
+        rescue NameError, LoadError
+          return "Warning: Could not find handler specified (#{options[:server] || 'default'}) to determine handler-specific options"
+        end
+      end
+    end
+    def self.start(options = nil)
+      new(options).start
+    end
+    attr_writer :options
+    def initialize(options = nil)
+      @ignore_options = []
+      if options
+        @use_default_options = false
+        @options = options
+        @app = options[:app] if options[:app]
+      else
+        argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV
+        @use_default_options = true
+        @options = parse_options(argv)
+      end
+    end
+    def options
+      merged_options = @use_default_options ? default_options.merge(@options) : @options
+      merged_options.reject { |k, v| @ignore_options.include?(k) }
+    end
+    def default_options
+      environment  = ENV['RACK_ENV'] || 'development'
+      default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
+      {
+        environment: environment,
+        pid: nil,
+        Port: 9292,
+        Host: default_host,
+        AccessLog: [],
+        config: "config.ru"
+      }
+    end
+    def app
+      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
+    end
+    class << self
+      def logging_middleware
+        lambda { |server|
+          /CGI/.match?(server.server.name) || server.options[:quiet] ? nil : [Rack::CommonLogger, $stderr]
+        }
+      end
+      def default_middleware_by_environment
+        m = Hash.new {|h, k| h[k] = []}
+        m["deployment"] = [
+          [Rack::ContentLength],
+          logging_middleware,
+          [Rack::TempfileReaper]
+        ]
+        m["development"] = [
+          [Rack::ContentLength],
+          logging_middleware,
+          [Rack::ShowExceptions],
+          [Rack::Lint],
+          [Rack::TempfileReaper]
+        ]
+        m
+      end
+      def middleware
+        default_middleware_by_environment
+      end
+    end
+    def middleware
+      self.class.middleware
+    end
+    def start(&block)
+      if options[:warn]
+        $-w = true
+      end
+      if includes = options[:include]
+        $LOAD_PATH.unshift(*includes)
+      end
+      Array(options[:require]).each do |library|
+        require library
+      end
+      if options[:debug]
+        $DEBUG = true
+        require 'pp'
+        p options[:server]
+        pp wrapped_app
+        pp app
+      end
+      check_pid! if options[:pid]
+      handle_profiling(options[:heapfile], options[:profile_mode], options[:profile_file]) do
+        wrapped_app
+      end
+      daemonize_app if options[:daemonize]
+      write_pid if options[:pid]
+      trap(:INT) do
+        if server.respond_to?(:shutdown)
+          server.shutdown
+        else
+          exit
+        end
+      end
+      server.run(wrapped_app, **options, &block)
+    end
+    def server
+      @_server ||= Rack::Handler.get(options[:server])
+      unless @_server
+        @_server = Rack::Handler.default
+        @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'
+      end
+      @_server
+    end
+    private
+      def build_app_and_options_from_config
+        if !::File.exist? options[:config]
+          abort "configuration #{options[:config]} not found"
+        end
+        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
+        @options.merge!(options) { |key, old, new| old }
+        app
+      end
+      def handle_profiling(heapfile, profile_mode, filename)
+        if heapfile
+          require "objspace"
+          ObjectSpace.trace_object_allocations_start
+          yield
+          GC.start
+          ::File.open(heapfile, "w") { |f| ObjectSpace.dump_all(output: f) }
+          exit
+        end
+        if profile_mode
+          require "stackprof"
+          require "tempfile"
+          make_profile_name(filename) do |filename|
+            ::File.open(filename, "w") do |f|
+              StackProf.run(mode: profile_mode, out: f) do
+                yield
+              end
+              puts "Profile written to: #{filename}"
+            end
+          end
+          exit
+        end
+        yield
+      end
+      def make_profile_name(filename)
+        if filename
+          yield filename
+        else
+          ::Dir::Tmpname.create("profile.dump") do |tmpname, _, _|
+            yield tmpname
+          end
+        end
+      end
+      def build_app_from_string
+        Rack::Builder.new_from_string(self.options[:builder])
+      end
+      def parse_options(args)
+        args.clear if ENV.include?(REQUEST_METHOD)
+        @options = opt_parser.parse!(args)
+        @options[:config] = ::File.expand_path(options[:config])
+        ENV["RACK_ENV"] = options[:environment]
+        @options
+      end
+      def opt_parser
+        Options.new
+      end
+      def build_app(app)
+        middleware[options[:environment]].reverse_each do |middleware|
+          middleware = middleware.call(self) if middleware.respond_to?(:call)
+          next unless middleware
+          klass, *args = middleware
+          app = klass.new(app, *args)
+        end
+        app
+      end
+      def wrapped_app
+        @wrapped_app ||= build_app app
+      end
+      def daemonize_app
+        Process.daemon
+      end
+      def write_pid
+        ::File.open(options[:pid], ::File::CREAT | ::File::EXCL | ::File::WRONLY ){ |f| f.write("#{Process.pid}") }
+        at_exit { ::FileUtils.rm_f(options[:pid]) }
+      rescue Errno::EEXIST
+        check_pid!
+        retry
+      end
+      def check_pid!
+        case pidfile_process_status
+        when :running, :not_owned
+          $stderr.puts "A server is already running. Check #{options[:pid]}."
+          exit(1)
+        when :dead
+          ::File.delete(options[:pid])
+        end
+      end
+      def pidfile_process_status
+        return :exited unless ::File.exist?(options[:pid])
+        pid = ::File.read(options[:pid]).to_i
+        return :dead if pid == 0
+        Process.kill(0, pid)
+        :running
+      rescue Errno::ESRCH
+        :dead
+      rescue Errno::EPERM
+        :not_owned
+      end
+  end
+end

--- a//dev/null
+++ b/lib/rack/session/abstract/id.rb
@@ -0,0 +1,349 @@
+require_relative '../../../rack'
+require 'time'
+require 'securerandom'
+require 'digest/sha2'
+module Rack
+  module Session
+    class SessionId
+      ID_VERSION = 2
+      attr_reader :public_id
+      def initialize(public_id)
+        @public_id = public_id
+      end
+      def private_id
+        "#{ID_VERSION}::#{hash_sid(public_id)}"
+      end
+      alias :cookie_value :public_id
+      alias :to_s :public_id
+      def empty?; false; end
+      def inspect; public_id.inspect; end
+      private
+      def hash_sid(sid)
+        Digest::SHA256.hexdigest(sid)
+      end
+    end
+    module Abstract
+      class SessionHash
+        include Enumerable
+        attr_writer :id
+        Unspecified = Object.new
+        def self.find(req)
+          req.get_header RACK_SESSION
+        end
+        def self.set(req, session)
+          req.set_header RACK_SESSION, session
+        end
+        def self.set_options(req, options)
+          req.set_header RACK_SESSION_OPTIONS, options.dup
+        end
+        def initialize(store, req)
+          @store = store
+          @req = req
+          @loaded = false
+        end
+        def id
+          return @id if @loaded or instance_variable_defined?(:@id)
+          @id = @store.send(:extract_session_id, @req)
+        end
+        def options
+          @req.session_options
+        end
+        def each(&block)
+          load_for_read!
+          @data.each(&block)
+        end
+        def [](key)
+          load_for_read!
+          @data[key.to_s]
+        end
+        def dig(key, *keys)
+          load_for_read!
+          @data.dig(key.to_s, *keys)
+        end
+        def fetch(key, default = Unspecified, &block)
+          load_for_read!
+          if default == Unspecified
+            @data.fetch(key.to_s, &block)
+          else
+            @data.fetch(key.to_s, default, &block)
+          end
+        end
+        def has_key?(key)
+          load_for_read!
+          @data.has_key?(key.to_s)
+        end
+        alias :key? :has_key?
+        alias :include? :has_key?
+        def []=(key, value)
+          load_for_write!
+          @data[key.to_s] = value
+        end
+        alias :store :[]=
+        def clear
+          load_for_write!
+          @data.clear
+        end
+        def destroy
+          clear
+          @id = @store.send(:delete_session, @req, id, options)
+        end
+        def to_hash
+          load_for_read!
+          @data.dup
+        end
+        def update(hash)
+          load_for_write!
+          @data.update(stringify_keys(hash))
+        end
+        alias :merge! :update
+        def replace(hash)
+          load_for_write!
+          @data.replace(stringify_keys(hash))
+        end
+        def delete(key)
+          load_for_write!
+          @data.delete(key.to_s)
+        end
+        def inspect
+          if loaded?
+            @data.inspect
+          else
+            "#<#{self.class}:0x#{self.object_id.to_s(16)} not yet loaded>"
+          end
+        end
+        def exists?
+          return @exists if instance_variable_defined?(:@exists)
+          @data = {}
+          @exists = @store.send(:session_exists?, @req)
+        end
+        def loaded?
+          @loaded
+        end
+        def empty?
+          load_for_read!
+          @data.empty?
+        end
+        def keys
+          load_for_read!
+          @data.keys
+        end
+        def values
+          load_for_read!
+          @data.values
+        end
+      private
+        def load_for_read!
+          load! if !loaded? && exists?
+        end
+        def load_for_write!
+          load! unless loaded?
+        end
+        def load!
+          @id, session = @store.send(:load_session, @req)
+          @data = stringify_keys(session)
+          @loaded = true
+        end
+        def stringify_keys(other)
+          hash = {}
+          other.to_hash.each do |key, value|
+            hash[key.to_s] = value
+          end
+          hash
+        end
+      end
+      class Persisted
+        DEFAULT_OPTIONS = {
+          key: RACK_SESSION,
+          path: '/',
+          domain: nil,
+          expire_after: nil,
+          secure: false,
+          httponly: true,
+          defer: false,
+          renew: false,
+          sidbits: 128,
+          cookie_only: true,
+          secure_random: ::SecureRandom
+        }.freeze
+        attr_reader :key, :default_options, :sid_secure
+        def initialize(app, options = {})
+          @app = app
+          @default_options = self.class::DEFAULT_OPTIONS.merge(options)
+          @key = @default_options.delete(:key)
+          @cookie_only = @default_options.delete(:cookie_only)
+          initialize_sid
+        end
+        def call(env)
+          context(env)
+        end
+        def context(env, app = @app)
+          req = make_request env
+          prepare_session(req)
+          status, headers, body = app.call(req.env)
+          res = Rack::Response::Raw.new status, headers
+          commit_session(req, res)
+          [status, headers, body]
+        end
+        private
+        def make_request(env)
+          Rack::Request.new env
+        end
+        def initialize_sid
+          @sidbits = @default_options[:sidbits]
+          @sid_secure = @default_options[:secure_random]
+          @sid_length = @sidbits / 4
+        end
+        def generate_sid(secure = @sid_secure)
+          if secure
+            secure.hex(@sid_length)
+          else
+            "%0#{@sid_length}x" % Kernel.rand(2**@sidbits - 1)
+          end
+        rescue NotImplementedError
+          generate_sid(false)
+        end
+        def prepare_session(req)
+          session_was               = req.get_header RACK_SESSION
+          session                   = session_class.new(self, req)
+          req.set_header RACK_SESSION, session
+          req.set_header RACK_SESSION_OPTIONS, @default_options.dup
+          session.merge! session_was if session_was
+        end
+        def load_session(req)
+          sid = current_session_id(req)
+          sid, session = find_session(req, sid)
+          [sid, session || {}]
+        end
+        def extract_session_id(request)
+          sid = request.cookies[@key]
+          sid ||= request.params[@key] unless @cookie_only
+          sid
+        end
+        def current_session_id(req)
+          req.get_header(RACK_SESSION).id
+        end
+        def session_exists?(req)
+          value = current_session_id(req)
+          value && !value.empty?
+        end
+        def commit_session?(req, session, options)
+          if options[:skip]
+            false
+          else
+            has_session = loaded_session?(session) || forced_session_update?(session, options)
+            has_session && security_matches?(req, options)
+          end
+        end
+        def loaded_session?(session)
+          !session.is_a?(session_class) || session.loaded?
+        end
+        def forced_session_update?(session, options)
+          force_options?(options) && session && !session.empty?
+        end
+        def force_options?(options)
+          options.values_at(:max_age, :renew, :drop, :defer, :expire_after).any?
+        end
+        def security_matches?(request, options)
+          return true unless options[:secure]
+          request.ssl?
+        end
+        def commit_session(req, res)
+          session = req.get_header RACK_SESSION
+          options = session.options
+          if options[:drop] || options[:renew]
+            session_id = delete_session(req, session.id || generate_sid, options)
+            return unless session_id
+          end
+          return unless commit_session?(req, session, options)
+          session.send(:load!) unless loaded_session?(session)
+          session_id ||= session.id
+          session_data = session.to_hash.delete_if { |k, v| v.nil? }
+          if not data = write_session(req, session_id, session_data, options)
+            req.get_header(RACK_ERRORS).puts("Warning! #{self.class.name} failed to save session. Content dropped.")
+          elsif options[:defer] and not options[:renew]
+            req.get_header(RACK_ERRORS).puts("Deferring cookie for #{session_id}") if $VERBOSE
+          else
+            cookie = Hash.new
+            cookie[:value] = cookie_value(data)
+            cookie[:expires] = Time.now + options[:expire_after] if options[:expire_after]
+            cookie[:expires] = Time.now + options[:max_age] if options[:max_age]
+            if @same_site.respond_to? :call
+              cookie[:same_site] = @same_site.call(req, res)
+            else
+              cookie[:same_site] = @same_site
+            end
+            set_cookie(req, res, cookie.merge!(options))
+          end
+        end
+        public :commit_session
+        def cookie_value(data)
+          data
+        end
+        def set_cookie(request, res, cookie)
+          if request.cookies[@key] != cookie[:value] || cookie[:expires]
+            res.set_cookie_header =
+              Utils.add_cookie_to_header(res.set_cookie_header, @key, cookie)
+          end
+        end
+        def session_class
+          SessionHash
+        end
+        def find_session(env, sid)
+          raise '#find_session not implemented.'
+        end
+        def write_session(req, sid, session, options)
+          raise '#write_session not implemented.'
+        end
+        def delete_session(req, sid, options)
+          raise '#delete_session not implemented'
+        end
+      end
+      class PersistedSecure < Persisted
+        class SecureSessionHash < SessionHash
+          def [](key)
+            if key == "session_id"
+              load_for_read!
+              id.public_id if id
+            else
+              super
+            end
+          end
+        end
+        def generate_sid(*)
+          public_id = super
+          SessionId.new(public_id)
+        end
+        def extract_session_id(*)
+          public_id = super
+          public_id && SessionId.new(public_id)
+        end
+        private
+        def session_class
+          SecureSessionHash
+        end
+        def cookie_value(data)
+          data.cookie_value
+        end
+      end
+      class ID < Persisted
+        def self.inherited(klass)
+          k = klass.ancestors.find { |kl| kl.respond_to?(:superclass) && kl.superclass == ID }
+          unless k.instance_variable_defined?(:"@_rack_warned")
+            warn "#{klass} is inheriting from #{ID}.  Inheriting from #{ID} is deprecated, please inherit from #{Persisted} instead" if $VERBOSE
+            k.instance_variable_set(:"@_rack_warned", true)
+          end
+          super
+        end
+        def find_session(req, sid)
+          get_session req.env, sid
+        end
+        def write_session(req, sid, session, options)
+          set_session req.env, sid, session, options
+        end
+        def delete_session(req, sid, options)
+          destroy_session req.env, sid, options
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/session/cookie.rb
@@ -0,0 +1,128 @@
+require 'openssl'
+require 'zlib'
+require_relative 'abstract/id'
+require 'json'
+require 'base64'
+module Rack
+  module Session
+    class Cookie < Abstract::PersistedSecure
+      class Base64
+        def encode(str)
+          ::Base64.strict_encode64(str)
+        end
+        def decode(str)
+          ::Base64.decode64(str)
+        end
+        class Marshal < Base64
+          def encode(str)
+            super(::Marshal.dump(str))
+          end
+          def decode(str)
+            return unless str
+            ::Marshal.load(super(str)) rescue nil
+          end
+        end
+        class JSON < Base64
+          def encode(obj)
+            super(::JSON.dump(obj))
+          end
+          def decode(str)
+            return unless str
+            ::JSON.parse(super(str)) rescue nil
+          end
+        end
+        class ZipJSON < Base64
+          def encode(obj)
+            super(Zlib::Deflate.deflate(::JSON.dump(obj)))
+          end
+          def decode(str)
+            return unless str
+            ::JSON.parse(Zlib::Inflate.inflate(super(str)))
+          rescue
+            nil
+          end
+        end
+      end
+      class Identity
+        def encode(str); str; end
+        def decode(str); str; end
+      end
+      attr_reader :coder
+      def initialize(app, options = {})
+        @secrets = options.values_at(:secret, :old_secret).compact
+        @hmac = options.fetch(:hmac, OpenSSL::Digest::SHA1)
+        warn <<-MSG unless secure?(options)
+        SECURITY WARNING: No secret option provided to Rack::Session::Cookie.
+        This poses a security threat. It is strongly recommended that you
+        provide a secret to prevent exploits that may be possible from crafted
+        cookies. This will not be supported in future versions of Rack, and
+        future versions will even invalidate your existing user cookies.
+        Called from: #{caller[0]}.
+        MSG
+        @coder = options[:coder] ||= Base64::Marshal.new
+        @same_site = options.delete :same_site
+        super(app, options.merge!(cookie_only: true))
+      end
+      private
+      def find_session(req, sid)
+        data = unpacked_cookie_data(req)
+        data = persistent_session_id!(data)
+        [data["session_id"], data]
+      end
+      def extract_session_id(request)
+        unpacked_cookie_data(request)["session_id"]
+      end
+      def unpacked_cookie_data(request)
+        request.fetch_header(RACK_SESSION_UNPACKED_COOKIE_DATA) do |k|
+          session_data = request.cookies[@key]
+          if @secrets.size > 0 && session_data
+            session_data, _, digest = session_data.rpartition('--')
+            session_data = nil unless digest_match?(session_data, digest)
+          end
+          request.set_header(k, coder.decode(session_data) || {})
+        end
+      end
+      def persistent_session_id!(data, sid = nil)
+        data ||= {}
+        data["session_id"] ||= sid || generate_sid
+        data
+      end
+      class SessionId < DelegateClass(Session::SessionId)
+        attr_reader :cookie_value
+        def initialize(session_id, cookie_value)
+          super(session_id)
+          @cookie_value = cookie_value
+        end
+      end
+      def write_session(req, session_id, session, options)
+        session = session.merge("session_id" => session_id)
+        session_data = coder.encode(session)
+        if @secrets.first
+          session_data << "--#{generate_hmac(session_data, @secrets.first)}"
+        end
+        if session_data.size > (4096 - @key.size)
+          req.get_header(RACK_ERRORS).puts("Warning! Rack::Session::Cookie data size exceeds 4K.")
+          nil
+        else
+          SessionId.new(session_id, session_data)
+        end
+      end
+      def delete_session(req, session_id, options)
+        generate_sid unless options[:drop]
+      end
+      def digest_match?(data, digest)
+        return unless data && digest
+        @secrets.any? do |secret|
+          Rack::Utils.secure_compare(digest, generate_hmac(data, secret))
+        end
+      end
+      def generate_hmac(data, secret)
+        OpenSSL::HMAC.hexdigest(@hmac.new, secret, data)
+      end
+      def secure?(options)
+        @secrets.size >= 1 ||
+        (options[:coder] && options[:let_coder_handle_secure_encoding])
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/session/pool.rb
@@ -0,0 +1,53 @@
+require_relative 'abstract/id'
+require 'thread'
+module Rack
+  module Session
+    class Pool < Abstract::PersistedSecure
+      attr_reader :mutex, :pool
+      DEFAULT_OPTIONS = Abstract::ID::DEFAULT_OPTIONS.merge drop: false
+      def initialize(app, options = {})
+        super
+        @pool = Hash.new
+        @mutex = Mutex.new
+      end
+      def generate_sid
+        loop do
+          sid = super
+          break sid unless @pool.key? sid.private_id
+        end
+      end
+      def find_session(req, sid)
+        with_lock(req) do
+          unless sid and session = get_session_with_fallback(sid)
+            sid, session = generate_sid, {}
+            @pool.store sid.private_id, session
+          end
+          [sid, session]
+        end
+      end
+      def write_session(req, session_id, new_session, options)
+        with_lock(req) do
+          @pool.store session_id.private_id, new_session
+          session_id
+        end
+      end
+      def delete_session(req, session_id, options)
+        with_lock(req) do
+          @pool.delete(session_id.public_id)
+          @pool.delete(session_id.private_id)
+          generate_sid unless options[:drop]
+        end
+      end
+      def with_lock(req)
+        @mutex.lock if req.multithread?
+        yield
+      ensure
+        @mutex.unlock if @mutex.locked?
+      end
+      private
+      def get_session_with_fallback(sid)
+        @pool[sid.private_id] || @pool[sid.public_id]
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/show_exceptions.rb
@@ -0,0 +1,322 @@
+require 'ostruct'
+require 'erb'
+module Rack
+  class ShowExceptions
+    CONTEXT = 7
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      @app.call(env)
+    rescue StandardError, LoadError, SyntaxError => e
+      exception_string = dump_exception(e)
+      env[RACK_ERRORS].puts(exception_string)
+      env[RACK_ERRORS].flush
+      if accepts_html?(env)
+        content_type = "text/html"
+        body = pretty(env, e)
+      else
+        content_type = "text/plain"
+        body = exception_string
+      end
+      [
+        500,
+        {
+          CONTENT_TYPE => content_type,
+          CONTENT_LENGTH => body.bytesize.to_s,
+        },
+        [body],
+      ]
+    end
+    def prefers_plaintext?(env)
+      !accepts_html?(env)
+    end
+    def accepts_html?(env)
+      Rack::Utils.best_q_match(env["HTTP_ACCEPT"], %w[text/html])
+    end
+    private :accepts_html?
+    def dump_exception(exception)
+      string = "#{exception.class}: #{exception.message}\n".dup
+      string << exception.backtrace.map { |l| "\t#{l}" }.join("\n")
+      string
+    end
+    def pretty(env, exception)
+      req = Rack::Request.new(env)
+      path = path = (req.script_name + req.path_info).squeeze("/")
+      frames = frames = exception.backtrace.map { |line|
+        frame = OpenStruct.new
+        if line =~ /(.*?):(\d+)(:in `(.*)')?/
+          frame.filename = $1
+          frame.lineno = $2.to_i
+          frame.function = $4
+          begin
+            lineno = frame.lineno - 1
+            lines = ::File.readlines(frame.filename)
+            frame.pre_context_lineno = [lineno - CONTEXT, 0].max
+            frame.pre_context = lines[frame.pre_context_lineno...lineno]
+            frame.context_line = lines[lineno].chomp
+            frame.post_context_lineno = [lineno + CONTEXT, lines.size].min
+            frame.post_context = lines[lineno + 1..frame.post_context_lineno]
+          rescue
+          end
+          frame
+        else
+          nil
+        end
+      }.compact
+      template.result(binding)
+    end
+    def template
+      TEMPLATE
+    end
+    def h(obj)                  # :nodoc:
+      case obj
+      when String
+        Utils.escape_html(obj)
+      else
+        Utils.escape_html(obj.inspect)
+      end
+    end
+    TEMPLATE = ERB.new(<<-'HTML'.gsub(/^      /, ''))
+      <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+      <html lang="en">
+      <head>
+        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
+        <meta name="robots" content="NONE,NOARCHIVE" />
+        <title><%=h exception.class %> at <%=h path %></title>
+        <style type="text/css">
+          html * { padding:0; margin:0; }
+          body * { padding:10px 20px; }
+          body * * { padding:0; }
+          body { font:small sans-serif; }
+          body>div { border-bottom:1px solid #ddd; }
+          h1 { font-weight:normal; }
+          h2 { margin-bottom:.8em; }
+          h2 span { font-size:80%; color:#666; font-weight:normal; }
+          h3 { margin:1em 0 .5em 0; }
+          h4 { margin:0 0 .5em 0; font-weight: normal; }
+          table {
+              border:1px solid #ccc; border-collapse: collapse; background:white; }
+          tbody td, tbody th { vertical-align:top; padding:2px 3px; }
+          thead th {
+              padding:1px 6px 1px 3px; background:#fefefe; text-align:left;
+              font-weight:normal; font-size:11px; border:1px solid #ddd; }
+          tbody th { text-align:right; color:#666; padding-right:.5em; }
+          table.vars { margin:5px 0 2px 40px; }
+          table.vars td, table.req td { font-family:monospace; }
+          table td.code { width:100%;}
+          table td.code div { overflow:hidden; }
+          table.source th { color:#666; }
+          table.source td {
+              font-family:monospace; white-space:pre; border-bottom:1px solid #eee; }
+          ul.traceback { list-style-type:none; }
+          ul.traceback li.frame { margin-bottom:1em; }
+          div.context { margin: 10px 0; }
+          div.context ol {
+              padding-left:30px; margin:0 10px; list-style-position: inside; }
+          div.context ol li {
+              font-family:monospace; white-space:pre; color:#666; cursor:pointer; }
+          div.context ol.context-line li { color:black; background-color:#ccc; }
+          div.context ol.context-line li span { float: right; }
+          div.commands { margin-left: 40px; }
+          div.commands a { color:black; text-decoration:none; }
+          .error { background: #ffc; }
+          .specific { color:#cc3300; font-weight:bold; }
+        </style>
+        <script type="text/javascript">
+        //<!--
+          function getElementsByClassName(oElm, strTagName, strClassName){
+              // Written by Jonathan Snook, http://www.snook.ca/jon;
+              // Add-ons by Robert Nyman, http://www.robertnyman.com
+              var arrElements = (strTagName == "*" && document.all)? document.all :
+              oElm.getElementsByTagName(strTagName);
+              var arrReturnElements = new Array();
+              strClassName = strClassName.replace(/\-/g, "\\-");
+              var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$$)");
+              var oElement;
+              for(var i=0; i<arrElements.length; i++){
+                  oElement = arrElements[i];
+                  if(oRegExp.test(oElement.className)){
+                      arrReturnElements.push(oElement);
+                  }
+              }
+              return (arrReturnElements)
+          }
+          function hideAll(elems) {
+            for (var e = 0; e < elems.length; e++) {
+              elems[e].style.display = 'none';
+            }
+          }
+          window.onload = function() {
+            hideAll(getElementsByClassName(document, 'table', 'vars'));
+            hideAll(getElementsByClassName(document, 'ol', 'pre-context'));
+            hideAll(getElementsByClassName(document, 'ol', 'post-context'));
+          }
+          function toggle() {
+            for (var i = 0; i < arguments.length; i++) {
+              var e = document.getElementById(arguments[i]);
+              if (e) {
+                e.style.display = e.style.display == 'none' ? 'block' : 'none';
+              }
+            }
+            return false;
+          }
+          function varToggle(link, id) {
+            toggle('v' + id);
+            var s = link.getElementsByTagName('span')[0];
+            var uarr = String.fromCharCode(0x25b6);
+            var darr = String.fromCharCode(0x25bc);
+            s.innerHTML = s.innerHTML == uarr ? darr : uarr;
+            return false;
+          }
+          //-->
+        </script>
+      </head>
+      <body>
+      <div id="summary">
+        <h1><%=h exception.class %> at <%=h path %></h1>
+        <h2><%=h exception.message %></h2>
+        <table><tr>
+          <th>Ruby</th>
+          <td>
+      <% if first = frames.first %>
+            <code><%=h first.filename %></code>: in <code><%=h first.function %></code>, line <%=h frames.first.lineno %>
+      <% else %>
+            unknown location
+      <% end %>
+          </td>
+        </tr><tr>
+          <th>Web</th>
+          <td><code><%=h req.request_method %> <%=h(req.host + path)%></code></td>
+        </tr></table>
+        <h3>Jump to:</h3>
+        <ul id="quicklinks">
+          <li><a href="#get-info">GET</a></li>
+          <li><a href="#post-info">POST</a></li>
+          <li><a href="#cookie-info">Cookies</a></li>
+          <li><a href="#env-info">ENV</a></li>
+        </ul>
+      </div>
+      <div id="traceback">
+        <h2>Traceback <span>(innermost first)</span></h2>
+        <ul class="traceback">
+      <% frames.each { |frame| %>
+            <li class="frame">
+              <code><%=h frame.filename %></code>: in <code><%=h frame.function %></code>
+                <% if frame.context_line %>
+                <div class="context" id="c<%=h frame.object_id %>">
+                    <% if frame.pre_context %>
+                    <ol start="<%=h frame.pre_context_lineno+1 %>" class="pre-context" id="pre<%=h frame.object_id %>">
+                      <% frame.pre_context.each { |line| %>
+                      <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h line %></li>
+                      <% } %>
+                    </ol>
+                    <% end %>
+                  <ol start="<%=h frame.lineno %>" class="context-line">
+                    <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h frame.context_line %><span>...</span></li></ol>
+                    <% if frame.post_context %>
+                    <ol start='<%=h frame.lineno+1 %>' class="post-context" id="post<%=h frame.object_id %>">
+                      <% frame.post_context.each { |line| %>
+                      <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h line %></li>
+                      <% } %>
+                    </ol>
+                    <% end %>
+                </div>
+                <% end %>
+            </li>
+      <% } %>
+        </ul>
+      </div>
+      <div id="requestinfo">
+        <h2>Request information</h2>
+        <h3 id="get-info">GET</h3>
+        <% if req.GET and not req.GET.empty? %>
+          <table class="req">
+            <thead>
+              <tr>
+                <th>Variable</th>
+                <th>Value</th>
+              </tr>
+            </thead>
+            <tbody>
+                <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %>
+                <tr>
+                  <td><%=h key %></td>
+                  <td class="code"><div><%=h val.inspect %></div></td>
+                </tr>
+                <% } %>
+            </tbody>
+          </table>
+        <% else %>
+          <p>No GET data.</p>
+        <% end %>
+        <h3 id="post-info">POST</h3>
+        <% if ((req.POST and not req.POST.empty?) rescue (no_post_data = "Invalid POST data"; nil)) %>
+          <table class="req">
+            <thead>
+              <tr>
+                <th>Variable</th>
+                <th>Value</th>
+              </tr>
+            </thead>
+            <tbody>
+                <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %>
+                <tr>
+                  <td><%=h key %></td>
+                  <td class="code"><div><%=h val.inspect %></div></td>
+                </tr>
+                <% } %>
+            </tbody>
+          </table>
+        <% else %>
+          <p><%= no_post_data || "No POST data" %>.</p>
+        <% end %>
+        <h3 id="cookie-info">COOKIES</h3>
+        <% unless req.cookies.empty? %>
+          <table class="req">
+            <thead>
+              <tr>
+                <th>Variable</th>
+                <th>Value</th>
+              </tr>
+            </thead>
+            <tbody>
+              <% req.cookies.each { |key, val| %>
+                <tr>
+                  <td><%=h key %></td>
+                  <td class="code"><div><%=h val.inspect %></div></td>
+                </tr>
+              <% } %>
+            </tbody>
+          </table>
+        <% else %>
+          <p>No cookie data.</p>
+        <% end %>
+        <h3 id="env-info">Rack ENV</h3>
+          <table class="req">
+            <thead>
+              <tr>
+                <th>Variable</th>
+                <th>Value</th>
+              </tr>
+            </thead>
+            <tbody>
+                <% env.sort_by { |k, v| k.to_s }.each { |key, val| %>
+                <tr>
+                  <td><%=h key %></td>
+                  <td class="code"><div><%=h val.inspect %></div></td>
+                </tr>
+                <% } %>
+            </tbody>
+          </table>
+      </div>
+      <div id="explanation">
+        <p>
+          You're seeing this error because you use <code>Rack::ShowExceptions</code>.
+        </p>
+      </div>
+      </body>
+      </html>
+    HTML
+  end
+end

--- a//dev/null
+++ b/lib/rack/show_status.rb
@@ -0,0 +1,77 @@
+require 'erb'
+module Rack
+  class ShowStatus
+    def initialize(app)
+      @app = app
+      @template = ERB.new(TEMPLATE)
+    end
+    def call(env)
+      status, headers, body = @app.call(env)
+      headers = Utils::HeaderHash[headers]
+      empty = headers[CONTENT_LENGTH].to_i <= 0
+      if (status.to_i >= 400 && empty) || env[RACK_SHOWSTATUS_DETAIL]
+        req = req = Rack::Request.new(env)
+        message = Rack::Utils::HTTP_STATUS_CODES[status.to_i] || status.to_s
+        detail = detail = env[RACK_SHOWSTATUS_DETAIL] || message
+        body = @template.result(binding)
+        size = body.bytesize
+        [status, headers.merge(CONTENT_TYPE => "text/html", CONTENT_LENGTH => size.to_s), [body]]
+      else
+        [status, headers, body]
+      end
+    end
+    def h(obj)                  # :nodoc:
+      case obj
+      when String
+        Utils.escape_html(obj)
+      else
+        Utils.escape_html(obj.inspect)
+      end
+    end
+TEMPLATE = <<'HTML'
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
+  <title><%=h message %> at <%=h req.script_name + req.path_info %></title>
+  <meta name="robots" content="NONE,NOARCHIVE" />
+  <style type="text/css">
+    html * { padding:0; margin:0; }
+    body * { padding:10px 20px; }
+    body * * { padding:0; }
+    body { font:small sans-serif; background:#eee; }
+    body>div { border-bottom:1px solid #ddd; }
+    h1 { font-weight:normal; margin-bottom:.4em; }
+    h1 span { font-size:60%; color:#666; font-weight:normal; }
+    table { border:none; border-collapse: collapse; width:100%; }
+    td, th { vertical-align:top; padding:2px 3px; }
+    th { width:12em; text-align:right; color:#666; padding-right:.5em; }
+  </style>
+</head>
+<body>
+  <div id="summary">
+    <h1><%=h message %> <span>(<%= status.to_i %>)</span></h1>
+    <table class="meta">
+      <tr>
+        <th>Request Method:</th>
+        <td><%=h req.request_method %></td>
+      </tr>
+      <tr>
+        <th>Request URL:</th>
+      <td><%=h req.url %></td>
+      </tr>
+    </table>
+  </div>
+  <div id="info">
+    <p><%=h detail %></p>
+  </div>
+  <div id="explanation">
+    <p>
+    You're seeing this error because you use <code>Rack::ShowStatus</code>.
+    </p>
+  </div>
+</body>
+</html>
+HTML
+  end
+end

--- a//dev/null
+++ b/lib/rack/static.rb
@@ -0,0 +1,81 @@
+module Rack
+  class Static
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    def initialize(app, options = {})
+      @app = app
+      @urls = options[:urls] || ["/favicon.ico"]
+      @index = options[:index]
+      @gzip = options[:gzip]
+      @cascade = options[:cascade]
+      root = options[:root] || Dir.pwd
+      @header_rules = options[:header_rules] || []
+      @header_rules.unshift([:all, { CACHE_CONTROL => options[:cache_control] }]) if options[:cache_control]
+      @file_server = Rack::Files.new(root)
+    end
+    def add_index_root?(path)
+      @index && route_file(path) && path.end_with?('/')
+    end
+    def overwrite_file_path(path)
+      @urls.kind_of?(Hash) && @urls.key?(path) || add_index_root?(path)
+    end
+    def route_file(path)
+      @urls.kind_of?(Array) && @urls.any? { |url| path.index(url) == 0 }
+    end
+    def can_serve(path)
+      route_file(path) || overwrite_file_path(path)
+    end
+    def call(env)
+      path = env[PATH_INFO]
+      if can_serve(path)
+        if overwrite_file_path(path)
+          env[PATH_INFO] = (add_index_root?(path) ? path + @index : @urls[path])
+        elsif @gzip && env['HTTP_ACCEPT_ENCODING'] && /\bgzip\b/.match?(env['HTTP_ACCEPT_ENCODING'])
+          path = env[PATH_INFO]
+          env[PATH_INFO] += '.gz'
+          response = @file_server.call(env)
+          env[PATH_INFO] = path
+          if response[0] == 404
+            response = nil
+          elsif response[0] == 304
+          else
+            if mime_type = Mime.mime_type(::File.extname(path), 'text/plain')
+              response[1][CONTENT_TYPE] = mime_type
+            end
+            response[1]['Content-Encoding'] = 'gzip'
+          end
+        end
+        path = env[PATH_INFO]
+        response ||= @file_server.call(env)
+        if @cascade && response[0] == 404
+          return @app.call(env)
+        end
+        headers = response[1]
+        applicable_rules(path).each do |rule, new_headers|
+          new_headers.each { |field, content| headers[field] = content }
+        end
+        response
+      else
+        @app.call(env)
+      end
+    end
+    def applicable_rules(path)
+      @header_rules.find_all do |rule, new_headers|
+        case rule
+        when :all
+          true
+        when :fonts
+          /\.(?:ttf|otf|eot|woff2|woff|svg)\z/.match?(path)
+        when String
+          path = ::Rack::Utils.unescape(path)
+          path.start_with?(rule) || path.start_with?('/' + rule)
+        when Array
+          /\.(#{rule.join('|')})\z/.match?(path)
+        when Regexp
+          rule.match?(path)
+        else
+          false
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/tempfile_reaper.rb
@@ -0,0 +1,15 @@
+module Rack
+  class TempfileReaper
+    def initialize(app)
+      @app = app
+    end
+    def call(env)
+      env[RACK_TEMPFILES] ||= []
+      status, headers, body = @app.call(env)
+      body_proxy = BodyProxy.new(body) do
+        env[RACK_TEMPFILES].each(&:close!) unless env[RACK_TEMPFILES].nil?
+      end
+      [status, headers, body_proxy]
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/urlmap.rb
@@ -0,0 +1,62 @@
+require 'set'
+module Rack
+  class URLMap
+    def initialize(map = {})
+      remap(map)
+    end
+    def remap(map)
+      @known_hosts = Set[]
+      @mapping = map.map { |location, app|
+        if location =~ %r{\Ahttps?://(.*?)(/.*)}
+          host, location = $1, $2
+          @known_hosts << host
+        else
+          host = nil
+        end
+        unless location[0] == ?/
+          raise ArgumentError, "paths need to start with /"
+        end
+        location = location.chomp('/')
+        match = Regexp.new("^#{Regexp.quote(location).gsub('/', '/+')}(.*)", nil, 'n')
+        [host, location, match, app]
+      }.sort_by do |(host, location, _, _)|
+        [host ? -host.size : Float::INFINITY, -location.size]
+      end
+    end
+    def call(env)
+      path        = env[PATH_INFO]
+      script_name = env[SCRIPT_NAME]
+      http_host   = env[HTTP_HOST]
+      server_name = env[SERVER_NAME]
+      server_port = env[SERVER_PORT]
+      is_same_server = casecmp?(http_host, server_name) ||
+                       casecmp?(http_host, "#{server_name}:#{server_port}")
+      is_host_known = @known_hosts.include? http_host
+      @mapping.each do |host, location, match, app|
+        unless casecmp?(http_host, host) \
+            || casecmp?(server_name, host) \
+            || (!host && is_same_server) \
+            || (!host && !is_host_known) # If we don't have a matching host, default to the first without a specified host
+          next
+        end
+        next unless m = match.match(path.to_s)
+        rest = m[1]
+        next unless !rest || rest.empty? || rest[0] == ?/
+        env[SCRIPT_NAME] = (script_name + location)
+        env[PATH_INFO] = rest
+        return app.call(env)
+      end
+      [404, { CONTENT_TYPE => "text/plain", "X-Cascade" => "pass" }, ["Not Found: #{path}"]]
+    ensure
+      env[PATH_INFO]   = path
+      env[SCRIPT_NAME] = script_name
+    end
+    private
+    def casecmp?(v1, v2)
+      return true if v1 == v2
+      return false if v1.nil?
+      return false if v2.nil?
+      v1.casecmp(v2).zero?
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rack/utils.rb
@@ -0,0 +1,453 @@
+require 'uri'
+require 'fileutils'
+require 'set'
+require 'tempfile'
+require 'time'
+require_relative 'query_parser'
+module Rack
+  module Utils
+    (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
+    ParameterTypeError = QueryParser::ParameterTypeError
+    InvalidParameterError = QueryParser::InvalidParameterError
+    DEFAULT_SEP = QueryParser::DEFAULT_SEP
+    COMMON_SEP = QueryParser::COMMON_SEP
+    KeySpaceConstrainedParams = QueryParser::Params
+    class << self
+      attr_accessor :default_query_parser
+    end
+    self.default_query_parser = QueryParser.make_default(65536, 100)
+    module_function
+    def escape(s)
+      URI.encode_www_form_component(s)
+    end
+    def escape_path(s)
+      ::URI::DEFAULT_PARSER.escape s
+    end
+    def unescape_path(s)
+      ::URI::DEFAULT_PARSER.unescape s
+    end
+    def unescape(s, encoding = Encoding::UTF_8)
+      URI.decode_www_form_component(s, encoding)
+    end
+    class << self
+      attr_accessor :multipart_part_limit
+    end
+    self.multipart_part_limit = (ENV['RACK_MULTIPART_PART_LIMIT'] || 128).to_i
+    def self.param_depth_limit
+      default_query_parser.param_depth_limit
+    end
+    def self.param_depth_limit=(v)
+      self.default_query_parser = self.default_query_parser.new_depth_limit(v)
+    end
+    def self.key_space_limit
+      default_query_parser.key_space_limit
+    end
+    def self.key_space_limit=(v)
+      self.default_query_parser = self.default_query_parser.new_space_limit(v)
+    end
+    if defined?(Process::CLOCK_MONOTONIC)
+      def clock_time
+        Process.clock_gettime(Process::CLOCK_MONOTONIC)
+      end
+    else
+      def clock_time
+        Time.now.to_f
+      end
+    end
+    def parse_query(qs, d = nil, &unescaper)
+      Rack::Utils.default_query_parser.parse_query(qs, d, &unescaper)
+    end
+    def parse_nested_query(qs, d = nil)
+      Rack::Utils.default_query_parser.parse_nested_query(qs, d)
+    end
+    def build_query(params)
+      params.map { |k, v|
+        if v.class == Array
+          build_query(v.map { |x| [k, x] })
+        else
+          v.nil? ? escape(k) : "#{escape(k)}=#{escape(v)}"
+        end
+      }.join("&")
+    end
+    def build_nested_query(value, prefix = nil)
+      case value
+      when Array
+        value.map { |v|
+          build_nested_query(v, "#{prefix}[]")
+        }.join("&")
+      when Hash
+        value.map { |k, v|
+          build_nested_query(v, prefix ? "#{prefix}[#{escape(k)}]" : escape(k))
+        }.delete_if(&:empty?).join('&')
+      when nil
+        prefix
+      else
+        raise ArgumentError, "value must be a Hash" if prefix.nil?
+        "#{prefix}=#{escape(value)}"
+      end
+    end
+    def q_values(q_value_header)
+      q_value_header.to_s.split(/\s*,\s*/).map do |part|
+        value, parameters = part.split(/\s*;\s*/, 2)
+        quality = 1.0
+        if parameters && (md = /\Aq=([\d.]+)/.match(parameters))
+          quality = md[1].to_f
+        end
+        [value, quality]
+      end
+    end
+    def best_q_match(q_value_header, available_mimes)
+      values = q_values(q_value_header)
+      matches = values.map do |req_mime, quality|
+        match = available_mimes.find { |am| Rack::Mime.match?(am, req_mime) }
+        next unless match
+        [match, quality]
+      end.compact.sort_by do |match, quality|
+        (match.split('/', 2).count('*') * -10) + quality
+      end.last
+      matches && matches.first
+    end
+    ESCAPE_HTML = {
+      "&" => "&amp;",
+      "<" => "&lt;",
+      ">" => "&gt;",
+      "'" => "&#x27;",
+      '"' => "&quot;",
+      "/" => "&#x2F;"
+    }
+    ESCAPE_HTML_PATTERN = Regexp.union(*ESCAPE_HTML.keys)
+    def escape_html(string)
+      string.to_s.gsub(ESCAPE_HTML_PATTERN){|c| ESCAPE_HTML[c] }
+    end
+    def select_best_encoding(available_encodings, accept_encoding)
+      expanded_accept_encoding = []
+      accept_encoding.each do |m, q|
+        preference = available_encodings.index(m) || available_encodings.size
+        if m == "*"
+          (available_encodings - accept_encoding.map(&:first)).each do |m2|
+            expanded_accept_encoding << [m2, q, preference]
+          end
+        else
+          expanded_accept_encoding << [m, q, preference]
+        end
+      end
+      encoding_candidates = expanded_accept_encoding
+        .sort_by { |_, q, p| [-q, p] }
+        .map!(&:first)
+      unless encoding_candidates.include?("identity")
+        encoding_candidates.push("identity")
+      end
+      expanded_accept_encoding.each do |m, q|
+        encoding_candidates.delete(m) if q == 0.0
+      end
+      (encoding_candidates & available_encodings)[0]
+    end
+    def parse_cookies(env)
+      parse_cookies_header env[HTTP_COOKIE]
+    end
+    def parse_cookies_header(header)
+      cookies = parse_query(header, ';') { |s| unescape(s) rescue s }
+      cookies.each_with_object({}) { |(k, v), hash| hash[k] = Array === v ? v.first : v }
+    end
+    def add_cookie_to_header(header, key, value)
+      case value
+      when Hash
+        domain  = "; domain=#{value[:domain]}"   if value[:domain]
+        path    = "; path=#{value[:path]}"       if value[:path]
+        max_age = "; max-age=#{value[:max_age]}" if value[:max_age]
+        expires = "; expires=#{value[:expires].httpdate}" if value[:expires]
+        secure = "; secure"  if value[:secure]
+        httponly = "; HttpOnly" if (value.key?(:httponly) ? value[:httponly] : value[:http_only])
+        same_site =
+          case value[:same_site]
+          when false, nil
+            nil
+          when :none, 'None', :None
+            '; SameSite=None'
+          when :lax, 'Lax', :Lax
+            '; SameSite=Lax'
+          when true, :strict, 'Strict', :Strict
+            '; SameSite=Strict'
+          else
+            raise ArgumentError, "Invalid SameSite value: #{value[:same_site].inspect}"
+          end
+        value = value[:value]
+      end
+      value = [value] unless Array === value
+      cookie = "#{escape(key)}=#{value.map { |v| escape v }.join('&')}#{domain}" \
+        "#{path}#{max_age}#{expires}#{secure}#{httponly}#{same_site}"
+      case header
+      when nil, ''
+        cookie
+      when String
+        [header, cookie].join("\n")
+      when Array
+        (header + [cookie]).join("\n")
+      else
+        raise ArgumentError, "Unrecognized cookie header value. Expected String, Array, or nil, got #{header.inspect}"
+      end
+    end
+    def set_cookie_header!(header, key, value)
+      header[SET_COOKIE] = add_cookie_to_header(header[SET_COOKIE], key, value)
+      nil
+    end
+    def make_delete_cookie_header(header, key, value)
+      case header
+      when nil, ''
+        cookies = []
+      when String
+        cookies = header.split("\n")
+      when Array
+        cookies = header
+      end
+      key = escape(key)
+      domain = value[:domain]
+      path = value[:path]
+      regexp = if domain
+                 if path
+                   /\A#{key}=.*(?:domain=#{domain}(?:;|$).*path=#{path}(?:;|$)|path=#{path}(?:;|$).*domain=#{domain}(?:;|$))/
+                 else
+                   /\A#{key}=.*domain=#{domain}(?:;|$)/
+                 end
+               elsif path
+                 /\A#{key}=.*path=#{path}(?:;|$)/
+               else
+                 /\A#{key}=/
+               end
+      cookies.reject! { |cookie| regexp.match? cookie }
+      cookies.join("\n")
+    end
+    def delete_cookie_header!(header, key, value = {})
+      header[SET_COOKIE] = add_remove_cookie_to_header(header[SET_COOKIE], key, value)
+      nil
+    end
+    def add_remove_cookie_to_header(header, key, value = {})
+      new_header = make_delete_cookie_header(header, key, value)
+      add_cookie_to_header(new_header, key,
+                 { value: '', path: nil, domain: nil,
+                   max_age: '0',
+                   expires: Time.at(0) }.merge(value))
+    end
+    def rfc2822(time)
+      time.rfc2822
+    end
+    def rfc2109(time)
+      wday = Time::RFC2822_DAY_NAME[time.wday]
+      mon = Time::RFC2822_MONTH_NAME[time.mon - 1]
+      time.strftime("#{wday}, %d-#{mon}-%Y %H:%M:%S GMT")
+    end
+    def byte_ranges(env, size)
+      warn "`byte_ranges` is deprecated, please use `get_byte_ranges`" if $VERBOSE
+      get_byte_ranges env['HTTP_RANGE'], size
+    end
+    def get_byte_ranges(http_range, size)
+      return nil unless http_range && http_range =~ /bytes=([^;]+)/
+      ranges = []
+      $1.split(/,\s*/).each do |range_spec|
+        return nil  unless range_spec =~ /(\d*)-(\d*)/
+        r0, r1 = $1, $2
+        if r0.empty?
+          return nil  if r1.empty?
+          r0 = size - r1.to_i
+          r0 = 0  if r0 < 0
+          r1 = size - 1
+        else
+          r0 = r0.to_i
+          if r1.empty?
+            r1 = size - 1
+          else
+            r1 = r1.to_i
+            return nil  if r1 < r0  # backwards range is syntactically invalid
+            r1 = size - 1  if r1 >= size
+          end
+        end
+        ranges << (r0..r1)  if r0 <= r1
+      end
+      ranges
+    end
+    def secure_compare(a, b)
+      return false unless a.bytesize == b.bytesize
+      l = a.unpack("C*")
+      r, i = 0, -1
+      b.each_byte { |v| r |= v ^ l[i += 1] }
+      r == 0
+    end
+    class Context
+      attr_reader :for, :app
+      def initialize(app_f, app_r)
+        raise 'running context does not respond to #context' unless app_f.respond_to? :context
+        @for, @app = app_f, app_r
+      end
+      def call(env)
+        @for.context(env, @app)
+      end
+      def recontext(app)
+        self.class.new(@for, app)
+      end
+      def context(env, app = @app)
+        recontext(app).call(env)
+      end
+    end
+    class HeaderHash < Hash # :nodoc:
+      def self.[](headers)
+        if headers.is_a?(HeaderHash) && !headers.frozen?
+          return headers
+        else
+          return self.new(headers)
+        end
+      end
+      def initialize(hash = {})
+        super()
+        @names = {}
+        hash.each { |k, v| self[k] = v }
+      end
+      def initialize_copy(other)
+        super
+        @names = other.names.dup
+      end
+      def clear
+        super
+        @names.clear
+      end
+      def each
+        super do |k, v|
+          yield(k, v.respond_to?(:to_ary) ? v.to_ary.join("\n") : v)
+        end
+      end
+      def to_hash
+        hash = {}
+        each { |k, v| hash[k] = v }
+        hash
+      end
+      def [](k)
+        super(k) || super(@names[k.downcase])
+      end
+      def []=(k, v)
+        canonical = k.downcase.freeze
+        delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
+        @names[canonical] = k
+        super k, v
+      end
+      def delete(k)
+        canonical = k.downcase
+        result = super @names.delete(canonical)
+        result
+      end
+      def include?(k)
+        super || @names.include?(k.downcase)
+      end
+      alias_method :has_key?, :include?
+      alias_method :member?, :include?
+      alias_method :key?, :include?
+      def merge!(other)
+        other.each { |k, v| self[k] = v }
+        self
+      end
+      def merge(other)
+        hash = dup
+        hash.merge! other
+      end
+      def replace(other)
+        clear
+        other.each { |k, v| self[k] = v }
+        self
+      end
+      protected
+        def names
+          @names
+        end
+    end
+    HTTP_STATUS_CODES = {
+      100 => 'Continue',
+      101 => 'Switching Protocols',
+      102 => 'Processing',
+      103 => 'Early Hints',
+      200 => 'OK',
+      201 => 'Created',
+      202 => 'Accepted',
+      203 => 'Non-Authoritative Information',
+      204 => 'No Content',
+      205 => 'Reset Content',
+      206 => 'Partial Content',
+      207 => 'Multi-Status',
+      208 => 'Already Reported',
+      226 => 'IM Used',
+      300 => 'Multiple Choices',
+      301 => 'Moved Permanently',
+      302 => 'Found',
+      303 => 'See Other',
+      304 => 'Not Modified',
+      305 => 'Use Proxy',
+      306 => '(Unused)',
+      307 => 'Temporary Redirect',
+      308 => 'Permanent Redirect',
+      400 => 'Bad Request',
+      401 => 'Unauthorized',
+      402 => 'Payment Required',
+      403 => 'Forbidden',
+      404 => 'Not Found',
+      405 => 'Method Not Allowed',
+      406 => 'Not Acceptable',
+      407 => 'Proxy Authentication Required',
+      408 => 'Request Timeout',
+      409 => 'Conflict',
+      410 => 'Gone',
+      411 => 'Length Required',
+      412 => 'Precondition Failed',
+      413 => 'Payload Too Large',
+      414 => 'URI Too Long',
+      415 => 'Unsupported Media Type',
+      416 => 'Range Not Satisfiable',
+      417 => 'Expectation Failed',
+      421 => 'Misdirected Request',
+      422 => 'Unprocessable Entity',
+      423 => 'Locked',
+      424 => 'Failed Dependency',
+      425 => 'Too Early',
+      426 => 'Upgrade Required',
+      428 => 'Precondition Required',
+      429 => 'Too Many Requests',
+      431 => 'Request Header Fields Too Large',
+      451 => 'Unavailable for Legal Reasons',
+      500 => 'Internal Server Error',
+      501 => 'Not Implemented',
+      502 => 'Bad Gateway',
+      503 => 'Service Unavailable',
+      504 => 'Gateway Timeout',
+      505 => 'HTTP Version Not Supported',
+      506 => 'Variant Also Negotiates',
+      507 => 'Insufficient Storage',
+      508 => 'Loop Detected',
+      509 => 'Bandwidth Limit Exceeded',
+      510 => 'Not Extended',
+      511 => 'Network Authentication Required'
+    }
+    STATUS_WITH_NO_ENTITY_BODY = Hash[((100..199).to_a << 204 << 304).product([true])]
+    SYMBOL_TO_STATUS_CODE = Hash[*HTTP_STATUS_CODES.map { |code, message|
+      [message.downcase.gsub(/\s|-|'/, '_').to_sym, code]
+    }.flatten]
+    def status_code(status)
+      if status.is_a?(Symbol)
+        SYMBOL_TO_STATUS_CODE.fetch(status) { raise ArgumentError, "Unrecognized status code #{status.inspect}" }
+      else
+        status.to_i
+      end
+    end
+    PATH_SEPS = Regexp.union(*[::File::SEPARATOR, ::File::ALT_SEPARATOR].compact)
+    def clean_path_info(path_info)
+      parts = path_info.split PATH_SEPS
+      clean = []
+      parts.each do |part|
+        next if part.empty? || part == '.'
+        part == '..' ? clean.pop : clean << part
+      end
+      clean_path = clean.join(::File::SEPARATOR)
+      clean_path.prepend("/") if parts.empty? || parts.first.empty?
+      clean_path
+    end
+    NULL_BYTE = "\0"
+    def valid_path?(path)
+      path.valid_encoding? && !path.include?(NULL_BYTE)
+    end
+  end
+end

--- a/lib/rack/version.rb
+++ b/lib/rack/version.rb
@@ -1,10 +1,10 @@
 module Rack
   VERSION = [1, 3]
   def self.version
     VERSION.join(".")
   end
-  RELEASE = "2.2.3.1"
+  RELEASE = "2.2.0"
   def self.release
     RELEASE
   end
 end
