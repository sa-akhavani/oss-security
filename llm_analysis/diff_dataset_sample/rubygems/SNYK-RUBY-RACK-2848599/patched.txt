# ====================================================================
# FILE: lib/rack/common_logger.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 10-43 ---
    10|       status, headers, body = @app.call(env)
    11|       headers = Utils::HeaderHash[headers]
    12|       body = BodyProxy.new(body) { log(env, status, headers, began_at) }
    13|       [status, headers, body]
    14|     end
    15|     private
    16|     def log(env, status, header, began_at)
    17|       length = extract_content_length(header)
    18|       msg = FORMAT % [
    19|         env['HTTP_X_FORWARDED_FOR'] || env["REMOTE_ADDR"] || "-",
    20|         env["REMOTE_USER"] || "-",
    21|         Time.now.strftime("%d/%b/%Y:%H:%M:%S %z"),
    22|         env[REQUEST_METHOD],
    23|         env[SCRIPT_NAME],
    24|         env[PATH_INFO],
    25|         env[QUERY_STRING].empty? ? "" : "?#{env[QUERY_STRING]}",
    26|         env[SERVER_PROTOCOL],
    27|         status.to_s[0..3],
    28|         length,
    29|         Utils.clock_time - began_at ]
    30|       msg.gsub!(/[^[:print:]\n]/) { |c| "\\x#{c.ord}" }
    31|       logger = @logger || env[RACK_ERRORS]
    32|       if logger.respond_to?(:write)
    33|         logger.write(msg)
    34|       else
    35|         logger << msg
    36|       end
    37|     end
    38|     def extract_content_length(headers)
    39|       value = headers[CONTENT_LENGTH]
    40|       !value || value.to_s == '0' ? '-' : value
    41|     end
    42|   end
    43| end


# ====================================================================
# FILE: lib/rack/lint.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 117-157 ---
   117|       }
   118|       env.each { |key, value|
   119|         next  if key.include? "."   # Skip extensions
   120|         assert("env variable #{key} has non-string value #{value.inspect}") {
   121|           value.kind_of? String
   122|         }
   123|         next if value.encoding == Encoding::ASCII_8BIT
   124|         assert("env variable #{key} has value containing non-ASCII characters and has non-ASCII-8BIT encoding #{value.inspect} encoding: #{value.encoding}") {
   125|           value.b !~ /[\x80-\xff]/n
   126|         }
   127|       }
   128|       assert("rack.version must be an Array, was #{env[RACK_VERSION].class}") {
   129|         env[RACK_VERSION].kind_of? Array
   130|       }
   131|       assert("rack.url_scheme unknown: #{env[RACK_URL_SCHEME].inspect}") {
   132|         %w[http https].include?(env[RACK_URL_SCHEME])
   133|       }
   134|       check_input env[RACK_INPUT]
   135|       check_error env[RACK_ERRORS]
   136|       check_hijack env
   137|       assert("REQUEST_METHOD unknown: #{env[REQUEST_METHOD].dump}") {
   138|         env[REQUEST_METHOD] =~ /\A[0-9A-Za-z!\#$%&'*+.^_`|~-]+\z/
   139|       }
   140|       assert("SCRIPT_NAME must start with /") {
   141|         !env.include?(SCRIPT_NAME) ||
   142|         env[SCRIPT_NAME] == "" ||
   143|         env[SCRIPT_NAME] =~ /\A\//
   144|       }
   145|       assert("PATH_INFO must start with /") {
   146|         !env.include?(PATH_INFO) ||
   147|         env[PATH_INFO] == "" ||
   148|         env[PATH_INFO] =~ /\A\//
   149|       }
   150|       assert("Invalid CONTENT_LENGTH: #{env["CONTENT_LENGTH"]}") {
   151|         !env.include?("CONTENT_LENGTH") || env["CONTENT_LENGTH"] =~ /\A\d+\z/
   152|       }
   153|       assert("One of SCRIPT_NAME or PATH_INFO must be set (make PATH_INFO '/' if SCRIPT_NAME is empty)") {
   154|         env[SCRIPT_NAME] || env[PATH_INFO]
   155|       }
   156|       assert("SCRIPT_NAME cannot be '/', make it '' and PATH_INFO '/'") {
   157|         env[SCRIPT_NAME] != "/"


# ====================================================================
# FILE: lib/rack/multipart.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| require_relative 'multipart/parser'
     2| module Rack
     3|   module Multipart
     4|     autoload :UploadedFile, 'rack/multipart/uploaded_file'
     5|     autoload :Generator, 'rack/multipart/generator'
     6|     EOL = "\r\n"
     7|     MULTIPART_BOUNDARY = "AaB03x"
     8|     MULTIPART = %r|\Amultipart/.*boundary=\"?([^\";,]+)\"?|ni
     9|     TOKEN = /[^\s()<>,;:\\"\/\[\]?=]+/
    10|     CONDISP = /Content-Disposition:\s*#{TOKEN}\s*/i
    11|     VALUE = /"(?:\\"|[^"])*"|#{TOKEN}/
    12|     BROKEN = /^#{CONDISP}.*;\s*filename=(#{VALUE})/i
    13|     MULTIPART_CONTENT_TYPE = /Content-Type: (.*)#{EOL}/ni
    14|     MULTIPART_CONTENT_DISPOSITION = /Content-Disposition:.*;\s*name=(#{VALUE})/ni
    15|     MULTIPART_CONTENT_ID = /Content-ID:\s*([^#{EOL}]*)/ni
    16|     ATTRIBUTE_CHAR = %r{[^ \t\v\n\r)(><@,;:\\"/\[\]?='*%]}
    17|     ATTRIBUTE = /#{ATTRIBUTE_CHAR}+/
    18|     SECTION = /\*[0-9]+/
    19|     REGULAR_PARAMETER_NAME = /#{ATTRIBUTE}#{SECTION}?/
    20|     REGULAR_PARAMETER = /(#{REGULAR_PARAMETER_NAME})=(#{VALUE})/
    21|     EXTENDED_OTHER_NAME = /#{ATTRIBUTE}\*[1-9][0-9]*\*/
    22|     EXTENDED_OTHER_VALUE = /%[0-9a-fA-F]{2}|#{ATTRIBUTE_CHAR}/
    23|     EXTENDED_OTHER_PARAMETER = /(#{EXTENDED_OTHER_NAME})=(#{EXTENDED_OTHER_VALUE}*)/
    24|     EXTENDED_INITIAL_NAME = /#{ATTRIBUTE}(?:\*0)?\*/
    25|     EXTENDED_INITIAL_VALUE = /[a-zA-Z0-9\-]*'[a-zA-Z0-9\-]*'#{EXTENDED_OTHER_VALUE}*/
    26|     EXTENDED_INITIAL_PARAMETER = /(#{EXTENDED_INITIAL_NAME})=(#{EXTENDED_INITIAL_VALUE})/
    27|     EXTENDED_PARAMETER = /#{EXTENDED_INITIAL_PARAMETER}|#{EXTENDED_OTHER_PARAMETER}/
    28|     DISPPARM = /;\s*(?:#{REGULAR_PARAMETER}|#{EXTENDED_PARAMETER})\s*/
    29|     RFC2183 = /^#{CONDISP}(#{DISPPARM})+$/i
    30|     class << self
    31|       def parse_multipart(env, params = Rack::Utils.default_query_parser)
    32|         extract_multipart Rack::Request.new(env), params


# ====================================================================
# FILE: lib/rack/multipart/parser.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 220-262 ---
   220|       def full_boundary; @full_boundary; end
   221|       def consume_boundary
   222|         while read_buffer = @sbuf.scan_until(BOUNDARY_REGEX)
   223|           case read_buffer.strip
   224|           when full_boundary then return :BOUNDARY
   225|           when @end_boundary then return :END_BOUNDARY
   226|           end
   227|           return if @sbuf.eos?
   228|         end
   229|       end
   230|       def get_filename(head)
   231|         filename = nil
   232|         case head
   233|         when RFC2183
   234|           params = Hash[*head.scan(DISPPARM).flat_map(&:compact)]
   235|           if filename = params['filename']
   236|             filename = $1 if filename =~ /^"(.*)"$/
   237|           elsif filename = params['filename*']
   238|             encoding, _, filename = filename.split("'", 3)
   239|           end
   240|         when BROKEN
   241|           filename = $1
   242|           filename = $1 if filename =~ /^"(.*)"$/
   243|         end
   244|         return unless filename
   245|         if filename.scan(/%.?.?/).all? { |s| /%[0-9a-fA-F]{2}/.match?(s) }
   246|           filename = Utils.unescape_path(filename)
   247|         end
   248|         filename.scrub!
   249|         if filename !~ /\\[^\\"]/
   250|           filename = filename.gsub(/\\(.)/, '\1')
   251|         end
   252|         if encoding
   253|           filename.force_encoding ::Encoding.find(encoding)
   254|         end
   255|         filename
   256|       end
   257|       CHARSET = "charset"
   258|       def tag_multipart_encoding(filename, content_type, name, body)
   259|         name = name.to_s
   260|         encoding = Encoding::UTF_8
   261|         name.force_encoding(encoding)
   262|         return if filename


# ====================================================================
# FILE: lib/rack/version.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| module Rack
     2|   VERSION = [1, 3]
     3|   def self.version
     4|     VERSION.join(".")
     5|   end
     6|   RELEASE = "2.2.3.1"
     7|   def self.release
     8|     RELEASE
     9|   end
    10| end

