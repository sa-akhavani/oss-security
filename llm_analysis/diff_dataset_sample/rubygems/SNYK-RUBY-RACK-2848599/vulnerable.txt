# ====================================================================
# FILE: lib/rack.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-118 ---
     1| require_relative 'rack/version'
     2| module Rack
     3|   HTTP_HOST         = 'HTTP_HOST'
     4|   HTTP_PORT         = 'HTTP_PORT'
     5|   HTTP_VERSION      = 'HTTP_VERSION'
     6|   HTTPS             = 'HTTPS'
     7|   PATH_INFO         = 'PATH_INFO'
     8|   REQUEST_METHOD    = 'REQUEST_METHOD'
     9|   REQUEST_PATH      = 'REQUEST_PATH'
    10|   SCRIPT_NAME       = 'SCRIPT_NAME'
    11|   QUERY_STRING      = 'QUERY_STRING'
    12|   SERVER_PROTOCOL   = 'SERVER_PROTOCOL'
    13|   SERVER_NAME       = 'SERVER_NAME'
    14|   SERVER_PORT       = 'SERVER_PORT'
    15|   CACHE_CONTROL     = 'Cache-Control'
    16|   EXPIRES           = 'Expires'
    17|   CONTENT_LENGTH    = 'Content-Length'
    18|   CONTENT_TYPE      = 'Content-Type'
    19|   SET_COOKIE        = 'Set-Cookie'
    20|   TRANSFER_ENCODING = 'Transfer-Encoding'
    21|   HTTP_COOKIE       = 'HTTP_COOKIE'
    22|   ETAG              = 'ETag'
    23|   GET     = 'GET'
    24|   POST    = 'POST'
    25|   PUT     = 'PUT'
    26|   PATCH   = 'PATCH'
    27|   DELETE  = 'DELETE'
    28|   HEAD    = 'HEAD'
    29|   OPTIONS = 'OPTIONS'
    30|   LINK    = 'LINK'
    31|   UNLINK  = 'UNLINK'
    32|   TRACE   = 'TRACE'
    33|   RACK_VERSION                        = 'rack.version'
    34|   RACK_TEMPFILES                      = 'rack.tempfiles'
    35|   RACK_ERRORS                         = 'rack.errors'
    36|   RACK_LOGGER                         = 'rack.logger'
    37|   RACK_INPUT                          = 'rack.input'
    38|   RACK_SESSION                        = 'rack.session'
    39|   RACK_SESSION_OPTIONS                = 'rack.session.options'
    40|   RACK_SHOWSTATUS_DETAIL              = 'rack.showstatus.detail'
    41|   RACK_MULTITHREAD                    = 'rack.multithread'
    42|   RACK_MULTIPROCESS                   = 'rack.multiprocess'
    43|   RACK_RUNONCE                        = 'rack.run_once'
    44|   RACK_URL_SCHEME                     = 'rack.url_scheme'
    45|   RACK_HIJACK                         = 'rack.hijack'
    46|   RACK_IS_HIJACK                      = 'rack.hijack?'
    47|   RACK_HIJACK_IO                      = 'rack.hijack_io'
    48|   RACK_RECURSIVE_INCLUDE              = 'rack.recursive.include'
    49|   RACK_MULTIPART_BUFFER_SIZE          = 'rack.multipart.buffer_size'
    50|   RACK_MULTIPART_TEMPFILE_FACTORY     = 'rack.multipart.tempfile_factory'
    51|   RACK_REQUEST_FORM_INPUT             = 'rack.request.form_input'
    52|   RACK_REQUEST_FORM_HASH              = 'rack.request.form_hash'
    53|   RACK_REQUEST_FORM_VARS              = 'rack.request.form_vars'
    54|   RACK_REQUEST_COOKIE_HASH            = 'rack.request.cookie_hash'
    55|   RACK_REQUEST_COOKIE_STRING          = 'rack.request.cookie_string'
    56|   RACK_REQUEST_QUERY_HASH             = 'rack.request.query_hash'
    57|   RACK_REQUEST_QUERY_STRING           = 'rack.request.query_string'
    58|   RACK_METHODOVERRIDE_ORIGINAL_METHOD = 'rack.methodoverride.original_method'
    59|   RACK_SESSION_UNPACKED_COOKIE_DATA   = 'rack.session.unpacked_cookie_data'
    60|   autoload :Builder, "rack/builder"
    61|   autoload :BodyProxy, "rack/body_proxy"
    62|   autoload :Cascade, "rack/cascade"
    63|   autoload :Chunked, "rack/chunked"
    64|   autoload :CommonLogger, "rack/common_logger"
    65|   autoload :ConditionalGet, "rack/conditional_get"
    66|   autoload :Config, "rack/config"
    67|   autoload :ContentLength, "rack/content_length"
    68|   autoload :ContentType, "rack/content_type"
    69|   autoload :ETag, "rack/etag"
    70|   autoload :Events, "rack/events"
    71|   autoload :File, "rack/file"
    72|   autoload :Files, "rack/files"
    73|   autoload :Deflater, "rack/deflater"
    74|   autoload :Directory, "rack/directory"
    75|   autoload :ForwardRequest, "rack/recursive"
    76|   autoload :Handler, "rack/handler"
    77|   autoload :Head, "rack/head"
    78|   autoload :Lint, "rack/lint"
    79|   autoload :Lock, "rack/lock"
    80|   autoload :Logger, "rack/logger"
    81|   autoload :MediaType, "rack/media_type"
    82|   autoload :MethodOverride, "rack/method_override"
    83|   autoload :Mime, "rack/mime"
    84|   autoload :NullLogger, "rack/null_logger"
    85|   autoload :Recursive, "rack/recursive"
    86|   autoload :Reloader, "rack/reloader"
    87|   autoload :RewindableInput, "rack/rewindable_input"
    88|   autoload :Runtime, "rack/runtime"
    89|   autoload :Sendfile, "rack/sendfile"
    90|   autoload :Server, "rack/server"
    91|   autoload :ShowExceptions, "rack/show_exceptions"
    92|   autoload :ShowStatus, "rack/show_status"
    93|   autoload :Static, "rack/static"
    94|   autoload :TempfileReaper, "rack/tempfile_reaper"
    95|   autoload :URLMap, "rack/urlmap"
    96|   autoload :Utils, "rack/utils"
    97|   autoload :Multipart, "rack/multipart"
    98|   autoload :MockRequest, "rack/mock"
    99|   autoload :MockResponse, "rack/mock"
   100|   autoload :Request, "rack/request"
   101|   autoload :Response, "rack/response"
   102|   module Auth
   103|     autoload :Basic, "rack/auth/basic"
   104|     autoload :AbstractRequest, "rack/auth/abstract/request"
   105|     autoload :AbstractHandler, "rack/auth/abstract/handler"
   106|     module Digest
   107|       autoload :MD5, "rack/auth/digest/md5"
   108|       autoload :Nonce, "rack/auth/digest/nonce"
   109|       autoload :Params, "rack/auth/digest/params"
   110|       autoload :Request, "rack/auth/digest/request"
   111|     end
   112|   end
   113|   module Session
   114|     autoload :Cookie, "rack/session/cookie"
   115|     autoload :Pool, "rack/session/pool"
   116|     autoload :Memcache, "rack/session/memcache"
   117|   end
   118| end


# ====================================================================
# FILE: lib/rack/auth/abstract/request.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| module Rack
     2|   module Auth
     3|     class AbstractRequest
     4|       def initialize(env)
     5|         @env = env
     6|       end
     7|       def request
     8|         @request ||= Request.new(@env)
     9|       end
    10|       def provided?
    11|         !authorization_key.nil? && valid?
    12|       end
    13|       def valid?
    14|         !@env[authorization_key].nil?
    15|       end
    16|       def parts
    17|         @parts ||= @env[authorization_key].split(' ', 2)
    18|       end
    19|       def scheme
    20|         @scheme ||= parts.first && parts.first.downcase
    21|       end
    22|       def params
    23|         @params ||= parts.last
    24|       end
    25|       private
    26|       AUTHORIZATION_KEYS = ['HTTP_AUTHORIZATION', 'X-HTTP_AUTHORIZATION', 'X_HTTP_AUTHORIZATION']
    27|       def authorization_key
    28|         @authorization_key ||= AUTHORIZATION_KEYS.detect { |key| @env.has_key?(key) }
    29|       end
    30|     end
    31|   end
    32| end


# ====================================================================
# FILE: lib/rack/auth/basic.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| require_relative 'abstract/handler'
     2| require_relative 'abstract/request'
     3| require 'base64'
     4| module Rack
     5|   module Auth
     6|     class Basic < AbstractHandler
     7|       def call(env)
     8|         auth = Basic::Request.new(env)
     9|         return unauthorized unless auth.provided?
    10|         return bad_request unless auth.basic?
    11|         if valid?(auth)
    12|           env['REMOTE_USER'] = auth.username
    13|           return @app.call(env)
    14|         end
    15|         unauthorized
    16|       end
    17|       private
    18|       def challenge
    19|         'Basic realm="%s"' % realm
    20|       end
    21|       def valid?(auth)
    22|         @authenticator.call(*auth.credentials)
    23|       end
    24|       class Request < Auth::AbstractRequest
    25|         def basic?
    26|           "basic" == scheme && credentials.length == 2
    27|         end
    28|         def credentials
    29|           @credentials ||= Base64.decode64(params).split(':', 2)
    30|         end
    31|         def username
    32|           credentials.first
    33|         end
    34|       end
    35|     end
    36|   end
    37| end


# ====================================================================
# FILE: lib/rack/auth/digest/md5.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| require_relative '../abstract/handler'
     2| require_relative 'request'
     3| require_relative 'params'
     4| require_relative 'nonce'
     5| require 'digest/md5'
     6| module Rack
     7|   module Auth
     8|     module Digest
     9|       class MD5 < AbstractHandler
    10|         attr_accessor :opaque
    11|         attr_writer :passwords_hashed
    12|         def initialize(app, realm = nil, opaque = nil, &authenticator)
    13|           @passwords_hashed = nil
    14|           if opaque.nil? and realm.respond_to? :values_at
    15|             realm, opaque, @passwords_hashed = realm.values_at :realm, :opaque, :passwords_hashed
    16|           end
    17|           super(app, realm, &authenticator)
    18|           @opaque = opaque
    19|         end
    20|         def passwords_hashed?
    21|           !!@passwords_hashed
    22|         end
    23|         def call(env)
    24|           auth = Request.new(env)
    25|           unless auth.provided?
    26|             return unauthorized
    27|           end
    28|           if !auth.digest? || !auth.correct_uri? || !valid_qop?(auth)
    29|             return bad_request
    30|           end
    31|           if valid?(auth)
    32|             if auth.nonce.stale?
    33|               return unauthorized(challenge(stale: true))
    34|             else
    35|               env['REMOTE_USER'] = auth.username
    36|               return @app.call(env)
    37|             end
    38|           end
    39|           unauthorized
    40|         end
    41|         private
    42|         QOP = 'auth'
    43|         def params(hash = {})
    44|           Params.new do |params|
    45|             params['realm'] = realm
    46|             params['nonce'] = Nonce.new.to_s
    47|             params['opaque'] = H(opaque)
    48|             params['qop'] = QOP
    49|             hash.each { |k, v| params[k] = v }
    50|           end
    51|         end
    52|         def challenge(hash = {})
    53|           "Digest #{params(hash)}"
    54|         end
    55|         def valid?(auth)
    56|           valid_opaque?(auth) && valid_nonce?(auth) && valid_digest?(auth)
    57|         end
    58|         def valid_qop?(auth)
    59|           QOP == auth.qop
    60|         end
    61|         def valid_opaque?(auth)
    62|           H(opaque) == auth.opaque
    63|         end
    64|         def valid_nonce?(auth)
    65|           auth.nonce.valid?
    66|         end
    67|         def valid_digest?(auth)
    68|           pw = @authenticator.call(auth.username)
    69|           pw && Rack::Utils.secure_compare(digest(auth, pw), auth.response)
    70|         end
    71|         def md5(data)
    72|           ::Digest::MD5.hexdigest(data)
    73|         end
    74|         alias :H :md5
    75|         def KD(secret, data)
    76|           H "#{secret}:#{data}"
    77|         end
    78|         def A1(auth, password)
    79|           "#{auth.username}:#{auth.realm}:#{password}"
    80|         end
    81|         def A2(auth)
    82|           "#{auth.method}:#{auth.uri}"
    83|         end
    84|         def digest(auth, password)
    85|           password_hash = passwords_hashed? ? password : H(A1(auth, password))
    86|           KD password_hash, "#{auth.nonce}:#{auth.nc}:#{auth.cnonce}:#{QOP}:#{H A2(auth)}"
    87|         end
    88|       end
    89|     end
    90|   end
    91| end


# ====================================================================
# FILE: lib/rack/auth/digest/request.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| require_relative '../abstract/request'
     2| require_relative 'params'
     3| require_relative 'nonce'
     4| module Rack
     5|   module Auth
     6|     module Digest
     7|       class Request < Auth::AbstractRequest
     8|         def method
     9|           @env[RACK_METHODOVERRIDE_ORIGINAL_METHOD] || @env[REQUEST_METHOD]
    10|         end
    11|         def digest?
    12|           "digest" == scheme
    13|         end
    14|         def correct_uri?
    15|           request.fullpath == uri
    16|         end
    17|         def nonce
    18|           @nonce ||= Nonce.parse(params['nonce'])
    19|         end
    20|         def params
    21|           @params ||= Params.parse(parts.last)
    22|         end
    23|         def respond_to?(sym, *)
    24|           super or params.has_key? sym.to_s
    25|         end
    26|         def method_missing(sym, *args)
    27|           return super unless params.has_key?(key = sym.to_s)
    28|           return params[key] if args.size == 0
    29|           raise ArgumentError, "wrong number of arguments (#{args.size} for 0)"
    30|         end
    31|       end
    32|     end
    33|   end
    34| end


# ====================================================================
# FILE: lib/rack/body_proxy.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| module Rack
     2|   class BodyProxy
     3|     def initialize(body, &block)
     4|       @body = body
     5|       @block = block
     6|       @closed = false
     7|     end
     8|     def respond_to_missing?(method_name, include_all = false)
     9|       super or @body.respond_to?(method_name, include_all)
    10|     end
    11|     def close
    12|       return if @closed
    13|       @closed = true
    14|       begin
    15|         @body.close if @body.respond_to? :close
    16|       ensure
    17|         @block.call
    18|       end
    19|     end
    20|     def closed?
    21|       @closed
    22|     end
    23|     def method_missing(method_name, *args, &block)
    24|       @body.__send__(method_name, *args, &block)
    25|     end
    26|     ruby2_keywords(:method_missing) if respond_to?(:ruby2_keywords, true)
    27|   end
    28| end


# ====================================================================
# FILE: lib/rack/builder.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-76 ---
     1| module Rack
     2|   class Builder
     3|     UTF_8_BOM = '\xef\xbb\xbf'
     4|     def self.parse_file(config, opts = Server::Options.new)
     5|       if config.end_with?('.ru')
     6|         return self.load_file(config, opts)
     7|       else
     8|         require config
     9|         app = Object.const_get(::File.basename(config, '.rb').split('_').map(&:capitalize).join(''))
    10|         return app, {}
    11|       end
    12|     end
    13|     def self.load_file(path, opts = Server::Options.new)
    14|       options = {}
    15|       cfgfile = ::File.read(path)
    16|       cfgfile.slice!(/\A#{UTF_8_BOM}/) if cfgfile.encoding == Encoding::UTF_8
    17|       if cfgfile[/^#\\(.*)/] && opts
    18|         warn "Parsing options from the first comment line is deprecated!"
    19|         options = opts.parse! $1.split(/\s+/)
    20|       end
    21|       cfgfile.sub!(/^__END__\n.*\Z/m, '')
    22|       app = new_from_string cfgfile, path
    23|       return app, options
    24|     end
    25|     def self.new_from_string(builder_script, file = "(rackup)")
    26|       binding, builder = TOPLEVEL_BINDING.eval('Rack::Builder.new.instance_eval { [binding, self] }')
    27|       eval builder_script, binding, file
    28|       builder.to_app
    29|     end
    30|     def initialize(default_app = nil, &block)
    31|       @use, @map, @run, @warmup, @freeze_app = [], nil, default_app, nil, false
    32|       instance_eval(&block) if block_given?
    33|     end
    34|     def self.app(default_app = nil, &block)
    35|       self.new(default_app, &block).to_app
    36|     end
    37|     def use(middleware, *args, &block)
    38|       if @map
    39|         mapping, @map = @map, nil
    40|         @use << proc { |app| generate_map(app, mapping) }
    41|       end
    42|       @use << proc { |app| middleware.new(app, *args, &block) }
    43|     end
    44|     ruby2_keywords(:use) if respond_to?(:ruby2_keywords, true)
    45|     def run(app)
    46|       @run = app
    47|     end
    48|     def warmup(prc = nil, &block)
    49|       @warmup = prc || block
    50|     end
    51|     def map(path, &block)
    52|       @map ||= {}
    53|       @map[path] = block
    54|     end
    55|     def freeze_app
    56|       @freeze_app = true
    57|     end
    58|     def to_app
    59|       app = @map ? generate_map(@run, @map) : @run
    60|       fail "missing run or map statement" unless app
    61|       app.freeze if @freeze_app
    62|       app = @use.reverse.inject(app) { |a, e| e[a].tap { |x| x.freeze if @freeze_app } }
    63|       @warmup.call(app) if @warmup
    64|       app
    65|     end
    66|     def call(env)
    67|       to_app.call(env)
    68|     end
    69|     private
    70|     def generate_map(default_app, mapping)
    71|       mapped = default_app ? { '/' => default_app } : {}
    72|       mapping.each { |r, b| mapped[r] = self.class.new(default_app, &b).to_app }
    73|       URLMap.new(mapped)
    74|     end
    75|   end
    76| end


# ====================================================================
# FILE: lib/rack/cascade.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| module Rack
     2|   class Cascade
     3|     NotFound = [404, { CONTENT_TYPE => "text/plain" }, []]
     4|     attr_reader :apps
     5|     def initialize(apps, cascade_for = [404, 405])
     6|       @apps = []
     7|       apps.each { |app| add app }
     8|       @cascade_for = {}
     9|       [*cascade_for].each { |status| @cascade_for[status] = true }
    10|     end
    11|     def call(env)
    12|       return [404, { CONTENT_TYPE => "text/plain" }, []] if @apps.empty?
    13|       result = nil
    14|       last_body = nil
    15|       @apps.each do |app|
    16|         last_body.close if last_body.respond_to? :close
    17|         result = app.call(env)
    18|         return result unless @cascade_for.include?(result[0].to_i)
    19|         last_body = result[2]
    20|       end
    21|       result
    22|     end
    23|     def add(app)
    24|       @apps << app
    25|     end
    26|     def include?(app)
    27|       @apps.include?(app)
    28|     end
    29|     alias_method :<<, :add
    30|   end
    31| end


# ====================================================================
# FILE: lib/rack/chunked.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| module Rack
     2|   class Chunked
     3|     include Rack::Utils
     4|     class Body
     5|       TERM = "\r\n"
     6|       TAIL = "0#{TERM}"
     7|       def initialize(body)
     8|         @body = body
     9|       end
    10|       def each(&block)
    11|         term = TERM
    12|         @body.each do |chunk|
    13|           size = chunk.bytesize
    14|           next if size == 0
    15|           yield [size.to_s(16), term, chunk.b, term].join
    16|         end
    17|         yield TAIL
    18|         yield_trailers(&block)
    19|         yield term
    20|       end
    21|       def close
    22|         @body.close if @body.respond_to?(:close)
    23|       end
    24|       private
    25|       def yield_trailers
    26|       end
    27|     end
    28|     class TrailerBody < Body
    29|       private
    30|       def yield_trailers
    31|         @body.trailers.each_pair do |k, v|
    32|           yield "#{k}: #{v}\r\n"
    33|         end
    34|       end
    35|     end
    36|     def initialize(app)
    37|       @app = app
    38|     end
    39|     def chunkable_version?(ver)
    40|       case ver
    41|       when 'HTTP/1.0', nil, 'HTTP/0.9'
    42|         false
    43|       else
    44|         true
    45|       end
    46|     end
    47|     def call(env)
    48|       status, headers, body = @app.call(env)
    49|       headers = HeaderHash[headers]
    50|       if chunkable_version?(env[SERVER_PROTOCOL]) &&
    51|          !STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) &&
    52|          !headers[CONTENT_LENGTH] &&
    53|          !headers[TRANSFER_ENCODING]
    54|         headers[TRANSFER_ENCODING] = 'chunked'
    55|         if headers['Trailer']
    56|           body = TrailerBody.new(body)
    57|         else
    58|           body = Body.new(body)
    59|         end
    60|       end
    61|       [status, headers, body]
    62|     end
    63|   end
    64| end


# ====================================================================
# FILE: lib/rack/common_logger.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 10-42 ---
    10|       status, headers, body = @app.call(env)
    11|       headers = Utils::HeaderHash[headers]
    12|       body = BodyProxy.new(body) { log(env, status, headers, began_at) }
    13|       [status, headers, body]
    14|     end
    15|     private
    16|     def log(env, status, header, began_at)
    17|       length = extract_content_length(header)
    18|       msg = FORMAT % [
    19|         env['HTTP_X_FORWARDED_FOR'] || env["REMOTE_ADDR"] || "-",
    20|         env["REMOTE_USER"] || "-",
    21|         Time.now.strftime("%d/%b/%Y:%H:%M:%S %z"),
    22|         env[REQUEST_METHOD],
    23|         env[SCRIPT_NAME],
    24|         env[PATH_INFO],
    25|         env[QUERY_STRING].empty? ? "" : "?#{env[QUERY_STRING]}",
    26|         env[SERVER_PROTOCOL],
    27|         status.to_s[0..3],
    28|         length,
    29|         Utils.clock_time - began_at ]
    30|       logger = @logger || env[RACK_ERRORS]
    31|       if logger.respond_to?(:write)
    32|         logger.write(msg)
    33|       else
    34|         logger << msg
    35|       end
    36|     end
    37|     def extract_content_length(headers)
    38|       value = headers[CONTENT_LENGTH]
    39|       !value || value.to_s == '0' ? '-' : value
    40|     end
    41|   end
    42| end


# ====================================================================
# FILE: lib/rack/conditional_get.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| module Rack
     2|   class ConditionalGet
     3|     def initialize(app)
     4|       @app = app
     5|     end
     6|     def call(env)
     7|       case env[REQUEST_METHOD]
     8|       when "GET", "HEAD"
     9|         status, headers, body = @app.call(env)
    10|         headers = Utils::HeaderHash[headers]
    11|         if status == 200 && fresh?(env, headers)
    12|           status = 304
    13|           headers.delete(CONTENT_TYPE)
    14|           headers.delete(CONTENT_LENGTH)
    15|           original_body = body
    16|           body = Rack::BodyProxy.new([]) do
    17|             original_body.close if original_body.respond_to?(:close)
    18|           end
    19|         end
    20|         [status, headers, body]
    21|       else
    22|         @app.call(env)
    23|       end
    24|     end
    25|   private
    26|     def fresh?(env, headers)
    27|       if none_match = env['HTTP_IF_NONE_MATCH']
    28|         etag_matches?(none_match, headers)
    29|       elsif (modified_since = env['HTTP_IF_MODIFIED_SINCE']) && (modified_since = to_rfc2822(modified_since))
    30|         modified_since?(modified_since, headers)
    31|       end
    32|     end
    33|     def etag_matches?(none_match, headers)
    34|       headers['ETag'] == none_match
    35|     end
    36|     def modified_since?(modified_since, headers)
    37|       last_modified = to_rfc2822(headers['Last-Modified']) and
    38|         modified_since >= last_modified
    39|     end
    40|     def to_rfc2822(since)
    41|       if since && since.length >= 16
    42|         Time.rfc2822(since) rescue nil
    43|       end
    44|     end
    45|   end
    46| end


# ====================================================================
# FILE: lib/rack/content_length.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| module Rack
     2|   class ContentLength
     3|     include Rack::Utils
     4|     def initialize(app)
     5|       @app = app
     6|     end
     7|     def call(env)
     8|       status, headers, body = @app.call(env)
     9|       headers = HeaderHash[headers]
    10|       if !STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) &&
    11|          !headers[CONTENT_LENGTH] &&
    12|          !headers[TRANSFER_ENCODING]
    13|         obody = body
    14|         body, length = [], 0
    15|         obody.each { |part| body << part; length += part.bytesize }
    16|         body = BodyProxy.new(body) do
    17|           obody.close if obody.respond_to?(:close)
    18|         end
    19|         headers[CONTENT_LENGTH] = length.to_s
    20|       end
    21|       [status, headers, body]
    22|     end
    23|   end
    24| end


# ====================================================================
# FILE: lib/rack/content_type.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| module Rack
     2|   class ContentType
     3|     include Rack::Utils
     4|     def initialize(app, content_type = "text/html")
     5|       @app, @content_type = app, content_type
     6|     end
     7|     def call(env)
     8|       status, headers, body = @app.call(env)
     9|       headers = Utils::HeaderHash[headers]
    10|       unless STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i)
    11|         headers[CONTENT_TYPE] ||= @content_type
    12|       end
    13|       [status, headers, body]
    14|     end
    15|   end
    16| end


# ====================================================================
# FILE: lib/rack/deflater.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| require "zlib"
     2| require "time"  # for Time.httpdate
     3| module Rack
     4|   class Deflater
     5|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     6|     def initialize(app, options = {})
     7|       @app = app
     8|       @condition = options[:if]
     9|       @compressible_types = options[:include]
    10|       @sync = options.fetch(:sync, true)
    11|     end
    12|     def call(env)
    13|       status, headers, body = @app.call(env)
    14|       headers = Utils::HeaderHash[headers]
    15|       unless should_deflate?(env, status, headers, body)
    16|         return [status, headers, body]
    17|       end
    18|       request = Request.new(env)
    19|       encoding = Utils.select_best_encoding(%w(gzip identity),
    20|                                             request.accept_encoding)
    21|       vary = headers["Vary"].to_s.split(",").map(&:strip)
    22|       unless vary.include?("*") || vary.include?("Accept-Encoding")
    23|         headers["Vary"] = vary.push("Accept-Encoding").join(",")
    24|       end
    25|       case encoding
    26|       when "gzip"
    27|         headers['Content-Encoding'] = "gzip"
    28|         headers.delete(CONTENT_LENGTH)
    29|         mtime = headers["Last-Modified"]
    30|         mtime = Time.httpdate(mtime).to_i if mtime
    31|         [status, headers, GzipStream.new(body, mtime, @sync)]
    32|       when "identity"
    33|         [status, headers, body]
    34|       when nil
    35|         message = "An acceptable encoding for the requested resource #{request.fullpath} could not be found."
    36|         bp = Rack::BodyProxy.new([message]) { body.close if body.respond_to?(:close) }
    37|         [406, { CONTENT_TYPE => "text/plain", CONTENT_LENGTH => message.length.to_s }, bp]
    38|       end
    39|     end
    40|     class GzipStream
    41|       def initialize(body, mtime, sync)
    42|         @body = body
    43|         @mtime = mtime
    44|         @sync = sync
    45|       end
    46|       def each(&block)
    47|         @writer = block
    48|         gzip = ::Zlib::GzipWriter.new(self)
    49|         gzip.mtime = @mtime if @mtime
    50|         @body.each { |part|
    51|           next if part.empty?
    52|           gzip.write(part)
    53|           gzip.flush if @sync
    54|         }
    55|       ensure
    56|         gzip.close
    57|       end
    58|       def write(data)
    59|         @writer.call(data)
    60|       end
    61|       def close
    62|         @body.close if @body.respond_to?(:close)
    63|       end
    64|     end
    65|     private
    66|     def should_deflate?(env, status, headers, body)
    67|       if Utils::STATUS_WITH_NO_ENTITY_BODY.key?(status.to_i) ||
    68|           /\bno-transform\b/.match?(headers['Cache-Control'].to_s) ||
    69|           headers['Content-Encoding']&.!~(/\bidentity\b/)
    70|         return false
    71|       end
    72|       return false if @compressible_types && !(headers.has_key?('Content-Type') && @compressible_types.include?(headers['Content-Type'][/[^;]*/]))
    73|       return false if @condition && !@condition.call(env, status, headers, body)
    74|       return false if headers[CONTENT_LENGTH] == '0'
    75|       true
    76|     end
    77|   end
    78| end


# ====================================================================
# FILE: lib/rack/directory.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-142 ---
     1| require 'time'
     2| module Rack
     3|   class Directory
     4|     DIR_FILE = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>\n"
     5|     DIR_PAGE_HEADER = <<-PAGE
     6| <html><head>
     7|   <title>%s</title>
     8|   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
     9|   <style type='text/css'>
    10| table { width:100%%; }
    11| .name { text-align:left; }
    12| .size, .mtime { text-align:right; }
    13| .type { width:11em; }
    14| .mtime { width:15em; }
    15|   </style>
    16| </head><body>
    17| <h1>%s</h1>
    18| <hr />
    19| <table>
    20|   <tr>
    21|     <th class='name'>Name</th>
    22|     <th class='size'>Size</th>
    23|     <th class='type'>Type</th>
    24|     <th class='mtime'>Last Modified</th>
    25|   </tr>
    26|     PAGE
    27|     DIR_PAGE_FOOTER = <<-PAGE
    28| </table>
    29| <hr />
    30| </body></html>
    31|     PAGE
    32|     class DirectoryBody < Struct.new(:root, :path, :files)
    33|       def each
    34|         show_path = Utils.escape_html(path.sub(/^#{root}/, ''))
    35|         yield(DIR_PAGE_HEADER % [ show_path, show_path ])
    36|         unless path.chomp('/') == root
    37|           yield(DIR_FILE % DIR_FILE_escape(files.call('..')))
    38|         end
    39|         Dir.foreach(path) do |basename|
    40|           next if basename.start_with?('.')
    41|           next unless f = files.call(basename)
    42|           yield(DIR_FILE % DIR_FILE_escape(f))
    43|         end
    44|         yield(DIR_PAGE_FOOTER)
    45|       end
    46|       private
    47|       def DIR_FILE_escape(htmls)
    48|         htmls.map { |e| Utils.escape_html(e) }
    49|       end
    50|     end
    51|     attr_reader :root
    52|     def initialize(root, app = nil)
    53|       @root = ::File.expand_path(root)
    54|       @app = app || Files.new(@root)
    55|       @head = Head.new(method(:get))
    56|     end
    57|     def call(env)
    58|       @head.call env
    59|     end
    60|     def get(env)
    61|       script_name = env[SCRIPT_NAME]
    62|       path_info = Utils.unescape_path(env[PATH_INFO])
    63|       if client_error_response = check_bad_request(path_info) || check_forbidden(path_info)
    64|         client_error_response
    65|       else
    66|         path = ::File.join(@root, path_info)
    67|         list_path(env, path, path_info, script_name)
    68|       end
    69|     end
    70|     def check_bad_request(path_info)
    71|       return if Utils.valid_path?(path_info)
    72|       body = "Bad Request\n"
    73|       [400, { CONTENT_TYPE => "text/plain",
    74|         CONTENT_LENGTH => body.bytesize.to_s,
    75|         "X-Cascade" => "pass" }, [body]]
    76|     end
    77|     def check_forbidden(path_info)
    78|       return unless path_info.include? ".."
    79|       return if ::File.expand_path(::File.join(@root, path_info)).start_with?(@root)
    80|       body = "Forbidden\n"
    81|       [403, { CONTENT_TYPE => "text/plain",
    82|         CONTENT_LENGTH => body.bytesize.to_s,
    83|         "X-Cascade" => "pass" }, [body]]
    84|     end
    85|     def list_directory(path_info, path, script_name)
    86|       url_head = (script_name.split('/') + path_info.split('/')).map do |part|
    87|         Utils.escape_path part
    88|       end
    89|       body = DirectoryBody.new(@root, path, ->(basename) do
    90|         stat = stat(::File.join(path, basename))
    91|         next unless stat
    92|         url = ::File.join(*url_head + [Utils.escape_path(basename)])
    93|         mtime = stat.mtime.httpdate
    94|         if stat.directory?
    95|           type = 'directory'
    96|           size = '-'
    97|           url << '/'
    98|           if basename == '..'
    99|             basename = 'Parent Directory'
   100|           else
   101|             basename << '/'
   102|           end
   103|         else
   104|           type = Mime.mime_type(::File.extname(basename))
   105|           size = filesize_format(stat.size)
   106|         end
   107|         [ url, basename, size, type, mtime ]
   108|       end)
   109|       [ 200, { CONTENT_TYPE => 'text/html; charset=utf-8' }, body ]
   110|     end
   111|     def stat(path)
   112|       ::File.stat(path)
   113|     rescue Errno::ENOENT, Errno::ELOOP
   114|       return nil
   115|     end
   116|     def list_path(env, path, path_info, script_name)
   117|       if (stat = stat(path)) && stat.readable?
   118|         return @app.call(env) if stat.file?
   119|         return list_directory(path_info, path, script_name) if stat.directory?
   120|       end
   121|       entity_not_found(path_info)
   122|     end
   123|     def entity_not_found(path_info)
   124|       body = "Entity not found: #{path_info}\n"
   125|       [404, { CONTENT_TYPE => "text/plain",
   126|         CONTENT_LENGTH => body.bytesize.to_s,
   127|         "X-Cascade" => "pass" }, [body]]
   128|     end
   129|     FILESIZE_FORMAT = [
   130|       ['%.1fT', 1 << 40],
   131|       ['%.1fG', 1 << 30],
   132|       ['%.1fM', 1 << 20],
   133|       ['%.1fK', 1 << 10],
   134|     ]
   135|     def filesize_format(int)
   136|       FILESIZE_FORMAT.each do |format, size|
   137|         return format % (int.to_f / size) if int >= size
   138|       end
   139|       "#{int}B"
   140|     end
   141|   end
   142| end


# ====================================================================
# FILE: lib/rack/etag.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| require_relative '../rack'
     2| require 'digest/sha2'
     3| module Rack
     4|   class ETag
     5|     ETAG_STRING = Rack::ETAG
     6|     DEFAULT_CACHE_CONTROL = "max-age=0, private, must-revalidate"
     7|     def initialize(app, no_cache_control = nil, cache_control = DEFAULT_CACHE_CONTROL)
     8|       @app = app
     9|       @cache_control = cache_control
    10|       @no_cache_control = no_cache_control
    11|     end
    12|     def call(env)
    13|       status, headers, body = @app.call(env)
    14|       if etag_status?(status) && etag_body?(body) && !skip_caching?(headers)
    15|         original_body = body
    16|         digest, new_body = digest_body(body)
    17|         body = Rack::BodyProxy.new(new_body) do
    18|           original_body.close if original_body.respond_to?(:close)
    19|         end
    20|         headers[ETAG_STRING] = %(W/"#{digest}") if digest
    21|       end
    22|       unless headers[CACHE_CONTROL]
    23|         if digest
    24|           headers[CACHE_CONTROL] = @cache_control if @cache_control
    25|         else
    26|           headers[CACHE_CONTROL] = @no_cache_control if @no_cache_control
    27|         end
    28|       end
    29|       [status, headers, body]
    30|     end
    31|     private
    32|       def etag_status?(status)
    33|         status == 200 || status == 201
    34|       end
    35|       def etag_body?(body)
    36|         !body.respond_to?(:to_path)
    37|       end
    38|       def skip_caching?(headers)
    39|         headers.key?(ETAG_STRING) || headers.key?('Last-Modified')
    40|       end
    41|       def digest_body(body)
    42|         parts = []
    43|         digest = nil
    44|         body.each do |part|
    45|           parts << part
    46|           (digest ||= Digest::SHA256.new) << part unless part.empty?
    47|         end
    48|         [digest && digest.hexdigest.byteslice(0, 32), parts]
    49|       end
    50|   end
    51| end


# ====================================================================
# FILE: lib/rack/events.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| module Rack
     2|   class Events
     3|     module Abstract
     4|       def on_start(req, res)
     5|       end
     6|       def on_commit(req, res)
     7|       end
     8|       def on_send(req, res)
     9|       end
    10|       def on_finish(req, res)
    11|       end
    12|       def on_error(req, res, e)
    13|       end
    14|     end
    15|     class EventedBodyProxy < Rack::BodyProxy # :nodoc:
    16|       attr_reader :request, :response
    17|       def initialize(body, request, response, handlers, &block)
    18|         super(body, &block)
    19|         @request  = request
    20|         @response = response
    21|         @handlers = handlers
    22|       end
    23|       def each
    24|         @handlers.reverse_each { |handler| handler.on_send request, response }
    25|         super
    26|       end
    27|     end
    28|     class BufferedResponse < Rack::Response::Raw # :nodoc:
    29|       attr_reader :body
    30|       def initialize(status, headers, body)
    31|         super(status, headers)
    32|         @body = body
    33|       end
    34|       def to_a; [status, headers, body]; end
    35|     end
    36|     def initialize(app, handlers)
    37|       @app      = app
    38|       @handlers = handlers
    39|     end
    40|     def call(env)
    41|       request = make_request env
    42|       on_start request, nil
    43|       begin
    44|         status, headers, body = @app.call request.env
    45|         response = make_response status, headers, body
    46|         on_commit request, response
    47|       rescue StandardError => e
    48|         on_error request, response, e
    49|         on_finish request, response
    50|         raise
    51|       end
    52|       body = EventedBodyProxy.new(body, request, response, @handlers) do
    53|         on_finish request, response
    54|       end
    55|       [response.status, response.headers, body]
    56|     end
    57|     private
    58|     def on_error(request, response, e)
    59|       @handlers.reverse_each { |handler| handler.on_error request, response, e }
    60|     end
    61|     def on_commit(request, response)
    62|       @handlers.reverse_each { |handler| handler.on_commit request, response }
    63|     end
    64|     def on_start(request, response)
    65|       @handlers.each { |handler| handler.on_start request, nil }
    66|     end
    67|     def on_finish(request, response)
    68|       @handlers.reverse_each { |handler| handler.on_finish request, response }
    69|     end
    70|     def make_request(env)
    71|       Rack::Request.new env
    72|     end
    73|     def make_response(status, headers, body)
    74|       BufferedResponse.new status, headers, body
    75|     end
    76|   end
    77| end


# ====================================================================
# FILE: lib/rack/file.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| require_relative 'files'
     2| module Rack
     3|   File = Files
     4| end


# ====================================================================
# FILE: lib/rack/files.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-156 ---
     1| require 'time'
     2| module Rack
     3|   class Files
     4|     ALLOWED_VERBS = %w[GET HEAD OPTIONS]
     5|     ALLOW_HEADER = ALLOWED_VERBS.join(', ')
     6|     MULTIPART_BOUNDARY = 'AaB03x'
     7|     def self.method_added(name)
     8|       if name == :response_body
     9|         raise "#{self.class}\#response_body is no longer supported."
    10|       end
    11|       super
    12|     end
    13|     attr_reader :root
    14|     def initialize(root, headers = {}, default_mime = 'text/plain')
    15|       @root = (::File.expand_path(root) if root)
    16|       @headers = headers
    17|       @default_mime = default_mime
    18|       @head = Rack::Head.new(lambda { |env| get env })
    19|     end
    20|     def call(env)
    21|       @head.call env
    22|     end
    23|     def get(env)
    24|       request = Rack::Request.new env
    25|       unless ALLOWED_VERBS.include? request.request_method
    26|         return fail(405, "Method Not Allowed", { 'Allow' => ALLOW_HEADER })
    27|       end
    28|       path_info = Utils.unescape_path request.path_info
    29|       return fail(400, "Bad Request") unless Utils.valid_path?(path_info)
    30|       clean_path_info = Utils.clean_path_info(path_info)
    31|       path = ::File.join(@root, clean_path_info)
    32|       available = begin
    33|         ::File.file?(path) && ::File.readable?(path)
    34|       rescue SystemCallError
    35|         false
    36|       end
    37|       if available
    38|         serving(request, path)
    39|       else
    40|         fail(404, "File not found: #{path_info}")
    41|       end
    42|     end
    43|     def serving(request, path)
    44|       if request.options?
    45|         return [200, { 'Allow' => ALLOW_HEADER, CONTENT_LENGTH => '0' }, []]
    46|       end
    47|       last_modified = ::File.mtime(path).httpdate
    48|       return [304, {}, []] if request.get_header('HTTP_IF_MODIFIED_SINCE') == last_modified
    49|       headers = { "Last-Modified" => last_modified }
    50|       mime_type = mime_type path, @default_mime
    51|       headers[CONTENT_TYPE] = mime_type if mime_type
    52|       headers.merge!(@headers) if @headers
    53|       status = 200
    54|       size = filesize path
    55|       ranges = Rack::Utils.get_byte_ranges(request.get_header('HTTP_RANGE'), size)
    56|       if ranges.nil?
    57|         ranges = [0..size - 1]
    58|       elsif ranges.empty?
    59|         response = fail(416, "Byte range unsatisfiable")
    60|         response[1]["Content-Range"] = "bytes */#{size}"
    61|         return response
    62|       elsif ranges.size >= 1
    63|         partial_content = true
    64|         if ranges.size == 1
    65|           range = ranges[0]
    66|           headers["Content-Range"] = "bytes #{range.begin}-#{range.end}/#{size}"
    67|         else
    68|           headers[CONTENT_TYPE] = "multipart/byteranges; boundary=#{MULTIPART_BOUNDARY}"
    69|         end
    70|         status = 206
    71|         body = BaseIterator.new(path, ranges, mime_type: mime_type, size: size)
    72|         size = body.bytesize
    73|       end
    74|       headers[CONTENT_LENGTH] = size.to_s
    75|       if request.head?
    76|         body = []
    77|       elsif !partial_content
    78|         body = Iterator.new(path, ranges, mime_type: mime_type, size: size)
    79|       end
    80|       [status, headers, body]
    81|     end
    82|     class BaseIterator
    83|       attr_reader :path, :ranges, :options
    84|       def initialize(path, ranges, options)
    85|         @path = path
    86|         @ranges = ranges
    87|         @options = options
    88|       end
    89|       def each
    90|         ::File.open(path, "rb") do |file|
    91|           ranges.each do |range|
    92|             yield multipart_heading(range) if multipart?
    93|             each_range_part(file, range) do |part|
    94|               yield part
    95|             end
    96|           end
    97|           yield "\r\n--#{MULTIPART_BOUNDARY}--\r\n" if multipart?
    98|         end
    99|       end
   100|       def bytesize
   101|         size = ranges.inject(0) do |sum, range|
   102|           sum += multipart_heading(range).bytesize if multipart?
   103|           sum += range.size
   104|         end
   105|         size += "\r\n--#{MULTIPART_BOUNDARY}--\r\n".bytesize if multipart?
   106|         size
   107|       end
   108|       def close; end
   109|       private
   110|       def multipart?
   111|         ranges.size > 1
   112|       end
   113|       def multipart_heading(range)
   114| <<-EOF
   115| \r
   116| --#{MULTIPART_BOUNDARY}\r
   117| Content-Type: #{options[:mime_type]}\r
   118| Content-Range: bytes #{range.begin}-#{range.end}/#{options[:size]}\r
   119| \r
   120| EOF
   121|       end
   122|       def each_range_part(file, range)
   123|         file.seek(range.begin)
   124|         remaining_len = range.end - range.begin + 1
   125|         while remaining_len > 0
   126|           part = file.read([8192, remaining_len].min)
   127|           break unless part
   128|           remaining_len -= part.length
   129|           yield part
   130|         end
   131|       end
   132|     end
   133|     class Iterator < BaseIterator
   134|       alias :to_path :path
   135|     end
   136|     private
   137|     def fail(status, body, headers = {})
   138|       body += "\n"
   139|       [
   140|         status,
   141|         {
   142|           CONTENT_TYPE   => "text/plain",
   143|           CONTENT_LENGTH => body.size.to_s,
   144|           "X-Cascade" => "pass"
   145|         }.merge!(headers),
   146|         [body]
   147|       ]
   148|     end
   149|     def mime_type(path, default_mime)
   150|       Mime.mime_type(::File.extname(path), default_mime)
   151|     end
   152|     def filesize(path)
   153|       ::File.size?(path) || ::File.read(path).bytesize
   154|     end
   155|   end
   156| end


# ====================================================================
# FILE: lib/rack/handler/cgi.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| module Rack
     2|   module Handler
     3|     class CGI
     4|       def self.run(app, **options)
     5|         $stdin.binmode
     6|         serve app
     7|       end
     8|       def self.serve(app)
     9|         env = ENV.to_hash
    10|         env.delete "HTTP_CONTENT_LENGTH"
    11|         env[SCRIPT_NAME] = ""  if env[SCRIPT_NAME] == "/"
    12|         env.update(
    13|           RACK_VERSION      => Rack::VERSION,
    14|           RACK_INPUT        => Rack::RewindableInput.new($stdin),
    15|           RACK_ERRORS       => $stderr,
    16|           RACK_MULTITHREAD  => false,
    17|           RACK_MULTIPROCESS => true,
    18|           RACK_RUNONCE      => true,
    19|           RACK_URL_SCHEME   => ["yes", "on", "1"].include?(ENV[HTTPS]) ? "https" : "http"
    20|         )
    21|         env[QUERY_STRING] ||= ""
    22|         env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
    23|         env[REQUEST_PATH] ||= "/"
    24|         status, headers, body = app.call(env)
    25|         begin
    26|           send_headers status, headers
    27|           send_body body
    28|         ensure
    29|           body.close  if body.respond_to? :close
    30|         end
    31|       end
    32|       def self.send_headers(status, headers)
    33|         $stdout.print "Status: #{status}\r\n"
    34|         headers.each { |k, vs|
    35|           vs.split("\n").each { |v|
    36|             $stdout.print "#{k}: #{v}\r\n"
    37|           }
    38|         }
    39|         $stdout.print "\r\n"
    40|         $stdout.flush
    41|       end
    42|       def self.send_body(body)
    43|         body.each { |part|
    44|           $stdout.print part
    45|           $stdout.flush
    46|         }
    47|       end
    48|     end
    49|   end
    50| end


# ====================================================================
# FILE: lib/rack/handler/fastcgi.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| require 'fcgi'
     2| require 'socket'
     3| if defined? FCGI::Stream
     4|   class FCGI::Stream
     5|     alias _rack_read_without_buffer read
     6|     def read(n, buffer = nil)
     7|       buf = _rack_read_without_buffer n
     8|       buffer.replace(buf.to_s)  if buffer
     9|       buf
    10|     end
    11|   end
    12| end
    13| module Rack
    14|   module Handler
    15|     class FastCGI
    16|       def self.run(app, **options)
    17|         if options[:File]
    18|           STDIN.reopen(UNIXServer.new(options[:File]))
    19|         elsif options[:Port]
    20|           STDIN.reopen(TCPServer.new(options[:Host], options[:Port]))
    21|         end
    22|         FCGI.each { |request|
    23|           serve request, app
    24|         }
    25|       end
    26|       def self.valid_options
    27|         environment  = ENV['RACK_ENV'] || 'development'
    28|         default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
    29|         {
    30|           "Host=HOST" => "Hostname to listen on (default: #{default_host})",
    31|           "Port=PORT" => "Port to listen on (default: 8080)",
    32|           "File=PATH" => "Creates a Domain socket at PATH instead of a TCP socket. Ignores Host and Port if set.",
    33|         }
    34|       end
    35|       def self.serve(request, app)
    36|         env = request.env
    37|         env.delete "HTTP_CONTENT_LENGTH"
    38|         env[SCRIPT_NAME] = ""  if env[SCRIPT_NAME] == "/"
    39|         rack_input = RewindableInput.new(request.in)
    40|         env.update(
    41|           RACK_VERSION      => Rack::VERSION,
    42|           RACK_INPUT        => rack_input,
    43|           RACK_ERRORS       => request.err,
    44|           RACK_MULTITHREAD  => false,
    45|           RACK_MULTIPROCESS => true,
    46|           RACK_RUNONCE      => false,
    47|           RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http"
    48|         )
    49|         env[QUERY_STRING] ||= ""
    50|         env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
    51|         env[REQUEST_PATH] ||= "/"
    52|         env.delete "CONTENT_TYPE"  if env["CONTENT_TYPE"] == ""
    53|         env.delete "CONTENT_LENGTH"  if env["CONTENT_LENGTH"] == ""
    54|         begin
    55|           status, headers, body = app.call(env)
    56|           begin
    57|             send_headers request.out, status, headers
    58|             send_body request.out, body
    59|           ensure
    60|             body.close  if body.respond_to? :close
    61|           end
    62|         ensure
    63|           rack_input.close
    64|           request.finish
    65|         end
    66|       end
    67|       def self.send_headers(out, status, headers)
    68|         out.print "Status: #{status}\r\n"
    69|         headers.each { |k, vs|
    70|           vs.split("\n").each { |v|
    71|             out.print "#{k}: #{v}\r\n"
    72|           }
    73|         }
    74|         out.print "\r\n"
    75|         out.flush
    76|       end
    77|       def self.send_body(out, body)
    78|         body.each { |part|
    79|           out.print part
    80|           out.flush
    81|         }
    82|       end
    83|     end
    84|   end
    85| end


# ====================================================================
# FILE: lib/rack/handler/lsws.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| require 'lsapi'
     2| module Rack
     3|   module Handler
     4|     class LSWS
     5|       def self.run(app, **options)
     6|         while LSAPI.accept != nil
     7|           serve app
     8|         end
     9|       end
    10|       def self.serve(app)
    11|         env = ENV.to_hash
    12|         env.delete "HTTP_CONTENT_LENGTH"
    13|         env[SCRIPT_NAME] = "" if env[SCRIPT_NAME] == "/"
    14|         rack_input = RewindableInput.new($stdin.read.to_s)
    15|         env.update(
    16|           RACK_VERSION      => Rack::VERSION,
    17|           RACK_INPUT        => rack_input,
    18|           RACK_ERRORS       => $stderr,
    19|           RACK_MULTITHREAD  => false,
    20|           RACK_MULTIPROCESS => true,
    21|           RACK_RUNONCE      => false,
    22|           RACK_URL_SCHEME   => ["yes", "on", "1"].include?(ENV[HTTPS]) ? "https" : "http"
    23|         )
    24|         env[QUERY_STRING] ||= ""
    25|         env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
    26|         env[REQUEST_PATH] ||= "/"
    27|         status, headers, body = app.call(env)
    28|         begin
    29|           send_headers status, headers
    30|           send_body body
    31|         ensure
    32|           body.close if body.respond_to? :close
    33|         end
    34|       ensure
    35|         rack_input.close
    36|       end
    37|       def self.send_headers(status, headers)
    38|         print "Status: #{status}\r\n"
    39|         headers.each { |k, vs|
    40|           vs.split("\n").each { |v|
    41|             print "#{k}: #{v}\r\n"
    42|           }
    43|         }
    44|         print "\r\n"
    45|         STDOUT.flush
    46|       end
    47|       def self.send_body(body)
    48|         body.each { |part|
    49|           print part
    50|           STDOUT.flush
    51|         }
    52|       end
    53|     end
    54|   end
    55| end


# ====================================================================
# FILE: lib/rack/handler/scgi.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| require 'scgi'
     2| require 'stringio'
     3| module Rack
     4|   module Handler
     5|     class SCGI < ::SCGI::Processor
     6|       attr_accessor :app
     7|       def self.run(app, **options)
     8|         options[:Socket] = UNIXServer.new(options[:File]) if options[:File]
     9|         new(options.merge(app: app,
    10|                           host: options[:Host],
    11|                           port: options[:Port],
    12|                           socket: options[:Socket])).listen
    13|       end
    14|       def self.valid_options
    15|         environment  = ENV['RACK_ENV'] || 'development'
    16|         default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
    17|         {
    18|           "Host=HOST" => "Hostname to listen on (default: #{default_host})",
    19|           "Port=PORT" => "Port to listen on (default: 8080)",
    20|         }
    21|       end
    22|       def initialize(settings = {})
    23|         @app = settings[:app]
    24|         super(settings)
    25|       end
    26|       def process_request(request, input_body, socket)
    27|         env = Hash[request]
    28|         env.delete "HTTP_CONTENT_TYPE"
    29|         env.delete "HTTP_CONTENT_LENGTH"
    30|         env[REQUEST_PATH], env[QUERY_STRING] = env["REQUEST_URI"].split('?', 2)
    31|         env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
    32|         env[PATH_INFO] = env[REQUEST_PATH]
    33|         env[QUERY_STRING] ||= ""
    34|         env[SCRIPT_NAME] = ""
    35|         rack_input = StringIO.new(input_body)
    36|         rack_input.set_encoding(Encoding::BINARY)
    37|         env.update(
    38|           RACK_VERSION      => Rack::VERSION,
    39|           RACK_INPUT        => rack_input,
    40|           RACK_ERRORS       => $stderr,
    41|           RACK_MULTITHREAD  => true,
    42|           RACK_MULTIPROCESS => true,
    43|           RACK_RUNONCE      => false,
    44|           RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http"
    45|         )
    46|         status, headers, body = app.call(env)
    47|         begin
    48|           socket.write("Status: #{status}\r\n")
    49|           headers.each do |k, vs|
    50|             vs.split("\n").each { |v| socket.write("#{k}: #{v}\r\n")}
    51|           end
    52|           socket.write("\r\n")
    53|           body.each {|s| socket.write(s)}
    54|         ensure
    55|           body.close if body.respond_to? :close
    56|         end
    57|       end
    58|     end
    59|   end
    60| end


# ====================================================================
# FILE: lib/rack/handler/thin.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| require "thin"
     2| require "thin/server"
     3| require "thin/logging"
     4| require "thin/backends/tcp_server"
     5| module Rack
     6|   module Handler
     7|     class Thin
     8|       def self.run(app, **options)
     9|         environment  = ENV['RACK_ENV'] || 'development'
    10|         default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
    11|         if block_given?
    12|           host = options.delete(:Host) || default_host
    13|           port = options.delete(:Port) || 8080
    14|           args = [host, port, app, options]
    15|           args.pop if ::Thin::VERSION::MAJOR < 1 && ::Thin::VERSION::MINOR < 8
    16|           server = ::Thin::Server.new(*args)
    17|           yield server
    18|           server.start
    19|         else
    20|           options[:address] = options[:Host] || default_host
    21|           options[:port] = options[:Port] || 8080
    22|           ::Thin::Controllers::Controller.new(options).start
    23|         end
    24|       end
    25|       def self.valid_options
    26|         environment  = ENV['RACK_ENV'] || 'development'
    27|         default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
    28|         {
    29|           "Host=HOST" => "Hostname to listen on (default: #{default_host})",
    30|           "Port=PORT" => "Port to listen on (default: 8080)",
    31|         }
    32|       end
    33|     end
    34|   end
    35| end


# ====================================================================
# FILE: lib/rack/handler/webrick.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-105 ---
     1| require 'webrick'
     2| require 'stringio'
     3| class WEBrick::HTTPResponse
     4|   attr_accessor :rack
     5|   alias _rack_setup_header setup_header
     6|   def setup_header
     7|     app_chunking = rack && @header['transfer-encoding'] == 'chunked'
     8|     @chunked = app_chunking if app_chunking
     9|     _rack_setup_header
    10|     @chunked = false if app_chunking
    11|   end
    12| end
    13| module Rack
    14|   module Handler
    15|     class WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
    16|       def self.run(app, **options)
    17|         environment  = ENV['RACK_ENV'] || 'development'
    18|         default_host = environment == 'development' ? 'localhost' : nil
    19|         if !options[:BindAddress] || options[:Host]
    20|           options[:BindAddress] = options.delete(:Host) || default_host
    21|         end
    22|         options[:Port] ||= 8080
    23|         if options[:SSLEnable]
    24|           require 'webrick/https'
    25|         end
    26|         @server = ::WEBrick::HTTPServer.new(options)
    27|         @server.mount "/", Rack::Handler::WEBrick, app
    28|         yield @server  if block_given?
    29|         @server.start
    30|       end
    31|       def self.valid_options
    32|         environment  = ENV['RACK_ENV'] || 'development'
    33|         default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
    34|         {
    35|           "Host=HOST" => "Hostname to listen on (default: #{default_host})",
    36|           "Port=PORT" => "Port to listen on (default: 8080)",
    37|         }
    38|       end
    39|       def self.shutdown
    40|         if @server
    41|           @server.shutdown
    42|           @server = nil
    43|         end
    44|       end
    45|       def initialize(server, app)
    46|         super server
    47|         @app = app
    48|       end
    49|       def service(req, res)
    50|         res.rack = true
    51|         env = req.meta_vars
    52|         env.delete_if { |k, v| v.nil? }
    53|         rack_input = StringIO.new(req.body.to_s)
    54|         rack_input.set_encoding(Encoding::BINARY)
    55|         env.update(
    56|           RACK_VERSION      => Rack::VERSION,
    57|           RACK_INPUT        => rack_input,
    58|           RACK_ERRORS       => $stderr,
    59|           RACK_MULTITHREAD  => true,
    60|           RACK_MULTIPROCESS => false,
    61|           RACK_RUNONCE      => false,
    62|           RACK_URL_SCHEME   => ["yes", "on", "1"].include?(env[HTTPS]) ? "https" : "http",
    63|           RACK_IS_HIJACK    => true,
    64|           RACK_HIJACK       => lambda { raise NotImplementedError, "only partial hijack is supported."},
    65|           RACK_HIJACK_IO    => nil
    66|         )
    67|         env[HTTP_VERSION] ||= env[SERVER_PROTOCOL]
    68|         env[QUERY_STRING] ||= ""
    69|         unless env[PATH_INFO] == ""
    70|           path, n = req.request_uri.path, env[SCRIPT_NAME].length
    71|           env[PATH_INFO] = path[n, path.length - n]
    72|         end
    73|         env[REQUEST_PATH] ||= [env[SCRIPT_NAME], env[PATH_INFO]].join
    74|         status, headers, body = @app.call(env)
    75|         begin
    76|           res.status = status.to_i
    77|           io_lambda = nil
    78|           headers.each { |k, vs|
    79|             if k == RACK_HIJACK
    80|               io_lambda = vs
    81|             elsif k.downcase == "set-cookie"
    82|               res.cookies.concat vs.split("\n")
    83|             else
    84|               res[k] = vs.split("\n").join(", ")
    85|             end
    86|           }
    87|           if io_lambda
    88|             rd, wr = IO.pipe
    89|             res.body = rd
    90|             res.chunked = true
    91|             io_lambda.call wr
    92|           elsif body.respond_to?(:to_path)
    93|             res.body = ::File.open(body.to_path, 'rb')
    94|           else
    95|             body.each { |part|
    96|               res.body << part
    97|             }
    98|           end
    99|         ensure
   100|           body.close  if body.respond_to? :close
   101|         end
   102|       end
   103|     end
   104|   end
   105| end


# ====================================================================
# FILE: lib/rack/head.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| module Rack
     2|   class Head
     3|     def initialize(app)
     4|       @app = app
     5|     end
     6|     def call(env)
     7|       status, headers, body = @app.call(env)
     8|       if env[REQUEST_METHOD] == HEAD
     9|         [
    10|           status, headers, Rack::BodyProxy.new([]) do
    11|             body.close if body.respond_to? :close
    12|           end
    13|         ]
    14|       else
    15|         [status, headers, body]
    16|       end
    17|     end
    18|   end
    19| end


# ====================================================================
# FILE: lib/rack/lint.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 117-157 ---
   117|       }
   118|       env.each { |key, value|
   119|         next  if key.include? "."   # Skip extensions
   120|         assert("env variable #{key} has non-string value #{value.inspect}") {
   121|           value.kind_of? String
   122|         }
   123|         next if value.encoding == Encoding::ASCII_8BIT
   124|         assert("env variable #{key} has value containing non-ASCII characters and has non-ASCII-8BIT encoding #{value.inspect} encoding: #{value.encoding}") {
   125|           value.b !~ /[\x80-\xff]/n
   126|         }
   127|       }
   128|       assert("rack.version must be an Array, was #{env[RACK_VERSION].class}") {
   129|         env[RACK_VERSION].kind_of? Array
   130|       }
   131|       assert("rack.url_scheme unknown: #{env[RACK_URL_SCHEME].inspect}") {
   132|         %w[http https].include?(env[RACK_URL_SCHEME])
   133|       }
   134|       check_input env[RACK_INPUT]
   135|       check_error env[RACK_ERRORS]
   136|       check_hijack env
   137|       assert("REQUEST_METHOD unknown: #{env[REQUEST_METHOD]}") {
   138|         env[REQUEST_METHOD] =~ /\A[0-9A-Za-z!\#$%&'*+.^_`|~-]+\z/
   139|       }
   140|       assert("SCRIPT_NAME must start with /") {
   141|         !env.include?(SCRIPT_NAME) ||
   142|         env[SCRIPT_NAME] == "" ||
   143|         env[SCRIPT_NAME] =~ /\A\//
   144|       }
   145|       assert("PATH_INFO must start with /") {
   146|         !env.include?(PATH_INFO) ||
   147|         env[PATH_INFO] == "" ||
   148|         env[PATH_INFO] =~ /\A\//
   149|       }
   150|       assert("Invalid CONTENT_LENGTH: #{env["CONTENT_LENGTH"]}") {
   151|         !env.include?("CONTENT_LENGTH") || env["CONTENT_LENGTH"] =~ /\A\d+\z/
   152|       }
   153|       assert("One of SCRIPT_NAME or PATH_INFO must be set (make PATH_INFO '/' if SCRIPT_NAME is empty)") {
   154|         env[SCRIPT_NAME] || env[PATH_INFO]
   155|       }
   156|       assert("SCRIPT_NAME cannot be '/', make it '' and PATH_INFO '/'") {
   157|         env[SCRIPT_NAME] != "/"


# ====================================================================
# FILE: lib/rack/lobster.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| require 'zlib'
     2| module Rack
     3|   class Lobster
     4|     LobsterString = Zlib::Inflate.inflate("eJx9kEEOwyAMBO99xd7MAcytUhPlJyj2
     5|     P6jy9i4k9EQyGAnBarEXeCBqSkntNXsi/ZCvC48zGQoZKikGrFMZvgS5ZHd+aGWVuWwhVF0
     6|     t1drVmiR42HcWNz5w3QanT+2gIvTVCiE1lm1Y0eU4JGmIIbaKwextKn8rvW+p5PIwFl8ZWJ
     7|     I8jyiTlhTcYXkekJAzTyYN6E08A+dk8voBkAVTJQ==".delete("\n ").unpack("m*")[0])
     8|     LambdaLobster = lambda { |env|
     9|       if env[QUERY_STRING].include?("flip")
    10|         lobster = LobsterString.split("\n").
    11|           map { |line| line.ljust(42).reverse }.
    12|           join("\n")
    13|         href = "?"
    14|       else
    15|         lobster = LobsterString
    16|         href = "?flip"
    17|       end
    18|       content = ["<title>Lobstericious!</title>",
    19|                  "<pre>", lobster, "</pre>",
    20|                  "<a href='#{href}'>flip!</a>"]
    21|       length = content.inject(0) { |a, e| a + e.size }.to_s
    22|       [200, { CONTENT_TYPE => "text/html", CONTENT_LENGTH => length }, content]
    23|     }
    24|     def call(env)
    25|       req = Request.new(env)
    26|       if req.GET["flip"] == "left"
    27|         lobster = LobsterString.split("\n").map do |line|
    28|           line.ljust(42).reverse.
    29|             gsub('\\', 'TEMP').
    30|             gsub('/', '\\').
    31|             gsub('TEMP', '/').
    32|             gsub('{', '}').
    33|             gsub('(', ')')
    34|         end.join("\n")
    35|         href = "?flip=right"
    36|       elsif req.GET["flip"] == "crash"
    37|         raise "Lobster crashed"
    38|       else
    39|         lobster = LobsterString
    40|         href = "?flip=left"
    41|       end
    42|       res = Response.new
    43|       res.write "<title>Lobstericious!</title>"
    44|       res.write "<pre>"
    45|       res.write lobster
    46|       res.write "</pre>"
    47|       res.write "<p><a href='#{href}'>flip!</a></p>"
    48|       res.write "<p><a href='?flip=crash'>crash!</a></p>"
    49|       res.finish
    50|     end
    51|   end
    52| end
    53| if $0 == __FILE__
    54|   require_relative '../rack'
    55|   Rack::Server.start(
    56|     app: Rack::ShowExceptions.new(Rack::Lint.new(Rack::Lobster.new)), Port: 9292
    57|   )
    58| end


# ====================================================================
# FILE: lib/rack/lock.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| require 'thread'
     2| module Rack
     3|   class Lock
     4|     def initialize(app, mutex = Mutex.new)
     5|       @app, @mutex = app, mutex
     6|     end
     7|     def call(env)
     8|       @mutex.lock
     9|       @env = env
    10|       @old_rack_multithread = env[RACK_MULTITHREAD]
    11|       begin
    12|         response = @app.call(env.merge!(RACK_MULTITHREAD => false))
    13|         returned = response << BodyProxy.new(response.pop) { unlock }
    14|       ensure
    15|         unlock unless returned
    16|       end
    17|     end
    18|     private
    19|     def unlock
    20|       @mutex.unlock
    21|       @env[RACK_MULTITHREAD] = @old_rack_multithread
    22|     end
    23|   end
    24| end


# ====================================================================
# FILE: lib/rack/mock.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-182 ---
     1| require 'uri'
     2| require 'stringio'
     3| require_relative '../rack'
     4| require 'cgi/cookie'
     5| module Rack
     6|   class MockRequest
     7|     class FatalWarning < RuntimeError
     8|     end
     9|     class FatalWarner
    10|       def puts(warning)
    11|         raise FatalWarning, warning
    12|       end
    13|       def write(warning)
    14|         raise FatalWarning, warning
    15|       end
    16|       def flush
    17|       end
    18|       def string
    19|         ""
    20|       end
    21|     end
    22|     DEFAULT_ENV = {
    23|       RACK_VERSION      => Rack::VERSION,
    24|       RACK_INPUT        => StringIO.new,
    25|       RACK_ERRORS       => StringIO.new,
    26|       RACK_MULTITHREAD  => true,
    27|       RACK_MULTIPROCESS => true,
    28|       RACK_RUNONCE      => false,
    29|     }.freeze
    30|     def initialize(app)
    31|       @app = app
    32|     end
    33|     def get(uri, opts = {})     request(GET, uri, opts)     end
    34|     def post(uri, opts = {})    request(POST, uri, opts)    end
    35|     def put(uri, opts = {})     request(PUT, uri, opts)     end
    36|     def patch(uri, opts = {})   request(PATCH, uri, opts)   end
    37|     def delete(uri, opts = {})  request(DELETE, uri, opts)  end
    38|     def head(uri, opts = {})    request(HEAD, uri, opts)    end
    39|     def options(uri, opts = {}) request(OPTIONS, uri, opts) end
    40|     def request(method = GET, uri = "", opts = {})
    41|       env = self.class.env_for(uri, opts.merge(method: method))
    42|       if opts[:lint]
    43|         app = Rack::Lint.new(@app)
    44|       else
    45|         app = @app
    46|       end
    47|       errors = env[RACK_ERRORS]
    48|       status, headers, body = app.call(env)
    49|       MockResponse.new(status, headers, body, errors)
    50|     ensure
    51|       body.close if body.respond_to?(:close)
    52|     end
    53|     def self.parse_uri_rfc2396(uri)
    54|       @parser ||= URI::Parser.new
    55|       @parser.parse(uri)
    56|     end
    57|     def self.env_for(uri = "", opts = {})
    58|       uri = parse_uri_rfc2396(uri)
    59|       uri.path = "/#{uri.path}" unless uri.path[0] == ?/
    60|       env = DEFAULT_ENV.dup
    61|       env[REQUEST_METHOD]  = (opts[:method] ? opts[:method].to_s.upcase : GET).b
    62|       env[SERVER_NAME]     = (uri.host || "example.org").b
    63|       env[SERVER_PORT]     = (uri.port ? uri.port.to_s : "80").b
    64|       env[QUERY_STRING]    = (uri.query.to_s).b
    65|       env[PATH_INFO]       = ((!uri.path || uri.path.empty?) ? "/" : uri.path).b
    66|       env[RACK_URL_SCHEME] = (uri.scheme || "http").b
    67|       env[HTTPS]           = (env[RACK_URL_SCHEME] == "https" ? "on" : "off").b
    68|       env[SCRIPT_NAME] = opts[:script_name] || ""
    69|       if opts[:fatal]
    70|         env[RACK_ERRORS] = FatalWarner.new
    71|       else
    72|         env[RACK_ERRORS] = StringIO.new
    73|       end
    74|       if params = opts[:params]
    75|         if env[REQUEST_METHOD] == GET
    76|           params = Utils.parse_nested_query(params) if params.is_a?(String)
    77|           params.update(Utils.parse_nested_query(env[QUERY_STRING]))
    78|           env[QUERY_STRING] = Utils.build_nested_query(params)
    79|         elsif !opts.has_key?(:input)
    80|           opts["CONTENT_TYPE"] = "application/x-www-form-urlencoded"
    81|           if params.is_a?(Hash)
    82|             if data = Rack::Multipart.build_multipart(params)
    83|               opts[:input] = data
    84|               opts["CONTENT_LENGTH"] ||= data.length.to_s
    85|               opts["CONTENT_TYPE"] = "multipart/form-data; boundary=#{Rack::Multipart::MULTIPART_BOUNDARY}"
    86|             else
    87|               opts[:input] = Utils.build_nested_query(params)
    88|             end
    89|           else
    90|             opts[:input] = params
    91|           end
    92|         end
    93|       end
    94|       empty_str = String.new
    95|       opts[:input] ||= empty_str
    96|       if String === opts[:input]
    97|         rack_input = StringIO.new(opts[:input])
    98|       else
    99|         rack_input = opts[:input]
   100|       end
   101|       rack_input.set_encoding(Encoding::BINARY)
   102|       env[RACK_INPUT] = rack_input
   103|       env["CONTENT_LENGTH"] ||= env[RACK_INPUT].size.to_s if env[RACK_INPUT].respond_to?(:size)
   104|       opts.each { |field, value|
   105|         env[field] = value  if String === field
   106|       }
   107|       env
   108|     end
   109|   end
   110|   class MockResponse < Rack::Response
   111|     class << self
   112|       alias [] new
   113|     end
   114|     attr_reader :original_headers, :cookies
   115|     attr_accessor :errors
   116|     def initialize(status, headers, body, errors = StringIO.new(""))
   117|       @original_headers = headers
   118|       @errors           = errors.string if errors.respond_to?(:string)
   119|       @cookies = parse_cookies_from_header
   120|       super(body, status, headers)
   121|       buffered_body!
   122|     end
   123|     def =~(other)
   124|       body =~ other
   125|     end
   126|     def match(other)
   127|       body.match other
   128|     end
   129|     def body
   130|       buffer = String.new
   131|       super.each do |chunk|
   132|         buffer << chunk
   133|       end
   134|       return buffer
   135|     end
   136|     def empty?
   137|       [201, 204, 304].include? status
   138|     end
   139|     def cookie(name)
   140|       cookies.fetch(name, nil)
   141|     end
   142|     private
   143|     def parse_cookies_from_header
   144|       cookies = Hash.new
   145|       if original_headers.has_key? 'Set-Cookie'
   146|         set_cookie_header = original_headers.fetch('Set-Cookie')
   147|         set_cookie_header.split("\n").each do |cookie|
   148|           cookie_name, cookie_filling = cookie.split('=', 2)
   149|           cookie_attributes = identify_cookie_attributes cookie_filling
   150|           parsed_cookie = CGI::Cookie.new(
   151|             'name' => cookie_name.strip,
   152|             'value' => cookie_attributes.fetch('value'),
   153|             'path' => cookie_attributes.fetch('path', nil),
   154|             'domain' => cookie_attributes.fetch('domain', nil),
   155|             'expires' => cookie_attributes.fetch('expires', nil),
   156|             'secure' => cookie_attributes.fetch('secure', false)
   157|           )
   158|           cookies.store(cookie_name, parsed_cookie)
   159|         end
   160|       end
   161|       cookies
   162|     end
   163|     def identify_cookie_attributes(cookie_filling)
   164|       cookie_bits = cookie_filling.split(';')
   165|       cookie_attributes = Hash.new
   166|       cookie_attributes.store('value', cookie_bits[0].strip)
   167|       cookie_bits.each do |bit|
   168|         if bit.include? '='
   169|           cookie_attribute, attribute_value = bit.split('=')
   170|           cookie_attributes.store(cookie_attribute.strip, attribute_value.strip)
   171|           if cookie_attribute.include? 'max-age'
   172|             cookie_attributes.store('expires', Time.now + attribute_value.strip.to_i)
   173|           end
   174|         end
   175|         if bit.include? 'secure'
   176|           cookie_attributes.store('secure', true)
   177|         end
   178|       end
   179|       cookie_attributes
   180|     end
   181|   end
   182| end


# ====================================================================
# FILE: lib/rack/multipart.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| require_relative 'multipart/parser'
     2| module Rack
     3|   module Multipart
     4|     autoload :UploadedFile, 'rack/multipart/uploaded_file'
     5|     autoload :Generator, 'rack/multipart/generator'
     6|     EOL = "\r\n"
     7|     MULTIPART_BOUNDARY = "AaB03x"
     8|     MULTIPART = %r|\Amultipart/.*boundary=\"?([^\";,]+)\"?|ni
     9|     TOKEN = /[^\s()<>,;:\\"\/\[\]?=]+/
    10|     CONDISP = /Content-Disposition:\s*#{TOKEN}\s*/i
    11|     VALUE = /"(?:\\"|[^"])*"|#{TOKEN}/
    12|     BROKEN_QUOTED = /^#{CONDISP}.*;\s*filename="(.*?)"(?:\s*$|\s*;\s*#{TOKEN}=)/i
    13|     BROKEN_UNQUOTED = /^#{CONDISP}.*;\s*filename=(#{TOKEN})/i
    14|     MULTIPART_CONTENT_TYPE = /Content-Type: (.*)#{EOL}/ni
    15|     MULTIPART_CONTENT_DISPOSITION = /Content-Disposition:.*;\s*name=(#{VALUE})/ni
    16|     MULTIPART_CONTENT_ID = /Content-ID:\s*([^#{EOL}]*)/ni
    17|     ATTRIBUTE_CHAR = %r{[^ \t\v\n\r)(><@,;:\\"/\[\]?='*%]}
    18|     ATTRIBUTE = /#{ATTRIBUTE_CHAR}+/
    19|     SECTION = /\*[0-9]+/
    20|     REGULAR_PARAMETER_NAME = /#{ATTRIBUTE}#{SECTION}?/
    21|     REGULAR_PARAMETER = /(#{REGULAR_PARAMETER_NAME})=(#{VALUE})/
    22|     EXTENDED_OTHER_NAME = /#{ATTRIBUTE}\*[1-9][0-9]*\*/
    23|     EXTENDED_OTHER_VALUE = /%[0-9a-fA-F]{2}|#{ATTRIBUTE_CHAR}/
    24|     EXTENDED_OTHER_PARAMETER = /(#{EXTENDED_OTHER_NAME})=(#{EXTENDED_OTHER_VALUE}*)/
    25|     EXTENDED_INITIAL_NAME = /#{ATTRIBUTE}(?:\*0)?\*/
    26|     EXTENDED_INITIAL_VALUE = /[a-zA-Z0-9\-]*'[a-zA-Z0-9\-]*'#{EXTENDED_OTHER_VALUE}*/
    27|     EXTENDED_INITIAL_PARAMETER = /(#{EXTENDED_INITIAL_NAME})=(#{EXTENDED_INITIAL_VALUE})/
    28|     EXTENDED_PARAMETER = /#{EXTENDED_INITIAL_PARAMETER}|#{EXTENDED_OTHER_PARAMETER}/
    29|     DISPPARM = /;\s*(?:#{REGULAR_PARAMETER}|#{EXTENDED_PARAMETER})\s*/
    30|     RFC2183 = /^#{CONDISP}(#{DISPPARM})+$/i
    31|     class << self
    32|       def parse_multipart(env, params = Rack::Utils.default_query_parser)
    33|         extract_multipart Rack::Request.new(env), params


# ====================================================================
# FILE: lib/rack/multipart/generator.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| module Rack
     2|   module Multipart
     3|     class Generator
     4|       def initialize(params, first = true)
     5|         @params, @first = params, first
     6|         if @first && !@params.is_a?(Hash)
     7|           raise ArgumentError, "value must be a Hash"
     8|         end
     9|       end
    10|       def dump
    11|         return nil if @first && !multipart?
    12|         return flattened_params unless @first
    13|         flattened_params.map do |name, file|
    14|           if file.respond_to?(:original_filename)
    15|             if file.path
    16|               ::File.open(file.path, 'rb') do |f|
    17|                 f.set_encoding(Encoding::BINARY)
    18|                 content_for_tempfile(f, file, name)
    19|               end
    20|             else
    21|               content_for_tempfile(file, file, name)
    22|             end
    23|           else
    24|             content_for_other(file, name)
    25|           end
    26|         end.join << "--#{MULTIPART_BOUNDARY}--\r"
    27|       end
    28|       private
    29|       def multipart?
    30|         query = lambda { |value|
    31|           case value
    32|           when Array
    33|             value.any?(&query)
    34|           when Hash
    35|             value.values.any?(&query)
    36|           when Rack::Multipart::UploadedFile
    37|             true
    38|           end
    39|         }
    40|         @params.values.any?(&query)
    41|       end
    42|       def flattened_params
    43|         @flattened_params ||= begin
    44|           h = Hash.new
    45|           @params.each do |key, value|
    46|             k = @first ? key.to_s : "[#{key}]"
    47|             case value
    48|             when Array
    49|               value.map { |v|
    50|                 Multipart.build_multipart(v, false).each { |subkey, subvalue|
    51|                   h["#{k}[]#{subkey}"] = subvalue
    52|                 }
    53|               }
    54|             when Hash
    55|               Multipart.build_multipart(value, false).each { |subkey, subvalue|
    56|                 h[k + subkey] = subvalue
    57|               }
    58|             else
    59|               h[k] = value
    60|             end
    61|           end
    62|           h
    63|         end
    64|       end
    65|       def content_for_tempfile(io, file, name)
    66|         length = ::File.stat(file.path).size if file.path
    67|         filename = "; filename=\"#{Utils.escape(file.original_filename)}\"" if file.original_filename
    68| <<-EOF
    69| --#{MULTIPART_BOUNDARY}\r
    70| Content-Disposition: form-data; name="#{name}"#{filename}\r
    71| Content-Type: #{file.content_type}\r
    72| EOF
    73|       end
    74|       def content_for_other(file, name)
    75| <<-EOF
    76| --#{MULTIPART_BOUNDARY}\r
    77| Content-Disposition: form-data; name="#{name}"\r
    78| \r
    79| EOF
    80|       end
    81|     end
    82|   end
    83| end


# ====================================================================
# FILE: lib/rack/multipart/parser.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 220-261 ---
   220|       def full_boundary; @full_boundary; end
   221|       def consume_boundary
   222|         while read_buffer = @sbuf.scan_until(BOUNDARY_REGEX)
   223|           case read_buffer.strip
   224|           when full_boundary then return :BOUNDARY
   225|           when @end_boundary then return :END_BOUNDARY
   226|           end
   227|           return if @sbuf.eos?
   228|         end
   229|       end
   230|       def get_filename(head)
   231|         filename = nil
   232|         case head
   233|         when RFC2183
   234|           params = Hash[*head.scan(DISPPARM).flat_map(&:compact)]
   235|           if filename = params['filename']
   236|             filename = $1 if filename =~ /^"(.*)"$/
   237|           elsif filename = params['filename*']
   238|             encoding, _, filename = filename.split("'", 3)
   239|           end
   240|         when BROKEN_QUOTED, BROKEN_UNQUOTED
   241|           filename = $1
   242|         end
   243|         return unless filename
   244|         if filename.scan(/%.?.?/).all? { |s| /%[0-9a-fA-F]{2}/.match?(s) }
   245|           filename = Utils.unescape_path(filename)
   246|         end
   247|         filename.scrub!
   248|         if filename !~ /\\[^\\"]/
   249|           filename = filename.gsub(/\\(.)/, '\1')
   250|         end
   251|         if encoding
   252|           filename.force_encoding ::Encoding.find(encoding)
   253|         end
   254|         filename
   255|       end
   256|       CHARSET = "charset"
   257|       def tag_multipart_encoding(filename, content_type, name, body)
   258|         name = name.to_s
   259|         encoding = Encoding::UTF_8
   260|         name.force_encoding(encoding)
   261|         return if filename


# ====================================================================
# FILE: lib/rack/multipart/uploaded_file.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| module Rack
     2|   module Multipart
     3|     class UploadedFile
     4|       attr_reader :original_filename
     5|       attr_accessor :content_type
     6|       def initialize(filepath = nil, ct = "text/plain", bin = false,
     7|                      path: filepath, content_type: ct, binary: bin, filename: nil, io: nil)
     8|         if io
     9|           @tempfile = io
    10|           @original_filename = filename
    11|         else
    12|           raise "#{path} file does not exist" unless ::File.exist?(path)
    13|           @original_filename = filename || ::File.basename(path)
    14|           @tempfile = Tempfile.new([@original_filename, ::File.extname(path)], encoding: Encoding::BINARY)
    15|           @tempfile.binmode if binary
    16|           FileUtils.copy_file(path, @tempfile.path)
    17|         end
    18|         @content_type = content_type
    19|       end
    20|       def path
    21|         @tempfile.path if @tempfile.respond_to?(:path)
    22|       end
    23|       alias_method :local_path, :path
    24|       def respond_to?(*args)
    25|         super or @tempfile.respond_to?(*args)
    26|       end
    27|       def method_missing(method_name, *args, &block) #:nodoc:
    28|         @tempfile.__send__(method_name, *args, &block)
    29|       end
    30|     end
    31|   end
    32| end


# ====================================================================
# FILE: lib/rack/query_parser.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-142 ---
     1| module Rack
     2|   class QueryParser
     3|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     4|     DEFAULT_SEP = /[&;] */n
     5|     COMMON_SEP = { ";" => /[;] */n, ";," => /[;,] */n, "&" => /[&] */n }
     6|     class ParameterTypeError < TypeError; end
     7|     class InvalidParameterError < ArgumentError; end
     8|     def self.make_default(key_space_limit, param_depth_limit)
     9|       new Params, key_space_limit, param_depth_limit
    10|     end
    11|     attr_reader :key_space_limit, :param_depth_limit
    12|     def initialize(params_class, key_space_limit, param_depth_limit)
    13|       @params_class = params_class
    14|       @key_space_limit = key_space_limit
    15|       @param_depth_limit = param_depth_limit
    16|     end
    17|     def parse_query(qs, d = nil, &unescaper)
    18|       unescaper ||= method(:unescape)
    19|       params = make_params
    20|       (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|
    21|         next if p.empty?
    22|         k, v = p.split('=', 2).map!(&unescaper)
    23|         if cur = params[k]
    24|           if cur.class == Array
    25|             params[k] << v
    26|           else
    27|             params[k] = [cur, v]
    28|           end
    29|         else
    30|           params[k] = v
    31|         end
    32|       end
    33|       return params.to_h
    34|     end
    35|     def parse_nested_query(qs, d = nil)
    36|       params = make_params
    37|       unless qs.nil? || qs.empty?
    38|         (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|
    39|           k, v = p.split('=', 2).map! { |s| unescape(s) }
    40|           normalize_params(params, k, v, param_depth_limit)
    41|         end
    42|       end
    43|       return params.to_h
    44|     rescue ArgumentError => e
    45|       raise InvalidParameterError, e.message, e.backtrace
    46|     end
    47|     def normalize_params(params, name, v, depth)
    48|       raise RangeError if depth <= 0
    49|       name =~ %r(\A[\[\]]*([^\[\]]+)\]*)
    50|       k = $1 || ''
    51|       after = $' || ''
    52|       if k.empty?
    53|         if !v.nil? && name == "[]"
    54|           return Array(v)
    55|         else
    56|           return
    57|         end
    58|       end
    59|       if after == ''
    60|         params[k] = v
    61|       elsif after == "["
    62|         params[name] = v
    63|       elsif after == "[]"
    64|         params[k] ||= []
    65|         raise ParameterTypeError, "expected Array (got #{params[k].class.name}) for param `#{k}'" unless params[k].is_a?(Array)
    66|         params[k] << v
    67|       elsif after =~ %r(^\[\]\[([^\[\]]+)\]$) || after =~ %r(^\[\](.+)$)
    68|         child_key = $1
    69|         params[k] ||= []
    70|         raise ParameterTypeError, "expected Array (got #{params[k].class.name}) for param `#{k}'" unless params[k].is_a?(Array)
    71|         if params_hash_type?(params[k].last) && !params_hash_has_key?(params[k].last, child_key)
    72|           normalize_params(params[k].last, child_key, v, depth - 1)
    73|         else
    74|           params[k] << normalize_params(make_params, child_key, v, depth - 1)
    75|         end
    76|       else
    77|         params[k] ||= make_params
    78|         raise ParameterTypeError, "expected Hash (got #{params[k].class.name}) for param `#{k}'" unless params_hash_type?(params[k])
    79|         params[k] = normalize_params(params[k], after, v, depth - 1)
    80|       end
    81|       params
    82|     end
    83|     def make_params
    84|       @params_class.new @key_space_limit
    85|     end
    86|     def new_space_limit(key_space_limit)
    87|       self.class.new @params_class, key_space_limit, param_depth_limit
    88|     end
    89|     def new_depth_limit(param_depth_limit)
    90|       self.class.new @params_class, key_space_limit, param_depth_limit
    91|     end
    92|     private
    93|     def params_hash_type?(obj)
    94|       obj.kind_of?(@params_class)
    95|     end
    96|     def params_hash_has_key?(hash, key)
    97|       return false if /\[\]/.match?(key)
    98|       key.split(/[\[\]]+/).inject(hash) do |h, part|
    99|         next h if part == ''
   100|         return false unless params_hash_type?(h) && h.key?(part)
   101|         h[part]
   102|       end
   103|       true
   104|     end
   105|     def unescape(s)
   106|       Utils.unescape(s)
   107|     end
   108|     class Params
   109|       def initialize(limit)
   110|         @limit  = limit
   111|         @size   = 0
   112|         @params = {}
   113|       end
   114|       def [](key)
   115|         @params[key]
   116|       end
   117|       def []=(key, value)
   118|         @size += key.size if key && !@params.key?(key)
   119|         raise RangeError, 'exceeded available parameter key space' if @size > @limit
   120|         @params[key] = value
   121|       end
   122|       def key?(key)
   123|         @params.key?(key)
   124|       end
   125|       def to_h
   126|         @params.each do |key, value|
   127|           case value
   128|           when self
   129|             @params[key] = @params
   130|           when Params
   131|             @params[key] = value.to_h
   132|           when Array
   133|             value.map! { |v| v.kind_of?(Params) ? v.to_h : v }
   134|           else
   135|           end
   136|         end
   137|         @params
   138|       end
   139|       alias_method :to_params_hash, :to_h
   140|     end
   141|   end
   142| end


# ====================================================================
# FILE: lib/rack/recursive.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| require 'uri'
     2| module Rack
     3|   class ForwardRequest < Exception
     4|     attr_reader :url, :env
     5|     def initialize(url, env = {})
     6|       @url = URI(url)
     7|       @env = env
     8|       @env[PATH_INFO]       = @url.path
     9|       @env[QUERY_STRING]    = @url.query  if @url.query
    10|       @env[HTTP_HOST]       = @url.host   if @url.host
    11|       @env[HTTP_PORT]       = @url.port   if @url.port
    12|       @env[RACK_URL_SCHEME] = @url.scheme if @url.scheme
    13|       super "forwarding to #{url}"
    14|     end
    15|   end
    16|   class Recursive
    17|     def initialize(app)
    18|       @app = app
    19|     end
    20|     def call(env)
    21|       dup._call(env)
    22|     end
    23|     def _call(env)
    24|       @script_name = env[SCRIPT_NAME]
    25|       @app.call(env.merge(RACK_RECURSIVE_INCLUDE => method(:include)))
    26|     rescue ForwardRequest => req
    27|       call(env.merge(req.env))
    28|     end
    29|     def include(env, path)
    30|       unless path.index(@script_name) == 0 && (path[@script_name.size] == ?/ ||
    31|                                                path[@script_name.size].nil?)
    32|         raise ArgumentError, "can only include below #{@script_name}, not #{path}"
    33|       end
    34|       env = env.merge(PATH_INFO => path,
    35|                       SCRIPT_NAME => @script_name,
    36|                       REQUEST_METHOD => GET,
    37|                       "CONTENT_LENGTH" => "0", "CONTENT_TYPE" => "",
    38|                       RACK_INPUT => StringIO.new(""))
    39|       @app.call(env)
    40|     end
    41|   end
    42| end


# ====================================================================
# FILE: lib/rack/reloader.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| require 'pathname'
     2| module Rack
     3|   class Reloader
     4|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     5|     def initialize(app, cooldown = 10, backend = Stat)
     6|       @app = app
     7|       @cooldown = cooldown
     8|       @last = (Time.now - cooldown)
     9|       @cache = {}
    10|       @mtimes = {}
    11|       @reload_mutex = Mutex.new
    12|       extend backend
    13|     end
    14|     def call(env)
    15|       if @cooldown and Time.now > @last + @cooldown
    16|         if Thread.list.size > 1
    17|           @reload_mutex.synchronize{ reload! }
    18|         else
    19|           reload!
    20|         end
    21|         @last = Time.now
    22|       end
    23|       @app.call(env)
    24|     end
    25|     def reload!(stderr = $stderr)
    26|       rotation do |file, mtime|
    27|         previous_mtime = @mtimes[file] ||= mtime
    28|         safe_load(file, mtime, stderr) if mtime > previous_mtime
    29|       end
    30|     end
    31|     def safe_load(file, mtime, stderr = $stderr)
    32|       load(file)
    33|       stderr.puts "#{self.class}: reloaded `#{file}'"
    34|       file
    35|     rescue LoadError, SyntaxError => ex
    36|       stderr.puts ex
    37|     ensure
    38|       @mtimes[file] = mtime
    39|     end
    40|     module Stat
    41|       def rotation
    42|         files = [$0, *$LOADED_FEATURES].uniq
    43|         paths = ['./', *$LOAD_PATH].uniq
    44|         files.map{|file|
    45|           next if /\.(so|bundle)$/.match?(file) # cannot reload compiled files
    46|           found, stat = figure_path(file, paths)
    47|           next unless found && stat && mtime = stat.mtime
    48|           @cache[file] = found
    49|           yield(found, mtime)
    50|         }.compact
    51|       end
    52|       def figure_path(file, paths)
    53|         found = @cache[file]
    54|         found = file if !found and Pathname.new(file).absolute?
    55|         found, stat = safe_stat(found)
    56|         return found, stat if found
    57|         paths.find do |possible_path|
    58|           path = ::File.join(possible_path, file)
    59|           found, stat = safe_stat(path)
    60|           return ::File.expand_path(found), stat if found
    61|         end
    62|         return false, false
    63|       end
    64|       def safe_stat(file)
    65|         return unless file
    66|         stat = ::File.stat(file)
    67|         return file, stat if stat.file?
    68|       rescue Errno::ENOENT, Errno::ENOTDIR, Errno::ESRCH
    69|         @cache.delete(file) and false
    70|       end
    71|     end
    72|   end
    73| end


# ====================================================================
# FILE: lib/rack/request.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-407 ---
     1| module Rack
     2|   class Request
     3|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     4|     class << self
     5|       attr_accessor :ip_filter
     6|     end
     7|     self.ip_filter = lambda { |ip| /\A127\.0\.0\.1\Z|\A(10|172\.(1[6-9]|2[0-9]|30|31)|192\.168)\.|\A::1\Z|\Afd[0-9a-f]{2}:.+|\Alocalhost\Z|\Aunix\Z|\Aunix:/i.match?(ip) }
     8|     ALLOWED_SCHEMES = %w(https http).freeze
     9|     SCHEME_WHITELIST = ALLOWED_SCHEMES
    10|     if Object.respond_to?(:deprecate_constant)
    11|       deprecate_constant :SCHEME_WHITELIST
    12|     end
    13|     def initialize(env)
    14|       @params = nil
    15|       super(env)
    16|     end
    17|     def params
    18|       @params ||= super
    19|     end
    20|     def update_param(k, v)
    21|       super
    22|       @params = nil
    23|     end
    24|     def delete_param(k)
    25|       v = super
    26|       @params = nil
    27|       v
    28|     end
    29|     module Env
    30|       attr_reader :env
    31|       def initialize(env)
    32|         @env = env
    33|         super()
    34|       end
    35|       def has_header?(name)
    36|         @env.key? name
    37|       end
    38|       def get_header(name)
    39|         @env[name]
    40|       end
    41|       def fetch_header(name, &block)
    42|         @env.fetch(name, &block)
    43|       end
    44|       def each_header(&block)
    45|         @env.each(&block)
    46|       end
    47|       def set_header(name, v)
    48|         @env[name] = v
    49|       end
    50|       def add_header(key, v)
    51|         if v.nil?
    52|           get_header key
    53|         elsif has_header? key
    54|           set_header key, "#{get_header key},#{v}"
    55|         else
    56|           set_header key, v
    57|         end
    58|       end
    59|       def delete_header(name)
    60|         @env.delete name
    61|       end
    62|       def initialize_copy(other)
    63|         @env = other.env.dup
    64|       end
    65|     end
    66|     module Helpers
    67|       FORM_DATA_MEDIA_TYPES = [
    68|         'application/x-www-form-urlencoded',
    69|         'multipart/form-data'
    70|       ]
    71|       PARSEABLE_DATA_MEDIA_TYPES = [
    72|         'multipart/related',
    73|         'multipart/mixed'
    74|       ]
    75|       DEFAULT_PORTS = { 'http' => 80, 'https' => 443, 'coffee' => 80 }
    76|       HTTP_X_FORWARDED_FOR = 'HTTP_X_FORWARDED_FOR'
    77|       HTTP_X_FORWARDED_HOST = 'HTTP_X_FORWARDED_HOST'
    78|       HTTP_X_FORWARDED_SCHEME = 'HTTP_X_FORWARDED_SCHEME'
    79|       HTTP_X_FORWARDED_PROTO = 'HTTP_X_FORWARDED_PROTO'
    80|       HTTP_X_FORWARDED_PORT = 'HTTP_X_FORWARDED_PORT'
    81|       HTTP_X_FORWARDED_SSL = 'HTTP_X_FORWARDED_SSL'
    82|       def body;            get_header(RACK_INPUT)                         end
    83|       def script_name;     get_header(SCRIPT_NAME).to_s                   end
    84|       def script_name=(s); set_header(SCRIPT_NAME, s.to_s)                end
    85|       def path_info;       get_header(PATH_INFO).to_s                     end
    86|       def path_info=(s);   set_header(PATH_INFO, s.to_s)                  end
    87|       def request_method;  get_header(REQUEST_METHOD)                     end
    88|       def query_string;    get_header(QUERY_STRING).to_s                  end
    89|       def content_length;  get_header('CONTENT_LENGTH')                   end
    90|       def logger;          get_header(RACK_LOGGER)                        end
    91|       def user_agent;      get_header('HTTP_USER_AGENT')                  end
    92|       def multithread?;    get_header(RACK_MULTITHREAD)                   end
    93|       def referer;         get_header('HTTP_REFERER')                     end
    94|       alias referrer referer
    95|       def session
    96|         fetch_header(RACK_SESSION) do |k|
    97|           set_header RACK_SESSION, default_session
    98|         end
    99|       end
   100|       def session_options
   101|         fetch_header(RACK_SESSION_OPTIONS) do |k|
   102|           set_header RACK_SESSION_OPTIONS, {}
   103|         end
   104|       end
   105|       def delete?;  request_method == DELETE  end
   106|       def get?;     request_method == GET     end
   107|       def head?;    request_method == HEAD    end
   108|       def options?; request_method == OPTIONS end
   109|       def link?;    request_method == LINK    end
   110|       def patch?;   request_method == PATCH   end
   111|       def post?;    request_method == POST    end
   112|       def put?;     request_method == PUT     end
   113|       def trace?;   request_method == TRACE   end
   114|       def unlink?;  request_method == UNLINK  end
   115|       def scheme
   116|         if get_header(HTTPS) == 'on'
   117|           'https'
   118|         elsif get_header(HTTP_X_FORWARDED_SSL) == 'on'
   119|           'https'
   120|         elsif forwarded_scheme
   121|           forwarded_scheme
   122|         else
   123|           get_header(RACK_URL_SCHEME)
   124|         end
   125|       end
   126|       def authority
   127|         forwarded_authority || host_authority || server_authority
   128|       end
   129|       def server_authority
   130|         host = self.server_name
   131|         port = self.server_port
   132|         if host
   133|           if port
   134|             "#{host}:#{port}"
   135|           else
   136|             host
   137|           end
   138|         end
   139|       end
   140|       def server_name
   141|         get_header(SERVER_NAME)
   142|       end
   143|       def server_port
   144|         if port = get_header(SERVER_PORT)
   145|           Integer(port)
   146|         end
   147|       end
   148|       def cookies
   149|         hash = fetch_header(RACK_REQUEST_COOKIE_HASH) do |key|
   150|           set_header(key, {})
   151|         end
   152|         string = get_header(HTTP_COOKIE)
   153|         unless string == get_header(RACK_REQUEST_COOKIE_STRING)
   154|           hash.replace Utils.parse_cookies_header(string)
   155|           set_header(RACK_REQUEST_COOKIE_STRING, string)
   156|         end
   157|         hash
   158|       end
   159|       def content_type
   160|         content_type = get_header('CONTENT_TYPE')
   161|         content_type.nil? || content_type.empty? ? nil : content_type
   162|       end
   163|       def xhr?
   164|         get_header("HTTP_X_REQUESTED_WITH") == "XMLHttpRequest"
   165|       end
   166|       def host_authority
   167|         get_header(HTTP_HOST)
   168|       end
   169|       def host_with_port(authority = self.authority)
   170|         host, _, port = split_authority(authority)
   171|         if port == DEFAULT_PORTS[self.scheme]
   172|           host
   173|         else
   174|           authority
   175|         end
   176|       end
   177|       def host
   178|         split_authority(self.authority)[0]
   179|       end
   180|       def hostname
   181|         split_authority(self.authority)[1]
   182|       end
   183|       def port
   184|         if authority = self.authority
   185|           _, _, port = split_authority(self.authority)
   186|           if port
   187|             return port
   188|           end
   189|         end
   190|         if forwarded_port = self.forwarded_port
   191|           return forwarded_port.first
   192|         end
   193|         if scheme = self.scheme
   194|           if port = DEFAULT_PORTS[self.scheme]
   195|             return port
   196|           end
   197|         end
   198|         self.server_port
   199|       end
   200|       def forwarded_for
   201|         if value = get_header(HTTP_X_FORWARDED_FOR)
   202|           split_header(value).map do |authority|
   203|             split_authority(wrap_ipv6(authority))[1]
   204|           end
   205|         end
   206|       end
   207|       def forwarded_port
   208|         if value = get_header(HTTP_X_FORWARDED_PORT)
   209|           split_header(value).map(&:to_i)
   210|         end
   211|       end
   212|       def forwarded_authority
   213|         if value = get_header(HTTP_X_FORWARDED_HOST)
   214|           wrap_ipv6(split_header(value).first)
   215|         end
   216|       end
   217|       def ssl?
   218|         scheme == 'https' || scheme == 'wss'
   219|       end
   220|       def ip
   221|         remote_addrs = split_header(get_header('REMOTE_ADDR'))
   222|         remote_addrs = reject_trusted_ip_addresses(remote_addrs)
   223|         if remote_addrs.any?
   224|           remote_addrs.first
   225|         else
   226|           forwarded_ips = self.forwarded_for
   227|           reject_trusted_ip_addresses(forwarded_ips).last || forwarded_ips.first || get_header("REMOTE_ADDR")
   228|         end
   229|       end
   230|       def media_type
   231|         MediaType.type(content_type)
   232|       end
   233|       def media_type_params
   234|         MediaType.params(content_type)
   235|       end
   236|       def content_charset
   237|         media_type_params['charset']
   238|       end
   239|       def form_data?
   240|         type = media_type
   241|         meth = get_header(RACK_METHODOVERRIDE_ORIGINAL_METHOD) || get_header(REQUEST_METHOD)
   242|         (meth == POST && type.nil?) || FORM_DATA_MEDIA_TYPES.include?(type)
   243|       end
   244|       def parseable_data?
   245|         PARSEABLE_DATA_MEDIA_TYPES.include?(media_type)
   246|       end
   247|       def GET
   248|         if get_header(RACK_REQUEST_QUERY_STRING) == query_string
   249|           get_header(RACK_REQUEST_QUERY_HASH)
   250|         else
   251|           query_hash = parse_query(query_string, '&;')
   252|           set_header(RACK_REQUEST_QUERY_STRING, query_string)
   253|           set_header(RACK_REQUEST_QUERY_HASH, query_hash)
   254|         end
   255|       end
   256|       def POST
   257|         if get_header(RACK_INPUT).nil?
   258|           raise "Missing rack.input"
   259|         elsif get_header(RACK_REQUEST_FORM_INPUT) == get_header(RACK_INPUT)
   260|           get_header(RACK_REQUEST_FORM_HASH)
   261|         elsif form_data? || parseable_data?
   262|           unless set_header(RACK_REQUEST_FORM_HASH, parse_multipart)
   263|             form_vars = get_header(RACK_INPUT).read
   264|             form_vars.slice!(-1) if form_vars.end_with?("\0")
   265|             set_header RACK_REQUEST_FORM_VARS, form_vars
   266|             set_header RACK_REQUEST_FORM_HASH, parse_query(form_vars, '&')
   267|             get_header(RACK_INPUT).rewind
   268|           end
   269|           set_header RACK_REQUEST_FORM_INPUT, get_header(RACK_INPUT)
   270|           get_header RACK_REQUEST_FORM_HASH
   271|         else
   272|           {}
   273|         end
   274|       end
   275|       def params
   276|         self.GET.merge(self.POST)
   277|       end
   278|       def update_param(k, v)
   279|         found = false
   280|         if self.GET.has_key?(k)
   281|           found = true
   282|           self.GET[k] = v
   283|         end
   284|         if self.POST.has_key?(k)
   285|           found = true
   286|           self.POST[k] = v
   287|         end
   288|         unless found
   289|           self.GET[k] = v
   290|         end
   291|       end
   292|       def delete_param(k)
   293|         post_value, get_value = self.POST.delete(k), self.GET.delete(k)
   294|         post_value || get_value
   295|       end
   296|       def base_url
   297|         "#{scheme}://#{host_with_port}"
   298|       end
   299|       def url
   300|         base_url + fullpath
   301|       end
   302|       def path
   303|         script_name + path_info
   304|       end
   305|       def fullpath
   306|         query_string.empty? ? path : "#{path}?#{query_string}"
   307|       end
   308|       def accept_encoding
   309|         parse_http_accept_header(get_header("HTTP_ACCEPT_ENCODING"))
   310|       end
   311|       def accept_language
   312|         parse_http_accept_header(get_header("HTTP_ACCEPT_LANGUAGE"))
   313|       end
   314|       def trusted_proxy?(ip)
   315|         Rack::Request.ip_filter.call(ip)
   316|       end
   317|       def [](key)
   318|         if $VERBOSE
   319|           warn("Request#[] is deprecated and will be removed in a future version of Rack. Please use request.params[] instead")
   320|         end
   321|         params[key.to_s]
   322|       end
   323|       def []=(key, value)
   324|         if $VERBOSE
   325|           warn("Request#[]= is deprecated and will be removed in a future version of Rack. Please use request.params[]= instead")
   326|         end
   327|         params[key.to_s] = value
   328|       end
   329|       def values_at(*keys)
   330|         keys.map { |key| params[key] }
   331|       end
   332|       private
   333|       def default_session; {}; end
   334|       def wrap_ipv6(host)
   335|         if !host.start_with?('[') && host.count(':') > 1
   336|           "[#{host}]"
   337|         else
   338|           host
   339|         end
   340|       end
   341|       def parse_http_accept_header(header)
   342|         header.to_s.split(/\s*,\s*/).map do |part|
   343|           attribute, parameters = part.split(/\s*;\s*/, 2)
   344|           quality = 1.0
   345|           if parameters and /\Aq=([\d.]+)/ =~ parameters
   346|             quality = $1.to_f
   347|           end
   348|           [attribute, quality]
   349|         end
   350|       end
   351|       def query_parser
   352|         Utils.default_query_parser
   353|       end
   354|       def parse_query(qs, d = '&')
   355|         query_parser.parse_nested_query(qs, d)
   356|       end
   357|       def parse_multipart
   358|         Rack::Multipart.extract_multipart(self, query_parser)
   359|       end
   360|       def split_header(value)
   361|         value ? value.strip.split(/[,\s]+/) : []
   362|       end
   363|       AUTHORITY = /
   364|         (?<host>
   365|           (\[(?<ip6>.*)\])
   366|           |
   367|           (?<ip4>[\d\.]+)
   368|           |
   369|           (?<name>[a-zA-Z0-9\.\-]+)
   370|         )
   371|         (:(?<port>\d+))?
   372|       /x
   373|       private_constant :AUTHORITY
   374|       def split_authority(authority)
   375|         if match = AUTHORITY.match(authority)
   376|           if address = match[:ip6]
   377|             return match[:host], address, match[:port]&.to_i
   378|           else
   379|             return match[:host], match[:host], match[:port]&.to_i
   380|           end
   381|         end
   382|         return authority, authority, nil
   383|       end
   384|       def reject_trusted_ip_addresses(ip_addresses)
   385|         ip_addresses.reject { |ip| trusted_proxy?(ip) }
   386|       end
   387|       def forwarded_scheme
   388|         allowed_scheme(get_header(HTTP_X_FORWARDED_SCHEME)) ||
   389|         allowed_scheme(extract_proto_header(get_header(HTTP_X_FORWARDED_PROTO)))
   390|       end
   391|       def allowed_scheme(header)
   392|         header if ALLOWED_SCHEMES.include?(header)
   393|       end
   394|       def extract_proto_header(header)
   395|         if header
   396|           if (comma_index = header.index(','))
   397|             header[0, comma_index]
   398|           else
   399|             header
   400|           end
   401|         end
   402|       end
   403|     end
   404|     include Env
   405|     include Helpers
   406|   end
   407| end


# ====================================================================
# FILE: lib/rack/response.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-210 ---
     1| require 'time'
     2| module Rack
     3|   class Response
     4|     def self.[](status, headers, body)
     5|       self.new(body, status, headers)
     6|     end
     7|     CHUNKED = 'chunked'
     8|     STATUS_WITH_NO_ENTITY_BODY = Utils::STATUS_WITH_NO_ENTITY_BODY
     9|     attr_accessor :length, :status, :body
    10|     attr_reader :headers
    11|     alias header headers
    12|     def initialize(body = nil, status = 200, headers = {})
    13|       @status = status.to_i
    14|       @headers = Utils::HeaderHash[headers]
    15|       @writer = self.method(:append)
    16|       @block = nil
    17|       if body.nil?
    18|         @body = []
    19|         @buffered = true
    20|         @length = 0
    21|       elsif body.respond_to?(:to_str)
    22|         @body = [body]
    23|         @buffered = true
    24|         @length = body.to_str.bytesize
    25|       else
    26|         @body = body
    27|         @buffered = false
    28|         @length = 0
    29|       end
    30|       yield self if block_given?
    31|     end
    32|     def redirect(target, status = 302)
    33|       self.status = status
    34|       self.location = target
    35|     end
    36|     def chunked?
    37|       CHUNKED == get_header(TRANSFER_ENCODING)
    38|     end
    39|     def finish(&block)
    40|       if STATUS_WITH_NO_ENTITY_BODY[status.to_i]
    41|         delete_header CONTENT_TYPE
    42|         delete_header CONTENT_LENGTH
    43|         close
    44|         return [@status, @headers, []]
    45|       else
    46|         if block_given?
    47|           @block = block
    48|           return [@status, @headers, self]
    49|         else
    50|           return [@status, @headers, @body]
    51|         end
    52|       end
    53|     end
    54|     alias to_a finish           # For *response
    55|     def each(&callback)
    56|       @body.each(&callback)
    57|       @buffered = true
    58|       if @block
    59|         @writer = callback
    60|         @block.call(self)
    61|       end
    62|     end
    63|     def write(chunk)
    64|       buffered_body!
    65|       @writer.call(chunk.to_s)
    66|     end
    67|     def close
    68|       @body.close if @body.respond_to?(:close)
    69|     end
    70|     def empty?
    71|       @block == nil && @body.empty?
    72|     end
    73|     def has_header?(key);   headers.key? key;   end
    74|     def get_header(key);    headers[key];       end
    75|     def set_header(key, v); headers[key] = v;   end
    76|     def delete_header(key); headers.delete key; end
    77|     alias :[] :get_header
    78|     alias :[]= :set_header
    79|     module Helpers
    80|       def invalid?;             status < 100 || status >= 600;        end
    81|       def informational?;       status >= 100 && status < 200;        end
    82|       def successful?;          status >= 200 && status < 300;        end
    83|       def redirection?;         status >= 300 && status < 400;        end
    84|       def client_error?;        status >= 400 && status < 500;        end
    85|       def server_error?;        status >= 500 && status < 600;        end
    86|       def ok?;                  status == 200;                        end
    87|       def created?;             status == 201;                        end
    88|       def accepted?;            status == 202;                        end
    89|       def no_content?;          status == 204;                        end
    90|       def moved_permanently?;   status == 301;                        end
    91|       def bad_request?;         status == 400;                        end
    92|       def unauthorized?;        status == 401;                        end
    93|       def forbidden?;           status == 403;                        end
    94|       def not_found?;           status == 404;                        end
    95|       def method_not_allowed?;  status == 405;                        end
    96|       def precondition_failed?; status == 412;                        end
    97|       def unprocessable?;       status == 422;                        end
    98|       def redirect?;            [301, 302, 303, 307, 308].include? status; end
    99|       def include?(header)
   100|         has_header? header
   101|       end
   102|       def add_header(key, v)
   103|         if v.nil?
   104|           get_header key
   105|         elsif has_header? key
   106|           set_header key, "#{get_header key},#{v}"
   107|         else
   108|           set_header key, v
   109|         end
   110|       end
   111|       def content_type
   112|         get_header CONTENT_TYPE
   113|       end
   114|       def content_type=(content_type)
   115|         set_header CONTENT_TYPE, content_type
   116|       end
   117|       def media_type
   118|         MediaType.type(content_type)
   119|       end
   120|       def media_type_params
   121|         MediaType.params(content_type)
   122|       end
   123|       def content_length
   124|         cl = get_header CONTENT_LENGTH
   125|         cl ? cl.to_i : cl
   126|       end
   127|       def location
   128|         get_header "Location"
   129|       end
   130|       def location=(location)
   131|         set_header "Location", location
   132|       end
   133|       def set_cookie(key, value)
   134|         cookie_header = get_header SET_COOKIE
   135|         set_header SET_COOKIE, ::Rack::Utils.add_cookie_to_header(cookie_header, key, value)
   136|       end
   137|       def delete_cookie(key, value = {})
   138|         set_header SET_COOKIE, ::Rack::Utils.add_remove_cookie_to_header(get_header(SET_COOKIE), key, value)
   139|       end
   140|       def set_cookie_header
   141|         get_header SET_COOKIE
   142|       end
   143|       def set_cookie_header=(v)
   144|         set_header SET_COOKIE, v
   145|       end
   146|       def cache_control
   147|         get_header CACHE_CONTROL
   148|       end
   149|       def cache_control=(v)
   150|         set_header CACHE_CONTROL, v
   151|       end
   152|       def do_not_cache!
   153|         set_header CACHE_CONTROL, "no-cache, must-revalidate"
   154|         set_header EXPIRES, Time.now.httpdate
   155|       end
   156|       def cache!(duration = 3600, directive: "public")
   157|         unless headers[CACHE_CONTROL] =~ /no-cache/
   158|           set_header CACHE_CONTROL, "#{directive}, max-age=#{duration}"
   159|           set_header EXPIRES, (Time.now + duration).httpdate
   160|         end
   161|       end
   162|       def etag
   163|         get_header ETAG
   164|       end
   165|       def etag=(v)
   166|         set_header ETAG, v
   167|       end
   168|     protected
   169|       def buffered_body!
   170|         return if @buffered
   171|         if @body.is_a?(Array)
   172|           @body = @body.compact
   173|           @body.each do |part|
   174|             @length += part.to_s.bytesize
   175|           end
   176|         else
   177|           body = @body
   178|           @body = Array.new
   179|           body.each do |part|
   180|             @writer.call(part.to_s)
   181|           end
   182|           body.close if body.respond_to?(:close)
   183|         end
   184|         @buffered = true
   185|       end
   186|       def append(chunk)
   187|         @body << chunk
   188|         unless chunked?
   189|           @length += chunk.bytesize
   190|           set_header(CONTENT_LENGTH, @length.to_s)
   191|         end
   192|         return chunk
   193|       end
   194|     end
   195|     include Helpers
   196|     class Raw
   197|       include Helpers
   198|       attr_reader :headers
   199|       attr_accessor :status
   200|       def initialize(status, headers)
   201|         @status = status
   202|         @headers = headers
   203|       end
   204|       def has_header?(key);   headers.key? key;   end
   205|       def get_header(key);    headers[key];       end
   206|       def set_header(key, v); headers[key] = v;   end
   207|       def delete_header(key); headers.delete key; end
   208|     end
   209|   end
   210| end


# ====================================================================
# FILE: lib/rack/rewindable_input.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| require 'tempfile'
     2| module Rack
     3|   class RewindableInput
     4|     def initialize(io)
     5|       @io = io
     6|       @rewindable_io = nil
     7|       @unlinked = false
     8|     end
     9|     def gets
    10|       make_rewindable unless @rewindable_io
    11|       @rewindable_io.gets
    12|     end
    13|     def read(*args)
    14|       make_rewindable unless @rewindable_io
    15|       @rewindable_io.read(*args)
    16|     end
    17|     def each(&block)
    18|       make_rewindable unless @rewindable_io
    19|       @rewindable_io.each(&block)
    20|     end
    21|     def rewind
    22|       make_rewindable unless @rewindable_io
    23|       @rewindable_io.rewind
    24|     end
    25|     def close
    26|       if @rewindable_io
    27|         if @unlinked
    28|           @rewindable_io.close
    29|         else
    30|           @rewindable_io.close!
    31|         end
    32|         @rewindable_io = nil
    33|       end
    34|     end
    35|     private
    36|     def make_rewindable
    37|       @rewindable_io = Tempfile.new('RackRewindableInput')
    38|       @rewindable_io.chmod(0000)
    39|       @rewindable_io.set_encoding(Encoding::BINARY) if @rewindable_io.respond_to?(:set_encoding)
    40|       @rewindable_io.binmode
    41|       if filesystem_has_posix_semantics?
    42|         raise 'Unlink failed. IO closed.' if @rewindable_io.closed?
    43|         @unlinked = true
    44|       end
    45|       buffer = "".dup
    46|       while @io.read(1024 * 4, buffer)
    47|         entire_buffer_written_out = false
    48|         while !entire_buffer_written_out
    49|           written = @rewindable_io.write(buffer)
    50|           entire_buffer_written_out = written == buffer.bytesize
    51|           if !entire_buffer_written_out
    52|             buffer.slice!(0 .. written - 1)
    53|           end
    54|         end
    55|       end
    56|       @rewindable_io.rewind
    57|     end
    58|     def filesystem_has_posix_semantics?
    59|       RUBY_PLATFORM !~ /(mswin|mingw|cygwin|java)/
    60|     end
    61|   end
    62| end


# ====================================================================
# FILE: lib/rack/runtime.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| module Rack
     2|   class Runtime
     3|     FORMAT_STRING = "%0.6f" # :nodoc:
     4|     HEADER_NAME = "X-Runtime" # :nodoc:
     5|     def initialize(app, name = nil)
     6|       @app = app
     7|       @header_name = HEADER_NAME
     8|       @header_name += "-#{name}" if name
     9|     end
    10|     def call(env)
    11|       start_time = Utils.clock_time
    12|       status, headers, body = @app.call(env)
    13|       headers = Utils::HeaderHash[headers]
    14|       request_time = Utils.clock_time - start_time
    15|       unless headers.key?(@header_name)
    16|         headers[@header_name] = FORMAT_STRING % request_time
    17|       end
    18|       [status, headers, body]
    19|     end
    20|   end
    21| end


# ====================================================================
# FILE: lib/rack/sendfile.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| module Rack
     2|   class Sendfile
     3|     def initialize(app, variation = nil, mappings = [])
     4|       @app = app
     5|       @variation = variation
     6|       @mappings = mappings.map do |internal, external|
     7|         [/^#{internal}/i, external]
     8|       end
     9|     end
    10|     def call(env)
    11|       status, headers, body = @app.call(env)
    12|       if body.respond_to?(:to_path)
    13|         case type = variation(env)
    14|         when 'X-Accel-Redirect'
    15|           path = ::File.expand_path(body.to_path)
    16|           if url = map_accel_path(env, path)
    17|             headers[CONTENT_LENGTH] = '0'
    18|             headers[type] = ::Rack::Utils.escape_path(url).gsub('?', '%3F')
    19|             obody = body
    20|             body = Rack::BodyProxy.new([]) do
    21|               obody.close if obody.respond_to?(:close)
    22|             end
    23|           else
    24|             env[RACK_ERRORS].puts "X-Accel-Mapping header missing"
    25|           end
    26|         when 'X-Sendfile', 'X-Lighttpd-Send-File'
    27|           path = ::File.expand_path(body.to_path)
    28|           headers[CONTENT_LENGTH] = '0'
    29|           headers[type] = path
    30|           obody = body
    31|           body = Rack::BodyProxy.new([]) do
    32|             obody.close if obody.respond_to?(:close)
    33|           end
    34|         when '', nil
    35|         else
    36|           env[RACK_ERRORS].puts "Unknown x-sendfile variation: '#{type}'.\n"
    37|         end
    38|       end
    39|       [status, headers, body]
    40|     end
    41|     private
    42|     def variation(env)
    43|       @variation ||
    44|         env['sendfile.type'] ||
    45|         env['HTTP_X_SENDFILE_TYPE']
    46|     end
    47|     def map_accel_path(env, path)
    48|       if mapping = @mappings.find { |internal, _| internal =~ path }
    49|         path.sub(*mapping)
    50|       elsif mapping = env['HTTP_X_ACCEL_MAPPING']
    51|         mapping.split(',').map(&:strip).each do |m|
    52|           internal, external = m.split('=', 2).map(&:strip)
    53|           new_path = path.sub(/^#{internal}/i, external)
    54|           return new_path unless path == new_path
    55|         end
    56|         path
    57|       end
    58|     end
    59|   end
    60| end


# ====================================================================
# FILE: lib/rack/server.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-321 ---
     1| require 'optparse'
     2| require 'fileutils'
     3| module Rack
     4|   class Server
     5|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     6|     class Options
     7|       def parse!(args)
     8|         options = {}
     9|         opt_parser = OptionParser.new("", 24, '  ') do |opts|
    10|           opts.banner = "Usage: rackup [ruby options] [rack options] [rackup config]"
    11|           opts.separator ""
    12|           opts.separator "Ruby options:"
    13|           lineno = 1
    14|           opts.on("-e", "--eval LINE", "evaluate a LINE of code") { |line|
    15|             eval line, TOPLEVEL_BINDING, "-e", lineno
    16|             lineno += 1
    17|           }
    18|           opts.on("-d", "--debug", "set debugging flags (set $DEBUG to true)") {
    19|             options[:debug] = true
    20|           }
    21|           opts.on("-w", "--warn", "turn warnings on for your script") {
    22|             options[:warn] = true
    23|           }
    24|           opts.on("-q", "--quiet", "turn off logging") {
    25|             options[:quiet] = true
    26|           }
    27|           opts.on("-I", "--include PATH",
    28|                   "specify $LOAD_PATH (may be used more than once)") { |path|
    29|             (options[:include] ||= []).concat(path.split(":"))
    30|           }
    31|           opts.on("-r", "--require LIBRARY",
    32|                   "require the library, before executing your script") { |library|
    33|             (options[:require] ||= []) << library
    34|           }
    35|           opts.separator ""
    36|           opts.separator "Rack options:"
    37|           opts.on("-b", "--builder BUILDER_LINE", "evaluate a BUILDER_LINE of code as a builder script") { |line|
    38|             options[:builder] = line
    39|           }
    40|           opts.on("-s", "--server SERVER", "serve using SERVER (thin/puma/webrick)") { |s|
    41|             options[:server] = s
    42|           }
    43|           opts.on("-o", "--host HOST", "listen on HOST (default: localhost)") { |host|
    44|             options[:Host] = host
    45|           }
    46|           opts.on("-p", "--port PORT", "use PORT (default: 9292)") { |port|
    47|             options[:Port] = port
    48|           }
    49|           opts.on("-O", "--option NAME[=VALUE]", "pass VALUE to the server as option NAME. If no VALUE, sets it to true. Run '#{$0} -s SERVER -h' to get a list of options for SERVER") { |name|
    50|             name, value = name.split('=', 2)
    51|             value = true if value.nil?
    52|             options[name.to_sym] = value
    53|           }
    54|           opts.on("-E", "--env ENVIRONMENT", "use ENVIRONMENT for defaults (default: development)") { |e|
    55|             options[:environment] = e
    56|           }
    57|           opts.on("-D", "--daemonize", "run daemonized in the background") { |d|
    58|             options[:daemonize] = d ? true : false
    59|           }
    60|           opts.on("-P", "--pid FILE", "file to store PID") { |f|
    61|             options[:pid] = ::File.expand_path(f)
    62|           }
    63|           opts.separator ""
    64|           opts.separator "Profiling options:"
    65|           opts.on("--heap HEAPFILE", "Build the application, then dump the heap to HEAPFILE") do |e|
    66|             options[:heapfile] = e
    67|           end
    68|           opts.on("--profile PROFILE", "Dump CPU or Memory profile to PROFILE (defaults to a tempfile)") do |e|
    69|             options[:profile_file] = e
    70|           end
    71|           opts.on("--profile-mode MODE", "Profile mode (cpu|wall|object)") do |e|
    72|             { cpu: true, wall: true, object: true }.fetch(e.to_sym) do
    73|               raise OptionParser::InvalidOption, "unknown profile mode: #{e}"
    74|             end
    75|             options[:profile_mode] = e.to_sym
    76|           end
    77|           opts.separator ""
    78|           opts.separator "Common options:"
    79|           opts.on_tail("-h", "-?", "--help", "Show this message") do
    80|             puts opts
    81|             puts handler_opts(options)
    82|             exit
    83|           end
    84|           opts.on_tail("--version", "Show version") do
    85|             puts "Rack #{Rack.version} (Release: #{Rack.release})"
    86|             exit
    87|           end
    88|         end
    89|         begin
    90|           opt_parser.parse! args
    91|         rescue OptionParser::InvalidOption => e
    92|           warn e.message
    93|           abort opt_parser.to_s
    94|         end
    95|         options[:config] = args.last if args.last && !args.last.empty?
    96|         options
    97|       end
    98|       def handler_opts(options)
    99|         begin
   100|           info = []
   101|           server = Rack::Handler.get(options[:server]) || Rack::Handler.default
   102|           if server && server.respond_to?(:valid_options)
   103|             info << ""
   104|             info << "Server-specific options for #{server.name}:"
   105|             has_options = false
   106|             server.valid_options.each do |name, description|
   107|               next if /^(Host|Port)[^a-zA-Z]/.match?(name.to_s) # ignore handler's host and port options, we do our own.
   108|               info << "  -O %-21s %s" % [name, description]
   109|               has_options = true
   110|             end
   111|             return "" if !has_options
   112|           end
   113|           info.join("\n")
   114|         rescue NameError, LoadError
   115|           return "Warning: Could not find handler specified (#{options[:server] || 'default'}) to determine handler-specific options"
   116|         end
   117|       end
   118|     end
   119|     def self.start(options = nil)
   120|       new(options).start
   121|     end
   122|     attr_writer :options
   123|     def initialize(options = nil)
   124|       @ignore_options = []
   125|       if options
   126|         @use_default_options = false
   127|         @options = options
   128|         @app = options[:app] if options[:app]
   129|       else
   130|         argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV
   131|         @use_default_options = true
   132|         @options = parse_options(argv)
   133|       end
   134|     end
   135|     def options
   136|       merged_options = @use_default_options ? default_options.merge(@options) : @options
   137|       merged_options.reject { |k, v| @ignore_options.include?(k) }
   138|     end
   139|     def default_options
   140|       environment  = ENV['RACK_ENV'] || 'development'
   141|       default_host = environment == 'development' ? 'localhost' : '0.0.0.0'
   142|       {
   143|         environment: environment,
   144|         pid: nil,
   145|         Port: 9292,
   146|         Host: default_host,
   147|         AccessLog: [],
   148|         config: "config.ru"
   149|       }
   150|     end
   151|     def app
   152|       @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
   153|     end
   154|     class << self
   155|       def logging_middleware
   156|         lambda { |server|
   157|           /CGI/.match?(server.server.name) || server.options[:quiet] ? nil : [Rack::CommonLogger, $stderr]
   158|         }
   159|       end
   160|       def default_middleware_by_environment
   161|         m = Hash.new {|h, k| h[k] = []}
   162|         m["deployment"] = [
   163|           [Rack::ContentLength],
   164|           logging_middleware,
   165|           [Rack::TempfileReaper]
   166|         ]
   167|         m["development"] = [
   168|           [Rack::ContentLength],
   169|           logging_middleware,
   170|           [Rack::ShowExceptions],
   171|           [Rack::Lint],
   172|           [Rack::TempfileReaper]
   173|         ]
   174|         m
   175|       end
   176|       def middleware
   177|         default_middleware_by_environment
   178|       end
   179|     end
   180|     def middleware
   181|       self.class.middleware
   182|     end
   183|     def start(&block)
   184|       if options[:warn]
   185|         $-w = true
   186|       end
   187|       if includes = options[:include]
   188|         $LOAD_PATH.unshift(*includes)
   189|       end
   190|       Array(options[:require]).each do |library|
   191|         require library
   192|       end
   193|       if options[:debug]
   194|         $DEBUG = true
   195|         require 'pp'
   196|         p options[:server]
   197|         pp wrapped_app
   198|         pp app
   199|       end
   200|       check_pid! if options[:pid]
   201|       handle_profiling(options[:heapfile], options[:profile_mode], options[:profile_file]) do
   202|         wrapped_app
   203|       end
   204|       daemonize_app if options[:daemonize]
   205|       write_pid if options[:pid]
   206|       trap(:INT) do
   207|         if server.respond_to?(:shutdown)
   208|           server.shutdown
   209|         else
   210|           exit
   211|         end
   212|       end
   213|       server.run(wrapped_app, **options, &block)
   214|     end
   215|     def server
   216|       @_server ||= Rack::Handler.get(options[:server])
   217|       unless @_server
   218|         @_server = Rack::Handler.default
   219|         @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'
   220|       end
   221|       @_server
   222|     end
   223|     private
   224|       def build_app_and_options_from_config
   225|         if !::File.exist? options[:config]
   226|           abort "configuration #{options[:config]} not found"
   227|         end
   228|         app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
   229|         @options.merge!(options) { |key, old, new| old }
   230|         app
   231|       end
   232|       def handle_profiling(heapfile, profile_mode, filename)
   233|         if heapfile
   234|           require "objspace"
   235|           ObjectSpace.trace_object_allocations_start
   236|           yield
   237|           GC.start
   238|           ::File.open(heapfile, "w") { |f| ObjectSpace.dump_all(output: f) }
   239|           exit
   240|         end
   241|         if profile_mode
   242|           require "stackprof"
   243|           require "tempfile"
   244|           make_profile_name(filename) do |filename|
   245|             ::File.open(filename, "w") do |f|
   246|               StackProf.run(mode: profile_mode, out: f) do
   247|                 yield
   248|               end
   249|               puts "Profile written to: #{filename}"
   250|             end
   251|           end
   252|           exit
   253|         end
   254|         yield
   255|       end
   256|       def make_profile_name(filename)
   257|         if filename
   258|           yield filename
   259|         else
   260|           ::Dir::Tmpname.create("profile.dump") do |tmpname, _, _|
   261|             yield tmpname
   262|           end
   263|         end
   264|       end
   265|       def build_app_from_string
   266|         Rack::Builder.new_from_string(self.options[:builder])
   267|       end
   268|       def parse_options(args)
   269|         args.clear if ENV.include?(REQUEST_METHOD)
   270|         @options = opt_parser.parse!(args)
   271|         @options[:config] = ::File.expand_path(options[:config])
   272|         ENV["RACK_ENV"] = options[:environment]
   273|         @options
   274|       end
   275|       def opt_parser
   276|         Options.new
   277|       end
   278|       def build_app(app)
   279|         middleware[options[:environment]].reverse_each do |middleware|
   280|           middleware = middleware.call(self) if middleware.respond_to?(:call)
   281|           next unless middleware
   282|           klass, *args = middleware
   283|           app = klass.new(app, *args)
   284|         end
   285|         app
   286|       end
   287|       def wrapped_app
   288|         @wrapped_app ||= build_app app
   289|       end
   290|       def daemonize_app
   291|         Process.daemon
   292|       end
   293|       def write_pid
   294|         ::File.open(options[:pid], ::File::CREAT | ::File::EXCL | ::File::WRONLY ){ |f| f.write("#{Process.pid}") }
   295|         at_exit { ::FileUtils.rm_f(options[:pid]) }
   296|       rescue Errno::EEXIST
   297|         check_pid!
   298|         retry
   299|       end
   300|       def check_pid!
   301|         case pidfile_process_status
   302|         when :running, :not_owned
   303|           $stderr.puts "A server is already running. Check #{options[:pid]}."
   304|           exit(1)
   305|         when :dead
   306|           ::File.delete(options[:pid])
   307|         end
   308|       end
   309|       def pidfile_process_status
   310|         return :exited unless ::File.exist?(options[:pid])
   311|         pid = ::File.read(options[:pid]).to_i
   312|         return :dead if pid == 0
   313|         Process.kill(0, pid)
   314|         :running
   315|       rescue Errno::ESRCH
   316|         :dead
   317|       rescue Errno::EPERM
   318|         :not_owned
   319|       end
   320|   end
   321| end


# ====================================================================
# FILE: lib/rack/session/abstract/id.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-349 ---
     1| require_relative '../../../rack'
     2| require 'time'
     3| require 'securerandom'
     4| require 'digest/sha2'
     5| module Rack
     6|   module Session
     7|     class SessionId
     8|       ID_VERSION = 2
     9|       attr_reader :public_id
    10|       def initialize(public_id)
    11|         @public_id = public_id
    12|       end
    13|       def private_id
    14|         "#{ID_VERSION}::#{hash_sid(public_id)}"
    15|       end
    16|       alias :cookie_value :public_id
    17|       alias :to_s :public_id
    18|       def empty?; false; end
    19|       def inspect; public_id.inspect; end
    20|       private
    21|       def hash_sid(sid)
    22|         Digest::SHA256.hexdigest(sid)
    23|       end
    24|     end
    25|     module Abstract
    26|       class SessionHash
    27|         include Enumerable
    28|         attr_writer :id
    29|         Unspecified = Object.new
    30|         def self.find(req)
    31|           req.get_header RACK_SESSION
    32|         end
    33|         def self.set(req, session)
    34|           req.set_header RACK_SESSION, session
    35|         end
    36|         def self.set_options(req, options)
    37|           req.set_header RACK_SESSION_OPTIONS, options.dup
    38|         end
    39|         def initialize(store, req)
    40|           @store = store
    41|           @req = req
    42|           @loaded = false
    43|         end
    44|         def id
    45|           return @id if @loaded or instance_variable_defined?(:@id)
    46|           @id = @store.send(:extract_session_id, @req)
    47|         end
    48|         def options
    49|           @req.session_options
    50|         end
    51|         def each(&block)
    52|           load_for_read!
    53|           @data.each(&block)
    54|         end
    55|         def [](key)
    56|           load_for_read!
    57|           @data[key.to_s]
    58|         end
    59|         def dig(key, *keys)
    60|           load_for_read!
    61|           @data.dig(key.to_s, *keys)
    62|         end
    63|         def fetch(key, default = Unspecified, &block)
    64|           load_for_read!
    65|           if default == Unspecified
    66|             @data.fetch(key.to_s, &block)
    67|           else
    68|             @data.fetch(key.to_s, default, &block)
    69|           end
    70|         end
    71|         def has_key?(key)
    72|           load_for_read!
    73|           @data.has_key?(key.to_s)
    74|         end
    75|         alias :key? :has_key?
    76|         alias :include? :has_key?
    77|         def []=(key, value)
    78|           load_for_write!
    79|           @data[key.to_s] = value
    80|         end
    81|         alias :store :[]=
    82|         def clear
    83|           load_for_write!
    84|           @data.clear
    85|         end
    86|         def destroy
    87|           clear
    88|           @id = @store.send(:delete_session, @req, id, options)
    89|         end
    90|         def to_hash
    91|           load_for_read!
    92|           @data.dup
    93|         end
    94|         def update(hash)
    95|           load_for_write!
    96|           @data.update(stringify_keys(hash))
    97|         end
    98|         alias :merge! :update
    99|         def replace(hash)
   100|           load_for_write!
   101|           @data.replace(stringify_keys(hash))
   102|         end
   103|         def delete(key)
   104|           load_for_write!
   105|           @data.delete(key.to_s)
   106|         end
   107|         def inspect
   108|           if loaded?
   109|             @data.inspect
   110|           else
   111|             "#<#{self.class}:0x#{self.object_id.to_s(16)} not yet loaded>"
   112|           end
   113|         end
   114|         def exists?
   115|           return @exists if instance_variable_defined?(:@exists)
   116|           @data = {}
   117|           @exists = @store.send(:session_exists?, @req)
   118|         end
   119|         def loaded?
   120|           @loaded
   121|         end
   122|         def empty?
   123|           load_for_read!
   124|           @data.empty?
   125|         end
   126|         def keys
   127|           load_for_read!
   128|           @data.keys
   129|         end
   130|         def values
   131|           load_for_read!
   132|           @data.values
   133|         end
   134|       private
   135|         def load_for_read!
   136|           load! if !loaded? && exists?
   137|         end
   138|         def load_for_write!
   139|           load! unless loaded?
   140|         end
   141|         def load!
   142|           @id, session = @store.send(:load_session, @req)
   143|           @data = stringify_keys(session)
   144|           @loaded = true
   145|         end
   146|         def stringify_keys(other)
   147|           hash = {}
   148|           other.to_hash.each do |key, value|
   149|             hash[key.to_s] = value
   150|           end
   151|           hash
   152|         end
   153|       end
   154|       class Persisted
   155|         DEFAULT_OPTIONS = {
   156|           key: RACK_SESSION,
   157|           path: '/',
   158|           domain: nil,
   159|           expire_after: nil,
   160|           secure: false,
   161|           httponly: true,
   162|           defer: false,
   163|           renew: false,
   164|           sidbits: 128,
   165|           cookie_only: true,
   166|           secure_random: ::SecureRandom
   167|         }.freeze
   168|         attr_reader :key, :default_options, :sid_secure
   169|         def initialize(app, options = {})
   170|           @app = app
   171|           @default_options = self.class::DEFAULT_OPTIONS.merge(options)
   172|           @key = @default_options.delete(:key)
   173|           @cookie_only = @default_options.delete(:cookie_only)
   174|           initialize_sid
   175|         end
   176|         def call(env)
   177|           context(env)
   178|         end
   179|         def context(env, app = @app)
   180|           req = make_request env
   181|           prepare_session(req)
   182|           status, headers, body = app.call(req.env)
   183|           res = Rack::Response::Raw.new status, headers
   184|           commit_session(req, res)
   185|           [status, headers, body]
   186|         end
   187|         private
   188|         def make_request(env)
   189|           Rack::Request.new env
   190|         end
   191|         def initialize_sid
   192|           @sidbits = @default_options[:sidbits]
   193|           @sid_secure = @default_options[:secure_random]
   194|           @sid_length = @sidbits / 4
   195|         end
   196|         def generate_sid(secure = @sid_secure)
   197|           if secure
   198|             secure.hex(@sid_length)
   199|           else
   200|             "%0#{@sid_length}x" % Kernel.rand(2**@sidbits - 1)
   201|           end
   202|         rescue NotImplementedError
   203|           generate_sid(false)
   204|         end
   205|         def prepare_session(req)
   206|           session_was               = req.get_header RACK_SESSION
   207|           session                   = session_class.new(self, req)
   208|           req.set_header RACK_SESSION, session
   209|           req.set_header RACK_SESSION_OPTIONS, @default_options.dup
   210|           session.merge! session_was if session_was
   211|         end
   212|         def load_session(req)
   213|           sid = current_session_id(req)
   214|           sid, session = find_session(req, sid)
   215|           [sid, session || {}]
   216|         end
   217|         def extract_session_id(request)
   218|           sid = request.cookies[@key]
   219|           sid ||= request.params[@key] unless @cookie_only
   220|           sid
   221|         end
   222|         def current_session_id(req)
   223|           req.get_header(RACK_SESSION).id
   224|         end
   225|         def session_exists?(req)
   226|           value = current_session_id(req)
   227|           value && !value.empty?
   228|         end
   229|         def commit_session?(req, session, options)
   230|           if options[:skip]
   231|             false
   232|           else
   233|             has_session = loaded_session?(session) || forced_session_update?(session, options)
   234|             has_session && security_matches?(req, options)
   235|           end
   236|         end
   237|         def loaded_session?(session)
   238|           !session.is_a?(session_class) || session.loaded?
   239|         end
   240|         def forced_session_update?(session, options)
   241|           force_options?(options) && session && !session.empty?
   242|         end
   243|         def force_options?(options)
   244|           options.values_at(:max_age, :renew, :drop, :defer, :expire_after).any?
   245|         end
   246|         def security_matches?(request, options)
   247|           return true unless options[:secure]
   248|           request.ssl?
   249|         end
   250|         def commit_session(req, res)
   251|           session = req.get_header RACK_SESSION
   252|           options = session.options
   253|           if options[:drop] || options[:renew]
   254|             session_id = delete_session(req, session.id || generate_sid, options)
   255|             return unless session_id
   256|           end
   257|           return unless commit_session?(req, session, options)
   258|           session.send(:load!) unless loaded_session?(session)
   259|           session_id ||= session.id
   260|           session_data = session.to_hash.delete_if { |k, v| v.nil? }
   261|           if not data = write_session(req, session_id, session_data, options)
   262|             req.get_header(RACK_ERRORS).puts("Warning! #{self.class.name} failed to save session. Content dropped.")
   263|           elsif options[:defer] and not options[:renew]
   264|             req.get_header(RACK_ERRORS).puts("Deferring cookie for #{session_id}") if $VERBOSE
   265|           else
   266|             cookie = Hash.new
   267|             cookie[:value] = cookie_value(data)
   268|             cookie[:expires] = Time.now + options[:expire_after] if options[:expire_after]
   269|             cookie[:expires] = Time.now + options[:max_age] if options[:max_age]
   270|             if @same_site.respond_to? :call
   271|               cookie[:same_site] = @same_site.call(req, res)
   272|             else
   273|               cookie[:same_site] = @same_site
   274|             end
   275|             set_cookie(req, res, cookie.merge!(options))
   276|           end
   277|         end
   278|         public :commit_session
   279|         def cookie_value(data)
   280|           data
   281|         end
   282|         def set_cookie(request, res, cookie)
   283|           if request.cookies[@key] != cookie[:value] || cookie[:expires]
   284|             res.set_cookie_header =
   285|               Utils.add_cookie_to_header(res.set_cookie_header, @key, cookie)
   286|           end
   287|         end
   288|         def session_class
   289|           SessionHash
   290|         end
   291|         def find_session(env, sid)
   292|           raise '#find_session not implemented.'
   293|         end
   294|         def write_session(req, sid, session, options)
   295|           raise '#write_session not implemented.'
   296|         end
   297|         def delete_session(req, sid, options)
   298|           raise '#delete_session not implemented'
   299|         end
   300|       end
   301|       class PersistedSecure < Persisted
   302|         class SecureSessionHash < SessionHash
   303|           def [](key)
   304|             if key == "session_id"
   305|               load_for_read!
   306|               id.public_id if id
   307|             else
   308|               super
   309|             end
   310|           end
   311|         end
   312|         def generate_sid(*)
   313|           public_id = super
   314|           SessionId.new(public_id)
   315|         end
   316|         def extract_session_id(*)
   317|           public_id = super
   318|           public_id && SessionId.new(public_id)
   319|         end
   320|         private
   321|         def session_class
   322|           SecureSessionHash
   323|         end
   324|         def cookie_value(data)
   325|           data.cookie_value
   326|         end
   327|       end
   328|       class ID < Persisted
   329|         def self.inherited(klass)
   330|           k = klass.ancestors.find { |kl| kl.respond_to?(:superclass) && kl.superclass == ID }
   331|           unless k.instance_variable_defined?(:"@_rack_warned")
   332|             warn "#{klass} is inheriting from #{ID}.  Inheriting from #{ID} is deprecated, please inherit from #{Persisted} instead" if $VERBOSE
   333|             k.instance_variable_set(:"@_rack_warned", true)
   334|           end
   335|           super
   336|         end
   337|         def find_session(req, sid)
   338|           get_session req.env, sid
   339|         end
   340|         def write_session(req, sid, session, options)
   341|           set_session req.env, sid, session, options
   342|         end
   343|         def delete_session(req, sid, options)
   344|           destroy_session req.env, sid, options
   345|         end
   346|       end
   347|     end
   348|   end
   349| end


# ====================================================================
# FILE: lib/rack/session/cookie.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| require 'openssl'
     2| require 'zlib'
     3| require_relative 'abstract/id'
     4| require 'json'
     5| require 'base64'
     6| module Rack
     7|   module Session
     8|     class Cookie < Abstract::PersistedSecure
     9|       class Base64
    10|         def encode(str)
    11|           ::Base64.strict_encode64(str)
    12|         end
    13|         def decode(str)
    14|           ::Base64.decode64(str)
    15|         end
    16|         class Marshal < Base64
    17|           def encode(str)
    18|             super(::Marshal.dump(str))
    19|           end
    20|           def decode(str)
    21|             return unless str
    22|             ::Marshal.load(super(str)) rescue nil
    23|           end
    24|         end
    25|         class JSON < Base64
    26|           def encode(obj)
    27|             super(::JSON.dump(obj))
    28|           end
    29|           def decode(str)
    30|             return unless str
    31|             ::JSON.parse(super(str)) rescue nil
    32|           end
    33|         end
    34|         class ZipJSON < Base64
    35|           def encode(obj)
    36|             super(Zlib::Deflate.deflate(::JSON.dump(obj)))
    37|           end
    38|           def decode(str)
    39|             return unless str
    40|             ::JSON.parse(Zlib::Inflate.inflate(super(str)))
    41|           rescue
    42|             nil
    43|           end
    44|         end
    45|       end
    46|       class Identity
    47|         def encode(str); str; end
    48|         def decode(str); str; end
    49|       end
    50|       attr_reader :coder
    51|       def initialize(app, options = {})
    52|         @secrets = options.values_at(:secret, :old_secret).compact
    53|         @hmac = options.fetch(:hmac, OpenSSL::Digest::SHA1)
    54|         warn <<-MSG unless secure?(options)
    55|         SECURITY WARNING: No secret option provided to Rack::Session::Cookie.
    56|         This poses a security threat. It is strongly recommended that you
    57|         provide a secret to prevent exploits that may be possible from crafted
    58|         cookies. This will not be supported in future versions of Rack, and
    59|         future versions will even invalidate your existing user cookies.
    60|         Called from: #{caller[0]}.
    61|         MSG
    62|         @coder = options[:coder] ||= Base64::Marshal.new
    63|         @same_site = options.delete :same_site
    64|         super(app, options.merge!(cookie_only: true))
    65|       end
    66|       private
    67|       def find_session(req, sid)
    68|         data = unpacked_cookie_data(req)
    69|         data = persistent_session_id!(data)
    70|         [data["session_id"], data]
    71|       end
    72|       def extract_session_id(request)
    73|         unpacked_cookie_data(request)["session_id"]
    74|       end
    75|       def unpacked_cookie_data(request)
    76|         request.fetch_header(RACK_SESSION_UNPACKED_COOKIE_DATA) do |k|
    77|           session_data = request.cookies[@key]
    78|           if @secrets.size > 0 && session_data
    79|             session_data, _, digest = session_data.rpartition('--')
    80|             session_data = nil unless digest_match?(session_data, digest)
    81|           end
    82|           request.set_header(k, coder.decode(session_data) || {})
    83|         end
    84|       end
    85|       def persistent_session_id!(data, sid = nil)
    86|         data ||= {}
    87|         data["session_id"] ||= sid || generate_sid
    88|         data
    89|       end
    90|       class SessionId < DelegateClass(Session::SessionId)
    91|         attr_reader :cookie_value
    92|         def initialize(session_id, cookie_value)
    93|           super(session_id)
    94|           @cookie_value = cookie_value
    95|         end
    96|       end
    97|       def write_session(req, session_id, session, options)
    98|         session = session.merge("session_id" => session_id)
    99|         session_data = coder.encode(session)
   100|         if @secrets.first
   101|           session_data << "--#{generate_hmac(session_data, @secrets.first)}"
   102|         end
   103|         if session_data.size > (4096 - @key.size)
   104|           req.get_header(RACK_ERRORS).puts("Warning! Rack::Session::Cookie data size exceeds 4K.")
   105|           nil
   106|         else
   107|           SessionId.new(session_id, session_data)
   108|         end
   109|       end
   110|       def delete_session(req, session_id, options)
   111|         generate_sid unless options[:drop]
   112|       end
   113|       def digest_match?(data, digest)
   114|         return unless data && digest
   115|         @secrets.any? do |secret|
   116|           Rack::Utils.secure_compare(digest, generate_hmac(data, secret))
   117|         end
   118|       end
   119|       def generate_hmac(data, secret)
   120|         OpenSSL::HMAC.hexdigest(@hmac.new, secret, data)
   121|       end
   122|       def secure?(options)
   123|         @secrets.size >= 1 ||
   124|         (options[:coder] && options[:let_coder_handle_secure_encoding])
   125|       end
   126|     end
   127|   end
   128| end


# ====================================================================
# FILE: lib/rack/session/pool.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| require_relative 'abstract/id'
     2| require 'thread'
     3| module Rack
     4|   module Session
     5|     class Pool < Abstract::PersistedSecure
     6|       attr_reader :mutex, :pool
     7|       DEFAULT_OPTIONS = Abstract::ID::DEFAULT_OPTIONS.merge drop: false
     8|       def initialize(app, options = {})
     9|         super
    10|         @pool = Hash.new
    11|         @mutex = Mutex.new
    12|       end
    13|       def generate_sid
    14|         loop do
    15|           sid = super
    16|           break sid unless @pool.key? sid.private_id
    17|         end
    18|       end
    19|       def find_session(req, sid)
    20|         with_lock(req) do
    21|           unless sid and session = get_session_with_fallback(sid)
    22|             sid, session = generate_sid, {}
    23|             @pool.store sid.private_id, session
    24|           end
    25|           [sid, session]
    26|         end
    27|       end
    28|       def write_session(req, session_id, new_session, options)
    29|         with_lock(req) do
    30|           @pool.store session_id.private_id, new_session
    31|           session_id
    32|         end
    33|       end
    34|       def delete_session(req, session_id, options)
    35|         with_lock(req) do
    36|           @pool.delete(session_id.public_id)
    37|           @pool.delete(session_id.private_id)
    38|           generate_sid unless options[:drop]
    39|         end
    40|       end
    41|       def with_lock(req)
    42|         @mutex.lock if req.multithread?
    43|         yield
    44|       ensure
    45|         @mutex.unlock if @mutex.locked?
    46|       end
    47|       private
    48|       def get_session_with_fallback(sid)
    49|         @pool[sid.private_id] || @pool[sid.public_id]
    50|       end
    51|     end
    52|   end
    53| end


# ====================================================================
# FILE: lib/rack/show_exceptions.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-322 ---
     1| require 'ostruct'
     2| require 'erb'
     3| module Rack
     4|   class ShowExceptions
     5|     CONTEXT = 7
     6|     def initialize(app)
     7|       @app = app
     8|     end
     9|     def call(env)
    10|       @app.call(env)
    11|     rescue StandardError, LoadError, SyntaxError => e
    12|       exception_string = dump_exception(e)
    13|       env[RACK_ERRORS].puts(exception_string)
    14|       env[RACK_ERRORS].flush
    15|       if accepts_html?(env)
    16|         content_type = "text/html"
    17|         body = pretty(env, e)
    18|       else
    19|         content_type = "text/plain"
    20|         body = exception_string
    21|       end
    22|       [
    23|         500,
    24|         {
    25|           CONTENT_TYPE => content_type,
    26|           CONTENT_LENGTH => body.bytesize.to_s,
    27|         },
    28|         [body],
    29|       ]
    30|     end
    31|     def prefers_plaintext?(env)
    32|       !accepts_html?(env)
    33|     end
    34|     def accepts_html?(env)
    35|       Rack::Utils.best_q_match(env["HTTP_ACCEPT"], %w[text/html])
    36|     end
    37|     private :accepts_html?
    38|     def dump_exception(exception)
    39|       string = "#{exception.class}: #{exception.message}\n".dup
    40|       string << exception.backtrace.map { |l| "\t#{l}" }.join("\n")
    41|       string
    42|     end
    43|     def pretty(env, exception)
    44|       req = Rack::Request.new(env)
    45|       path = path = (req.script_name + req.path_info).squeeze("/")
    46|       frames = frames = exception.backtrace.map { |line|
    47|         frame = OpenStruct.new
    48|         if line =~ /(.*?):(\d+)(:in `(.*)')?/
    49|           frame.filename = $1
    50|           frame.lineno = $2.to_i
    51|           frame.function = $4
    52|           begin
    53|             lineno = frame.lineno - 1
    54|             lines = ::File.readlines(frame.filename)
    55|             frame.pre_context_lineno = [lineno - CONTEXT, 0].max
    56|             frame.pre_context = lines[frame.pre_context_lineno...lineno]
    57|             frame.context_line = lines[lineno].chomp
    58|             frame.post_context_lineno = [lineno + CONTEXT, lines.size].min
    59|             frame.post_context = lines[lineno + 1..frame.post_context_lineno]
    60|           rescue
    61|           end
    62|           frame
    63|         else
    64|           nil
    65|         end
    66|       }.compact
    67|       template.result(binding)
    68|     end
    69|     def template
    70|       TEMPLATE
    71|     end
    72|     def h(obj)                  # :nodoc:
    73|       case obj
    74|       when String
    75|         Utils.escape_html(obj)
    76|       else
    77|         Utils.escape_html(obj.inspect)
    78|       end
    79|     end
    80|     TEMPLATE = ERB.new(<<-'HTML'.gsub(/^      /, ''))
    81|       <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    82|       <html lang="en">
    83|       <head>
    84|         <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    85|         <meta name="robots" content="NONE,NOARCHIVE" />
    86|         <title><%=h exception.class %> at <%=h path %></title>
    87|         <style type="text/css">
    88|           html * { padding:0; margin:0; }
    89|           body * { padding:10px 20px; }
    90|           body * * { padding:0; }
    91|           body { font:small sans-serif; }
    92|           body>div { border-bottom:1px solid #ddd; }
    93|           h1 { font-weight:normal; }
    94|           h2 { margin-bottom:.8em; }
    95|           h2 span { font-size:80%; color:#666; font-weight:normal; }
    96|           h3 { margin:1em 0 .5em 0; }
    97|           h4 { margin:0 0 .5em 0; font-weight: normal; }
    98|           table {
    99|               border:1px solid #ccc; border-collapse: collapse; background:white; }
   100|           tbody td, tbody th { vertical-align:top; padding:2px 3px; }
   101|           thead th {
   102|               padding:1px 6px 1px 3px; background:#fefefe; text-align:left;
   103|               font-weight:normal; font-size:11px; border:1px solid #ddd; }
   104|           tbody th { text-align:right; color:#666; padding-right:.5em; }
   105|           table.vars { margin:5px 0 2px 40px; }
   106|           table.vars td, table.req td { font-family:monospace; }
   107|           table td.code { width:100%;}
   108|           table td.code div { overflow:hidden; }
   109|           table.source th { color:#666; }
   110|           table.source td {
   111|               font-family:monospace; white-space:pre; border-bottom:1px solid #eee; }
   112|           ul.traceback { list-style-type:none; }
   113|           ul.traceback li.frame { margin-bottom:1em; }
   114|           div.context { margin: 10px 0; }
   115|           div.context ol {
   116|               padding-left:30px; margin:0 10px; list-style-position: inside; }
   117|           div.context ol li {
   118|               font-family:monospace; white-space:pre; color:#666; cursor:pointer; }
   119|           div.context ol.context-line li { color:black; background-color:#ccc; }
   120|           div.context ol.context-line li span { float: right; }
   121|           div.commands { margin-left: 40px; }
   122|           div.commands a { color:black; text-decoration:none; }
   123|           .error { background: #ffc; }
   124|           .specific { color:#cc3300; font-weight:bold; }
   125|         </style>
   126|         <script type="text/javascript">
   127|         //<!--
   128|           function getElementsByClassName(oElm, strTagName, strClassName){
   129|               // Written by Jonathan Snook, http://www.snook.ca/jon;
   130|               // Add-ons by Robert Nyman, http://www.robertnyman.com
   131|               var arrElements = (strTagName == "*" && document.all)? document.all :
   132|               oElm.getElementsByTagName(strTagName);
   133|               var arrReturnElements = new Array();
   134|               strClassName = strClassName.replace(/\-/g, "\\-");
   135|               var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$$)");
   136|               var oElement;
   137|               for(var i=0; i<arrElements.length; i++){
   138|                   oElement = arrElements[i];
   139|                   if(oRegExp.test(oElement.className)){
   140|                       arrReturnElements.push(oElement);
   141|                   }
   142|               }
   143|               return (arrReturnElements)
   144|           }
   145|           function hideAll(elems) {
   146|             for (var e = 0; e < elems.length; e++) {
   147|               elems[e].style.display = 'none';
   148|             }
   149|           }
   150|           window.onload = function() {
   151|             hideAll(getElementsByClassName(document, 'table', 'vars'));
   152|             hideAll(getElementsByClassName(document, 'ol', 'pre-context'));
   153|             hideAll(getElementsByClassName(document, 'ol', 'post-context'));
   154|           }
   155|           function toggle() {
   156|             for (var i = 0; i < arguments.length; i++) {
   157|               var e = document.getElementById(arguments[i]);
   158|               if (e) {
   159|                 e.style.display = e.style.display == 'none' ? 'block' : 'none';
   160|               }
   161|             }
   162|             return false;
   163|           }
   164|           function varToggle(link, id) {
   165|             toggle('v' + id);
   166|             var s = link.getElementsByTagName('span')[0];
   167|             var uarr = String.fromCharCode(0x25b6);
   168|             var darr = String.fromCharCode(0x25bc);
   169|             s.innerHTML = s.innerHTML == uarr ? darr : uarr;
   170|             return false;
   171|           }
   172|           //-->
   173|         </script>
   174|       </head>
   175|       <body>
   176|       <div id="summary">
   177|         <h1><%=h exception.class %> at <%=h path %></h1>
   178|         <h2><%=h exception.message %></h2>
   179|         <table><tr>
   180|           <th>Ruby</th>
   181|           <td>
   182|       <% if first = frames.first %>
   183|             <code><%=h first.filename %></code>: in <code><%=h first.function %></code>, line <%=h frames.first.lineno %>
   184|       <% else %>
   185|             unknown location
   186|       <% end %>
   187|           </td>
   188|         </tr><tr>
   189|           <th>Web</th>
   190|           <td><code><%=h req.request_method %> <%=h(req.host + path)%></code></td>
   191|         </tr></table>
   192|         <h3>Jump to:</h3>
   193|         <ul id="quicklinks">
   194|           <li><a href="#get-info">GET</a></li>
   195|           <li><a href="#post-info">POST</a></li>
   196|           <li><a href="#cookie-info">Cookies</a></li>
   197|           <li><a href="#env-info">ENV</a></li>
   198|         </ul>
   199|       </div>
   200|       <div id="traceback">
   201|         <h2>Traceback <span>(innermost first)</span></h2>
   202|         <ul class="traceback">
   203|       <% frames.each { |frame| %>
   204|             <li class="frame">
   205|               <code><%=h frame.filename %></code>: in <code><%=h frame.function %></code>
   206|                 <% if frame.context_line %>
   207|                 <div class="context" id="c<%=h frame.object_id %>">
   208|                     <% if frame.pre_context %>
   209|                     <ol start="<%=h frame.pre_context_lineno+1 %>" class="pre-context" id="pre<%=h frame.object_id %>">
   210|                       <% frame.pre_context.each { |line| %>
   211|                       <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h line %></li>
   212|                       <% } %>
   213|                     </ol>
   214|                     <% end %>
   215|                   <ol start="<%=h frame.lineno %>" class="context-line">
   216|                     <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h frame.context_line %><span>...</span></li></ol>
   217|                     <% if frame.post_context %>
   218|                     <ol start='<%=h frame.lineno+1 %>' class="post-context" id="post<%=h frame.object_id %>">
   219|                       <% frame.post_context.each { |line| %>
   220|                       <li onclick="toggle('pre<%=h frame.object_id %>', 'post<%=h frame.object_id %>')"><%=h line %></li>
   221|                       <% } %>
   222|                     </ol>
   223|                     <% end %>
   224|                 </div>
   225|                 <% end %>
   226|             </li>
   227|       <% } %>
   228|         </ul>
   229|       </div>
   230|       <div id="requestinfo">
   231|         <h2>Request information</h2>
   232|         <h3 id="get-info">GET</h3>
   233|         <% if req.GET and not req.GET.empty? %>
   234|           <table class="req">
   235|             <thead>
   236|               <tr>
   237|                 <th>Variable</th>
   238|                 <th>Value</th>
   239|               </tr>
   240|             </thead>
   241|             <tbody>
   242|                 <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %>
   243|                 <tr>
   244|                   <td><%=h key %></td>
   245|                   <td class="code"><div><%=h val.inspect %></div></td>
   246|                 </tr>
   247|                 <% } %>
   248|             </tbody>
   249|           </table>
   250|         <% else %>
   251|           <p>No GET data.</p>
   252|         <% end %>
   253|         <h3 id="post-info">POST</h3>
   254|         <% if ((req.POST and not req.POST.empty?) rescue (no_post_data = "Invalid POST data"; nil)) %>
   255|           <table class="req">
   256|             <thead>
   257|               <tr>
   258|                 <th>Variable</th>
   259|                 <th>Value</th>
   260|               </tr>
   261|             </thead>
   262|             <tbody>
   263|                 <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %>
   264|                 <tr>
   265|                   <td><%=h key %></td>
   266|                   <td class="code"><div><%=h val.inspect %></div></td>
   267|                 </tr>
   268|                 <% } %>
   269|             </tbody>
   270|           </table>
   271|         <% else %>
   272|           <p><%= no_post_data || "No POST data" %>.</p>
   273|         <% end %>
   274|         <h3 id="cookie-info">COOKIES</h3>
   275|         <% unless req.cookies.empty? %>
   276|           <table class="req">
   277|             <thead>
   278|               <tr>
   279|                 <th>Variable</th>
   280|                 <th>Value</th>
   281|               </tr>
   282|             </thead>
   283|             <tbody>
   284|               <% req.cookies.each { |key, val| %>
   285|                 <tr>
   286|                   <td><%=h key %></td>
   287|                   <td class="code"><div><%=h val.inspect %></div></td>
   288|                 </tr>
   289|               <% } %>
   290|             </tbody>
   291|           </table>
   292|         <% else %>
   293|           <p>No cookie data.</p>
   294|         <% end %>
   295|         <h3 id="env-info">Rack ENV</h3>
   296|           <table class="req">
   297|             <thead>
   298|               <tr>
   299|                 <th>Variable</th>
   300|                 <th>Value</th>
   301|               </tr>
   302|             </thead>
   303|             <tbody>
   304|                 <% env.sort_by { |k, v| k.to_s }.each { |key, val| %>
   305|                 <tr>
   306|                   <td><%=h key %></td>
   307|                   <td class="code"><div><%=h val.inspect %></div></td>
   308|                 </tr>
   309|                 <% } %>
   310|             </tbody>
   311|           </table>
   312|       </div>
   313|       <div id="explanation">
   314|         <p>
   315|           You're seeing this error because you use <code>Rack::ShowExceptions</code>.
   316|         </p>
   317|       </div>
   318|       </body>
   319|       </html>
   320|     HTML
   321|   end
   322| end


# ====================================================================
# FILE: lib/rack/show_status.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| require 'erb'
     2| module Rack
     3|   class ShowStatus
     4|     def initialize(app)
     5|       @app = app
     6|       @template = ERB.new(TEMPLATE)
     7|     end
     8|     def call(env)
     9|       status, headers, body = @app.call(env)
    10|       headers = Utils::HeaderHash[headers]
    11|       empty = headers[CONTENT_LENGTH].to_i <= 0
    12|       if (status.to_i >= 400 && empty) || env[RACK_SHOWSTATUS_DETAIL]
    13|         req = req = Rack::Request.new(env)
    14|         message = Rack::Utils::HTTP_STATUS_CODES[status.to_i] || status.to_s
    15|         detail = detail = env[RACK_SHOWSTATUS_DETAIL] || message
    16|         body = @template.result(binding)
    17|         size = body.bytesize
    18|         [status, headers.merge(CONTENT_TYPE => "text/html", CONTENT_LENGTH => size.to_s), [body]]
    19|       else
    20|         [status, headers, body]
    21|       end
    22|     end
    23|     def h(obj)                  # :nodoc:
    24|       case obj
    25|       when String
    26|         Utils.escape_html(obj)
    27|       else
    28|         Utils.escape_html(obj.inspect)
    29|       end
    30|     end
    31| TEMPLATE = <<'HTML'
    32| <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    33| <html lang="en">
    34| <head>
    35|   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    36|   <title><%=h message %> at <%=h req.script_name + req.path_info %></title>
    37|   <meta name="robots" content="NONE,NOARCHIVE" />
    38|   <style type="text/css">
    39|     html * { padding:0; margin:0; }
    40|     body * { padding:10px 20px; }
    41|     body * * { padding:0; }
    42|     body { font:small sans-serif; background:#eee; }
    43|     body>div { border-bottom:1px solid #ddd; }
    44|     h1 { font-weight:normal; margin-bottom:.4em; }
    45|     h1 span { font-size:60%; color:#666; font-weight:normal; }
    46|     table { border:none; border-collapse: collapse; width:100%; }
    47|     td, th { vertical-align:top; padding:2px 3px; }
    48|     th { width:12em; text-align:right; color:#666; padding-right:.5em; }
    49|   </style>
    50| </head>
    51| <body>
    52|   <div id="summary">
    53|     <h1><%=h message %> <span>(<%= status.to_i %>)</span></h1>
    54|     <table class="meta">
    55|       <tr>
    56|         <th>Request Method:</th>
    57|         <td><%=h req.request_method %></td>
    58|       </tr>
    59|       <tr>
    60|         <th>Request URL:</th>
    61|       <td><%=h req.url %></td>
    62|       </tr>
    63|     </table>
    64|   </div>
    65|   <div id="info">
    66|     <p><%=h detail %></p>
    67|   </div>
    68|   <div id="explanation">
    69|     <p>
    70|     You're seeing this error because you use <code>Rack::ShowStatus</code>.
    71|     </p>
    72|   </div>
    73| </body>
    74| </html>
    75| HTML
    76|   end
    77| end


# ====================================================================
# FILE: lib/rack/static.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| module Rack
     2|   class Static
     3|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
     4|     def initialize(app, options = {})
     5|       @app = app
     6|       @urls = options[:urls] || ["/favicon.ico"]
     7|       @index = options[:index]
     8|       @gzip = options[:gzip]
     9|       @cascade = options[:cascade]
    10|       root = options[:root] || Dir.pwd
    11|       @header_rules = options[:header_rules] || []
    12|       @header_rules.unshift([:all, { CACHE_CONTROL => options[:cache_control] }]) if options[:cache_control]
    13|       @file_server = Rack::Files.new(root)
    14|     end
    15|     def add_index_root?(path)
    16|       @index && route_file(path) && path.end_with?('/')
    17|     end
    18|     def overwrite_file_path(path)
    19|       @urls.kind_of?(Hash) && @urls.key?(path) || add_index_root?(path)
    20|     end
    21|     def route_file(path)
    22|       @urls.kind_of?(Array) && @urls.any? { |url| path.index(url) == 0 }
    23|     end
    24|     def can_serve(path)
    25|       route_file(path) || overwrite_file_path(path)
    26|     end
    27|     def call(env)
    28|       path = env[PATH_INFO]
    29|       if can_serve(path)
    30|         if overwrite_file_path(path)
    31|           env[PATH_INFO] = (add_index_root?(path) ? path + @index : @urls[path])
    32|         elsif @gzip && env['HTTP_ACCEPT_ENCODING'] && /\bgzip\b/.match?(env['HTTP_ACCEPT_ENCODING'])
    33|           path = env[PATH_INFO]
    34|           env[PATH_INFO] += '.gz'
    35|           response = @file_server.call(env)
    36|           env[PATH_INFO] = path
    37|           if response[0] == 404
    38|             response = nil
    39|           elsif response[0] == 304
    40|           else
    41|             if mime_type = Mime.mime_type(::File.extname(path), 'text/plain')
    42|               response[1][CONTENT_TYPE] = mime_type
    43|             end
    44|             response[1]['Content-Encoding'] = 'gzip'
    45|           end
    46|         end
    47|         path = env[PATH_INFO]
    48|         response ||= @file_server.call(env)
    49|         if @cascade && response[0] == 404
    50|           return @app.call(env)
    51|         end
    52|         headers = response[1]
    53|         applicable_rules(path).each do |rule, new_headers|
    54|           new_headers.each { |field, content| headers[field] = content }
    55|         end
    56|         response
    57|       else
    58|         @app.call(env)
    59|       end
    60|     end
    61|     def applicable_rules(path)
    62|       @header_rules.find_all do |rule, new_headers|
    63|         case rule
    64|         when :all
    65|           true
    66|         when :fonts
    67|           /\.(?:ttf|otf|eot|woff2|woff|svg)\z/.match?(path)
    68|         when String
    69|           path = ::Rack::Utils.unescape(path)
    70|           path.start_with?(rule) || path.start_with?('/' + rule)
    71|         when Array
    72|           /\.(#{rule.join('|')})\z/.match?(path)
    73|         when Regexp
    74|           rule.match?(path)
    75|         else
    76|           false
    77|         end
    78|       end
    79|     end
    80|   end
    81| end


# ====================================================================
# FILE: lib/rack/tempfile_reaper.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| module Rack
     2|   class TempfileReaper
     3|     def initialize(app)
     4|       @app = app
     5|     end
     6|     def call(env)
     7|       env[RACK_TEMPFILES] ||= []
     8|       status, headers, body = @app.call(env)
     9|       body_proxy = BodyProxy.new(body) do
    10|         env[RACK_TEMPFILES].each(&:close!) unless env[RACK_TEMPFILES].nil?
    11|       end
    12|       [status, headers, body_proxy]
    13|     end
    14|   end
    15| end


# ====================================================================
# FILE: lib/rack/urlmap.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| require 'set'
     2| module Rack
     3|   class URLMap
     4|     def initialize(map = {})
     5|       remap(map)
     6|     end
     7|     def remap(map)
     8|       @known_hosts = Set[]
     9|       @mapping = map.map { |location, app|
    10|         if location =~ %r{\Ahttps?://(.*?)(/.*)}
    11|           host, location = $1, $2
    12|           @known_hosts << host
    13|         else
    14|           host = nil
    15|         end
    16|         unless location[0] == ?/
    17|           raise ArgumentError, "paths need to start with /"
    18|         end
    19|         location = location.chomp('/')
    20|         match = Regexp.new("^#{Regexp.quote(location).gsub('/', '/+')}(.*)", nil, 'n')
    21|         [host, location, match, app]
    22|       }.sort_by do |(host, location, _, _)|
    23|         [host ? -host.size : Float::INFINITY, -location.size]
    24|       end
    25|     end
    26|     def call(env)
    27|       path        = env[PATH_INFO]
    28|       script_name = env[SCRIPT_NAME]
    29|       http_host   = env[HTTP_HOST]
    30|       server_name = env[SERVER_NAME]
    31|       server_port = env[SERVER_PORT]
    32|       is_same_server = casecmp?(http_host, server_name) ||
    33|                        casecmp?(http_host, "#{server_name}:#{server_port}")
    34|       is_host_known = @known_hosts.include? http_host
    35|       @mapping.each do |host, location, match, app|
    36|         unless casecmp?(http_host, host) \
    37|             || casecmp?(server_name, host) \
    38|             || (!host && is_same_server) \
    39|             || (!host && !is_host_known) # If we don't have a matching host, default to the first without a specified host
    40|           next
    41|         end
    42|         next unless m = match.match(path.to_s)
    43|         rest = m[1]
    44|         next unless !rest || rest.empty? || rest[0] == ?/
    45|         env[SCRIPT_NAME] = (script_name + location)
    46|         env[PATH_INFO] = rest
    47|         return app.call(env)
    48|       end
    49|       [404, { CONTENT_TYPE => "text/plain", "X-Cascade" => "pass" }, ["Not Found: #{path}"]]
    50|     ensure
    51|       env[PATH_INFO]   = path
    52|       env[SCRIPT_NAME] = script_name
    53|     end
    54|     private
    55|     def casecmp?(v1, v2)
    56|       return true if v1 == v2
    57|       return false if v1.nil?
    58|       return false if v2.nil?
    59|       v1.casecmp(v2).zero?
    60|     end
    61|   end
    62| end


# ====================================================================
# FILE: lib/rack/utils.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-453 ---
     1| require 'uri'
     2| require 'fileutils'
     3| require 'set'
     4| require 'tempfile'
     5| require 'time'
     6| require_relative 'query_parser'
     7| module Rack
     8|   module Utils
     9|     (require_relative 'core_ext/regexp'; using ::Rack::RegexpExtensions) if RUBY_VERSION < '2.4'
    10|     ParameterTypeError = QueryParser::ParameterTypeError
    11|     InvalidParameterError = QueryParser::InvalidParameterError
    12|     DEFAULT_SEP = QueryParser::DEFAULT_SEP
    13|     COMMON_SEP = QueryParser::COMMON_SEP
    14|     KeySpaceConstrainedParams = QueryParser::Params
    15|     class << self
    16|       attr_accessor :default_query_parser
    17|     end
    18|     self.default_query_parser = QueryParser.make_default(65536, 100)
    19|     module_function
    20|     def escape(s)
    21|       URI.encode_www_form_component(s)
    22|     end
    23|     def escape_path(s)
    24|       ::URI::DEFAULT_PARSER.escape s
    25|     end
    26|     def unescape_path(s)
    27|       ::URI::DEFAULT_PARSER.unescape s
    28|     end
    29|     def unescape(s, encoding = Encoding::UTF_8)
    30|       URI.decode_www_form_component(s, encoding)
    31|     end
    32|     class << self
    33|       attr_accessor :multipart_part_limit
    34|     end
    35|     self.multipart_part_limit = (ENV['RACK_MULTIPART_PART_LIMIT'] || 128).to_i
    36|     def self.param_depth_limit
    37|       default_query_parser.param_depth_limit
    38|     end
    39|     def self.param_depth_limit=(v)
    40|       self.default_query_parser = self.default_query_parser.new_depth_limit(v)
    41|     end
    42|     def self.key_space_limit
    43|       default_query_parser.key_space_limit
    44|     end
    45|     def self.key_space_limit=(v)
    46|       self.default_query_parser = self.default_query_parser.new_space_limit(v)
    47|     end
    48|     if defined?(Process::CLOCK_MONOTONIC)
    49|       def clock_time
    50|         Process.clock_gettime(Process::CLOCK_MONOTONIC)
    51|       end
    52|     else
    53|       def clock_time
    54|         Time.now.to_f
    55|       end
    56|     end
    57|     def parse_query(qs, d = nil, &unescaper)
    58|       Rack::Utils.default_query_parser.parse_query(qs, d, &unescaper)
    59|     end
    60|     def parse_nested_query(qs, d = nil)
    61|       Rack::Utils.default_query_parser.parse_nested_query(qs, d)
    62|     end
    63|     def build_query(params)
    64|       params.map { |k, v|
    65|         if v.class == Array
    66|           build_query(v.map { |x| [k, x] })
    67|         else
    68|           v.nil? ? escape(k) : "#{escape(k)}=#{escape(v)}"
    69|         end
    70|       }.join("&")
    71|     end
    72|     def build_nested_query(value, prefix = nil)
    73|       case value
    74|       when Array
    75|         value.map { |v|
    76|           build_nested_query(v, "#{prefix}[]")
    77|         }.join("&")
    78|       when Hash
    79|         value.map { |k, v|
    80|           build_nested_query(v, prefix ? "#{prefix}[#{escape(k)}]" : escape(k))
    81|         }.delete_if(&:empty?).join('&')
    82|       when nil
    83|         prefix
    84|       else
    85|         raise ArgumentError, "value must be a Hash" if prefix.nil?
    86|         "#{prefix}=#{escape(value)}"
    87|       end
    88|     end
    89|     def q_values(q_value_header)
    90|       q_value_header.to_s.split(/\s*,\s*/).map do |part|
    91|         value, parameters = part.split(/\s*;\s*/, 2)
    92|         quality = 1.0
    93|         if parameters && (md = /\Aq=([\d.]+)/.match(parameters))
    94|           quality = md[1].to_f
    95|         end
    96|         [value, quality]
    97|       end
    98|     end
    99|     def best_q_match(q_value_header, available_mimes)
   100|       values = q_values(q_value_header)
   101|       matches = values.map do |req_mime, quality|
   102|         match = available_mimes.find { |am| Rack::Mime.match?(am, req_mime) }
   103|         next unless match
   104|         [match, quality]
   105|       end.compact.sort_by do |match, quality|
   106|         (match.split('/', 2).count('*') * -10) + quality
   107|       end.last
   108|       matches && matches.first
   109|     end
   110|     ESCAPE_HTML = {
   111|       "&" => "&amp;",
   112|       "<" => "&lt;",
   113|       ">" => "&gt;",
   114|       "'" => "&#x27;",
   115|       '"' => "&quot;",
   116|       "/" => "&#x2F;"
   117|     }
   118|     ESCAPE_HTML_PATTERN = Regexp.union(*ESCAPE_HTML.keys)
   119|     def escape_html(string)
   120|       string.to_s.gsub(ESCAPE_HTML_PATTERN){|c| ESCAPE_HTML[c] }
   121|     end
   122|     def select_best_encoding(available_encodings, accept_encoding)
   123|       expanded_accept_encoding = []
   124|       accept_encoding.each do |m, q|
   125|         preference = available_encodings.index(m) || available_encodings.size
   126|         if m == "*"
   127|           (available_encodings - accept_encoding.map(&:first)).each do |m2|
   128|             expanded_accept_encoding << [m2, q, preference]
   129|           end
   130|         else
   131|           expanded_accept_encoding << [m, q, preference]
   132|         end
   133|       end
   134|       encoding_candidates = expanded_accept_encoding
   135|         .sort_by { |_, q, p| [-q, p] }
   136|         .map!(&:first)
   137|       unless encoding_candidates.include?("identity")
   138|         encoding_candidates.push("identity")
   139|       end
   140|       expanded_accept_encoding.each do |m, q|
   141|         encoding_candidates.delete(m) if q == 0.0
   142|       end
   143|       (encoding_candidates & available_encodings)[0]
   144|     end
   145|     def parse_cookies(env)
   146|       parse_cookies_header env[HTTP_COOKIE]
   147|     end
   148|     def parse_cookies_header(header)
   149|       cookies = parse_query(header, ';') { |s| unescape(s) rescue s }
   150|       cookies.each_with_object({}) { |(k, v), hash| hash[k] = Array === v ? v.first : v }
   151|     end
   152|     def add_cookie_to_header(header, key, value)
   153|       case value
   154|       when Hash
   155|         domain  = "; domain=#{value[:domain]}"   if value[:domain]
   156|         path    = "; path=#{value[:path]}"       if value[:path]
   157|         max_age = "; max-age=#{value[:max_age]}" if value[:max_age]
   158|         expires = "; expires=#{value[:expires].httpdate}" if value[:expires]
   159|         secure = "; secure"  if value[:secure]
   160|         httponly = "; HttpOnly" if (value.key?(:httponly) ? value[:httponly] : value[:http_only])
   161|         same_site =
   162|           case value[:same_site]
   163|           when false, nil
   164|             nil
   165|           when :none, 'None', :None
   166|             '; SameSite=None'
   167|           when :lax, 'Lax', :Lax
   168|             '; SameSite=Lax'
   169|           when true, :strict, 'Strict', :Strict
   170|             '; SameSite=Strict'
   171|           else
   172|             raise ArgumentError, "Invalid SameSite value: #{value[:same_site].inspect}"
   173|           end
   174|         value = value[:value]
   175|       end
   176|       value = [value] unless Array === value
   177|       cookie = "#{escape(key)}=#{value.map { |v| escape v }.join('&')}#{domain}" \
   178|         "#{path}#{max_age}#{expires}#{secure}#{httponly}#{same_site}"
   179|       case header
   180|       when nil, ''
   181|         cookie
   182|       when String
   183|         [header, cookie].join("\n")
   184|       when Array
   185|         (header + [cookie]).join("\n")
   186|       else
   187|         raise ArgumentError, "Unrecognized cookie header value. Expected String, Array, or nil, got #{header.inspect}"
   188|       end
   189|     end
   190|     def set_cookie_header!(header, key, value)
   191|       header[SET_COOKIE] = add_cookie_to_header(header[SET_COOKIE], key, value)
   192|       nil
   193|     end
   194|     def make_delete_cookie_header(header, key, value)
   195|       case header
   196|       when nil, ''
   197|         cookies = []
   198|       when String
   199|         cookies = header.split("\n")
   200|       when Array
   201|         cookies = header
   202|       end
   203|       key = escape(key)
   204|       domain = value[:domain]
   205|       path = value[:path]
   206|       regexp = if domain
   207|                  if path
   208|                    /\A#{key}=.*(?:domain=#{domain}(?:;|$).*path=#{path}(?:;|$)|path=#{path}(?:;|$).*domain=#{domain}(?:;|$))/
   209|                  else
   210|                    /\A#{key}=.*domain=#{domain}(?:;|$)/
   211|                  end
   212|                elsif path
   213|                  /\A#{key}=.*path=#{path}(?:;|$)/
   214|                else
   215|                  /\A#{key}=/
   216|                end
   217|       cookies.reject! { |cookie| regexp.match? cookie }
   218|       cookies.join("\n")
   219|     end
   220|     def delete_cookie_header!(header, key, value = {})
   221|       header[SET_COOKIE] = add_remove_cookie_to_header(header[SET_COOKIE], key, value)
   222|       nil
   223|     end
   224|     def add_remove_cookie_to_header(header, key, value = {})
   225|       new_header = make_delete_cookie_header(header, key, value)
   226|       add_cookie_to_header(new_header, key,
   227|                  { value: '', path: nil, domain: nil,
   228|                    max_age: '0',
   229|                    expires: Time.at(0) }.merge(value))
   230|     end
   231|     def rfc2822(time)
   232|       time.rfc2822
   233|     end
   234|     def rfc2109(time)
   235|       wday = Time::RFC2822_DAY_NAME[time.wday]
   236|       mon = Time::RFC2822_MONTH_NAME[time.mon - 1]
   237|       time.strftime("#{wday}, %d-#{mon}-%Y %H:%M:%S GMT")
   238|     end
   239|     def byte_ranges(env, size)
   240|       warn "`byte_ranges` is deprecated, please use `get_byte_ranges`" if $VERBOSE
   241|       get_byte_ranges env['HTTP_RANGE'], size
   242|     end
   243|     def get_byte_ranges(http_range, size)
   244|       return nil unless http_range && http_range =~ /bytes=([^;]+)/
   245|       ranges = []
   246|       $1.split(/,\s*/).each do |range_spec|
   247|         return nil  unless range_spec =~ /(\d*)-(\d*)/
   248|         r0, r1 = $1, $2
   249|         if r0.empty?
   250|           return nil  if r1.empty?
   251|           r0 = size - r1.to_i
   252|           r0 = 0  if r0 < 0
   253|           r1 = size - 1
   254|         else
   255|           r0 = r0.to_i
   256|           if r1.empty?
   257|             r1 = size - 1
   258|           else
   259|             r1 = r1.to_i
   260|             return nil  if r1 < r0  # backwards range is syntactically invalid
   261|             r1 = size - 1  if r1 >= size
   262|           end
   263|         end
   264|         ranges << (r0..r1)  if r0 <= r1
   265|       end
   266|       ranges
   267|     end
   268|     def secure_compare(a, b)
   269|       return false unless a.bytesize == b.bytesize
   270|       l = a.unpack("C*")
   271|       r, i = 0, -1
   272|       b.each_byte { |v| r |= v ^ l[i += 1] }
   273|       r == 0
   274|     end
   275|     class Context
   276|       attr_reader :for, :app
   277|       def initialize(app_f, app_r)
   278|         raise 'running context does not respond to #context' unless app_f.respond_to? :context
   279|         @for, @app = app_f, app_r
   280|       end
   281|       def call(env)
   282|         @for.context(env, @app)
   283|       end
   284|       def recontext(app)
   285|         self.class.new(@for, app)
   286|       end
   287|       def context(env, app = @app)
   288|         recontext(app).call(env)
   289|       end
   290|     end
   291|     class HeaderHash < Hash # :nodoc:
   292|       def self.[](headers)
   293|         if headers.is_a?(HeaderHash) && !headers.frozen?
   294|           return headers
   295|         else
   296|           return self.new(headers)
   297|         end
   298|       end
   299|       def initialize(hash = {})
   300|         super()
   301|         @names = {}
   302|         hash.each { |k, v| self[k] = v }
   303|       end
   304|       def initialize_copy(other)
   305|         super
   306|         @names = other.names.dup
   307|       end
   308|       def clear
   309|         super
   310|         @names.clear
   311|       end
   312|       def each
   313|         super do |k, v|
   314|           yield(k, v.respond_to?(:to_ary) ? v.to_ary.join("\n") : v)
   315|         end
   316|       end
   317|       def to_hash
   318|         hash = {}
   319|         each { |k, v| hash[k] = v }
   320|         hash
   321|       end
   322|       def [](k)
   323|         super(k) || super(@names[k.downcase])
   324|       end
   325|       def []=(k, v)
   326|         canonical = k.downcase.freeze
   327|         delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
   328|         @names[canonical] = k
   329|         super k, v
   330|       end
   331|       def delete(k)
   332|         canonical = k.downcase
   333|         result = super @names.delete(canonical)
   334|         result
   335|       end
   336|       def include?(k)
   337|         super || @names.include?(k.downcase)
   338|       end
   339|       alias_method :has_key?, :include?
   340|       alias_method :member?, :include?
   341|       alias_method :key?, :include?
   342|       def merge!(other)
   343|         other.each { |k, v| self[k] = v }
   344|         self
   345|       end
   346|       def merge(other)
   347|         hash = dup
   348|         hash.merge! other
   349|       end
   350|       def replace(other)
   351|         clear
   352|         other.each { |k, v| self[k] = v }
   353|         self
   354|       end
   355|       protected
   356|         def names
   357|           @names
   358|         end
   359|     end
   360|     HTTP_STATUS_CODES = {
   361|       100 => 'Continue',
   362|       101 => 'Switching Protocols',
   363|       102 => 'Processing',
   364|       103 => 'Early Hints',
   365|       200 => 'OK',
   366|       201 => 'Created',
   367|       202 => 'Accepted',
   368|       203 => 'Non-Authoritative Information',
   369|       204 => 'No Content',
   370|       205 => 'Reset Content',
   371|       206 => 'Partial Content',
   372|       207 => 'Multi-Status',
   373|       208 => 'Already Reported',
   374|       226 => 'IM Used',
   375|       300 => 'Multiple Choices',
   376|       301 => 'Moved Permanently',
   377|       302 => 'Found',
   378|       303 => 'See Other',
   379|       304 => 'Not Modified',
   380|       305 => 'Use Proxy',
   381|       306 => '(Unused)',
   382|       307 => 'Temporary Redirect',
   383|       308 => 'Permanent Redirect',
   384|       400 => 'Bad Request',
   385|       401 => 'Unauthorized',
   386|       402 => 'Payment Required',
   387|       403 => 'Forbidden',
   388|       404 => 'Not Found',
   389|       405 => 'Method Not Allowed',
   390|       406 => 'Not Acceptable',
   391|       407 => 'Proxy Authentication Required',
   392|       408 => 'Request Timeout',
   393|       409 => 'Conflict',
   394|       410 => 'Gone',
   395|       411 => 'Length Required',
   396|       412 => 'Precondition Failed',
   397|       413 => 'Payload Too Large',
   398|       414 => 'URI Too Long',
   399|       415 => 'Unsupported Media Type',
   400|       416 => 'Range Not Satisfiable',
   401|       417 => 'Expectation Failed',
   402|       421 => 'Misdirected Request',
   403|       422 => 'Unprocessable Entity',
   404|       423 => 'Locked',
   405|       424 => 'Failed Dependency',
   406|       425 => 'Too Early',
   407|       426 => 'Upgrade Required',
   408|       428 => 'Precondition Required',
   409|       429 => 'Too Many Requests',
   410|       431 => 'Request Header Fields Too Large',
   411|       451 => 'Unavailable for Legal Reasons',
   412|       500 => 'Internal Server Error',
   413|       501 => 'Not Implemented',
   414|       502 => 'Bad Gateway',
   415|       503 => 'Service Unavailable',
   416|       504 => 'Gateway Timeout',
   417|       505 => 'HTTP Version Not Supported',
   418|       506 => 'Variant Also Negotiates',
   419|       507 => 'Insufficient Storage',
   420|       508 => 'Loop Detected',
   421|       509 => 'Bandwidth Limit Exceeded',
   422|       510 => 'Not Extended',
   423|       511 => 'Network Authentication Required'
   424|     }
   425|     STATUS_WITH_NO_ENTITY_BODY = Hash[((100..199).to_a << 204 << 304).product([true])]
   426|     SYMBOL_TO_STATUS_CODE = Hash[*HTTP_STATUS_CODES.map { |code, message|
   427|       [message.downcase.gsub(/\s|-|'/, '_').to_sym, code]
   428|     }.flatten]
   429|     def status_code(status)
   430|       if status.is_a?(Symbol)
   431|         SYMBOL_TO_STATUS_CODE.fetch(status) { raise ArgumentError, "Unrecognized status code #{status.inspect}" }
   432|       else
   433|         status.to_i
   434|       end
   435|     end
   436|     PATH_SEPS = Regexp.union(*[::File::SEPARATOR, ::File::ALT_SEPARATOR].compact)
   437|     def clean_path_info(path_info)
   438|       parts = path_info.split PATH_SEPS
   439|       clean = []
   440|       parts.each do |part|
   441|         next if part.empty? || part == '.'
   442|         part == '..' ? clean.pop : clean << part
   443|       end
   444|       clean_path = clean.join(::File::SEPARATOR)
   445|       clean_path.prepend("/") if parts.empty? || parts.first.empty?
   446|       clean_path
   447|     end
   448|     NULL_BYTE = "\0"
   449|     def valid_path?(path)
   450|       path.valid_encoding? && !path.include?(NULL_BYTE)
   451|     end
   452|   end
   453| end


# ====================================================================
# FILE: lib/rack/version.rb
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| module Rack
     2|   VERSION = [1, 3]
     3|   def self.version
     4|     VERSION.join(".")
     5|   end
     6|   RELEASE = "2.2.0"
     7|   def self.release
     8|     RELEASE
     9|   end
    10| end

