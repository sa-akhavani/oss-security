--- a//dev/null
+++ b/decidim-accountability/app/cells/decidim/accountability/highlighted_results_for_component_cell.rb
@@ -0,0 +1,35 @@
+require "cell/partial"
+module Decidim
+  module Accountability
+    class HighlightedResultsForComponentCell < Decidim::ViewModel
+      include ActiveSupport::NumberHelper
+      include Decidim::Accountability::ApplicationHelper
+      include Decidim::ComponentPathHelper
+      include Decidim::LayoutHelper
+      include Cell::ViewModel::Partial
+      def show
+        render unless results_count.zero?
+      end
+      private
+      def results
+        @results ||= Decidim::Accountability::Result.where(component: model).order_randomly((rand * 2) - 1)
+      end
+      def results_to_render
+        @results_to_render ||= results.includes(:component, :status).limit(4)
+      end
+      def results_count
+        @results_count ||= results.count
+      end
+      def cache_hash
+        hash = []
+        hash << "decidim/accountability/highlighted_results_for_component"
+        hash << results.cache_key_with_version
+        hash << I18n.locale.to_s
+        hash.join(Decidim.cache_key_separator)
+      end
+      def cache_expiry_time
+        10.minutes
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/create_imported_result.rb
@@ -0,0 +1,84 @@
+module Decidim
+  module Accountability
+    module Admin
+      class CreateImportedResult < Decidim::Command
+        def initialize(form, parent_id = nil)
+          @form = form
+          @parent_id = parent_id
+        end
+        def call
+          return broadcast(:invalid) if @form.invalid?
+          transaction do
+            create_result
+            link_meetings
+            link_proposals
+            link_projects
+            notify_proposal_followers
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :result
+        def create_result
+          params = {
+            component: @form.current_component,
+            scope: @form.scope,
+            category: @form.category,
+            parent_id: @parent_id,
+            title: @form.title,
+            description: @form.description,
+            start_date: @form.start_date,
+            end_date: @form.end_date,
+            progress: @form.progress,
+            decidim_accountability_status_id: @form.decidim_accountability_status_id,
+            external_id: @form.external_id.presence,
+            weight: @form.weight
+          }
+          @result = Decidim.traceability.create!(
+            Result,
+            @form.current_user,
+            params,
+            visibility: "all"
+          )
+        end
+        def proposals
+          @proposals ||= result.sibling_scope(:proposals).where(id: @form.proposal_ids)
+        end
+        def projects
+          @projects ||= result.sibling_scope(:projects).where(id: @form.project_ids)
+        end
+        def meeting_ids
+          @meeting_ids ||= proposals.flat_map do |proposal|
+            proposal.linked_resources(:meetings, "proposals_from_meeting").pluck(:id)
+          end.uniq
+        end
+        def meetings
+          @meetings ||= result.sibling_scope(:meetings).where(id: meeting_ids)
+        end
+        def link_proposals
+          result.link_resources(proposals, "included_proposals")
+        end
+        def link_projects
+          result.link_resources(projects, "included_projects")
+        end
+        def link_meetings
+          result.link_resources(meetings, "meetings_through_proposals")
+        end
+        def notify_proposal_followers
+          proposals.each do |proposal|
+            Decidim::EventsManager.publish(
+              event: "decidim.events.accountability.proposal_linked",
+              event_class: Decidim::Accountability::ProposalLinkedEvent,
+              resource: result,
+              affected_users: proposal.notifiable_identities,
+              followers: proposal.followers - proposal.notifiable_identities,
+              extra: {
+                proposal_id: proposal.id
+              }
+            )
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/create_result.rb
@@ -0,0 +1,83 @@
+module Decidim
+  module Accountability
+    module Admin
+      class CreateResult < Decidim::Command
+        def initialize(form)
+          @form = form
+        end
+        def call
+          return broadcast(:invalid) if @form.invalid?
+          transaction do
+            create_result
+            link_meetings
+            link_proposals
+            link_projects
+            notify_proposal_followers
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :result
+        def create_result
+          params = {
+            component: @form.current_component,
+            scope: @form.scope,
+            category: @form.category,
+            parent_id: @form.parent_id,
+            title: @form.title,
+            description: @form.description,
+            start_date: @form.start_date,
+            end_date: @form.end_date,
+            progress: @form.progress,
+            decidim_accountability_status_id: @form.decidim_accountability_status_id,
+            external_id: @form.external_id.presence,
+            weight: @form.weight
+          }
+          @result = Decidim.traceability.create!(
+            Result,
+            @form.current_user,
+            params,
+            visibility: "all"
+          )
+        end
+        def proposals
+          @proposals ||= result.sibling_scope(:proposals).where(id: @form.proposal_ids)
+        end
+        def projects
+          @projects ||= result.sibling_scope(:projects).where(id: @form.project_ids)
+        end
+        def meeting_ids
+          @meeting_ids ||= proposals.flat_map do |proposal|
+            proposal.linked_resources(:meetings, "proposals_from_meeting").pluck(:id)
+          end.uniq
+        end
+        def meetings
+          @meetings ||= result.sibling_scope(:meetings).where(id: meeting_ids)
+        end
+        def link_proposals
+          result.link_resources(proposals, "included_proposals")
+        end
+        def link_projects
+          result.link_resources(projects, "included_projects")
+        end
+        def link_meetings
+          result.link_resources(meetings, "meetings_through_proposals")
+        end
+        def notify_proposal_followers
+          proposals.each do |proposal|
+            Decidim::EventsManager.publish(
+              event: "decidim.events.accountability.proposal_linked",
+              event_class: Decidim::Accountability::ProposalLinkedEvent,
+              resource: result,
+              affected_users: proposal.notifiable_identities,
+              followers: proposal.followers - proposal.notifiable_identities,
+              extra: {
+                proposal_id: proposal.id
+              }
+            )
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/create_status.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Accountability
+    module Admin
+      class CreateStatus < Decidim::Command
+        def initialize(form, user)
+          @form = form
+          @user = user
+        end
+        def call
+          return broadcast(:invalid) if @form.invalid?
+          transaction do
+            create_status
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :status
+        def create_status
+          @status = Decidim.traceability.create!(
+            Status,
+            @user,
+            component: @form.current_component,
+            key: @form.key,
+            name: @form.name,
+            description: @form.description,
+            progress: @form.progress
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/create_timeline_entry.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Accountability
+    module Admin
+      class CreateTimelineEntry < Decidim::Command
+        def initialize(form, user)
+          @form = form
+          @user = user
+        end
+        def call
+          return broadcast(:invalid) if @form.invalid?
+          transaction do
+            create_timeline_entry
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :timeline_entry, :form
+        def create_timeline_entry
+          @timeline_entry = Decidim.traceability.create!(
+            TimelineEntry,
+            @user,
+            decidim_accountability_result_id: form.decidim_accountability_result_id,
+            entry_date: form.entry_date,
+            title: form.title,
+            description: form.description
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/destroy_result.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Accountability
+    module Admin
+      class DestroyResult < Decidim::Command
+        def initialize(result, current_user)
+          @result = result
+          @current_user = current_user
+        end
+        def call
+          destroy_result
+          broadcast(:ok)
+        end
+        private
+        attr_reader :result, :current_user
+        def destroy_result
+          Decidim.traceability.perform_action!(
+            :delete,
+            result,
+            current_user
+          ) do
+            result.destroy!
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/update_imported_result.rb
@@ -0,0 +1,84 @@
+module Decidim
+  module Accountability
+    module Admin
+      class UpdateImportedResult < Decidim::Command
+        def initialize(form, result, parent_id = nil)
+          @form = form
+          @result = result
+          @parent_id = parent_id
+        end
+        def call
+          return broadcast(:invalid) if form.invalid?
+          transaction do
+            update_result
+            link_proposals
+            link_meetings
+            link_projects
+            send_notifications if should_notify_followers?
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :result, :form
+        def update_result
+          Decidim.traceability.update!(
+            result,
+            form.current_user,
+            scope: @form.scope,
+            category: @form.category,
+            parent_id: @parent_id,
+            title: @form.title,
+            description: @form.description,
+            start_date: @form.start_date,
+            end_date: @form.end_date,
+            progress: @form.progress,
+            decidim_accountability_status_id: @form.decidim_accountability_status_id,
+            external_id: @form.external_id.presence,
+            weight: @form.weight
+          )
+        end
+        def proposals
+          @proposals ||= result.sibling_scope(:proposals).where(id: form.proposal_ids)
+        end
+        def projects
+          @projects ||= result.sibling_scope(:projects).where(id: form.project_ids)
+        end
+        def meeting_ids
+          @meeting_ids ||= proposals.flat_map do |proposal|
+            proposal.linked_resources(:meetings, "proposals_from_meeting").pluck(:id)
+          end.uniq
+        end
+        def meetings
+          @meetings ||= result.sibling_scope(:meetings).where(id: meeting_ids)
+        end
+        def link_proposals
+          result.link_resources(proposals, "included_proposals")
+        end
+        def link_projects
+          result.link_resources(projects, "included_projects")
+        end
+        def link_meetings
+          result.link_resources(meetings, "meetings_through_proposals")
+        end
+        def send_notifications
+          result.linked_resources(:proposals, "included_proposals").each do |proposal|
+            Decidim::EventsManager.publish(
+              event: "decidim.events.accountability.result_progress_updated",
+              event_class: Decidim::Accountability::ResultProgressUpdatedEvent,
+              resource: result,
+              affected_users: proposal.notifiable_identities,
+              followers: proposal.followers - proposal.notifiable_identities,
+              extra: {
+                progress: result.progress,
+                proposal_id: proposal.id
+              }
+            )
+          end
+        end
+        def should_notify_followers?
+          result.previous_changes["progress"].present?
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/update_result.rb
@@ -0,0 +1,83 @@
+module Decidim
+  module Accountability
+    module Admin
+      class UpdateResult < Decidim::Command
+        def initialize(form, result)
+          @form = form
+          @result = result
+        end
+        def call
+          return broadcast(:invalid) if form.invalid?
+          transaction do
+            update_result
+            link_proposals
+            link_meetings
+            link_projects
+            send_notifications if should_notify_followers?
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :result, :form
+        def update_result
+          Decidim.traceability.update!(
+            result,
+            form.current_user,
+            scope: @form.scope,
+            category: @form.category,
+            parent_id: @form.parent_id,
+            title: @form.title,
+            description: @form.description,
+            start_date: @form.start_date,
+            end_date: @form.end_date,
+            progress: @form.progress,
+            decidim_accountability_status_id: @form.decidim_accountability_status_id,
+            external_id: @form.external_id.presence,
+            weight: @form.weight
+          )
+        end
+        def proposals
+          @proposals ||= result.sibling_scope(:proposals).where(id: form.proposal_ids)
+        end
+        def projects
+          @projects ||= result.sibling_scope(:projects).where(id: form.project_ids)
+        end
+        def meeting_ids
+          @meeting_ids ||= proposals.flat_map do |proposal|
+            proposal.linked_resources(:meetings, "proposals_from_meeting").pluck(:id)
+          end.uniq
+        end
+        def meetings
+          @meetings ||= result.sibling_scope(:meetings).where(id: meeting_ids)
+        end
+        def link_proposals
+          result.link_resources(proposals, "included_proposals")
+        end
+        def link_projects
+          result.link_resources(projects, "included_projects")
+        end
+        def link_meetings
+          result.link_resources(meetings, "meetings_through_proposals")
+        end
+        def send_notifications
+          result.linked_resources(:proposals, "included_proposals").each do |proposal|
+            Decidim::EventsManager.publish(
+              event: "decidim.events.accountability.result_progress_updated",
+              event_class: Decidim::Accountability::ResultProgressUpdatedEvent,
+              resource: result,
+              affected_users: proposal.notifiable_identities,
+              followers: proposal.followers - proposal.notifiable_identities,
+              extra: {
+                progress: result.progress,
+                proposal_id: proposal.id
+              }
+            )
+          end
+        end
+        def should_notify_followers?
+          result.previous_changes["progress"].present?
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/update_status.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Accountability
+    module Admin
+      class UpdateStatus < Decidim::Command
+        def initialize(form, status, user)
+          @form = form
+          @status = status
+          @user = user
+        end
+        def call
+          return broadcast(:invalid) if form.invalid?
+          transaction do
+            update_status
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :status, :form
+        def update_status
+          Decidim.traceability.update!(
+            status,
+            @user,
+            key: @form.key,
+            name: @form.name,
+            description: @form.description,
+            progress: @form.progress
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/commands/decidim/accountability/admin/update_timeline_entry.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Accountability
+    module Admin
+      class UpdateTimelineEntry < Decidim::Command
+        def initialize(form, timeline_entry, user)
+          @form = form
+          @timeline_entry = timeline_entry
+          @user = user
+        end
+        def call
+          return broadcast(:invalid) if form.invalid?
+          transaction do
+            update_timeline_entry
+          end
+          broadcast(:ok)
+        end
+        private
+        attr_reader :timeline_entry, :form
+        def update_timeline_entry
+          Decidim.traceability.update!(
+            timeline_entry,
+            @user,
+            entry_date: form.entry_date,
+            title: form.title,
+            description: form.description
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/controllers/decidim/accountability/admin/statuses_controller.rb
@@ -0,0 +1,60 @@
+module Decidim
+  module Accountability
+    module Admin
+      class StatusesController < Admin::ApplicationController
+        helper_method :statuses
+        def new
+          enforce_permission_to :create, :status
+          @form = form(StatusForm).instance
+        end
+        def create
+          enforce_permission_to :create, :status
+          @form = form(StatusForm).from_params(params)
+          CreateStatus.call(@form, current_user) do
+            on(:ok) do
+              flash[:notice] = I18n.t("statuses.create.success", scope: "decidim.accountability.admin")
+              redirect_to statuses_path
+            end
+            on(:invalid) do
+              flash.now[:alert] = I18n.t("statuses.create.invalid", scope: "decidim.accountability.admin")
+              render action: "new"
+            end
+          end
+        end
+        def edit
+          enforce_permission_to :update, :status, status: status
+          @form = form(StatusForm).from_model(status)
+        end
+        def update
+          enforce_permission_to :update, :status, status: status
+          @form = form(StatusForm).from_params(params)
+          UpdateStatus.call(@form, status, current_user) do
+            on(:ok) do
+              flash[:notice] = I18n.t("statuses.update.success", scope: "decidim.accountability.admin")
+              redirect_to statuses_path
+            end
+            on(:invalid) do
+              flash.now[:alert] = I18n.t("statuses.update.invalid", scope: "decidim.accountability.admin")
+              render action: "edit"
+            end
+          end
+        end
+        def destroy
+          enforce_permission_to :destroy, :status, status: status
+          Decidim.traceability.perform_action!("delete", status, current_user) do
+            status.destroy!
+          end
+          flash[:notice] = I18n.t("statuses.destroy.success", scope: "decidim.accountability.admin")
+          redirect_to statuses_path
+        end
+        private
+        def statuses
+          @statuses ||= Status.where(component: current_component).page(params[:page]).per(15)
+        end
+        def status
+          @status ||= statuses.find(params[:id])
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/controllers/decidim/accountability/admin/timeline_entries_controller.rb
@@ -0,0 +1,64 @@
+module Decidim
+  module Accountability
+    module Admin
+      class TimelineEntriesController < Admin::ApplicationController
+        helper_method :result, :timeline_entries
+        def new
+          enforce_permission_to :create, :timeline_entry
+          @form = form(TimelineEntryForm).instance
+        end
+        def create
+          enforce_permission_to :create, :timeline_entry
+          @form = form(TimelineEntryForm).from_params(params)
+          @form.decidim_accountability_result_id = params[:result_id]
+          CreateTimelineEntry.call(@form, current_user) do
+            on(:ok) do
+              flash[:notice] = I18n.t("timeline_entries.create.success", scope: "decidim.accountability.admin")
+              redirect_to result_timeline_entries_path(params[:result_id])
+            end
+            on(:invalid) do
+              flash.now[:alert] = I18n.t("timeline_entries.create.invalid", scope: "decidim.accountability.admin")
+              render action: "new"
+            end
+          end
+        end
+        def edit
+          enforce_permission_to :update, :timeline_entry, timeline_entry: timeline_entry
+          @form = form(TimelineEntryForm).from_model(timeline_entry)
+        end
+        def update
+          enforce_permission_to :update, :timeline_entry, timeline_entry: timeline_entry
+          @form = form(TimelineEntryForm).from_params(params)
+          UpdateTimelineEntry.call(@form, timeline_entry, current_user) do
+            on(:ok) do
+              flash[:notice] = I18n.t("timeline_entries.update.success", scope: "decidim.accountability.admin")
+              redirect_to result_timeline_entries_path(params[:result_id])
+            end
+            on(:invalid) do
+              flash.now[:alert] = I18n.t("timeline_entries.update.invalid", scope: "decidim.accountability.admin")
+              render action: "edit"
+            end
+          end
+        end
+        def destroy
+          enforce_permission_to :destroy, :timeline_entry, timeline_entry: timeline_entry
+          Decidim.traceability.perform_action!("delete", timeline_entry, current_user) do
+            timeline_entry.destroy!
+          end
+          flash[:notice] = I18n.t("timeline_entries.destroy.success", scope: "decidim.accountability.admin")
+          redirect_to result_timeline_entries_path(params[:result_id])
+        end
+        private
+        def timeline_entries
+          @timeline_entries ||= result.timeline_entries.page(params[:page]).per(15)
+        end
+        def timeline_entry
+          @timeline_entry ||= timeline_entries.find(params[:id])
+        end
+        def result
+          @result ||= Result.where(component: current_component).find(params[:result_id])
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/controllers/decidim/accountability/results_controller.rb
@@ -0,0 +1,41 @@
+module Decidim
+  module Accountability
+    class ResultsController < Decidim::Accountability::ApplicationController
+      include FilterResource
+      helper Decidim::TraceabilityHelper
+      helper Decidim::Accountability::BreadcrumbHelper
+      helper_method :results, :result, :first_class_categories, :count_calculator
+      def show
+        raise ActionController::RoutingError, "Not Found" unless result
+      end
+      private
+      def results
+        @results ||= begin
+          parent_id = params[:parent_id].presence
+          search.result.where(
+            parent_id: [parent_id] + Result.where(parent_id: parent_id).pluck(:id)
+          ).page(params[:page]).per(12)
+        end
+      end
+      def result
+        @result ||= search_collection.includes(:timeline_entries).find_by(id: params[:id])
+      end
+      def search_collection
+        Result.where(component: current_component)
+      end
+      def default_filter_params
+        {
+          search_text_cont: "",
+          with_scope: "",
+          with_category: ""
+        }
+      end
+      def first_class_categories
+        @first_class_categories ||= current_participatory_space.categories.first_class
+      end
+      def count_calculator(scope_id, category_id)
+        Decidim::Accountability::ResultsCalculator.new(current_component, scope_id, category_id).count
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/forms/decidim/accountability/admin/result_form.rb
@@ -0,0 +1,61 @@
+module Decidim
+  module Accountability
+    module Admin
+      class ResultForm < Decidim::Form
+        include TranslatableAttributes
+        include TranslationsHelper
+        translatable_attribute :title, String
+        translatable_attribute :description, String
+        attribute :decidim_scope_id, Integer
+        attribute :decidim_category_id, Integer
+        attribute :proposal_ids, Array[Integer]
+        attribute :project_ids, Array[Integer]
+        attribute :start_date, Decidim::Attributes::LocalizedDate
+        attribute :end_date, Decidim::Attributes::LocalizedDate
+        attribute :progress, Float
+        attribute :decidim_accountability_status_id, Integer
+        attribute :parent_id, Integer
+        attribute :external_id, String
+        attribute :weight, Float
+        validates :title, translatable_presence: true
+        validates :progress, numericality: { greater_than_or_equal_to: 0, less_than_or_equal_to: 100 }, if: ->(form) { form.progress.present? }
+        validates :scope, presence: true, if: ->(form) { form.decidim_scope_id.present? }
+        validates :decidim_scope_id, scope_belongs_to_component: true, if: ->(form) { form.decidim_scope_id.present? }
+        validates :category, presence: true, if: ->(form) { form.decidim_category_id.present? }
+        validates :parent, presence: true, if: ->(form) { form.parent_id.present? }
+        validates :status, presence: true, if: ->(form) { form.decidim_accountability_status_id.present? }
+        delegate :categories, to: :current_component
+        def map_model(model)
+          self.proposal_ids = model.linked_resources(:proposals, "included_proposals").pluck(:id)
+          self.project_ids = model.linked_resources(:projects, "included_projects").pluck(:id)
+          self.decidim_category_id = model.category.try(:id)
+        end
+        def proposals
+          @proposals ||= Decidim.find_resource_manifest(:proposals)
+                                .try(:resource_scope, current_component)
+                                &.where(id: proposal_ids)
+                                &.order(title: :asc)
+        end
+        def projects
+          @projects ||= Decidim.find_resource_manifest(:projects).try(:resource_scope, current_component)&.order(title: :asc)
+                               &.select(:title, :id)&.map { |a| [a.title[I18n.locale.to_s], a.id] }
+        end
+        def scope
+          @scope ||= @attributes["decidim_scope_id"].value ? current_component.scopes.find_by(id: @attributes["decidim_scope_id"].value) : current_component.scope
+        end
+        def decidim_scope_id
+          super || scope&.id
+        end
+        def category
+          @category ||= categories.find_by(id: decidim_category_id)
+        end
+        def parent
+          @parent ||= Decidim::Accountability::Result.find_by(component: current_component, id: parent_id)
+        end
+        def status
+          @status ||= Decidim::Accountability::Status.find_by(component: current_component, id: decidim_accountability_status_id)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/forms/decidim/accountability/admin/timeline_entry_form.rb
@@ -0,0 +1,16 @@
+module Decidim
+  module Accountability
+    module Admin
+      class TimelineEntryForm < Decidim::Form
+        include TranslatableAttributes
+        include TranslationsHelper
+        attribute :decidim_accountability_result_id, Integer
+        attribute :entry_date, Decidim::Attributes::LocalizedDate
+        translatable_attribute :title, String
+        translatable_attribute :description, String
+        validates :entry_date, presence: true
+        validates :title, translatable_presence: true
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/helpers/decidim/accountability/breadcrumb_helper.rb
@@ -0,0 +1,19 @@
+module Decidim
+  module Accountability
+    module BreadcrumbHelper
+      def stats_calculator
+        @stats_calculator ||= ResultStatsCalculator.new(result)
+      end
+      def current_scope
+        params[:filter][:with_scope] if params[:filter]
+      end
+      def progress_calculator(scope_id, category_id)
+        Decidim::Accountability::ResultsCalculator.new(current_component, scope_id, category_id).progress
+      end
+      def category
+        return if (category_id = params.dig(:filter, :with_category)).blank?
+        @category ||= current_participatory_space.categories.find(category_id.is_a?(Array) ? category_id.first : category_id)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/models/decidim/accountability/result.rb
@@ -0,0 +1,73 @@
+module Decidim
+  module Accountability
+    class Result < Accountability::ApplicationRecord
+      include Decidim::Resourceable
+      include Decidim::HasAttachments
+      include Decidim::HasAttachmentCollections
+      include Decidim::HasComponent
+      include Decidim::ScopableResource
+      include Decidim::HasCategory
+      include Decidim::HasReference
+      include Decidim::Comments::CommentableWithComponent
+      include Decidim::Traceable
+      include Decidim::Loggable
+      include Decidim::DownloadYourData
+      include Decidim::Randomable
+      include Decidim::Searchable
+      include Decidim::TranslatableResource
+      include Decidim::FilterableResource
+      component_manifest_name "accountability"
+      translatable_fields :title, :description
+      has_many :children, foreign_key: "parent_id", class_name: "Decidim::Accountability::Result", inverse_of: :parent, dependent: :destroy
+      belongs_to :parent, class_name: "Decidim::Accountability::Result", inverse_of: :children, optional: true, counter_cache: :children_count
+      belongs_to :status, foreign_key: "decidim_accountability_status_id", class_name: "Decidim::Accountability::Status", inverse_of: :results, optional: true
+      has_many :timeline_entries, -> { order(:entry_date) }, foreign_key: "decidim_accountability_result_id",
+                                                             class_name: "Decidim::Accountability::TimelineEntry", inverse_of: :result, dependent: :destroy
+      scope :order_by_most_recent, -> { order(created_at: :desc) }
+      after_save :update_parent_progress, if: -> { parent_id.present? }
+      searchable_fields(
+        scope_id: :decidim_scope_id,
+        participatory_space: { component: :participatory_space },
+        A: :title,
+        D: :description,
+        datetime: :start_date
+      )
+      def self.log_presenter_class_for(_log)
+        Decidim::Accountability::AdminLog::ResultPresenter
+      end
+      def update_parent_progress
+        return if parent.blank?
+        parent.update_progress!
+      end
+      def update_progress!
+        self.progress = if children_use_weighted_progress?
+                          children.sum { |result| (result.progress.presence || 0) * (result.weight.presence || 1) }
+                        else
+                          children.average(:progress)
+                        end
+        save!
+      end
+      def comments_have_alignment?
+        true
+      end
+      def comments_have_votes?
+        true
+      end
+      def allow_resource_permissions?
+        true
+      end
+      def self.ransackable_scopes(_auth_object = nil)
+        [:with_category, :with_scope]
+      end
+      ransacker :id_string do
+        Arel.sql(%{cast("decidim_accountability_results"."id" as text)})
+      end
+      ransacker_i18n_multi :search_text, [:title, :description]
+      private
+      def children_use_weighted_progress?
+        return false if children.pluck(:weight).all?(&:nil?)
+        children.length == 1 || children.pluck(:weight).none? { |weight| weight&.to_d == 1.0.to_d }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/models/decidim/accountability/status.rb
@@ -0,0 +1,19 @@
+module Decidim
+  module Accountability
+    class Status < Accountability::ApplicationRecord
+      include Decidim::HasComponent
+      include Decidim::TranslatableResource
+      include Decidim::FilterableResource
+      include Decidim::Traceable
+      component_manifest_name "accountability"
+      translatable_fields :name, :description
+      has_many :results, foreign_key: "decidim_accountability_status_id", class_name: "Decidim::Accountability::Result", inverse_of: :status, dependent: :nullify
+      validates :key, presence: true, uniqueness: { scope: :decidim_component_id }
+      validates :name, presence: true
+      ransacker_i18n :name
+      def self.log_presenter_class_for(_log)
+        Decidim::Accountability::AdminLog::StatusPresenter
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/models/decidim/accountability/timeline_entry.rb
@@ -0,0 +1,14 @@
+module Decidim
+  module Accountability
+    class TimelineEntry < Accountability::ApplicationRecord
+      include Decidim::TranslatableResource
+      include Decidim::Traceable
+      translatable_fields :title
+      translatable_fields :description
+      belongs_to :result, foreign_key: "decidim_accountability_result_id", class_name: "Decidim::Accountability::Result", inverse_of: :timeline_entries
+      def self.log_presenter_class_for(_log)
+        Decidim::Accountability::AdminLog::TimelineEntryPresenter
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/permissions/decidim/accountability/admin/permissions.rb
@@ -0,0 +1,41 @@
+module Decidim
+  module Accountability
+    module Admin
+      class Permissions < Decidim::DefaultPermissions
+        def permissions
+          return permission_action if permission_action.scope != :admin
+          permission_action.allow! if can_perform_actions_on?(:result, result)
+          permission_action.allow! if can_perform_actions_on?(:status, status)
+          permission_action.allow! if can_perform_actions_on?(:timeline_entry, timeline_entry)
+          permission_action
+        end
+        private
+        def result
+          @result ||= context.fetch(:result, nil)
+        end
+        def status
+          @status ||= context.fetch(:status, nil)
+        end
+        def timeline_entry
+          @timeline_entry ||= context.fetch(:timeline_entry, nil)
+        end
+        def can_perform_actions_on?(subject, resource)
+          return unless permission_action.subject == subject
+          return false if can_create_grandchildren_results?
+          case permission_action.action
+          when :create, :create_children
+            true
+          when :update, :destroy
+            resource.present?
+          else
+            false
+          end
+        end
+        def can_create_grandchildren_results?
+          result&.parent&.present? &&
+            permission_action.action == :create_children
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/presenters/decidim/accountability/admin_log/status_presenter.rb
@@ -0,0 +1,25 @@
+module Decidim
+  module Accountability
+    module AdminLog
+      class StatusPresenter < Decidim::Log::BasePresenter
+        private
+        def action_string
+          case action
+          when "create", "delete", "update"
+            "decidim.accountability.admin_log.status.#{action}"
+          else
+            super
+          end
+        end
+        def diff_fields_mapping
+          {
+            key: :string,
+            name: :i18n,
+            description: :i18n,
+            progress: :integer
+          }
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/presenters/decidim/accountability/admin_log/timeline_entry_presenter.rb
@@ -0,0 +1,24 @@
+module Decidim
+  module Accountability
+    module AdminLog
+      class TimelineEntryPresenter < Decidim::Log::BasePresenter
+        private
+        def action_string
+          case action
+          when "create", "delete", "update"
+            "decidim.accountability.admin_log.timeline_entry.#{action}"
+          else
+            super
+          end
+        end
+        def diff_fields_mapping
+          {
+            entry_date: :date,
+            description: :i18n,
+            title: :i18n
+          }
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/app/services/decidim/accountability/results_calculator.rb
@@ -0,0 +1,28 @@
+module Decidim
+  module Accountability
+    class ResultsCalculator
+      def initialize(component, scope_id, category_id)
+        @component = component
+        @scope_id = scope_id
+        @category_id = category_id
+      end
+      delegate :count, to: :results
+      def progress
+        results.average("COALESCE(progress, 0)")
+      end
+      private
+      attr_reader :component, :scope_id, :category_id
+      def results
+        @results ||= begin
+          query = Result.where(
+            parent_id: nil,
+            component: component
+          )
+          query = query.with_any_scope(scope_id) if scope_id
+          query = query.with_any_category(category_id) if category_id
+          query
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/db/migrate/20220331150008_add_title_to_timeline_entries.rb
@@ -0,0 +1,5 @@
+class AddTitleToTimelineEntries < ActiveRecord::Migration[6.1]
+  def change
+    add_column :decidim_accountability_timeline_entries, :title, :jsonb
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/db/migrate/20220331150155_move_legacy_description_to_title_of_timeline_entries.rb
@@ -0,0 +1,10 @@
+class MoveLegacyDescriptionToTitleOfTimelineEntries < ActiveRecord::Migration[6.1]
+  class TimelineEntry < ApplicationRecord
+    self.table_name = :decidim_accountability_timeline_entries
+  end
+  def up
+    TimelineEntry.find_each do |timeline_entry|
+      timeline_entry.update!(title: timeline_entry.description, description: nil)
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/lib/decidim/accountability/component.rb
@@ -0,0 +1,145 @@
+require "decidim/components/namer"
+Decidim.register_component(:accountability) do |component|
+  component.engine = Decidim::Accountability::Engine
+  component.admin_engine = Decidim::Accountability::AdminEngine
+  component.icon = "media/images/decidim_accountability.svg"
+  component.stylesheet = "decidim/accountability/accountability"
+  component.permissions_class_name = "Decidim::Accountability::Permissions"
+  component.query_type = "Decidim::Accountability::AccountabilityType"
+  component.on(:before_destroy) do |instance|
+    raise StandardError, "Can't remove this component" if Decidim::Accountability::Result.where(component: instance).any?
+  end
+  component.actions = %w(comment)
+  component.register_resource(:result) do |resource|
+    resource.model_class_name = "Decidim::Accountability::Result"
+    resource.template = "decidim/accountability/results/linked_results"
+    resource.card = "decidim/accountability/result"
+    resource.searchable = false
+    resource.actions = %w(comment)
+  end
+  component.settings(:global) do |settings|
+    settings.attribute :scopes_enabled, type: :boolean, default: true
+    settings.attribute :scope_id, type: :scope
+    settings.attribute :comments_enabled, type: :boolean, default: true
+    settings.attribute :comments_max_length, type: :integer, required: false
+    settings.attribute :intro, type: :text, translated: true, editor: true
+    settings.attribute :categories_label, type: :string, translated: true, editor: true
+    settings.attribute :subcategories_label, type: :string, translated: true, editor: true
+    settings.attribute :heading_parent_level_results, type: :string, translated: true, editor: true
+    settings.attribute :heading_leaf_level_results, type: :string, translated: true, editor: true
+    settings.attribute :display_progress_enabled, type: :boolean, default: true
+  end
+  component.register_stat :results_count, primary: true, priority: Decidim::StatsRegistry::HIGH_PRIORITY do |components, _start_at, _end_at|
+    Decidim::Accountability::Result.where(component: components).count
+  end
+  component.settings(:step) do |settings|
+    settings.attribute :comments_blocked, type: :boolean, default: false
+  end
+  component.exports :results do |exports|
+    exports.collection do |component_instance|
+      Decidim::Accountability::Result
+        .where(component: component_instance)
+        .includes(:category, :scope, :status, component: { participatory_space: :organization })
+    end
+    exports.include_in_open_data = true
+    exports.serializer Decidim::Accountability::ResultSerializer
+  end
+  component.exports :result_comments do |exports|
+    exports.collection do |component_instance|
+      Decidim::Comments::Export.comments_for_resource(
+        Decidim::Accountability::Result, component_instance
+      ).includes(:author, :root_commentable, :commentable)
+    end
+    exports.include_in_open_data = true
+    exports.serializer Decidim::Comments::CommentSerializer
+  end
+  component.seeds do |participatory_space|
+    admin_user = Decidim::User.find_by(
+      organization: participatory_space.organization,
+      email: "admin@example.org"
+    )
+    params = {
+      name: Decidim::Components::Namer.new(participatory_space.organization.available_locales, :accountability).i18n_name,
+      manifest_name: :accountability,
+      published_at: Time.current,
+      participatory_space: participatory_space,
+      settings: {
+        intro: Decidim::Faker::Localized.wrapped("<p>", "</p>") { Decidim::Faker::Localized.sentence(word_count: 4) },
+        categories_label: Decidim::Faker::Localized.word,
+        subcategories_label: Decidim::Faker::Localized.word,
+        heading_parent_level_results: Decidim::Faker::Localized.word,
+        heading_leaf_level_results: Decidim::Faker::Localized.word,
+        scopes_enabled: true,
+        scope_id: participatory_space.scope&.id
+      }
+    }
+    component = Decidim.traceability.perform_action!("publish", Decidim::Component, admin_user, visibility: "all") do
+      Decidim::Component.create!(params)
+    end
+    5.times do |i|
+      Decidim::Accountability::Status.create!(
+        component: component,
+        name: Decidim::Faker::Localized.word,
+        key: "status_#{i}"
+      )
+    end
+    3.times do
+      parent_category = participatory_space.categories.sample
+      categories = [parent_category]
+      2.times do
+        categories << Decidim::Category.create!(
+          name: Decidim::Faker::Localized.sentence(word_count: 5),
+          description: Decidim::Faker::Localized.wrapped("<p>", "</p>") do
+            Decidim::Faker::Localized.paragraph(sentence_count: 3)
+          end,
+          parent: parent_category,
+          participatory_space: participatory_space
+        )
+      end
+      categories.each do |category|
+        result = Decidim.traceability.create!(
+          Decidim::Accountability::Result,
+          admin_user,
+          {
+            component: component,
+            scope: participatory_space.organization.scopes.sample,
+            category: category,
+            title: Decidim::Faker::Localized.sentence(word_count: 2),
+            description: Decidim::Faker::Localized.wrapped("<p>", "</p>") do
+              Decidim::Faker::Localized.paragraph(sentence_count: 3)
+            end
+          },
+          visibility: "all"
+        )
+        Decidim::Comments::Seed.comments_for(result)
+        3.times do
+          child_result = Decidim.traceability.create!(
+            Decidim::Accountability::Result,
+            admin_user,
+            {
+              component: component,
+              parent: result,
+              start_date: Time.zone.today,
+              end_date: Time.zone.today + 10,
+              status: Decidim::Accountability::Status.all.sample,
+              progress: rand(1..100),
+              title: Decidim::Faker::Localized.sentence(word_count: 2),
+              description: Decidim::Faker::Localized.wrapped("<p>", "</p>") do
+                Decidim::Faker::Localized.paragraph(sentence_count: 3)
+              end
+            },
+            visibility: "all"
+          )
+          rand(0..5).times do |i|
+            child_result.timeline_entries.create!(
+              entry_date: child_result.start_date + i.days,
+              title: Decidim::Faker::Localized.sentence(word_count: 2),
+              description: Decidim::Faker::Localized.paragraph(sentence_count: 1)
+            )
+          end
+          Decidim::Comments::Seed.comments_for(child_result)
+        end
+      end
+    end
+  end
+end

--- a/decidim-accountability/lib/decidim/accountability/version.rb
+++ b/decidim-accountability/lib/decidim/accountability/version.rb
@@ -1,7 +1,7 @@
 module Decidim
   module Accountability
     def self.version
-      "0.27.3"
+      "0.27.0"
     end
   end
 end

--- a//dev/null
+++ b/decidim-accountability/lib/decidim/api/timeline_entry_type.rb
@@ -0,0 +1,14 @@
+module Decidim
+  module Accountability
+    class TimelineEntryType < Decidim::Api::Types::BaseObject
+      description "A Timeline Entry"
+      field :id, GraphQL::Types::ID, "The internal ID for this timeline entry", null: false
+      field :entry_date, Decidim::Core::DateType, "The entry date for this timeline entry", null: true
+      field :title, Decidim::Core::TranslatedFieldType, "The title for this timeline entry", null: true
+      field :description, Decidim::Core::TranslatedFieldType, "The description for this timeline entry", null: true
+      field :created_at, Decidim::Core::DateTimeType, "When this timeline entry was created", null: true
+      field :updated_at, Decidim::Core::DateTimeType, "When this timeline entry was updated", null: true
+      field :result, Decidim::Accountability::ResultType, "The result for this timeline entry", null: true
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/cells/decidim/accountability/result_m_cell_spec.rb
@@ -0,0 +1,44 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe ResultCell, type: :cell do
+    controller Decidim::Accountability::ResultsController
+    subject { cell_html }
+    let(:start_date) { 3.days.ago }
+    let(:end_date) { 3.days.from_now }
+    let(:progress) { 67.0 }
+    let!(:result) { create(:result, start_date: start_date, end_date: end_date, progress: progress) }
+    let(:model) { result }
+    let(:cell_html) { cell("decidim/accountability/result_m", result, context: { show_space: show_space }).call }
+    it_behaves_like "has space in m-cell"
+    context "when rendering" do
+      let(:show_space) { false }
+      it "renders the card" do
+        expect(subject).to have_css(".card--result")
+      end
+      it "renders the start and end time" do
+        result_start = I18n.l(start_date.to_date, format: :decidim_short)
+        result_end = I18n.l(end_date.to_date, format: :decidim_short)
+        expect(subject).to have_css(".card-data__item--centerblock", text: result_start)
+        expect(subject).to have_css(".card-data__item--centerblock", text: result_end)
+      end
+      it "renders the progress value and bar" do
+        expect(subject).to have_css(".progress__bar")
+        expect(subject).to have_content(/#{progress.to_i}%\s*Executed/)
+        expect(subject).to have_css(".progress__bar__bar")
+      end
+      context "when start and end dates are blank" do
+        let(:start_date) { nil }
+        let(:end_date) { nil }
+        it "hides dates block" do
+          expect(subject).to have_no_css(".card-data__item--centerblock")
+        end
+      end
+      context "when progress is blank" do
+        let(:progress) { nil }
+        it "hides progress value and bar" do
+          expect(subject).to have_no_css(".progress__bar")
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/commands/admin/create_status_spec.rb
@@ -0,0 +1,63 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe Admin::CreateStatus do
+    subject { described_class.new(form, user) }
+    let(:organization) { create :organization, available_locales: [:en] }
+    let(:user) { create(:user, organization: organization) }
+    let(:participatory_process) { create :participatory_process, organization: organization }
+    let(:current_component) { create :component, manifest_name: "accountability", participatory_space: participatory_process }
+    let(:key) { "planned" }
+    let(:name) { "Planned" }
+    let(:description) { "description" }
+    let(:progress) { 75 }
+    let(:form) do
+      double(
+        invalid?: invalid,
+        current_component: current_component,
+        key: key,
+        name: { en: name },
+        description: { en: description },
+        progress: progress
+      )
+    end
+    let(:invalid) { false }
+    context "when the form is not valid" do
+      let(:invalid) { true }
+      it "is not valid" do
+        expect { subject.call }.to broadcast(:invalid)
+      end
+    end
+    context "when everything is ok" do
+      let(:status) { Status.last }
+      it "creates the status" do
+        expect { subject.call }.to change(Status, :count).by(1)
+      end
+      it "sets the name" do
+        subject.call
+        expect(translated(status.name)).to eq name
+      end
+      it "sets the description" do
+        subject.call
+        expect(translated(status.description)).to eq description
+      end
+      it "sets the key" do
+        subject.call
+        expect(status.key).to eq key
+      end
+      it "sets the progress" do
+        subject.call
+        expect(status.progress).to eq progress
+      end
+      it "traces the action", versioning: true do
+        expect(Decidim.traceability)
+          .to receive(:perform_action!)
+          .with(:create, Decidim::Accountability::Status, user, {})
+          .and_call_original
+        expect { subject.call }.to change(Decidim::ActionLog, :count)
+        action_log = Decidim::ActionLog.last
+        expect(action_log.action).to eq("create")
+        expect(action_log.version).to be_present
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/commands/admin/create_timeline_entry_spec.rb
@@ -0,0 +1,62 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe Admin::CreateTimelineEntry do
+    subject { described_class.new(form, user) }
+    let(:organization) { create :organization, available_locales: [:en] }
+    let(:user) { create :user, organization: organization }
+    let(:participatory_process) { create :participatory_process, organization: organization }
+    let(:current_component) { create :accountability_component, participatory_space: participatory_process }
+    let(:result) { create :result, component: current_component }
+    let(:date) { "2017-8-23" }
+    let(:title) { "Title" }
+    let(:description) { "description" }
+    let(:form) do
+      double(
+        invalid?: invalid,
+        decidim_accountability_result_id: result.id,
+        entry_date: date,
+        title: { en: title },
+        description: { en: description }
+      )
+    end
+    let(:invalid) { false }
+    context "when the form is not valid" do
+      let(:invalid) { true }
+      it "is not valid" do
+        expect { subject.call }.to broadcast(:invalid)
+      end
+    end
+    context "when everything is ok" do
+      let(:timeline_entry) { TimelineEntry.last }
+      it "creates the timeline entry" do
+        expect { subject.call }.to change(TimelineEntry, :count).by(1)
+      end
+      it "sets the entry date" do
+        subject.call
+        expect(timeline_entry.entry_date).to eq(Date.new(2017, 8, 23))
+      end
+      it "sets the title" do
+        subject.call
+        expect(translated(timeline_entry.title)).to eq title
+      end
+      it "sets the description" do
+        subject.call
+        expect(translated(timeline_entry.description)).to eq description
+      end
+      it "sets the result" do
+        subject.call
+        expect(timeline_entry.result).to eq(result)
+      end
+      it "traces the action", versioning: true do
+        expect(Decidim.traceability)
+          .to receive(:perform_action!)
+          .with(:create, Decidim::Accountability::TimelineEntry, user, {})
+          .and_call_original
+        expect { subject.call }.to change(Decidim::ActionLog, :count)
+        action_log = Decidim::ActionLog.last
+        expect(action_log.action).to eq("create")
+        expect(action_log.version).to be_present
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/commands/admin/update_status_spec.rb
@@ -0,0 +1,59 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe Admin::UpdateStatus do
+    subject { described_class.new(form, status, user) }
+    let(:organization) { create :organization, available_locales: [:en] }
+    let(:user) { create :user, organization: organization }
+    let(:participatory_process) { create :participatory_process, organization: organization }
+    let(:current_component) { create :accountability_component, participatory_space: participatory_process }
+    let(:status) { create :status, component: current_component }
+    let(:key) { "planned" }
+    let(:name) { "Planned" }
+    let(:description) { "description" }
+    let(:progress) { 75 }
+    let(:form) do
+      double(
+        invalid?: invalid,
+        key: key,
+        name: { en: name },
+        description: { en: description },
+        progress: progress
+      )
+    end
+    let(:invalid) { false }
+    context "when the form is not valid" do
+      let(:invalid) { true }
+      it "is not valid" do
+        expect { subject.call }.to broadcast(:invalid)
+      end
+    end
+    context "when everything is ok" do
+      it "sets the name" do
+        subject.call
+        expect(translated(status.name)).to eq name
+      end
+      it "sets the description" do
+        subject.call
+        expect(translated(status.description)).to eq description
+      end
+      it "sets the key" do
+        subject.call
+        expect(status.key).to eq key
+      end
+      it "sets the progress" do
+        subject.call
+        expect(status.progress).to eq progress
+      end
+      it "traces the action", versioning: true do
+        expect(Decidim.traceability)
+          .to receive(:perform_action!)
+          .with(:update, status, user, {})
+          .and_call_original
+        expect { subject.call }.to change(Decidim::ActionLog, :count)
+        action_log = Decidim::ActionLog.last
+        expect(action_log.action).to eq("update")
+        expect(action_log.version).to be_present
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/commands/admin/update_timeline_entry_spec.rb
@@ -0,0 +1,50 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe Admin::UpdateTimelineEntry do
+    subject { described_class.new(form, timeline_entry, user) }
+    let(:organization) { create :organization, available_locales: [:en] }
+    let(:user) { create :user, organization: organization }
+    let(:participatory_process) { create :participatory_process, organization: organization }
+    let(:current_component) { create :accountability_component, participatory_space: participatory_process }
+    let(:result) { create :result, component: current_component }
+    let(:timeline_entry) { create :timeline_entry, result: result }
+    let(:date) { "2017-9-23" }
+    let(:title) { "New title" }
+    let(:description) { "new description" }
+    let(:form) do
+      double(
+        invalid?: invalid,
+        entry_date: date,
+        title: { en: title },
+        description: { en: description }
+      )
+    end
+    let(:invalid) { false }
+    context "when the form is not valid" do
+      let(:invalid) { true }
+      it "is not valid" do
+        expect { subject.call }.to broadcast(:invalid)
+      end
+    end
+    context "when everything is ok" do
+      it "sets the date" do
+        subject.call
+        expect(timeline_entry.entry_date).to eq(Date.new(2017, 9, 23))
+      end
+      it "sets the description" do
+        subject.call
+        expect(translated(timeline_entry.description)).to eq description
+      end
+      it "traces the action", versioning: true do
+        expect(Decidim.traceability)
+          .to receive(:perform_action!)
+          .with(:update, Decidim::Accountability::TimelineEntry, user, {})
+          .and_call_original
+        expect { subject.call }.to change(Decidim::ActionLog, :count)
+        action_log = Decidim::ActionLog.last
+        expect(action_log.action).to eq("update")
+        expect(action_log.version).to be_present
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/controllers/decidim/accountability/versions_controller_spec.rb
@@ -0,0 +1,10 @@
+require "spec_helper"
+module Decidim
+  module Accountability
+    describe VersionsController, versioning: true, type: :controller do
+      routes { Decidim::Accountability::Engine.routes }
+      let(:resource) { create(:result) }
+      it_behaves_like "versions controller"
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/forms/admin/timeline_entry_form_spec.rb
@@ -0,0 +1,44 @@
+require "spec_helper"
+module Decidim::Accountability
+  describe Admin::TimelineEntryForm do
+    subject { described_class.from_params(attributes).with_context(context) }
+    let(:organization) { create(:organization, available_locales: [:en]) }
+    let(:context) do
+      {
+        current_organization: organization,
+        current_component: current_component
+      }
+    end
+    let(:participatory_process) { create :participatory_process, organization: organization }
+    let(:current_component) { create :accountability_component, participatory_space: participatory_process }
+    let(:result) { create :result, component: current_component }
+    let(:entry_date) { "12/3/2017" }
+    let(:title) do
+      Decidim::Faker::Localized.sentence(word_count: 3)
+    end
+    let(:description) do
+      Decidim::Faker::Localized.sentence(word_count: 3)
+    end
+    let(:attributes) do
+      {
+        decidim_accountability_result_id: result.id,
+        entry_date: entry_date,
+        title_en: title[:en],
+        description_en: description[:en]
+      }
+    end
+    it { is_expected.to be_valid }
+    describe "when entry date is missing" do
+      let(:entry_date) { nil }
+      it { is_expected.not_to be_valid }
+    end
+    describe "when title is missing" do
+      let(:title) { { en: nil } }
+      it { is_expected.not_to be_valid }
+    end
+    describe "when description is missing" do
+      let(:description) { { en: nil } }
+      it { is_expected.to be_valid }
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/mailers/import_mailer_spec.rb
@@ -0,0 +1,40 @@
+require "spec_helper"
+require "decidim/core/test/factories"
+require "decidim/accountability/test/factories"
+require "decidim/participatory_processes/test/factories"
+module Decidim
+  module Accountability
+    describe ImportMailer, type: :mailer do
+      let(:organization) { create :organization, available_locales: [:en] }
+      let(:current_user) { create :user, organization: organization }
+      let(:participatory_process) { create :participatory_process, organization: organization }
+      let(:current_component) { create :accountability_component, participatory_space: participatory_process, id: 16 }
+      let!(:category) { create :category, id: 16, participatory_space: current_component.participatory_space }
+      let!(:status6) { create :status, id: 6, component: current_component }
+      let!(:status7) { create :status, id: 7, component: current_component }
+      let!(:status8) { create :status, id: 8, component: current_component }
+      let(:valid_csv) { File.read("spec/fixtures/valid_result.csv") }
+      let(:invalid_csv) { File.read("spec/fixtures/invalid_result.csv") }
+      context "with a valid CSV" do
+        describe "import" do
+          let(:importer) { Decidim::Accountability::ResultsCsvImporter.new(current_component, valid_csv, current_user) }
+          let(:import_data) { importer.import! }
+          let(:mail) { described_class.import(current_user, import_data) }
+          it "email body informs no errors on process" do
+            expect(mail.body).to include(I18n.t("decidim.accountability.import_mailer.import.success"))
+          end
+        end
+      end
+      context "with an invalid CSV" do
+        describe "import" do
+          let(:importer) { Decidim::Accountability::ResultsCsvImporter.new(current_component, invalid_csv, current_user) }
+          let(:import_data) { importer.import! }
+          let(:mail) { described_class.import(current_user, import_data) }
+          it "email body informs of csv errors" do
+            expect(mail.body).to include(I18n.t("decidim.accountability.import_mailer.import.errors_present"))
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/permissions/decidim/accountability/admin/permissions_spec.rb
@@ -0,0 +1,93 @@
+require "spec_helper"
+describe Decidim::Accountability::Admin::Permissions do
+  subject { described_class.new(user, permission_action, context).permissions.allowed? }
+  let(:user) { build :user }
+  let(:context) do
+    {
+      current_component: accountability_component
+    }.merge(extra_context)
+  end
+  let(:extra_context) { {} }
+  let(:accountability_component) { create :accountability_component }
+  let(:permission_action) { Decidim::PermissionAction.new(**action) }
+  shared_examples "crud permissions" do
+    describe "create" do
+      let(:action) do
+        { scope: :admin, action: :create, subject: action_subject }
+      end
+      it { is_expected.to be true }
+    end
+    describe "update" do
+      let(:action) do
+        { scope: :admin, action: :update, subject: action_subject }
+      end
+      context "when the resource is present" do
+        it { is_expected.to be true }
+      end
+      context "when the resource is not present" do
+        let(:resource) { nil }
+        it_behaves_like "permission is not set"
+      end
+    end
+    describe "destroy" do
+      let(:action) do
+        { scope: :admin, action: :destroy, subject: action_subject }
+      end
+      context "when the resource is present" do
+        it { is_expected.to be true }
+      end
+      context "when the resource is not present" do
+        let(:resource) { nil }
+        it_behaves_like "permission is not set"
+      end
+    end
+    context "when any other action" do
+      let(:action) do
+        { scope: :admin, action: :foo, subject: :action_subject }
+      end
+      it_behaves_like "permission is not set"
+    end
+  end
+  describe "result" do
+    let(:resource) { create :result, component: accountability_component }
+    let(:action_subject) { :result }
+    let(:extra_context) { { result: resource } }
+    it_behaves_like "crud permissions"
+    describe "creating a children" do
+      let(:resource) { create :result, component: accountability_component }
+      let(:action_subject) { :result }
+      let(:extra_context) { { result: resource } }
+      let(:action) do
+        { scope: :admin, action: :create_children, subject: action_subject }
+      end
+      it { is_expected.to be true }
+    end
+    describe "creating a grandchildren" do
+      let(:parent_result) { create :result, component: accountability_component }
+      let(:resource) { create :result, parent: parent_result }
+      let(:action) do
+        { scope: :admin, action: :create_children, subject: action_subject }
+      end
+      it_behaves_like "permission is not set"
+    end
+  end
+  describe "status" do
+    let(:resource) { create :status, component: accountability_component }
+    let(:action_subject) { :status }
+    let(:extra_context) { { status: resource } }
+    it_behaves_like "crud permissions"
+  end
+  describe "timeline_entry" do
+    let(:result) { create :result, component: accountability_component }
+    let(:resource) { create :timeline_entry, result: result }
+    let(:action_subject) { :timeline_entry }
+    let(:extra_context) { { timeline_entry: resource } }
+    it_behaves_like "crud permissions"
+  end
+  context "when any other condition" do
+    let(:action) do
+      { scope: :admin, action: :foo, subject: :foo }
+    end
+    it_behaves_like "permission is not set"
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/permissions/decidim/accountability/permissions_spec.rb
@@ -0,0 +1,24 @@
+require "spec_helper"
+describe Decidim::Accountability::Permissions do
+  subject { described_class.new(user, permission_action, context).permissions.allowed? }
+  let(:user) { create :user, organization: accountability_component.organization }
+  let(:context) do
+    {
+      current_component: accountability_component
+    }
+  end
+  let(:accountability_component) { create :accountability_component }
+  let(:permission_action) { Decidim::PermissionAction.new(**action) }
+  context "when scope is admin" do
+    let(:action) do
+      { scope: :admin, action: :vote, subject: :proposal }
+    end
+    it_behaves_like "delegates permissions to", Decidim::Accountability::Admin::Permissions
+  end
+  context "when any other condition" do
+    let(:action) do
+      { scope: :public, action: :foo, subject: :foo }
+    end
+    it_behaves_like "permission is not set"
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/requests/result_search_spec.rb
@@ -0,0 +1,90 @@
+require "spec_helper"
+RSpec.describe "Result search", type: :request do
+  include Decidim::ComponentPathHelper
+  let(:component) { create :accountability_component }
+  let(:participatory_space) { component.participatory_space }
+  let(:parent_id) { nil }
+  let(:filter_params) { {} }
+  let!(:result1) do
+    create(
+      :result,
+      title: Decidim::Faker::Localized.literal("A doggo in the title"),
+      component: component,
+      parent: nil,
+      category: create(:category, participatory_space: participatory_space)
+    )
+  end
+  let!(:result2) do
+    create(
+      :result,
+      description: Decidim::Faker::Localized.literal("There is a doggo in the office"),
+      component: component,
+      parent: result1,
+      category: create(:category, participatory_space: participatory_space)
+    )
+  end
+  let!(:result3) do
+    create(
+      :result,
+      component: component,
+      parent: result2,
+      category: create(:category, participatory_space: participatory_space)
+    )
+  end
+  let!(:result4) do
+    create(
+      :result,
+      component: component,
+      parent: nil,
+      category: create(:category, participatory_space: participatory_space)
+    )
+  end
+  let(:request_path) { main_component_path(component) }
+  before do
+    get(
+      request_path,
+      params: { parent_id: parent_id, filter: filter_params },
+      headers: { "HOST" => component.organization.host }
+    )
+  end
+  describe "home" do
+    subject { response.body }
+    it "displays all categories that have top-level results" do
+      expect(subject).to include(translated(result1.category.name))
+      expect(subject).to include(translated(result4.category.name))
+    end
+    it "does not display the categories that only have sub-results" do
+      expect(subject).not_to include(translated(result2.category.name))
+      expect(subject).not_to include(translated(result3.category.name))
+    end
+  end
+  describe "results" do
+    subject { assigns(:results) }
+    let(:request_path) { "#{main_component_path(component)}/results" }
+    context "when deep searching" do
+      context "when the parent_id is nil" do
+        it "returns the search on all results" do
+          expect(subject).to match_array [result1, result2, result4]
+        end
+      end
+      context "when the parent_id is result1" do
+        let(:parent_id) { result1.id }
+        it "returns the search on the children of result" do
+          expect(subject).to match_array [result2, result3]
+        end
+      end
+      context "when the parent_id is result2" do
+        let(:parent_id) { result2.id }
+        it "returns the search on the children of result" do
+          expect(subject).to match_array [result3]
+        end
+      end
+    end
+    context "when searching by text" do
+      let(:filter_params) { { search_text_cont: "doggo" } }
+      it "returns the search results matching the word in title or description" do
+        expect(subject).to match_array [result1, result2]
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/services/decidim/accountability/diff_renderer_spec.rb
@@ -0,0 +1,71 @@
+require "spec_helper"
+describe Decidim::Accountability::DiffRenderer, versioning: true do
+  let!(:result) { create :result, progress: 50 }
+  let(:version) { result.versions.last }
+  before do
+    Decidim.traceability.update!(
+      result,
+      "test suite",
+      title: {
+        en: "Only changes in English"
+      },
+      description: {
+        ca: "<p>HTML description</p>"
+      },
+      progress: result.progress / 2.0,
+      start_date: result.start_date + 1.day
+    )
+  end
+  describe "#diff" do
+    subject { described_class.new(version).diff }
+    it "calculates the fields that have changed" do
+      expect(subject.keys)
+        .to match_array [:title_en, :description_ca, :progress, :start_date]
+    end
+    it "has the old and new values for each field" do
+      expect(subject[:progress][:old_value]).to eq 50.0
+      expect(subject[:progress][:new_value]).to eq 25.0
+    end
+    it "has the type of each field" do
+      expected_types = {
+        description_ca: :i18n_html,
+        progress: :percentage,
+        start_date: :date,
+        title_en: :i18n
+      }
+      types = subject.to_h { |attribute, data| [attribute.to_sym, data[:type]] }
+      expect(types).to eq expected_types
+    end
+    it "generates the labels correctly" do
+      expected_labels = {
+        description_ca: "Description (Catal)",
+        progress: "Progress",
+        start_date: "Start date",
+        title_en: "Title (English)"
+      }
+      labels = subject.to_h { |attribute, data| [attribute.to_sym, data[:label]] }
+      expect(labels).to eq expected_labels
+    end
+    context "when one of the locales is not available" do
+      let!(:default_available_locales) do
+        I18n.available_locales
+      end
+      before do
+        I18n.available_locales = [:en]
+      end
+      after do
+        I18n.available_locales = default_available_locales
+      end
+      it "generates the label with locale name" do
+        expected_labels = {
+          description_ca: "Description (ca)",
+          progress: "Progress",
+          start_date: "Start date",
+          title_en: "Title (English)"
+        }
+        labels = subject.to_h { |attribute, data| [attribute.to_sym, data[:label]] }
+        expect(labels).to eq expected_labels
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/services/decidim/accountability/results_csv_importer_spec.rb
@@ -0,0 +1,42 @@
+require "spec_helper"
+require "decidim/core/test/factories"
+require "decidim/accountability/test/factories"
+require "decidim/participatory_processes/test/factories"
+describe Decidim::Accountability::ResultsCsvImporter do
+  let(:organization) { create :organization, available_locales: [:en] }
+  let(:current_user) { create :user, organization: organization }
+  let(:participatory_process) { create :participatory_process, organization: organization }
+  let(:current_component) { create :accountability_component, participatory_space: participatory_process, id: 16 }
+  let!(:category) { create :category, id: 16, participatory_space: current_component.participatory_space }
+  let!(:status6) { create :status, id: 6, component: current_component }
+  let!(:status7) { create :status, id: 7, component: current_component }
+  let!(:status8) { create :status, id: 8, component: current_component }
+  let(:valid_csv) { File.read("spec/fixtures/valid_result.csv") }
+  let(:invalid_csv) { File.read("spec/fixtures/invalid_result.csv") }
+  context "with a valid CSV" do
+    subject { described_class.new(current_component, valid_csv, current_user) }
+    describe "#import!" do
+      it "Import all rows from csv file" do
+        expect do
+          subject.import!
+        end.to change(Decidim::Accountability::Result, :count).by(4)
+      end
+      context "when results exist" do
+        let!(:result1) { create :result, component: current_component, progress: 0, id: 69, status: status6 }
+        it "Update the result1 progress attribute" do
+          subject.import!
+          expect(result1.reload.progress.to_f).to eq 96.0
+        end
+      end
+    end
+  end
+  context "with an invalid CSV" do
+    subject { described_class.new(current_component, invalid_csv, current_user) }
+    describe "#import!" do
+      it "Errors would be returned" do
+        errors = subject.import!
+        expect(errors.length).to eq 3
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/services/decidim/accountability/searchable_result_resource_spec.rb
@@ -0,0 +1,121 @@
+require "spec_helper"
+module Decidim
+  describe Search do
+    subject { described_class.new(params) }
+    include_context "when a resource is ready for global search"
+    let(:current_component) { create :accountability_component, organization: organization }
+    let!(:result) do
+      create(
+        :result,
+        component: current_component,
+        scope: scope1,
+        title: Decidim::Faker::Localized.name,
+        description: description1
+      )
+    end
+    before(:all) do
+      manifest = Decidim.find_resource_manifest(Decidim::Accountability::Result)
+      manifest.searchable = true
+    end
+    after(:all) do
+      manifest = Decidim.find_resource_manifest(Decidim::Accountability::Result)
+      manifest.searchable = false
+    end
+    describe "Indexing of results" do
+      context "when implementing Searchable" do
+        context "when on create" do
+          it "does indexes a SearchableResource after Result creation" do
+            organization.available_locales.each do |locale|
+              searchable = SearchableResource.find_by(resource_type: result.class.name, resource_id: result.id, locale: locale)
+              expect_searchable_resource_to_correspond_to_result(searchable, result, locale)
+            end
+          end
+        end
+        context "when on update" do
+          context "when it is updated" do
+            before do
+              result.update end_date: Time.zone.today.in(1.year)
+            end
+            it "updates the associated SearchableResource after update" do
+              searchable = SearchableResource.find_by(resource_type: result.class.name, resource_id: result.id)
+              created_at = searchable.created_at
+              updated_title = Decidim::Faker::Localized.name
+              result.update(title: updated_title)
+              result.save!
+              searchable.reload
+              organization.available_locales.each do |locale|
+                searchable = SearchableResource.find_by(resource_type: result.class.name, resource_id: result.id, locale: locale)
+                expect(searchable.content_a).to eq I18n.transliterate(translated(updated_title, locale: locale))
+                expect(searchable.updated_at).to be > created_at
+              end
+            end
+          end
+        end
+        context "when on destroy" do
+          it "destroys the associated SearchableResource after Result destroy" do
+            result.destroy
+            searchables = SearchableResource.where(resource_type: result.class.name, resource_id: result.id)
+            expect(searchables.any?).to be false
+          end
+        end
+      end
+    end
+    describe "Search" do
+      context "when searching by Result resource_type" do
+        let!(:result2) do
+          create(
+            :result,
+            component: current_component,
+            scope: scope1,
+            title: Decidim::Faker::Localized.name,
+            description: Decidim::Faker::Localized.prefixed("Chewie, I'll be waiting for your signal. Take care, you two. May the Force be with you. Ow!", test_locales)
+          )
+        end
+        it "returns Result results" do
+          Decidim::Search.call("Ow", organization, resource_type: result.class.name) do
+            on(:ok) do |results_by_type|
+              results = results_by_type[result.class.name]
+              expect(results[:count]).to eq 2
+              expect(results[:results]).to match_array [result, result2]
+            end
+            on(:invalid) { raise("Should not happen") }
+          end
+        end
+        it "allows searching by prefix characters" do
+          Decidim::Search.call("wait", organization, resource_type: result.class.name) do
+            on(:ok) do |results_by_type|
+              results = results_by_type[result.class.name]
+              expect(results[:count]).to eq 1
+              expect(results[:results]).to eq [result2]
+            end
+            on(:invalid) { raise("Should not happen") }
+          end
+        end
+      end
+    end
+    private
+    def expect_searchable_resource_to_correspond_to_result(searchable, result, locale)
+      attrs = searchable.attributes.clone
+      attrs.delete("id")
+      attrs.delete("created_at")
+      attrs.delete("updated_at")
+      expect(attrs.delete("datetime").to_s(:short)).to eq(result.start_date.in_time_zone.to_s(:short))
+      expect(attrs).to eq(expected_searchable_resource_attrs(result, locale))
+    end
+    def expected_searchable_resource_attrs(resource, locale)
+      {
+        "content_a" => I18n.transliterate(translated(resource.title, locale: locale)),
+        "content_b" => "",
+        "content_c" => "",
+        "content_d" => I18n.transliterate(translated(resource.description, locale: locale)),
+        "locale" => locale,
+        "decidim_organization_id" => resource.component.organization.id,
+        "decidim_participatory_space_id" => current_component.participatory_space_id,
+        "decidim_participatory_space_type" => current_component.participatory_space_type,
+        "decidim_scope_id" => resource.decidim_scope_id,
+        "resource_id" => resource.id,
+        "resource_type" => "Decidim::Accountability::Result"
+      }
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/shared/manage_child_results_examples.rb
@@ -0,0 +1,74 @@
+RSpec.shared_examples "manage child results" do
+  it "updates a result" do
+    within find("tr", text: translated(child_result.title)) do
+      click_link "Edit"
+    end
+    within ".edit_result" do
+      fill_in_i18n(
+        :result_title,
+        "#result-title-tabs",
+        en: "My new title",
+        es: "Mi nuevo ttulo",
+        ca: "El meu nou ttol"
+      )
+      find("*[type=submit]").click
+    end
+    expect(page).to have_admin_callout("successfully")
+    within "table" do
+      expect(page).to have_content("My new title")
+    end
+  end
+  it "allows the user to preview the result" do
+    within find("tr", text: translated(child_result.title)) do
+      klass = "action-icon--preview"
+      href = resource_locator(child_result).path
+      target = "blank"
+      expect(page).to have_selector(
+        :xpath,
+        "//a[contains(@class,'#{klass}')][@href='#{href}'][@target='#{target}']"
+      )
+    end
+  end
+  it "creates a new child result" do
+    click_link "New Result", match: :first
+    within ".new_result" do
+      fill_in_i18n(
+        :result_title,
+        "#result-title-tabs",
+        en: "My result",
+        es: "Mi result",
+        ca: "El meu result"
+      )
+      fill_in_i18n_editor(
+        :result_description,
+        "#result-description-tabs",
+        en: "A longer description",
+        es: "Descripcin ms larga",
+        ca: "Descripci ms llarga"
+      )
+      select "Ongoing", from: :result_decidim_accountability_status_id
+      fill_in :result_progress, with: 89
+      find("*[type=submit]").click
+    end
+    expect(page).to have_admin_callout("successfully")
+    within "table" do
+      expect(page).to have_content("My result")
+      expect(page).not_to have_selector(".action-icon--plus"), "results grandchildren creation is disallowed"
+    end
+  end
+  describe "deleting a result" do
+    before do
+      visit current_path
+      click_link translated(result.title)
+    end
+    it "deletes a result" do
+      within find("tr", text: translated(child_result.title)) do
+        accept_confirm { click_link "Delete" }
+      end
+      expect(page).to have_admin_callout("successfully")
+      within "table" do
+        expect(page).not_to have_content(translated(child_result.title))
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/system/admin/admin_orders_results_spec.rb
@@ -0,0 +1,80 @@
+require "spec_helper"
+describe "Admin orders results", type: :system do
+  let(:manifest_name) { "accountability" }
+  let!(:results) do
+    [
+      create(:result, scope: create(:scope, organization: component.organization,
+                                            name: { "ca" => "Scope2", "en" => "Scope3" }),
+                      component: current_component,
+                      category: create(:category, participatory_space: participatory_space),
+                      created_at: 2.days.ago),
+      create(:result, scope: create(:scope, organization: component.organization,
+                                            name: { "ca" => "Scope3", "en" => "Scope1" }),
+                      component: current_component,
+                      category: create(:category, participatory_space: participatory_space),
+                      created_at: 1.day.ago),
+      create(:result, scope: create(:scope, organization: component.organization,
+                                            name: { "ca" => "Scope1", "en" => "Scope2" }),
+                      component: current_component,
+                      category: create(:category, participatory_space: participatory_space),
+                      created_at: Time.current)
+    ]
+  end
+  include_context "when managing a component as an admin"
+  it "orders results by ID" do
+    ordered_results = results.sort_by(&:id).reverse
+    click_link "ID"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by title" do
+    ordered_results = results.sort_by { |result| translated(result.title) }
+    click_link "Title"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by category" do
+    ordered_results = results.sort_by { |result| translated(result.category.name) }
+    click_link "Category"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by scope" do
+    ordered_results = results.sort_by { |result| translated(result.scope.name) }
+    click_link "Scope"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by status" do
+    ordered_results = results.sort_by { |result| translated(result.status.name) }
+    click_link "Status"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by progress" do
+    ordered_results = results.sort_by(&:progress)
+    click_link "Progress"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+  it "orders results by created at" do
+    ordered_results = results.sort_by(&:created_at)
+    click_link "Created"
+    rows = page.all("tbody tr")
+    rows.each_with_index do |row, i|
+      expect(row).to have_text(translated(ordered_results[i].title))
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/system/explore_results_spec.rb
@@ -0,0 +1,307 @@
+require "spec_helper"
+describe "Explore results", versioning: true, type: :system do
+  include_context "with a component"
+  let(:manifest_name) { "accountability" }
+  let(:results_count) { 5 }
+  let!(:scope) { create :scope, organization: organization }
+  let!(:results) do
+    create_list(
+      :result,
+      results_count,
+      component: component
+    )
+  end
+  before do
+    component.update(settings: { scopes_enabled: true })
+    visit path
+  end
+  describe "home" do
+    let!(:other_category) { create :category, participatory_space: participatory_space }
+    let!(:other_scope) { create :scope, organization: organization }
+    let(:subcategory) { create :subcategory, parent: category }
+    let(:other_subcategory) { create :subcategory, parent: other_category }
+    let(:path) { decidim_participatory_process_accountability.root_path(participatory_process_slug: participatory_process.slug, component_id: component.id) }
+    before do
+      results[0..2].each { |r| r.update!(category: subcategory, scope: scope) }
+      results[3..-1].each { |r| r.update!(category: other_subcategory, scope: other_scope) }
+      visit path
+    end
+    it "shows categories and subcategories with results" do
+      participatory_process.categories.each do |category|
+        category_count = Decidim::Accountability::ResultsCalculator.new(component, nil, category.id).count
+        expect(page).to have_content(translated(category.name)) if category_count.positive?
+      end
+    end
+    it "shows progress" do
+      expect(page).to have_content("Global execution status")
+      expect(page).to have_selector(".progress-figure")
+    end
+    context "with progress disabled" do
+      before do
+        component.update!(settings: { display_progress_enabled: false })
+      end
+      it "doesn't show progress" do
+        visit path
+        expect(page).to have_no_content("Global execution status")
+        expect(page).to have_no_selector(".progress-figure")
+      end
+    end
+    context "with a scope" do
+      before do
+        within "ul.tags.tags--action" do
+          click_link translated(scope.name)
+        end
+      end
+      it "shows current scope active" do
+        within "ul.tags.tags--action li.active" do
+          expect(page).to have_content(translated(scope.name))
+        end
+      end
+      it "shows only the categories with results matching the current scope" do
+        participatory_process.categories.each do |category|
+          category_count = Decidim::Accountability::ResultsCalculator.new(component, scope.id, category.id).count
+          if category_count.positive?
+            expect(page).to have_content(translated(category.name))
+          else
+            expect(page).not_to have_content(translated(category.name))
+          end
+        end
+      end
+    end
+    context "when searching" do
+      let!(:matching_result1) do
+        create(
+          :result,
+          title: Decidim::Faker::Localized.literal("A doggo in the title"),
+          component: component
+        )
+      end
+      let!(:matching_result2) do
+        create(
+          :result,
+          title: Decidim::Faker::Localized.literal("Other matching result"),
+          description: Decidim::Faker::Localized.literal("There is a doggo in the office"),
+          component: component
+        )
+      end
+      it "displays the correct search results" do
+        fill_in :filter_search_text_cont, with: "doggo"
+        within "form .filters__search" do
+          find("*[type=submit]").click
+        end
+        expect(page).to have_content("2 RESULTS")
+        expect(page).to have_content(translated(matching_result1.title))
+        expect(page).to have_content(translated(matching_result2.title))
+        results.each do |result|
+          expect(page).not_to have_content(translated(result.title))
+        end
+      end
+    end
+  end
+  describe "index" do
+    let(:path) { decidim_participatory_process_accountability.results_path(participatory_process_slug: participatory_process.slug, component_id: component.id) }
+    it "shows all results for the given process and category" do
+      expect(page).to have_selector(".card--list__item", count: results_count)
+      results.each do |result|
+        expect(page).to have_content(translated(result.title))
+      end
+    end
+    context "with a category and a scope" do
+      let!(:category) { create :category, participatory_space: participatory_process }
+      let!(:scope) { create :scope, organization: organization }
+      let!(:result) do
+        result = results.first
+        result.category = category
+        result.scope = scope
+        result.save
+        result
+      end
+      let(:path) do
+        decidim_participatory_process_accountability.results_path(
+          participatory_process_slug: participatory_process.slug, component_id: component.id, filter: { with_category: category.id, with_scope: scope.id }
+        )
+      end
+      it "shows current scope active" do
+        within "ul.tags.tags--action li.active" do
+          expect(page).to have_content(translated(scope.name))
+        end
+      end
+      it "maintains scope filter" do
+        click_link translated(category.name)
+        within "ul.tags.tags--action li.active" do
+          expect(page).to have_content(translated(scope.name))
+        end
+      end
+    end
+  end
+  describe "show" do
+    let(:path) { decidim_participatory_process_accountability.result_path(id: result.id, participatory_process_slug: participatory_process.slug, component_id: component.id) }
+    let(:results_count) { 1 }
+    let(:result) { results.first }
+    it "shows all result info" do
+      expect(page).to have_i18n_content(result.title)
+      expect(page).to have_i18n_content(result.description)
+      expect(page).to have_content(result.reference)
+      expect(page).to have_content("#{result.progress.to_i}%")
+    end
+    context "when it has no versions" do
+      before do
+        result.versions.destroy_all
+        visit current_path
+      end
+      it "does not show version data" do
+        expect(page).not_to have_content("Version number")
+      end
+    end
+    context "when it has some versions" do
+      it "does shows version data" do
+        expect(page).to have_content("Version number 1")
+      end
+    end
+    context "without category or scope" do
+      it "does not show any tag" do
+        expect(page).not_to have_selector("ul.tags.tags--result")
+      end
+    end
+    context "with a category" do
+      let(:result) do
+        result = results.first
+        result.category = create :category, participatory_space: participatory_process
+        result.save
+        result
+      end
+      it "shows tags for category" do
+        expect(page).to have_selector("ul.tags.tags--result")
+        within "ul.tags.tags--result" do
+          expect(page).to have_content(translated(result.category.name))
+        end
+      end
+    end
+    context "with a scope" do
+      let(:result) do
+        result = results.first
+        result.scope = create :scope, organization: organization
+        result.save
+        result
+      end
+      before do
+        visit current_path
+      end
+      it "shows tags for scope" do
+        expect(page).to have_selector("ul.tags.tags--result")
+        within "ul.tags.tags--result" do
+          expect(page).to have_content(translated(result.scope.name))
+        end
+      end
+    end
+    context "when a proposal has comments" do
+      let(:result) { results.first }
+      let(:author) { create(:user, :confirmed, organization: component.organization) }
+      let!(:comments) { create_list(:comment, 3, commentable: result) }
+      before do
+        visit current_path
+      end
+      it "shows the comments" do
+        comments.each do |comment|
+          expect(page).to have_content(comment.body.values.first)
+        end
+      end
+    end
+    context "with linked proposals" do
+      let(:proposal_component) do
+        create(:component, manifest_name: :proposals, participatory_space: result.component.participatory_space)
+      end
+      let(:proposals) { create_list(:proposal, 3, component: proposal_component) }
+      let(:proposal) { proposals.first }
+      before do
+        result.link_resources(proposals, "included_proposals")
+        visit current_path
+      end
+      it "shows related proposals" do
+        proposals.each do |proposal|
+          expect(page).to have_content(translated(proposal.title))
+          expect(page).to have_content(proposal.creator_author.name)
+          expect(page).to have_content(proposal.votes.size)
+        end
+      end
+      it "the result is mentioned in the proposal page" do
+        click_link translated(proposal.title)
+        expect(page).to have_i18n_content(result.title)
+      end
+    end
+    context "with linked projects" do
+      let(:budgets_component) do
+        create(:component, manifest_name: :budgets, participatory_space: result.component.participatory_space)
+      end
+      let(:budget) { create(:budget, component: budgets_component) }
+      let(:projects) { create_list(:project, 3, budget: budget) }
+      let(:project) { projects.first }
+      before do
+        result.link_resources(projects, "included_projects")
+        visit current_path
+      end
+      it "shows related projects" do
+        projects.each do |project|
+          expect(page).to have_content(translated(project.title))
+        end
+      end
+      it "the result is mentioned in the project page" do
+        click_link translated(project.title)
+        expect(page).to have_i18n_content(result.title)
+      end
+    end
+    context "with linked meetings" do
+      let(:meeting_component) do
+        create(:component, manifest_name: :meetings, participatory_space: result.component.participatory_space)
+      end
+      let(:meetings) { create_list(:meeting, 3, :published, component: meeting_component) }
+      let(:meeting) { meetings.first }
+      before do
+        result.link_resources(meetings, "meetings_through_proposals")
+        visit current_path
+      end
+      it "shows related meetings" do
+        meetings.each do |meeting|
+          expect(page).to have_i18n_content(meeting.title)
+          expect(page).to have_i18n_content(meeting.description)
+        end
+      end
+      it "the result is mentioned in the meeting page" do
+        click_link translated(meeting.title)
+        expect(page).to have_i18n_content(result.title)
+      end
+    end
+    context "when filtering" do
+      before do
+        create(:result, component: component, scope: scope)
+        visit_component
+      end
+      context "when the process has a linked scope and the component has scopes disabled" do
+        before do
+          participatory_process.update(scope: scope)
+          component.update(settings: { scopes_enabled: false })
+          visit current_path
+        end
+        it "disables filtering by scope" do
+          within ".scope-filters" do
+            expect(page).not_to have_content(/Scopes/i)
+          end
+        end
+      end
+      context "when the process has no linked scope" do
+        before do
+          participatory_process.update(scope: nil)
+          visit current_path
+        end
+        it "enables filtering by scope" do
+          within ".scope-filters" do
+            expect(page).to have_content(/Scopes/i)
+          end
+        end
+      end
+    end
+    it_behaves_like "has attachments" do
+      let(:attached_to) { result }
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/types/integration_schema_spec.rb
@@ -0,0 +1,292 @@
+require "spec_helper"
+require "decidim/api/test/component_context"
+require "decidim/accountability/test/factories"
+describe "Decidim::Api::QueryType" do
+  include_context "with a graphql decidim component"
+  let(:component_type) { "Accountability" }
+  let!(:current_component) { create :accountability_component, participatory_space: participatory_process }
+  let!(:result) { create(:result, component: current_component, category: category) }
+  let!(:timeline_entry) { create(:timeline_entry, result: result) }
+  let(:accountability_single_result) do
+    {
+      "acceptsNewComments" => result.accepts_new_comments?,
+      "category" => {
+        "id" => result.category.id.to_s,
+        "name" => { "translation" => result.category.name[locale] },
+        "parent" => nil,
+        "subcategories" => []
+      },
+      "children" => [],
+      "childrenCount" => result.children.size,
+      "comments" => [],
+      "commentsHaveAlignment" => result.comments_have_alignment?,
+      "commentsHaveVotes" => result.comments_have_votes?,
+      "createdAt" => result.created_at.iso8601.to_s.gsub("Z", "+00:00"),
+      "description" => { "translation" => result.description[locale] },
+      "endDate" => result.end_date.to_s,
+      "externalId" => result.external_id,
+      "hasComments" => result.comment_threads.size.positive?,
+      "id" => result.id.to_s,
+      "parent" => result.parent,
+      "participatorySpace" => { "id" => result.participatory_space.id.to_s },
+      "progress" => result.progress.to_f,
+      "reference" => result.reference,
+      "scope" => result.scope,
+      "startDate" => result.start_date.to_s,
+      "status" => {
+        "createdAt" => result.status.created_at.to_date.to_s,
+        "description" => { "translation" => result.status.description[locale] },
+        "id" => result.status.id.to_s,
+        "key" => result.status.key,
+        "name" => { "translation" => result.status.name[locale] },
+        "progress" => result.status.progress,
+        "results" => [{ "id" => result.id.to_s }],
+        "updatedAt" => result.status.updated_at.to_date.to_s
+      },
+      "timelineEntries" => [
+        {
+          "createdAt" => result.timeline_entries.first.created_at.iso8601.to_s.gsub("Z", "+00:00"),
+          "title" => { "translation" => result.timeline_entries.first.title[locale] },
+          "description" => { "translation" => result.timeline_entries.first.description[locale] },
+          "entryDate" => result.timeline_entries.first.entry_date.to_s,
+          "id" => result.timeline_entries.first.id.to_s,
+          "result" => { "id" => result.id.to_s },
+          "updatedAt" => result.timeline_entries.first.updated_at.iso8601.to_s.gsub("Z", "+00:00")
+        }
+      ],
+      "title" => { "translation" => result.title[locale] },
+      "totalCommentsCount" => result.comments_count,
+      "type" => "Decidim::Accountability::Result",
+      "updatedAt" => result.updated_at.iso8601.to_s.gsub("Z", "+00:00"),
+      "userAllowedToComment" => result.user_allowed_to_comment?(current_user),
+      "weight" => result.weight.to_i
+    }
+  end
+  let(:accountability_data) do
+    {
+      "__typename" => "Accountability",
+      "id" => current_component.id.to_s,
+      "name" => { "translation" => "Accountability" },
+      "results" => {
+        "edges" => [
+          {
+            "node" => accountability_single_result
+          }
+        ]
+      },
+      "weight" => 0
+    }
+  end
+  describe "valid connection query" do
+    let(:component_fragment) do
+      %(
+      fragment fooComponent on Accountability {
+        results {
+          edges{
+            node{
+              acceptsNewComments
+              category {
+                id
+                name {
+                  translation(locale: "#{locale}")
+                }
+                parent {
+                  id
+                }
+                subcategories {
+                  id
+                }
+              }
+              children {
+                id
+              }
+              childrenCount
+              comments {
+                id
+              }
+              commentsHaveAlignment
+              commentsHaveVotes
+              createdAt
+              description {
+                translation(locale:"#{locale}")
+              }
+              endDate
+              externalId
+              hasComments
+              id
+              parent {
+                id
+              }
+              participatorySpace {
+                id
+              }
+              progress
+              reference
+              scope {
+                id
+                children {
+                  id
+                }
+                name {
+                  translation(locale:"#{locale}")
+                }
+                parent {
+                  id
+                }
+              }
+              startDate
+              status {
+                id
+                createdAt
+                description {
+                  translation(locale:"#{locale}")
+                }
+                key
+                name {
+                  translation(locale:"#{locale}")
+                }
+                progress
+                results {
+                  id
+                }
+                updatedAt
+              }
+              timelineEntries {
+                id
+                createdAt
+                title {
+                  translation(locale:"#{locale}")
+                }
+                description {
+                  translation(locale:"#{locale}")
+                }
+                entryDate
+                result {
+                  id
+                }
+                updatedAt
+              }
+              title {
+                translation(locale:"#{locale}")
+              }
+              totalCommentsCount
+              type
+              updatedAt
+              userAllowedToComment
+              weight
+            }
+          }
+        }
+      }
+    )
+    end
+    it "executes sucessfully" do
+      expect { response }.not_to raise_error
+    end
+    it { expect(response["participatoryProcess"]["components"].first).to eq(accountability_data) }
+  end
+  describe "valid query" do
+    let(:component_fragment) do
+      %(
+      fragment fooComponent on Accountability {
+        result(id: #{result.id}) {
+          acceptsNewComments
+          category {
+            id
+            name {
+              translation(locale: "#{locale}")
+            }
+            parent {
+              id
+            }
+            subcategories {
+              id
+            }
+          }
+          children {
+            id
+          }
+          childrenCount
+          comments {
+            id
+          }
+          commentsHaveAlignment
+          commentsHaveVotes
+          createdAt
+          description {
+            translation(locale:"#{locale}")
+          }
+          endDate
+          externalId
+          hasComments
+          id
+          parent {
+            id
+          }
+          participatorySpace {
+            id
+          }
+          progress
+          reference
+          scope {
+            id
+            children {
+              id
+            }
+            name {
+              translation(locale:"#{locale}")
+            }
+            parent {
+              id
+            }
+          }
+          startDate
+          status {
+            id
+            createdAt
+            description {
+              translation(locale:"#{locale}")
+            }
+            key
+            name {
+              translation(locale:"#{locale}")
+            }
+            progress
+            results {
+              id
+            }
+            updatedAt
+          }
+          timelineEntries {
+            id
+            createdAt
+            title {
+              translation(locale:"#{locale}")
+            }
+            description {
+              translation(locale:"#{locale}")
+            }
+            entryDate
+            result {
+              id
+            }
+            updatedAt
+          }
+          title {
+            translation(locale:"#{locale}")
+          }
+          totalCommentsCount
+          type
+          updatedAt
+          userAllowedToComment
+          weight
+        }
+      }
+    )
+    end
+    it "executes sucessfully" do
+      expect { response }.not_to raise_error
+    end
+    it { expect(response["participatoryProcess"]["components"].first["result"]).to eq(accountability_single_result) }
+  end
+end

--- a//dev/null
+++ b/decidim-accountability/spec/types/timeline_entry_type_spec.rb
@@ -0,0 +1,52 @@
+require "spec_helper"
+require "decidim/api/test/type_context"
+module Decidim
+  module Accountability
+    describe TimelineEntryType, type: :graphql do
+      include_context "with a graphql class type"
+      let(:model) { create(:timeline_entry) }
+      describe "id" do
+        let(:query) { "{ id }" }
+        it "returns the id field" do
+          expect(response["id"]).to eq(model.id.to_s)
+        end
+      end
+      describe "entryDate" do
+        let(:query) { "{ entryDate }" }
+        it "returns the entryDate" do
+          expect(response["entryDate"]).to eq(model.entry_date.to_date.iso8601)
+        end
+      end
+      describe "title" do
+        let(:query) { '{ title { translation(locale:"en")}}' }
+        it "returns the title field" do
+          expect(response["title"]["translation"]).to eq(model.title["en"])
+        end
+      end
+      describe "description" do
+        let(:query) { '{ description { translation(locale:"en")}}' }
+        it "returns the description field" do
+          expect(response["description"]["translation"]).to eq(model.description["en"])
+        end
+      end
+      describe "createdAt" do
+        let(:query) { "{ createdAt }" }
+        it "returns the createdAt" do
+          expect(response["createdAt"]).to eq(model.created_at.to_time.iso8601)
+        end
+      end
+      describe "updatedAt" do
+        let(:query) { "{ updatedAt }" }
+        it "returns the updatedAt" do
+          expect(response["updatedAt"]).to eq(model.updated_at.to_time.iso8601)
+        end
+      end
+      describe "result" do
+        let(:query) { "{ result { id } }" }
+        it "returns the result" do
+          expect(response["result"]["id"]).to eq(model.result.id.to_s)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/cells/decidim/admin/attachments_privacy_warning_cell.rb
@@ -0,0 +1,14 @@
+module Decidim
+  module Admin
+    class AttachmentsPrivacyWarningCell < Decidim::ViewModel
+      delegate :current_participatory_space, to: :controller
+      private
+      def private_space?
+        current_participatory_space.private_space if current_participatory_space.respond_to?(:private_space)
+      end
+      def transparent_space?
+        current_participatory_space.is_transparent if current_participatory_space.respond_to?(:is_transparent)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/block_user.rb
@@ -0,0 +1,54 @@
+module Decidim
+  module Admin
+    class BlockUser < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        transaction do
+          block!
+          register_justification!
+          notify_user!
+        end
+        broadcast(:ok, form.user)
+      end
+      private
+      attr_reader :form
+      def register_justification!
+        @current_blocking = UserBlock.create!(
+          justification: form.justification,
+          user: form.user,
+          blocking_user: form.current_user
+        )
+      end
+      def notify_user!
+        Decidim::BlockUserJob.perform_later(
+          @current_blocking.user,
+          @current_blocking.justification
+        )
+      end
+      def block!
+        Decidim.traceability.perform_action!(
+          "block",
+          form.user,
+          form.current_user,
+          extra: {
+            reportable_type: form.user.class.name,
+            current_justification: form.justification
+          },
+          resource: {
+            title: form.user.name
+          }
+        ) do
+          form.user.blocked = true
+          form.user.blocked_at = Time.current
+          form.user.blocking = @current_blocking
+          form.user.extended_data["user_name"] = form.user.name
+          form.user.name = "Blocked user"
+          form.user.save!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/close_session_managed_user.rb
@@ -0,0 +1,24 @@
+module Decidim
+  module Admin
+    class CloseSessionManagedUser < Decidim::Command
+      def initialize(user, current_user)
+        @user = user
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) if impersonation_log.blank?
+        close_session
+        broadcast(:ok)
+      end
+      attr_reader :current_user, :user
+      private
+      def impersonation_log
+        @impersonation_log ||= Decidim::ImpersonationLog.where(admin: current_user, user: user).active.first
+      end
+      def close_session
+        impersonation_log.ended_at = Time.current
+        impersonation_log.save!
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_area.rb
@@ -0,0 +1,25 @@
+module Decidim
+  module Admin
+    class CreateArea < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_area
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_area
+        Decidim.traceability.create!(
+          Area,
+          form.current_user,
+          name: form.name,
+          organization: form.organization,
+          area_type: form.area_type
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_area_type.rb
@@ -0,0 +1,26 @@
+module Decidim
+  module Admin
+    class CreateAreaType < Decidim::Command
+      def initialize(form, user)
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_area_type
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_area_type
+        Decidim.traceability.create!(
+          AreaType,
+          @user,
+          name: form.name,
+          organization: form.organization,
+          plural: form.plural
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_attachment.rb
@@ -0,0 +1,51 @@
+module Decidim
+  module Admin
+    class CreateAttachment < Decidim::Command
+      def initialize(form, attached_to, user)
+        @form = form
+        @attached_to = attached_to
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        build_attachment
+        if @attachment.valid?
+          Decidim.traceability.perform_action!(:create, Decidim::Attachment, @user) do
+            @attachment.save!
+            notify_followers
+            broadcast(:ok)
+            @attachment
+          end
+        else
+          @form.errors.add :file, @attachment.errors[:file] if @attachment.errors.has_key? :file
+          broadcast(:invalid)
+        end
+      end
+      private
+      attr_reader :form
+      def build_attachment
+        @attachment = Attachment.new(
+          title: form.title,
+          description: form.description,
+          attached_to: @attached_to,
+          weight: form.weight,
+          attachment_collection: form.attachment_collection,
+          file: form.file, # Define attached_to before this
+          content_type: blob(form.file).content_type
+        )
+      end
+      def notify_followers
+        return unless @attachment.attached_to.is_a?(Decidim::Followable)
+        Decidim::EventsManager.publish(
+          event: "decidim.events.attachments.attachment_created",
+          event_class: Decidim::AttachmentCreatedEvent,
+          resource: @attachment,
+          followers: @attachment.attached_to.followers
+        )
+      end
+      def blob(signed_id)
+        ActiveStorage::Blob.find_signed(signed_id)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_attachment_collection.rb
@@ -0,0 +1,33 @@
+module Decidim
+  module Admin
+    class CreateAttachmentCollection < Decidim::Command
+      def initialize(form, collection_for, user)
+        @form = form
+        @collection_for = collection_for
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_attachment_collection
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_attachment_collection
+        Decidim.traceability.create!(
+          AttachmentCollection,
+          @user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          weight: form.weight,
+          description: form.description,
+          collection_for: @collection_for
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_category.rb
@@ -0,0 +1,28 @@
+module Decidim
+  module Admin
+    class CreateCategory < Decidim::Command
+      def initialize(form, participatory_space, user)
+        @form = form
+        @participatory_space = participatory_space
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_category
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_category
+        Decidim.traceability.create!(
+          Category,
+          @user,
+          name: form.name,
+          weight: form.weight,
+          parent_id: form.parent_id,
+          participatory_space: @participatory_space
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_component.rb
@@ -0,0 +1,36 @@
+module Decidim
+  module Admin
+    class CreateComponent < Decidim::Command
+      attr_reader :form, :manifest, :participatory_space
+      def initialize(form)
+        @form = form
+        @manifest = form.manifest
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        transaction do
+          create_component
+          run_hooks
+        end
+        broadcast(:ok)
+      end
+      private
+      def create_component
+        @component = Decidim.traceability.create!(
+          Component,
+          form.current_user,
+          manifest_name: manifest.name,
+          name: form.name,
+          participatory_space: form.participatory_space,
+          weight: form.weight,
+          settings: form.settings,
+          default_step_settings: form.default_step_settings,
+          step_settings: form.step_settings
+        )
+      end
+      def run_hooks
+        manifest.run_hooks(:create, @component)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_import.rb
@@ -0,0 +1,21 @@
+module Decidim
+  module Admin
+    class CreateImport < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        imported_data = form.importer.prepare
+        transaction do
+          form.importer.import!
+          broadcast(:ok, imported_data)
+        rescue StandardError
+          broadcast(:invalid)
+          raise ActiveRecord::Rollback
+        end
+      end
+      attr_reader :form
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_import_example.rb
@@ -0,0 +1,15 @@
+module Decidim
+  module Admin
+    class CreateImportExample < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        broadcast(:ok, form.example)
+      end
+      private
+      attr_reader :form
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_newsletter.rb
@@ -0,0 +1,41 @@
+module Decidim
+  module Admin
+    class CreateNewsletter < Decidim::Command
+      def initialize(form, content_block, user)
+        @form = form
+        @content_block = content_block
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        transaction do
+          create_newsletter
+          create_content_block
+        end
+        broadcast(:ok, newsletter)
+      end
+      private
+      attr_reader :user, :form, :newsletter, :content_block
+      def create_newsletter
+        @newsletter = Decidim.traceability.create!(
+          Newsletter,
+          user,
+          subject: form.subject,
+          author: user,
+          organization: user.organization
+        )
+      end
+      def create_content_block
+        UpdateContentBlock.call(form, content_block, user) do
+          on(:ok) do |content_block|
+            content_block.update(scoped_resource_id: newsletter.id)
+            @content_block = content_block
+          end
+          on(:invalid) do
+            raise "There was a problem persisting the changes to the content block"
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_participatory_space_private_user.rb
@@ -0,0 +1,68 @@
+module Decidim
+  module Admin
+    class CreateParticipatorySpacePrivateUser < Decidim::Command
+      def initialize(form, current_user, private_user_to, via_csv: false)
+        @form = form
+        @current_user = current_user
+        @private_user_to = private_user_to
+        @via_csv = via_csv
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        ActiveRecord::Base.transaction do
+          @user ||= existing_user || new_user
+          create_private_user
+        end
+        broadcast(:ok)
+      rescue ActiveRecord::RecordInvalid
+        form.errors.add(:email, :taken)
+        broadcast(:invalid)
+      end
+      private
+      attr_reader :form, :private_user_to, :current_user, :user
+      def create_private_user
+        action = @via_csv ? "create_via_csv" : "create"
+        Decidim.traceability.perform_action!(
+          action,
+          Decidim::ParticipatorySpacePrivateUser,
+          current_user,
+          resource: {
+            title: user.name
+          }
+        ) do
+          Decidim::ParticipatorySpacePrivateUser.find_or_create_by!(
+            user: user,
+            privatable_to: @private_user_to
+          )
+        end
+      end
+      def existing_user
+        return @existing_user if defined?(@existing_user)
+        @existing_user = User.find_by(
+          email: form.email,
+          organization: private_user_to.organization
+        )
+        InviteUserAgain.call(@existing_user, invitation_instructions) if @existing_user&.invitation_pending?
+        @existing_user
+      end
+      def new_user
+        @new_user ||= InviteUser.call(user_form) do
+          on(:ok) do |user|
+            return user
+          end
+        end
+      end
+      def user_form
+        OpenStruct.new(name: form.name,
+                       email: form.email.downcase,
+                       organization: private_user_to.organization,
+                       admin: false,
+                       invited_by: current_user,
+                       invitation_instructions: invitation_instructions)
+      end
+      def invitation_instructions
+        "invite_private_user"
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_scope.rb
@@ -0,0 +1,34 @@
+module Decidim
+  module Admin
+    class CreateScope < Decidim::Command
+      def initialize(form, parent_scope = nil)
+        @form = form
+        @parent_scope = parent_scope
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_scope
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_scope
+        Decidim.traceability.create!(
+          Scope,
+          form.current_user,
+          {
+            name: form.name,
+            organization: form.organization,
+            code: form.code,
+            scope_type: form.scope_type,
+            parent: @parent_scope
+          },
+          extra: {
+            parent_name: @parent_scope.try(:name),
+            scope_type_name: form.scope_type.try(:name)
+          }
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_scope_type.rb
@@ -0,0 +1,26 @@
+module Decidim
+  module Admin
+    class CreateScopeType < Decidim::Command
+      def initialize(form, user)
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_scope_type
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_scope_type
+        Decidim.traceability.create!(
+          ScopeType,
+          @user,
+          name: form.name,
+          organization: form.organization,
+          plural: form.plural
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_static_page.rb
@@ -0,0 +1,40 @@
+module Decidim
+  module Admin
+    class CreateStaticPage < Decidim::Command
+      def initialize(form)
+        @form = form
+        @page = nil
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        create_page
+        update_organization_tos_version
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def create_page
+        @page = Decidim.traceability.create!(
+          StaticPage,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          organization: form.organization,
+          title: form.title,
+          slug: form.slug,
+          show_in_footer: form.show_in_footer,
+          weight: form.weight,
+          topic: form.topic,
+          content: form.content,
+          allow_public_access: form.allow_public_access
+        }
+      end
+      def update_organization_tos_version
+        UpdateOrganizationTosVersion.call(@form.organization, @page, @form)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/create_static_page_topic.rb
@@ -0,0 +1,22 @@
+module Decidim
+  module Admin
+    class CreateStaticPageTopic < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if @form.invalid?
+        @topic = Decidim.traceability.create!(
+          StaticPageTopic,
+          @form.current_user,
+          title: @form.title,
+          description: @form.description,
+          organization: @form.current_organization,
+          show_in_footer: @form.show_in_footer,
+          weight: @form.weight
+        )
+        broadcast(:ok)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/deliver_newsletter.rb
@@ -0,0 +1,35 @@
+module Decidim
+  module Admin
+    class DeliverNewsletter < Decidim::Command
+      def initialize(newsletter, form, user)
+        @newsletter = newsletter
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if @form.send_to_all_users && !@user.admin?
+        return broadcast(:invalid) unless @form.valid?
+        return broadcast(:invalid) if @newsletter.sent?
+        return broadcast(:no_recipients) if recipients.blank?
+        @newsletter.with_lock do
+          send_newsletter!
+        end
+        broadcast(:ok, @newsletter)
+      end
+      private
+      attr_reader :form
+      def send_newsletter!
+        Decidim.traceability.perform_action!(
+          "deliver",
+          @newsletter,
+          @user
+        ) do
+          NewsletterJob.perform_later(@newsletter, @form.as_json, recipients.map(&:id))
+        end
+      end
+      def recipients
+        @recipients ||= Decidim::Admin::NewsletterRecipients.for(@form)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_area.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Admin
+    class DestroyArea < Decidim::Command
+      def initialize(area, current_user)
+        @area = area
+        @current_user = current_user
+      end
+      def call
+        destroy_area
+        broadcast(:ok)
+      rescue ActiveRecord::RecordNotDestroyed
+        broadcast(:has_spaces)
+      end
+      private
+      attr_reader :current_user
+      def destroy_area
+        Decidim.traceability.perform_action!(
+          "delete",
+          @area,
+          current_user
+        ) do
+          @area.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_category.rb
@@ -0,0 +1,22 @@
+module Decidim
+  module Admin
+    class DestroyCategory < Decidim::Command
+      def initialize(category, user)
+        @category = category
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if category.nil? || category.subcategories.any?
+        destroy_category
+        broadcast(:ok)
+      end
+      private
+      attr_reader :category
+      def destroy_category
+        Decidim.traceability.perform_action!(:delete, category, @user) do
+          category.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_component.rb
@@ -0,0 +1,38 @@
+module Decidim
+  module Admin
+    class DestroyComponent < Decidim::Command
+      def initialize(component, current_user)
+        @component = component
+        @current_user = current_user
+      end
+      def call
+        begin
+          destroy_component
+        rescue StandardError
+          return broadcast(:invalid)
+        end
+        broadcast(:ok)
+      end
+      private
+      def destroy_component
+        transaction do
+          run_before_hooks
+          Decidim.traceability.perform_action!(
+            "delete",
+            @component,
+            @current_user
+          ) do
+            @component.destroy!
+          end
+          run_hooks
+        end
+      end
+      def run_before_hooks
+        @component.manifest.run_hooks(:before_destroy, @component)
+      end
+      def run_hooks
+        @component.manifest.run_hooks(:destroy, @component)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_newsletter.rb
@@ -0,0 +1,26 @@
+module Decidim
+  module Admin
+    class DestroyNewsletter < Decidim::Command
+      def initialize(newsletter, current_user)
+        @newsletter = newsletter
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:already_sent) if newsletter.sent?
+        destroy_newsletter
+        broadcast(:ok)
+      end
+      private
+      attr_reader :newsletter, :current_user
+      def destroy_newsletter
+        Decidim.traceability.perform_action!(
+          "delete",
+          newsletter,
+          current_user
+        ) do
+          newsletter.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_participatory_space_private_user.rb
@@ -0,0 +1,28 @@
+module Decidim
+  module Admin
+    class DestroyParticipatorySpacePrivateUser < Decidim::Command
+      def initialize(participatory_space_private_user, current_user)
+        @participatory_space_private_user = participatory_space_private_user
+        @current_user = current_user
+      end
+      def call
+        destroy_participatory_space_private_user
+        broadcast(:ok)
+      end
+      private
+      attr_reader :current_user
+      def destroy_participatory_space_private_user
+        Decidim.traceability.perform_action!(
+          "delete",
+          @participatory_space_private_user,
+          current_user,
+          resource: {
+            title: @participatory_space_private_user.user.name
+          }
+        ) do
+          @participatory_space_private_user.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_scope.rb
@@ -0,0 +1,29 @@
+module Decidim
+  module Admin
+    class DestroyScope < Decidim::Command
+      def initialize(scope, current_user)
+        @scope = scope
+        @current_user = current_user
+      end
+      def call
+        update_scope
+        broadcast(:ok)
+      end
+      private
+      attr_reader :current_user
+      def update_scope
+        Decidim.traceability.perform_action!(
+          "delete",
+          @scope,
+          current_user,
+          extra: {
+            parent_name: @scope.parent.try(:name),
+            scope_type_name: @scope.scope_type.try(:name)
+          }
+        ) do
+          @scope.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_share_token.rb
@@ -0,0 +1,29 @@
+module Decidim
+  module Admin
+    class DestroyShareToken < Decidim::Command
+      def initialize(share_token, current_user)
+        @share_token = share_token
+        @current_user = current_user
+      end
+      def call
+        begin
+          destroy_share_token
+        rescue StandardError
+          broadcast(:invalid)
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :current_user
+      def destroy_share_token
+        Decidim.traceability.perform_action!(
+          "delete",
+          @share_token,
+          current_user
+        ) do
+          @share_token.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_static_page.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Admin
+    class DestroyStaticPage < Decidim::Command
+      def initialize(page, current_user)
+        @page = page
+        @current_user = current_user
+      end
+      def call
+        destroy_page
+        broadcast(:ok)
+      end
+      private
+      attr_reader :page, :current_user
+      def destroy_page
+        transaction do
+          Decidim.traceability.perform_action!(
+            "delete",
+            page,
+            current_user
+          ) do
+            page.destroy!
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/destroy_static_page_topic.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Admin
+    class DestroyStaticPageTopic < Decidim::Command
+      def initialize(_topic, current_user)
+        @topic = page
+        @current_user = current_user
+      end
+      def call
+        destroy_topic
+        broadcast(:ok)
+      end
+      private
+      attr_reader :page, :current_user
+      def destroy_page
+        transaction do
+          Decidim.traceability.perform_action!(
+            "delete",
+            topic,
+            current_user
+          ) do
+            topic.destroy!
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/hide_resource.rb
@@ -0,0 +1,48 @@
+module Decidim
+  module Admin
+    class HideResource < Decidim::Command
+      def initialize(reportable, current_user)
+        @reportable = reportable
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless hideable?
+        hide!
+        send_hide_notification_to_author
+        broadcast(:ok, @reportable)
+      end
+      private
+      def hideable?
+        !@reportable.hidden? && @reportable.reported?
+      end
+      def hide!
+        Decidim.traceability.perform_action!(
+          "hide",
+          @reportable.moderation,
+          @current_user,
+          extra: {
+            reportable_type: @reportable.class.name
+          }
+        ) do
+          @reportable.moderation.update!(hidden_at: Time.current)
+          @reportable.try(:touch)
+        end
+      end
+      def send_hide_notification_to_author
+        data = {
+          event: "decidim.events.reports.resource_hidden",
+          event_class: Decidim::ResourceHiddenEvent,
+          resource: @reportable,
+          extra: {
+            report_reasons: report_reasons
+          },
+          affected_users: @reportable.try(:authors) || [@reportable.try(:normalized_author)]
+        }
+        Decidim::EventsManager.publish(**data)
+      end
+      def report_reasons
+        @reportable.moderation.reports.pluck(:reason).uniq
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/impersonate_user.rb
@@ -0,0 +1,55 @@
+module Decidim
+  module Admin
+    class ImpersonateUser < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        transaction do
+          user.save! unless user.persisted?
+          create_authorization
+          impersonation_log = create_impersonation_log
+          create_action_log(impersonation_log)
+        end
+        enqueue_expire_job
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def user
+        form.user
+      end
+      def create_authorization
+        Authorization.create_or_update_from(form.authorization)
+      end
+      def create_impersonation_log
+        Decidim::ImpersonationLog.create!(
+          admin: form.current_user,
+          user: user,
+          reason: form.reason,
+          started_at: Time.current
+        )
+      end
+      def enqueue_expire_job
+        Decidim::Admin::ExpireImpersonationJob
+          .set(wait: Decidim::ImpersonationLog::SESSION_TIME_IN_MINUTES.minutes)
+          .perform_later(user, form.current_user)
+      end
+      def create_action_log(impersonation_log)
+        Decidim.traceability.perform_action!(
+          "manage",
+          impersonation_log,
+          form.current_user,
+          resource: {
+            name: user.name,
+            id: user.id,
+            nickname: user.nickname
+          },
+          visibility: "admin-only",
+          reason: form.reason
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/invite_admin.rb
@@ -0,0 +1,40 @@
+module Decidim
+  module Admin
+    class InviteAdmin < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        transaction do
+          invite_user
+          log_action
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :user, :form
+      def invite_user
+        InviteUser.call(form) do
+          on(:ok) do |user|
+            save_user(user)
+          end
+        end
+      end
+      def save_user(user)
+        @user = user
+      end
+      def log_action
+        Decidim.traceability.perform_action!(
+          "invite",
+          user,
+          form.current_user,
+          extra: {
+            invited_user_role: form.role,
+            invited_user_id: user.id
+          }
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/officialize_user.rb
@@ -0,0 +1,41 @@
+module Decidim
+  module Admin
+    class OfficializeUser < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        officialize_user
+        Decidim::EventsManager.publish(
+          event: "decidim.events.users.user_officialized",
+          event_class: Decidim::ProfileUpdatedEvent,
+          resource: form.user,
+          followers: form.user.followers
+        )
+        broadcast(:ok, form.user)
+      end
+      private
+      attr_reader :form
+      def officialize_user
+        timestamp = Time.current
+        Decidim.traceability.perform_action!(
+          "officialize",
+          form.user,
+          form.current_user,
+          extra: {
+            officialized_user_badge: form.officialized_as,
+            officialized_user_badge_previous: form.user.officialized_as,
+            officialized_user_at: timestamp,
+            officialized_user_at_previous: form.user.officialized_at
+          }
+        ) do
+          form.user.update!(
+            officialized_at: timestamp,
+            officialized_as: form.officialized_as
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/process_participatory_space_private_user_import_csv.rb
@@ -0,0 +1,26 @@
+require "csv"
+module Decidim
+  module Admin
+    class ProcessParticipatorySpacePrivateUserImportCsv < Decidim::Command
+      include Decidim::ProcessesFileLocally
+      def initialize(form, current_user, private_users_to)
+        @form = form
+        @current_user = current_user
+        @private_users_to = private_users_to
+      end
+      def call
+        return broadcast(:invalid) unless @form.valid?
+        process_csv
+        broadcast(:ok)
+      end
+      private
+      def process_csv
+        process_file_locally(@form.file) do |file_path|
+          CSV.foreach(file_path, encoding: "BOM|UTF-8") do |email, user_name|
+            ImportParticipatorySpacePrivateUserCsvJob.perform_later(email, user_name, @private_users_to, @current_user) if email.present? && user_name.present?
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/process_user_group_verification_csv.rb
@@ -0,0 +1,27 @@
+require "csv"
+module Decidim
+  module Admin
+    class ProcessUserGroupVerificationCsv < Decidim::Command
+      include Decidim::ProcessesFileLocally
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) unless @form.valid?
+        process_csv
+        broadcast(:ok)
+      end
+      private
+      def process_csv
+        verifier = @form.current_user
+        organization = @form.current_organization
+        process_file_locally(@form.file) do |file_path|
+          CSV.foreach(file_path) do |row|
+            email = row[0]
+            VerifyUserGroupFromCsvJob.perform_later(email, verifier, organization) if email.present?
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/promote_managed_user.rb
@@ -0,0 +1,39 @@
+module Decidim
+  module Admin
+    class PromoteManagedUser < Decidim::Command
+      def initialize(form, user, promoted_by)
+        @form = form
+        @user = user
+        @promoted_by = promoted_by
+      end
+      def call
+        return broadcast(:invalid) if form.invalid? || !user.managed? || email_already_exists?
+        promote_user
+        invite_user
+        create_action_log
+        broadcast(:ok)
+      end
+      attr_reader :form, :user, :promoted_by
+      private
+      def promote_user
+        user.email = form.email.downcase
+        user.skip_reconfirmation!
+        user.save(validate: false)
+      end
+      def invite_user
+        user.invite!(promoted_by)
+      end
+      def email_already_exists?
+        Decidim::User.where(email: form.email.downcase).any?
+      end
+      def create_action_log
+        Decidim.traceability.perform_action!(
+          "promote",
+          user,
+          form.current_user,
+          visibility: "admin-only"
+        )
+      end
+    end
+  end
+end

--- a/decidim-admin/app/commands/decidim/admin/publish_component.rb
+++ b/decidim-admin/app/commands/decidim/admin/publish_component.rb
@@ -1,20 +1,20 @@
 module Decidim
   module Admin
     class PublishComponent < Decidim::Command
       def initialize(component, current_user)
         @component = component
         @current_user = current_user
       end
       def call
         publish_component
-        publish_event unless component.previously_published?
+        publish_event
         broadcast(:ok)
       end
       private
       attr_reader :component, :current_user
       def publish_component
         Decidim.traceability.perform_action!(
           :publish,
           component,
           current_user,
           visibility: "all"

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/reject_user_group.rb
@@ -0,0 +1,25 @@
+module Decidim
+  module Admin
+    class RejectUserGroup < Decidim::Command
+      def initialize(user_group, current_user)
+        @user_group = user_group
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless @user_group.valid?
+        reject_user_group
+        broadcast(:ok)
+      end
+      private
+      def reject_user_group
+        Decidim.traceability.perform_action!(
+          "reject",
+          @user_group,
+          @current_user
+        ) do
+          @user_group.reject!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/remove_admin.rb
@@ -0,0 +1,29 @@
+module Decidim
+  module Admin
+    class RemoveAdmin < Decidim::Command
+      def initialize(user, current_user)
+        @user = user
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless user
+        Decidim.traceability.perform_action!(
+          "remove_from_admin",
+          user,
+          current_user,
+          extra: {
+            invited_user_role: user_role
+          }
+        ) do
+          user.update!(admin: false, roles: [])
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :user, :current_user
+      def user_role
+        user.admin? ? :admin : user.roles.last
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/reorder_content_blocks.rb
@@ -0,0 +1,66 @@
+module Decidim
+  module Admin
+    class ReorderContentBlocks < Decidim::Command
+      def initialize(organization, scope, order, scoped_resource_id = nil)
+        @organization = organization
+        @scope = scope
+        @order = order
+        @scoped_resource_id = scoped_resource_id
+      end
+      def call
+        return broadcast(:invalid) if order.blank?
+        reorder_steps
+        broadcast(:ok)
+      end
+      private
+      attr_reader :organization, :scope, :scoped_resource_id
+      def reorder_steps
+        transaction do
+          reset_weights
+          collection.reload
+          set_new_weights
+          unpublish_removed_content_blocks
+          publish_appearing_content_blocks
+        end
+      end
+      def reset_weights
+        collection.where.not(weight: nil).update_all(weight: nil)
+      end
+      def set_new_weights
+        data = order.each_with_index.inject({}) do |hash, (manifest_name, index)|
+          hash.update(manifest_name => index + 1)
+        end
+        data.each do |manifest_name, weight|
+          content_block = collection.find { |block| block.manifest_name == manifest_name }
+          if content_block.present?
+            content_block.update!(weight: weight)
+          else
+            create_content_block(manifest_name, weight)
+          end
+        end
+      end
+      def unpublish_removed_content_blocks
+        collection.where(weight: nil).update_all(published_at: nil)
+      end
+      def publish_appearing_content_blocks
+        collection.where(published_at: nil).where.not(weight: nil).update_all(published_at: Time.current)
+      end
+      def create_content_block(manifest_name, weight)
+        Decidim::ContentBlock.create!(
+          organization: organization,
+          scope_name: scope,
+          scoped_resource_id: scoped_resource_id.presence,
+          weight: weight,
+          manifest_name: manifest_name
+        )
+      end
+      def order
+        return nil unless @order.is_a?(Array) && @order.present?
+        @order
+      end
+      def collection
+        @collection ||= Decidim::ContentBlock.for_scope(scope, organization: organization).where(scoped_resource_id: scoped_resource_id)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/transfer_user.rb
@@ -0,0 +1,52 @@
+module Decidim
+  module Admin
+    class TransferUser < Decidim::Command
+      def initialize(form)
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        transaction do
+          update_managed_user
+          mark_conflict_as_solved
+          create_action_log
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def new_user
+        form.conflict.current_user
+      end
+      def managed_user
+        form.conflict.managed_user
+      end
+      def current_user
+        form.current_user
+      end
+      def update_managed_user
+        clean_email_and_delete_new_user if form.email == new_user.email
+        managed_user.email = form.email
+        managed_user.encrypted_password = new_user.encrypted_password
+        managed_user.confirmed_at = new_user.confirmed_at
+        managed_user.managed = false
+        managed_user.skip_reconfirmation!
+        managed_user.save!
+      end
+      def clean_email_and_delete_new_user
+        new_user.update(deleted_at: Time.now.utc, email: "")
+      end
+      def mark_conflict_as_solved
+        form.conflict.update(solved: true)
+      end
+      def create_action_log
+        Decidim.traceability.perform_action!(
+          "transfer",
+          form.conflict.managed_user,
+          current_user,
+          visibility: "admin-only"
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unblock_user.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Admin
+    class UnblockUser < Decidim::Command
+      def initialize(blocked_user, current_user)
+        @blocked_user = blocked_user
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless @blocked_user.blocked?
+        unblock!
+        broadcast(:ok, @blocked_user)
+      end
+      private
+      def unblock!
+        Decidim.traceability.perform_action!(
+          "unblock",
+          @blocked_user,
+          @current_user,
+          extra: {
+            reportable_type: @blocked_user.class.name
+          }
+        ) do
+          @blocked_user.blocked = false
+          @blocked_user.blocked_at = nil
+          @blocked_user.block_id = nil
+          @blocked_user.name = @blocked_user.user_name
+          @blocked_user.save!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unhide_resource.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Admin
+    class UnhideResource < Decidim::Command
+      def initialize(reportable, current_user)
+        @reportable = reportable
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless unhideable?
+        unhide!
+        broadcast(:ok, @reportable)
+      end
+      private
+      def unhideable?
+        @reportable.hidden? && @reportable.reported?
+      end
+      def unhide!
+        Decidim.traceability.perform_action!(
+          "unhide",
+          @reportable.moderation,
+          @current_user,
+          extra: {
+            reportable_type: @reportable.class.name
+          }
+        ) do
+          @reportable.moderation.update!(hidden_at: nil)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unofficialize_user.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Admin
+    class UnofficializeUser < Decidim::Command
+      def initialize(user, current_user)
+        @user = user
+        @current_user = current_user
+      end
+      def call
+        unofficialize_user
+        broadcast(:ok)
+      end
+      private
+      attr_reader :user, :current_user
+      def unofficialize_user
+        Decidim.traceability.perform_action!(
+          "unofficialize",
+          user,
+          current_user,
+          extra: {
+            officialized_user_badge: nil,
+            officialized_user_badge_previous: user.officialized_as,
+            officialized_user_at: nil,
+            officialized_user_at_previous: user.officialized_at
+          }
+        ) do
+          user.update!(officialized_at: nil, officialized_as: nil)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unpublish_component.rb
@@ -0,0 +1,26 @@
+module Decidim
+  module Admin
+    class UnpublishComponent < Decidim::Command
+      def initialize(component, current_user)
+        @component = component
+        @current_user = current_user
+      end
+      def call
+        unpublish_component
+        broadcast(:ok)
+      end
+      private
+      attr_reader :component, :current_user
+      def unpublish_component
+        Decidim.traceability.perform_action!(
+          :unpublish,
+          component,
+          current_user
+        ) do
+          component.unpublish!
+          component
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unreport_resource.rb
@@ -0,0 +1,28 @@
+module Decidim
+  module Admin
+    class UnreportResource < Decidim::Command
+      def initialize(reportable, current_user)
+        @reportable = reportable
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless @reportable.reported?
+        unreport!
+        broadcast(:ok, @reportable)
+      end
+      private
+      def unreport!
+        Decidim.traceability.perform_action!(
+          "unreport",
+          @reportable.moderation,
+          @current_user,
+          extra: {
+            reportable_type: @reportable.class.name
+          }
+        ) do
+          @reportable.moderation.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/unreport_user.rb
@@ -0,0 +1,30 @@
+module Decidim
+  module Admin
+    class UnreportUser < Decidim::Command
+      def initialize(reportable, current_user)
+        @reportable = reportable
+        @current_user = current_user
+      end
+      def call
+        return broadcast(:invalid) unless @reportable.reported?
+        unreport!
+        broadcast(:ok, @reportable)
+      end
+      private
+      def unreport!
+        Decidim.traceability.perform_action!(
+          "unreport",
+          @reportable.user_moderation,
+          @current_user,
+          extra: {
+            reportable_type: @reportable.class.name,
+            username: @reportable.name,
+            user_id: @reportable.id
+          }
+        ) do
+          @reportable.user_moderation.destroy!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_area.rb
@@ -0,0 +1,30 @@
+module Decidim
+  module Admin
+    class UpdateArea < Decidim::Command
+      def initialize(area, form)
+        @area = area
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_area
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_area
+        Decidim.traceability.update!(
+          @area,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          area_type: form.area_type
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_area_type.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Admin
+    class UpdateAreaType < Decidim::Command
+      def initialize(area_type, form, user)
+        @area_type = area_type
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_area_type
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_area_type
+        Decidim.traceability.update!(
+          @area_type,
+          @user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          plural: form.plural
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_attachment.rb
@@ -0,0 +1,36 @@
+module Decidim
+  module Admin
+    class UpdateAttachment < Decidim::Command
+      include ::Decidim::AttachmentAttributesMethods
+      attr_reader :attachment
+      def initialize(attachment, form, user)
+        @attachment = attachment
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_attachment
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_attachment
+        Decidim.traceability.update!(@attachment, @user, attributes)
+      end
+      def attributes
+        {
+          title: form.title,
+          file: form.file,
+          description: form.description,
+          weight: form.weight,
+          attachment_collection: form.attachment_collection
+        }.merge(
+          attachment_attributes(:file)
+        ).reject do |attribute, value|
+          value.blank? && attribute != :attachment_collection
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_attachment_collection.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Admin
+    class UpdateAttachmentCollection < Decidim::Command
+      def initialize(attachment_collection, form, user)
+        @attachment_collection = attachment_collection
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_attachment_collection
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_attachment_collection
+        Decidim.traceability.update!(
+          @attachment_collection,
+          @user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          weight: form.weight,
+          description: form.description
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_category.rb
@@ -0,0 +1,33 @@
+module Decidim
+  module Admin
+    class UpdateCategory < Decidim::Command
+      attr_reader :category
+      def initialize(category, form, user)
+        @category = category
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_category
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_category
+        Decidim.traceability.update!(
+          category,
+          @user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          weight: form.weight,
+          parent_id: form.parent_id
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_component.rb
@@ -0,0 +1,62 @@
+module Decidim
+  module Admin
+    class UpdateComponent < Decidim::Command
+      attr_reader :form, :component, :previous_settings
+      def initialize(form, component, user)
+        @manifest = component.manifest
+        @form = form
+        @component = component
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        Decidim.traceability.perform_action!("update", @component, @user) do
+          transaction do
+            update_component
+            run_hooks
+          end
+        end
+        broadcast(:ok, settings_changed?, previous_settings, current_settings)
+      end
+      private
+      def update_component
+        @previous_settings = @component.attributes["settings"].with_indifferent_access
+        @component.name = form.name
+        @component.weight = form.weight
+        restore_readonly_settings!
+        @component.settings = form.settings
+        @component.default_step_settings = form.default_step_settings
+        @component.step_settings = form.step_settings
+        @settings_changed = @component.settings_changed?
+        @component.save!
+      end
+      def run_hooks
+        @manifest.run_hooks(:update, @component)
+      end
+      def settings_changed?
+        @settings_changed
+      end
+      def current_settings
+        @component.attributes["settings"]
+      end
+      def restore_readonly_settings!
+        browse_readonly_settings("global") do |attribute|
+          form.settings[attribute] = @previous_settings.dig("global", attribute)
+        end
+        browse_readonly_settings("step") do |attribute|
+          form.default_step_settings[attribute] = @previous_settings.dig("default_step", attribute) if form.default_step_settings.present?
+          if form.step_settings.present?
+            form.step_settings.each do |step_name, step|
+              step[attribute] = @previous_settings.dig("steps", step_name, attribute)
+            end
+          end
+        end
+      end
+      def browse_readonly_settings(settings_name)
+        @component.manifest.settings(settings_name).attributes
+                  .select { |_attribute, obj| obj.readonly?(component: @component) }
+                  .each { |attribute, _obj| yield(attribute) }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_component_permissions.rb
@@ -0,0 +1,65 @@
+module Decidim
+  module Admin
+    class UpdateComponentPermissions < Decidim::Command
+      def initialize(form, component, resource, user)
+        @form = form
+        @component = component
+        @resource = resource
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        Decidim.traceability.perform_action!("update_permissions", @component, @user) do
+          transaction do
+            update_permissions
+            run_hooks
+          end
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form, :component, :resource
+      def configured_permissions
+        form.permissions.select do |action, permission|
+          selected_handlers(permission).present? || overriding_component_permissions?(action)
+        end
+      end
+      def update_permissions
+        permissions = configured_permissions.inject({}) do |result, (key, value)|
+          handlers_content = {}
+          selected_handlers(value).each do |handler_key|
+            opts = value.authorization_handlers_options[handler_key.to_s]
+            handlers_content[handler_key] = opts ? { options: opts } : {}
+          end
+          serialized = {
+            "authorization_handlers" => handlers_content
+          }
+          result.update(key => selected_handlers(value).any? ? serialized : {})
+        end
+        if resource
+          resource_permissions.update!(permissions: different_from_component_permissions(permissions))
+        else
+          component.update!(permissions: permissions)
+        end
+      end
+      def run_hooks
+        component.manifest.run_hooks(:permission_update, component: component, resource: resource)
+      end
+      def resource_permissions
+        @resource_permissions ||= resource.resource_permission || resource.build_resource_permission
+      end
+      def different_from_component_permissions(permissions)
+        return permissions unless component.permissions
+        permissions.deep_stringify_keys.reject do |action, config|
+          Hashdiff.diff(config, component.permissions[action]).empty?
+        end
+      end
+      def overriding_component_permissions?(action)
+        resource && component&.permissions&.fetch(action, nil)
+      end
+      def selected_handlers(permission)
+        permission.authorization_handlers_names & component.organization.available_authorizations
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_content_block.rb
@@ -0,0 +1,42 @@
+module Decidim
+  module Admin
+    class UpdateContentBlock < Decidim::Command
+      attr_reader :form, :content_block, :scope
+      def initialize(form, content_block, scope)
+        @form = form
+        @content_block = content_block
+        @scope = scope
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        images_valid = true
+        transaction do
+          update_content_block_settings
+          content_block.save!
+          update_content_block_images
+          unless content_block.valid?
+            images_valid = false
+            raise ActiveRecord::Rollback
+          end
+          content_block.save!
+        end
+        return broadcast(:invalid) unless images_valid
+        broadcast(:ok, content_block)
+      end
+      private
+      def update_content_block_settings
+        content_block.settings = form.settings
+      end
+      def update_content_block_images
+        content_block.manifest.images.each do |image_config|
+          image_name = image_config[:name]
+          if form.images[image_name]
+            content_block.images_container.send("#{image_name}=", form.images[image_name])
+          elsif form.images["remove_#{image_name}".to_sym] == "1"
+            content_block.images_container.send("#{image_name}=", nil)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_external_domain_whitelist.rb
@@ -0,0 +1,26 @@
+module Decidim
+  module Admin
+    class UpdateExternalDomainWhitelist < Decidim::Command
+      attr_reader :form, :organization
+      def initialize(form, organization, user)
+        @form = form
+        @organization = organization
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        Decidim.traceability.perform_action!("update_external_domain", @organization, @user) do
+          save_domains!
+        end
+        broadcast(:ok)
+      end
+      private
+      def save_domains!
+        organization.external_domain_whitelist = form.external_domains.filter_map do |external_domain_form|
+          external_domain_form.value unless external_domain_form.deleted
+        end.flatten
+        organization.save!
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_help_sections.rb
@@ -0,0 +1,29 @@
+module Decidim
+  module Admin
+    class UpdateHelpSections < Decidim::Command
+      def initialize(form, organization, user)
+        @form = form
+        @organization = organization
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) unless @form.valid?
+        ActiveRecord::Base.transaction do
+          @form.sections.each do |section|
+            next unless content_has_changed?(section)
+            Decidim.traceability.perform_action!("update", ContextualHelpSection, @user, { "resource" => { "title" => section.id.humanize } }) do
+              ContextualHelpSection.set_content(@organization, section.id, section.content)
+              ContextualHelpSection.find_by(organization: @organization, section_id: section.id)
+            end
+          end
+        end
+        broadcast(:ok)
+      end
+      private
+      def content_has_changed?(section)
+        return if ContextualHelpSection.find_by(organization: @organization, section_id: section.id).nil? && section.content.compact_blank.blank?
+        section.content != ContextualHelpSection.find_content(@organization, section.id).except("machine_translations")
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_newsletter.rb
@@ -0,0 +1,43 @@
+module Decidim
+  module Admin
+    class UpdateNewsletter < Decidim::Command
+      def initialize(newsletter, form, user)
+        @newsletter = newsletter
+        @content_block = newsletter.template
+        @form = form
+        @user = user
+        @organization = user.organization
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        return broadcast(:invalid) if newsletter.sent?
+        return broadcast(:invalid) unless organization == newsletter.organization
+        transaction do
+          update_newsletter
+          update_content_block
+        end
+        broadcast(:ok, newsletter)
+      end
+      private
+      attr_reader :user, :newsletter, :content_block, :organization, :form
+      def update_newsletter
+        @newsletter = Decidim.traceability.update!(
+          newsletter,
+          user,
+          subject: form.subject,
+          author: user
+        )
+      end
+      def update_content_block
+        UpdateContentBlock.call(form, content_block, user) do
+          on(:ok) do |content_block|
+            @content_block = content_block
+          end
+          on(:invalid) do
+            raise "There was a problem persisting the changes to the content block"
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_organization.rb
@@ -0,0 +1,58 @@
+module Decidim
+  module Admin
+    class UpdateOrganization < Decidim::Command
+      def initialize(organization, form)
+        @organization = organization
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        return broadcast(:ok, @organization) if update_organization
+        broadcast(:invalid)
+      end
+      private
+      attr_reader :form, :organization
+      def update_organization
+        @organization = Decidim.traceability.update!(
+          @organization,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          default_locale: form.default_locale,
+          reference_prefix: form.reference_prefix,
+          time_zone: form.time_zone,
+          twitter_handler: form.twitter_handler,
+          facebook_handler: form.facebook_handler,
+          instagram_handler: form.instagram_handler,
+          youtube_handler: form.youtube_handler,
+          github_handler: form.github_handler,
+          badges_enabled: form.badges_enabled,
+          user_groups_enabled: form.user_groups_enabled,
+          comments_max_length: form.comments_max_length,
+          enable_machine_translations: form.enable_machine_translations,
+          admin_terms_of_use_body: form.admin_terms_of_use_body,
+          rich_text_editor_in_public_views: form.rich_text_editor_in_public_views,
+          enable_participatory_space_filters: form.enable_participatory_space_filters
+        }.merge(welcome_notification_attributes)
+          .merge(machine_translation_attributes || {})
+      end
+      def welcome_notification_attributes
+        {
+          send_welcome_notification: form.send_welcome_notification,
+          welcome_notification_subject: form.customize_welcome_notification ? form.welcome_notification_subject : nil,
+          welcome_notification_body: form.customize_welcome_notification ? form.welcome_notification_body : nil
+        }
+      end
+      def machine_translation_attributes
+        return unless Decidim.config.enable_machine_translations
+        {
+          machine_translation_display_priority: form.machine_translation_display_priority
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_organization_appearance.rb
@@ -0,0 +1,86 @@
+module Decidim
+  module Admin
+    class UpdateOrganizationAppearance < Decidim::Command
+      include ::Decidim::AttachmentAttributesMethods
+      def initialize(organization, form)
+        @organization = organization
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        begin
+          update_organization
+          broadcast(:ok, organization)
+        rescue ActiveRecord::RecordInvalid
+          image_fields.each do |field|
+            form.errors.add(field, organization.errors[field]) if organization.errors.include? field
+          end
+          broadcast(:invalid)
+        end
+      end
+      private
+      def image_fields
+        [:logo, :highlighted_content_banner_image, :favicon, :official_img_header, :official_img_footer]
+      end
+      attr_reader :form, :organization
+      def update_organization
+        @organization = Decidim.traceability.update!(
+          organization,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        appearance_attributes
+          .merge(attachment_attributes(*image_fields))
+          .merge(highlighted_content_banner_attributes)
+          .merge(omnipresent_banner_attributes)
+          .merge(colors_attributes)
+          .delete_if { |_k, val| val.is_a?(Decidim::ApplicationUploader) }
+          .tap do |attributes|
+            attributes[:header_snippets] = form.header_snippets if Decidim.enable_html_header_snippets
+          end
+      end
+      def appearance_attributes
+        {
+          cta_button_path: form.cta_button_path,
+          cta_button_text: form.cta_button_text,
+          description: form.description,
+          official_url: form.official_url
+        }
+      end
+      def highlighted_content_banner_attributes
+        {
+          highlighted_content_banner_enabled: form.highlighted_content_banner_enabled,
+          highlighted_content_banner_action_url: form.highlighted_content_banner_action_url,
+          highlighted_content_banner_title: form.highlighted_content_banner_title,
+          highlighted_content_banner_short_description: form.highlighted_content_banner_short_description,
+          highlighted_content_banner_action_title: form.highlighted_content_banner_action_title,
+          highlighted_content_banner_action_subtitle: form.highlighted_content_banner_action_subtitle
+        }
+      end
+      def omnipresent_banner_attributes
+        {
+          enable_omnipresent_banner: form.enable_omnipresent_banner,
+          omnipresent_banner_url: form.omnipresent_banner_url,
+          omnipresent_banner_short_description: form.omnipresent_banner_short_description,
+          omnipresent_banner_title: form.omnipresent_banner_title
+        }
+      end
+      def colors_attributes
+        {
+          colors: {
+            primary: form.primary_color,
+            secondary: form.secondary_color,
+            success: form.success_color,
+            warning: form.warning_color,
+            alert: form.alert_color,
+            highlight: form.highlight_color,
+            "highlight-alternative": form.highlight_alternative_color,
+            theme: form.theme_color
+          }
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_organization_tos_version.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Admin
+    class UpdateOrganizationTosVersion < Decidim::Command
+      def initialize(organization, page, form)
+        @organization = organization
+        @page = page
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if @form.nil?
+        return broadcast(:invalid) if @page.nil?
+        return broadcast(:invalid) unless @page.slug == "terms-and-conditions"
+        update_organization_tos_version
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_organization_tos_version
+        Decidim.traceability.update!(
+          @organization,
+          @form.current_user,
+          tos_version: @page.updated_at
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_resource_permissions.rb
@@ -0,0 +1,43 @@
+module Decidim
+  module Admin
+    class UpdateResourcePermissions < Decidim::Command
+      def initialize(form, resource)
+        @form = form
+        @resource = resource
+      end
+      def call
+        return broadcast(:invalid) unless form.valid?
+        transaction do
+          update_permissions
+        end
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form, :resource
+      def configured_permissions
+        form.permissions.select do |_, permission|
+          selected_handlers(permission).any?
+        end
+      end
+      def update_permissions
+        permissions = configured_permissions.inject({}) do |result, (key, value)|
+          handlers_content = selected_handlers(value).inject({}) do |handlers_content_result, handler_key|
+            opts = value.authorization_handlers_options[handler_key.to_s]
+            handlers_content_result.update(handler_key => opts ? { options: opts } : {})
+          end
+          serialized = {
+            "authorization_handlers" => handlers_content
+          }
+          result.update(key => selected_handlers(value).any? ? serialized : {})
+        end
+        resource_permissions.update!(permissions: permissions)
+      end
+      def resource_permissions
+        @resource_permissions ||= resource.resource_permission || resource.build_resource_permission
+      end
+      def selected_handlers(permission)
+        permission.authorization_handlers_names & @form.current_organization.available_authorizations
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_scope.rb
@@ -0,0 +1,35 @@
+module Decidim
+  module Admin
+    class UpdateScope < Decidim::Command
+      def initialize(scope, form)
+        @scope = scope
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_scope
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_scope
+        Decidim.traceability.update!(
+          @scope,
+          form.current_user,
+          attributes,
+          extra: {
+            parent_name: @scope.parent.try(:name),
+            scope_type_name: form.scope_type.try(:name)
+          }
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          code: form.code,
+          scope_type: form.scope_type
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_scope_type.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Admin
+    class UpdateScopeType < Decidim::Command
+      def initialize(scope_type, form, user)
+        @scope_type = scope_type
+        @form = form
+        @user = user
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_scope_type
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_scope_type
+        Decidim.traceability.update!(
+          @scope_type,
+          @user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          name: form.name,
+          plural: form.plural
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_static_page.rb
@@ -0,0 +1,39 @@
+module Decidim
+  module Admin
+    class UpdateStaticPage < Decidim::Command
+      def initialize(page, form)
+        @page = page
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_page
+        update_organization_tos_version if form.changed_notably
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_page
+        Decidim.traceability.update!(
+          @page,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          title: form.title,
+          slug: form.slug,
+          show_in_footer: form.show_in_footer,
+          weight: form.weight,
+          topic: form.topic,
+          content: form.content,
+          allow_public_access: form.allow_public_access
+        }
+      end
+      def update_organization_tos_version
+        UpdateOrganizationTosVersion.call(@form.organization, @page, @form)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_static_page_topic.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Admin
+    class UpdateStaticPageTopic < Decidim::Command
+      def initialize(topic, form)
+        @topic = topic
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_topic
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_topic
+        Decidim.traceability.update!(
+          @topic,
+          form.current_user,
+          attributes
+        )
+      end
+      def attributes
+        {
+          title: form.title,
+          description: form.description,
+          show_in_footer: form.show_in_footer,
+          weight: form.weight
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/update_user_groups.rb
@@ -0,0 +1,25 @@
+module Decidim
+  module Admin
+    class UpdateUserGroups < Decidim::Command
+      def initialize(user_group)
+        @user_group = user_group
+        @form = form
+      end
+      def call
+        return broadcast(:invalid) if form.invalid?
+        update_scope
+        broadcast(:ok)
+      end
+      private
+      attr_reader :form
+      def update_scope
+        @scope.update!(attributes)
+      end
+      def attributes
+        {
+          name: form.name
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/commands/decidim/admin/verify_user_group.rb
@@ -0,0 +1,27 @@
+module Decidim
+  module Admin
+    class VerifyUserGroup < Decidim::Command
+      def initialize(user_group, current_user, via_csv: false)
+        @user_group = user_group
+        @current_user = current_user
+        @via_csv = via_csv
+      end
+      def call
+        return broadcast(:invalid) unless @user_group.valid?
+        verify_user_group
+        broadcast(:ok)
+      end
+      private
+      def verify_user_group
+        action = @via_csv ? "verify_via_csv" : "verify"
+        Decidim.traceability.perform_action!(
+          action,
+          @user_group,
+          @current_user
+        ) do
+          @user_group.verify!
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/concerns/decidim/admin/filterable.rb
@@ -0,0 +1,92 @@
+require "active_support/concern"
+module Decidim
+  module Admin
+    module Filterable
+      extend ActiveSupport::Concern
+      included do
+        include Decidim::Admin::Paginable
+        include Decidim::TranslatableAttributes
+        helper Decidim::Admin::FilterableHelper
+        helper_method :collection_name,
+                      :extra_allowed_params,
+                      :extra_filters,
+                      :filters,
+                      :filters_with_values,
+                      :find_dynamic_translation,
+                      :query,
+                      :query_params,
+                      :query_params_with,
+                      :query_params_without,
+                      :ransack_params,
+                      :search_field_predicate
+        delegate :categories, to: :current_component
+        delegate :scopes, to: :current_organization
+        def query
+          @query ||= base_query.ransack(ransack_params, search_context: :admin, auth_object: current_user)
+        end
+        private
+        def filtered_collection
+          paginate(query.result)
+        end
+        def base_query
+          raise NotImplementedError, "A base query is needed to filter admin resources"
+        end
+        def query_params
+          params.permit(*allowed_query_params).to_h.deep_symbolize_keys
+        end
+        def allowed_query_params
+          [*extra_allowed_params, { q: {} }]
+        end
+        def extra_allowed_params
+          [:per_page]
+        end
+        def ransack_params
+          query_params[:q] || {}
+        end
+        def query_params_with(hash)
+          query_params.merge(q: ransack_params.merge(hash))
+        end
+        def query_params_without(*filters)
+          query_params.merge(q: ransack_params.except(*filters))
+        end
+        def search_field_predicate
+          :title_cont
+        end
+        def filters
+          [:private_space_eq, :published_at_null]
+        end
+        def extra_filters
+          []
+        end
+        def filters_with_values
+          filters.index_with { [true, false] }
+        end
+        def collection_name
+          query.klass.model_name.human(count: 2)
+        end
+        def category_ids_hash(categories)
+          categories.each_with_object({}) do |category, hash|
+            hash[category.id] = category.subcategories.any? ? category_ids_hash(category.subcategories) : nil
+          end
+        end
+        def scope_ids_hash(scopes)
+          scopes.each_with_object({}) do |scope, hash|
+            hash[scope.id] = scope.children.any? ? scope_ids_hash(scope.children) : nil
+          end
+        end
+        def dynamically_translated_filters
+          [:scope_id_eq, :category_id_eq]
+        end
+        def find_dynamic_translation(filter, value)
+          send("translated_#{filter}", value) if filter.in?(dynamically_translated_filters)
+        end
+        def translated_scope_id_eq(id)
+          translated_attribute(scopes.find_by(id: id).name)
+        end
+        def translated_category_id_eq(id)
+          translated_attribute(categories.find_by(id: id).name)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/concerns/decidim/admin/participatory_space_export.rb
@@ -0,0 +1,31 @@
+module Decidim
+  module Admin
+    module ParticipatorySpaceExport
+      extend ActiveSupport::Concern
+      included do
+        helper_method :exportable_space
+        def create
+          enforce_permission_to :create, :export_space, participatory_space: exportable_space
+          Decidim.traceability.perform_action!("export", exportable_space, current_user) do
+            ExportParticipatorySpaceJob.perform_later(current_user, exportable_space, manifest_name, default_format)
+          end
+          flash[:notice] = t("decidim.admin.exports.notice")
+          redirect_back(fallback_location: after_export_path)
+        end
+        def exportable_space
+          raise NotImplementedError
+        end
+        def manifest_name
+          raise NotImplementedError
+        end
+        def after_export_path
+          decidim.root_path
+        end
+        private
+        def default_format
+          "JSON"
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/application_controller.rb
@@ -0,0 +1,46 @@
+module Decidim
+  module Admin
+    class ApplicationController < ::DecidimController
+      include NeedsOrganization
+      include NeedsPermission
+      include NeedsPasswordChange
+      include NeedsSnippets
+      include FormFactory
+      include LocaleSwitcher
+      include UseOrganizationTimeZone
+      include PayloadInfo
+      include HttpCachingDisabler
+      include DisableRedirectionToExternalHost
+      helper Decidim::Admin::ApplicationHelper
+      helper Decidim::Admin::AttributesDisplayHelper
+      helper Decidim::Admin::SettingsHelper
+      helper Decidim::Admin::IconLinkHelper
+      helper Decidim::Admin::MenuHelper
+      helper Decidim::Admin::ScopesHelper
+      helper Decidim::Admin::Paginable::PerPageHelper
+      helper Decidim::DecidimFormHelper
+      helper Decidim::ReplaceButtonsHelper
+      helper Decidim::ScopesHelper
+      helper Decidim::TranslationsHelper
+      helper Decidim::LanguageChooserHelper
+      helper Decidim::ComponentPathHelper
+      helper Decidim::SanitizeHelper
+      default_form_builder Decidim::Admin::FormBuilder
+      protect_from_forgery with: :exception, prepend: true
+      register_permissions(::Decidim::Admin::ApplicationController,
+                           ::Decidim::Admin::Permissions)
+      def user_has_no_permission_path
+        decidim_admin.root_path
+      end
+      def user_not_authorized_path
+        decidim_admin.root_path
+      end
+      def permission_class_chain
+        ::Decidim.permissions_registry.chain_for(::Decidim::Admin::ApplicationController)
+      end
+      def permission_scope
+        :admin
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/area_types_controller.rb
@@ -0,0 +1,62 @@
+module Decidim
+  module Admin
+    class AreaTypesController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/settings"
+      helper_method :area_types
+      def index
+        enforce_permission_to :read, :area_type
+      end
+      def new
+        enforce_permission_to :create, :area_type
+        @form = form(AreaTypeForm).instance
+      end
+      def create
+        enforce_permission_to :create, :area_type
+        @form = form(AreaTypeForm).from_params(params)
+        CreateAreaType.call(@form, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("area_types.create.success", scope: "decidim.admin")
+            redirect_to area_types_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("area_types.create.error", scope: "decidim.admin")
+            render :new
+          end
+        end
+      end
+      def edit
+        enforce_permission_to :update, :area_type, area_type: area_type
+        @form = form(AreaTypeForm).from_model(area_type)
+      end
+      def update
+        enforce_permission_to :update, :area_type, area_type: area_type
+        @form = form(AreaTypeForm).from_params(params)
+        UpdateAreaType.call(area_type, @form, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("area_types.update.success", scope: "decidim.admin")
+            redirect_to area_types_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("area_types.update.error", scope: "decidim.admin")
+            render :edit
+          end
+        end
+      end
+      def destroy
+        enforce_permission_to :destroy, :area_type, area_type: area_type
+        Decidim.traceability.perform_action!("delete", area_type, current_user) do
+          area_type.destroy!
+        end
+        flash[:notice] = I18n.t("area_types.destroy.success", scope: "decidim.admin")
+        redirect_to area_types_path
+      end
+      private
+      def area_type
+        @area_type ||= area_types.find(params[:id])
+      end
+      def area_types
+        current_organization.area_types
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/categories_controller.rb
@@ -0,0 +1,70 @@
+module Decidim
+  module Admin
+    class CategoriesController < Decidim::Admin::ApplicationController
+      include ParticipatorySpaceAdminContext
+      participatory_space_admin_layout
+      def index
+        enforce_permission_to :read, :category
+      end
+      def new
+        enforce_permission_to :create, :category
+        @form = form(CategoryForm).from_params({}, current_participatory_space: current_participatory_space)
+      end
+      def create
+        enforce_permission_to :create, :category
+        @form = form(CategoryForm).from_params(params, current_participatory_space: current_participatory_space)
+        CreateCategory.call(@form, current_participatory_space, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("categories.create.success", scope: "decidim.admin")
+            redirect_to categories_path(current_participatory_space)
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("categories.create.error", scope: "decidim.admin")
+            render :new
+          end
+        end
+      end
+      def edit
+        @category = collection.find(params[:id])
+        enforce_permission_to :update, :category, category: @category
+        @form = form(CategoryForm).from_model(@category, current_participatory_space: current_participatory_space)
+      end
+      def update
+        @category = collection.find(params[:id])
+        enforce_permission_to :update, :category, category: @category
+        @form = form(CategoryForm).from_params(params, current_participatory_space: current_participatory_space)
+        UpdateCategory.call(@category, @form, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("categories.update.success", scope: "decidim.admin")
+            redirect_to categories_path(current_participatory_space)
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("categories.update.error", scope: "decidim.admin")
+            render :edit
+          end
+        end
+      end
+      def show
+        @category = collection.find(params[:id])
+        enforce_permission_to :read, :category, category: @category
+      end
+      def destroy
+        @category = collection.find(params[:id])
+        enforce_permission_to :destroy, :category, category: @category
+        DestroyCategory.call(@category, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("categories.destroy.success", scope: "decidim.admin")
+          end
+          on(:invalid) do
+            flash[:alert] = I18n.t("categories.destroy.error", scope: "decidim.admin")
+          end
+          redirect_back(fallback_location: categories_path(current_participatory_space))
+        end
+      end
+      private
+      def collection
+        @collection ||= current_participatory_space.categories.includes(:subcategories)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/component_permissions_controller.rb
@@ -0,0 +1,51 @@
+module Decidim
+  module Admin
+    class ComponentPermissionsController < ResourcePermissionsController
+      include Decidim::ComponentPathHelper
+      def edit
+        enforce_permission_to :update, :component, component: component
+        @permissions_form = PermissionsForm.new(
+          permissions: permission_forms
+        )
+        render template: "decidim/admin/resource_permissions/edit"
+      end
+      def update
+        enforce_permission_to :update, :component, component: component
+        @permissions_form = PermissionsForm.from_params(params)
+        UpdateComponentPermissions.call(@permissions_form, component, resource, current_user) do
+          on(:ok) do
+            flash[:notice] = t("component_permissions.update.success", scope: "decidim.admin")
+            redirect_to return_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = t("component_permissions.update.error", scope: "decidim.admin")
+            render action: :edit
+          end
+        end
+      end
+      private
+      def return_path
+        if resource
+          manage_component_path(component)
+        else
+          components_path(current_participatory_space)
+        end
+      end
+      def actions
+        @actions ||= (resource&.resource_manifest || component.manifest).actions
+      end
+      def resource
+        @resource ||= if params[:resource_id] && params[:resource_name]
+                        res = Decidim.find_resource_manifest(params[:resource_name])&.resource_scope(component)&.find_by(id: params[:resource_id])
+                        res if res&.allow_resource_permissions?
+                      end
+      end
+      def component
+        @component ||= current_participatory_space.components.find(params[:component_id])
+      end
+      def permissions
+        @permissions ||= (component.permissions || {}).merge(resource&.permissions || {})
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/components/base_controller.rb
@@ -0,0 +1,55 @@
+module Decidim
+  module Admin
+    module Components
+      class BaseController < Decidim::Admin::ApplicationController
+        include Settings
+        include Decidim::Admin::ParticipatorySpaceAdminContext
+        include Decidim::NeedsPermission
+        participatory_space_admin_layout
+        helper Decidim::ResourceHelper
+        helper Decidim::Admin::ExportsHelper
+        helper Decidim::Admin::ImportsHelper
+        helper Decidim::Admin::RemindersHelper
+        helper Decidim::Admin::BulkActionsHelper
+        helper Decidim::Admin::ResourcePermissionsHelper
+        helper_method :current_component,
+                      :current_participatory_space,
+                      :parent_path
+        before_action except: [:index, :show] do
+          enforce_permission_to :manage, :component, component: current_component unless skip_manage_component_permission
+        end
+        before_action on: [:index, :show] do
+          enforce_permission_to :read, :component, component: current_component
+        end
+        def permissions_context
+          super.merge(
+            current_participatory_space: current_participatory_space,
+            participatory_space: current_participatory_space
+          )
+        end
+        def permission_class_chain
+          [
+            current_component.manifest.permissions_class,
+            current_participatory_space.manifest.permissions_class,
+            Decidim::Admin::Permissions
+          ]
+        end
+        def permission_scope
+          :admin
+        end
+        def current_component
+          request.env["decidim.current_component"]
+        end
+        def current_participatory_space
+          current_component.participatory_space
+        end
+        def parent_path
+          @parent_path ||= ::Decidim::EngineRouter.admin_proxy(current_participatory_space).components_path
+        end
+        def skip_manage_component_permission
+          false
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/components_controller.rb
@@ -0,0 +1,136 @@
+module Decidim
+  module Admin
+    class ComponentsController < Decidim::Admin::ApplicationController
+      helper_method :manifest, :current_participatory_space
+      def index
+        enforce_permission_to :read, :component
+        @manifests = Decidim.component_manifests
+        @components = current_participatory_space.components
+      end
+      def new
+        enforce_permission_to :create, :component
+        @component = Component.new(
+          name: default_name(manifest),
+          manifest_name: params[:type],
+          participatory_space: current_participatory_space,
+          settings: {
+            scope_id: current_participatory_space.scope.try(:id)
+          }
+        )
+        @form = form(@component.form_class).from_model(@component)
+      end
+      def create
+        @form = form(manifest.component_form_class).from_params(component_params)
+        enforce_permission_to :create, :component
+        CreateComponent.call(@form) do
+          on(:ok) do
+            flash[:notice] = I18n.t("components.create.success", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("components.create.error", scope: "decidim.admin")
+            render action: "new"
+          end
+        end
+      end
+      def edit
+        @component = query_scope.find(params[:id])
+        enforce_permission_to :update, :component, component: @component
+        @form = form(@component.form_class).from_model(@component)
+      end
+      def update
+        @component = query_scope.find(params[:id])
+        @form = form(@component.form_class).from_params(component_params)
+        enforce_permission_to :update, :component, component: @component
+        UpdateComponent.call(@form, @component, current_user) do
+          on(:ok) do |settings_changed, previous_settings, current_settings|
+            handle_component_settings_change(previous_settings, current_settings) if settings_changed
+            flash[:notice] = I18n.t("components.update.success", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+          on(:invalid) do
+            flash[:alert] = I18n.t("components.update.error", scope: "decidim.admin")
+            render action: :edit
+          end
+        end
+      end
+      def destroy
+        @component = query_scope.find(params[:id])
+        enforce_permission_to :destroy, :component, component: @component
+        DestroyComponent.call(@component, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("components.destroy.success", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+          on(:invalid) do
+            flash[:alert] = I18n.t("components.destroy.error", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+        end
+      end
+      def publish
+        @component = query_scope.find(params[:id])
+        enforce_permission_to :publish, :component, component: @component
+        PublishComponent.call(@component, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("components.publish.success", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+        end
+      end
+      def unpublish
+        @component = query_scope.find(params[:id])
+        enforce_permission_to :unpublish, :component, component: @component
+        UnpublishComponent.call(@component, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("components.unpublish.success", scope: "decidim.admin")
+            redirect_to action: :index
+          end
+        end
+      end
+      def share
+        @component = query_scope.find(params[:id])
+        share_token = @component.share_tokens.create!(user: current_user, organization: current_organization)
+        redirect_to share_token.url
+      end
+      private
+      def component_params
+        new_settings = proc { |name, data| Component.build_settings(manifest, name, data, current_organization) }
+        params[:component].permit!.tap do |hsh|
+          hsh[:id] = params[:id]
+          hsh[:manifest] = manifest
+          hsh[:participatory_space] = current_participatory_space
+          hsh[:settings] = new_settings.call(:global, hsh[:settings])
+          if hsh[:default_step_settings]
+            hsh[:default_step_settings] = new_settings.call(:step, hsh[:default_step_settings])
+          else
+            hsh[:step_settings] ||= {}
+            hsh[:step_settings].each do |key, value|
+              hsh[:step_settings][key] = new_settings.call(:step, value)
+            end
+          end
+        end
+      end
+      def query_scope
+        current_participatory_space.components
+      end
+      def manifest
+        @component&.manifest || Decidim.find_component_manifest(params[:type])
+      end
+      def default_name(manifest)
+        TranslationsHelper.multi_translation(
+          "decidim.components.#{manifest.name}.name",
+          current_organization.available_locales
+        )
+      end
+      def handle_component_settings_change(previous_settings, current_settings)
+        return if @component.participatory_space.allows_steps?
+        Decidim::SettingsChange.publish(
+          @component,
+          previous_settings["default_step"] || {},
+          current_settings["default_step"] || {}
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/concerns/has_attachment_collections.rb
@@ -0,0 +1,79 @@
+module Decidim
+  module Admin
+    module Concerns
+      module HasAttachmentCollections
+        extend ActiveSupport::Concern
+        included do
+          helper_method :collection_for, :attachment_collection
+          def index
+            enforce_permission_to :read, :attachment_collection
+            render template: "decidim/admin/attachment_collections/index"
+          end
+          def new
+            enforce_permission_to :create, :attachment_collection
+            @form = form(AttachmentCollectionForm).from_params({}, collection_for: collection_for)
+            render template: "decidim/admin/attachment_collections/new"
+          end
+          def create
+            enforce_permission_to :create, :attachment_collection
+            @form = form(AttachmentCollectionForm).from_params(params, collection_for: collection_for)
+            CreateAttachmentCollection.call(@form, collection_for, current_user) do
+              on(:ok) do
+                flash[:notice] = I18n.t("attachment_collections.create.success", scope: "decidim.admin")
+                redirect_to action: :index
+              end
+              on(:invalid) do
+                flash.now[:alert] = I18n.t("attachment_collections.create.error", scope: "decidim.admin")
+                render template: "decidim/admin/attachment_collections/new"
+              end
+            end
+          end
+          def edit
+            @attachment_collection = collection.find(params[:id])
+            enforce_permission_to :update, :attachment_collection, attachment_collection: @attachment_collection
+            @form = form(AttachmentCollectionForm).from_model(@attachment_collection, collection_for: collection_for)
+            render template: "decidim/admin/attachment_collections/edit"
+          end
+          def update
+            @attachment_collection = collection.find(params[:id])
+            enforce_permission_to :update, :attachment_collection, attachment_collection: @attachment_collection
+            @form = form(AttachmentCollectionForm).from_params(params, collection_for: collection_for)
+            UpdateAttachmentCollection.call(@attachment_collection, @form, current_user) do
+              on(:ok) do
+                flash[:notice] = I18n.t("attachment_collections.update.success", scope: "decidim.admin")
+                redirect_to action: :index
+              end
+              on(:invalid) do
+                flash.now[:alert] = I18n.t("attachment_collections.update.error", scope: "decidim.admin")
+                render template: "decidim/admin/attachment_collections/edit"
+              end
+            end
+          end
+          def show
+            @attachment_collection = collection.find(params[:id])
+            enforce_permission_to :read, :attachment_collection, attachment_collection: @attachment_collection
+            render template: "decidim/admin/attachment_collections/show"
+          end
+          def destroy
+            @attachment_collection = collection.find(params[:id])
+            enforce_permission_to :destroy, :attachment_collection, attachment_collection: @attachment_collection
+            Decidim.traceability.perform_action!("delete", @attachment_collection, current_user) do
+              @attachment_collection.destroy!
+            end
+            flash[:notice] = I18n.t("attachment_collections.destroy.success", scope: "decidim.admin")
+            redirect_to after_destroy_path
+          end
+          def after_destroy_path
+            collection_for
+          end
+          def collection_for
+            raise NotImplementedError
+          end
+          def collection
+            @collection ||= collection_for.attachment_collections
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/concerns/has_attachments.rb
@@ -0,0 +1,87 @@
+module Decidim
+  module Admin
+    module Concerns
+      module HasAttachments
+        extend ActiveSupport::Concern
+        included do
+          helper_method :attached_to, :attachment
+          def index
+            enforce_permission_to :read, :attachment, attached_to: attached_to
+            render template: "decidim/admin/attachments/index"
+          end
+          def new
+            enforce_permission_to :create, :attachment, attached_to: attached_to
+            @form = form(::Decidim::Admin::AttachmentForm).from_params({}, attached_to: attached_to)
+            render template: "decidim/admin/attachments/new"
+          end
+          def create
+            enforce_permission_to :create, :attachment, attached_to: attached_to
+            @form = form(::Decidim::Admin::AttachmentForm).from_params(params, attached_to: attached_to)
+            CreateAttachment.call(@form, attached_to, current_user) do
+              on(:ok) do
+                flash[:notice] = I18n.t("attachments.create.success", scope: "decidim.admin")
+                redirect_to action: :index
+              end
+              on(:invalid) do
+                flash.now[:alert] = I18n.t("attachments.create.error", scope: "decidim.admin")
+                render template: "decidim/admin/attachments/new"
+              end
+            end
+          end
+          def edit
+            @attachment = collection.find(params[:id])
+            enforce_permission_to :update, :attachment, attachment: attachment
+            @form = form(::Decidim::Admin::AttachmentForm).from_model(@attachment, attached_to: attached_to)
+            render template: "decidim/admin/attachments/edit"
+          end
+          def update
+            @attachment = collection.find(params[:id])
+            enforce_permission_to :update, :attachment, attachment: attachment
+            @form = form(::Decidim::Admin::AttachmentForm).from_params(attachment_params, attached_to: attached_to)
+            UpdateAttachment.call(@attachment, @form, current_user) do
+              on(:ok) do
+                flash[:notice] = I18n.t("attachments.update.success", scope: "decidim.admin")
+                redirect_to action: :index
+              end
+              on(:invalid) do
+                flash.now[:alert] = I18n.t("attachments.update.error", scope: "decidim.admin")
+                render template: "decidim/admin/attachments/edit"
+              end
+            end
+          end
+          def show
+            @attachment = collection.find(params[:id])
+            enforce_permission_to :read, :attachment, attachment: attachment
+            render template: "decidim/admin/attachments/show"
+          end
+          def destroy
+            @attachment = collection.find(params[:id])
+            enforce_permission_to :destroy, :attachment, attachment: attachment
+            Decidim.traceability.perform_action!("delete", @attachment, current_user) do
+              @attachment.destroy!
+            end
+            flash[:notice] = I18n.t("attachments.destroy.success", scope: "decidim.admin")
+            redirect_to after_destroy_path
+          end
+          def after_destroy_path
+            attached_to
+          end
+          def attached_to
+            raise NotImplementedError
+          end
+          def attachment
+            attached_to
+          end
+          def collection
+            @collection ||= attached_to.attachments
+          end
+          attr_reader :attachment
+          private
+          def attachment_params
+            { id: params[:id] }.merge(params[:attachment].to_unsafe_h)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/concerns/has_private_users_csv_import.rb
@@ -0,0 +1,43 @@
+module Decidim
+  module Admin
+    module Concerns
+      module HasPrivateUsersCsvImport
+        extend ActiveSupport::Concern
+        included do
+          helper_method :privatable_to
+          def new
+            enforce_permission_to :csv_import, :space_private_user
+            @form = form(ParticipatorySpacePrivateUserCsvImportForm).from_params({}, privatable_to: privatable_to)
+            @count = Decidim::ParticipatorySpacePrivateUser.by_participatory_space(privatable_to).count
+            render template: "decidim/admin/participatory_space_private_users_csv_imports/new"
+          end
+          def create
+            enforce_permission_to :csv_import, :space_private_user
+            @form = form(ParticipatorySpacePrivateUserCsvImportForm).from_params(params, privatable_to: privatable_to)
+            ProcessParticipatorySpacePrivateUserImportCsv.call(@form, current_user, current_participatory_space) do
+              on(:ok) do
+                flash[:notice] = I18n.t("participatory_space_private_users_csv_imports.create.success", scope: "decidim.admin")
+                redirect_to after_import_path
+              end
+              on(:invalid) do
+                flash[:alert] = I18n.t("participatory_space_private_users_csv_imports.create.invalid", scope: "decidim.admin")
+                render template: "decidim/admin/participatory_space_private_users_csv_imports/new"
+              end
+            end
+          end
+          def destroy_all
+            enforce_permission_to :csv_import, :space_private_user
+            Decidim::ParticipatorySpacePrivateUser.by_participatory_space(privatable_to).delete_all
+            redirect_to new_participatory_space_private_users_csv_imports_path
+          end
+          def after_import_path
+            privatable_to
+          end
+          def privatable_to
+            raise NotImplementedError
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/conflicts_controller.rb
@@ -0,0 +1,39 @@
+module Decidim
+  module Admin
+    class ConflictsController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/users"
+      def index
+        @conflicts = Decidim::Verifications::Conflict.joins(:current_user).where(
+          decidim_users: { decidim_organization_id: current_organization.id }
+        )
+      end
+      def edit
+        conflict = Decidim::Verifications::Conflict.find(params[:id])
+        @form = form(TransferUserForm).from_params(
+          user: conflict.current_user,
+          managed_user: conflict.managed_user,
+          conflict: conflict
+        )
+      end
+      def update
+        conflict = Decidim::Verifications::Conflict.find(params[:id])
+        @form = form(TransferUserForm).from_params(
+          current_user: current_user,
+          conflict: conflict,
+          reason: params[:transfer_user][:reason],
+          email: params[:transfer_user][:email]
+        )
+        TransferUser.call(@form) do
+          on(:ok) do
+            flash[:notice] = I18n.t("success", scope: "decidim.admin.conflicts.transfer")
+            redirect_to conflicts_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("error", scope: "decidim.admin.conflicts.transfer")
+            redirect_to decidim.root_path
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/dashboard_controller.rb
@@ -0,0 +1,48 @@
+module Decidim
+  module Admin
+    class DashboardController < Decidim::Admin::ApplicationController
+      helper_method :latest_action_logs
+      helper_method :users_counter
+      helper_method :metrics_presenter
+      def show
+        enforce_permission_to :read, :admin_dashboard
+      end
+      private
+      def latest_action_logs
+        @latest_action_logs ||= Decidim::ActionLog
+                                .where(organization: current_organization)
+                                .includes(:participatory_space, :user, :resource, :component, :version)
+                                .for_admin
+                                .order(created_at: :desc)
+                                .first(5)
+      end
+      def metrics_presenter
+        @metrics_presenter ||= Decidim::Admin::DashboardMetricChartsPresenter.new(
+          summary: true,
+          organization: current_organization,
+          view_context: view_context
+        )
+      end
+      def users_counter
+        last_day = Time.zone.yesterday
+        last_week = Time.zone.today.prev_week
+        last_month = Time.zone.today.prev_month
+        {
+          total_admins_last_day: users_count(last_day, true),
+          total_admins_last_week: users_count(last_week, true),
+          total_admins_last_month: users_count(last_month, true),
+          total_participants_last_day: users_count(last_day, false),
+          total_participants_last_week: users_count(last_week, false),
+          total_participants_last_month: users_count(last_month, false)
+        }
+      end
+      def users_count(date, admin)
+        @users_count = Decidim::Admin::ActiveUsersCounter.new(
+          organization: current_organization,
+          date: date,
+          admin: admin
+        ).query.count
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/exports_controller.rb
@@ -0,0 +1,23 @@
+module Decidim
+  module Admin
+    class ExportsController < Decidim::Admin::ApplicationController
+      include Decidim::ComponentPathHelper
+      def create
+        enforce_permission_to :export, :component_data, component: component
+        name = params[:id]
+        Decidim.traceability.perform_action!("export_component", component, current_user, { name: name, format: params[:format] || default_format }) do
+          ExportJob.perform_later(current_user, component, name, params[:format] || default_format, params[:resource_id].presence)
+        end
+        flash[:notice] = t("decidim.admin.exports.notice")
+        redirect_back(fallback_location: manage_component_path(component))
+      end
+      private
+      def default_format
+        "json"
+      end
+      def component
+        @component ||= current_participatory_space.components.find(params[:component_id])
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/global_moderations_controller.rb
@@ -0,0 +1,19 @@
+module Decidim
+  module Admin
+    class GlobalModerationsController < Decidim::Admin::ModerationsController
+      layout "decidim/admin/global_moderations"
+      include Decidim::Admin::GlobalModerationContext
+      def collection
+        @collection ||=
+          if params[:hidden]
+            moderations_for_user.hidden
+          else
+            moderations_for_user.not_hidden
+          end
+      end
+      def reportable
+        @reportable ||= moderations_for_user.find(params[:id]).reportable
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/help_sections_controller.rb
@@ -0,0 +1,40 @@
+module Decidim
+  module Admin
+    class HelpSectionsController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/settings"
+      include TranslationsHelper
+      helper_method :sections
+      before_action do
+        enforce_permission_to :update, :help_sections
+      end
+      def show
+        @form = form(HelpSectionsForm).from_model(
+          OpenStruct.new(sections: sections)
+        )
+      end
+      def update
+        @form = form(HelpSectionsForm).from_params(
+          params[:help_sections]
+        )
+        UpdateHelpSections.call(@form, current_organization, current_user) do
+          on(:ok) do
+            flash[:notice] = t("help_sections.success", scope: "decidim.admin")
+            redirect_to action: :show
+          end
+          on(:invalid) do
+            flash.now[:alert] = t("help_sections.error", scope: "decidim.admin")
+          end
+        end
+      end
+      private
+      def sections
+        @sections ||= Decidim.participatory_space_manifests.map do |manifest|
+          OpenStruct.new(
+            id: manifest.name.to_s,
+            content: ContextualHelpSection.find_content(current_organization, manifest.name)
+          )
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/metrics_controller.rb
@@ -0,0 +1,18 @@
+module Decidim
+  module Admin
+    class MetricsController < Decidim::Admin::ApplicationController
+      helper_method :metrics_presenter
+      def index
+        enforce_permission_to :read, :metrics
+      end
+      private
+      def metrics_presenter
+        @metrics_presenter ||= Decidim::Admin::DashboardMetricChartsPresenter.new(
+          summary: false,
+          organization: current_organization,
+          view_context: view_context
+        )
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/moderations_controller.rb
@@ -0,0 +1,77 @@
+module Decidim
+  module Admin
+    class ModerationsController < Decidim::Admin::ApplicationController
+      include Decidim::Moderations::Admin::Filterable
+      helper_method :moderations, :allowed_to?, :query, :permission_resource
+      def index
+        enforce_permission_to :read, permission_resource
+      end
+      def show
+        enforce_permission_to :read, permission_resource
+        @moderation = collection.find(params[:id])
+      end
+      def unreport
+        enforce_permission_to :unreport, permission_resource
+        Admin::UnreportResource.call(reportable, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("reportable.unreport.success", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("reportable.unreport.invalid", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+        end
+      end
+      def hide
+        enforce_permission_to :hide, permission_resource
+        Admin::HideResource.call(reportable, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("reportable.hide.success", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("reportable.hide.invalid", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+        end
+      end
+      def unhide
+        enforce_permission_to :unhide, permission_resource
+        Admin::UnhideResource.call(reportable, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("reportable.unhide.success", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("reportable.unhide.invalid", scope: "decidim.moderations.admin")
+            redirect_to moderations_path
+          end
+        end
+      end
+      private
+      def ransack_params
+        query_params[:q] || { s: "created_at desc" }
+      end
+      def collection
+        @collection ||= if params[:hidden]
+                          participatory_space_moderations.hidden
+                        else
+                          participatory_space_moderations.not_hidden
+                        end
+      end
+      def moderations
+        @moderations ||= filtered_collection
+      end
+      def reportable
+        @reportable ||= participatory_space_moderations.find(params[:id]).reportable
+      end
+      def participatory_space_moderations
+        @participatory_space_moderations ||= Decidim::Moderation.where(participatory_space: current_participatory_space)
+      end
+      def permission_resource
+        :moderation
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/organization_controller.rb
@@ -0,0 +1,51 @@
+module Decidim
+  module Admin
+    class OrganizationController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/settings"
+      def edit
+        enforce_permission_to :update, :organization, organization: current_organization
+        @form = form(OrganizationForm).from_model(current_organization)
+      end
+      def update
+        enforce_permission_to :update, :organization, organization: current_organization
+        @form = form(OrganizationForm).from_params(params)
+        UpdateOrganization.call(current_organization, @form) do
+          on(:ok) do
+            flash[:notice] = I18n.t("organization.update.success", scope: "decidim.admin")
+            redirect_to edit_organization_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("organization.update.error", scope: "decidim.admin")
+            render :edit
+          end
+        end
+      end
+      def users
+        search(current_organization.users.available)
+      end
+      def user_entities
+        search(current_organization.user_entities.available)
+      end
+      private
+      def search(relation)
+        respond_to do |format|
+          format.json do
+            if (term = params[:term].to_s).present?
+              query = relation.order(name: :asc)
+              query = if term.start_with?("@")
+                        query.where("nickname ILIKE ?", "#{term.delete("@")}%")
+                      else
+                        query.where("name ILIKE ?", "%#{term}%").or(
+                          query.where("email ILIKE ?", "%#{term}%")
+                        )
+                      end
+              render json: query.all.collect { |u| { value: u.id, label: "#{u.name} (@#{u.nickname})" } }
+            else
+              render json: []
+            end
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/organization_external_domain_whitelist_controller.rb
@@ -0,0 +1,30 @@
+module Decidim
+  module Admin
+    class OrganizationExternalDomainWhitelistController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/settings"
+      helper_method :blank_external_domain
+      def edit
+        enforce_permission_to :update, :organization, organization: current_organization
+        @form = form(OrganizationExternalDomainWhitelistForm).from_model(current_organization)
+      end
+      def update
+        enforce_permission_to :update, :organization, organization: current_organization
+        @form = form(OrganizationExternalDomainWhitelistForm).from_params(params)
+        UpdateExternalDomainWhitelist.call(@form, current_organization, current_user) do
+          on(:ok) do
+            flash[:notice] = t("domain_whitelist.update.success", scope: "decidim.admin")
+            redirect_to edit_organization_external_domain_whitelist_path
+          end
+          on(:invalid) do
+            flash[:notice] = t("domain_whitelist.update.error", scope: "decidim.admin")
+            render action: "edit"
+          end
+        end
+      end
+      private
+      def blank_external_domain
+        @blank_external_domain ||= Admin::ExternalDomainForm.new
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/reminders_controller.rb
@@ -0,0 +1,46 @@
+module Decidim
+  module Admin
+    class RemindersController < Admin::ApplicationController
+      include Decidim::ComponentPathHelper
+      helper_method :reminder_manifest
+      def new
+        enforce_permission_to :create, :reminder
+        @form = reminder_form_from_params(name: reminder_manifest.name)
+        render :new
+      end
+      def create
+        enforce_permission_to :create, :reminder
+        @form = reminder_form_from_params(params)
+        command_class.call(@form) do
+          on(:ok) do |reminders_queued|
+            flash[:notice] = t("decidim.admin.reminders.create.success", count: reminders_queued)
+            redirect_to manage_component_path(current_component)
+          end
+          on(:invalid) do
+            flash.now[:alert] = t("decidim.admin.reminders.create.error")
+            render :new
+          end
+        end
+      end
+      private
+      def reminder_form_from_params(params)
+        form(reminder_manifest.form_class).from_params(
+          params,
+          current_component: current_component
+        )
+      end
+      def reminder_manifest
+        @reminder_manifest ||= Decidim.reminders_registry.for(reminder_name)
+      end
+      def reminder_name
+        params[:name]
+      end
+      def command_class
+        reminder_manifest.command_class
+      end
+      def current_component
+        @current_component ||= current_participatory_space.components.find(params[:component_id])
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/resource_permissions_controller.rb
@@ -0,0 +1,82 @@
+module Decidim
+  module Admin
+    class ResourcePermissionsController < Decidim::Admin::ApplicationController
+      helper Decidim::ResourceHelper
+      helper_method :authorizations, :other_authorizations_for, :resource_params, :resource
+      def edit
+        @permissions_form = PermissionsForm.new(
+          permissions: permission_forms
+        )
+      end
+      def update
+        @permissions_form = PermissionsForm.from_params(params).with_context(current_organization: current_organization)
+        UpdateResourcePermissions.call(@permissions_form, resource) do
+          on(:ok) do
+            flash[:notice] = t("resource_permissions.update.success", scope: "decidim.admin")
+            redirect_to return_path
+          end
+          on(:invalid) do
+            render action: :edit
+          end
+        end
+      end
+      private
+      def return_path
+        ResourceLocatorPresenter.new(resource).admin_index
+      end
+      def resource_params
+        params.permit(:resource_id, :resource_name).to_h.symbolize_keys
+      end
+      def resource_symbol
+        @resource_symbol ||= resource.class.name.demodulize.underscore.to_sym
+      end
+      def permission_forms
+        actions.inject({}) do |result, action|
+          form = PermissionForm.new(
+            authorization_handlers: authorizations_for(action).keys,
+            authorization_handlers_options: options_for(action)
+          )
+          result.update(action => form)
+        end
+      end
+      def actions
+        @actions ||= resource&.resource_manifest&.actions
+      end
+      def authorizations
+        Verifications::Adapter.from_collection(
+          current_organization.available_authorizations
+        )
+      end
+      def other_authorizations_for(action)
+        Verifications::Adapter.from_collection(
+          current_organization.available_authorizations - authorizations_for(action).keys
+        )
+      end
+      def resource
+        return if params[:resource_name].blank?
+        resource_id = params["#{params[:resource_name]}_id"]
+        resource_slug = params["#{params[:resource_name]}_slug"]
+        find_by = resource_slug.present? ? { slug: resource_slug } : { id: resource_id }
+        @resource ||= Decidim.find_resource_manifest(params[:resource_name])&.model_class&.find_by(find_by)
+        @resource if @resource&.allow_resource_permissions?
+      end
+      def manifest_name
+        @manifest_name ||= resource.resource_manifest.name
+      end
+      def permissions
+        @permissions ||= (resource&.permissions || {})
+      end
+      def authorizations_for(action)
+        if permissions.dig(action, "authorization_handler_name")
+          opts = permissions.dig(action, "options")
+          { permissions.dig(action, "authorization_handler_name") => opts.blank? ? {} : { "options" => opts } }
+        else
+          permissions.dig(action, "authorization_handlers") || {}
+        end
+      end
+      def options_for(action)
+        authorizations_for(action)&.transform_values { |value| value["options"] }&.reject { |_, value| value.blank? }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/scope_types_controller.rb
@@ -0,0 +1,62 @@
+module Decidim
+  module Admin
+    class ScopeTypesController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/settings"
+      helper_method :scope_types
+      def index
+        enforce_permission_to :read, :scope_type
+      end
+      def new
+        enforce_permission_to :create, :scope_type
+        @form = form(ScopeTypeForm).instance
+      end
+      def create
+        enforce_permission_to :create, :scope_type
+        @form = form(ScopeTypeForm).from_params(params)
+        CreateScopeType.call(@form, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("scope_types.create.success", scope: "decidim.admin")
+            redirect_to scope_types_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("scope_types.create.error", scope: "decidim.admin")
+            render :new
+          end
+        end
+      end
+      def edit
+        enforce_permission_to :update, :scope_type, scope_type: scope_type
+        @form = form(ScopeTypeForm).from_model(scope_type)
+      end
+      def update
+        enforce_permission_to :update, :scope_type, scope_type: scope_type
+        @form = form(ScopeTypeForm).from_params(params)
+        UpdateScopeType.call(scope_type, @form, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("scope_types.update.success", scope: "decidim.admin")
+            redirect_to scope_types_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("scope_types.update.error", scope: "decidim.admin")
+            render :edit
+          end
+        end
+      end
+      def destroy
+        enforce_permission_to :destroy, :scope_type, scope_type: scope_type
+        Decidim.traceability.perform_action!("delete", scope_type, current_user) do
+          scope_type.destroy!
+        end
+        flash[:notice] = I18n.t("scope_types.destroy.success", scope: "decidim.admin")
+        redirect_to scope_types_path
+      end
+      private
+      def scope_type
+        @scope_type ||= scope_types.find(params[:id])
+      end
+      def scope_types
+        current_organization.scope_types
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/controllers/decidim/admin/static_pages_controller.rb
@@ -0,0 +1,85 @@
+module Decidim
+  module Admin
+    class StaticPagesController < Decidim::Admin::ApplicationController
+      layout "decidim/admin/pages"
+      before_action :tos_version_formatted, only: [:index, :edit]
+      helper_method :topics
+      def index
+        enforce_permission_to :read, :static_page
+        @topics = Decidim::StaticPageTopic.where(organization: current_organization)
+        @orphan_pages = collection.where(topic: nil)
+      end
+      def new
+        enforce_permission_to :create, :static_page
+        @form = form(StaticPageForm).instance
+      end
+      def create
+        enforce_permission_to :create, :static_page
+        @form = form(StaticPageForm).from_params(form_params)
+        CreateStaticPage.call(@form) do
+          on(:ok) do
+            flash[:notice] = I18n.t("static_pages.create.success", scope: "decidim.admin")
+            redirect_to static_pages_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("static_pages.create.error", scope: "decidim.admin")
+            render :new
+          end
+        end
+      end
+      def edit
+        enforce_permission_to :update, :static_page, static_page: page
+        @form = form(StaticPageForm).from_model(page)
+      end
+      def update
+        @page = collection.find(params[:id])
+        enforce_permission_to :update, :static_page, static_page: page
+        @form = form(StaticPageForm).from_params(form_params)
+        UpdateStaticPage.call(page, @form) do
+          on(:ok) do
+            flash[:notice] = I18n.t("static_pages.update.success", scope: "decidim.admin")
+            redirect_to static_pages_path
+          end
+          on(:invalid) do
+            flash.now[:alert] = I18n.t("static_pages.update.error", scope: "decidim.admin")
+            render :edit
+          end
+        end
+      end
+      def show
+        enforce_permission_to :read, :static_page
+      end
+      def destroy
+        enforce_permission_to :destroy, :static_page, static_page: page
+        DestroyStaticPage.call(page, current_user) do
+          on(:ok) do
+            flash[:notice] = I18n.t("static_pages.destroy.success", scope: "decidim.admin")
+            redirect_to static_pages_path
+          end
+        end
+      end
+      private
+      def form_params
+        form_params = params.to_unsafe_hash
+        form_params["static_page"] ||= {}
+        form_params["static_page"]["organization"] = current_organization
+        form_params["static_page"]["allow_public_access"] ||= page ? page.allow_public_access : false
+        return form_params unless page
+        form_params["static_page"]["slug"] ||= page.slug
+        form_params
+      end
+      def page
+        @page ||= collection.find_by(slug: params[:id])
+      end
+      def collection
+        current_organization.static_pages
+      end
+      def tos_version
+        current_organization.tos_version
+      end
+      def tos_version_formatted
+        @tos_version_formatted ||= l(tos_version, format: :short) if tos_version.present?
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/category_form.rb
@@ -0,0 +1,21 @@
+module Decidim
+  module Admin
+    class CategoryForm < Form
+      include TranslatableAttributes
+      translatable_attribute :name, String
+      attribute :weight, Integer, default: 0
+      attribute :parent_id, Integer
+      mimic :category
+      validates :name, translatable_presence: true
+      validates :parent_id, inclusion: { in: :parent_categories_ids }, allow_blank: true
+      delegate :current_participatory_space, to: :context, prefix: false
+      def parent_categories
+        @parent_categories ||= current_participatory_space.categories.first_class.where.not(id: id)
+      end
+      private
+      def parent_categories_ids
+        @parent_categories_ids ||= parent_categories.pluck(:id)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/component_form.rb
@@ -0,0 +1,49 @@
+module Decidim
+  module Admin
+    class ComponentForm < Decidim::Form
+      include TranslatableAttributes
+      mimic :component
+      translatable_attribute :name, String
+      validates :name, translatable_presence: true
+      attribute :weight, Integer, default: 0
+      attribute :manifest, Object
+      attribute :participatory_space, Object
+      validates :manifest, :participatory_space, presence: true
+      attribute :settings, Object
+      attribute :default_step_settings, Object
+      attribute(:step_settings, { String => Object })
+      attribute :share_tokens, Array[ShareToken]
+      validate :validate_settings, :validate_step_settings
+      def settings?
+        settings.manifest.attributes.any?
+      end
+      def default_step_settings?
+        default_step_settings.manifest.attributes.any?
+      end
+      def map_model(model)
+        self.share_tokens = model.share_tokens
+      end
+      private
+      def validate_settings
+        return unless errors.empty? && settings_errors_empty? # Preserves errors from custom validation methods
+        attributes.each do |key, value|
+          next unless value.respond_to?(:valid?)
+          errors.add(key, :invalid) unless value.valid?
+        end
+      end
+      def validate_step_settings
+        return unless step_settings.respond_to?(:attributes)
+        errors.add(:step_settings, :invalid) unless step_settings.attributes.values.all? { |v| !v.respond_to?(:valid?) || v.valid? }
+      end
+      def settings_errors_empty?
+        validations = [settings.errors.empty?]
+        validations << if default_step_settings.present?
+                         default_step_settings.errors.empty?
+                       else
+                         step_settings.each_value.map(&:errors).all?(&:empty?)
+                       end
+        validations.all?
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/import_example_form.rb
@@ -0,0 +1,35 @@
+module Decidim
+  module Admin
+    class ImportExampleForm < Form
+      attribute :name, String
+      attribute :format, String
+      validates :name, presence: true
+      validates :format, presence: true
+      validates :manifest, presence: true
+      validates :reader_klass, presence: true
+      validates :example_data, presence: true
+      def example
+        reader.example_file(example_data)
+      end
+      def available_formats
+        Decidim::Admin::Import::Readers::ACCEPTED_MIME_TYPES
+      end
+      private
+      def manifest
+        @manifest ||= current_component.manifest.import_manifests.find do |import_manifest|
+          import_manifest.name.to_s == name
+        end
+      end
+      def example_data
+        return unless manifest
+        manifest.example(self, current_component)
+      end
+      def reader
+        @reader ||= reader_klass ? reader_klass.new("/dev/null") : nil
+      end
+      def reader_klass
+        @reader_klass ||= Decidim::Admin::Import::Readers.search_by_file_extension(format)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/import_form.rb
@@ -0,0 +1,69 @@
+module Decidim
+  module Admin
+    class ImportForm < Form
+      ACCEPTED_MIME_TYPES = Decidim::Admin::Import::Readers::ACCEPTED_MIME_TYPES
+      include Decidim::HasUploadValidations
+      include Decidim::ProcessesFileLocally
+      attribute :name, String
+      attribute :file, Decidim::Attributes::Blob
+      validates :file, presence: true
+      validates :name, presence: true
+      validate :check_accepted_mime_type
+      validate :check_invalid_file, if: -> { file.present? && accepted_mime_type? }
+      validate :verify_import, if: -> { file.present? && accepted_mime_type? && !importer.invalid_file? }
+      def importer
+        @importer ||= importer_for(file, mime_type)
+      end
+      private
+      def check_accepted_mime_type
+        return if accepted_mime_type?
+        errors.add(
+          :file,
+          I18n.t(
+            "activemodel.errors.new_import.attributes.file.invalid_mime_type",
+            valid_mime_types: ACCEPTED_MIME_TYPES.keys.map do |m|
+              I18n.t("decidim.admin.new_import.accepted_mime_types.#{m}")
+            end.join(", ")
+          )
+        )
+      end
+      def check_invalid_file
+        return unless importer.invalid_file?
+        errors.add(:file, I18n.t("activemodel.errors.new_import.attributes.file.invalid_file"))
+      end
+      def verify_import
+        return if importer.verify
+        importer.errors.each do |error|
+          errors.add(:file, error.message)
+        end
+      end
+      def mime_type
+        file&.content_type
+      end
+      def creator_class
+        manifest.creator
+      end
+      def importer_for(path, mime_type)
+        Import::ImporterFactory.build(
+          path,
+          mime_type,
+          context: importer_context,
+          creator: creator_class
+        )
+      end
+      protected
+      def accepted_mime_type?
+        return true if ACCEPTED_MIME_TYPES.values.include?(mime_type)
+        false
+      end
+      def importer_context
+        context
+      end
+      def manifest
+        @manifest ||= current_component.manifest.import_manifests.find do |import_manifest|
+          import_manifest.name.to_s == name
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/managed_user_promotion_form.rb
@@ -0,0 +1,18 @@
+module Decidim
+  module Admin
+    class ManagedUserPromotionForm < Form
+      attribute :email, String
+      validates :email, presence: true, "valid_email_2/email": { disposable: true }
+      validate :unique_email
+      private
+      def unique_email
+        return true if Decidim::User.where(
+          organization: context.current_organization,
+          email: email
+        ).where.not(id: context.current_user.id).empty?
+        errors.add :email, :taken
+        false
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/participatory_space_private_user_csv_import_form.rb
@@ -0,0 +1,22 @@
+require "csv"
+module Decidim
+  module Admin
+    class ParticipatorySpacePrivateUserCsvImportForm < Form
+      include Decidim::HasUploadValidations
+      include Decidim::ProcessesFileLocally
+      attribute :file, Decidim::Attributes::Blob
+      attribute :user_name, String
+      attribute :email, String
+      validates :file, presence: true, file_content_type: { allow: ["text/csv"] }
+      validate :validate_csv
+      def validate_csv
+        return if file.blank?
+        process_file_locally(file) do |file_path|
+          CSV.foreach(file_path) do |_email, user_name|
+            errors.add(:user_name, :invalid) unless user_name.match?(UserBaseEntity::REGEXP_NAME)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/permission_form.rb
@@ -0,0 +1,32 @@
+module Decidim
+  module Admin
+    class PermissionForm < Form
+      attribute :authorization_handlers, Array[String]
+      attribute(:authorization_handlers_options, { String => Object })
+      def authorization_handlers
+        handlers = super || []
+        handlers.index_with { |name| { "options" => authorization_handler_options(name) } }
+      end
+      def authorization_handlers_names
+        authorization_handlers.keys.map(&:to_s)
+      end
+      def authorization_handler_options(handler_name)
+        authorization_handlers_options&.dig(handler_name.to_s) || {}
+      end
+      def manifest(handler_name)
+        Decidim::Verifications.find_workflow_manifest(handler_name)
+      end
+      def options_schema(handler_name)
+        options_manifest(handler_name).schema.new(authorization_handler_options(handler_name))
+      end
+      def options_attributes(handler_name)
+        manifest = options_manifest(handler_name)
+        manifest ? manifest.attributes : []
+      end
+      private
+      def options_manifest(handler_name)
+        manifest(handler_name).options
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/permissions_form.rb
@@ -0,0 +1,8 @@
+module Decidim
+  module Admin
+    class PermissionsForm < Form
+      mimic :component_permissions
+      attribute(:permissions, { String => PermissionForm })
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/selective_newsletter_form.rb
@@ -0,0 +1,35 @@
+module Decidim
+  module Admin
+    class SelectiveNewsletterForm < Decidim::Form
+      mimic :newsletter
+      attribute :participatory_space_types, Array[SelectiveNewsletterParticipatorySpaceTypeForm]
+      attribute :scope_ids, Array
+      attribute :send_to_all_users, Boolean
+      attribute :send_to_participants, Boolean
+      attribute :send_to_followers, Boolean
+      validates :send_to_all_users, presence: true, unless: ->(form) { form.send_to_participants.present? || form.send_to_followers.present? }
+      validates :send_to_followers, presence: true, if: ->(form) { form.send_to_all_users.blank? && form.send_to_participants.blank? }
+      validates :send_to_participants, presence: true, if: ->(form) { form.send_to_all_users.blank? && form.send_to_followers.blank? }
+      validate :at_least_one_participatory_space_selected
+      def map_model(_newsletter)
+        self.participatory_space_types = Decidim.participatory_space_manifests.map do |manifest|
+          SelectiveNewsletterParticipatorySpaceTypeForm.from_model(manifest: manifest)
+        end
+      end
+      def scope_ids
+        super.select(&:presence)
+      end
+      private
+      def at_least_one_participatory_space_selected
+        return if send_to_all_users && current_user.admin?
+        errors.add(:base, :at_least_one_space) if spaces_selected.blank?
+      end
+      def spaces_selected
+        participatory_space_types.map do |type|
+          spaces = type.ids.reject(&:empty?)
+          [type.manifest_name, spaces] if spaces.present?
+        end.compact
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/forms/decidim/admin/user_group_csv_verification_form.rb
@@ -0,0 +1,9 @@
+module Decidim
+  module Admin
+    class UserGroupCsvVerificationForm < Form
+      include Decidim::HasUploadValidations
+      attribute :file, Decidim::Attributes::Blob
+      validates :file, presence: true, file_content_type: { allow: ["text/csv"] }
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/helpers/decidim/admin/bulk_actions_helper.rb
@@ -0,0 +1,37 @@
+module Decidim
+  module Admin
+    module BulkActionsHelper
+      def bulk_categories_select(collection)
+        categories = bulk_categories_for_select collection
+        disabled = bulk_disabled_categories_for collection
+        prompt = t("decidim.proposals.admin.proposals.index.change_category")
+        select(:category, :id, options_for_select(categories, selected: [], disabled: disabled), prompt: prompt)
+      end
+      def bulk_categories_for_select(scope)
+        sorted_main_categories = scope.first_class.includes(:subcategories).sort_by do |category|
+          translated_attribute(category.name, category.participatory_space.organization)
+        end
+        sorted_main_categories.flat_map do |category|
+          parent = [[translated_attribute(category.name, category.participatory_space.organization), category.id]]
+          sorted_subcategories = category.subcategories.sort_by do |subcategory|
+            translated_attribute(subcategory.name, subcategory.participatory_space.organization)
+          end
+          sorted_subcategories.each do |subcategory|
+            parent << ["- #{translated_attribute(subcategory.name, subcategory.participatory_space.organization)}", subcategory.id]
+          end
+          parent
+        end
+      end
+      def bulk_disabled_categories_for(scope)
+        scope.first_class.joins(:subcategories).pluck(:id)
+      end
+      def bulk_components_select(siblings)
+        components = siblings.map do |component|
+          [translated_attribute(component.name, component.organization), component.id]
+        end
+        prompt = t("decidim.proposals.admin.proposals.index.select_component")
+        select(:target_component_id, nil, options_for_select(components, selected: []), prompt: prompt)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/helpers/decidim/admin/moderations/reports_helper.rb
@@ -0,0 +1,40 @@
+module Decidim
+  module Admin
+    module Moderations
+      module ReportsHelper
+        include Decidim::Messaging::ConversationHelper
+        include Decidim::ResourceHelper
+        include Decidim::TranslationsHelper
+        def reportable_author_name(reportable)
+          reportable_authors = reportable.try(:authors) || [reportable.try(:normalized_author)]
+          content_tag :ul, class: "reportable-authors" do
+            reportable_authors.select(&:present?).map do |author|
+              case author
+              when User
+                content_tag :li do
+                  link_to current_or_new_conversation_path_with(author), target: "_blank", rel: "noopener" do
+                    "#{author.name} #{icon "envelope-closed"}".html_safe
+                  end
+                end
+              when Decidim::Meetings::Meeting
+                content_tag :li do
+                  link_to resource_locator(author).path, target: "_blank", rel: "noopener" do
+                    translated_attribute(author.title)
+                  end
+                end
+              else
+                content_tag(:li, author.name)
+              end
+            end.join.html_safe
+          end
+        end
+        def reported_content_for(reportable, options = {})
+          cell "decidim/reported_content", reportable, options
+        end
+        def translatable_resource?(reportable)
+          reportable.respond_to?(:content_original_language)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/helpers/decidim/admin/newsletters_helper.rb
@@ -0,0 +1,127 @@
+module Decidim
+  module Admin
+    module NewslettersHelper
+      def participatory_spaces_for_select(form_object)
+        content_tag :div do
+          @form.participatory_space_types.each do |space_type|
+            concat participatory_space_types_form_object(form_object, space_type)
+          end
+        end
+      end
+      def participatory_space_types_form_object(form_object, space_type)
+        return if spaces_user_can_admin[space_type.manifest_name.to_sym].blank?
+        html = ""
+        form_object.fields_for "participatory_space_types[#{space_type.manifest_name}]", space_type do |ff|
+          html += ff.hidden_field :manifest_name, value: space_type.manifest_name
+          html += select_tag_participatory_spaces(space_type.manifest_name, spaces_for_select(space_type.manifest_name.to_sym), ff)
+        end
+        html.html_safe
+      end
+      def select_tag_participatory_spaces(manifest_name, spaces, child_form)
+        return unless spaces
+        content_tag :div, class: "#{manifest_name}-block spaces-block-tag cell small-12 medium-6" do
+          child_form.select :ids, options_for_select(spaces),
+                            { prompt: t("select_recipients_to_deliver.none", scope: "decidim.admin.newsletters"),
+                              label: t("activerecord.models.decidim/#{manifest_name.singularize}.other"),
+                              include_hidden: false },
+                            multiple: true, size: spaces.size > 10 ? 10 : spaces.size, class: "chosen-select"
+        end
+      end
+      def spaces_for_select(manifest_name)
+        return unless Decidim.participatory_space_manifests.map(&:name).include?(manifest_name)
+        return spaces_user_can_admin[manifest_name] unless current_user.admin?
+        [[I18n.t("select_recipients_to_deliver.all_spaces", scope: "decidim.admin.newsletters"), "all"]] + spaces_user_can_admin[manifest_name]
+      end
+      def selective_newsletter_to(newsletter)
+        return content_tag(:strong, t("index.not_sent", scope: "decidim.admin.newsletters"), class: "text-warning") unless newsletter.sent?
+        return content_tag(:strong, t("index.all_users", scope: "decidim.admin.newsletters"), class: "text-success") if newsletter.sent? && newsletter.extended_data.blank?
+        content_tag :div do
+          concat sent_to_users newsletter
+          concat sent_to_spaces newsletter
+          concat sent_to_scopes newsletter
+        end
+      end
+      def sent_to_users(newsletter)
+        content_tag :p, style: "margin-bottom:0;" do
+          concat content_tag(:strong, t("index.has_been_sent_to", scope: "decidim.admin.newsletters"), class: "text-success")
+          concat content_tag(:strong, t("index.all_users", scope: "decidim.admin.newsletters")) if newsletter.sended_to_all_users?
+          concat content_tag(:strong, t("index.followers", scope: "decidim.admin.newsletters")) if newsletter.sended_to_followers?
+          concat t("index.and", scope: "decidim.admin.newsletters") if newsletter.sended_to_followers? && newsletter.sended_to_participants?
+          concat content_tag(:strong, t("index.participants", scope: "decidim.admin.newsletters")) if newsletter.sended_to_participants?
+        end
+      end
+      def sent_to_spaces(newsletter)
+        html = "<p style='margin-bottom:0;'> "
+        newsletter.sended_to_partipatory_spaces.try(:each) do |type|
+          next if type["ids"].blank?
+          html += t("index.segmented_to", scope: "decidim.admin.newsletters", subject: t("activerecord.models.decidim/#{type["manifest_name"].singularize}.other"))
+          if type["ids"].include?("all")
+            html += "<strong> #{t("index.all", scope: "decidim.admin.newsletters")} </strong>"
+          else
+            Decidim.find_participatory_space_manifest(type["manifest_name"].to_sym)
+                   .participatory_spaces.call(current_organization).where(id: type["ids"]).each do |space|
+              html += "<strong>#{translated_attribute space.title}</strong>"
+            end
+          end
+          html += "<br/>"
+        end
+        html += "</p>"
+        html.html_safe
+      end
+      def sent_to_scopes(newsletter)
+        content_tag :p, style: "margin-bottom:0;" do
+          concat t("index.segmented_to", scope: "decidim.admin.newsletters", subject: nil)
+          if newsletter.sent_scopes.any?
+            newsletter.sent_scopes.each do |scope|
+              concat content_tag(:strong, (translated_attribute scope.name).to_s)
+            end
+          else
+            concat content_tag(:strong, t("index.no_scopes", scope: "decidim.admin.newsletters"))
+          end
+        end
+      end
+      def organization_participatory_space(manifest_name)
+        @organization_participatory_spaces ||= {}
+        @organization_participatory_spaces[manifest_name] ||= Decidim
+                                                              .find_participatory_space_manifest(manifest_name)
+                                                              .participatory_spaces.call(current_organization)
+                                                              .published
+                                                              .sort_by { |space| [space.try(:closed?) ? 1 : 0, space.title[current_locale]] }
+      end
+      def spaces_user_can_admin
+        @spaces_user_can_admin ||= {}
+        Decidim.participatory_space_manifests.each do |manifest|
+          organization_participatory_space(manifest.name)&.each do |space|
+            next unless space.admins.exists?(id: current_user.id)
+            @spaces_user_can_admin[manifest.name] ||= []
+            space_as_option_for_select_data = space_as_option_for_select(space)
+            @spaces_user_can_admin[manifest.name] << space_as_option_for_select_data unless @spaces_user_can_admin[manifest.name].detect do |x|
+              x == space_as_option_for_select_data
+            end
+          end
+        end
+        @spaces_user_can_admin
+      end
+      def space_as_option_for_select(space)
+        return unless space
+        [
+          translated_attribute(space.title),
+          space.id,
+          { class: space.try(:closed?) ? "red" : "green", title: translated_attribute(space.title).to_s }
+        ]
+      end
+      def newsletter_attention_callout_announcement
+        {
+          body: t("warning", scope: "decidim.admin.newsletters.select_recipients_to_deliver").html_safe
+        }
+      end
+      def newsletter_recipients_count_callout_announcement
+        spinner = "<span id='recipients_count_spinner' class='loading-spinner hide'></span>"
+        body = "#{t("recipients_count", scope: "decidim.admin.newsletters.select_recipients_to_deliver", count: recipients_count_query)} #{spinner}"
+        {
+          body: body
+        }
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/helpers/decidim/admin/reminders_helper.rb
@@ -0,0 +1,9 @@
+module Decidim
+  module Admin
+    module RemindersHelper
+      def admin_reminders_path(component, options = {})
+        EngineRouter.admin_proxy(component.participatory_space).new_component_reminder_path(options.merge(component_id: component))
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/helpers/decidim/admin/settings_helper.rb
@@ -0,0 +1,92 @@
+module Decidim
+  module Admin
+    module SettingsHelper
+      include Decidim::ScopesHelper
+      TYPES = {
+        boolean: :check_box,
+        integer: :number_field,
+        string: :text_field,
+        text: :text_area,
+        select: :select_field,
+        scope: :scope_field,
+        enum: :collection_radio_buttons,
+        time: :datetime_field
+      }.freeze
+      def settings_attribute_input(form, attribute, name, i18n_scope, options = {})
+        form_method = form_method_for_attribute(attribute)
+        container_class = "#{name}_container"
+        if options[:readonly]
+          container_class += " readonly_container"
+          help_text = text_for_setting(name, "readonly", i18n_scope)
+        end
+        help_text ||= text_for_setting(name, "help", i18n_scope)
+        help_text_options = help_text ? { help_text: help_text } : {}
+        options = { label: t(name, scope: i18n_scope) }
+                  .merge(help_text_options)
+                  .merge(extra_options_for_type(form_method))
+                  .merge(options)
+        content_tag(:div, class: container_class) do
+          if attribute.translated?
+            options[:tabs_id] = "#{options.delete(:tabs_prefix)}-#{name}-tabs"
+            form.send(:translated, form_method, name, options)
+          elsif form_method == :collection_radio_buttons
+            render_enum_form_field(form, attribute, name, i18n_scope, options)
+          elsif form_method == :select_field
+            render_select_form_field(form, attribute, name, i18n_scope, options)
+          elsif form_method == :scope_field
+            scopes_picker_field(form, name)
+          else
+            form.send(form_method, name, options)
+          end
+        end.html_safe
+      end
+      private
+      def render_select_form_field(form, attribute, name, i18n_scope, options)
+        html = form.select(
+          name,
+          attribute.build_choices.map { |o| [t("#{name}_options.#{o}", scope: i18n_scope), o] },
+          { include_blank: attribute.include_blank, label: options[:label] }
+        )
+        html << content_tag(:p, options[:help_text], class: "help-text") if options[:help_text]
+        html
+      end
+      def render_enum_form_field(form, attribute, name, i18n_scope, options)
+        html = label_tag(name) do
+          concat options[:label]
+          concat tag(:br)
+          concat form.collection_radio_buttons(name,
+                                               build_enum_choices(name, i18n_scope, attribute.build_choices),
+                                               :last,
+                                               :first,
+                                               { checked: form.object.send(name) },
+                                               options) { |b| b.label { b.radio_button + b.text } }
+        end
+        html << content_tag(:p, options[:help_text], class: "help-text") if options[:help_text]
+        html
+      end
+      def text_for_setting(name, suffix, i18n_scope)
+        html_key = "#{i18n_scope}.#{name}_#{suffix}_html"
+        return t(html_key) if I18n.exists?(html_key)
+        key = "#{i18n_scope}.#{name}_#{suffix}"
+        return t(key) if I18n.exists?(key)
+      end
+      def form_method_for_attribute(attribute)
+        return :editor if attribute.type.to_sym == :text && attribute.editor?
+        TYPES[attribute.type.to_sym]
+      end
+      def extra_options_for_type(input_type)
+        case input_type
+        when :text_area
+          { rows: 6 }
+        else
+          {}
+        end
+      end
+      def build_enum_choices(name, i18n_scope, choices)
+        choices.map do |choice|
+          [t("#{name}_choices.#{choice}", scope: i18n_scope), choice]
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/decidim-admin/app/packs/entrypoints/decidim_admin.js
@@ -0,0 +1,39 @@
+/* eslint no-unused-vars: 0 */
+/* eslint id-length: ["error", { "exceptions": ["$"] }] */
+import "core-js/stable";
+import "regenerator-runtime/runtime";
+import $ from "jquery"
+import Quill from "quill"
+import Rails from "@rails/ujs"
+import "foundation-sites"
+import "src/decidim/vendor/foundation-datepicker"
+import "src/decidim/foundation_datepicker_locales"
+import "jquery-serializejson"
+import "src/decidim/admin/tab_focus"
+import initLanguageChangeSelect from "src/decidim/admin/choose_language"
+import "src/decidim/admin/application"
+import "src/decidim/admin/resources_permissions"
+import "src/decidim/admin/welcome_notification"
+import "src/decidim/admin/newsletters"
+import "src/decidim/admin/form"
+import "src/decidim/admin/external_domain_whitelist"
+import "src/decidim/confirm"
+import "src/decidim/admin/draggable-list"
+import "src/decidim/admin/sortable"
+import "src/decidim/gallery"
+import "src/decidim/admin/moderations"
+import "src/decidim/input_tags"
+import "src/decidim/input_hashtags"
+import "src/decidim/input_mentions"
+import "src/decidim/vizzs"
+import "src/decidim/ajax_modals"
+import "src/decidim/admin/officializations"
+import "src/decidim/session_timeouter"
+import "src/decidim/slug_form"
+import "src/decidim/direct_uploads/upload_field"
+import "src/decidim/admin/admin_autocomplete"
+import "entrypoints/decidim_admin.scss";
+Rails.start()
+window.addEventListener("DOMContentLoaded", () => {
+  initLanguageChangeSelect(document.querySelectorAll("select.language-change"));
+});

--- a//dev/null
+++ b/decidim-admin/app/packs/src/decidim/admin/admin_autocomplete.js
@@ -0,0 +1,80 @@
+import AutoComplete from "src/decidim/autocomplete";
+/**
+ * This function can be used to create an autocomplete input automatically
+ * from the following kind of div:
+ *   <div data-autocomplete="{...}"></div>
+ *
+ * The data-autocomplete attribute should contain the following configuration
+ * as an encoded JSON, which is used to generate the AutoComplete options:
+ * - name: assembly_member[user_id],
+ * - options: [],
+ * - placeholder: "Select a participant",
+ * - searchURL: "http://..."
+ * - selected: "",
+ *
+ * @param {HTMLElement} el The element to generate the autocomplete for.
+ * @returns {AutoComplete} An instance of the AutoComplete class.
+ */
+const autoConfigure = (el) => {
+  const config = JSON.parse(el.dataset.autocomplete);
+  const searchUrl = new URL(config.searchURL);
+  const textInput = document.createElement("input");
+  textInput.type = "text";
+  textInput.className = "autocomplete-input";
+  el.appendChild(textInput);
+  let mode = config.mode || "sticky"
+  let selected = null;
+  if (config.selected) {
+    switch (mode) {
+    case "multi":
+      selected = config.selected.map((item) => (
+        {
+          key: "label",
+          value: {
+            value: item.value,
+            label: item.label
+          }
+        }
+      ));
+      break;
+    case "sticky":
+      selected = { key: "label", value: config.options[config.options.length - 1] };
+      break;
+    default:
+      selected = config.selected;
+    }
+  }
+  const dataSource = (query, callback) => {
+    const params = new URLSearchParams({
+      ...Object.fromEntries(searchUrl.searchParams),
+      term: query
+    });
+    fetch(`${searchUrl.origin}${searchUrl.pathname}?${params.toString()}`, {
+      method: "GET",
+      headers: { "Content-Type": "application/json" }
+    }).then((response) => response.json()).then((data) => {
+      callback(data)
+    });
+  };
+  const ac = new AutoComplete(textInput, {
+    name: config.name,
+    placeholder: config.placeholder,
+    selected: selected,
+    mode: mode,
+    searchPrompt: true,
+    searchPromptText: config.searchPromptText,
+    threshold: 3,
+    dataMatchKeys: ["label"],
+    dataSource
+  });
+  return ac;
+}
+$(() => {
+  const $autocompleteDiv = $("[data-autocomplete]");
+  if ($autocompleteDiv.length < 1) {
+    return;
+  }
+  $autocompleteDiv.each((_index, element) => {
+    autoConfigure(element);
+  })
+})

--- a//dev/null
+++ b/decidim-admin/app/packs/src/decidim/admin/application.js
@@ -0,0 +1,40 @@
+/* eslint-disable no-invalid-this */
+import toggleNav from "src/decidim/admin/toggle_nav"
+import createSortList from "src/decidim/admin/sort_list.component"
+import createQuillEditor from "src/decidim/editor"
+import formDatePicker from "src/decidim/form_datepicker"
+import DataPicker from "src/decidim/data_picker"
+import FormFilterComponent from "src/decidim/form_filter"
+import Configuration from "src/decidim/configuration"
+import InputCharacterCounter from "src/decidim/input_character_counter"
+import managedUsersForm from "src/decidim/admin/managed_users"
+window.Decidim = window.Decidim || {};
+window.Decidim.managedUsersForm = managedUsersForm
+window.Decidim.config = new Configuration()
+window.Decidim.InputCharacterCounter = InputCharacterCounter;
+$(() => {
+  window.theDataPicker = new DataPicker($(".data-picker"));
+  $(document).foundation();
+  toggleNav();
+  createSortList("#steps tbody", {
+    placeholder: $('<tr style="border-style: dashed; border-color: #000"><td colspan="4">&nbsp;</td></tr>')[0],
+    onSortUpdate: ($children) => {
+      const sortUrl = $("#steps tbody").data("sort-url")
+      const order = $children.map((index, child) => $(child).data("id")).toArray();
+      $.ajax({
+        method: "POST",
+        url: sortUrl,
+        contentType: "application/json",
+        data: JSON.stringify({ items_ids: order }) }, // eslint-disable-line camelcase
+      );
+    }
+  })
+  formDatePicker();
+  $(".editor-container").each((_idx, container) => {
+    createQuillEditor(container);
+  });
+  $("form.new_filter").each(function () {
+    const formFilter = new FormFilterComponent($(this));
+    formFilter.mountComponent();
+  })
+});

--- a//dev/null
+++ b/decidim-admin/app/packs/src/decidim/admin/choose_language.js
@@ -0,0 +1,12 @@
+/* eslint-disable no-invalid-this */
+/* eslint-disable require-jsdoc */
+export default function initLanguageChangeSelect(elements) {
+  elements.forEach((select) => {
+    select.addEventListener("change", () => {
+      let targetTabPaneSelector = select.value;
+      let tabsContent = select.parentElement.parentElement.nextElementSibling;
+      tabsContent.querySelector(".is-active").classList.remove("is-active");
+      tabsContent.querySelector(targetTabPaneSelector).classList.add("is-active");
+    })
+  });
+}

--- a/decidim-admin/app/packs/src/decidim/admin/draggable-list.js
+++ b//dev/null
@@ -1,23 +0,0 @@
-/* eslint-disable require-jsdoc */
-import createSortList from "src/decidim/admin/sort_list.component"
-export default function createSortableList(lists) {
-  createSortList(lists, {
-    handle: "li",
-    forcePlaceholderSize: true,
-    acceptFrom: ".js-connect"
-  })
-}
-$(() => {
-  const $draggables = $(".draggable-list")
-  let draggablesClassNames = []
-  $draggables.each((index, elem) => {
-    draggablesClassNames = [...draggablesClassNames, `.${elem.className.split(" ").filter((name) => (/js-list.*/).test(name))[0]}`]
-  })
-  document.addEventListener("drag", function (event) {
-    $draggables.not(event.target.parentElement).addClass("dragging")
-  })
-  document.addEventListener("dragend", function() {
-    $draggables.removeClass("dragging")
-  })
-  createSortableList(draggablesClassNames.join(", "))
-})

--- a//dev/null
+++ b/decidim-admin/app/packs/src/decidim/admin/dynamic_fields.component.js
@@ -0,0 +1,174 @@
+/* eslint-disable require-jsdoc */
+class DynamicFieldsComponent {
+  constructor(options = {}) {
+    this.wrapperSelector = options.wrapperSelector;
+    this.containerSelector = options.containerSelector;
+    this.fieldSelector = options.fieldSelector;
+    this.addFieldButtonSelector = options.addFieldButtonSelector;
+    this.addSeparatorButtonSelector = options.addSeparatorButtonSelector;
+    this.addTitleAndDescriptionButtonSelector = options.addTitleAndDescriptionButtonSelector;
+    this.fieldTemplateSelector = options.fieldTemplateSelector;
+    this.separatorTemplateSelector = options.separatorTemplateSelector;
+    this.TitleAndDescriptionTemplateSelector = options.TitleAndDescriptionTemplateSelector;
+    this.removeFieldButtonSelector = options.removeFieldButtonSelector;
+    this.moveUpFieldButtonSelector = options.moveUpFieldButtonSelector;
+    this.moveDownFieldButtonSelector = options.moveDownFieldButtonSelector;
+    this.onAddField = options.onAddField;
+    this.onRemoveField = options.onRemoveField;
+    this.onMoveUpField = options.onMoveUpField;
+    this.onMoveDownField = options.onMoveDownField;
+    this.placeholderId = options.placeholderId;
+    this.elementCounter = 0;
+    this._enableInterpolation();
+    this._activateFields();
+    this._bindEvents();
+  }
+  _enableInterpolation() {
+    $.fn.replaceAttribute = function(attribute, placeholder, value) {
+      $(this).find(`[${attribute}*=${placeholder}]`).addBack(`[${attribute}*=${placeholder}]`).each((index, element) => {
+        $(element).attr(attribute, $(element).attr(attribute).replace(placeholder, value));
+      });
+      return this;
+    }
+    $.fn.template = function(placeholder, value) {
+      const $subtemplate = $(this).find("template, .decidim-template");
+      if ($subtemplate.length > 0) {
+        $subtemplate.html((index, oldHtml) => $(oldHtml).template(placeholder, value)[0].outerHTML);
+      }
+      const $subtemplateParents = $(this).find("[data-template]");
+      if ($subtemplateParents.length > 0) {
+        $subtemplateParents.each((_i, elem) => {
+          const $self = $(elem);
+          const $tpl = $($self.data("template"));
+          const $subtpl = $($tpl[0].outerHTML);
+          const subtemplateId = `${$tpl.attr("id")}-${value}`;
+          const subtemplateSelector = `#${subtemplateId}`;
+          $subtpl.attr("id", subtemplateId);
+          $self.attr("data-template", subtemplateSelector).data("template", subtemplateSelector);
+          $tpl.after($subtpl);
+          $subtpl.html((index, oldHtml) => $(oldHtml).template(placeholder, value)[0].outerHTML);
+        });
+      }
+      $(this).replaceAttribute("id", placeholder, value);
+      $(this).replaceAttribute("name", placeholder, value);
+      $(this).replaceAttribute("data-tabs-content", placeholder, value);
+      $(this).replaceAttribute("for", placeholder, value);
+      $(this).replaceAttribute("tabs_id", placeholder, value);
+      $(this).replaceAttribute("href", placeholder, value);
+      $(this).replaceAttribute("value", placeholder, value);
+      return this;
+    }
+  }
+  _bindEvents() {
+    $(this.wrapperSelector).on("click", this.addFieldButtonSelector, (event) =>
+      this._bindSafeEvent(event, () => this._addField(this.fieldTemplateSelector))
+    );
+    if (this.addSeparatorButtonSelector) {
+      $(this.wrapperSelector).on("click", this.addSeparatorButtonSelector, (event) =>
+        this._bindSafeEvent(event, () => this._addField(this.separatorTemplateSelector))
+      );
+    }
+    if (this.addTitleAndDescriptionButtonSelector) {
+      $(this.wrapperSelector).on("click", this.addTitleAndDescriptionButtonSelector, (event) =>
+        this._bindSafeEvent(event, () => this._addField(this.TitleAndDescriptionTemplateSelector))
+      );
+    }
+    $(this.wrapperSelector).on("click", this.removeFieldButtonSelector, (event) =>
+      this._bindSafeEvent(event, (target) => this._removeField(target))
+    );
+    if (this.moveUpFieldButtonSelector) {
+      $(this.wrapperSelector).on("click", this.moveUpFieldButtonSelector, (event) =>
+        this._bindSafeEvent(event, (target) => this._moveUpField(target))
+      );
+    }
+    if (this.moveDownFieldButtonSelector) {
+      $(this.wrapperSelector).on("click", this.moveDownFieldButtonSelector, (event) =>
+        this._bindSafeEvent(event, (target) => this._moveDownField(target))
+      );
+    }
+  }
+  _bindSafeEvent(event, cb) {
+    event.preventDefault();
+    event.stopPropagation();
+    try {
+      return cb(event.target);
+    } catch (error) {
+      console.error(error); // eslint-disable-line no-console
+      return error;
+    }
+  }
+  _addField(templateClass = ".decidim-template") {
+    const $wrapper = $(this.wrapperSelector);
+    const $container = $wrapper.find(this.containerSelector);
+    const templateSelector = $wrapper.data("template");
+    let $template = null;
+    if (templateSelector) {
+      $template = $(templateSelector);
+    }
+    if ($template === null || $template.length < 1) {
+      $template = $wrapper.children(`template, ${templateClass}`);
+    }
+    const $newField = $($template.html()).template(this.placeholderId, this._getUID());
+    $newField.find("ul.tabs").attr("data-tabs", true);
+    const $lastQuestion = $container.find(this.fieldSelector).last()
+    if ($lastQuestion.length > 0) {
+      $lastQuestion.after($newField);
+    } else {
+      $newField.appendTo($container);
+    }
+    $newField.foundation();
+    if (this.onAddField) {
+      this.onAddField($newField);
+    }
+  }
+  _removeField(target) {
+    const $target = $(target);
+    const $removedField = $target.parents(this.fieldSelector);
+    const idInput = $removedField.find("input").filter((idx, input) => input.name.match(/id/));
+    if (idInput.length > 0) {
+      const deletedInput = $removedField.find("input").filter((idx, input) => input.name.match(/delete/));
+      if (deletedInput.length > 0) {
+        $(deletedInput[0]).val(true);
+      }
+      $removedField.addClass("hidden");
+      $removedField.hide();
+    } else {
+      $removedField.remove();
+    }
+    if (this.onRemoveField) {
+      this.onRemoveField($removedField);
+    }
+  }
+  _moveUpField(target) {
+    const $target = $(target);
+    const $movedUpField = $target.parents(this.fieldSelector);
+    $movedUpField.prev().before($movedUpField);
+    if (this.onMoveUpField) {
+      this.onMoveUpField($movedUpField);
+    }
+  }
+  _moveDownField(target) {
+    const $target = $(target);
+    const $movedDownField = $target.parents(this.fieldSelector);
+    $movedDownField.next().after($movedDownField);
+    if (this.onMoveDownField) {
+      this.onMoveDownField($movedDownField);
+    }
+  }
+  _activateFields() {
+    const $wrapper = $(this.wrapperSelector);
+    const $container = $wrapper.find(this.containerSelector);
+    $container.append($container.find("script"));
+    $(this.fieldSelector).each((idx, el) => {
+      $(el).template(this.placeholderId, this._getUID());
+      $(el).find("ul.tabs").attr("data-tabs", true);
+    })
+  }
+  _getUID() {
+    this.elementCounter += 1;
+    return (new Date().getTime()) + this.elementCounter;
+  }
+}
+export default function createDynamicFields(options) {
+  return new DynamicFieldsComponent(options);
+}

--- a/decidim-admin/app/permissions/decidim/admin/permissions.rb
+++ b/decidim-admin/app/permissions/decidim/admin/permissions.rb
@@ -14,32 +14,30 @@
         if user_manager?
           begin
             allow! if user_manager_permissions.allowed?
           rescue Decidim::PermissionAction::PermissionNotSetError
             nil
           end
         end
         allow! if user_can_enter_space_area?(require_admin_terms_accepted: true)
         read_admin_dashboard_action?
         apply_newsletter_permissions_for_admin!
-        apply_global_moderations_permission_for_admin!
+        allow! if permission_action.subject == :global_moderation
         if user.admin? && admin_terms_accepted?
           allow! if read_admin_log_action?
-          allow! if read_user_statistics_action?
           allow! if read_metrics_action?
           allow! if static_page_action?
-          allow! if templates_action?
           allow! if organization_action?
           allow! if user_action?
-          allow! if admin_user_action?
           allow! if permission_action.subject == :category
           allow! if permission_action.subject == :component
+          allow! if permission_action.subject == :admin_user
           allow! if permission_action.subject == :attachment
           allow! if permission_action.subject == :editor_image
           allow! if permission_action.subject == :attachment_collection
           allow! if permission_action.subject == :scope
           allow! if permission_action.subject == :scope_type
           allow! if permission_action.subject == :area
           allow! if permission_action.subject == :area_type
           allow! if permission_action.subject == :user_group
           allow! if permission_action.subject == :officialization
           allow! if permission_action.subject == :moderate_users
@@ -55,58 +53,40 @@
       private
       def user_manager?
         user && !user.admin? && user.role?("user_manager")
       end
       def read_admin_dashboard_action?
         return unless permission_action.subject == :admin_dashboard &&
                       permission_action.action == :read
         return user_manager_permissions if user_manager?
         toggle_allow(user.admin? || space_allows_admin_access_to_current_action?)
       end
-      def apply_global_moderations_permission_for_admin!
-        return unless admin_terms_accepted?
-        return unless permission_action.subject == :global_moderation
-        return allow! if user.admin?
-        return allow! if Decidim.participatory_space_manifests.flat_map.any? do |manifest|
-          Decidim
-                         .find_participatory_space_manifest(manifest.name)
-                         .participatory_spaces
-                         .call(user.organization)&.any? do |space|
-            space.respond_to?(:user_roles) && space.user_roles(:admin).where(user: user).or(space.user_roles(:moderator).where(user: user)).any?
-          end
-        end
-        disallow!
-      end
       def apply_newsletter_permissions_for_admin!
         return unless admin_terms_accepted?
         return unless permission_action.subject == :newsletter
         return allow! if user.admin?
         return unless space_allows_admin_access?
         newsletter = context.fetch(:newsletter, nil)
         case permission_action.action
         when :index, :create
           allow!
         when :read, :update, :destroy
           toggle_allow(user == newsletter.author)
         end
       end
       def space_allows_admin_access?
         Decidim.participatory_space_manifests.any? do |manifest|
           Decidim.find_participatory_space_manifest(manifest.name)
                  .participatory_spaces.call(organization)&.any? do |space|
             space.admins.exists?(id: user.id)
           end
         end
-      end
-      def read_user_statistics_action?
-        permission_action.subject == :users_statistics &&
-          permission_action.action == :read
       end
       def read_metrics_action?
         permission_action.subject == :metrics &&
           permission_action.action == :read
       end
       def read_admin_log_action?
         permission_action.subject == :admin_log &&
           permission_action.action == :read
       end
       def static_page_action?
@@ -116,34 +96,29 @@
         when :update
           static_page.present?
         when :update_slug, :destroy
           static_page.present? && !StaticPage.default?(static_page.slug)
         when :update_notable_changes
           static_page.slug == "terms-and-conditions" && static_page.persisted?
         else
           true
         end
       end
-      def templates_action?
-        permission_action.subject == :templates &&
-          permission_action.action == :read
-      end
       def organization_action?
         return unless permission_action.subject == :organization
         return unless permission_action.action == :update
         organization == user.organization
       end
       def managed_user_action?
         return unless permission_action.subject == :managed_user
         return user_manager_permissions if user_manager?
         return unless user&.admin?
-        return unless user&.admin_terms_accepted?
         case permission_action.action
         when :create
           toggle_allow(!organization.available_authorizations.empty?)
         else
           allow!
         end
         true
       end
       def user_action?
         return unless [:user, :impersonatable_user].include?(permission_action.subject)
@@ -155,41 +130,31 @@
           available_authorization_handlers? &&
             !subject_user.admin? &&
             subject_user.roles.empty? &&
             Decidim::ImpersonationLog.active.where(admin: user).empty?
         when :destroy
           subject_user != user
         else
           true
         end
       end
-      def admin_user_action?
-        return unless permission_action.subject == :admin_user
-        target_user = context.fetch(:user, nil)
-        case permission_action.action
-        when :destroy, :block
-          target_user != user
-        else
-          true
-        end
-      end
       def organization
         @organization ||= context.fetch(:organization, nil) || context.fetch(:current_organization, nil)
       end
       def user_can_enter_space_area?(**args)
         return unless permission_action.action == :enter &&
                       permission_action.subject == :space_area
         space_allows_admin_access_to_current_action?(**args)
       end
       def space_allows_admin_access_to_current_action?(require_admin_terms_accepted: false)
         Decidim.participatory_space_manifests.any? do |manifest|
-          next if require_admin_terms_accepted && !admin_terms_accepted?
+          next if manifest.name != :initiatives && require_admin_terms_accepted && !admin_terms_accepted?
           new_permission_action = Decidim::PermissionAction.new(
             action: permission_action.action,
             scope: permission_action.scope,
             subject: permission_action.subject
           )
           manifest.permissions_class.new(user, new_permission_action, context).permissions.allowed?
         rescue Decidim::PermissionAction::PermissionNotSetError
           nil
         end
       end

--- a//dev/null
+++ b/decidim-admin/app/presenters/decidim/admin/dashboard_metric_charts_presenter.rb
@@ -0,0 +1,46 @@
+module Decidim
+  module Admin
+    class DashboardMetricChartsPresenter < Decidim::MetricChartsPresenter
+      def summary?
+        __getobj__.fetch(:summary)
+      end
+      def render_not_highlighted(metrics)
+        safe_join(
+          metrics.map do |metric|
+            render_metrics_data(metric.metric_name, klass: not_highlighted_classes, graph_klass: "small")
+          end
+        )
+      end
+      def highlighted_metrics
+        return super unless summary?
+        Decidim.metrics_registry.filtered(
+          highlight: true,
+          scope: "home"
+        ).select do |registry|
+          %w(users proposals).include? registry.metric_name
+        end
+      end
+      def not_highlighted_metrics
+        return super unless summary?
+        Decidim.metrics_registry.filtered(
+          highlight: false,
+          scope: "home"
+        ).select do |registry|
+          %w(comments meetings accepted_proposals results blocked_users user_reports reported_users).include? registry.metric_name
+        end
+      end
+      private
+      def highlighted_classes
+        return "cell medium-6" if summary?
+        "cell medium-4"
+      end
+      def not_highlighted_classes
+        return "cell medium-3" if summary?
+        "cell medium-2"
+      end
+      def not_highlighted_wrapper_classes
+        "grid-x grid-margin-x"
+      end
+    end
+  end
+end

--- a/decidim-admin/lib/decidim/admin/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Admin
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-admin/spec/commands/decidim/admin/publish_component_spec.rb
+++ b//dev/null
@@ -1,46 +0,0 @@
-require "spec_helper"
-module Decidim::Admin
-  describe PublishComponent do
-    subject { described_class.new(component, user) }
-    let!(:user) { create(:user, :admin, :confirmed, organization: participatory_process.organization) }
-    let!(:participatory_process) { create(:participatory_process, :with_steps) }
-    let(:step) { participatory_process.steps.first }
-    let!(:component) { create(:component, :unpublished, participatory_space: participatory_process) }
-    it "publishes the component" do
-      expect { subject.call }.to change(component, :published?).from(false).to(true)
-    end
-    it "traces the action", versioning: true do
-      expect(Decidim.traceability)
-        .to receive(:perform_action!)
-        .with(:publish, component, user, visibility: "all")
-        .and_call_original
-      expect { subject.call }.to change(Decidim::ActionLog, :count)
-      action_log = Decidim::ActionLog.last
-      expect(action_log.version).to be_present
-    end
-    it "fires an event" do
-      create :follow, followable: participatory_process, user: user
-      expect(Decidim::EventsManager)
-        .to receive(:publish)
-        .with(
-          event: "decidim.events.components.component_published",
-          event_class: Decidim::ComponentPublishedEvent,
-          resource: component,
-          followers: [user]
-        )
-      subject.call
-    end
-    context "when the component is being republished" do
-      let!(:component) { create(:component, :unpublished, participatory_space: participatory_process) }
-      let!(:follower) { create :follow, followable: participatory_process, user: user }
-      it "does not fire an event", versioning: true do
-        subject.call
-        component.unpublish!
-        component.reload
-        expect(component.previously_published?).to be true
-        expect(Decidim::EventsManager).not_to receive(:publish)
-        subject.call
-      end
-    end
-  end
-end

--- a/decidim-admin/spec/permissions/decidim/admin/permissions_spec.rb
+++ b//dev/null
@@ -1,276 +0,0 @@
-require "spec_helper"
-describe Decidim::Admin::Permissions do
-  subject { described_class.new(user, permission_action, context).permissions.allowed? }
-  let(:user) { build :user, :admin, organization: organization }
-  let(:organization) { build :organization }
-  let(:context) { {} }
-  let(:permission_action) { Decidim::PermissionAction.new(**action) }
-  let(:registrations_enabled) { true }
-  let(:action) do
-    { scope: :admin, action: action_name, subject: action_subject }
-  end
-  let(:action_name) { :foo }
-  let(:action_subject) { :bar }
-  shared_examples "needs to accept Terms of Use for" do |action_subject_name, action_name|
-    let(:action_subject) { action_subject_name }
-    let(:action_name) { action_name }
-    context "when admin has accepted Terms of Use" do
-      let(:user) { build :user, :admin, admin_terms_accepted_at: Time.current, organization: organization }
-      it { is_expected.to be true }
-    end
-    context "when admin hasn't accepted Terms of Use" do
-      let(:user) { build :user, :admin, admin_terms_accepted_at: nil, organization: organization }
-      it_behaves_like "permission is not set"
-    end
-  end
-  context "when scope is not admin" do
-    let(:action) do
-      { scope: :public, action: :foo, subject: :bar }
-    end
-    context "when reading the admin dashboard" do
-      let(:action) do
-        { scope: :public, action: :read, subject: :admin_dashboard }
-      end
-      it { is_expected.to be true }
-      context "when user is a user manager" do
-        let(:user) { build :user, :user_manager }
-        it { is_expected.to be true }
-      end
-    end
-    it_behaves_like "permission is not set"
-  end
-  context "when user is not present" do
-    let(:user) { nil }
-    it { is_expected.to be false }
-  end
-  context "when user is a user manager" do
-    let(:user) { build :user, :user_manager }
-    it_behaves_like "delegates permissions to", Decidim::Admin::UserManagerPermissions
-    context "when entering a space area with space admin role" do
-      let(:action) do
-        { scope: :admin, action: :enter, subject: :space_area }
-      end
-      let(:participatory_process) { create(:participatory_process, organization: user.organization) }
-      before do
-        ::Decidim::ParticipatoryProcessUserRole.create(user: user, participatory_process: participatory_process, role: :admin)
-      end
-      it "allows users to enter the space area" do
-        expect { subject }.to raise_error(Decidim::PermissionAction::PermissionNotSetError)
-      end
-    end
-  end
-  context "when action is not registered" do
-    it_behaves_like "permission is not set"
-  end
-  context "when reading the admin dashboard" do
-    let(:action_name) { :read }
-    let(:action_subject) { :admin_dashboard }
-    it { is_expected.to be true }
-  end
-  describe "admin logs" do
-    let(:action_subject) { :admin_log }
-    it_behaves_like "permission is not set"
-    context "when reading" do
-      let(:action_name) { :read }
-      it { is_expected.to be true }
-    end
-  end
-  describe "user statistics" do
-    let(:action_subject) { :users_statistics }
-    it_behaves_like "permission is not set"
-    context "when reading" do
-      let(:action_name) { :read }
-      it { is_expected.to be true }
-    end
-  end
-  describe "metrics" do
-    let(:action_subject) { :metrics }
-    it_behaves_like "permission is not set"
-    context "when reading" do
-      let(:action_name) { :read }
-      it { is_expected.to be true }
-    end
-  end
-  describe "static pages" do
-    let(:action_subject) { :static_page }
-    let(:page) { build(:static_page, :default) }
-    let(:context) { { static_page: page } }
-    context "when updating" do
-      let(:action_name) { :update }
-      it { is_expected.to be true }
-      context "when page is not present" do
-        let(:page) { nil }
-        it_behaves_like "permission is not set"
-      end
-    end
-    context "when updating the slug" do
-      let(:action_name) { :update_slug }
-      context "when page is not present" do
-        let(:page) { nil }
-        it_behaves_like "permission is not set"
-      end
-      context "when page is default" do
-        it_behaves_like "permission is not set"
-      end
-      context "when page is not default" do
-        let(:page) { build :static_page }
-        it { is_expected.to be true }
-      end
-    end
-    context "when any other action" do
-      it { is_expected.to be true }
-    end
-  end
-  describe "global moderation" do
-    it_behaves_like "needs to accept Terms of Use for", :global_moderation, :read
-  end
-  describe "share tokens" do
-    let(:action_subject) { :share_token }
-    context "when any action" do
-      it { is_expected.to be true }
-    end
-  end
-  describe "organization" do
-    let(:action_subject) { :organization }
-    let(:context) { { organization: organization } }
-    context "when updating" do
-      let(:action_name) { :update }
-      context "when user belongs to organization" do
-        it { is_expected.to be true }
-      end
-      context "when user does not belong to organization" do
-        let(:user) { build :user, :admin }
-        it_behaves_like "permission is not set"
-      end
-    end
-    context "when any other action" do
-      it_behaves_like "permission is not set"
-    end
-  end
-  describe "managed users" do
-    let(:action_subject) { :managed_user }
-    let(:context) { { organization: organization } }
-    context "when creating" do
-      let(:action_name) { :create }
-      before do
-        allow(organization)
-          .to receive(:available_authorizations)
-          .and_return(authorizations)
-      end
-      context "when organization available authorizations are empty" do
-        let(:authorizations) { [] }
-        it { is_expected.to be false }
-      end
-      context "when organization available authorizations are not empty" do
-        let(:authorizations) { [:foo] }
-        it_behaves_like "needs to accept Terms of Use for", :managed_user, :create
-        it { is_expected.to be true }
-      end
-    end
-    context "when any other action" do
-      it { is_expected.to be true }
-    end
-  end
-  describe "users" do
-    let(:action_subject) { :user }
-    let(:subject_user) { build :user }
-    let(:context) { { user: subject_user } }
-    context "when destroying" do
-      let(:action_name) { :destroy }
-      context "when destroying another user" do
-        it { is_expected.to be true }
-      end
-      context "when destroying itself" do
-        let(:subject_user) { user }
-        it_behaves_like "permission is not set"
-      end
-    end
-    context "when promoting" do
-      let(:action_name) { :promote }
-      context "when subject user is not managed" do
-        it_behaves_like "permission is not set"
-      end
-      context "when subject user is managed" do
-        let(:subject_user) { build :user, :managed, organization: organization }
-        context "when there are active impersonation logs" do
-          before do
-            create :impersonation_log, user: subject_user, admin: user
-          end
-          it_behaves_like "permission is not set"
-        end
-        context "when there are no active impersonation logs" do
-          it { is_expected.to be true }
-        end
-      end
-    end
-    context "when impersonating" do
-      let(:action_name) { :impersonate }
-      let(:organization) { build :organization, available_authorizations: ["dummy_authorization_handler"] }
-      context "when organization has no available authorizations" do
-        let(:organization) { build :organization, available_authorizations: [] }
-        it_behaves_like "permission is not set"
-      end
-      context "when subject user is admin" do
-        let(:subject_user) { build :user, :admin, organization: organization }
-        it_behaves_like "permission is not set"
-      end
-      context "when subject user has some roles" do
-        let(:subject_user) { build :user, roles: ["my_role"] }
-        it_behaves_like "permission is not set"
-      end
-      context "when there are active impersonation logs" do
-        let(:subject_user) { build :user, organization: organization }
-        before do
-          create :impersonation_log, user: subject_user, admin: user
-        end
-        it_behaves_like "permission is not set"
-      end
-      context "when there are no active impersonation logs" do
-        it { is_expected.to be true }
-      end
-    end
-    context "when show their email" do
-      let(:action_name) { :show_email }
-      it { is_expected.to be true }
-      context "when user is not an admin" do
-        let(:user) { build :user, organization: organization }
-        it_behaves_like "permission is not set"
-      end
-    end
-    context "when any other action" do
-      it { is_expected.to be true }
-    end
-  end
-  describe "admins" do
-    let(:action_subject) { :admin_user }
-    context "when trying to delete admin rights from self" do
-      let(:action_name) { :destroy }
-      let(:context) { { user: user } }
-      it_behaves_like "permission is not set"
-    end
-    context "when trying to block self" do
-      let(:action_name) { :block }
-      let(:context) { { user: user } }
-      it_behaves_like "permission is not set"
-    end
-  end
-  shared_examples "can perform any action for" do |action_subject_name|
-    let(:action_subject) { action_subject_name }
-    it { is_expected.to be true }
-  end
-  it_behaves_like "can perform any action for", :category
-  it_behaves_like "can perform any action for", :component
-  it_behaves_like "can perform any action for", :admin_user
-  it_behaves_like "can perform any action for", :attachment
-  it_behaves_like "can perform any action for", :attachment_collection
-  it_behaves_like "can perform any action for", :scope
-  it_behaves_like "can perform any action for", :scope_type
-  it_behaves_like "can perform any action for", :area
-  it_behaves_like "can perform any action for", :area_type
-  it_behaves_like "can perform any action for", :newsletter
-  it_behaves_like "can perform any action for", :user_group
-  it_behaves_like "can perform any action for", :officialization
-  it_behaves_like "can perform any action for", :moderate_users
-  it_behaves_like "can perform any action for", :authorization
-  it_behaves_like "can perform any action for", :authorization_workflow
-end

--- a/decidim-admin/spec/system/admin_manages_officializations_spec.rb
+++ b//dev/null
@@ -1,206 +0,0 @@
-require "spec_helper"
-describe "Admin manages officializations", type: :system do
-  include_context "with filterable context"
-  let(:model_name) { Decidim::User.model_name }
-  let(:resource_controller) { Decidim::Admin::OfficializationsController }
-  let(:organization) { create(:organization) }
-  let!(:admin) { create(:user, :admin, :confirmed, organization: organization) }
-  before do
-    switch_to_host(organization.host)
-    login_as admin, scope: :user
-    visit decidim_admin.root_path
-    click_link "Participants"
-  end
-  describe "listing officializations" do
-    let!(:officialized) { create(:user, :officialized, organization: organization) }
-    let!(:not_officialized) { create(:user, organization: organization) }
-    let!(:deleted) do
-      user = create(:user, organization: organization)
-      result = Decidim::DestroyAccount.call(user, OpenStruct.new(valid?: true, delete_reason: "Testing"))
-      result["ok"]
-    end
-    let!(:external_not_officialized) { create(:user) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    it_behaves_like "a filtered collection", options: "State", filter: "Officialized" do
-      let(:in_filter) { officialized.name }
-      let(:not_in_filter) { not_officialized.name }
-    end
-    it_behaves_like "a filtered collection", options: "State", filter: "Not officialized" do
-      let(:in_filter) { not_officialized.name }
-      let(:not_in_filter) { officialized.name }
-    end
-    it_behaves_like "paginating a collection"
-  end
-  describe "blocked users" do
-    let!(:user) { create(:user, :blocked, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    context "when user is blocked" do
-      it "cannot be officialized" do
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          expect(page).not_to have_link("Officialize")
-        end
-      end
-    end
-  end
-  describe "officializating users" do
-    context "when not yet officialized" do
-      let!(:user) { create(:user, organization: organization) }
-      before do
-        within ".secondary-nav" do
-          click_link "Participants"
-        end
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          click_link "Officialize"
-        end
-      end
-      it "officializes it with the standard badge" do
-        click_button "Officialize"
-        expect(page).to have_content("successfully officialized")
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          expect(page).to have_content("Officialized")
-        end
-      end
-      it "officializes it with a custom badge" do
-        fill_in_i18n(
-          :officialization_officialized_as,
-          "#officialization-officialized_as-tabs",
-          en: "Major of Barcelona",
-          es: "Alcaldesa de Barcelona"
-        )
-        click_button "Officialize"
-        expect(page).to have_content("successfully officialized")
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          expect(page).to have_content("Officialized").and have_content("Major of Barcelona")
-        end
-      end
-    end
-    context "when officialized already" do
-      let!(:user) do
-        create(
-          :user,
-          :officialized,
-          officialized_as: { "en" => "Mayor of Barcelona" },
-          organization: organization
-        )
-      end
-      before do
-        within ".secondary-nav" do
-          click_link "Participants"
-        end
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          click_link "Reofficialize"
-        end
-      end
-      it "allows changing the officialization label" do
-        expect(page).to have_field("officialization_officialized_as_en", with: "Mayor of Barcelona")
-        fill_in_i18n(
-          :officialization_officialized_as,
-          "#officialization-officialized_as-tabs",
-          en: "Major of Barcelona"
-        )
-        click_button "Officialize"
-        expect(page).to have_content("successfully officialized")
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          expect(page).to have_content("Officialized").and have_content("Major of Barcelona")
-        end
-      end
-    end
-  end
-  describe "unofficializating users" do
-    let!(:user) { create(:user, :officialized, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-      within "tr[data-user-id=\"#{user.id}\"]" do
-        click_link "Unofficialize"
-      end
-    end
-    it "unofficializes user and goes back to list" do
-      expect(page).to have_content("successfully unofficialized")
-      within "tr[data-user-id=\"#{user.id}\"]" do
-        expect(page).to have_content("Not officialized")
-      end
-    end
-  end
-  describe "contacting the user" do
-    let!(:user) { create(:user, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    it "redirect to conversation path" do
-      within "tr[data-user-id=\"#{user.id}\"]" do
-        click_link "Contact"
-      end
-      expect(page).to have_current_path decidim.new_conversation_path(recipient_id: user.id)
-    end
-  end
-  describe "clicking on user name" do
-    let!(:user) { create(:user, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    it "redirect to user profile page" do
-      within "tr[data-user-id=\"#{user.id}\"]" do
-        click_link user.name
-      end
-      within ".profile--sidebar" do
-        expect(page).to have_content(user.name)
-      end
-    end
-  end
-  describe "clicking on user nickname" do
-    let!(:user) { create(:user, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    it "redirect to user profile page" do
-      within "tr[data-user-id=\"#{user.id}\"]" do
-        click_link user.nickname
-      end
-      within ".profile--sidebar" do
-        expect(page).to have_content(user.name)
-      end
-    end
-  end
-  describe "retrieving the user email address" do
-    let!(:users) { create_list(:user, 3, organization: organization) }
-    before do
-      within ".secondary-nav" do
-        click_link "Participants"
-      end
-    end
-    it "shows the users emails to admin users and logs the action" do
-      users.each do |user|
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          click_link "Show email"
-        end
-        within "#show-email-modal" do
-          expect(page).to have_content("Show participant's email address")
-          expect(page).not_to have_content(user.email)
-          click_button "Show"
-          expect(page).to have_content(user.email)
-          find("button[data-close]").click
-        end
-      end
-      visit decidim_admin.root_path
-      users.each do |user|
-        expect(page).to have_content("#{admin.name} retrieved the email of the participant #{user.name}")
-      end
-    end
-  end
-end

--- a/decidim-admin/spec/system/admin_manages_organization_admins_spec.rb
+++ b//dev/null
@@ -1,79 +0,0 @@
-require "spec_helper"
-describe "Organization admins", type: :system do
-  include Decidim::SanitizeHelper
-  let(:admin) { create :user, :admin, :confirmed }
-  let(:organization) { admin.organization }
-  before do
-    switch_to_host(organization.host)
-  end
-  describe "Managing users" do
-    before do
-      login_as admin, scope: :user
-      visit decidim_admin.root_path
-      click_link "Participants"
-      click_link "Admins"
-    end
-    it "can invite new users" do
-      within ".card-title" do
-        find(".button--title").click
-      end
-      within ".new_user" do
-        fill_in :user_name, with: "New admin"
-        fill_in :user_email, with: "newadmin@example.org"
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_content("New admin")
-      end
-    end
-    it "can invite a user with a specific role" do
-      within ".card-title" do
-        find(".button--title").click
-      end
-      within ".new_user" do
-        fill_in :user_name, with: "New user manager"
-        fill_in :user_email, with: "newusermanager@example.org"
-        select "Participant manager", from: :user_role
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_content("New user manager")
-        expect(page).to have_content("Participant manager")
-      end
-    end
-    context "with existing users" do
-      let!(:user) do
-        user = build(:user, :confirmed, :admin, organization: organization)
-        user.invite!
-        user
-      end
-      let!(:other_admin) { create(:user, :confirmed, :admin, organization: organization) }
-      before do
-        visit current_path
-      end
-      it "can resend the invitation" do
-        within "tr[data-user-id=\"#{user.id}\"]" do
-          click_link "Resend invitation"
-        end
-        expect(page).to have_content("Invitation successfully resent")
-      end
-      it "can remove the admin rights" do
-        expect(page).to have_content(other_admin.name)
-        within "tr[data-user-id=\"#{other_admin.id}\"]" do
-          accept_confirm { click_link "Delete" }
-        end
-        expect(page).to have_no_content(other_admin.name)
-      end
-      it "cannot remove admin rights from self" do
-        within "tr[data-user-id=\"#{admin.id}\"]" do
-          expect(page).not_to have_link("Delete")
-        end
-        within "tr[data-user-id=\"#{other_admin.id}\"]" do
-          expect(page).to have_link("Delete")
-        end
-      end
-    end
-  end
-end

--- a/decidim-admin/spec/system/space_admin_manages_global_moderations_spec.rb
+++ b//dev/null
@@ -1,85 +0,0 @@
-require "spec_helper"
-describe "Space admin manages global moderations", type: :system do
-  let!(:user) do
-    create(
-      :process_admin,
-      :confirmed,
-      organization: organization,
-      participatory_process: participatory_space
-    )
-  end
-  let(:organization) { current_component.organization }
-  let(:current_component) { create :component }
-  let(:participatory_space) { current_component.participatory_space }
-  let!(:reportables) { create_list(:dummy_resource, 2, component: current_component) }
-  let(:participatory_space_path) do
-    decidim_admin.root_path
-  end
-  before do
-    switch_to_host(organization.host)
-    login_as user, scope: :user
-  end
-  context "when the user didn't accepted the admin ToS" do
-    before do
-      user.update(admin_terms_accepted_at: nil)
-      visit decidim_admin.moderations_path
-    end
-    it "has a message that they need to accept the admin TOS" do
-      expect(page).to have_content("You are not authorized")
-      expect(page).to have_content("Please take a moment to review Admin Terms of Use. Otherwise you won't be able to manage the platform")
-    end
-    it "has only the Dashboard menu item in the main navigation" do
-      within ".main-nav" do
-        expect(page).to have_text("Dashboard")
-        expect(page).to have_selector("li a", count: 1)
-      end
-    end
-    context "when they visit other admin pages" do
-      before do
-        visit decidim_admin.newsletters_path
-      end
-      it "says that you're not authorized" do
-        within ".callout.alert" do
-          expect(page).to have_text("You are not authorized to perform this action")
-        end
-      end
-    end
-  end
-  context "when the user can visualize the components" do
-    let!(:reportable) { create(:dummy_resource, component: current_component, title: { "en" => "<p>Dummy<br> Title</p>" }) }
-    let!(:moderation) { create(:moderation, reportable: reportable) }
-    it "can see links to components" do
-      visit decidim_admin.moderations_path
-      within "body", wait: 2 do
-        expect(page).to have_content("Reported content")
-        expect(page).to have_link("Visit URL")
-        find_link("Visit URL").hover
-        expect(page).to have_content("Dummy Title")
-        tooltip_id = find_link("Visit URL")["data-toggle"]
-        result = page.find("[id='#{tooltip_id}']", visible: :all)
-        expect(result).to have_content("Dummy Title")
-      end
-    end
-  end
-  context "when the user can manage a space that has moderations" do
-    it_behaves_like "manage moderations" do
-      let(:moderations_link_text) { "Global moderations" }
-    end
-    it_behaves_like "sorted moderations" do
-      let!(:reportables) { create_list(:dummy_resource, 17, component: current_component) }
-      let(:moderations_link_text) { "Global moderations" }
-    end
-  end
-  context "when the user can manage a space without moderations" do
-    let(:participatory_space) do
-      create :participatory_process, organization: organization
-    end
-    it "can't see any moderation" do
-      visit decidim_admin.moderations_path
-      within ".container" do
-        expect(page).to have_content("Reported content")
-        expect(page).to have_no_selector("table.table-list tbody tr")
-      end
-    end
-  end
-end

--- a/decidim-admin/spec/system/space_moderator_manages_global_moderations_spec.rb
+++ b//dev/null
@@ -1,61 +0,0 @@
-require "spec_helper"
-describe "Space moderator manages global moderations", type: :system do
-  let!(:user) do
-    create(
-      :process_moderator,
-      :confirmed,
-      organization: organization,
-      admin_terms_accepted_at: Time.current,
-      participatory_process: participatory_space
-    )
-  end
-  let(:organization) { current_component.organization }
-  let(:current_component) { create :component }
-  let(:participatory_space) { current_component.participatory_space }
-  let!(:reportables) { create_list(:dummy_resource, 2, component: current_component) }
-  let(:participatory_space_path) do
-    decidim_admin.root_path
-  end
-  before do
-    switch_to_host(organization.host)
-    login_as user, scope: :user
-  end
-  context "when the user hasn't accepted the Terms of Use" do
-    before do
-      user.update(admin_terms_accepted_at: nil)
-    end
-    it "doesn't have the menu item in the main navigation" do
-      visit participatory_space_path
-      within ".main-nav" do
-        expect(page).not_to have_text("Global moderations")
-      end
-    end
-    it "can't access to the Global moderations page" do
-      visit decidim_admin.moderations_path
-      within ".callout.alert" do
-        expect(page).to have_text("You are not authorized to perform this action")
-      end
-    end
-  end
-  context "when the user can manage a space that has moderations" do
-    it_behaves_like "manage moderations" do
-      let(:moderations_link_text) { "Global moderations" }
-    end
-    it_behaves_like "sorted moderations" do
-      let!(:reportables) { create_list(:dummy_resource, 17, component: current_component) }
-      let(:moderations_link_text) { "Global moderations" }
-    end
-  end
-  context "when the user can manage a space without moderations" do
-    let(:participatory_space) do
-      create :participatory_process, organization: organization
-    end
-    it "can't see any moderation" do
-      visit decidim_admin.moderations_path
-      within ".container" do
-        expect(page).to have_content("Reported content")
-        expect(page).to have_no_selector("table.table-list tbody tr")
-      end
-    end
-  end
-end

--- a/decidim-admin/spec/system/static_pages_spec.rb
+++ b//dev/null
@@ -1,207 +0,0 @@
-require "spec_helper"
-describe "Content pages", type: :system do
-  include ActionView::Helpers::SanitizeHelper
-  let(:admin) { create :user, :admin, :confirmed }
-  let(:organization) { admin.organization }
-  before do
-    switch_to_host(organization.host)
-  end
-  describe "Showing pages" do
-    let!(:decidim_pages) { create_list(:static_page, 5, :with_topic, organization: organization) }
-    it_behaves_like "editable content for admins" do
-      let(:target_path) { decidim.pages_path }
-    end
-    context "when requesting the pages path" do
-      before do
-        visit decidim.pages_path
-      end
-      it "shows the list of all the pages" do
-        decidim_pages.each do |decidim_page|
-          expect(page).to have_css(
-            "a[href=\"#{decidim.page_path(decidim_page)}\"]",
-            text: decidim_page.title[I18n.locale.to_s]
-          )
-        end
-      end
-    end
-  end
-  describe "Managing topics" do
-    context "when creating a topic" do
-      before do
-        login_as admin, scope: :user
-        visit decidim_admin.root_path
-        click_link "Pages"
-      end
-      it "can create topics" do
-        within ".secondary-nav" do
-          click_link "Create topic"
-        end
-        within ".new_static_page_topic" do
-          fill_in_i18n(
-            :static_page_topic_title,
-            "#static_page_topic-title-tabs",
-            en: "General",
-            es: "General",
-            ca: "General"
-          )
-          fill_in_i18n(
-            :static_page_topic_description,
-            "#static_page_topic-description-tabs",
-            en: "<p>Some HTML content</p>",
-            es: "<p>Contenido HTML</p>",
-            ca: "<p>Contingut HTML</p>"
-          )
-          find("*[type=submit]").click
-        end
-        expect(page).to have_admin_callout("successfully")
-        expect(page).to have_css(".card h2", text: "General")
-      end
-    end
-    context "when editing a topic" do
-      let!(:topic) { create(:static_page_topic, organization: organization) }
-      before do
-        login_as admin, scope: :user
-        visit decidim_admin.root_path
-        click_link "Pages"
-      end
-      it "can create page groups" do
-        within find(".card-title", text: topic.title[I18n.locale.to_s]) do
-          click_link "Edit"
-        end
-        within ".edit_static_page_topic" do
-          fill_in_i18n(
-            :static_page_topic_title,
-            "#static_page_topic-title-tabs",
-            en: "New title",
-            es: "Nuevo ttulo",
-            ca: "Nou ttol"
-          )
-          fill_in_i18n(
-            :static_page_topic_description,
-            "#static_page_topic-description-tabs",
-            en: "<p>Some HTML content</p>",
-            es: "<p>Contenido HTML</p>",
-            ca: "<p>Contingut HTML</p>"
-          )
-          find("*[type=submit]").click
-        end
-        expect(page).to have_admin_callout("successfully")
-        expect(page).to have_css(".card h2", text: "New title")
-      end
-    end
-    context "when deleting topics" do
-      let!(:topic) { create(:static_page_topic, organization: organization) }
-      before do
-        login_as admin, scope: :user
-        visit decidim_admin.root_path
-        click_link "Pages"
-      end
-      it "can delete them" do
-        within find(".card", text: translated(topic.title)) do
-          accept_confirm { click_link "Remove topic" }
-        end
-        expect(page).to have_admin_callout("successfully")
-        within "table" do
-          expect(page).to have_no_content(translated(topic.title))
-        end
-      end
-    end
-  end
-  describe "Managing pages" do
-    let!(:topic) { create(:static_page_topic, organization: organization) }
-    before do
-      login_as admin, scope: :user
-      visit decidim_admin.root_path
-      click_link "Pages"
-    end
-    context "when displaying the page form" do
-      before do
-        click_link "Create page"
-      end
-      it_behaves_like "having a rich text editor", "new_static_page", "full"
-    end
-    it "can create new pages" do
-      within ".secondary-nav" do
-        click_link "Create page"
-      end
-      within ".new_static_page" do
-        fill_in :static_page_slug, with: "welcome"
-        fill_in_i18n(
-          :static_page_title,
-          "#static_page-title-tabs",
-          en: "Welcome to Decidim",
-          es: "Te damos la bienvendida a Decidim",
-          ca: "Et donem la benvinguda a Decidim"
-        )
-        fill_in_i18n_editor(
-          :static_page_content,
-          "#static_page-content-tabs",
-          en: "<p>Some HTML content</p>",
-          es: "<p>Contenido HTML</p>",
-          ca: "<p>Contingut HTML</p>"
-        )
-        select topic.title[I18n.locale.to_s], from: "Topic"
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within find(".card", text: topic.title[I18n.locale.to_s]) do
-        expect(page).to have_css("tr", text: "Welcome to Decidim")
-      end
-    end
-    context "with existing pages" do
-      let!(:decidim_page) { create(:static_page, :with_topic, organization: organization) }
-      let!(:topic) { create(:static_page_topic, organization: organization) }
-      before do
-        visit current_path
-      end
-      context "when displaying the page form" do
-        before do
-          within find("tr", text: translated(decidim_page.title)) do
-            click_link "Edit"
-          end
-        end
-        it_behaves_like "having a rich text editor", "edit_static_page", "full"
-      end
-      it "can edit them" do
-        within find("tr", text: translated(decidim_page.title)) do
-          click_link "Edit"
-        end
-        within ".edit_static_page" do
-          fill_in_i18n(
-            :static_page_title,
-            "#static_page-title-tabs",
-            en: "Not welcomed anymore"
-          )
-          fill_in_i18n_editor(
-            :static_page_content,
-            "#static_page-content-tabs",
-            en: "This is the new <strong>content</strong>"
-          )
-          select topic.title[I18n.locale.to_s], from: "Topic"
-          find("*[type=submit]").click
-        end
-        expect(page).to have_admin_callout("successfully")
-        within find(".card", text: topic.title[I18n.locale.to_s]) do
-          expect(page).to have_css("tr", text: "Not welcomed anymore")
-        end
-      end
-      it "can delete them" do
-        within find("tr", text: translated(decidim_page.title)) do
-          accept_confirm { click_link "Delete" }
-        end
-        expect(page).to have_admin_callout("successfully")
-        within "table" do
-          expect(page).to have_no_content(translated(decidim_page.title))
-        end
-      end
-      it "can visit them" do
-        within find("tr", text: translated(decidim_page.title)) do
-          click_link "View public page"
-        end
-        expect(page).to have_content(translated(decidim_page.title))
-        expect(page).to have_content(strip_tags(translated(decidim_page.content)))
-        expect(page).to have_current_path(/#{decidim_page.slug}/)
-      end
-    end
-  end
-end

--- a/decidim-api/lib/decidim/api/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Api
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-assemblies/lib/decidim/assemblies/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Assemblies
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-assemblies/spec/system/admin/admin_manages_assemblies_spec.rb
+++ b//dev/null
@@ -1,129 +0,0 @@
-require "spec_helper"
-describe "Admin manages assemblies", type: :system do
-  include_context "when admin administrating an assembly"
-  let(:model_name) { assembly.class.model_name }
-  let(:resource_controller) { Decidim::Assemblies::Admin::AssembliesController }
-  shared_examples "creating an assembly" do
-    let(:image1_filename) { "city.jpeg" }
-    let(:image1_path) { Decidim::Dev.asset(image1_filename) }
-    let(:image2_filename) { "city2.jpeg" }
-    let(:image2_path) { Decidim::Dev.asset(image2_filename) }
-    before do
-      click_link "New assembly"
-    end
-    %w(purpose_of_action composition description short_description announcement internal_organisation).each do |field|
-      it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='assembly-#{field}-tabs']", "full"
-    end
-    it_behaves_like "having a rich text editor for field", "#closing_date_reason_div", "content"
-    it "creates a new assembly" do
-      within ".new_assembly" do
-        fill_in_i18n(
-          :assembly_title,
-          "#assembly-title-tabs",
-          en: "My assembly",
-          es: "Mi proceso participativo",
-          ca: "El meu procs participatiu"
-        )
-        fill_in_i18n(
-          :assembly_subtitle,
-          "#assembly-subtitle-tabs",
-          en: "Subtitle",
-          es: "Subttulo",
-          ca: "Subttol"
-        )
-        fill_in_i18n_editor(
-          :assembly_short_description,
-          "#assembly-short_description-tabs",
-          en: "Short description",
-          es: "Descripcin corta",
-          ca: "Descripci curta"
-        )
-        fill_in_i18n_editor(
-          :assembly_description,
-          "#assembly-description-tabs",
-          en: "A longer description",
-          es: "Descripcin ms larga",
-          ca: "Descripci ms llarga"
-        )
-        fill_in :assembly_slug, with: "slug"
-        fill_in :assembly_hashtag, with: "#hashtag"
-        fill_in :assembly_weight, with: 1
-      end
-      dynamically_attach_file(:assembly_hero_image, image1_path)
-      dynamically_attach_file(:assembly_banner_image, image2_path)
-      within ".new_assembly" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_current_path decidim_admin_assemblies.assemblies_path(q: { parent_id_eq: parent_assembly&.id })
-        expect(page).to have_content("My assembly")
-      end
-    end
-  end
-  context "when managing parent assemblies" do
-    let(:parent_assembly) { nil }
-    let!(:assembly) { create :assembly, organization: organization }
-    before do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_assemblies.assemblies_path
-    end
-    it_behaves_like "manage assemblies"
-    it_behaves_like "creating an assembly"
-    it_behaves_like "manage assemblies announcements"
-    describe "listing parent assemblies" do
-      it_behaves_like "filtering collection by published/unpublished"
-      it_behaves_like "filtering collection by private/public"
-      context "when filtering by assemblies type" do
-        include_context "with filterable context"
-        let!(:assemblies_type1) { create(:assemblies_type) }
-        let!(:assemblies_type2) { create(:assemblies_type) }
-        Decidim::AssembliesType.all.each do |assemblies_type|
-          i18n_assemblies_type = assemblies_type.name[I18n.locale.to_s]
-          context "filtering collection by assemblies_type: #{i18n_assemblies_type}" do
-            let!(:assembly1) { create(:assembly, organization: organization, assemblies_type: assemblies_type1) }
-            let!(:assembly2) { create(:assembly, organization: organization, assemblies_type: assemblies_type2) }
-            it_behaves_like "a filtered collection", options: "Assembly type", filter: i18n_assemblies_type do
-              let(:in_filter) { translated(assembly_with_type(type).title) }
-              let(:not_in_filter) { translated(assembly_without_type(type).title) }
-            end
-          end
-        end
-        it_behaves_like "paginating a collection"
-        def assembly_with_type(type)
-          Decidim::Assembly.find_by(decidim_assemblies_type_id: type)
-        end
-        def assembly_without_type(type)
-          Decidim::Assembly.where.not(decidim_assemblies_type_id: type).sample
-        end
-      end
-    end
-  end
-  context "when managing child assemblies" do
-    let!(:parent_assembly) { create :assembly, organization: organization }
-    let!(:child_assembly) { create :assembly, organization: organization, parent: parent_assembly }
-    let(:assembly) { child_assembly }
-    before do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_assemblies.assemblies_path
-      within find("tr", text: translated(parent_assembly.title)) do
-        click_link "Assemblies"
-      end
-    end
-    it_behaves_like "manage assemblies"
-    it_behaves_like "creating an assembly"
-    it_behaves_like "manage assemblies announcements"
-    describe "listing child assemblies" do
-      it_behaves_like "filtering collection by published/unpublished" do
-        let!(:published_space) { child_assembly }
-        let!(:unpublished_space) { create(:assembly, :unpublished, parent: parent_assembly, organization: organization) }
-      end
-      it_behaves_like "filtering collection by private/public" do
-        let!(:public_space) { child_assembly }
-        let!(:private_space) { create(:assembly, :private, parent: parent_assembly, organization: organization) }
-      end
-    end
-  end
-end

--- a/decidim-assemblies/spec/system/assemblies_spec.rb
+++ b//dev/null
@@ -1,283 +0,0 @@
-require "spec_helper"
-require "decidim/core/test/shared_examples/has_contextual_help"
-describe "Assemblies", type: :system do
-  let(:organization) { create(:organization) }
-  let(:show_statistics) { true }
-  let(:description) { { en: "Description", ca: "Descripci", es: "Descripcin" } }
-  let(:short_description) { { en: "Short description", ca: "Descripci curta", es: "Descripcin corta" } }
-  let(:purpose_of_action) { { en: "Purpose of action", ca: "Propsit de l'acci", es: "Propsito de la accin" } }
-  let(:internal_organisation) { { en: "Internal organisation", ca: "Organitzaci interna", es: "Organizacin interna" } }
-  let(:composition) { { en: "Composition", ca: "Composici", es: "Composicin" } }
-  let(:closing_date_reason) { { en: "Closing date reason", ca: "Motiu de la data de tancament", es: "Razn de la fecha de cierre" } }
-  let(:base_assembly) do
-    create(
-      :assembly,
-      :with_type,
-      organization: organization,
-      description: description,
-      short_description: short_description,
-      purpose_of_action: purpose_of_action,
-      internal_organisation: internal_organisation,
-      composition: composition,
-      closing_date_reason: closing_date_reason,
-      show_statistics: show_statistics
-    )
-  end
-  before do
-    switch_to_host(organization.host)
-  end
-  context "when there are no assemblies and directly accessing from URL" do
-    it_behaves_like "a 404 page" do
-      let(:target_path) { decidim_assemblies.assemblies_path }
-    end
-  end
-  context "when there are no assemblies and accessing from the homepage" do
-    it "the menu link is not shown" do
-      visit decidim.root_path
-      within ".main-nav" do
-        expect(page).to have_no_content("Assemblies")
-      end
-    end
-  end
-  context "when the assembly does not exist" do
-    it_behaves_like "a 404 page" do
-      let(:target_path) { decidim_assemblies.assembly_path(99_999_999) }
-    end
-  end
-  context "when there are some assemblies and all are unpublished" do
-    before do
-      create(:assembly, :unpublished, organization: organization)
-      create(:assembly, :published)
-    end
-    context "and directly accessing from URL" do
-      it_behaves_like "a 404 page" do
-        let(:target_path) { decidim_assemblies.assemblies_path }
-      end
-    end
-    context "and accessing from the homepage" do
-      it "the menu link is not shown" do
-        visit decidim.root_path
-        within ".main-nav" do
-          expect(page).to have_no_content("Assemblies")
-        end
-      end
-    end
-  end
-  context "when there are some published assemblies" do
-    let!(:assembly) { base_assembly }
-    let!(:child_assembly) { create(:assembly, parent: assembly, organization: organization) }
-    let!(:promoted_assembly) { create(:assembly, :promoted, organization: organization) }
-    let!(:unpublished_assembly) { create(:assembly, :unpublished, organization: organization) }
-    it_behaves_like "editable content for admins" do
-      let(:target_path) { decidim_assemblies.assemblies_path }
-    end
-    it_behaves_like "shows contextual help" do
-      let(:index_path) { decidim_assemblies.assemblies_path }
-      let(:manifest_name) { :assemblies }
-    end
-    context "and requesting the asseblies path" do
-      before do
-        visit decidim_assemblies.assemblies_path
-      end
-      context "and accessing from the homepage" do
-        it "the menu link is shown" do
-          visit decidim.root_path
-          within ".main-nav" do
-            expect(page).to have_content("Assemblies")
-            click_link "Assemblies"
-          end
-          expect(page).to have_current_path decidim_assemblies.assemblies_path
-        end
-      end
-      it "lists all the highlighted assemblies" do
-        within "#highlighted-assemblies" do
-          expect(page).to have_content(translated(promoted_assembly.title, locale: :en))
-          expect(page).to have_selector(".card--full", count: 1)
-        end
-      end
-      it "lists the parent assemblies" do
-        within "#parent-assemblies" do
-          within "#parent-assemblies h3" do
-            expect(page).to have_content("2")
-          end
-          expect(page).to have_content(translated(assembly.title, locale: :en))
-          expect(page).to have_content(translated(promoted_assembly.title, locale: :en))
-          expect(page).to have_selector(".card", count: 2)
-          expect(page).to have_selector(".card.card--stack", count: 1)
-          expect(page).not_to have_content(translated(child_assembly.title, locale: :en))
-          expect(page).not_to have_content(translated(unpublished_assembly.title, locale: :en))
-        end
-      end
-      it "links to the individual assembly page" do
-        first(".card__link", text: translated(assembly.title, locale: :en)).click
-        expect(page).to have_current_path decidim_assemblies.assembly_path(assembly)
-      end
-      it "shows the organizational chart" do
-        within "#assemblies-chart" do
-          within ".js-orgchart" do
-            expect(page).to have_selector(".svg-chart-container")
-            within ".svg-chart-container" do
-              expect(page).to have_selector("g.node", count: 2)
-            end
-          end
-        end
-      end
-    end
-  end
-  describe "when going to the assembly page" do
-    let!(:assembly) { base_assembly }
-    let!(:proposals_component) { create(:component, :published, participatory_space: assembly, manifest_name: :proposals) }
-    let!(:meetings_component) { create(:component, :unpublished, participatory_space: assembly, manifest_name: :meetings) }
-    before do
-      create_list(:proposal, 3, component: proposals_component)
-      allow(Decidim).to receive(:component_manifests).and_return([proposals_component.manifest, meetings_component.manifest])
-    end
-    it_behaves_like "editable content for admins" do
-      let(:target_path) { decidim_assemblies.assembly_path(assembly) }
-    end
-    context "and requesting the assembly path" do
-      before do
-        visit decidim_assemblies.assembly_path(assembly)
-      end
-      it "shows the details of the given assembly" do
-        within "main" do
-          expect(page).to have_content(translated(assembly.title, locale: :en))
-          expect(page).to have_content(translated(assembly.subtitle, locale: :en))
-          expect(page).to have_content(translated(assembly.description, locale: :en))
-          expect(page).to have_content(translated(assembly.short_description, locale: :en))
-          expect(page).to have_content(translated(assembly.meta_scope, locale: :en))
-          expect(page).to have_content(translated(assembly.developer_group, locale: :en))
-          expect(page).to have_content(translated(assembly.local_area, locale: :en))
-          expect(page).to have_content(translated(assembly.target, locale: :en))
-          expect(page).to have_content(translated(assembly.participatory_scope, locale: :en))
-          expect(page).to have_content(translated(assembly.participatory_structure, locale: :en))
-          expect(page).to have_content(assembly.hashtag)
-        end
-      end
-      it_behaves_like "has attachments" do
-        let(:attached_to) { assembly }
-      end
-      context "when having rich content" do
-        context "when short_description" do
-          it_behaves_like "has embedded video in description", :short_description
-        end
-        context "when description" do
-          before { click_button("Read more") }
-          it_behaves_like "has embedded video in description", :description
-        end
-        context "when purpose_of_action" do
-          before { click_button("Read more") }
-          it_behaves_like "has embedded video in description", :purpose_of_action
-        end
-        context "when internal_organisation" do
-          before { click_button("Read more") }
-          it_behaves_like "has embedded video in description", :internal_organisation
-        end
-        context "when composition" do
-          before { click_button("Read more") }
-          it_behaves_like "has embedded video in description", :composition
-        end
-      end
-      context "when the assembly has some components" do
-        it "shows the components" do
-          within ".process-nav" do
-            expect(page).to have_content(translated(proposals_component.name, locale: :en).upcase)
-            expect(page).to have_no_content(translated(meetings_component.name, locale: :en).upcase)
-          end
-        end
-      end
-      context "and the process statistics are enabled" do
-        let(:show_statistics) { true }
-        it "renders the stats for those components are visible" do
-          within ".section-statistics" do
-            expect(page).to have_css("h3.section-heading", text: "STATISTICS")
-            expect(page).to have_css(".statistic__title", text: "PROPOSALS")
-            expect(page).to have_css(".statistic__number", text: "3")
-            expect(page).to have_no_css(".statistic__title", text: "MEETINGS")
-            expect(page).to have_no_css(".statistic__number", text: "0")
-          end
-        end
-      end
-      context "and the process statistics are not enabled" do
-        let(:show_statistics) { false }
-        it "doesn't render the stats for those components that are not visible" do
-          expect(page).to have_no_css("h4.section-heading", text: "STATISTICS")
-          expect(page).to have_no_css(".statistic__title", text: "PROPOSALS")
-          expect(page).to have_no_css(".statistic__number", text: "3")
-        end
-      end
-      context "when the assembly has children assemblies" do
-        let!(:child_assembly) { create :assembly, organization: organization, parent: assembly, weight: 0 }
-        let!(:second_child_assembly) { create :assembly, organization: organization, parent: assembly, weight: 1 }
-        let!(:unpublished_child_assembly) { create :assembly, :unpublished, organization: organization, parent: assembly }
-        before do
-          visit decidim_assemblies.assembly_path(assembly)
-        end
-        it "shows only the published children assemblies" do
-          within("#assemblies-grid") do
-            expect(page).to have_link translated(child_assembly.title)
-            expect(page).not_to have_link translated(unpublished_child_assembly.title)
-          end
-        end
-        it "shows the children assemblies by weigth" do
-          expect(page).to have_selector("#assemblies-grid .row .column:first-child", text: child_assembly.title[:en])
-          expect(page).to have_selector("#assemblies-grid .row .column:last-child", text: second_child_assembly.title[:en])
-        end
-        context "when child assembly has a meeting" do
-          let(:meetings_component) { create(:meeting_component, :published, participatory_space: child_assembly) }
-          context "with unpublished meeting" do
-            let!(:meeting) { create(:meeting, :upcoming, component: meetings_component) }
-            it "is not displaying the widget" do
-              visit decidim_assemblies.assembly_path(assembly)
-              within("#assemblies-grid") do
-                expect(page).not_to have_content("Upcoming meeting")
-              end
-            end
-          end
-          context "with published meeting" do
-            let!(:meeting) { create(:meeting, :upcoming, :published, component: meetings_component) }
-            it "is displaying the widget" do
-              visit decidim_assemblies.assembly_path(assembly)
-              within("#assemblies-grid") do
-                expect(page).to have_content("Upcoming meeting")
-              end
-            end
-          end
-        end
-      end
-      context "when the assembly has children private and transparent assemblies" do
-        let!(:private_transparent_child_assembly) { create :assembly, organization: organization, parent: assembly, private_space: true, is_transparent: true }
-        let!(:private_transparent_unpublished_child_assembly) { create :assembly, :unpublished, organization: organization, parent: assembly, private_space: true, is_transparent: true }
-        before do
-          visit decidim_assemblies.assembly_path(assembly)
-        end
-        it "shows only the published, private and transparent children assemblies" do
-          within("#assemblies-grid") do
-            expect(page).to have_link translated(private_transparent_child_assembly.title)
-            expect(page).not_to have_link translated(private_transparent_unpublished_child_assembly.title)
-          end
-        end
-      end
-      context "when the assembly has children private and not transparent assemblies" do
-        let!(:private_child_assembly) { create :assembly, organization: organization, parent: assembly, private_space: true, is_transparent: false }
-        let!(:private_unpublished_child_assembly) { create :assembly, :unpublished, organization: organization, parent: assembly, private_space: true, is_transparent: false }
-        before do
-          visit decidim_assemblies.assembly_path(assembly)
-        end
-        it "not shows any children assemblies" do
-          expect(page).not_to have_css("div#assemblies-grid")
-        end
-      end
-    end
-  end
-  describe "when going to the assembly child page" do
-    let!(:parent_assembly) { base_assembly }
-    let!(:child_assembly) { create :assembly, organization: organization, parent: parent_assembly }
-    before do
-      visit decidim_assemblies.assembly_path(child_assembly)
-    end
-    it "have a link to the parent assembly" do
-      expect(page).to have_link translated(parent_assembly.title)
-    end
-  end
-end

--- a/decidim-blogs/lib/decidim/blogs/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Blogs
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-blogs/spec/shared/manage_posts_examples.rb
+++ b//dev/null
@@ -1,212 +0,0 @@
-shared_examples "manage posts" do
-  it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='post-body-tabs']", "full" do
-    before do
-      within find("tr", text: translated(post1.title)) do
-        click_link "Edit"
-      end
-    end
-  end
-  it "updates a post" do
-    within find("tr", text: translated(post1.title)) do
-      click_link "Edit"
-    end
-    within ".edit_post" do
-      expect(page).to have_select("post_decidim_author_id", selected: author.name)
-      fill_in_i18n(
-        :post_title,
-        "#post-title-tabs",
-        en: "My new title",
-        es: "Mi nuevo ttulo",
-        ca: "El meu nou ttol"
-      )
-      fill_in_i18n_editor(
-        :post_body,
-        "#post-body-tabs",
-        en: "A longer description",
-        es: "Descripcin ms larga",
-        ca: "Descripci ms llarga"
-      )
-      find("*[type=submit]").click
-    end
-    expect(page).to have_admin_callout("successfully")
-    within "table" do
-      expect(page).to have_content("My new title")
-      expect(page).to have_content("Post title 2")
-      expect(page).to have_content(author.name)
-    end
-  end
-  it "creates a new post", :slow do
-    find(".card-title a.button").click
-    fill_in_i18n(
-      :post_title,
-      "#post-title-tabs",
-      en: "My post",
-      es: "Mi post",
-      ca: "El meu post"
-    )
-    fill_in_i18n_editor(
-      :post_body,
-      "#post-body-tabs",
-      en: "A description",
-      es: "Descripcin",
-      ca: "Descripci"
-    )
-    within ".new_post" do
-      find("*[type=submit]").click
-    end
-    expect(page).to have_admin_callout("successfully")
-    within "table" do
-      expect(page).to have_content("My post")
-      expect(page).to have_content("Post title 1")
-      expect(page).to have_content("Post title 2")
-    end
-  end
-  describe "deleting a post" do
-    before do
-      visit current_path
-    end
-    it "deletes a post" do
-      within find("tr", text: translated(post1.title)) do
-        accept_confirm { click_link "Delete" }
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_no_content(translated(post1.title))
-        expect(page).to have_content(translated(post2.title))
-      end
-    end
-  end
-  context "when user is in user group" do
-    let(:user_group) { create :user_group, :confirmed, :verified, organization: organization }
-    let!(:membership) { create(:user_group_membership, user: user, user_group: user_group) }
-    it "can set user group as posts author", :slow do
-      find(".card-title a.button").click
-      select user_group.name, from: "post_decidim_author_id"
-      fill_in_i18n(
-        :post_title,
-        "#post-title-tabs",
-        en: "My post",
-        es: "Mi post",
-        ca: "El meu post"
-      )
-      fill_in_i18n_editor(
-        :post_body,
-        "#post-body-tabs",
-        en: "A description",
-        es: "Descripcin",
-        ca: "Descripci"
-      )
-      within ".new_post" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_content(user_group.name)
-        expect(page).to have_content("My post")
-        expect(page).to have_content("Post title 1")
-        expect(page).to have_content("Post title 2")
-      end
-    end
-    it "can update the user group as the post author" do
-      within find("tr", text: translated(post1.title)) do
-        click_link "Edit"
-      end
-      within ".edit_post" do
-        select user_group.name, from: "post_decidim_author_id"
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within find("tr", text: translated(post1.title)) do
-        expect(page).to have_content(user_group.name)
-      end
-    end
-  end
-  context "when user is the organization" do
-    let(:author) { organization }
-    it "can set organization as posts author", :slow do
-      find(".card-title a.button").click
-      select organization.name, from: "post_decidim_author_id"
-      fill_in_i18n(
-        :post_title,
-        "#post-title-tabs",
-        en: "My post",
-        es: "Mi post",
-        ca: "El meu post"
-      )
-      fill_in_i18n_editor(
-        :post_body,
-        "#post-body-tabs",
-        en: "A description",
-        es: "Descripcin",
-        ca: "Descripci"
-      )
-      within ".new_post" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_content(author.name)
-        expect(page).to have_content("My post")
-        expect(page).to have_content("Post title 1")
-        expect(page).to have_content("Post title 2")
-      end
-    end
-    it "can update the blog as the organization" do
-      within find("tr", text: translated(post1.title)) do
-        click_link "Edit"
-      end
-      within ".edit_post" do
-        select organization.name, from: "post_decidim_author_id"
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within find("tr", text: translated(post1.title)) do
-        expect(page).to have_content(author.name)
-      end
-    end
-  end
-  context "when user is current_user" do
-    let(:author) { user }
-    it "can set current_user as posts author", :slow do
-      find(".card-title a.button").click
-      select user.name, from: "post_decidim_author_id"
-      fill_in_i18n(
-        :post_title,
-        "#post-title-tabs",
-        en: "My post",
-        es: "Mi post",
-        ca: "El meu post"
-      )
-      fill_in_i18n_editor(
-        :post_body,
-        "#post-body-tabs",
-        en: "A description",
-        es: "Descripcin",
-        ca: "Descripci"
-      )
-      within ".new_post" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).to have_content(author.name)
-        expect(page).to have_content("My post")
-        expect(page).to have_content("Post title 1")
-        expect(page).to have_content("Post title 2")
-      end
-    end
-    it "can update the blog as the user" do
-      within find("tr", text: translated(post1.title)) do
-        click_link "Edit"
-      end
-      within ".edit_post" do
-        select user.name, from: "post_decidim_author_id"
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within find("tr", text: translated(post1.title)) do
-        expect(page).to have_content(author.name)
-      end
-    end
-  end
-end

--- a/decidim-blogs/spec/system/explore_posts_spec.rb
+++ b//dev/null
@@ -1,109 +0,0 @@
-require "spec_helper"
-describe "Explore posts", type: :system do
-  include_context "with a component"
-  let(:manifest_name) { "blogs" }
-  let!(:old_post) { create(:post, component: component, created_at: 2.days.ago) }
-  let!(:new_post) { create(:post, component: component, created_at: Time.current) }
-  let!(:image) { create(:attachment, attached_to: old_post) }
-  describe "index" do
-    it "shows all posts for the given process" do
-      visit_component
-      expect(page).to have_selector(".card", count: 2)
-      expect(page).to have_selector(".card--post", text: translated(new_post.title))
-      expect(page).to have_selector(".card--post", text: translated(old_post.title))
-    end
-    it "shows comment counts" do
-      visit_component
-      expect(page).to have_selector('a[title="comments"]', text: "comment".pluralize(new_post.comments.count))
-      expect(page).to have_selector('a[title="comments"]', text: "comment".pluralize(old_post.comments.count))
-    end
-    it "shows endorsement counts" do
-      visit_component
-      expect(page).to have_selector('a[title="endorsements"]', text: "endorsement".pluralize(new_post.endorsements.count))
-      expect(page).to have_selector('a[title="endorsements"]', text: "endorsement".pluralize(old_post.endorsements.count))
-    end
-    it "shows images" do
-      visit_component
-      expect(page).to have_selector(".card--post img.card__image")
-    end
-    context "when paginating" do
-      let(:collection_size) { 10 }
-      let!(:collection) { create_list :post, collection_size, component: component }
-      let!(:resource_selector) { ".card--post" }
-      before do
-        visit_component
-      end
-      it "lists 4 resources per page by default" do
-        expect(page).to have_css(resource_selector, count: 4)
-        expect(page).to have_css(".pagination .page", count: 3)
-      end
-    end
-  end
-  describe "show" do
-    let(:posts_count) { 1 }
-    let(:author) { organization }
-    let(:body) { { en: "Short description", ca: "Descripci curta", es: "Descripcin corta" } }
-    let!(:post) { create(:post, component: component, author: author, body: body) }
-    before do
-      visit resource_locator(post).path
-    end
-    context "when author is an organization" do
-      it "shows 'Official' as the author" do
-        within ".author__name" do
-          expect(page).to have_content("Official")
-        end
-      end
-    end
-    context "when author is a user_group" do
-      let(:author) { create(:user_group, :verified, organization: organization) }
-      it "shows user group as the author" do
-        within ".author__name" do
-          expect(page).to have_content(author.name)
-        end
-      end
-    end
-    context "when author is a user" do
-      let(:author) { user }
-      it "shows user as the author" do
-        within ".author__name" do
-          expect(page).to have_content(user.name)
-        end
-      end
-    end
-    it "show post info" do
-      expect(page).to have_i18n_content(post.title)
-      expect(page).to have_i18n_content(post.body)
-      expect(page).to have_content(post.author.name)
-      expect(page).to have_content(post.created_at.strftime("%d/%m/%Y %H:%M "))
-    end
-    it_behaves_like "has embedded video in description", :body
-    it "shows the back button" do
-      expect(page).to have_link(href: "#{main_component_path(component)}posts")
-    end
-    context "when clicking the back button" do
-      before do
-        click_link(href: "#{main_component_path(component)}posts")
-      end
-      it "redirect the user to component index" do
-        expect(page).to have_current_path("#{main_component_path(component)}posts")
-      end
-    end
-  end
-  describe "most commented" do
-    context "when ordering by 'most_commented'" do
-      let!(:post_more_comments) { create(:post, component: component) }
-      let!(:post_less_comments) { create(:post, component: component) }
-      let!(:more_comments) { create_list(:comment, 7, commentable: post_more_comments) }
-      let!(:less_comments) { create_list(:comment, 3, commentable: post_less_comments) }
-      before do
-        visit_component
-      end
-      it "lists the posts ordered by comments count" do
-        within "#most-commented" do
-          expect(page).to have_content(translated(post_more_comments.title))
-          expect(page).to have_content(translated(post_less_comments.title))
-        end
-      end
-    end
-  end
-end

--- a/decidim-budgets/lib/decidim/budgets/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Budgets
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-budgets/spec/mailers/decidim/budgets/order_summary_mailer_spec.rb
+++ b//dev/null
@@ -1,45 +0,0 @@
-require "spec_helper"
-module Decidim::Budgets
-  describe OrderSummaryMailer, type: :mailer do
-    let(:order) { create :order, :with_projects }
-    let(:user) { order.user }
-    let(:space) { order.budget.participatory_space }
-    let(:organization) { space.organization }
-    let(:budget) { order.budget }
-    describe "#order_summary" do
-      let(:mail) { described_class.order_summary(order) }
-      shared_examples "working order summary mail" do
-        it "delivers the email to the user" do
-          expect(mail.to).to eq([user.email])
-        end
-        it "includes the organization data" do
-          expect(mail.body.encoded).to include(user.organization.name)
-        end
-        it "includes the budget title" do
-          expect(mail.body.encoded).to include(translated(budget.title))
-        end
-        it "includes the participatory space title" do
-          expect(mail.body).to include(translated(space.title))
-        end
-        it "includes the projects names" do
-          order.projects.each do |project|
-            expect(mail.body).to include(translated(project.title))
-          end
-        end
-      end
-      it_behaves_like "working order summary mail"
-      context "when scopes are enabled and the component has a scope defined" do
-        let(:scope) { create(:scope, organization: organization) }
-        let(:component) { budget.component }
-        before do
-          component.update(settings: { scopes_enabled: true, scope_id: scope.id })
-        end
-        it_behaves_like "working order summary mail"
-        it "includes the scope name and scope type name" do
-          expect(mail.body.encoded).to include(translated(scope.name))
-          expect(mail.body.encoded).to include(translated(scope.scope_type.name))
-        end
-      end
-    end
-  end
-end

--- a/decidim-budgets/spec/system/admin_manages_budgets_spec.rb
+++ b//dev/null
@@ -1,158 +0,0 @@
-require "spec_helper"
-describe "Admin manages budgets", type: :system do
-  let(:budget) { create :budget, component: current_component }
-  let(:manifest_name) { "budgets" }
-  include_context "when managing a component as an admin"
-  before do
-    budget
-    switch_to_host(organization.host)
-    login_as user, scope: :user
-    visit_component_admin
-  end
-  describe "admin form" do
-    before { click_on "New Budget" }
-    it_behaves_like "having a rich text editor", "new_budget", "content"
-  end
-  it "creates a new budget" do
-    within ".card-title" do
-      click_link "New Budget"
-    end
-    within ".new_budget" do
-      fill_in_i18n(
-        :budget_title,
-        "#budget-title-tabs",
-        en: "My Budget",
-        es: "Mi Presupuesto",
-        ca: "El meu Pressupost"
-      )
-      fill_in_i18n_editor(
-        :budget_description,
-        "#budget-description-tabs",
-        en: "Long description",
-        es: "Descripcin ms larga",
-        ca: "Descripci ms llarga"
-      )
-      fill_in :budget_weight, with: 1
-      fill_in :budget_total_budget, with: 100_000_00
-      scope_pick select_data_picker(:budget_decidim_scope_id), scope
-    end
-    within ".new_budget" do
-      find("*[type=submit]").click
-    end
-    within ".callout-wrapper" do
-      expect(page).to have_content("successfully")
-    end
-    within "table" do
-      expect(page).to have_content("My Budget")
-    end
-  end
-  describe "updating a budget" do
-    it "updates a budget" do
-      within find("tr", text: translated(budget.title)) do
-        page.find(".action-icon--edit").click
-      end
-      within ".edit_budget" do
-        fill_in_i18n(
-          :budget_title,
-          "#budget-title-tabs",
-          en: "My new title",
-          es: "Mi nuevo ttulo",
-          ca: "El meu nou ttol"
-        )
-        find("*[type=submit]").click
-      end
-      within ".callout-wrapper" do
-        expect(page).to have_content("successfully")
-      end
-      within "table" do
-        expect(page).to have_content("My new title")
-      end
-    end
-  end
-  describe "previewing budgets" do
-    it "links the budget correctly" do
-      link = find("a[title=Preview]")
-      expect(link[:href]).to include(resource_locator(budget).path)
-    end
-  end
-  describe "deleting a budget" do
-    it "deletes a budget" do
-      within find("tr", text: translated(budget.title)) do
-        accept_confirm do
-          page.find(".action-icon--remove").click
-        end
-      end
-      within ".callout-wrapper" do
-        expect(page).to have_content("successfully")
-      end
-      within "table" do
-        expect(page).not_to have_content(translated(budget.title))
-      end
-    end
-    context "when the budget has projects" do
-      let!(:budget) { create(:budget, :with_projects, component: current_component) }
-      it "cannot delete the budget" do
-        within find("tr", text: translated(budget.title)) do
-          expect(page).to have_no_selector(".action-icon--remove")
-        end
-      end
-    end
-  end
-  describe "component page shows finished and pending orders of all budgets" do
-    context "when component has many budgets with orders" do
-      let(:budget2) { create(:budget, :with_projects, component: current_component) }
-      let(:project) { create(:project, budget: budget, budget_amount: 90_000_000) }
-      let(:project2) { create(:project, budget: budget2, budget_amount: 95_000_000) }
-      let(:user2) { create :user, :confirmed, organization: organization }
-      let(:user3) { create :user, :confirmed, organization: organization }
-      let!(:finished_order) do
-        order = create(:order, user: user, budget: budget)
-        order.projects << project
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      let!(:pending_order) do
-        order = create(:order, user: user, budget: budget2)
-        order.projects << project2
-        order.save!
-        order
-      end
-      let!(:finished_order2) do
-        order = create(:order, user: user2, budget: budget)
-        order.projects << project
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      let!(:finished_order3) do
-        order = create(:order, user: user2, budget: budget2)
-        order.projects << project2
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      let!(:finished_order4) do
-        order = create(:order, user: user3, budget: budget2)
-        order.projects << project2
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      it "shows finished and pending orders" do
-        visit current_path
-        within find_all(".card-divider").last do
-          expect(page).to have_content("Finished votes: \n4")
-          expect(page).to have_content("Pending votes: \n1")
-        end
-      end
-      it "shows count of users with finished and pending orders" do
-        visit current_path
-        within find_all(".card-divider").last do
-          expect(page).to have_content("Users with finished votes: \n3")
-          expect(page).to have_content("Users with pending votes: \n1")
-        end
-      end
-    end
-  end
-end

--- a/decidim-budgets/spec/system/explore_budgets_spec.rb
+++ b//dev/null
@@ -1,86 +0,0 @@
-require "spec_helper"
-describe "Explore Budgets", :slow, type: :system do
-  include ActionView::Helpers::NumberHelper
-  include_context "with a component"
-  let(:manifest_name) { "budgets" }
-  let!(:component) do
-    create(:budgets_component,
-           :with_vote_threshold_percent,
-           manifest: manifest,
-           participatory_space: participatory_process)
-  end
-  context "with only one budget" do
-    let!(:budgets) { create_list(:budget, 1, component: component) }
-    it "redirects to the only budget details" do
-      visit_component
-      expect(page).to have_content("More information")
-    end
-  end
-  context "with many budgets" do
-    let!(:budgets) do
-      1.upto(6).to_a.map { |x| create(:budget, component: component, weight: x, total_budget: x * 10_000_000, description: { en: "This is budget #{x}" }) }
-    end
-    before do
-      visit_component
-    end
-    it "lists all the budgets" do
-      expect(page).to have_selector(".card--list__item", count: 6)
-      budgets.each do |budget|
-        expect(page).to have_content(translated(budget.title))
-        expect(page).to have_content(number_to_currency(budget.total_budget, unit: Decidim.currency_unit, precision: 0))
-      end
-    end
-    describe "budget list item" do
-      let!(:component) do
-        create(:budgets_component,
-               :with_vote_threshold_percent,
-               manifest: manifest,
-               participatory_space: participatory_process,
-               settings: { landing_page_content: description })
-      end
-      let(:description) { { en: "Short description", ca: "Descripci curta", es: "Descripcin corta" } }
-      let(:budget) { budgets.first }
-      let(:item) { page.find(".budget-list .card--list__item:first-child", match: :first) }
-      let!(:projects) { create_list(:project, 3, budget: budget, budget_amount: 10_000_000) }
-      before do
-        login_as user, scope: :user
-      end
-      it_behaves_like "has embedded video in description", :description
-      it "has a clickable title" do
-        expect(item).to have_link(translated(budget.title), href: budget_path(budget))
-      end
-      context "when an item is bookmarked" do
-        let!(:order) { create(:order, user: user, budget: budget) }
-        let!(:line_item) { create(:line_item, order: order, project: projects.first) }
-        it "shows the bookmark icon" do
-          visit_component
-          expect(item).to have_selector(".budget-list__icon .icon--bookmark")
-          expect(item).to have_link("Finish voting", href: budget_path(budget))
-        end
-      end
-      context "when an item is voted" do
-        let(:item) { page.find("#voted-budgets .card--list__item:first-child") }
-        let!(:order) do
-          order = create(:order, user: user, budget: budget)
-          order.projects = [projects.first]
-          order.checked_out_at = Time.current
-          order.save!
-          order
-        end
-        it "shows the check icon" do
-          visit_component
-          expect(item).to have_selector(".budget-list__icon .icon--check")
-          expect(item).to have_link("See projects", href: budget_path(budget))
-        end
-      end
-    end
-  end
-  context "when directly accessing from URL with an invalid budget id" do
-    it_behaves_like "a 404 page" do
-      let(:target_path) { Decidim::EngineRouter.main_proxy(component).budget_path(99_999_999) }
-    end
-  end
-  def budget_path(budget)
-    Decidim::EngineRouter.main_proxy(component).budget_path(budget.id)
-  end
-end

--- a/decidim-budgets/spec/system/explore_projects_spec.rb
+++ b//dev/null
@@ -1,144 +0,0 @@
-require "spec_helper"
-describe "Explore projects", :slow, type: :system do
-  include_context "with a component"
-  let(:manifest_name) { "budgets" }
-  let(:budget) { create :budget, component: component }
-  let(:projects_count) { 5 }
-  let!(:projects) do
-    create_list(:project, projects_count, budget: budget)
-  end
-  let!(:project) { projects.first }
-  let(:categories) { create_list(:category, 3, participatory_space: component.participatory_space) }
-  describe "show" do
-    let(:description) { { en: "Short description", ca: "Descripci curta", es: "Descripcin corta" } }
-    let(:project) { create(:project, budget: budget, description: description) }
-    before do
-      visit_budget
-      click_link translated(project.title)
-    end
-    it_behaves_like "has embedded video in description", :description
-  end
-  describe "index" do
-    it "shows all resources for the given component" do
-      visit_budget
-      within "#projects" do
-        expect(page).to have_selector(".budget-list__item", count: projects_count)
-      end
-      projects.each do |project|
-        expect(page).to have_content(translated(project.title))
-      end
-    end
-    context "when filtering" do
-      it "allows searching by text" do
-        visit_budget
-        within ".filters__search" do
-          fill_in "filter[search_text_cont]", with: translated(project.title)
-          find(".button").click
-        end
-        within "#projects" do
-          expect(page).to have_css(".budget-list__item", count: 1)
-          expect(page).to have_content(translated(project.title))
-        end
-      end
-      it "updates the current URL with the text filter" do
-        create(:project, budget: budget, title: { en: "Foobar project" })
-        create(:project, budget: budget, title: { en: "Another project" })
-        visit_budget
-        within "form.new_filter" do
-          fill_in("filter[search_text_cont]", with: "foobar")
-          click_button "Search"
-        end
-        expect(page).not_to have_content("Another project")
-        expect(page).to have_content("Foobar project")
-        filter_params = CGI.parse(URI.parse(page.current_url).query)
-        expect(filter_params["filter[search_text_cont]"]).to eq(["foobar"])
-      end
-      it "allows filtering by scope" do
-        scope = create(:scope, organization: organization)
-        project.scope = scope
-        project.save
-        visit_budget
-        within ".with_any_scope_check_boxes_tree_filter" do
-          uncheck "All"
-          check translated(scope.name)
-        end
-        within "#projects" do
-          expect(page).to have_css(".budget-list__item", count: 1)
-          expect(page).to have_content(translated(project.title))
-        end
-      end
-      it "allows filtering by category" do
-        category = categories.first
-        project.category = category
-        project.save
-        visit_budget
-        within ".with_any_category_check_boxes_tree_filter" do
-          uncheck "All"
-          check translated(category.name)
-        end
-        within "#projects" do
-          expect(page).to have_css(".budget-list__item", count: 1)
-          expect(page).to have_content(translated(project.title))
-        end
-      end
-      it "works with 'back to list' link" do
-        category = categories.first
-        project.category = category
-        project.save
-        visit_budget
-        within ".with_any_category_check_boxes_tree_filter" do
-          uncheck "All"
-          check translated(category.name)
-        end
-        within "#projects" do
-          expect(page).to have_css(".budget-list__item", count: 1)
-          expect(page).to have_content(translated(project.title))
-        end
-        page.find(".budget-list__item .card__link", match: :first).click
-        click_link "View all projects"
-        take_screenshot
-        within "#projects" do
-          expect(page).to have_css(".budget-list__item", count: 1)
-          expect(page).to have_content(translated(project.title))
-        end
-      end
-      context "and votes are finished" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_voting_finished,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "allows filtering by status" do
-          project.selected_at = Time.current
-          project.save
-          visit_budget
-          within ".with_any_status_check_boxes_tree_filter" do
-            uncheck "Selected"
-          end
-          within "#projects" do
-            expect(page).to have_css(".budget-list__item", count: 1)
-            expect(page).to have_content(translated(project.title))
-          end
-        end
-      end
-    end
-    context "when directly accessing from URL with an invalid budget id" do
-      it_behaves_like "a 404 page" do
-        let(:target_path) { decidim_budgets.budget_projects_path(99_999_999) }
-      end
-    end
-    context "when directly accessing from URL with an invalid project id" do
-      it_behaves_like "a 404 page" do
-        let(:target_path) { decidim_budgets.budget_project_path(budget, 99_999_999) }
-      end
-    end
-  end
-  private
-  def decidim_budgets
-    Decidim::EngineRouter.main_proxy(component)
-  end
-  def visit_budget
-    page.visit decidim_budgets.budget_projects_path(budget)
-  end
-end

--- a/decidim-budgets/spec/system/orders_spec.rb
+++ b//dev/null
@@ -1,553 +0,0 @@
-require "spec_helper"
-describe "Orders", type: :system do
-  include_context "with a component"
-  let(:manifest_name) { "budgets" }
-  let(:organization) { create :organization, available_authorizations: %w(dummy_authorization_handler) }
-  let!(:user) { create :user, :confirmed, organization: organization }
-  let(:project) { projects.first }
-  let!(:component) do
-    create(:budgets_component,
-           :with_vote_threshold_percent,
-           manifest: manifest,
-           participatory_space: participatory_process)
-  end
-  let(:budget) { create :budget, component: component }
-  context "when the user is not logged in" do
-    let!(:projects) { create_list(:project, 1, budget: budget, budget_amount: 25_000_000) }
-    it "is given the option to sign in" do
-      visit_budget
-      within "#project-#{project.id}-item" do
-        page.find(".budget-list__action").click
-      end
-      expect(page).to have_css("#loginModal", visible: :visible)
-    end
-  end
-  context "when the user is logged in" do
-    let!(:projects) { create_list(:project, 3, budget: budget, budget_amount: 25_000_000) }
-    before do
-      login_as user, scope: :user
-    end
-    context "when visiting budget" do
-      before do
-        visit_budget
-      end
-      context "when voting by percentage threshold" do
-        it "displays description messages" do
-          within ".budget-summary" do
-            expect(page).to have_content("You decide the budget\nWhat projects do you think we should allocate budget for? Assign at least 70,000,000 to the projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-        it "displays rules" do
-          within ".voting-rules" do
-            expect(page).to have_content("Assign at least 70,000,000 to the projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-      end
-      context "when voting by minimum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_minimum_budget_projects,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "displays description messages" do
-          within ".budget-summary" do
-            expect(page).to have_content("What projects do you think we should allocate budget for? Select at least 3 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-        it "displays rules" do
-          within ".voting-rules" do
-            expect(page).to have_content("Select at least 3 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-      end
-      context "when voting by maximum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_budget_projects_range,
-                 vote_minimum_budget_projects_number: 0,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "displays description messages" do
-          within ".budget-summary" do
-            expect(page).to have_content("What projects do you think we should allocate budget for? Select up to 6 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-        it "displays rules" do
-          within ".voting-rules" do
-            expect(page).to have_content("Select up to 6 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-      end
-      context "when voting by minimum and maximum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_budget_projects_range,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "displays description messages" do
-          within ".budget-summary" do
-            expect(page).to have_content("What projects do you think we should allocate budget for? Select at least 3 and up to 6 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-        it "displays rules" do
-          within ".voting-rules" do
-            expect(page).to have_content("Select at least 3 and up to 6 projects you want and vote according to your preferences to define the budget.")
-          end
-        end
-      end
-    end
-    context "and has not a pending order" do
-      before do
-        visit_budget
-      end
-      context "when voting by percentage threshold" do
-        it "adds a project to the current order" do
-          within "#project-#{project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_selector ".budget-list__data--added", count: 1
-          expect(page).to have_content "ASSIGNED: 25,000,000"
-          expect(page).to have_content "1 project selected"
-          within ".budget-summary__selected" do
-            expect(page).to have_selector(".budget-summary__selected-item", text: project.title[I18n.locale.to_s], visible: :hidden)
-          end
-          within "#order-progress .budget-summary__progressbox" do
-            expect(page).to have_content "25%"
-            expect(page).to have_selector("button.small:disabled")
-          end
-        end
-        it "displays total budget" do
-          within ".budget-summary__total" do
-            expect(page).to have_content("TOTAL BUDGET 100,000,000")
-          end
-        end
-      end
-      context "when voting by minimum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_minimum_budget_projects,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "adds a project to the current order" do
-          within "#project-#{project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_selector ".budget-list__data--added", count: 1
-          expect(page).to have_content "ASSIGNED: 25,000,000"
-          expect(page).to have_content "1 project selected"
-          within ".budget-summary__selected" do
-            expect(page).to have_selector(".budget-summary__selected-item", text: project.title[I18n.locale.to_s], visible: :hidden)
-          end
-          within "#order-progress .budget-summary__progressbox" do
-            expect(page).to have_content "25%"
-            expect(page).to have_selector("button.small:disabled")
-          end
-        end
-        it "displays total budget" do
-          within ".budget-summary__total" do
-            expect(page).to have_content("TOTAL BUDGET 100,000,000")
-          end
-        end
-      end
-      context "when voting by maximum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_budget_projects_range,
-                 vote_minimum_budget_projects_number: 0,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "adds a project to the current order" do
-          within "#project-#{project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_selector ".budget-list__data--added", count: 1
-          expect(page).to have_content "ASSIGNED: 1 / 6"
-          expect(page).to have_content "1 project selected"
-          within ".budget-summary__selected" do
-            expect(page).to have_selector(".budget-summary__selected-item", text: project.title[I18n.locale.to_s], visible: :hidden)
-          end
-          within "#order-progress .budget-summary__progressbox" do
-            expect(page).to have_content "16%"
-            expect(page).to have_selector("button.small")
-          end
-        end
-        it "displays total budget" do
-          within ".budget-summary__total" do
-            expect(page).to have_content("TOTAL VOTES 6")
-          end
-        end
-      end
-      context "when voting by minimum and maximum projects number" do
-        let!(:component) do
-          create(:budgets_component,
-                 :with_budget_projects_range,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        it "adds a project to the current order" do
-          within "#project-#{project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_selector ".budget-list__data--added", count: 1
-          expect(page).to have_content "ASSIGNED: 1 / 6"
-          expect(page).to have_content "1 project selected"
-          within ".budget-summary__selected" do
-            expect(page).to have_selector(".budget-summary__selected-item", text: project.title[I18n.locale.to_s], visible: :hidden)
-          end
-          within "#order-progress .budget-summary__progressbox" do
-            expect(page).to have_content "16%"
-            expect(page).to have_selector("button.small")
-          end
-        end
-        it "displays total budget" do
-          within ".budget-summary__total" do
-            expect(page).to have_content("TOTAL VOTES 6")
-          end
-        end
-      end
-    end
-    context "and isn't authorized" do
-      before do
-        permissions = {
-          vote: {
-            authorization_handlers: {
-              "dummy_authorization_handler" => {}
-            }
-          }
-        }
-        component.update!(permissions: permissions)
-      end
-      it "shows a modal dialog" do
-        visit_budget
-        within "#project-#{project.id}-item" do
-          page.find(".budget-list__action").click
-        end
-        expect(page).to have_content("Authorization required")
-      end
-    end
-    context "and has pending order" do
-      let!(:order) { create(:order, user: user, budget: budget) }
-      let!(:line_item) { create(:line_item, order: order, project: project) }
-      it "removes a project from the current order" do
-        visit_budget
-        expect(page).to have_content "ASSIGNED: 25,000,000"
-        within "#project-#{project.id}-item" do
-          page.find(".budget-list__action").click
-        end
-        expect(page).to have_content "ASSIGNED: 0"
-        expect(page).to have_no_content "1 project selected"
-        expect(page).to have_no_selector ".budget-summary__selected"
-        within "#order-progress .budget-summary__progressbox" do
-          expect(page).to have_content "0%"
-        end
-        expect(page).to have_no_selector ".budget-list__data--added"
-      end
-      it "is alerted when trying to leave the component before completing" do
-        budget_projects_path = Decidim::EngineRouter.main_proxy(component).budget_projects_path(budget)
-        visit_budget
-        expect(page).to have_content "ASSIGNED: 25,000,000"
-        page.find(".logo-wrapper a").click
-        expect(page).to have_content "You have not yet voted"
-        click_button "Return to voting"
-        expect(page).not_to have_content("You have not yet voted")
-        expect(page).to have_current_path budget_projects_path
-      end
-      it "is alerted but can sign out before completing" do
-        visit_budget
-        page.find("#user-menu-control").click
-        page.find(".sign-out-link").click
-        expect(page).to have_content "You have not yet voted"
-        page.find("#exit-notification-link").click
-        expect(page).to have_content("Signed out successfully")
-      end
-      context "and try to vote a project that exceed the total budget" do
-        let!(:expensive_project) { create(:project, budget: budget, budget_amount: 250_000_000) }
-        it "cannot add the project" do
-          visit_budget
-          within "#project-#{expensive_project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_css("#budget-excess", visible: :visible)
-        end
-      end
-      context "and in project show page cant exceed the budget" do
-        let!(:expensive_project) { create(:project, budget: budget, budget_amount: 250_000_000) }
-        it "cannot add the project" do
-          page.visit Decidim::EngineRouter.main_proxy(component).budget_project_path(budget, expensive_project)
-          within "#project-#{expensive_project.id}-budget-button" do
-            page.find("button").click
-          end
-          expect(page).to have_css("#budget-excess", visible: :visible)
-        end
-      end
-      context "and add another project exceeding vote threshold" do
-        let!(:other_project) { create(:project, budget: budget, budget_amount: 50_000_000) }
-        it "can complete the checkout process" do
-          visit_budget
-          within "#project-#{other_project.id}-item" do
-            page.find(".budget-list__action").click
-          end
-          expect(page).to have_selector ".budget-list__data--added", count: 2
-          within "#order-progress .budget-summary__progressbox:not(.budget-summary__progressbox--fixed)" do
-            page.find(".button.small").click
-          end
-          expect(page).to have_css("#budget-confirm", visible: :visible)
-          within "#budget-confirm" do
-            page.find(".button.expanded").click
-          end
-          expect(page).to have_content("successfully")
-          within "#order-progress .budget-summary__progressbox" do
-            expect(page).to have_no_selector("button.small")
-          end
-        end
-      end
-      context "when the voting rule is set to threshold percent" do
-        before do
-          visit_budget
-        end
-        it "shows the rule description" do
-          within ".card.budget-summary" do
-            expect(page).to have_content("Assign at least 70,000,000 to the projects you want and vote")
-          end
-        end
-        context "when the order total budget doesn't exceed the threshold" do
-          it "cannot vote" do
-            within "#order-progress" do
-              expect(page).to have_button("Vote", disabled: true)
-            end
-          end
-        end
-        context "when the order total budget exceeds the threshold" do
-          let(:projects) { create_list(:project, 2, budget: budget, budget_amount: 36_000_000) }
-          let(:order_percent) { create(:order, user: user, budget: budget) }
-          before do
-            order.destroy!
-            order_percent.projects << projects
-            order_percent.save!
-            visit_budget
-          end
-          it "can vote" do
-            within "#order-progress" do
-              expect(page).to have_button("Vote", disabled: false)
-            end
-          end
-          context "when user has voted" do
-            let(:router) { Decidim::EngineRouter.main_proxy(component) }
-            let(:another_user) { create(:user, :confirmed, organization: organization) }
-            before do
-              find("[data-toggle='budget-confirm']").click
-              click_button "Confirm"
-              expect(page).to have_css(".flash.success")
-            end
-            it "shows private-only activity log entry" do
-              page.visit decidim.profile_activity_path(nickname: user.nickname)
-              expect(page).to have_content("New budgeting vote at #{translated(budget.participatory_space.title)}")
-              expect(page).to have_link(translated(budget.title), href: router.budget_path(budget))
-            end
-            it "does not show activity log entry to another user" do
-              relogin_as another_user, scope: :user
-              page.visit decidim.profile_activity_path(nickname: user.nickname)
-              expect(page).to have_content(user.name)
-              expect(page).to have_current_path "/profiles/#{user.nickname}/activity"
-              expect(page).not_to have_content("New budgeting vote at")
-              expect(page).not_to have_link(translated(budget.title))
-            end
-          end
-        end
-      end
-      context "when the voting rule is set to minimum projects" do
-        before do
-          order.destroy!
-        end
-        let(:component) do
-          create(:budgets_component,
-                 :with_minimum_budget_projects,
-                 manifest: manifest,
-                 participatory_space: participatory_process)
-        end
-        let!(:order_min) { create(:order, user: user, budget: budget) }
-        it "shows the rule description" do
-          visit_budget
-          within ".card.budget-summary" do
-            expect(page).to have_content("Select at least 3 projects you want and vote")
-          end
-        end
-        context "when the order total budget doesn't reach the minimum" do
-          it "cannot vote" do
-            visit_budget
-            within "#order-progress" do
-              expect(page).to have_button("Vote", disabled: true)
-            end
-          end
-        end
-        context "when the order total budget exceeds the minimum" do
-          before do
-            order_min.projects = projects
-            order_min.save!
-          end
-          it "can vote" do
-            visit_budget
-            within "#order-progress" do
-              expect(page).to have_button("Vote", disabled: false)
-            end
-          end
-        end
-      end
-    end
-    context "and has a finished order" do
-      let!(:order) do
-        order = create(:order, user: user, budget: budget)
-        order.projects = projects
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      it "can cancel the order" do
-        visit_budget
-        within ".budget-summary" do
-          accept_confirm { page.find(".cancel-order").click }
-        end
-        expect(page).to have_content("successfully")
-        within "#order-progress .budget-summary__progressbox" do
-          expect(page).to have_selector("button.small:disabled")
-        end
-        within ".budget-summary" do
-          expect(page).to have_no_selector(".cancel-order")
-        end
-      end
-      it "is not alerted when trying to leave the component" do
-        visit_budget
-        expect(page).to have_content("Budget vote completed")
-        page.find(".logo-wrapper a").click
-        expect(page).to have_current_path decidim.root_path
-      end
-    end
-    context "and votes are disabled" do
-      let!(:component) do
-        create(:budgets_component,
-               :with_votes_disabled,
-               manifest: manifest,
-               participatory_space: participatory_process)
-      end
-      it "cannot create new orders" do
-        visit_budget
-        expect(page).to have_no_selector("button.budget-list__action")
-      end
-    end
-    context "and show votes are enabled" do
-      let!(:component) do
-        create(:budgets_component,
-               :with_show_votes_enabled,
-               manifest: manifest,
-               participatory_space: participatory_process)
-      end
-      let!(:order) do
-        order = create(:order, user: user, budget: budget)
-        order.projects = projects
-        order.checked_out_at = Time.current
-        order.save!
-        order
-      end
-      it "displays the number of votes for a project" do
-        visit_budget
-        within "#project-#{project.id}-item .budget-list__number" do
-          expect(page).to have_selector(".project-votes", text: "1 VOTE")
-        end
-      end
-    end
-    context "and votes are finished" do
-      let!(:component) do
-        create(:budgets_component,
-               :with_voting_finished,
-               manifest: manifest,
-               participatory_space: participatory_process)
-      end
-      let!(:projects) { create_list(:project, 2, :selected, budget: budget, budget_amount: 25_000_000) }
-      it "renders selected projects" do
-        visit_budget
-        expect(page).to have_selector(".card__text--status.success", count: 2)
-      end
-    end
-  end
-  describe "index" do
-    it "respects the projects_per_page setting when under total projects" do
-      component.update!(settings: { projects_per_page: 1 })
-      create_list(:project, 2, budget: budget)
-      visit_budget
-      expect(page).to have_selector("div[id^=project-]", count: 1)
-    end
-    it "respects the projects_per_page setting when it matches total projects" do
-      component.update!(settings: { projects_per_page: 2 })
-      create_list(:project, 2, budget: budget)
-      visit_budget
-      expect(page).to have_selector("div[id^=project-]", count: 2)
-    end
-    it "respects the projects_per_page setting when over total projects" do
-      component.update!(settings: { projects_per_page: 3 })
-      create_list(:project, 2, budget: budget)
-      visit_budget
-      expect(page).to have_selector("div[id^=project-]", count: 2)
-    end
-  end
-  describe "show" do
-    let!(:project) { create(:project, budget: budget, budget_amount: 25_000_000) }
-    before do
-      visit resource_locator([budget, project]).path
-    end
-    it_behaves_like "has attachments" do
-      let(:attached_to) { project }
-    end
-    it "shows the component" do
-      expect(page).to have_i18n_content(project.title)
-      expect(page).to have_i18n_content(project.description)
-    end
-    context "with linked proposals" do
-      let(:proposal_component) do
-        create(:component, manifest_name: :proposals, participatory_space: project.component.participatory_space)
-      end
-      let(:proposals) { create_list(:proposal, 3, component: proposal_component) }
-      before do
-        project.link_resources(proposals, "included_proposals")
-      end
-      it "shows related proposals" do
-        visit_budget
-        click_link translated(project.title)
-        proposals.each do |proposal|
-          expect(page).to have_content(translated(proposal.title))
-          expect(page).to have_content(proposal.creator_author.name)
-          expect(page).to have_content(proposal.votes.size)
-        end
-      end
-      context "with supports enabled" do
-        let(:proposal_component) do
-          create(:proposal_component, :with_votes_enabled, participatory_space: project.component.participatory_space)
-        end
-        let(:proposals) { create_list(:proposal, 1, :with_votes, component: proposal_component) }
-        it "shows the amount of supports" do
-          visit_budget
-          click_link translated(project.title)
-          expect(page.find('span[class="card--list__data__number"]')).to have_content("5")
-        end
-      end
-      context "with supports disabled" do
-        let(:proposal_component) do
-          create(:proposal_component, participatory_space: project.component.participatory_space)
-        end
-        let(:proposals) { create_list(:proposal, 1, :with_votes, component: proposal_component) }
-        it "does not show supports" do
-          visit_budget
-          click_link translated(project.title)
-          expect(page).not_to have_selector('span[class="card--list__data__number"]')
-        end
-      end
-    end
-  end
-  def visit_budget
-    page.visit Decidim::EngineRouter.main_proxy(component).budget_projects_path(budget)
-  end
-end

--- a/decidim-comments/app/controllers/decidim/comments/comments_controller.rb
+++ b//dev/null
@@ -1,155 +0,0 @@
-module Decidim
-  module Comments
-    class CommentsController < Decidim::Comments::ApplicationController
-      include Decidim::ResourceHelper
-      include Decidim::SkipTimeoutable
-      prepend_before_action :skip_timeout, only: :index
-      before_action :authenticate_user!, only: [:create]
-      before_action :set_commentable, except: [:destroy, :update]
-      before_action :ensure_commentable!, except: [:destroy, :update]
-      helper_method :root_depth, :commentable, :order, :reply?, :reload?, :root_comment
-      def index
-        enforce_permission_to :read, :comment, commentable: commentable
-        @comments = SortedComments.for(
-          commentable,
-          order_by: order,
-          after: params.fetch(:after, 0).to_i
-        )
-        @comments = @comments.reject do |comment|
-          next if comment.depth < 1
-          next if !comment.deleted? && !comment.hidden?
-          comment.commentable.descendants.where(decidim_commentable_type: "Decidim::Comments::Comment").not_hidden.not_deleted.blank?
-        end
-        @comments_count = commentable.comments_count
-        respond_to do |format|
-          format.js do
-            if reload?
-              render :reload
-            else
-              render :index
-            end
-          end
-          format.html { redirect_to commentable_path }
-        end
-      end
-      def update
-        set_comment
-        enforce_permission_to :update, :comment, comment: comment
-        form = Decidim::Comments::CommentForm.from_params(
-          params.merge(commentable: comment.commentable)
-        ).with_context(
-          current_organization: current_organization
-        )
-        Decidim::Comments::UpdateComment.call(comment, current_user, form) do
-          on(:ok) do
-            respond_to do |format|
-              format.js { render :update }
-            end
-          end
-          on(:invalid) do
-            respond_to do |format|
-              format.js { render :update_error }
-            end
-          end
-        end
-      end
-      def create
-        enforce_permission_to :create, :comment, commentable: commentable
-        form = Decidim::Comments::CommentForm.from_params(
-          params.merge(commentable: commentable)
-        ).with_context(
-          current_organization: current_organization,
-          current_component: current_component
-        )
-        Decidim::Comments::CreateComment.call(form, current_user) do
-          on(:ok) do |comment|
-            handle_success(comment)
-            respond_to do |format|
-              format.js { render :create }
-            end
-          end
-          on(:invalid) do
-            @error = t("create.error", scope: "decidim.comments.comments")
-            respond_to do |format|
-              format.js { render :error }
-            end
-          end
-        end
-      end
-      def current_component
-        return commentable.component if commentable.respond_to?(:component)
-        return commentable.participatory_space if commentable.respond_to?(:participatory_space)
-        return commentable if Decidim.participatory_space_manifests.find { |manifest| manifest.model_class_name == commentable.class.name }
-      end
-      def destroy
-        set_comment
-        @commentable = @comment.commentable
-        enforce_permission_to :destroy, :comment, comment: comment
-        Decidim::Comments::DeleteComment.call(comment, current_user) do
-          on(:ok) do
-            @comments_count = @comment.root_commentable.comments_count
-            respond_to do |format|
-              format.js { render :delete }
-            end
-          end
-          on(:invalid) do
-            respond_to do |format|
-              format.js { render :deletion_error }
-            end
-          end
-        end
-      end
-      private
-      attr_reader :commentable, :comment
-      def set_commentable
-        @commentable = GlobalID::Locator.locate_signed(commentable_gid)
-      end
-      def set_comment
-        @comment = Decidim::Comments::Comment.find_by(id: params[:id])
-      end
-      def ensure_commentable!
-        raise ActionController::RoutingError, "Not Found" unless commentable
-      end
-      def handle_success(comment)
-        @comment = comment.reload
-        @comments_count = case commentable
-                          when Decidim::Comments::Comment
-                            commentable.root_commentable.comments_count
-                          else
-                            commentable.comments_count
-                          end
-      end
-      def root_comment
-        @root_comment ||= begin
-          root_comment = comment
-          root_comment = root_comment.commentable while root_comment.commentable.is_a?(Decidim::Comments::Comment)
-          root_comment
-        end
-      end
-      def commentable_gid
-        case action_name
-        when "create"
-          params.require(:comment).fetch(:commentable_gid)
-        else
-          params.fetch(:commentable_gid, nil)
-        end
-      end
-      def reply?(comment)
-        comment.root_commentable != comment.commentable
-      end
-      def order
-        params.fetch(:order, "older")
-      end
-      def reload?
-        params.fetch(:reload, 0).to_i == 1
-      end
-      def root_depth
-        params.fetch(:root_depth, 0).to_i
-      end
-      def commentable_path
-        return commentable.polymorphic_resource_path({}) if commentable.respond_to?(:polymorphic_resource_path)
-        resource_locator(commentable).path
-      end
-    end
-  end
-end

--- a/decidim-comments/lib/decidim/comments/export.rb
+++ b//dev/null
@@ -1,14 +0,0 @@
-module Decidim
-  module Comments
-    module Export
-      def comments_for_resource(resource_class, component)
-        Comment
-          .where(decidim_root_commentable_id: resource_class.where(component: component))
-          .not_deleted
-          .not_hidden
-          .where(decidim_root_commentable_type: resource_class.to_s)
-      end
-      module_function :comments_for_resource
-    end
-  end
-end

--- a/decidim-comments/lib/decidim/comments/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Comments
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-comments/spec/lib/decidim/comments/export_spec.rb
+++ b//dev/null
@@ -1,30 +0,0 @@
-require "spec_helper"
-module Decidim
-  module Comments
-    describe Export do
-      subject { described_class }
-      let!(:component) { create(:component, manifest_name: "dummy") }
-      let!(:dummy_resources) { create_list(:dummy_resource, 2, component: component) }
-      let!(:comments) { create_list(:comment, 5, commentable: dummy_resources[1], root_commentable: dummy_resources[1]) }
-      let!(:other_comments) { create_list(:comment, 5) }
-      let!(:deleted_comment) { create(:comment, :deleted, commentable: dummy_resources[1], root_commentable: dummy_resources[1]) }
-      let!(:hidden_comment) { create(:comment, :deleted, commentable: dummy_resources[1], root_commentable: dummy_resources[1]) }
-      let!(:moderation) { create(:moderation, hidden_at: 6.hours.ago, reportable: hidden_comment) }
-      describe "#comments_for_resource" do
-        let(:collection) { subject.comments_for_resource(Decidim::DummyResources::DummyResource, component) }
-        it "returns a collection of comments" do
-          expect(collection).to include(*comments)
-        end
-        it "excludes other comments" do
-          expect(collection).not_to include(*other_comments)
-        end
-        it "excludes deleted comments" do
-          expect(collection).not_to include(deleted_comment)
-        end
-        it "excludes hidden comments" do
-          expect(collection).not_to include(hidden_comment)
-        end
-      end
-    end
-  end
-end

--- a/decidim-conferences/lib/decidim/conferences/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Conferences
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-conferences/spec/shared/manage_conferences_examples.rb
+++ b//dev/null
@@ -1,180 +0,0 @@
-shared_examples "manage conferences" do
-  describe "creating a conference" do
-    let(:image1_filename) { "city.jpeg" }
-    let(:image1_path) { Decidim::Dev.asset(image1_filename) }
-    let(:image2_filename) { "city2.jpeg" }
-    let(:image2_path) { Decidim::Dev.asset(image2_filename) }
-    before do
-      click_link "New Conference"
-    end
-    %w(description short_description objectives).each do |field|
-      it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='conference-#{field}-tabs']", "full"
-    end
-    it_behaves_like "having a rich text editor for field", "#conference_registrations_terms", "content"
-    it "creates a new conference" do
-      within ".new_conference" do
-        fill_in_i18n(
-          :conference_title,
-          "#conference-title-tabs",
-          en: "My conference",
-          es: "Mi proceso participativo",
-          ca: "El meu procs participatiu"
-        )
-        fill_in_i18n(
-          :conference_slogan,
-          "#conference-slogan-tabs",
-          en: "Slogan",
-          es: "Eslogan",
-          ca: "Eslgan"
-        )
-        fill_in_i18n_editor(
-          :conference_short_description,
-          "#conference-short_description-tabs",
-          en: "Short description",
-          es: "Descripcin corta",
-          ca: "Descripci curta"
-        )
-        fill_in_i18n_editor(
-          :conference_description,
-          "#conference-description-tabs",
-          en: "A longer description",
-          es: "Descripcin ms larga",
-          ca: "Descripci ms llarga"
-        )
-        fill_in :conference_slug, with: "slug"
-        fill_in :conference_hashtag, with: "#hashtag"
-      end
-      dynamically_attach_file(:conference_hero_image, image1_path)
-      dynamically_attach_file(:conference_banner_image, image2_path)
-      within ".new_conference" do
-        fill_in :conference_start_date, with: 1.month.ago
-        fill_in :conference_end_date, with: 1.month.ago + 3.days
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_current_path decidim_admin_conferences.conferences_path
-        expect(page).to have_content("My conference")
-      end
-    end
-  end
-  describe "updating a conference" do
-    let(:image3_filename) { "city3.jpeg" }
-    let(:image3_path) { Decidim::Dev.asset(image3_filename) }
-    before do
-      click_link translated(conference.title)
-    end
-    it "updates a conference" do
-      fill_in_i18n(
-        :conference_title,
-        "#conference-title-tabs",
-        en: "My new title",
-        es: "Mi nuevo ttulo",
-        ca: "El meu nou ttol"
-      )
-      dynamically_attach_file(:conference_banner_image, image3_path, remove_before: true)
-      within ".edit_conference" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_selector("input[value='My new title']")
-        expect(page).to have_css("img[src*='#{image3_filename}']")
-      end
-    end
-  end
-  describe "updating an conference without images" do
-    before do
-      click_link translated(conference.title)
-    end
-    %w(description short_description objectives).each do |field|
-      it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='conference-#{field}-tabs']", "full"
-    end
-    it_behaves_like "having a rich text editor for field", "#conference_registrations_terms", "content"
-    it "update an conference without images does not delete them" do
-      click_submenu_link "Info"
-      click_button "Update"
-      expect(page).to have_admin_callout("successfully")
-      expect(page).to have_css("img[src*='#{conference.attached_uploader(:hero_image).path}']")
-      expect(page).to have_css("img[src*='#{conference.attached_uploader(:banner_image).path}']")
-    end
-  end
-  describe "previewing conferences" do
-    context "when the conference is unpublished" do
-      let!(:conference) { create(:conference, :unpublished, organization: organization) }
-      it "allows the user to preview the unpublished conference" do
-        within find("tr", text: translated(conference.title)) do
-          click_link "Preview"
-        end
-        expect(page).to have_content(translated(conference.title))
-      end
-    end
-    context "when the conference is published" do
-      let!(:conference) { create(:conference, organization: organization) }
-      it "allows the user to preview the unpublished conference" do
-        within find("tr", text: translated(conference.title)) do
-          click_link "Preview"
-        end
-        expect(page).to have_current_path decidim_conferences.conference_path(conference)
-        expect(page).to have_content(translated(conference.title))
-      end
-    end
-  end
-  describe "viewing a missing conference" do
-    it_behaves_like "a 404 page" do
-      let(:target_path) { decidim_admin_conferences.conference_path(99_999_999) }
-    end
-  end
-  describe "publishing a conference" do
-    let!(:conference) { create(:conference, :unpublished, organization: organization) }
-    before do
-      click_link translated(conference.title)
-    end
-    it "publishes the conference" do
-      click_link "Publish"
-      expect(page).to have_content("successfully published")
-      expect(page).to have_content("Unpublish")
-      expect(page).to have_current_path decidim_admin_conferences.edit_conference_path(conference)
-      conference.reload
-      expect(conference).to be_published
-    end
-  end
-  describe "unpublishing a conference" do
-    let!(:conference) { create(:conference, organization: organization) }
-    before do
-      click_link translated(conference.title)
-    end
-    it "unpublishes the conference" do
-      click_link "Unpublish"
-      expect(page).to have_content("successfully unpublished")
-      expect(page).to have_content("Publish")
-      expect(page).to have_current_path decidim_admin_conferences.edit_conference_path(conference)
-      conference.reload
-      expect(conference).not_to be_published
-    end
-  end
-  context "when there are multiple organizations in the system" do
-    let!(:external_conference) { create(:conference) }
-    it "doesn't let the admin manage conferences form other organizations" do
-      within "table" do
-        expect(page).not_to have_content(external_conference.title["en"])
-      end
-    end
-  end
-  context "when the conference has a scope" do
-    let(:scope) { create(:scope, organization: organization) }
-    before do
-      conference.update!(scopes_enabled: true, scope: scope)
-    end
-    it "disables the scope for the conference" do
-      click_link translated(conference.title)
-      uncheck :conference_scopes_enabled
-      expect(page).to have_selector("#conference_scope_id.disabled")
-      expect(page).to have_selector("#conference_scope_id .picker-values div input[disabled]", visible: :all)
-      within ".edit_conference" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-    end
-  end
-end

--- a/decidim-consultations/app/cells/decidim/consultations/consultation_m_cell.rb
+++ b//dev/null
@@ -1,64 +0,0 @@
-module Decidim
-  module Consultations
-    class ConsultationMCell < Decidim::CardMCell
-      private
-      def has_state?
-        true
-      end
-      def state_classes
-        state_data[:state_classes]
-      end
-      def has_badge?
-        false
-      end
-      def badge_name
-        text = state_data[:badge_name]
-        return unless text
-        I18n.t(text, scope: "decidim.consultations.show.badge_name")
-      end
-      def description
-        render(:badge) + truncate(strip_tags(super), length: 100)
-      end
-      def resource_path
-        Decidim::Consultations::Engine.routes.url_helpers.consultation_path(model)
-      end
-      def resource_image_path
-        model.attached_uploader(:banner_image).path
-      end
-      def has_image?
-        true
-      end
-      def start_date
-        model.start_voting_date
-      end
-      def end_date
-        model.end_voting_date
-      end
-      def statuses
-        super << :questions_count
-      end
-      def questions_count_status
-        content_tag(
-          :strong,
-          t("activemodel.attributes.consultation.questions")
-        ) + " " + model.questions.count.to_s
-      end
-      def footer_button_text
-        state_data[:button_text]
-      end
-      def state_data
-        @state_data ||= if model.active?
-                          { state: :active, badge_name: "open_votes", state_classes: ["success"], button_text: "vote" }
-                        elsif model.upcoming?
-                          { state: :upcoming, badge_name: "open", state_classes: ["warning"], button_text: "debate" }
-                        elsif model.finished?
-                          { state: :finished, badge_name: "finished", state_classes: ["muted"], button_text: "view" }
-                        elsif model.published_results?
-                          { state: :published_results, badge_name: "published_results", state_classes: ["muted"], button_text: "view_results" }
-                        else
-                          { state: :undefined, badge_name: nil, state_classes: ["muted"], button_text: "view" }
-                        end
-      end
-    end
-  end
-end

--- a/decidim-consultations/app/scrubbers/decidim/consultations/question_title_scrubber.rb
+++ b//dev/null
@@ -1,13 +0,0 @@
-module Decidim
-  module Consultations
-    class QuestionTitleScrubber < Decidim::UserInputScrubber
-      private
-      def custom_allowed_tags
-        %w(strong em u b i br ul ol li p a code)
-      end
-      def custom_allowed_attributes
-        %w(class href target rel)
-      end
-    end
-  end
-end

--- a/decidim-consultations/lib/decidim/consultations/version.rb
+++ b//dev/null
@@ -1,7 +0,0 @@
-module Decidim
-  module Consultations
-    def self.version
-      "0.27.3"
-    end
-  end
-end

--- a/decidim-consultations/spec/scrubbers/decidim/consultations/question_title_scrubber_spec.rb
+++ b//dev/null
@@ -1,47 +0,0 @@
-require "spec_helper"
-describe Decidim::Consultations::QuestionTitleScrubber do
-  subject { described_class.new }
-  def scrub(html)
-    Loofah.scrub_fragment(html, subject).to_s
-  end
-  RSpec::Matchers.define :be_scrubbed do
-    match do |actual|
-      expect(scrub(actual)).to eq actual
-    end
-    failure_message do |actual|
-      "expected \"#{actual}\" to eq \"#{scrub(actual)}\" after scrubbing"
-    end
-  end
-  RSpec::Matchers.define :be_scrubbed_as do |expected|
-    match do |actual|
-      expect(scrub(actual)).to eq expected
-    end
-    failure_message do |actual|
-      "expected \"#{actual}\" to eq \"#{expected}\" after scrubbing, scrubbed as \"#{scrub(actual)}\" instead"
-    end
-  end
-  it "does not allow iframes" do
-    html = "<iframe frameborder=\"0\" allowfullscreen=\"true\" src=\"url\"></iframe>"
-    expect(html).to be_scrubbed_as("")
-  end
-  it "does not allow comments" do
-    html = "<p>Hello, <!-- world! --></p>"
-    expect(html).to be_scrubbed_as("<p>Hello, </p>")
-  end
-  it "does not allow disabled iframes" do
-    html = %(<div class="disabled-iframe"><!-- <iframe src="url"></iframe> --></div>)
-    expect(html).to be_scrubbed_as("")
-  end
-  it "allows most basic tags" do
-    html = "<a></a><b></b><strong></strong><em></em><i></i><p></p><br>"
-    expect(html).to be_scrubbed
-  end
-  it "does not allow scripts" do
-    html = "<script></script>"
-    expect(html).to be_scrubbed_as("")
-  end
-  it "does not allow onerror attributes" do
-    html = "<img src=x onerror=alert(1)>"
-    expect(html).to be_scrubbed_as("")
-  end
-end

--- a/decidim-consultations/spec/system/admin/admin_manages_consultations_spec.rb
+++ b//dev/null
@@ -1,219 +0,0 @@
-require "spec_helper"
-describe "Admin manages consultations", type: :system do
-  include_context "when administrating a consultation"
-  before do
-    switch_to_host(organization.host)
-    login_as user, scope: :user
-    visit decidim_admin_consultations.consultations_path
-  end
-  describe "listing consultations" do
-    let(:model_name) { consultation.class.model_name }
-    let(:resource_controller) { Decidim::Consultations::Admin::ConsultationsController }
-    it_behaves_like "filtering collection by published/unpublished"
-  end
-  describe "creating a consultation" do
-    before do
-      within ".layout-content" do
-        click_link("New")
-      end
-    end
-    it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='consultation-description-tabs']", "full"
-    it "creates a new consultation" do
-      execute_script("$('#consultation_start_voting_date').focus()")
-      find(".active").click
-      execute_script("$('#consultation_end_voting_date').focus()")
-      find(".active").click
-      within ".new_consultation" do
-        fill_in_i18n(
-          :consultation_title,
-          "#consultation-title-tabs",
-          en: "My consultation",
-          es: "Mi proceso participativo",
-          ca: "El meu procs participatiu"
-        )
-        fill_in_i18n(
-          :consultation_subtitle,
-          "#consultation-subtitle-tabs",
-          en: "Subtitle",
-          es: "Subttulo",
-          ca: "Subttol"
-        )
-        fill_in_i18n_editor(
-          :consultation_description,
-          "#consultation-description-tabs",
-          en: "A longer description",
-          es: "Descripcin ms larga",
-          ca: "Descripci ms llarga"
-        )
-        fill_in :consultation_slug, with: "slug"
-      end
-      dynamically_attach_file(:consultation_banner_image, image2_path)
-      within ".new_consultation" do
-        scope_pick select_data_picker(:consultation_decidim_highlighted_scope_id), organization.scopes.first
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_current_path decidim_admin_consultations.consultations_path
-        expect(page).to have_content("My consultation")
-      end
-    end
-  end
-  describe "trying to create a consultation with invalid data" do
-    before do
-      within ".layout-content" do
-        click_link("New")
-      end
-    end
-    it "fails to create a new consultation" do
-      execute_script("$('#consultation_start_voting_date').focus()")
-      find(".active").click
-      execute_script("$('#consultation_end_voting_date').focus()")
-      find(".active").click
-      within ".new_consultation" do
-        fill_in_i18n(
-          :consultation_title,
-          "#consultation-title-tabs",
-          en: "",
-          es: "",
-          ca: ""
-        )
-        fill_in_i18n(
-          :consultation_subtitle,
-          "#consultation-subtitle-tabs",
-          en: "Subtitle",
-          es: "Subttulo",
-          ca: "Subttol"
-        )
-        fill_in_i18n_editor(
-          :consultation_description,
-          "#consultation-description-tabs",
-          en: "A longer description",
-          es: "Descripcin ms larga",
-          ca: "Descripci ms llarga"
-        )
-        fill_in :consultation_slug, with: "slug"
-      end
-      dynamically_attach_file(:consultation_banner_image, image2_path)
-      within ".new_consultation" do
-        scope_pick select_data_picker(:consultation_decidim_highlighted_scope_id), organization.scopes.first
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("problem")
-    end
-  end
-  describe "updating a consultation" do
-    before do
-      click_link translated(consultation.title)
-    end
-    it "updates a consultation" do
-      fill_in_i18n(
-        :consultation_title,
-        "#consultation-title-tabs",
-        en: "My new title",
-        es: "Mi nuevo ttulo",
-        ca: "El meu nou ttol"
-      )
-      dynamically_attach_file(:consultation_banner_image, image3_path, remove_before: true)
-      within ".edit_consultation" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_selector("input[value='My new title']")
-        expect(page).not_to have_css("img[src*='#{image2_filename}']")
-        expect(page).to have_css("img[src*='#{image3_filename}']")
-      end
-    end
-  end
-  describe "updating a consultation with invalid values" do
-    before do
-      click_link translated(consultation.title)
-    end
-    it "do not updates the consultation" do
-      fill_in_i18n(
-        :consultation_title,
-        "#consultation-title-tabs",
-        en: "",
-        es: "",
-        ca: ""
-      )
-      within ".edit_consultation" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("problem")
-    end
-  end
-  describe "updating a consultation without images" do
-    let!(:consultation3) { create(:consultation, organization: organization) }
-    before do
-      visit decidim_admin_consultations.consultations_path
-    end
-    it "update a consultation without images does not delete them" do
-      click_link translated(consultation3.title)
-      within ".edit_consultation" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      expect(page).to have_css("img[src*='#{consultation3.attached_uploader(:banner_image).path}']")
-    end
-  end
-  describe "previewing consultations" do
-    let!(:consultation) { create(:consultation, :unpublished, organization: organization) }
-    it "allows the user to preview the unpublished consultation" do
-      within find("tr", text: translated(consultation.title)) do
-        preview_window = window_opened_by do
-          click_link "Preview"
-        end
-        within_window(preview_window) do
-          expect(page).to have_i18n_content(consultation.title)
-          expect(page).to have_i18n_content(consultation.description)
-        end
-      end
-    end
-  end
-  describe "viewing a missing consultation" do
-    it_behaves_like "a 404 page" do
-      let(:target_path) { decidim_admin_consultations.consultation_path(99_999_999) }
-    end
-  end
-  describe "publishing a consultation" do
-    let!(:consultation) { create(:consultation, :unpublished, organization: organization) }
-    before do
-      click_link translated(consultation.title)
-    end
-    it "publishes the consultation" do
-      click_link "Publish"
-      expect(page).to have_content("successfully published")
-      expect(page).to have_content("Unpublish")
-      expect(page).to have_current_path decidim_admin_consultations.edit_consultation_path(consultation)
-      consultation.reload
-      expect(consultation).to be_published
-    end
-  end
-  describe "unpublishing a consultation" do
-    let!(:consultation) { create(:consultation, :published, organization: organization) }
-    before do
-      click_link translated(consultation.title)
-    end
-    it "unpublishes the consultation" do
-      click_link "Unpublish"
-      expect(page).to have_content("successfully unpublished")
-      expect(page).to have_content("Publish")
-      expect(page).to have_current_path decidim_admin_consultations.edit_consultation_path(consultation)
-      consultation.reload
-      expect(consultation).not_to be_published
-    end
-  end
-  context "when there are multiple organizations in the system" do
-    let!(:external_consultation) { create(:consultation) }
-    before do
-      visit decidim_admin_consultations.consultations_path
-    end
-    it "doesn't let the admin manage assemblies form other organizations" do
-      within "table" do
-        expect(page).not_to have_content(external_consultation.title["en"])
-      end
-    end
-  end
-end

--- a/decidim-consultations/spec/system/admin/admin_manages_questions_spec.rb
+++ b//dev/null
@@ -1,235 +0,0 @@
-require "spec_helper"
-describe "Admin manages questions", type: :system do
-  include_context "when administrating a consultation"
-  describe "creating a question" do
-    context "when displaying the form" do
-      before do
-        switch_to_host(organization.host)
-        login_as user, scope: :user
-        visit decidim_admin_consultations.consultation_questions_path(consultation)
-        click_link("New question")
-      end
-      %w(question_context what_is_decided).each do |field|
-        it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='question-#{field}-tabs']", "full"
-      end
-      it_behaves_like "having a rich text editor for field", ".tabs-content[data-tabs-content='question-title-tabs']", "basic"
-    end
-    it "creates a new question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link("New question")
-      within ".new_question" do
-        fill_in_i18n_editor(
-          :question_title,
-          "#question-title-tabs",
-          en: "My question"
-        )
-        fill_in_i18n(
-          :question_subtitle,
-          "#question-subtitle-tabs",
-          en: "Subtitle"
-        )
-        fill_in_i18n(
-          :question_promoter_group,
-          "#question-promoter_group-tabs",
-          en: "Promoter group"
-        )
-        fill_in_i18n(
-          :question_participatory_scope,
-          "#question-participatory_scope-tabs",
-          en: "Participatory scope"
-        )
-        fill_in_i18n_editor(
-          :question_question_context,
-          "#question-question_context-tabs",
-          en: "Context"
-        )
-        fill_in_i18n_editor(
-          :question_what_is_decided,
-          "#question-what_is_decided-tabs",
-          en: "What is decided"
-        )
-        fill_in :question_slug, with: "slug"
-        scope_pick select_data_picker(:question_decidim_scope_id), organization.scopes.first
-      end
-      dynamically_attach_file(:question_hero_image, image2_path)
-      dynamically_attach_file(:question_banner_image, image1_path)
-      within ".new_question" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_current_path decidim_admin_consultations.consultation_questions_path(consultation)
-        expect(page).to have_content("My question")
-      end
-    end
-  end
-  describe "trying to create a question with invalid data" do
-    it "fails to create a new question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link("New question")
-      within ".new_question" do
-        fill_in :question_slug, with: "slug"
-        fill_in_i18n(
-          :question_subtitle,
-          "#question-subtitle-tabs",
-          en: "Subtitle"
-        )
-        fill_in_i18n(
-          :question_promoter_group,
-          "#question-promoter_group-tabs",
-          en: "Promoter group"
-        )
-        fill_in_i18n(
-          :question_participatory_scope,
-          "#question-participatory_scope-tabs",
-          en: "Participatory scope"
-        )
-        fill_in_i18n_editor(
-          :question_question_context,
-          "#question-question_context-tabs",
-          en: "Context"
-        )
-        fill_in_i18n_editor(
-          :question_what_is_decided,
-          "#question-what_is_decided-tabs",
-          en: "What is decided"
-        )
-        scope_pick select_data_picker(:question_decidim_scope_id), organization.scopes.first
-      end
-      dynamically_attach_file(:question_banner_image, image1_path)
-      dynamically_attach_file(:question_hero_image, image2_path)
-      within ".new_question" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("problem")
-    end
-  end
-  describe "updating a question" do
-    it "updates a question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      fill_in_i18n_editor(
-        :question_title,
-        "#question-title-tabs",
-        en: "My new title"
-      )
-      dynamically_attach_file(:question_banner_image, image3_path, remove_before: true)
-      within ".edit_question" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      within ".container" do
-        expect(page).to have_content("My new title")
-        expect(page).not_to have_css("img[src*='#{image2_filename}']")
-        expect(page).to have_css("img[src*='#{image3_filename}']")
-      end
-    end
-  end
-  describe "updating a question with invalid values" do
-    it "do not updates the question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      fill_in_i18n(
-        :question_subtitle,
-        "#question-subtitle-tabs",
-        en: "",
-        es: "",
-        ca: ""
-      )
-      within ".edit_question" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("problem")
-    end
-  end
-  describe "updating an question without images" do
-    it "update a question without images does not deletes them" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      within ".edit_question" do
-        find("*[type=submit]").click
-      end
-      expect(page).to have_admin_callout("successfully")
-      expect(page).to have_css("img[src*='#{question.attached_uploader(:banner_image).path}']")
-      expect(page).to have_css("img[src*='#{question.attached_uploader(:hero_image).path}']")
-    end
-  end
-  describe "deleting a question" do
-    it "deletes the question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      accept_confirm { click_link "Delete" }
-      expect(page).to have_admin_callout("successfully")
-      within "table" do
-        expect(page).not_to have_content(translated(question.title))
-      end
-    end
-  end
-  describe "previewing questions" do
-    it "allows the user to preview the question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      within find("tr", text: translated(question.title)) do
-        preview_window = window_opened_by do
-          click_link "Preview"
-        end
-        within_window(preview_window) do
-          expect(page).to have_i18n_content(question.title)
-          expect(page).to have_i18n_content(question.question_context)
-        end
-      end
-    end
-  end
-  describe "viewing a missing question" do
-    it_behaves_like "a 404 page" do
-      before do
-        switch_to_host(organization.host)
-        login_as user, scope: :user
-      end
-      let(:target_path) { decidim_admin_consultations.question_path(99_999_999) }
-    end
-  end
-  describe "publishing a question" do
-    let!(:question) { create(:question, :unpublished, consultation: consultation) }
-    it "publishes the question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      click_link "Publish"
-      expect(page).to have_content("successfully published")
-      expect(page).to have_content("Unpublish")
-      expect(page).to have_current_path decidim_admin_consultations.edit_question_path(question)
-      question.reload
-      expect(question).to be_published
-    end
-  end
-  describe "unpublishing a question" do
-    let!(:question) { create(:question, :published, consultation: consultation) }
-    it "unpublishes the question" do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_admin_consultations.consultation_questions_path(consultation)
-      click_link translated(question.title)
-      click_link "Unpublish"
-      expect(page).to have_content("successfully unpublished")
-      expect(page).to have_content("Publish")
-      expect(page).to have_current_path decidim_admin_consultations.edit_question_path(question)
-      question.reload
-      expect(question).not_to be_published
-    end
-  end
-end

--- a/decidim-consultations/spec/system/consultation_spec.rb
+++ b//dev/null
@@ -1,108 +0,0 @@
-require "spec_helper"
-describe "Consultation", type: :system do
-  let!(:organization) { create(:organization) }
-  let(:description) { { en: "Short description", ca: "Descripci curta", es: "Descripcin corta" } }
-  let(:introductory_video_url) { "https://www.youtube.com/watch?v=1234567890" }
-  let!(:consultation) { create(:consultation, :published, organization: organization, description: description, introductory_video_url: introductory_video_url) }
-  let!(:user) { create :user, :confirmed, organization: organization }
-  before do
-    switch_to_host(organization.host)
-  end
-  it_behaves_like "editable content for admins" do
-    let(:target_path) { decidim_consultations.consultation_path(consultation) }
-  end
-  context "when requesting the consultation path" do
-    before do
-      visit decidim_consultations.consultation_path(consultation)
-    end
-    it_behaves_like "has embedded video in description", :description do
-      let(:introductory_video_url) { nil }
-    end
-    it "Shows the basic consultation data" do
-      expect(page).to have_i18n_content(consultation.title)
-      expect(page).to have_i18n_content(consultation.subtitle)
-      expect(page).to have_i18n_content(consultation.description)
-    end
-    context "when the consultation is unpublished" do
-      let!(:consultation) do
-        create(:consultation, :unpublished, organization: organization)
-      end
-      before do
-        switch_to_host(organization.host)
-      end
-      it "redirects to sign in path" do
-        visit decidim_consultations.consultation_path(consultation)
-        expect(page).to have_current_path("/users/sign_in")
-      end
-      context "with signed in user" do
-        let!(:user) { create(:user, :confirmed, organization: organization) }
-        before do
-          sign_in user, scope: :user
-        end
-        it "redirects to root path" do
-          visit decidim_consultations.consultation_path(consultation)
-          expect(page).to have_current_path("/")
-        end
-      end
-    end
-    context "when highlighted questions" do
-      let!(:question) { create(:question, :published, consultation: consultation, scope: consultation.highlighted_scope) }
-      before do
-        switch_to_host(organization.host)
-        visit decidim_consultations.consultation_path(consultation)
-      end
-      it "Shows the highlighted questions section" do
-        expect(page).to have_content("Questions from #{translated consultation.highlighted_scope.name}".upcase)
-      end
-      it "shows highlighted question details" do
-        expect(page).to have_i18n_content(question.title)
-        expect(page).to have_i18n_content(question.subtitle)
-      end
-    end
-    context "when regular questions" do
-      let!(:scope) { create(:scope, organization: organization) }
-      let!(:question) { create(:question, :published, consultation: consultation, scope: scope) }
-      before do
-        switch_to_host(organization.host)
-        visit decidim_consultations.consultation_path(consultation)
-      end
-      it "Shows the regular questions section" do
-        expect(page).to have_content("QUESTIONS FOR THIS CONSULTATION")
-      end
-      it "shows the scope name" do
-        expect(page).to have_content(scope.name["en"].upcase)
-      end
-      it "shows the question details" do
-        expect(page).to have_i18n_content(question.title)
-        expect(page).to have_i18n_content(question.subtitle)
-      end
-    end
-    context "when showing the button that links to the question" do
-      let!(:question) { create(:question, :published, consultation: consultation, scope: consultation.highlighted_scope) }
-      context "when the user is not logged in" do
-        before do
-          switch_to_host(organization.host)
-          visit decidim_consultations.consultation_path(consultation)
-        end
-        it "shows the `take part` button" do
-          expect(page).to have_content("TAKE PART")
-        end
-      end
-      context "when the user is logged in" do
-        before do
-          switch_to_host(organization.host)
-          login_as user, scope: :user
-        end
-        it "shows the `take part` button if the user has not voted yet" do
-          visit decidim_consultations.consultation_path(consultation)
-          expect(page).to have_content("TAKE PART")
-        end
-        it "shows the `already voted` button if the user has already voted" do
-          question.votes.create(author: user, response: Decidim::Consultations::Response.new)
-          visit decidim_consultations.consultation_path(consultation)
-          expect(page).to have_content("ALREADY VOTED")
-        end
-      end
-    end
-  end
-end

--- a/decidim-consultations/spec/system/question_spec.rb
+++ b//dev/null
@@ -1,135 +0,0 @@
-require "spec_helper"
-describe "Question", type: :system do
-  let(:organization) { create(:organization) }
-  let!(:consultation) { create(:consultation, :published, organization: organization) }
-  let(:question_context) { Decidim::Faker::Localized.wrapped("<p>", "</p>") { generate_localized_title } }
-  let(:what_is_decided) { Decidim::Faker::Localized.wrapped("<p>", "</p>") { generate_localized_title } }
-  let(:previous_question) { create :question, consultation: consultation }
-  let(:question) { create :question, consultation: consultation, question_context: question_context, what_is_decided: what_is_decided }
-  let(:next_question) { create :question, consultation: consultation }
-  context "when shows question information" do
-    before do
-      switch_to_host(organization.host)
-      visit decidim_consultations.question_path(question)
-    end
-    context "when displaying question context" do
-      it_behaves_like "has embedded video in description", :question_context, count: 2 do
-        before { click_button("Read more") }
-      end
-    end
-    context "when displaying what is decided" do
-      it_behaves_like "has embedded video in description", :what_is_decided do
-        before { click_button("Read more") }
-      end
-    end
-    it "Shows the basic question data" do
-      expect(page).to have_i18n_content(question.promoter_group)
-      expect(page).to have_i18n_content(question.scope.name)
-      expect(page).to have_i18n_content(question.participatory_scope)
-      expect(page).to have_i18n_content(question.question_context)
-      expect(page).not_to have_i18n_content(question.what_is_decided)
-    end
-    it "Shows the technical data" do
-      expect(page).to have_i18n_content(question.promoter_group)
-      expect(page).to have_i18n_content(question.scope.name)
-      expect(page).to have_i18n_content(question.participatory_scope)
-      expect(page).to have_i18n_content(question.question_context)
-      click_button("Read more")
-      expect(page).to have_i18n_content(question.what_is_decided)
-    end
-    context "when is the only published question" do
-      it "doesn't show the previous/next question button" do
-        expect(page).not_to have_content("Previous question")
-        expect(page).not_to have_content("Next question")
-      end
-    end
-  end
-  context "when previous question is published" do
-    before do
-      previous_question.publish!
-      question.publish!
-      switch_to_host(organization.host)
-      visit decidim_consultations.question_path(question)
-    end
-    it "shows the previous/next question button" do
-      expect(page).to have_content("Previous question")
-      expect(page).to have_content("Next question")
-    end
-    context "when showing the previous/next question button" do
-      let(:previous_button) { page.find("a", text: "Previous question") }
-      let(:next_button) { page.find("a", text: "Next question") }
-      it "enables the previous button when viewing the first question" do
-        expect(previous_button[:class]).not_to include("disabled")
-      end
-      it "disables the next button when viewing the last question" do
-        expect(next_button[:class]).to include("disabled")
-      end
-    end
-  end
-  context "when no question is published" do
-    let(:user) { create(:user, :admin, :confirmed, organization: organization) }
-    let(:previous_question) { create :question, :unpublished, consultation: consultation }
-    let(:question) { create :question, :unpublished, consultation: consultation }
-    let(:next_question) { create :question, :unpublished, consultation: consultation }
-    before do
-      switch_to_host(organization.host)
-      login_as user, scope: :user
-      visit decidim_consultations.question_path(question)
-    end
-    it "hides the previous/next question button" do
-      expect(page).not_to have_content("Previous question")
-      expect(page).not_to have_content("Next question")
-    end
-  end
-  context "when next question is published" do
-    before do
-      question.publish!
-      next_question.publish!
-      switch_to_host(organization.host)
-      visit decidim_consultations.question_path(question)
-    end
-    it "shows the previous/next question button" do
-      expect(page).to have_content("Previous question")
-      expect(page).to have_content("Next question")
-    end
-    context "when showing the previous/next question button" do
-      let(:previous_button) { page.find("a", text: "Previous question") }
-      let(:next_button) { page.find("a", text: "Next question") }
-      it "disables the previous button when viewing the first question" do
-        expect(previous_button[:class]).to include("disabled")
-      end
-      it "enables the next button when viewing the last question" do
-        expect(next_button[:class]).not_to include("disabled")
-      end
-    end
-  end
-  context "when finished consultations" do
-    context "and published results" do
-      let(:consultation) { create :consultation, :finished, :published, :published_results, organization: organization }
-      let(:response) { create :response, question: question }
-      let!(:vote) { create :vote, question: question, response: response }
-      before do
-        switch_to_host(organization.host)
-        visit decidim_consultations.question_path(question)
-      end
-      it "Has the results" do
-        expect(page).to have_content("RESULTS")
-        expect(page).to have_i18n_content(response.title)
-        expect(page).to have_content(response.votes_count)
-      end
-    end
-  end
-  context "when question has no hero image" do
-    let(:question_without_hero) { create :question, consultation: consultation, hero_image: nil }
-    before do
-      switch_to_host(organization.host)
-      visit decidim_consultations.question_path(question_without_hero)
-    end
-    it "Shows the basic question data" do
-      expect(page).to have_i18n_content(question_without_hero.promoter_group)
-      expect(page).to have_i18n_content(question_without_hero.scope.name)
-      expect(page).to have_i18n_content(question_without_hero.participatory_scope)
-      expect(page).to have_i18n_content(question_without_hero.question_context)
-    end
-  end
-end

--- a/decidim-core/app/cells/decidim/upload_modal_cell.rb
+++ b//dev/null
@@ -1,157 +0,0 @@
-module Decidim
-  class UploadModalCell < Decidim::ViewModel
-    include Cell::ViewModel::Partial
-    include ERB::Util
-    include Decidim::SanitizeHelper
-    alias form model
-    def show
-      return unless resource_name
-      render
-    end
-    private
-    def button_id
-      prefix = form.object_name.present? ? "#{form.object_name}_" : ""
-      "#{prefix.gsub(/[\[\]]/, "_").gsub(/__+/, "_")}#{attribute}_button"
-    end
-    def button_class
-      "button small hollow add-field add-file" if has_title?
-      "button small add-file"
-    end
-    def label
-      form.send(:custom_label, attribute, options[:label], { required: required?, for: nil })
-    end
-    def button_label
-      return button_edit_label if attachments.count.positive?
-      options[:button_label]
-    end
-    def button_edit_label
-      options[:button_edit_label] || options[:button_label]
-    end
-    def max_file_size
-      options[:max_file_size]
-    end
-    def max_file_size_mb
-      return unless max_file_size
-      (((max_file_size / 1024 / 1024) * 100) / 100).round
-    end
-    def resource_class
-      options[:resource_class].to_s
-    end
-    def resource_name
-      options[:resource_name]
-    end
-    def actions_wrapper_class
-      has_title? ? "actions-wrapper titled" : "actions-wrapper"
-    end
-    def attribute
-      options[:attribute]
-    end
-    def multiple
-      options[:multiple] || false
-    end
-    def optional
-      !required?
-    end
-    def required?
-      return !options[:optional] if options.has_key?(:optional)
-      options[:required] == true
-    end
-    def input_validation_field
-      object_name = form.object.present? ? "#{form.object.model_name.param_key}[#{add_attribute}_validation]" : "#{add_attribute}_validation"
-      input = check_box_tag object_name, 1, attachments.present?, class: "hide", label: false, required: required?
-      message = form.send(:abide_error_element, add_attribute) + form.send(:error_and_help_text, add_attribute)
-      input + message
-    end
-    def explanation
-      i18n_options = {
-        scope: options[:help_i18n_scope].presence || "decidim.forms.upload_help",
-        attribute: attribute_translation
-      }
-      I18n.t("explanation", **i18n_options)
-    end
-    def attribute_translation
-      I18n.t(attribute, scope: [:activemodel, :attributes, resource_class.constantize.model_name.param_key].join("."))
-    rescue NameError
-      I18n.t(attribute, scope: "activemodel.attributes")
-    end
-    def add_attribute
-      return "add_#{attribute}" if form.object.respond_to? "add_#{attribute}"
-      attribute
-    end
-    def has_title?
-      options[:titled] == true
-    end
-    def with_title
-      "with-title" if has_title?
-    end
-    def attachment_label
-      return I18n.t("current_image", scope: "decidim.forms") if attachments.count.positive? && file_attachment_path(attachments.first).present?
-      I18n.t("default_image", scope: "decidim.forms")
-    end
-    def help_messages
-      Array(options[:help])
-    end
-    def attachments
-      @attachments = begin
-        attachments = options[:attachments] || form.object.send(attribute)
-        attachments = Array(attachments).compact_blank
-        attachments.map { |attachment| attachment.is_a?(String) ? ActiveStorage::Blob.find_signed(attachment) : attachment }
-      end
-    end
-    def id_for(attachment)
-      return attachment.id if attachment.respond_to? :id
-      rand(1..10_000)
-    end
-    def title_for(attachment)
-      return unless has_title?
-      decidim_html_escape(decidim_sanitize(translated_attribute(attachment.title)))
-    end
-    def truncated_file_name_for(attachment, max_length = 31)
-      filename = file_name_for(attachment)
-      return filename if filename.length <= max_length
-      name = File.basename(filename, File.extname(filename))
-      name.truncate(max_length, omission: "...#{name.last((max_length / 2) - 3)}#{File.extname(filename)}")
-    end
-    def file_name_for(attachment)
-      determine_filename(attachment)
-    end
-    def determine_filename(attachment)
-      return attachment.filename.to_s if attachment.is_a? ActiveStorage::Blob
-      return blob(attachment).filename.to_s if blob(attachment).present?
-      attachment.url.split("/").last
-    end
-    def file_attachment_path(attachment)
-      return unless attachment
-      return Rails.application.routes.url_helpers.rails_blob_url(attachment, only_path: true) if attachment.is_a? ActiveStorage::Blob
-      if attachment.try(:attached?)
-        attachment_path = Rails.application.routes.url_helpers&.rails_blob_url(attachment.blob, only_path: true)
-        return attachment_path if attachment_path.present?
-      end
-      uploader_default_image_path(attribute)
-    end
-    def uploader_default_image_path(attribute)
-      uploader = Decidim::FileValidatorHumanizer.new(form.object, attribute).uploader
-      return if uploader.blank?
-      return unless uploader.is_a?(Decidim::ImageUploader)
-      uploader.try(:default_url)
-    end
-    def blob(attachment)
-      return attachment if attachment.is_a? ActiveStorage::Blob
-      return ActiveStorage::Blob.find_signed(attachment) if attachment.is_a? String
-      return attachment.file.blob if attachment.is_a? Decidim::Attachment
-      return attachment.blob if attachment.respond_to? :blob
-    end
-    def direct_upload_url
-      Rails.application.class.routes.url_helpers.rails_direct_uploads_path
-    end
-    def form_object_class
-      form.object.class.to_s
-    end
-    def modal_id
-      @modal_id ||= "upload_#{SecureRandom.uuid}"
-    end
-    def current_organization
-      controller.current_organization
-    end
-  end
-end

--- a/decidim-core/app/commands/decidim/attachment_methods.rb
+++ b//dev/null
@@ -1,56 +0,0 @@
-module Decidim
-  module AttachmentMethods
-    private
-    def build_attachment(attached_to = nil)
-      attached_to = @attached_to if attached_to.blank?
-      attached_to = form.current_organization if attached_to.blank? && form.respond_to?(:current_organization)
-      @attachment = Attachment.new(
-        title: { I18n.locale => @form.attachment.title },
-        attached_to: attached_to,
-        file: signed_id_for(@form.attachment.file),
-        content_type: content_type_for(@form.attachment.file)
-      )
-    end
-    def delete_attachment(attachment)
-      Attachment.find(attachment.id).delete if attachment.id.to_i == proposal.documents.first.id
-    end
-    def attachment_invalid?
-      if attachment.invalid? && attachment.errors.has_key?(:file)
-        @form.attachment.errors.add :file, attachment.errors[:file]
-        true
-      end
-    end
-    def attachment_present?
-      @form.attachment.file.present?
-    end
-    def attachment_file_uploaded?
-      !@form.attachment.file.is_a?(Decidim::ApplicationUploader)
-    end
-    def create_attachment(weight: 0)
-      attachment.weight = weight
-      attachment.attached_to = @attached_to
-      attachment.save!
-    end
-    def attachments_allowed?
-      @form.current_component.settings.attachments_allowed?
-    end
-    def process_attachments?
-      attachments_allowed? && attachment_present? && attachment_file_uploaded?
-    end
-    def delete_attachment?
-      @form.attachment&.delete_file.present?
-    end
-    protected
-    def signed_id_for(attachment)
-      return attachment[:file] if attachment.is_a?(Hash)
-      attachment
-    end
-    def content_type_for(attachment)
-      return attachment.content_type if attachment.instance_of?(ActionDispatch::Http::UploadedFile)
-      blob(signed_id_for(attachment)).content_type
-    end
-    def blob(signed_id)
-      ActiveStorage::Blob.find_signed(signed_id)
-    end
-  end
-end

--- a/decidim-core/app/commands/decidim/create_registration.rb
+++ b//dev/null
@@ -1,35 +0,0 @@
-module Decidim
-  class CreateRegistration < Decidim::Command
-    def initialize(form)
-      @form = form
-    end
-    def call
-      if form.invalid?
-        user = User.has_pending_invitations?(form.current_organization.id, form.email)
-        user.invite!(user.invited_by) if user
-        return broadcast(:invalid)
-      end
-      create_user
-      broadcast(:ok, @user)
-    rescue ActiveRecord::RecordInvalid
-      broadcast(:invalid)
-    end
-    private
-    attr_reader :form
-    def create_user
-      @user = User.create!(
-        email: form.email,
-        name: form.name,
-        nickname: form.nickname,
-        password: form.password,
-        password_confirmation: form.password_confirmation,
-        password_updated_at: Time.current,
-        organization: form.current_organization,
-        tos_agreement: form.tos_agreement,
-        newsletter_notifications_at: form.newsletter_at,
-        accepted_tos_version: form.current_organization.tos_version,
-        locale: form.current_locale
-      )
-    end
-  end
-end

--- a/decidim-core/app/commands/decidim/gallery_methods.rb
+++ b//dev/null
@@ -1,82 +0,0 @@
-module Decidim
-  module GalleryMethods
-    private
-    def build_gallery(attached_to = nil)
-      @gallery = []
-      @form.add_photos.compact_blank.each do |photo|
-        if photo.is_a?(Hash) && photo.has_key?(:id)
-          update_attachment_title_for(photo)
-          next
-        end
-        @gallery << Attachment.new(
-          title: photos_title(photo),
-          attached_to: attached_to || gallery_attached_to,
-          file: photos_signed_id(photo), # Define attached_to before this
-          content_type: photos_content_type(photo)
-        )
-      end
-    end
-    def update_attachment_title_for(photo)
-      Decidim::Attachment.find(photo[:id]).update(title: photos_title(photo))
-    end
-    def image?(signed_id)
-      blob(signed_id).content_type.start_with? "image"
-    end
-    def gallery_invalid?
-      @gallery.each do |photo|
-        if photo.invalid? && photo.errors.has_key?(:file)
-          @form.errors.add(:add_photos, photo.errors[:file])
-          return true
-        end
-      end
-      false
-    end
-    def create_gallery(first_weight: 0)
-      weight = first_weight
-      @form.photos.each do |photo|
-        photo.update!(weight: weight)
-        weight += 1
-      end
-      @gallery.map! do |photo|
-        photo.weight = weight
-        photo.attached_to = gallery_attached_to
-        photo.save!
-        weight += 1
-        @form.photos << photo
-      end
-    end
-    def photo_cleanup!
-      gallery_attached_to.photos.each do |photo|
-        next unless @form.photos.map(&:id).exclude?(photo.id)
-        photo.destroy! if (@form.respond_to?(:documents) && @form.documents.map(&:id).exclude?(photo.id)) || !@form.respond_to?(:documents)
-      end
-      gallery_attached_to.reload
-      gallery_attached_to.instance_variable_set(:@photos, nil)
-    end
-    def gallery_allowed?
-      true
-    end
-    def process_gallery?
-      gallery_allowed? && @form.add_photos.any?
-    end
-    def gallery_attached_to
-      return @attached_to if @attached_to.present?
-      return form.current_organization if form.respond_to?(:current_organization)
-      form.current_component.organization if form.respond_to?(:current_component)
-    end
-    def photos_signed_id(photo)
-      return photo[:file] if photo.is_a?(Hash)
-      photo
-    end
-    def photos_title(photo)
-      return { I18n.locale => photo[:title] } if photo.is_a?(Hash) && photo.has_key?(:title)
-      { I18n.locale => "" }
-    end
-    def photos_content_type(photo)
-      blob(photos_signed_id(photo)).content_type
-    end
-    def blob(signed_id)
-      ActiveStorage::Blob.find_signed(signed_id)
-    end
-  end
-end

--- a/decidim-core/app/commands/decidim/update_account.rb
+++ b//dev/null
@@ -1,55 +0,0 @@
-module Decidim
-  class UpdateAccount < Decidim::Command
-    def initialize(user, form)
-      @user = user
-      @form = form
-    end
-    def call
-      return broadcast(:invalid) unless @form.valid?
-      update_personal_data
-      update_avatar
-      update_password
-      if @user.valid?
-        @user.save!
-        notify_followers
-        broadcast(:ok, @user.unconfirmed_email.present?)
-      else
-        [:avatar, :password, :password_confirmation].each do |key|
-          @form.errors.add key, @user.errors[key] if @user.errors.has_key? key
-        end
-        broadcast(:invalid)
-      end
-    end
-    private
-    def update_personal_data
-      @user.locale = @form.locale
-      @user.name = @form.name
-      @user.nickname = @form.nickname
-      @user.email = @form.email
-      @user.personal_url = @form.personal_url
-      @user.about = @form.about
-    end
-    def update_avatar
-      if @form.avatar.present?
-        @user.avatar.attach(@form.avatar)
-      elsif @form.remove_avatar
-        @user.avatar = nil
-      end
-    end
-    def update_password
-      return if @form.password.blank?
-      @user.password = @form.password
-      @user.password_confirmation = @form.password_confirmation
-      @user.password_updated_at = Time.current
-    end
-    def notify_followers
-      return if (@user.previous_changes.keys & %w(about personal_url)).empty?
-      Decidim::EventsManager.publish(
-        event: "decidim.events.users.profile_updated",
-        event_class: Decidim::ProfileUpdatedEvent,
-        resource: @user,
-        followers: @user.followers
-      )
-    end
-  end
-end

--- a/decidim-core/app/commands/decidim/update_password.rb
+++ b//dev/null
@@ -1,21 +0,0 @@
-module Decidim
-  class UpdatePassword < Decidim::Command
-    def initialize(user, form)
-      @user = user
-      @form = form
-    end
-    def call
-      return broadcast(:invalid) if form.invalid?
-      user.password = form.password
-      user.password_confirmation = form.password
-      user.password_updated_at = Time.current
-      if user.save
-        broadcast(:ok)
-      else
-        broadcast(:invalid)
-      end
-    end
-    private
-    attr_reader :form, :user
-  end
-end

--- a/decidim-core/app/controllers/decidim/devise/sessions_controller.rb
+++ b//dev/null
@@ -1,48 +0,0 @@
-module Decidim
-  module Devise
-    class SessionsController < ::Devise::SessionsController
-      include Decidim::DeviseControllers
-      before_action :check_sign_in_enabled, only: :create
-      def create
-        super do |user|
-          if user.admin?
-            validator = PasswordValidator.new({ attributes: :password })
-            user.update!(password_updated_at: nil) unless validator.validate_each(user, :password, sign_in_params[:password])
-          end
-        end
-      end
-      def destroy
-        current_user.invalidate_all_sessions!
-        if params[:translation_suffix].present?
-          super { set_flash_message! :notice, params[:translation_suffix], { scope: "decidim.devise.sessions" } }
-        else
-          super
-        end
-      end
-      def after_sign_in_path_for(user)
-        if user.present? && user.blocked?
-          check_user_block_status(user)
-        elsif user.needs_password_update?
-          change_password_path
-        elsif first_login_and_not_authorized?(user) && !user.admin? && !pending_redirect?(user)
-          decidim_verifications.first_login_authorizations_path
-        else
-          super
-        end
-      end
-      def pending_redirect?(user)
-        store_location_for(user, stored_location_for(user))
-      end
-      def first_login_and_not_authorized?(user)
-        user.is_a?(User) && user.sign_in_count == 1 && current_organization.available_authorizations.any? && user.verifiable?
-      end
-      def after_sign_out_path_for(user)
-        request.referer || super
-      end
-      private
-      def check_sign_in_enabled
-        redirect_to new_user_session_path unless current_organization.sign_in_enabled?
-      end
-    end
-  end
-end

--- a/decidim-core/app/controllers/decidim/links_controller.rb
+++ b//dev/null
@@ -1,31 +0,0 @@
-module Decidim
-  class InvalidUrlError < StandardError; end
-  class LinksController < Decidim::ApplicationController
-    skip_before_action :store_current_location
-    helper Decidim::ExternalDomainHelper
-    helper_method :external_url
-    before_action :parse_url
-    rescue_from Decidim::InvalidUrlError, with: :invalid_url
-    rescue_from URI::InvalidURIError, with: :invalid_url
-    def new
-      headers["X-Robots-Tag"] = "noindex"
-    end
-    private
-    def invalid_url
-      flash[:alert] = I18n.t("decidim.links.invalid_url")
-      if request.xhr?
-        render "invalid_url"
-      else
-        redirect_to decidim.root_path
-      end
-    end
-    def parse_url
-      raise Decidim::InvalidUrlError if params[:external_url].blank?
-      raise Decidim::InvalidUrlError unless external_url
-      raise Decidim::InvalidUrlError unless %w(http https).include?(external_url.scheme)
-    end
-    def external_url
-      @external_url ||= URI.parse(params[:external_url])
-    end
-  end
-end

--- a/decidim-core/app/helpers/decidim/cells_helper.rb
+++ b//dev/null
@@ -1,33 +0,0 @@
-module Decidim
-  module CellsHelper
-    def from_context
-      options[:from].presence || context[:from].presence
-    end
-    def index_action?
-      context[:controller].action_name == "index"
-    end
-    def show_action?
-      context[:controller].action_name == "show"
-    end
-    def current_component
-      from_context.component
-    end
-    def withdrawable?
-      return unless from_context
-      return unless context[:controller].try(:withdrawable_controller?)
-      return if index_action?
-      from_context.withdrawable_by?(current_user)
-    end
-    def flaggable?
-      return unless from_context
-      return unless context[:controller].try(:flaggable_controller?)
-      return if index_action?
-      true
-    end
-    def user_flaggable?
-      return if (try(:profile_holder) || try(:profile_user) || try(:model)).try(:blocked)
-      return unless context[:controller].try(:flaggable_controller?)
-      true
-    end
-  end
-end

--- a/decidim-core/app/helpers/decidim/external_domain_helper.rb
+++ b//dev/null
@@ -1,20 +0,0 @@
-module Decidim
-  module ExternalDomainHelper
-    def highlight_domain
-      highlighted_domain = [
-        external_url.host,
-        (external_url.port && [80, 443].include?(external_url.port) ? "" : ":#{external_url.port}")
-      ].join
-      path = [
-        external_url.path,
-        (external_url.query ? "?#{external_url.query}" : ""),
-        (external_url.fragment ? "##{external_url.fragment}" : "")
-      ].join
-      tag.div do
-        content_tag(:span, "#{external_url.scheme}://") +
-          content_tag(:span, highlighted_domain, class: "text-alert") +
-          content_tag(:span, path)
-      end
-    end
-  end
-end

--- a/decidim-core/app/helpers/decidim/sanitize_helper.rb
+++ b//dev/null
@@ -1,77 +0,0 @@
-module Decidim
-  module SanitizeHelper
-    def self.included(base)
-      base.include ActionView::Helpers::SanitizeHelper
-      base.include ActionView::Helpers::TagHelper
-    end
-    def decidim_sanitize(html, options = {})
-      scrubber = options[:scrubber] || Decidim::UserInputScrubber.new
-      if options[:strip_tags]
-        strip_tags sanitize(html, scrubber: scrubber)
-      else
-        sanitize(html, scrubber: scrubber)
-      end
-    end
-    def decidim_sanitize_admin(html, options = {})
-      decidim_sanitize(html, { scrubber: Decidim::AdminInputScrubber.new }.merge(options))
-    end
-    def decidim_sanitize_newsletter(html, options = {})
-      if options[:strip_tags]
-        strip_tags sanitize(html, scrubber: Decidim::NewsletterScrubber.new)
-      else
-        sanitize(html, scrubber: Decidim::NewsletterScrubber.new)
-      end
-    end
-    def decidim_sanitize_editor(html, options = {})
-      content_tag(:div, decidim_sanitize(html, options), class: %w(ql-editor-display))
-    end
-    def decidim_sanitize_editor_admin(html, options = {})
-      html = Decidim::IframeDisabler.new(html, options).perform
-      decidim_sanitize_editor(html, { scrubber: Decidim::AdminInputScrubber.new }.merge(options))
-    end
-    def decidim_html_escape(text)
-      ERB::Util.unwrapped_html_escape(text.to_str)
-    end
-    def decidim_url_escape(text)
-      decidim_html_escape(text).sub(/^javascript:/, "")
-    end
-    private
-    def sanitize_text(text)
-      add_line_feeds(sanitize_ordered_lists(sanitize_unordered_lists(text)))
-    end
-    def sanitize_unordered_lists(text)
-      text.gsub(%r{(?=.*</ul>)(?!.*?<li>.*?</ol>.*?</ul>)<li>}) { |li| "#{li} " }
-    end
-    def sanitize_ordered_lists(text)
-      i = 0
-      text.gsub(%r{(?=.*</ol>)(?!.*?<li>.*?</ul>.*?</ol>)<li>}) do |li|
-        i += 1
-        li + "#{i}. "
-      end
-    end
-    def add_line_feeds_to_paragraphs(text)
-      text.gsub("</p>") { |p| "#{p}\n\n" }
-    end
-    def add_line_feeds_to_list_items(text)
-      text.gsub("</li>") { |li| "#{li}\n" }
-    end
-    def add_line_feeds(text)
-      add_line_feeds_to_paragraphs(add_line_feeds_to_list_items(text))
-    end
-    def content_handle_locale(body, all_locales, extras, links, strip_tags)
-      handle_locales(body, all_locales) do |content|
-        content = strip_tags(sanitize_text(content)) if strip_tags
-        renderer = Decidim::ContentRenderers::HashtagRenderer.new(content)
-        content = renderer.render(links: links, extras: extras).html_safe
-        content = Decidim::ContentRenderers::LinkRenderer.new(content).render if links
-        content
-      end
-    end
-    def render_sanitized_content(resource, method)
-      content = present(resource).send(method, links: true, strip_tags: !try(:safe_content?))
-      return decidim_sanitize(content, {}) unless try(:safe_content?)
-      return decidim_sanitize_editor_admin(content, {}) if try(:safe_content_admin?)
-      decidim_sanitize_editor(content)
-    end
-  end
-end

--- a/decidim-core/app/models/decidim/scope_type.rb
+++ b//dev/null
@@ -1,28 +0,0 @@
-module Decidim
-  class ScopeType < ApplicationRecord
-    include Decidim::TranslatableResource
-    include Traceable
-    translatable_fields :name, :plural
-    belongs_to :organization,
-               foreign_key: "decidim_organization_id",
-               class_name: "Decidim::Organization",
-               inverse_of: :scope_types
-    has_many :scopes, class_name: "Decidim::Scope", inverse_of: :scope_type, dependent: :nullify
-    validates :name, presence: true
-    before_destroy :detach_dynamic_associations
-    def self.log_presenter_class_for(_log)
-      Decidim::AdminLog::ScopeTypePresenter
-    end
-    private
-    def detach_dynamic_associations
-      ActiveRecord::Base.descendants.each do |cls|
-        next if cls.abstract_class? || !cls.name&.match?(/^Decidim::/)
-        next if cls == self.class || cls == Decidim::Scope
-        cls.reflect_on_all_associations(:belongs_to).each do |ref|
-          next unless ref.options[:class_name] == self.class.name
-          cls.where(ref.options[:foreign_key] => id).update_all(ref.options[:foreign_key] => nil) # rubocop:disable Rails/SkipsModelValidations
-        end
-      end
-    end
-  end
-end

--- a/decidim-core/app/packs/src/decidim/direct_uploads/upload_modal.js
+++ b//dev/null
@@ -1,213 +0,0 @@
-import { Uploader } from "src/decidim/direct_uploads/uploader";
-import { truncateFilename, checkTitles, createHiddenInput } from "src/decidim/direct_uploads/upload_utility";
-export default class UploadModal {
-  constructor(button, options = {}) {
-    this.button = button;
-    let providedOptions = {};
-    try {
-      providedOptions = JSON.parse(button.dataset.upload);
-    } catch (_e) {
-    }
-    this.options = Object.assign(providedOptions, options)
-    this.name = this.button.name;
-    this.modal = document.querySelector(`#${button.dataset.open}`);
-    this.saveButton = this.modal.querySelector(`button.add-file-${this.name}`);
-    this.attachmentCounter = 0;
-    this.dropZoneEnabled = true;
-    this.modalTitle = this.modal.querySelector(".reveal__title");
-    this.uploadItems = this.modal.querySelector(".upload-items");
-    this.locales = JSON.parse(this.uploadItems.dataset.locales);
-    this.dropZone = this.modal.querySelector(".dropzone");
-    this.input = this.dropZone.querySelector("input");
-    this.uploadContainer = document.querySelector(`.upload-container-for-${this.name}`);
-    this.activeAttachments = this.uploadContainer.querySelector(".active-uploads");
-    this.trashCan = this.createTrashCan();
-  }
-  uploadFile(file) {
-    if (!this.dropZoneEnabled) {
-      return;
-    }
-    const title = file.name.split(".")[0].slice(0, 31);
-    const uploadItem = this.createUploadItem(file.name, title, "init");
-    const uploader = new Uploader(this, uploadItem, {
-      file: file,
-      url: this.input.dataset.directUploadUrl,
-      attachmentName: file.name
-    });
-    if (uploader.fileTooBig) {
-      return;
-    }
-    uploader.upload.create((error, blob) => {
-      if (error) {
-        uploadItem.dataset.state = "error";
-        const progressBar = uploadItem.querySelector(".progress-bar");
-        progressBar.classList.add("filled");
-        progressBar.innerHTML = this.locales.error;
-        console.error(error);
-      } else {
-        const ordinalNumber = this.getOrdinalNumber();
-        const attachmentDetails = document.createElement("div");
-        attachmentDetails.classList.add("attachment-details");
-        attachmentDetails.dataset.filename = file.name;
-        const titleAndFileNameSpan = document.createElement("span");
-        titleAndFileNameSpan.style.display = "none";
-        attachmentDetails.appendChild(titleAndFileNameSpan);
-        const hiddenBlobField = createHiddenInput(null, null, blob.signed_id);
-        if (this.options.titled) {
-          hiddenBlobField.name = `${this.options.resourceName}[${this.options.addAttribute}][${ordinalNumber}][file]`;
-        } else {
-          hiddenBlobField.name = `${this.options.resourceName}[${this.options.addAttribute}]`;
-        }
-        if (this.options.titled) {
-          const hiddenTitleField = createHiddenInput("hidden-title", `${this.options.resourceName}[${this.options.addAttribute}][${ordinalNumber}][title]`, title);
-          titleAndFileNameSpan.innerHTML = `${title} (${file.name})`;
-          attachmentDetails.appendChild(hiddenTitleField);
-        } else {
-          titleAndFileNameSpan.innerHTML = file.name;
-        }
-        if (!this.options.multiple) {
-          this.cleanTrashCan();
-        }
-        attachmentDetails.appendChild(hiddenBlobField);
-        uploadItem.appendChild(attachmentDetails);
-        uploader.validate(blob.signed_id);
-      }
-    });
-    this.updateDropZone();
-  }
-  getOrdinalNumber() {
-    const nextOrdinalNumber = this.attachmentCounter;
-    this.attachmentCounter += 1;
-    return nextOrdinalNumber;
-  }
-  updateDropZone() {
-    if (this.options.multiple) {
-      return;
-    }
-    if (this.uploadItems.children.length > 0) {
-      this.dropZone.classList.add("disabled");
-      this.dropZoneEnabled = false;
-      this.input.disabled = true;
-    } else {
-      this.dropZone.classList.remove("disabled");
-      this.dropZoneEnabled = true;
-      this.input.disabled = false;
-    }
-  }
-  createUploadItem(fileName, title, state) {
-    const wrapper = document.createElement("div");
-    wrapper.classList.add("upload-item");
-    wrapper.setAttribute("data-filename", fileName);
-    const firstRow = document.createElement("div");
-    const secondRow = document.createElement("div");
-    const thirdRow = document.createElement("div");
-    firstRow.classList.add("row", "upload-item-first-row");
-    secondRow.classList.add("row", "upload-item-second-row");
-    thirdRow.classList.add("row", "upload-item-third-row");
-    const fileNameSpan = document.createElement("span");
-    let fileNameSpanClasses = ["columns", "file-name-span"];
-    if (this.options.titled) {
-      fileNameSpanClasses.push("small-4", "medium-5");
-    } else {
-      fileNameSpanClasses.push("small-12");
-    }
-    fileNameSpan.classList.add(...fileNameSpanClasses);
-    fileNameSpan.innerHTML = truncateFilename(fileName);
-    const progressBar = document.createElement("div");
-    progressBar.classList.add("progress-bar");
-    if (state) {
-      if (state === "validated") {
-        progressBar.innerHTML = this.locales.uploaded;
-      } else {
-        progressBar.innerHTML = "0%";
-        progressBar.style.width = "15%";
-      }
-      wrapper.dataset.state = state;
-    }
-    const progressBarBorder = document.createElement("div");
-    progressBarBorder.classList.add("progress-bar-border");
-    progressBarBorder.appendChild(progressBar);
-    const progressBarWrapper = document.createElement("div");
-    progressBarWrapper.classList.add("columns", "progress-bar-wrapper");
-    progressBarWrapper.appendChild(progressBarBorder);
-    if (this.options.titled) {
-      progressBarWrapper.classList.add("small-4", "medium-5");
-    } else {
-      progressBarWrapper.classList.add("small-10");
-    }
-    const errorList = document.createElement("ul");
-    errorList.classList.add("upload-errors");
-    const removeButton = document.createElement("button");
-    removeButton.classList.add("columns", "small-3", "medium-2", "remove-upload-item");
-    removeButton.innerHTML = `&times; ${this.locales.remove}`;
-    removeButton.addEventListener(("click"), (event) => {
-      event.preventDefault();
-      const item = this.uploadItems.querySelector(`[data-filename='${fileName}']`);
-      this.trashCan.append(item);
-      this.updateDropZone();
-    })
-    const titleAndFileNameSpan = document.createElement("span");
-    titleAndFileNameSpan.classList.add("columns", "small-5", "title-and-filename-span");
-    titleAndFileNameSpan.innerHTML = `${title} (${truncateFilename(fileName)})`;
-    firstRow.appendChild(fileNameSpan);
-    secondRow.appendChild(progressBarWrapper);
-    thirdRow.appendChild(errorList);
-    let titleInputContainer = null;
-    if (this.options.titled) {
-      const titleInput = document.createElement("input");
-      titleInput.classList.add("attachment-title");
-      titleInput.type = "text";
-      titleInput.value = title;
-      titleInput.addEventListener("input", (event) => {
-        event.preventDefault();
-        checkTitles(this.uploadItems, this.saveButton);
-      })
-      titleInputContainer = document.createElement("div");
-      titleInputContainer.classList.add("columns", "small-5", "title-input-container");
-      titleInputContainer.appendChild(titleInput);
-      const noTitleErrorSpan = document.createElement("span");
-      noTitleErrorSpan.classList.add("form-error", "no-title-error");
-      noTitleErrorSpan.role = "alert";
-      noTitleErrorSpan.innerHTML = this.locales.title_required;
-      titleInputContainer.appendChild(noTitleErrorSpan);
-      const titleLabelSpan = document.createElement("span");
-      titleLabelSpan.classList.add("title-label-span");
-      titleLabelSpan.innerHTML = this.locales.title;
-      const titleContainer = document.createElement("div");
-      titleContainer.classList.add("columns", "small-8", "medium-7", "title-container");
-      titleContainer.appendChild(titleLabelSpan);
-      firstRow.appendChild(titleContainer);
-      secondRow.appendChild(titleInputContainer);
-    }
-    secondRow.appendChild(removeButton);
-    wrapper.appendChild(firstRow);
-    wrapper.appendChild(secondRow);
-    wrapper.appendChild(thirdRow);
-    this.uploadItems.appendChild(wrapper);
-    return wrapper;
-  }
-  updateAddAttachmentsButton() {
-    if (this.activeAttachments.children.length === 0) {
-      this.button.innerHTML = this.modalTitle.dataset.addlabel;
-    } else {
-      this.button.innerHTML = this.modalTitle.dataset.editlabel;
-    }
-  }
-  createTrashCan() {
-    const trashCan =  document.createElement("div");
-    trashCan.classList.add("trash-can");
-    trashCan.style.display = "none";
-    this.uploadItems.parentElement.appendChild(trashCan);
-    return trashCan;
-  }
-  cleanTrashCan() {
-    Array.from(this.trashCan.children).forEach((item) => {
-      const fileName = item.dataset.filename;
-      const activeAttachment = this.activeAttachments.querySelector(`div[data-filename='${fileName}']`);
-      if (activeAttachment) {
-        activeAttachment.remove();
-      }
-      item.remove();
-    })
-  }
-}

--- a/decidim-core/app/packs/src/decidim/editor.js
+++ b//dev/null
@@ -1,128 +0,0 @@
-/* eslint-disable require-jsdoc */
-import lineBreakButtonHandler from "src/decidim/editor/linebreak_module";
-import "src/decidim/editor/clipboard_override";
-import "src/decidim/vendor/image-resize.min";
-import "src/decidim/vendor/image-upload.min";
-const quillFormats = [
-  "bold",
-  "italic",
-  "link",
-  "underline",
-  "header",
-  "list",
-  "alt",
-  "break",
-  "width",
-  "style",
-  "code",
-  "blockquote",
-  "indent"
-];
-export default function createQuillEditor(container) {
-  const toolbar = $(container).data("toolbar");
-  const disabled = $(container).data("disabled");
-  const allowedEmptyContentSelector = "iframe";
-  let quillToolbar = [
-    ["bold", "italic", "underline", "linebreak"],
-    [{ list: "ordered" }, { list: "bullet" }],
-    ["link", "clean"],
-    ["code", "blockquote"],
-    [{ indent: "-1" }, { indent: "+1" }]
-  ];
-  let addImage = false;
-  let addVideo = false;
-  /**
-   * - basic = only basic controls without titles
-   * - content = basic + headings
-   * - full = basic + headings + image + video
-   */
-  if (toolbar === "content") {
-    quillToolbar = [[{ header: [2, 3, 4, 5, 6, false] }], ...quillToolbar];
-  } else if (toolbar === "full") {
-    addImage = true;
-    addVideo = true;
-    quillToolbar = [
-      [{ header: [2, 3, 4, 5, 6, false] }],
-      ...quillToolbar,
-      ["video"],
-      ["image"]
-    ];
-  }
-  let modules = {
-    linebreak: {},
-    toolbar: {
-      container: quillToolbar,
-      handlers: {
-        linebreak: lineBreakButtonHandler
-      }
-    }
-  };
-  const $input = $(container).siblings('input[type="hidden"]');
-  container.innerHTML = $input.val() || "";
-  const token = $('meta[name="csrf-token"]').attr("content");
-  if (addVideo) {
-    quillFormats.push("video");
-  }
-  if (addImage) {
-    quillFormats.push("image");
-    modules.imageResize = {
-      modules: ["Resize", "DisplaySize"]
-    };
-    modules.imageUpload = {
-      url: $(container).data("uploadImagesPath"),
-      method: "POST",
-      name: "image",
-      withCredentials: false,
-      headers: { "X-CSRF-Token": token },
-      callbackOK: (serverResponse, next) => {
-        $("div.ql-toolbar").last().removeClass("editor-loading");
-        next(serverResponse.url);
-      },
-      callbackKO: (serverError) => {
-        $("div.ql-toolbar").last().removeClass("editor-loading");
-        console.log(`Image upload error: ${serverError.message}`);
-      },
-      checkBeforeSend: (file, next) => {
-        $("div.ql-toolbar").last().addClass("editor-loading");
-        next(file);
-      }
-    };
-    const text = $(container).data("dragAndDropHelpText");
-    $(container).after(
-      `<p class="help-text" style="margin-top:-1.5rem;">${text}</p>`
-    );
-  }
-  const quill = new Quill(container, {
-    modules: modules,
-    formats: quillFormats,
-    theme: "snow"
-  });
-  if (addImage === false) {
-    quill.root.addEventListener("drop", (ev) => ev.preventDefault());
-  }
-  if (disabled) {
-    quill.disable();
-  }
-  quill.on("text-change", () => {
-    const text = quill.getText();
-    let event = new CustomEvent("quill-position", {
-      detail: quill.getSelection()
-    });
-    container.dispatchEvent(event);
-    if (
-      (text === "\n" || text === "\n\n") &&
-      quill.root.querySelectorAll(allowedEmptyContentSelector).length === 0
-    ) {
-      $input.val("");
-    } else {
-      const emptyParagraph = "<p><br></p>";
-      const cleanHTML = quill.root.innerHTML.replace(
-        new RegExp(`^${emptyParagraph}|${emptyParagraph}$`, "g"),
-        ""
-      );
-      $input.val(cleanHTML);
-    }
-  });
-  quill.emitter.emit("editor-ready");
-  return quill;
-}

--- a/decidim-core/app/packs/src/decidim/editor/clipboard_override.js
+++ b//dev/null
@@ -1,128 +0,0 @@
-/* eslint max-lines: ["error", 350] */
-/**
- * Quill clipboard utilities
- *
- * Copyright (c) 2017, Slab
- * Copyright (c) 2014, Jason Chen
- * Copyright (c) 2013, salesforce.com
- * BSD 3-Clause "New" or "Revised" License
- *
- * Extends the original version from https://github.com/quilljs/quill
- * Relevant parts converted from TypeScript to JavaScript
- */
-import CodeBlock from "quill/formats/code";
-import { matchNewline, matchBreak, deltaEndsWith, traverse } from "src/decidim/editor/clipboard_utilities";
-const Delta = Quill.import("delta");
-const Clipboard = Quill.import("modules/clipboard");
-/**
- * Pasting bold text is broken in Quill as described at:
- * https://github.com/quilljs/quill/issues/306
- *
- * The reason is that the `<strong>` nodes are not recognized as bold types.
- * This override fixes the issue by introducing parts of the newer Quill code
- * at GitHub and defining the `<strong>` tags as bold tags.
- */
-export default class ClipboardOverride extends Clipboard {
-  constructor(quill, options) {
-    super(quill, options);
-    this.overrideMatcher("b", "b, strong");
-    this.overrideMatcher("br", "br", matchBreak);
-    this.matchers[1][1] = matchNewline;
-    this.matchers[3][1] = matchNewline;
-    this.removeMatcher(Node.ELEMENT_NODE, "matchSpacing");
-  }
-  overrideMatcher(originalSelector, newSelector, newMatcher = null) {
-    const idx = this.matchers.findIndex((item) => item[0] === originalSelector);
-    if (idx >= 0) {
-      this.matchers[idx][0] = newSelector;
-      if (newMatcher) {
-        this.matchers[idx][1] = newMatcher;
-      }
-    }
-  }
-  removeMatcher(selector, matcherName) {
-    const idx = this.matchers.findIndex((item) => item[0] === selector && item[1].name === matcherName);
-    if (idx >= 0) {
-      this.matchers.splice(idx, 1);
-    }
-  }
-  onPaste(ev) {
-    if (ev.defaultPrevented || !this.quill.isEnabled()) {
-      return;
-    }
-    ev.preventDefault();
-    const range = this.quill.getSelection(true);
-    if (range === null) {
-      return;
-    }
-    const html = ev.clipboardData.getData("text/html");
-    const text = ev.clipboardData.getData("text/plain");
-    const files = Array.from(ev.clipboardData.files || []);
-    if (!html && files.length > 0) {
-      if (typeof this.quill.uploader !== "undefined") {
-        this.quill.uploader.upload(range, files);
-      }
-      return;
-    }
-    if (html && files.length > 0) {
-      const doc = new DOMParser().parseFromString(html, "text/html");
-      if (
-        doc.body.childElementCount === 1 &&
-        doc.body.firstElementChild.tagName === "IMG"
-      ) {
-        if (typeof this.quill.uploader !== "undefined") {
-          this.quill.uploader.upload(range, files);
-        }
-        return;
-      }
-    }
-    this.onPasteRange(range, { html, text });
-  }
-  onPasteRange(range, { text, html }) {
-    const formats = this.quill.getFormat(range.index);
-    const pastedDelta = this.convertPaste({ text, html }, formats);
-    const delta = new Delta().retain(range.index).delete(range.length).concat(pastedDelta);
-    this.quill.updateContents(delta, Quill.sources.USER);
-    this.quill.setSelection(
-      delta.length() - range.length,
-      Quill.sources.SILENT,
-    );
-    this.quill.scrollIntoView();
-  }
-  convertPaste({ html, text }, formats = {}) {
-    if (formats[CodeBlock.blotName]) {
-      return new Delta().insert(text, {
-        [CodeBlock.blotName]: formats[CodeBlock.blotName]
-      });
-    }
-    if (!html) {
-      return new Delta().insert(text || "");
-    }
-    const delta = this.convertPasteHTML(html);
-    if (
-      deltaEndsWith(delta, "\n") &&
-      (delta.ops[delta.ops.length - 1].attributes === null || formats.table)
-    ) {
-      return delta.compose(new Delta().retain(delta.length() - 1).delete(1));
-    }
-    return delta;
-  }
-  convertPasteHTML(html) {
-    const doc = new DOMParser().parseFromString(html, "text/html");
-    const container = doc.body;
-    const nodeMatches = new WeakMap();
-    const [elementMatchers, textMatchers] = this.prepareMatching(
-      container,
-      nodeMatches
-    );
-    return traverse(
-      this.quill.scroll,
-      container,
-      elementMatchers,
-      textMatchers,
-      nodeMatches
-    );
-  }
-}
-Quill.debug("error");
-Quill.register({"modules/clipboard": ClipboardOverride}, true);

--- a/decidim-core/app/presenters/decidim/notification_presenter.rb
+++ b//dev/null
@@ -1,17 +0,0 @@
-module Decidim
-  class NotificationPresenter < SimpleDelegator
-    include ActionView::Helpers::DateHelper
-    delegate :resource_text, to: :event_class_instance
-    def created_at_in_words
-      if created_at.between?(1.month.ago, Time.current)
-        I18n.t("decidim.user_conversations.index.time_ago", time: time_ago_in_words(created_at))
-      else
-        format = created_at.year == Time.current.year ? :ddmm : :ddmmyyyy
-        I18n.l(created_at, format: format)
-      end
-    end
-    def display_resource_text?
-      event_class.constantize.included_modules.include?(Decidim::Comments::CommentEvent)
-    end
-  end
-end

--- a/decidim-core/app/presenters/decidim/notification_to_mailer_presenter.rb
+++ b//dev/null
@@ -1,30 +0,0 @@
-module Decidim
-  class NotificationToMailerPresenter < SimpleDelegator
-    include Decidim::TranslatableAttributes
-    delegate :url_helpers, to: "Decidim::Core::Engine.routes"
-    delegate :resource_title, to: :event
-    delegate :resource_url, to: :event
-    delegate :email_intro, to: :event
-    delegate :resource_path, to: :event
-    def date_time
-      if frequency == :daily
-        created_at.strftime("%H:%M")
-      else
-        I18n.l(created_at, format: :decidim_short)
-      end
-    end
-    private
-    def event
-      @event ||= event_class.constantize.new(
-        resource: resource,
-        user: user,
-        user_role: user_role,
-        event_name: event_name,
-        extra: extra
-      )
-    end
-    def frequency
-      @frequency ||= user.notifications_sending_frequency
-    end
-  end
-end

--- a/decidim-core/app/presenters/decidim/user_group_presenter.rb
+++ b//dev/null
@@ -1,23 +0,0 @@
-module Decidim
-  class UserGroupPresenter < UserPresenter
-    def deleted?
-      false
-    end
-    def badge
-      return "" unless verified?
-      "verified-badge"
-    end
-    def can_be_contacted?
-      true unless blocked?
-    end
-    def officialization_text
-      I18n.t("decidim.profiles.default_officialization_text_for_user_groups")
-    end
-    def can_follow?
-      false
-    end
-    def members_count
-      Decidim::UserGroups::AcceptedUsers.for(__getobj__).count
-    end
-  end
-end

--- a/decidim-core/app/presenters/decidim/user_presenter.rb
+++ b//dev/null
@@ -1,57 +0,0 @@
-module Decidim
-  class UserPresenter < SimpleDelegator
-    include ActionView::Helpers::UrlHelper
-    include Decidim::TranslatableAttributes
-    def nickname
-      return "" if __getobj__.blocked?
-      "@#{__getobj__.nickname}"
-    end
-    def badge
-      return "" unless officialized?
-      "verified-badge"
-    end
-    def profile_url
-      return "" if respond_to?(:deleted?) && deleted?
-      decidim.profile_url(__getobj__.nickname)
-    end
-    def avatar
-      attached_uploader(:avatar)
-    end
-    def avatar_url(variant = nil)
-      return default_avatar_url if __getobj__.blocked?
-      return default_avatar_url unless avatar.attached?
-      avatar.path(variant: variant)
-    end
-    def default_avatar_url
-      avatar.default_url
-    end
-    def profile_path
-      return "" if respond_to?(:deleted?) && deleted?
-      decidim.profile_path(__getobj__.nickname)
-    end
-    def direct_messages_enabled?(context)
-      return false unless __getobj__.respond_to?(:accepts_conversation?)
-      __getobj__.accepts_conversation?(context[:current_user])
-    end
-    def display_mention
-      link_to nickname, profile_url, class: "user-mention"
-    end
-    def can_be_contacted?
-      true unless blocked?
-    end
-    def officialization_text
-      translated_attribute(officialized_as).presence ||
-        I18n.t("decidim.profiles.default_officialization_text_for_users")
-    end
-    def can_follow?
-      true
-    end
-    def has_tooltip?
-      true
-    end
-    private
-    def decidim
-      @decidim ||= Decidim::EngineRouter.new("decidim", { host: __getobj__.organization.host })
-    end
-  end
-end

--- a/decidim-core/app/scrubbers/decidim/admin_input_scrubber.rb
+++ b//dev/null
@@ -1,12 +0,0 @@
-module Decidim
-  class AdminInputScrubber < UserInputScrubber
-    private
-    DECIDIM_ALLOWED_TAGS = %w(img video audio source comment iframe).freeze
-    def custom_allowed_attributes
-      super + %w(frameborder allowfullscreen) - %w(onerror)
-    end
-    def custom_allowed_tags
-      super + DECIDIM_ALLOWED_TAGS
-    end
-  end
-end

--- a/decidim-core/app/scrubbers/decidim/user_input_scrubber.rb
+++ b//dev/null
@@ -1,44 +0,0 @@
-module Decidim
-  class UserInputScrubber < Rails::Html::PermitScrubber
-    def initialize
-      super
-      self.tags = custom_allowed_tags
-      self.attributes = custom_allowed_attributes
-    end
-    private
-    RESTRICTED_TAGS = %w(
-      area
-      article
-      aside
-      audio
-      button
-      canvas
-      fieldset
-      figcaption
-      figure
-      font
-      footer
-      form
-      header
-      img
-      input
-      label
-      legend
-      main
-      map
-      menu
-      optgroup
-      option
-      output
-      select
-      textarea
-      video
-    ).freeze
-    def custom_allowed_attributes
-      Loofah::HTML5::SafeList::ALLOWED_ATTRIBUTES
-    end
-    def custom_allowed_tags
-      Loofah::HTML5::SafeList::ACCEPTABLE_ELEMENTS - RESTRICTED_TAGS
-    end
-  end
-end

--- a/decidim-core/app/services/decidim/traceability.rb
+++ b//dev/null
@@ -1,59 +0,0 @@
-module Decidim
-  class Traceability
-    def create(klass, author, params, extra_log_info = {})
-      perform_action!(:create, klass, author, extra_log_info) do
-        klass.create(params)
-      end
-    end
-    def create!(klass, author, params, extra_log_info = {})
-      perform_action!(:create, klass, author, extra_log_info) do
-        klass.create!(params)
-      end
-    end
-    def perform_action!(action, resource, author, extra_log_info = {})
-      PaperTrail.request(whodunnit: gid(author)) do
-        Decidim::ApplicationRecord.transaction do
-          result = block_given? ? yield : nil
-          loggable_resource = resource.is_a?(Class) ? result : resource
-          log(action, author, loggable_resource, extra_log_info)
-          result
-        end
-      end
-    end
-    def update!(resource, author, params, extra_log_info = {})
-      perform_action!(:update, resource, author, extra_log_info) do
-        resource.update!(params)
-        resource
-      end
-    end
-    def last_editor(resource)
-      version_editor(resource.versions.last)
-    end
-    def version_editor(version)
-      ::GlobalID::Locator.locate(version.whodunnit) || version.whodunnit
-    end
-    private
-    def gid(author)
-      return if author.blank?
-      return author.to_gid if author.respond_to?(:to_gid)
-      author
-    end
-    def log(action, user, resource, extra_log_info = {})
-      return unless user.is_a?(Decidim::User)
-      return if resource.nil?
-      return unless resource.valid?
-      Decidim::ActionLogger.log(
-        action,
-        user,
-        resource,
-        version_id(resource),
-        extra_log_info
-      )
-    end
-    def version_id(resource)
-      return nil unless resource.is_a?(Decidim::Traceable)
-      return nil if resource.versions.blank?
-      resource.versions.last.id
-    end
-  end
-end

--- a/decidim-core/app/validators/uploader_image_dimensions_validator.rb
+++ b//dev/null
@@ -1,40 +0,0 @@
-require "mini_magick"
-class UploaderImageDimensionsValidator < ActiveModel::Validations::FileContentTypeValidator
-  def validate_each(record, attribute, value)
-    begin
-      values = parse_values(value)
-    rescue JSON::ParserError
-      record.errors.add attribute, :invalid
-      return
-    end
-    return if values.empty?
-    uploader = record.attached_uploader(attribute) || record.send(attribute)
-    return unless uploader.is_a?(Decidim::ApplicationUploader)
-    values.each do |val|
-      validate_image_size(record, attribute, val, uploader)
-    end
-  end
-  def validate_image_size(record, attribute, file, uploader)
-    return unless uploader.validable_dimensions
-    return if (image = extract_image(file)).blank?
-    record.errors.add attribute, I18n.t("carrierwave.errors.file_resolution_too_large") if image.dimensions.any? { |dimension| dimension > uploader.max_image_height_or_width }
-  rescue MiniMagick::Error, MiniMagick::Invalid
-    record.errors.add attribute, I18n.t("carrierwave.errors.file_cannot_be_processed")
-  end
-  def extract_image(file)
-    return unless file.try(:content_type).to_s.start_with?("image")
-    if uploaded_file?(file)
-      MiniMagick::Image.new(file.path)
-    elsif file.is_a?(ActiveStorage::Attached) && file.blob.persisted?
-      MiniMagick::Image.read(file.blob.download)
-    end
-  rescue ActiveStorage::FileNotFoundError, MiniMagick::Invalid
-    nil
-  end
-  def check_validity!; end
-  private
-  def uploaded_file?(file)
-    return true if defined?(Rack::Test::UploadedFile) && file.is_a?(Rack::Test::UploadedFile)
-    file.is_a?(ActionDispatch::Http::UploadedFile)
-  end
-end
