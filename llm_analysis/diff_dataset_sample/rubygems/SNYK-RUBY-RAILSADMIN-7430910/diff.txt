--- a//dev/null
+++ b/app/controllers/rails_admin/application_controller.rb
@@ -0,0 +1,61 @@
+require 'rails_admin/abstract_model'
+module RailsAdmin
+  class ModelNotFound < ::StandardError
+  end
+  class ObjectNotFound < ::StandardError
+  end
+  class ActionNotAllowed < ::StandardError
+  end
+  class ApplicationController < Config.parent_controller.constantize
+    include RailsAdmin::Extensions::ControllerExtension
+    protect_from_forgery(Config.forgery_protection_settings)
+    before_action :_authenticate!
+    before_action :_authorize!
+    before_action :_audit!
+    helper_method :_current_user, :_get_plugin_name
+    attr_reader :object, :model_config, :abstract_model, :authorization_adapter
+    def get_model
+      @model_name = to_model_name(params[:model_name])
+      raise RailsAdmin::ModelNotFound unless (@abstract_model = RailsAdmin::AbstractModel.new(@model_name))
+      raise RailsAdmin::ModelNotFound if (@model_config = @abstract_model.config).excluded?
+      @properties = @abstract_model.properties
+    end
+    def get_object
+      raise RailsAdmin::ObjectNotFound unless (@object = @abstract_model.get(params[:id], @model_config.scope))
+    end
+    def to_model_name(param)
+      param.split('~').collect(&:camelize).join('::')
+    end
+    def _current_user
+      instance_eval(&RailsAdmin::Config.current_user_method)
+    end
+  private
+    def _get_plugin_name
+      @plugin_name_array ||= [RailsAdmin.config.main_app_name.is_a?(Proc) ? instance_eval(&RailsAdmin.config.main_app_name) : RailsAdmin.config.main_app_name].flatten
+    end
+    def _authenticate!
+      instance_eval(&RailsAdmin::Config.authenticate_with)
+    end
+    def _authorize!
+      instance_eval(&RailsAdmin::Config.authorize_with)
+    end
+    def _audit!
+      instance_eval(&RailsAdmin::Config.audit_with)
+    end
+    def rails_admin_controller?
+      true
+    end
+    rescue_from RailsAdmin::ObjectNotFound do
+      flash[:error] = I18n.t('admin.flash.object_not_found', model: @model_name, id: params[:id])
+      params[:action] = 'index'
+      @status_code = :not_found
+      index
+    end
+    rescue_from RailsAdmin::ModelNotFound do
+      flash[:error] = I18n.t('admin.flash.model_not_found', model: @model_name)
+      params[:action] = 'dashboard'
+      @status_code = :not_found
+      dashboard
+    end
+  end
+end

--- a//dev/null
+++ b/app/controllers/rails_admin/main_controller.rb
@@ -0,0 +1,129 @@
+module RailsAdmin
+  class MainController < RailsAdmin::ApplicationController
+    include ActionView::Helpers::TextHelper
+    include RailsAdmin::MainHelper
+    include RailsAdmin::ApplicationHelper
+    before_action :check_for_cancel
+    def bulk_action
+      get_model
+      process(params[:bulk_action]) if params[:bulk_action].in?(RailsAdmin::Config::Actions.all(:bulkable, controller: self, abstract_model: @abstract_model).collect(&:route_fragment))
+    end
+    def list_entries(model_config = @model_config, auth_scope_key = :index, additional_scope = get_association_scope_from_params, pagination = !(params[:associated_collection] || params[:all] || params[:bulk_ids]))
+      scope = model_config.scope
+      auth_scope = @authorization_adapter&.query(auth_scope_key, model_config.abstract_model)
+      scope = scope.merge(auth_scope) if auth_scope
+      scope = scope.instance_eval(&additional_scope) if additional_scope
+      get_collection(model_config, scope, pagination)
+    end
+  private
+    def action_missing(name, *_args)
+      action = RailsAdmin::Config::Actions.find(name.to_sym)
+      raise AbstractController::ActionNotFound.new("The action '#{name}' could not be found for #{self.class.name}") unless action
+      get_model unless action.root?
+      get_object if action.member?
+      @authorization_adapter.try(:authorize, action.authorization_key, @abstract_model, @object)
+      @action = action.with({controller: self, abstract_model: @abstract_model, object: @object})
+      raise(ActionNotAllowed) unless @action.enabled?
+      @page_name = wording_for(:title)
+      instance_eval(&@action.controller)
+    end
+    def method_missing(name, *args, &block)
+      action = RailsAdmin::Config::Actions.find(name.to_sym)
+      if action
+        action_missing name, *args, &block
+      else
+        super
+      end
+    end
+    def respond_to_missing?(sym, include_private)
+      if RailsAdmin::Config::Actions.find(sym)
+        true
+      else
+        super
+      end
+    end
+    def back_or_index
+      params[:return_to].presence && params[:return_to].include?(request.host) && (params[:return_to] != request.fullpath) ? params[:return_to] : index_path
+    end
+    def get_sort_hash(model_config)
+      abstract_model = model_config.abstract_model
+      field = model_config.list.fields.detect { |f| f.name.to_s == params[:sort] }
+      column =
+        if field.nil? || field.sortable == false # use default sort, asked field does not exist or is not sortable
+          field = model_config.list.possible_fields.detect { |f| f.name == model_config.list.sort_by.to_sym }
+          "#{abstract_model.table_name}.#{model_config.list.sort_by}"
+        elsif field.sortable == true # use the given field
+          "#{abstract_model.table_name}.#{field.name}"
+        elsif (field.sortable.is_a?(String) || field.sortable.is_a?(Symbol)) && field.sortable.to_s.include?('.') # just provide sortable, don't do anything smart
+          field.sortable
+        elsif field.sortable.is_a?(Hash) # just join sortable hash, don't do anything smart
+          "#{field.sortable.keys.first}.#{field.sortable.values.first}"
+        elsif field.association? # use column on target table
+          "#{field.associated_model_config.abstract_model.table_name}.#{field.sortable}"
+        else # use described column in the field conf.
+          "#{abstract_model.table_name}.#{field.sortable}"
+        end
+      params[:sort_reverse] ||= 'false'
+      {sort: column, sort_reverse: (params[:sort_reverse] == (field&.sort_reverse&.to_s || 'true'))}
+    end
+    def redirect_to_on_success
+      notice = I18n.t('admin.flash.successful', name: @model_config.label, action: I18n.t("admin.actions.#{@action.key}.done"))
+      if params[:_add_another]
+        redirect_to new_path(return_to: params[:return_to]), flash: {success: notice}
+      elsif params[:_add_edit]
+        redirect_to edit_path(id: @object.id, return_to: params[:return_to]), flash: {success: notice}
+      else
+        redirect_to back_or_index, flash: {success: notice}
+      end
+    end
+    def visible_fields(action, model_config = @model_config)
+      model_config.send(action).with(controller: self, view: view_context, object: @object).visible_fields
+    end
+    def sanitize_params_for!(action, model_config = @model_config, target_params = params[@abstract_model.param_key])
+      return unless target_params.present?
+      fields = visible_fields(action, model_config)
+      allowed_methods = fields.collect(&:allowed_methods).flatten.uniq.collect(&:to_s) << 'id' << '_destroy'
+      fields.each { |field| field.parse_input(target_params) }
+      target_params.slice!(*allowed_methods)
+      target_params.permit! if target_params.respond_to?(:permit!)
+      fields.select(&:nested_form).each do |association|
+        children_params = association.multiple? ? target_params[association.method_name].try(:values) : [target_params[association.method_name]].compact
+        (children_params || []).each do |children_param|
+          sanitize_params_for!(:nested, association.associated_model_config, children_param)
+        end
+      end
+    end
+    def handle_save_error(whereto = :new)
+      flash.now[:error] = I18n.t('admin.flash.error', name: @model_config.label, action: I18n.t("admin.actions.#{@action.key}.done").html_safe).html_safe
+      flash.now[:error] += %(<br>- #{@object.errors.full_messages.join('<br>- ')}).html_safe
+      respond_to do |format|
+        format.html { render whereto, status: :not_acceptable }
+        format.js   { render whereto, layout: 'rails_admin/modal', status: :not_acceptable, content_type: Mime[:html].to_s }
+      end
+    end
+    def check_for_cancel
+      return unless params[:_continue] || (params[:bulk_action] && !params[:bulk_ids])
+      redirect_to(back_or_index, notice: I18n.t('admin.flash.noaction'))
+    end
+    def get_collection(model_config, scope, pagination)
+      eager_loads = model_config.list.fields.flat_map(&:eager_load_values)
+      options = {}
+      options = options.merge(page: (params[Kaminari.config.param_name] || 1).to_i, per: (params[:per] || model_config.list.items_per_page)) if pagination
+      options = options.merge(include: eager_loads) unless eager_loads.blank?
+      options = options.merge(get_sort_hash(model_config))
+      options = options.merge(query: params[:query]) if params[:query].present?
+      options = options.merge(filters: params[:f]) if params[:f].present?
+      options = options.merge(bulk_ids: params[:bulk_ids]) if params[:bulk_ids]
+      model_config.abstract_model.all(options, scope)
+    end
+    def get_association_scope_from_params
+      return nil unless params[:associated_collection].present?
+      source_abstract_model = RailsAdmin::AbstractModel.new(to_model_name(params[:source_abstract_model]))
+      source_model_config = source_abstract_model.config
+      source_object = source_abstract_model.get(params[:source_object_id])
+      action = params[:current_action].in?(%w[create update]) ? params[:current_action] : 'edit'
+      @association = source_model_config.send(action).fields.detect { |f| f.name == params[:associated_collection].to_sym }.with(controller: self, object: source_object)
+      @association.associated_collection_scope
+    end
+  end
+end

--- a//dev/null
+++ b/app/helpers/rails_admin/application_helper.rb
@@ -0,0 +1,197 @@
+module RailsAdmin
+  module ApplicationHelper
+    def authorized?(action_name, abstract_model = nil, object = nil)
+      object = nil if object.try :new_record?
+      action(action_name, abstract_model, object).try(:authorized?)
+    end
+    def current_action?(action, abstract_model = @abstract_model, object = @object)
+      @action.custom_key == action.custom_key &&
+        abstract_model.try(:to_param) == @abstract_model.try(:to_param) &&
+        (@object.try(:persisted?) ? @object.id == object.try(:id) : !object.try(:persisted?))
+    end
+    def action(key, abstract_model = nil, object = nil)
+      RailsAdmin::Config::Actions.find(key, controller: controller, abstract_model: abstract_model, object: object)
+    end
+    def actions(scope = :all, abstract_model = nil, object = nil)
+      RailsAdmin::Config::Actions.all(scope, controller: controller, abstract_model: abstract_model, object: object)
+    end
+    def edit_user_link
+      return nil unless _current_user.try(:email).present?
+      return nil unless (abstract_model = RailsAdmin.config(_current_user.class).abstract_model)
+      edit_action = action(:edit, abstract_model, _current_user)
+      authorized = edit_action.try(:authorized?)
+      content = edit_user_link_label
+      if authorized
+        edit_url = rails_admin.url_for(
+          action_name: edit_action.action_name,
+          model_name: abstract_model.to_param,
+          controller: 'rails_admin/main',
+          id: _current_user.id,
+        )
+        link_to content, edit_url, class: 'nav-link'
+      else
+        content_tag :span, content, class: 'nav-link'
+      end
+    end
+    def logout_path
+      if defined?(Devise)
+        scope = Devise::Mapping.find_scope!(_current_user)
+        begin
+          main_app.send("destroy_#{scope}_session_path")
+        rescue StandardError
+          false
+        end
+      elsif main_app.respond_to?(:logout_path)
+        main_app.logout_path
+      end
+    end
+    def logout_method
+      return [Devise.sign_out_via].flatten.first if defined?(Devise)
+      :delete
+    end
+    def wording_for(label, action = @action, abstract_model = @abstract_model, object = @object)
+      model_config = abstract_model.try(:config)
+      object = nil unless abstract_model && object.is_a?(abstract_model.model)
+      action = RailsAdmin::Config::Actions.find(action.to_sym) if action.is_a?(Symbol) || action.is_a?(String)
+      I18n.t(
+        "admin.actions.#{action.i18n_key}.#{label}",
+        model_label: model_config&.label,
+        model_label_plural: model_config&.label_plural,
+        object_label: model_config && object.try(model_config.object_label_method),
+      )
+    end
+    def main_navigation
+      nodes_stack = RailsAdmin::Config.visible_models(controller: controller)
+      node_model_names = nodes_stack.collect { |c| c.abstract_model.model_name }
+      parent_groups = nodes_stack.group_by { |n| n.parent&.to_s }
+      nodes_stack.group_by(&:navigation_label).collect do |navigation_label, nodes|
+        nodes = nodes.select { |n| n.parent.nil? || !n.parent.to_s.in?(node_model_names) }
+        li_stack = navigation parent_groups, nodes
+        label = navigation_label || t('admin.misc.navigation')
+        %(<li class='dropdown-header'>#{label}</li>#{li_stack}) if li_stack.present?
+      end.join.html_safe
+    end
+    def root_navigation
+      actions(:root).select(&:show_in_sidebar).group_by(&:sidebar_label).collect do |label, nodes|
+        li_stack = nodes.map do |node|
+          url = rails_admin.url_for(action: node.action_name, controller: 'rails_admin/main')
+          nav_icon = node.link_icon ? %(<i class="#{node.link_icon}"></i>).html_safe : ''
+          content_tag :li do
+            link_to nav_icon + " " + wording_for(:menu, node), url, class: "nav-link"
+          end
+        end.join.html_safe
+        label ||= t('admin.misc.root_navigation')
+        %(<li class='dropdown-header'>#{label}</li>#{li_stack}) if li_stack.present?
+      end.join.html_safe
+    end
+    def static_navigation
+      li_stack = RailsAdmin::Config.navigation_static_links.collect do |title, url|
+        content_tag(:li, link_to(title.to_s, url, target: '_blank', rel: 'noopener noreferrer', class: 'nav-link'))
+      end.join
+      label = RailsAdmin::Config.navigation_static_label || t('admin.misc.navigation_static_label')
+      li_stack = %(<li class='dropdown-header'>#{label}</li>#{li_stack}).html_safe if li_stack.present?
+      li_stack
+    end
+    def navigation(parent_groups, nodes, level = 0)
+      nodes.collect do |node|
+        abstract_model = node.abstract_model
+        model_param = abstract_model.to_param
+        url         = rails_admin.url_for(action: :index, controller: 'rails_admin/main', model_name: model_param)
+        level_class = " nav-level-#{level}" if level > 0
+        nav_icon = node.navigation_icon ? %(<i class="#{node.navigation_icon}"></i>).html_safe : ''
+        li = content_tag :li, data: {model: model_param} do
+          link_to nav_icon + node.label_plural, url, class: "nav-link#{level_class}"
+        end
+        child_nodes = parent_groups[abstract_model.model_name]
+        child_nodes ? li + navigation(parent_groups, child_nodes, level + 1) : li
+      end.join.html_safe
+    end
+    def breadcrumb(action = @action, _acc = [])
+      begin
+        (parent_actions ||= []) << action
+      end while action.breadcrumb_parent && (action = action(*action.breadcrumb_parent)) # rubocop:disable Lint/Loop
+      content_tag(:ol, class: 'breadcrumb') do
+        parent_actions.collect do |a|
+          am = a.send(:eval, 'bindings[:abstract_model]')
+          o = a.send(:eval, 'bindings[:object]')
+          content_tag(:li, class: ['breadcrumb-item', current_action?(a, am, o) && 'active']) do
+            if current_action?(a, am, o)
+              wording_for(:breadcrumb, a, am, o)
+            elsif a.http_methods.include?(:get)
+              link_to rails_admin.url_for(action: a.action_name, controller: 'rails_admin/main', model_name: am.try(:to_param), id: (o.try(:persisted?) && o.try(:id) || nil)) do
+                wording_for(:breadcrumb, a, am, o)
+              end
+            else
+              content_tag(:span, wording_for(:breadcrumb, a, am, o))
+            end
+          end
+        end.reverse.join.html_safe
+      end
+    end
+    def menu_for(parent, abstract_model = nil, object = nil, only_icon = false)
+      actions = actions(parent, abstract_model, object).select { |a| a.http_methods.include?(:get) && a.show_in_menu }
+      actions.collect do |action|
+        wording = wording_for(:menu, action)
+        li_class = ['nav-item', 'icon', "#{action.key}_#{parent}_link"].
+                   concat(action.enabled? ? [] : ['disabled'])
+        content_tag(:li, {class: li_class}.merge(only_icon ? {title: wording, rel: 'tooltip'} : {})) do
+          label = content_tag(:i, '', {class: action.link_icon}) + ' ' + content_tag(:span, wording, (only_icon ? {style: 'display:none'} : {}))
+          if action.enabled? || !only_icon
+            href =
+              if action.enabled?
+                rails_admin.url_for(action: action.action_name, controller: 'rails_admin/main', model_name: abstract_model.try(:to_param), id: (object.try(:persisted?) && object.try(:id) || nil))
+              else
+                'javascript:void(0)'
+              end
+            content_tag(:a, label, {href: href, target: action.link_target, class: ['nav-link', current_action?(action) && 'active', !action.enabled? && 'disabled'].compact}.merge(action.turbo? ? {} : {data: {turbo: 'false'}}))
+          else
+            content_tag(:span, label)
+          end
+        end
+      end.join(' ').html_safe
+    end
+    def bulk_menu(abstract_model = @abstract_model)
+      actions = actions(:bulkable, abstract_model)
+      return '' if actions.empty?
+      content_tag :li, class: 'nav-item dropdown dropdown-menu-end' do
+        content_tag(:a, class: 'nav-link dropdown-toggle', data: {'bs-toggle': 'dropdown'}, href: '#') { t('admin.misc.bulk_menu_title').html_safe + ' ' + '<b class="caret"></b>'.html_safe } +
+          content_tag(:ul, class: 'dropdown-menu', style: 'left:auto; right:0;') do
+            actions.collect do |action|
+              content_tag :li do
+                link_to wording_for(:bulk_link, action, abstract_model), '#', class: 'dropdown-item bulk-link', data: {action: action.action_name}
+              end
+            end.join.html_safe
+          end
+      end.html_safe
+    end
+    def flash_alert_class(flash_key)
+      case flash_key.to_s
+      when 'error'  then 'alert-danger'
+      when 'alert'  then 'alert-warning'
+      when 'notice' then 'alert-info'
+      else "alert-#{flash_key}"
+      end
+    end
+    def handle_asset_dependency_error
+      yield
+    rescue LoadError => e
+      if /sassc/.match?(e.message)
+        e = e.exception <<-MSG.gsub(/^\s{10}/, '')
+          RailsAdmin requires the gem sassc-rails, make sure to put `gem 'sassc-rails'` to Gemfile.
+        MSG
+      end
+      raise e
+    end
+  private
+    def edit_user_link_label
+      [
+        RailsAdmin::Config.show_gravatar &&
+          image_tag(gravatar_url(_current_user.email), alt: ''),
+        content_tag(:span, _current_user.email),
+      ].filter(&:present?).join.html_safe
+    end
+    def gravatar_url(email)
+      "https://secure.gravatar.com/avatar/#{Digest::MD5.hexdigest email}?s=30"
+    end
+  end
+end

--- a//dev/null
+++ b/app/helpers/rails_admin/form_builder.rb
@@ -0,0 +1,123 @@
+require 'nested_form/builder_mixin'
+module RailsAdmin
+  class FormBuilder < ::ActionView::Helpers::FormBuilder
+    include ::NestedForm::BuilderMixin
+    include ::RailsAdmin::ApplicationHelper
+    def generate(options = {})
+      without_field_error_proc_added_div do
+        options.reverse_merge!(
+          action: @template.controller.params[:action],
+          model_config: @template.instance_variable_get(:@model_config),
+          nested_in: false,
+        )
+        object_infos +
+          visible_groups(options[:model_config], generator_action(options[:action], options[:nested_in])).collect do |fieldset|
+            fieldset_for fieldset, options[:nested_in]
+          end.join.html_safe +
+          (options[:nested_in] ? '' : @template.render(partial: 'rails_admin/main/submit_buttons'))
+      end
+    end
+    def fieldset_for(fieldset, nested_in)
+      fields = fieldset.with(
+        form: self,
+        object: @object,
+        view: @template,
+        controller: @template.controller,
+      ).visible_fields
+      return if fields.empty?
+      @template.content_tag :fieldset do
+        contents = []
+        contents << @template.content_tag(:legend, %(<i class="fas fa-chevron-#{fieldset.active? ? 'down' : 'right'}"></i> #{fieldset.label}).html_safe, style: fieldset.name == :default ? 'display:none' : '')
+        contents << @template.content_tag(:p, fieldset.help) if fieldset.help.present?
+        contents << fields.collect { |field| field_wrapper_for(field, nested_in) }.join
+        contents.join.html_safe
+      end
+    end
+    def field_wrapper_for(field, nested_in)
+      return if nested_field_association?(field, nested_in)
+      @template.content_tag(:div, class: "control-group row mb-3 #{field.type_css_class} #{field.css_class} #{'error' if field.errors.present?}", id: "#{dom_id(field)}_field") do
+        if field.label
+          label(field.method_name, field.label, class: 'col-sm-2 col-form-label text-md-end') +
+            (field.nested_form ? field_for(field) : input_for(field))
+        else
+          field.nested_form ? field_for(field) : input_for(field)
+        end
+      end
+    end
+    def input_for(field)
+      css = 'col-sm-10 controls'
+      css += ' has-error' if field.errors.present?
+      @template.content_tag(:div, class: css) do
+        field_for(field) +
+          errors_for(field) +
+          help_for(field)
+      end
+    end
+    def errors_for(field)
+      field.errors.present? ? @template.content_tag(:span, field.errors.to_sentence, class: 'help-inline text-danger') : ''.html_safe
+    end
+    def help_for(field)
+      field.help.present? ? @template.content_tag(:div, field.help, class: 'form-text') : ''.html_safe
+    end
+    def field_for(field)
+      field.read_only? ? @template.content_tag(:div, field.pretty_value, class: 'form-control-static') : field.render
+    end
+    def object_infos
+      model_config = RailsAdmin.config(object)
+      model_label = model_config.label
+      object_label =
+        if object.new_record?
+          I18n.t('admin.form.new_model', name: model_label)
+        else
+          object.send(model_config.object_label_method).presence || "#{model_config.label} ##{object.id}"
+        end
+      %(<span style="display:none" class="object-infos" data-model-label="#{model_label}" data-object-label="#{CGI.escapeHTML(object_label.to_s)}"></span>).html_safe
+    end
+    def jquery_namespace(field)
+      %(#{'#modal ' if @template.controller.params[:modal]}##{dom_id(field)}_field)
+    end
+    def dom_id(field)
+      (@dom_id ||= {})[field.name] ||=
+        [
+          @object_name.to_s.gsub(/\]\[|[^-a-zA-Z0-9:.]/, '_').sub(/_$/, ''),
+          options[:index],
+          field.method_name,
+        ].reject(&:blank?).join('_')
+    end
+    def dom_name(field)
+      (@dom_name ||= {})[field.name] ||= %(#{@object_name}#{options[:index] && "[#{options[:index]}]"}[#{field.method_name}]#{field.is_a?(Config::Fields::Association) && field.multiple? ? '[]' : ''})
+    end
+  protected
+    def generator_action(action, nested)
+      if nested
+        action = :nested
+      elsif @template.request.format == 'text/javascript'
+        action = :modal
+      end
+      action
+    end
+    def visible_groups(model_config, action)
+      model_config.send(action).with(
+        form: self,
+        object: @object,
+        view: @template,
+        controller: @template.controller,
+      ).visible_groups
+    end
+    def without_field_error_proc_added_div
+      default_field_error_proc = ::ActionView::Base.field_error_proc
+      begin
+        ::ActionView::Base.field_error_proc = proc { |html_tag, _instance| html_tag }
+        yield
+      ensure
+        ::ActionView::Base.field_error_proc = default_field_error_proc
+      end
+    end
+  private
+    def nested_field_association?(field, nested_in)
+      field.inverse_of.presence && nested_in.presence && field.inverse_of == nested_in.name &&
+        (@template.instance_variable_get(:@model_config).abstract_model == field.abstract_model ||
+         field.name == nested_in.inverse_of)
+    end
+  end
+end

--- a//dev/null
+++ b/app/helpers/rails_admin/main_helper.rb
@@ -0,0 +1,61 @@
+module RailsAdmin
+  module MainHelper
+    def rails_admin_form_for(*args, &block)
+      options = args.extract_options!.reverse_merge(builder: RailsAdmin::FormBuilder)
+      (options[:html] ||= {})[:novalidate] ||= !RailsAdmin::Config.browser_validations
+      form_for(*(args << options), &block) << after_nested_form_callbacks
+    end
+    def get_indicator(percent)
+      return '' if percent < 0          # none
+      return 'info' if percent < 34     # < 1/100 of max
+      return 'success' if percent < 67  # < 1/10 of max
+      return 'warning' if percent < 84  # < 1/3 of max
+      'danger'                          # > 1/3 of max
+    end
+    def filterable_fields
+      @filterable_fields ||= @model_config.list.fields.select(&:filterable?)
+    end
+    def ordered_filters
+      return @ordered_filters if @ordered_filters.present?
+      @index = 0
+      @ordered_filters = (params[:f].try(:permit!).try(:to_h) || @model_config.list.filters).inject({}) do |memo, filter|
+        field_name = filter.is_a?(Array) ? filter.first : filter
+        (filter.is_a?(Array) ? filter.last : {(@index += 1) => {'v' => ''}}).each do |index, filter_hash|
+          if filter_hash['disabled'].blank?
+            memo[index] = {field_name => filter_hash}
+          else
+            params[:f].delete(field_name)
+          end
+        end
+        memo
+      end.to_a.sort_by(&:first)
+    end
+    def ordered_filter_options
+      if ordered_filters
+        @ordered_filter_options ||= ordered_filters.map do |duplet|
+          options = {index: duplet[0]}
+          filter_for_field = duplet[1]
+          filter_name = filter_for_field.keys.first
+          filter_hash = filter_for_field.values.first
+          unless (field = filterable_fields.find { |f| f.name == filter_name.to_sym })
+            raise "#{filter_name} is not currently filterable; filterable fields are #{filterable_fields.map(&:name).join(', ')}"
+          end
+          case field.type
+          when :enum
+            options[:select_options] = options_for_select(field.with(object: @abstract_model.model.new).enum, filter_hash['v'])
+          when :date, :datetime, :time
+            options[:datetimepicker_options] = field.datepicker_options
+          end
+          options[:label] = field.label
+          options[:name]  = field.name
+          options[:type]  = field.type
+          options[:value] = filter_hash['v']
+          options[:label] = field.label
+          options[:operator] = filter_hash['o'] || field.default_filter_operator
+          options[:required] = field.required
+          options
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/config/initializers/active_record_extensions.rb
@@ -0,0 +1,21 @@
+ActiveSupport.on_load(:active_record) do
+  module ActiveRecord
+    class Base
+      def self.rails_admin(&block)
+        RailsAdmin.config do |config|
+          config.model(self, &block)
+        end
+      end
+      def rails_admin_default_object_label_method
+        new_record? ? "new #{self.class}" : "#{self.class} ##{id}"
+      end
+      def safe_send(value)
+        if has_attribute?(value)
+          read_attribute(value)
+        else
+          send(value)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/config/initializers/mongoid_extensions.rb
@@ -0,0 +1,4 @@
+if defined?(::Mongoid::Document)
+  require 'rails_admin/adapters/mongoid/extension'
+  Mongoid::Document.include RailsAdmin::Adapters::Mongoid::Extension
+end

--- a//dev/null
+++ b/lib/generators/rails_admin/install_generator.rb
@@ -0,0 +1,59 @@
+require 'rails/generators'
+require 'rails_admin/version'
+require File.expand_path('utils', __dir__)
+module RailsAdmin
+  class InstallGenerator < Rails::Generators::Base
+    source_root File.expand_path('templates', __dir__)
+    include Generators::Utils::InstanceMethods
+    argument :_namespace, type: :string, required: false, desc: 'RailsAdmin url namespace'
+    class_option :asset, type: :string, required: false, default: nil, desc: 'Asset delivery method [options: webpacker, sprockets]'
+    desc 'RailsAdmin installation generator'
+    def install
+      if File.read(File.join(destination_root, 'config/routes.rb')).include?('mount RailsAdmin::Engine')
+        display "Skipped route addition, since it's already there"
+      else
+        namespace = ask_for('Where do you want to mount rails_admin?', 'admin', _namespace)
+        route("mount RailsAdmin::Engine => '/#{namespace}', as: 'rails_admin'")
+      end
+      if File.exist? File.join(destination_root, 'config/initializers/rails_admin.rb')
+        insert_into_file 'config/initializers/rails_admin.rb', "  config.asset_source = :#{asset}\n", after: "RailsAdmin.config do |config|\n"
+      else
+        template 'initializer.erb', 'config/initializers/rails_admin.rb'
+      end
+      display "Using [#{asset}] for asset delivery method"
+      case asset
+      when 'webpack'
+        configure_for_webpack
+      when 'webpacker'
+        configure_for_webpacker5
+      when 'sprockets'
+        configure_for_sprockets
+      end
+    end
+  private
+    def asset
+      return options['asset'] if options['asset']
+      if defined?(Webpacker)
+        'webpacker'
+      else
+        'sprockets'
+      end
+    end
+    def configure_for_sprockets
+      gem 'sassc-rails'
+    end
+    def configure_for_webpacker5
+      run "yarn add rails_admin@#{RailsAdmin::Version.js}"
+      @scss_relative_dir = '../stylesheets/'
+      template 'rails_admin.js.erb', 'app/javascript/packs/rails_admin.js'
+      template 'rails_admin.scss', 'app/javascript/stylesheets/rails_admin.scss'
+    end
+    def configure_for_webpack
+      run "yarn add rails_admin@#{RailsAdmin::Version.js} css-loader mini-css-extract-plugin sass sass-loader"
+      @scss_relative_dir = './'
+      template 'rails_admin.js.erb', 'app/javascript/rails_admin.js'
+      template 'rails_admin.scss', 'app/javascript/rails_admin.scss'
+      template 'webpack.config.js', 'webpack.config.js'
+    end
+  end
+end

--- a//dev/null
+++ b/lib/generators/rails_admin/templates/webpack.config.js
@@ -0,0 +1,28 @@
+const path    = require("path")
+const webpack = require('webpack')
+const MiniCssExtractPlugin = require("mini-css-extract-plugin")
+module.exports = {
+  mode: "production",
+  entry: {
+    application: "./app/javascript/application.js",
+    rails_admin: "./app/javascript/rails_admin.js",
+  },
+  output: {
+    filename: "[name].js",
+    path: path.resolve(__dirname, "app/assets/builds"),
+  },
+  module: {
+    rules: [
+      {
+        test: /.s?css$/,
+        use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
+      },
+    ],
+  },
+  plugins: [
+    new webpack.optimize.LimitChunkCountPlugin({
+      maxChunks: 1
+    }),
+    new MiniCssExtractPlugin(),
+  ]
+}

--- a//dev/null
+++ b/lib/rails_admin.rb
@@ -0,0 +1,38 @@
+require 'rails_admin/engine'
+require 'rails_admin/abstract_model'
+require 'rails_admin/config'
+require 'rails_admin/extension'
+require 'rails_admin/extensions/cancancan'
+require 'rails_admin/extensions/pundit'
+require 'rails_admin/extensions/paper_trail'
+require 'rails_admin/support/csv_converter'
+require 'rails_admin/support/hash_helper'
+require 'yaml'
+module RailsAdmin
+  def self.config(entity = nil, &block)
+    if entity
+      RailsAdmin::Config.model(entity, &block)
+    elsif block_given?
+      RailsAdmin::Config.apply(&block)
+    else
+      RailsAdmin::Config
+    end
+  end
+  begin
+    require 'safe_yaml/load'
+    def self.yaml_load(yaml)
+      SafeYAML.load(yaml)
+    end
+  rescue LoadError
+    if YAML.respond_to?(:safe_load)
+      def self.yaml_load(yaml)
+        YAML.safe_load(yaml)
+      end
+    else
+      raise LoadError.new "Safe-loading of YAML is not available. Please install 'safe_yaml' or install Psych 2.0+"
+    end
+  end
+  def self.yaml_dump(object)
+    YAML.dump(object)
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/abstract_model.rb
@@ -0,0 +1,212 @@
+require 'rails_admin/support/datetime'
+module RailsAdmin
+  class AbstractModel
+    cattr_accessor :all
+    attr_reader :adapter, :model_name
+    class << self
+      def reset
+        @@all = nil
+      end
+      def all(adapter = nil)
+        @@all ||= Config.models_pool.collect { |m| new(m) }.compact
+        adapter ? @@all.select { |m| m.adapter == adapter } : @@all
+      end
+      alias_method :old_new, :new
+      def new(m)
+        m = m.constantize unless m.is_a?(Class)
+        (am = old_new(m)).model && am.adapter ? am : nil
+      rescue *([LoadError, NameError] + (defined?(ActiveRecord) ? ['ActiveRecord::NoDatabaseError'.constantize, 'ActiveRecord::ConnectionNotEstablished'.constantize] : []))
+        puts "[RailsAdmin] Could not load model #{m}, assuming model is non existing. (#{$ERROR_INFO})" unless Rails.env.test?
+        nil
+      end
+      @@polymorphic_parents = {}
+      def polymorphic_parents(adapter, model_name, name)
+        @@polymorphic_parents[adapter.to_sym] ||= {}.tap do |hash|
+          all(adapter).each do |am|
+            am.associations.select(&:as).each do |association|
+              (hash[[association.klass.to_s.underscore, association.as].join('_').to_sym] ||= []) << am.model
+            end
+          end
+        end
+        @@polymorphic_parents[adapter.to_sym][[model_name.to_s.underscore, name].join('_').to_sym]
+      end
+      def reset_polymorphic_parents
+        @@polymorphic_parents = {}
+      end
+    end
+    def initialize(model_or_model_name)
+      @model_name = model_or_model_name.to_s
+      ancestors = model.ancestors.collect(&:to_s)
+      if ancestors.include?('ActiveRecord::Base') && !model.abstract_class? && model.table_exists?
+        initialize_active_record
+      elsif ancestors.include?('Mongoid::Document')
+        initialize_mongoid
+      end
+    end
+    def model
+      @model_name.constantize
+    end
+    def to_s
+      model.to_s
+    end
+    def config
+      Config.model self
+    end
+    def to_param
+      @model_name.split('::').collect(&:underscore).join('~')
+    end
+    def param_key
+      @model_name.split('::').collect(&:underscore).join('_')
+    end
+    def pretty_name
+      model.model_name.human
+    end
+    def where(conditions)
+      model.where(conditions)
+    end
+    def each_associated_children(object)
+      associations.each do |association|
+        case association.type
+        when :has_one
+          child = object.send(association.name)
+          yield(association, [child]) if child
+        when :has_many
+          children = object.send(association.name)
+          yield(association, Array.new(children))
+        end
+      end
+    end
+  private
+    def initialize_active_record
+      @adapter = :active_record
+      require 'rails_admin/adapters/active_record'
+      extend Adapters::ActiveRecord
+    end
+    def initialize_mongoid
+      @adapter = :mongoid
+      require 'rails_admin/adapters/mongoid'
+      extend Adapters::Mongoid
+    end
+    def parse_field_value(field, value)
+      value.is_a?(Array) ? value.map { |v| field.parse_value(v) } : field.parse_value(value)
+    end
+    class StatementBuilder
+      def initialize(column, type, value, operator)
+        @column = column
+        @type = type
+        @value = value
+        @operator = operator
+      end
+      def to_statement
+        return if [@operator, @value].any? { |v| v == '_discard' }
+        unary_operators[@operator] || unary_operators[@value] ||
+          build_statement_for_type_generic
+      end
+    protected
+      def get_filtering_duration
+        FilteringDuration.new(@operator, @value).get_duration
+      end
+      def build_statement_for_type_generic
+        build_statement_for_type || begin
+          case @type
+          when :date
+            build_statement_for_date
+          when :datetime, :timestamp, :time
+            build_statement_for_datetime_or_timestamp
+          end
+        end
+      end
+      def build_statement_for_type
+        raise 'You must override build_statement_for_type in your StatementBuilder'
+      end
+      def build_statement_for_integer_decimal_or_float
+        case @value
+        when Array
+          val, range_begin, range_end = *@value.collect do |v|
+            next unless v.to_i.to_s == v || v.to_f.to_s == v
+            @type == :integer ? v.to_i : v.to_f
+          end
+          case @operator
+          when 'between'
+            range_filter(range_begin, range_end)
+          else
+            column_for_value(val) if val
+          end
+        else
+          if @value.to_i.to_s == @value || @value.to_f.to_s == @value
+            @type == :integer ? column_for_value(@value.to_i) : column_for_value(@value.to_f)
+          end
+        end
+      end
+      def build_statement_for_date
+        start_date, end_date = get_filtering_duration
+        if start_date
+          start_date = begin
+            start_date.to_date
+          rescue StandardError
+            nil
+          end
+        end
+        if end_date
+          end_date = begin
+            end_date.to_date
+          rescue StandardError
+            nil
+          end
+        end
+        range_filter(start_date, end_date)
+      end
+      def build_statement_for_datetime_or_timestamp
+        start_date, end_date = get_filtering_duration
+        start_date = start_date.beginning_of_day if start_date.is_a?(Date)
+        end_date = end_date.end_of_day if end_date.is_a?(Date)
+        range_filter(start_date, end_date)
+      end
+      def unary_operators
+        raise 'You must override unary_operators in your StatementBuilder'
+      end
+      def range_filter(_min, _max)
+        raise 'You must override range_filter in your StatementBuilder'
+      end
+      class FilteringDuration
+        def initialize(operator, value)
+          @value = value
+          @operator = operator
+        end
+        def get_duration
+          case @operator
+          when 'between'   then between
+          when 'today'     then today
+          when 'yesterday' then yesterday
+          when 'this_week' then this_week
+          when 'last_week' then last_week
+          else default
+          end
+        end
+        def today
+          [Date.today, Date.today]
+        end
+        def yesterday
+          [Date.yesterday, Date.yesterday]
+        end
+        def this_week
+          [Date.today.beginning_of_week, Date.today.end_of_week]
+        end
+        def last_week
+          [1.week.ago.to_date.beginning_of_week,
+           1.week.ago.to_date.end_of_week]
+        end
+        def between
+          [@value[1], @value[2]]
+        end
+        def default
+          [default_date, default_date]
+        end
+      private
+        def default_date
+          Array.wrap(@value).first
+        end
+      end
+    end
+  end
+end

--- a/lib/rails_admin/adapters/active_record.rb
+++ b/lib/rails_admin/adapters/active_record.rb
@@ -17,25 +17,25 @@
       def scoped
         model.all
       end
       def first(options = {}, scope = nil)
         all(options, scope).first
       end
       def all(options = {}, scope = nil)
         scope ||= scoped
         scope = scope.includes(options[:include]) if options[:include]
         scope = scope.limit(options[:limit]) if options[:limit]
-        scope = bulk_scope(scope, options) if options[:bulk_ids]
+        scope = scope.where(primary_key => options[:bulk_ids]) if options[:bulk_ids]
         scope = query_scope(scope, options[:query]) if options[:query]
         scope = filter_scope(scope, options[:filters]) if options[:filters]
         scope = scope.send(Kaminari.config.page_method_name, options[:page]).per(options[:per]) if options[:page] && options[:per]
-        scope = sort_scope(scope, options) if options[:sort]
+        scope = scope.reorder("#{options[:sort]} #{options[:sort_reverse] ? 'asc' : 'desc'}") if options[:sort]
         scope
       end
       def count(options = {}, scope = nil)
         all(options.merge(limit: false, page: false), scope).count(:all)
       end
       def destroy(objects)
         Array.wrap(objects).each(&:destroy)
       end
       def associations
         model.reflect_on_all_associations.collect do |association|
@@ -79,38 +79,20 @@
         end
       end
       def embedded?
         false
       end
       def cyclic?
         false
       end
       def adapter_supports_joins?
         true
-      end
-    private
-      def bulk_scope(scope, options)
-        scope.where(primary_key => options[:bulk_ids])
-      end
-      def sort_scope(scope, options)
-        direction = options[:sort_reverse] ? :asc : :desc
-        case options[:sort]
-        when String, Symbol
-          scope.reorder("#{options[:sort]} #{direction}")
-        when Array
-          scope.reorder(options[:sort].zip(Array.new(options[:sort].size) { direction }).to_h)
-        when Hash
-          scope.reorder(options[:sort].map { |table_name, column| "#{table_name}.#{column}" }.
-            zip(Array.new(options[:sort].size) { direction }).to_h)
-        else
-          raise ArgumentError.new("Unsupported sort value: #{options[:sort]}")
-        end
       end
       class WhereBuilder
         def initialize(scope)
           @statements = []
           @values = []
           @tables = []
           @scope = scope
         end
         def add(field, value, operator)
           field.searchable_columns.flatten.each do |column_infos|
@@ -135,21 +117,21 @@
           wb = WhereBuilder.new(scope)
           fields.each do |field|
             value = parse_field_value(field, query)
             wb.add(field, value, field.search_operator)
           end
           wb.build
         end
       end
       def filter_scope(scope, filters, fields = config.list.fields.select(&:filterable?))
         filters.each_pair do |field_name, filters_dump|
-          filters_dump.each_value do |filter_dump|
+          filters_dump.each do |_, filter_dump|
             wb = WhereBuilder.new(scope)
             field = fields.detect { |f| f.name.to_s == field_name }
             value = parse_field_value(field, filter_dump[:v])
             wb.add(field, value, (filter_dump[:o] || RailsAdmin::Config.default_search_operator))
             scope = wb.build
           end
         end
         scope
       end
       def build_statement(column, type, value, operator)
@@ -207,21 +189,21 @@
           when :boolean                   then build_statement_for_boolean
           when :integer, :decimal, :float then build_statement_for_integer_decimal_or_float
           when :string, :text, :citext    then build_statement_for_string_or_text
           when :enum                      then build_statement_for_enum
           when :belongs_to_association    then build_statement_for_belongs_to_association
           when :uuid                      then build_statement_for_uuid
           end
         end
         def build_statement_for_boolean
           return ["(#{@column} IS NULL OR #{@column} = ?)", false] if %w[false f 0].include?(@value)
-          ["(#{@column} = ?)", true] if %w[true t 1].include?(@value)
+          return ["(#{@column} = ?)", true] if %w[true t 1].include?(@value)
         end
         def column_for_value(value)
           ["(#{@column} = ?)", value]
         end
         def build_statement_for_belongs_to_association
           return if @value.blank?
           ["(#{@column} = ?)", @value.to_i] if @value.to_i.to_s == @value
         end
         def build_statement_for_string_or_text
           return if @value.blank?

--- a/lib/rails_admin/adapters/active_record/association.rb
+++ b/lib/rails_admin/adapters/active_record/association.rb
@@ -8,27 +8,20 @@
           @model = model
         end
         def name
           association.name.to_sym
         end
         def pretty_name
           name.to_s.tr('_', ' ').capitalize
         end
         def type
           association.macro
-        end
-        def field_type
-          if polymorphic?
-            :polymorphic_association
-          else
-            :"#{association.macro}_association"
-          end
         end
         def klass
           if options[:polymorphic]
             polymorphic_parents(:active_record, model.name.to_s, name) || []
           else
             association.klass
           end
         end
         def primary_key
           return nil if polymorphic?
@@ -48,38 +41,38 @@
         end
         def foreign_type
           options[:foreign_type].try(:to_sym) || :"#{name}_type" if options[:polymorphic]
         end
         def foreign_inverse_of
           nil
         end
         def key_accessor
           case type
           when :has_many, :has_and_belongs_to_many
-            :"#{name.to_s.singularize}_ids"
+            "#{name.to_s.singularize}_ids".to_sym
           when :has_one
-            :"#{name}_id"
+            "#{name}_id".to_sym
           else
             foreign_key
           end
         end
         def as
           options[:as].try :to_sym
         end
         def polymorphic?
           options[:polymorphic] || false
         end
         def inverse_of
           options[:inverse_of].try :to_sym
         end
         def read_only?
-          (klass.all.instance_exec(&scope).readonly_value if scope.is_a?(Proc) && scope.arity == 0) ||
+          (klass.all.instance_eval(&scope).readonly_value if scope.is_a? Proc) ||
             association.nested? ||
             false
         end
         def nested_options
           model.nested_attributes_options.try { |o| o[name.to_sym] }
         end
         def association?
           true
         end
         delegate :options, :scope, to: :association, prefix: false

--- a//dev/null
+++ b/lib/rails_admin/adapters/active_record/object_extension.rb
@@ -0,0 +1,27 @@
+module RailsAdmin
+  module Adapters
+    module ActiveRecord
+      module ObjectExtension
+        def self.extended(object)
+          object.class.reflect_on_all_associations.each do |association|
+            association = Association.new(association, object.class)
+            case association.type
+            when :has_one
+              object.instance_eval <<-RUBY, __FILE__, __LINE__ + 1
+                def #{association.name}_id
+                  self.#{association.name}&.id
+                end
+                def #{association.name}_id=(item_id)
+                  self.#{association.name} = (#{association.klass}.find(item_id) rescue nil)
+                end
+              RUBY
+            end
+          end
+        end
+        def assign_attributes(attributes)
+          super if attributes
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/adapters/active_record/property.rb
@@ -0,0 +1,45 @@
+module RailsAdmin
+  module Adapters
+    module ActiveRecord
+      class Property
+        attr_reader :property, :model
+        def initialize(property, model)
+          @property = property
+          @model = model
+        end
+        def name
+          property.name.to_sym
+        end
+        def pretty_name
+          property.name.to_s.tr('_', ' ').capitalize
+        end
+        def type
+          if serialized?
+            :serialized
+          else
+            property.type
+          end
+        end
+        def length
+          property.limit
+        end
+        def nullable?
+          property.null
+        end
+        def serial?
+          model.primary_key == property.name
+        end
+        def association?
+          false
+        end
+        def read_only?
+          model.readonly_attributes.include? property.name.to_s
+        end
+      private
+        def serialized?
+          model.type_for_attribute(property.name).instance_of?(::ActiveRecord::Type::Serialized)
+        end
+      end
+    end
+  end
+end

--- a/lib/rails_admin/adapters/mongoid.rb
+++ b/lib/rails_admin/adapters/mongoid.rb
@@ -17,42 +17,41 @@
       def get(id, scope = scoped)
         object = scope.find(id)
         return nil unless object
         object.extend(ObjectExtension)
       rescue StandardError => e
         raise e if %w[
           Mongoid::Errors::DocumentNotFound
           Mongoid::Errors::InvalidFind
           Moped::Errors::InvalidObjectId
           BSON::InvalidObjectId
-          BSON::Error::InvalidObjectId
         ].exclude?(e.class.to_s)
       end
       def scoped
         model.scoped
       end
       def first(options = {}, scope = nil)
         all(options, scope).first
       end
       def all(options = {}, scope = nil)
         scope ||= scoped
         scope = scope.includes(*options[:include]) if options[:include]
         scope = scope.limit(options[:limit]) if options[:limit]
         scope = scope.any_in(_id: options[:bulk_ids]) if options[:bulk_ids]
         scope = query_scope(scope, options[:query]) if options[:query]
         scope = filter_scope(scope, options[:filters]) if options[:filters]
         scope = scope.send(Kaminari.config.page_method_name, options[:page]).per(options[:per]) if options[:page] && options[:per]
         scope = sort_by(options, scope) if options[:sort]
         scope
       rescue NoMethodError => e
         if /page/.match?(e.message)
-          e = e.exception <<~ERROR
+          e = e.exception <<-ERROR.gsub(/^\s{12}/, '')
             If you don't have kaminari-mongoid installed, add `gem 'kaminari-mongoid'` to your Gemfile.
           ERROR
         end
         raise e
       end
       def count(options = {}, scope = nil)
         all(options.merge(limit: false, page: false), scope).count
       end
       def destroy(objects)
         Array.wrap(objects).each(&:destroy)
@@ -113,21 +112,21 @@
             value = parse_field_value(field, query)
             conditions_per_collection = make_field_conditions(field, value, field.search_operator)
             statements.concat make_condition_for_current_collection(field, conditions_per_collection)
           end
           scope.where(statements.any? ? {'$or' => statements} : {})
         end
       end
       def filter_scope(scope, filters, fields = config.list.fields.select(&:filterable?))
         statements = []
         filters.each_pair do |field_name, filters_dump|
-          filters_dump.each_value do |filter_dump|
+          filters_dump.each do |_, filter_dump|
             field = fields.detect { |f| f.name.to_s == field_name }
             next unless field
             value = parse_field_value(field, filter_dump[:v])
             conditions_per_collection = make_field_conditions(field, value, (filter_dump[:o] || 'default'))
             field_statements = make_condition_for_current_collection(field, conditions_per_collection)
             if field_statements.many?
               statements << {'$or' => field_statements}
             elsif field_statements.any?
               statements << field_statements.first
             end
@@ -154,21 +153,21 @@
         end
         result
       end
       def perform_search_on_associated_collection(field_name, conditions)
         target_association = associations.detect { |a| a.name == field_name }
         return [] unless target_association
         model = target_association.klass
         case target_association.type
         when :belongs_to, :has_and_belongs_to_many
           [{target_association.foreign_key.to_s => {'$in' => model.where('$or' => conditions).all.collect { |r| r.send(target_association.primary_key) }}}]
-        when :has_many, :has_one
+        when :has_many
           [{target_association.primary_key.to_s => {'$in' => model.where('$or' => conditions).all.collect { |r| r.send(target_association.foreign_key) }}}]
         end
       end
       def sort_by(options, scope)
         return scope unless options[:sort]
         case options[:sort]
         when String
           field_name, collection_name = options[:sort].split('.').reverse
           raise 'sorting by associated model column is not supported in Non-Relational databases' if collection_name && collection_name != table_name
         when Symbol
@@ -197,21 +196,21 @@
           case @type
           when :boolean                   then build_statement_for_boolean
           when :integer, :decimal, :float then build_statement_for_integer_decimal_or_float
           when :string, :text             then build_statement_for_string_or_text
           when :enum                      then build_statement_for_enum
           when :belongs_to_association, :bson_object_id then build_statement_for_belongs_to_association_or_bson_object_id
           end
         end
         def build_statement_for_boolean
           return {@column => false} if %w[false f 0].include?(@value)
-          {@column => true} if %w[true t 1].include?(@value)
+          return {@column => true} if %w[true t 1].include?(@value)
         end
         def column_for_value(value)
           {@column => value}
         end
         def build_statement_for_string_or_text
           return if @value.blank?
           @value =
             case @operator
             when 'not_like'
               Regexp.compile("^((?!#{Regexp.escape(@value)}).)*$", Regexp::IGNORECASE)

--- a/lib/rails_admin/adapters/mongoid/association.rb
+++ b/lib/rails_admin/adapters/mongoid/association.rb
@@ -19,27 +19,20 @@
           when :belongs_to, :referenced_in, :embedded_in
             :belongs_to
           when :has_one, :references_one, :embeds_one
             :has_one
           when :has_many, :references_many, :embeds_many
             :has_many
           when :has_and_belongs_to_many, :references_and_referenced_in_many
             :has_and_belongs_to_many
           else
             raise "Unknown association type: #{macro.inspect}"
-          end
-        end
-        def field_type
-          if polymorphic?
-            :polymorphic_association
-          else
-            :"#{type}_association"
           end
         end
         def klass
           if polymorphic? && %i[referenced_in belongs_to].include?(macro)
             polymorphic_parents(:mongoid, model.name, name) || []
           else
             association.klass
           end
         end
         def primary_key
@@ -66,23 +59,23 @@
           return unless polymorphic? && %i[referenced_in belongs_to].include?(macro)
           association.inverse_type.try(:to_sym) || :"#{name}_type"
         end
         def foreign_inverse_of
           return unless polymorphic? && %i[referenced_in belongs_to].include?(macro)
           inverse_of_field.try(:to_sym)
         end
         def key_accessor
           case macro.to_sym
           when :has_many
-            :"#{name.to_s.singularize}_ids"
+            "#{name.to_s.singularize}_ids".to_sym
           when :has_one
-            :"#{name}_id"
+            "#{name}_id".to_sym
           when :embedded_in, :embeds_one, :embeds_many
             nil
           else
             foreign_key
           end
         end
         def as
           association.as.try :to_sym
         end
         def polymorphic?
@@ -90,24 +83,24 @@
         end
         def inverse_of
           association.inverse_of.try :to_sym
         end
         def read_only?
           false
         end
         def nested_options
           nested = nested_attributes_options.try { |o| o[name] }
           if !nested && %i[embeds_one embeds_many].include?(macro.to_sym) && !cyclic?
-            raise <<~MSG
-              Embedded association without accepts_nested_attributes_for can't be handled by RailsAdmin,
-              because embedded model doesn't have top-level access.
-              Please add `accepts_nested_attributes_for :#{association.name}' line to `#{model}' model.
+            raise <<-MSG.gsub(/^\s+/, '')
+            Embbeded association without accepts_nested_attributes_for can't be handled by RailsAdmin,
+            because embedded model doesn't have top-level access.
+            Please add `accepts_nested_attributes_for :#{association.name}' line to `#{model}' model.
             MSG
           end
           nested
         end
         def association?
           true
         end
         def macro
           association.try(:macro) || association.class.name.split('::').last.underscore.to_sym
         end

--- a/lib/rails_admin/adapters/mongoid/bson.rb
+++ b/lib/rails_admin/adapters/mongoid/bson.rb
@@ -10,18 +10,17 @@
             BSON::ObjectId
           end
         class << self
           def parse_object_id(value)
             OBJECT_ID.from_string(value)
           rescue StandardError => e
             raise e if %w[
               Moped::Errors::InvalidObjectId
               BSON::ObjectId::Invalid
               BSON::InvalidObjectId
-              BSON::Error::InvalidObjectId
             ].exclude?(e.class.to_s)
           end
         end
       end
     end
   end
 end

--- a//dev/null
+++ b/lib/rails_admin/adapters/mongoid/extension.rb
@@ -0,0 +1,42 @@
+module RailsAdmin
+  module Adapters
+    module Mongoid
+      module Extension
+        extend ActiveSupport::Concern
+        included do
+          class_attribute :nested_attributes_options
+          self.nested_attributes_options = {}
+          class << self
+            def rails_admin(&block)
+              RailsAdmin.config do |config|
+                config.model(self, &block)
+              end
+            end
+            alias_method :accepts_nested_attributes_for_without_rails_admin, :accepts_nested_attributes_for
+            alias_method :accepts_nested_attributes_for, :accepts_nested_attributes_for_with_rails_admin
+          end
+        end
+        def rails_admin_default_object_label_method
+          new_record? ? "new #{self.class}" : "#{self.class} ##{id}"
+        end
+        def safe_send(value)
+          if attributes.detect { |k, _v| k.to_s == value.to_s }
+            read_attribute(value)
+          else
+            send(value)
+          end
+        end
+        module ClassMethods
+          def accepts_nested_attributes_for_with_rails_admin(*args)
+            options = args.extract_options!
+            args.each do |arg|
+              nested_attributes_options[arg.to_sym] = options.reverse_merge(allow_destroy: false, update_only: false)
+            end
+            args << options
+            accepts_nested_attributes_for_without_rails_admin(*args)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/adapters/mongoid/object_extension.rb
@@ -0,0 +1,32 @@
+module RailsAdmin
+  module Adapters
+    module Mongoid
+      module ObjectExtension
+        def self.extended(object)
+          object.associations.each do |name, association|
+            association = Association.new(association, object.class)
+            case association.macro
+            when :has_many
+              unless association.autosave?
+                object.singleton_class.after_create do
+                  send(name).each(&:save)
+                end
+              end
+            when :has_one
+              unless association.autosave?
+                object.singleton_class.after_create do
+                  send(name)&.save
+                end
+              end
+              object.instance_eval <<-RUBY, __FILE__, __LINE__ + 1
+                def #{name}_id=(item_id)
+                  self.#{name} = (#{association.klass}.find(item_id) rescue nil)
+                end
+              RUBY
+            end
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/adapters/mongoid/property.rb
@@ -0,0 +1,85 @@
+module RailsAdmin
+  module Adapters
+    module Mongoid
+      class Property
+        STRING_TYPE_COLUMN_NAMES = %i[name title subject].freeze
+        attr_reader :property, :model
+        def initialize(property, model)
+          @property = property
+          @model = model
+        end
+        def name
+          (property.options[:as] || property.name).to_sym
+        end
+        def pretty_name
+          (property.options[:as] || property.name).to_s.tr('_', ' ').capitalize
+        end
+        def type
+          case property.type.to_s
+          when 'Array', 'Hash', 'Money'
+            :serialized
+          when 'BigDecimal'
+            :decimal
+          when 'Boolean', 'Mongoid::Boolean'
+            :boolean
+          when 'BSON::ObjectId', 'Moped::BSON::ObjectId'
+            :bson_object_id
+          when 'Date'
+            :date
+          when 'ActiveSupport::TimeWithZone', 'DateTime', 'Time'
+            :datetime
+          when 'Float'
+            :float
+          when 'Integer'
+            :integer
+          when 'Object'
+            object_field_type
+          when 'String'
+            string_field_type
+          when 'Symbol'
+            :string
+          else
+            :string
+          end
+        end
+        def length
+          (length_validation_lookup || 255) if type == :string
+        end
+        def nullable?
+          true
+        end
+        def serial?
+          name == :_id
+        end
+        def association?
+          false
+        end
+        def read_only?
+          model.readonly_attributes.include? property.name.to_s
+        end
+      private
+        def object_field_type
+          association = Association.new model.relations.values.detect { |r| r.try(:foreign_key).try(:to_sym) == name }, model
+          if %i[belongs_to referenced_in embedded_in].include?(association.macro)
+            :bson_object_id
+          else
+            :string
+          end
+        end
+        def string_field_type
+          if ((length = length_validation_lookup) && length < 256) || STRING_TYPE_COLUMN_NAMES.include?(name)
+            :string
+          else
+            :text
+          end
+        end
+        def length_validation_lookup
+          shortest = model.validators.select { |validator| validator.respond_to?(:attributes) && validator.attributes.include?(name.to_sym) && validator.kind == :length && validator.options[:maximum] }.min do |a, b|
+            a.options[:maximum] <=> b.options[:maximum]
+          end
+          shortest && shortest.options[:maximum]
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config.rb
@@ -0,0 +1,223 @@
+require 'rails_admin/config/model'
+require 'rails_admin/config/sections/list'
+require 'active_support/core_ext/module/attribute_accessors'
+module RailsAdmin
+  module Config
+    DEFAULT_AUTHENTICATION = proc {}
+    DEFAULT_AUTHORIZE = proc {}
+    DEFAULT_AUDIT = proc {}
+    DEFAULT_CURRENT_USER = proc {}
+    @initialized = false
+    @deferred_blocks = []
+    class << self
+      attr_accessor :main_app_name
+      attr_accessor :excluded_models
+      attr_accessor :included_models
+      attr_reader :default_hidden_fields
+      attr_accessor :default_items_per_page
+      attr_accessor :default_associated_collection_limit
+      attr_reader :default_search_operator
+      attr_accessor :label_methods
+      attr_accessor :compact_show_view
+      attr_accessor :browser_validations
+      attr_reader :parent_controller
+      attr_accessor :forgery_protection_settings
+      attr_reader :registry
+      attr_accessor :show_gravatar
+      attr_accessor :navigation_static_links
+      attr_accessor :navigation_static_label
+      attr_writer :asset_source
+      def initialize!
+        @deferred_blocks.each { |block| block.call(self) }
+        @deferred_blocks.clear
+        @initialized = true
+      end
+      def apply(&block)
+        if @initialized
+          yield(self)
+        else
+          @deferred_blocks << block
+        end
+      end
+      def authenticate_with(&blk)
+        @authenticate = blk if blk
+        @authenticate || DEFAULT_AUTHENTICATION
+      end
+      def audit_with(*args, &block)
+        extension = args.shift
+        if extension
+          klass = RailsAdmin::AUDITING_ADAPTERS[extension]
+          klass.setup if klass.respond_to? :setup
+          @audit = proc do
+            @auditing_adapter = klass.new(*([self] + args).compact)
+          end
+        elsif block
+          @audit = block
+        end
+        @audit || DEFAULT_AUDIT
+      end
+      def authorize_with(*args, &block)
+        extension = args.shift
+        if extension
+          klass = RailsAdmin::AUTHORIZATION_ADAPTERS[extension]
+          klass.setup if klass.respond_to? :setup
+          @authorize = proc do
+            @authorization_adapter = klass.new(*([self] + args).compact)
+          end
+        elsif block
+          @authorize = block
+        end
+        @authorize || DEFAULT_AUTHORIZE
+      end
+      def configure_with(extension)
+        configuration = RailsAdmin::CONFIGURATION_ADAPTERS[extension].new
+        yield(configuration) if block_given?
+      end
+      def current_user_method(&block)
+        @current_user = block if block
+        @current_user || DEFAULT_CURRENT_USER
+      end
+      def default_search_operator=(operator)
+        if %w[default like not_like starts_with ends_with is =].include? operator
+          @default_search_operator = operator
+        else
+          raise ArgumentError.new("Search operator '#{operator}' not supported")
+        end
+      end
+      def models_pool
+        (viable_models - excluded_models.collect(&:to_s)).uniq.sort
+      end
+      def model(entity, &block)
+        key =
+          case entity
+          when RailsAdmin::AbstractModel
+            entity.model.try(:name).try :to_sym
+          when Class
+            entity.name.to_sym
+          when String, Symbol
+            entity.to_sym
+          else
+            entity.class.name.to_sym
+          end
+        @registry[key] ||= RailsAdmin::Config::Model.new(entity)
+        @registry[key].instance_eval(&block) if block && @registry[key].abstract_model
+        @registry[key]
+      end
+      def asset_source
+        @asset_source ||=
+          begin
+            warn <<-MSG.gsub(/^ +/, '').freeze
+              [Warning] After upgrading RailsAdmin to 3.x you haven't set asset_source yet, using :sprockets as the default.
+              To suppress this message, run 'rails rails_admin:install' to setup the asset delivery method suitable to you.
+            MSG
+            :sprockets
+          end
+      end
+      def default_hidden_fields=(fields)
+        if fields.is_a?(Array)
+          @default_hidden_fields = {}
+          @default_hidden_fields[:edit] = fields
+          @default_hidden_fields[:show] = fields
+        else
+          @default_hidden_fields = fields
+        end
+      end
+      def parent_controller=(name)
+        @parent_controller = name
+        if defined?(RailsAdmin::ApplicationController) || defined?(RailsAdmin::MainController)
+          RailsAdmin.send(:remove_const, :ApplicationController)
+          RailsAdmin.send(:remove_const, :MainController)
+          load RailsAdmin::Engine.root.join('app/controllers/rails_admin/application_controller.rb')
+          load RailsAdmin::Engine.root.join('app/controllers/rails_admin/main_controller.rb')
+        end
+      end
+      def total_columns_width=(_)
+        ActiveSupport::Deprecation.warn('The total_columns_width configuration option is deprecated and has no effect.')
+      end
+      def sidescroll=(_)
+        ActiveSupport::Deprecation.warn('The sidescroll configuration option was removed, it is always enabled now.')
+      end
+      def actions(&block)
+        return unless block
+        RailsAdmin::Config::Actions.reset
+        RailsAdmin::Config::Actions.instance_eval(&block)
+      end
+      def models
+        RailsAdmin::AbstractModel.all.collect { |m| model(m) }
+      end
+      def reset
+        @compact_show_view = true
+        @browser_validations = true
+        @authenticate = nil
+        @authorize = nil
+        @audit = nil
+        @current_user = nil
+        @default_hidden_fields = {}
+        @default_hidden_fields[:base] = [:_type]
+        @default_hidden_fields[:edit] = %i[id _id created_at created_on deleted_at updated_at updated_on deleted_on]
+        @default_hidden_fields[:show] = %i[id _id created_at created_on deleted_at updated_at updated_on deleted_on]
+        @default_items_per_page = 20
+        @default_associated_collection_limit = 100
+        @default_search_operator = 'default'
+        @excluded_models = []
+        @included_models = []
+        @label_methods = %i[name title]
+        @main_app_name = proc { [Rails.application.engine_name.titleize.chomp(' Application'), 'Admin'] }
+        @registry = {}
+        @show_gravatar = true
+        @navigation_static_links = {}
+        @navigation_static_label = nil
+        @asset_source = nil
+        @parent_controller = '::ActionController::Base'
+        @forgery_protection_settings = {with: :exception}
+        RailsAdmin::Config::Actions.reset
+        RailsAdmin::AbstractModel.reset
+      end
+      def reset_model(model)
+        key = model.is_a?(Class) ? model.name.to_sym : model.to_sym
+        @registry.delete(key)
+      end
+      def reload!
+        @initialized = false
+        reset
+        load RailsAdmin::Engine.config.initializer_path
+        initialize!
+      end
+      def visible_models(bindings)
+        visible_models_with_bindings(bindings).sort do |a, b|
+          if (weight_order = a.weight <=> b.weight) == 0
+            a.label.casecmp(b.label)
+          else
+            weight_order
+          end
+        end
+      end
+    private
+      def lchomp(base, arg)
+        base.to_s.reverse.chomp(arg.to_s.reverse).reverse
+      end
+      def viable_models
+        included_models.collect(&:to_s).presence || begin
+          @@system_models ||= # memoization for tests
+            ([Rails.application] + Rails::Engine.subclasses.collect(&:instance)).flat_map do |app|
+              (app.paths['app/models'].to_a + app.config.eager_load_paths).collect do |load_path|
+                Dir.glob(app.root.join(load_path)).collect do |load_dir|
+                  Dir.glob("#{load_dir}/**/*.rb").collect do |filename|
+                    lchomp(filename, "#{app.root.join(load_dir)}/").chomp('.rb').camelize
+                  end
+                end
+              end
+            end.flatten.reject { |m| m.starts_with?('Concerns::') } # rubocop:disable Style/MultilineBlockChain
+        end
+      end
+      def visible_models_with_bindings(bindings)
+        models.collect { |m| m.with(bindings) }.select do |m|
+          m.visible? &&
+            RailsAdmin::Config::Actions.find(:index, bindings.merge(abstract_model: m.abstract_model)).try(:authorized?) &&
+            (!m.abstract_model.embedded? || m.abstract_model.cyclic?)
+        end
+      end
+    end
+    reset
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions.rb
@@ -0,0 +1,106 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class << self
+        def all(scope = nil, bindings = {})
+          if scope.is_a?(Hash)
+            bindings = scope
+            scope = :all
+          end
+          scope ||= :all
+          init_actions!
+          actions =
+            case scope
+            when :all
+              @@actions
+            when :root
+              @@actions.select(&:root?)
+            when :collection
+              @@actions.select(&:collection?)
+            when :bulkable
+              @@actions.select(&:bulkable?)
+            when :member
+              @@actions.select(&:member?)
+            end
+          actions = actions.collect { |action| action.with(bindings) }
+          bindings[:controller] ? actions.select(&:visible?) : actions
+        end
+        def find(custom_key, bindings = {})
+          init_actions!
+          action = @@actions.detect { |a| a.custom_key == custom_key }.try(:with, bindings)
+          bindings[:controller] ? (action.try(:visible?) && action || nil) : action
+        end
+        def collection(key, parent_class = :base, &block)
+          add_action key, parent_class, :collection, &block
+        end
+        def member(key, parent_class = :base, &block)
+          add_action key, parent_class, :member, &block
+        end
+        def root(key, parent_class = :base, &block)
+          add_action key, parent_class, :root, &block
+        end
+        def add_action(key, parent_class, parent, &block)
+          a = "RailsAdmin::Config::Actions::#{parent_class.to_s.camelize}".constantize.new
+          a.instance_eval(%(
+            def key
+              :#{key}
+            end
+          ), __FILE__, __LINE__ - 5)
+          add_action_custom_key(a, &block)
+        end
+        def reset
+          @@actions = nil
+        end
+        def register(name, klass = nil)
+          if klass.nil? && name.is_a?(Class)
+            klass = name
+            name = klass.to_s.demodulize.underscore.to_sym
+          end
+          instance_eval %{
+            def #{name}(&block)
+              action = #{klass}.new
+              add_action_custom_key(action, &block)
+            end
+          }, __FILE__, __LINE__ - 5
+        end
+      private
+        def init_actions!
+          @@actions ||= [
+            Dashboard.new,
+            Index.new,
+            Show.new,
+            New.new,
+            Edit.new,
+            Export.new,
+            Delete.new,
+            BulkDelete.new,
+            HistoryShow.new,
+            HistoryIndex.new,
+            ShowInApp.new,
+          ]
+        end
+        def add_action_custom_key(action, &block)
+          action.instance_eval(&block) if block
+          @@actions ||= []
+          if action.custom_key.in?(@@actions.collect(&:custom_key))
+            raise "Action #{action.custom_key} already exists. Please change its custom key."
+          else
+            @@actions << action
+          end
+        end
+      end
+    end
+  end
+end
+require 'rails_admin/config/actions/base'
+require 'rails_admin/config/actions/dashboard'
+require 'rails_admin/config/actions/index'
+require 'rails_admin/config/actions/show'
+require 'rails_admin/config/actions/show_in_app'
+require 'rails_admin/config/actions/history_show'
+require 'rails_admin/config/actions/history_index'
+require 'rails_admin/config/actions/new'
+require 'rails_admin/config/actions/edit'
+require 'rails_admin/config/actions/export'
+require 'rails_admin/config/actions/delete'
+require 'rails_admin/config/actions/bulk_delete'

--- a//dev/null
+++ b/lib/rails_admin/config/actions/base.rb
@@ -0,0 +1,109 @@
+require 'rails_admin/config/proxyable'
+require 'rails_admin/config/configurable'
+require 'rails_admin/config/hideable'
+module RailsAdmin
+  module Config
+    module Actions
+      class Base
+        include RailsAdmin::Config::Proxyable
+        include RailsAdmin::Config::Configurable
+        include RailsAdmin::Config::Hideable
+        register_instance_option :only do
+          nil
+        end
+        register_instance_option :except do
+          []
+        end
+        register_instance_option :show_in_navigation do
+          root?
+        end
+        register_instance_option :show_in_sidebar do
+          !show_in_navigation
+        end
+        register_instance_option :show_in_menu do
+          true
+        end
+        register_instance_option :sidebar_label do
+          nil
+        end
+        register_instance_option :link_icon do
+          'fas fa-question'
+        end
+        register_instance_option :visible? do
+          authorized?
+        end
+        register_instance_option :enabled? do
+          bindings[:abstract_model].nil? || (
+            (only.nil? || [only].flatten.collect(&:to_s).include?(bindings[:abstract_model].to_s)) &&
+            ![except].flatten.collect(&:to_s).include?(bindings[:abstract_model].to_s) &&
+            !bindings[:abstract_model].config.excluded?
+          ) && (!respond_to?(:writable?) || writable?)
+        end
+        register_instance_option :authorized? do
+          enabled? && (
+            bindings[:controller].try(:authorization_adapter).nil? || bindings[:controller].authorization_adapter.authorized?(authorization_key, bindings[:abstract_model], bindings[:object])
+          )
+        end
+        register_instance_option :root? do
+          false
+        end
+        register_instance_option :collection? do
+          false
+        end
+        register_instance_option :member? do
+          false
+        end
+        register_instance_option :link_target do
+          nil
+        end
+        register_instance_option :turbo? do
+          true
+        end
+        register_instance_option :controller do
+          proc do
+            render action: @action.template_name
+          end
+        end
+        register_instance_option :bulkable? do
+          false
+        end
+        register_instance_option :template_name do
+          key.to_sym
+        end
+        register_instance_option :authorization_key do
+          key.to_sym
+        end
+        register_instance_option :http_methods do
+          [:get]
+        end
+        register_instance_option :route_fragment do
+          custom_key.to_s
+        end
+        register_instance_option :action_name do
+          custom_key.to_sym
+        end
+        register_instance_option :i18n_key do
+          key
+        end
+        register_instance_option :custom_key do
+          key
+        end
+        register_instance_option :breadcrumb_parent do
+          if root?
+            [:dashboard]
+          elsif collection?
+            [:index, bindings[:abstract_model]]
+          elsif member?
+            [:show, bindings[:abstract_model], bindings[:object]]
+          end
+        end
+        def key
+          self.class.key
+        end
+        def self.key
+          name.to_s.demodulize.underscore.to_sym
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/bulk_delete.rb
@@ -0,0 +1,55 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class BulkDelete < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :collection do
+          true
+        end
+        register_instance_option :http_methods do
+          %i[post delete]
+        end
+        register_instance_option :controller do
+          proc do
+            if request.post? # BULK DELETE
+              @objects = list_entries(@model_config, :destroy)
+              if @objects.blank?
+                flash[:error] = t('admin.flash.error', name: pluralize(0, @model_config.label), action: t('admin.actions.delete.done'))
+                redirect_to index_path
+              else
+                render @action.template_name
+              end
+            elsif request.delete? # BULK DESTROY
+              destroyed = nil
+              not_destroyed = nil
+              unless params[:bulk_ids].blank?
+                @objects = list_entries(@model_config, :destroy)
+                unless @objects.blank?
+                  processed_objects = @abstract_model.destroy(@objects)
+                  destroyed = processed_objects.select(&:destroyed?)
+                  not_destroyed = processed_objects - destroyed
+                  destroyed.each do |object|
+                    @auditing_adapter&.delete_object(object, @abstract_model, _current_user)
+                  end
+                end
+              end
+              if destroyed.nil?
+                flash[:error] = t('admin.flash.error', name: pluralize(0, @model_config.label), action: t('admin.actions.delete.done'))
+              else
+                flash[:success] = t('admin.flash.successful', name: pluralize(destroyed.count, @model_config.label), action: t('admin.actions.delete.done')) unless destroyed.empty?
+                flash[:error] = t('admin.flash.error', name: pluralize(not_destroyed.count, @model_config.label), action: t('admin.actions.delete.done')) unless not_destroyed.empty?
+              end
+              redirect_to back_or_index
+            end
+          end
+        end
+        register_instance_option :authorization_key do
+          :destroy
+        end
+        register_instance_option :bulkable? do
+          true
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/dashboard.rb
@@ -0,0 +1,51 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class Dashboard < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :root? do
+          true
+        end
+        register_instance_option :breadcrumb_parent do
+          nil
+        end
+        register_instance_option :auditing_versions_limit do
+          100
+        end
+        register_instance_option :controller do
+          proc do
+            @history = @auditing_adapter&.latest(@action.auditing_versions_limit) if @action.history?
+            if @action.statistics?
+              model_configs = RailsAdmin::Config.visible_models(controller: self)
+              @abstract_models = model_configs.map(&:abstract_model)
+              @most_recent_created = {}
+              @count = {}
+              @max = 0
+              model_configs.each do |config|
+                scope = @authorization_adapter&.query(:index, config.abstract_model)
+                current_count = config.abstract_model.count({}, scope)
+                @max = current_count > @max ? current_count : @max
+                name = config.abstract_model.model.name
+                @count[name] = current_count
+                @most_recent_created[name] = config.last_created_at
+              end
+            end
+            render @action.template_name, status: @status_code || :ok
+          end
+        end
+        register_instance_option :route_fragment do
+          ''
+        end
+        register_instance_option :link_icon do
+          'fas fa-home'
+        end
+        register_instance_option :statistics? do
+          true
+        end
+        register_instance_option :history? do
+          true
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/delete.rb
@@ -0,0 +1,45 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class Delete < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :member do
+          true
+        end
+        register_instance_option :route_fragment do
+          'delete'
+        end
+        register_instance_option :http_methods do
+          %i[get delete]
+        end
+        register_instance_option :authorization_key do
+          :destroy
+        end
+        register_instance_option :controller do
+          proc do
+            if request.get? # DELETE
+              respond_to do |format|
+                format.html { render @action.template_name }
+                format.js   { render @action.template_name, layout: false }
+              end
+            elsif request.delete? # DESTROY
+              @auditing_adapter&.delete_object(@object, @abstract_model, _current_user)
+              if @object.destroy
+                flash[:success] = t('admin.flash.successful', name: @model_config.label, action: t('admin.actions.delete.done'))
+                redirect_to index_path
+              else
+                handle_save_error :delete
+              end
+            end
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-times'
+        end
+        register_instance_option :writable? do
+          !(bindings[:object] && bindings[:object].readonly?)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/edit.rb
@@ -0,0 +1,45 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class Edit < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :member do
+          true
+        end
+        register_instance_option :http_methods do
+          %i[get put]
+        end
+        register_instance_option :controller do
+          proc do
+            if request.get? # EDIT
+              respond_to do |format|
+                format.html { render @action.template_name }
+                format.js   { render @action.template_name, layout: 'rails_admin/modal', content_type: Mime[:html].to_s }
+              end
+            elsif request.put? # UPDATE
+              sanitize_params_for!(request.xhr? ? :modal : :update)
+              @object.assign_attributes(params[@abstract_model.param_key])
+              @authorization_adapter&.authorize(:update, @abstract_model, @object)
+              changes = @object.changes
+              if @object.save
+                @auditing_adapter&.update_object(@object, @abstract_model, _current_user, changes)
+                respond_to do |format|
+                  format.html { redirect_to_on_success }
+                  format.json { render json: {id: @object.id.to_s, label: @model_config.with(object: @object).object_label} }
+                end
+              else
+                handle_save_error :edit
+              end
+            end
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-pencil-alt'
+        end
+        register_instance_option :writable? do
+          !(bindings[:object] && bindings[:object].readonly?)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/export.rb
@@ -0,0 +1,34 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class Export < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :collection do
+          true
+        end
+        register_instance_option :http_methods do
+          %i[get post]
+        end
+        register_instance_option :controller do
+          proc do
+            format = params[:json] && :json || params[:csv] && :csv || params[:xml] && :xml
+            if format
+              request.format = format
+              @schema = HashHelper.symbolize(params[:schema].slice(:except, :include, :methods, :only).permit!.to_h) if params[:schema] # to_json and to_xml expect symbols for keys AND values.
+              @objects = list_entries(@model_config, :export)
+              index
+            else
+              render @action.template_name
+            end
+          end
+        end
+        register_instance_option :bulkable? do
+          true
+        end
+        register_instance_option :link_icon do
+          'fas fa-file-export'
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/history_index.rb
@@ -0,0 +1,31 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class HistoryIndex < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :authorization_key do
+          :history
+        end
+        register_instance_option :collection do
+          true
+        end
+        register_instance_option :route_fragment do
+          'history'
+        end
+        register_instance_option :controller do
+          proc do
+            @general = true
+            @history = @auditing_adapter&.listing_for_model(@abstract_model, params[:query], params[:sort], params[:sort_reverse], params[:all], params[Kaminari.config.param_name]) || []
+            render @action.template_name
+          end
+        end
+        register_instance_option :template_name do
+          :history
+        end
+        register_instance_option :link_icon do
+          'fas fa-book'
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/history_show.rb
@@ -0,0 +1,31 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class HistoryShow < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :authorization_key do
+          :history
+        end
+        register_instance_option :member do
+          true
+        end
+        register_instance_option :route_fragment do
+          'history'
+        end
+        register_instance_option :controller do
+          proc do
+            @general = false
+            @history = @auditing_adapter&.listing_for_object(@abstract_model, @object, params[:query], params[:sort], params[:sort_reverse], params[:all], params[Kaminari.config.param_name]) || []
+            render @action.template_name
+          end
+        end
+        register_instance_option :template_name do
+          :history
+        end
+        register_instance_option :link_icon do
+          'fas fa-book'
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/index.rb
@@ -0,0 +1,81 @@
+require 'activemodel-serializers-xml'
+module RailsAdmin
+  module Config
+    module Actions
+      class Index < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :collection do
+          true
+        end
+        register_instance_option :http_methods do
+          %i[get post]
+        end
+        register_instance_option :route_fragment do
+          ''
+        end
+        register_instance_option :breadcrumb_parent do
+          parent_model = bindings[:abstract_model].try(:config).try(:parent)
+          am = parent_model && RailsAdmin.config(parent_model).try(:abstract_model)
+          if am
+            [:index, am]
+          else
+            [:dashboard]
+          end
+        end
+        register_instance_option :controller do
+          proc do
+            @objects ||= list_entries
+            unless @model_config.list.scopes.empty?
+              if params[:scope].blank?
+                @objects = @objects.send(@model_config.list.scopes.first) unless @model_config.list.scopes.first.nil?
+              elsif @model_config.list.scopes.collect(&:to_s).include?(params[:scope])
+                @objects = @objects.send(params[:scope].to_sym)
+              end
+            end
+            respond_to do |format|
+              format.html do
+                render @action.template_name, status: @status_code || :ok
+              end
+              format.json do
+                output =
+                  if params[:compact]
+                    primary_key_method = @association ? @association.associated_primary_key : @model_config.abstract_model.primary_key
+                    label_method = @model_config.object_label_method
+                    @objects.collect { |o| {id: o.send(primary_key_method).to_s, label: o.send(label_method).to_s} }
+                  else
+                    @objects.to_json(@schema)
+                  end
+                if params[:send_data]
+                  send_data output, filename: "#{params[:model_name]}_#{DateTime.now.strftime('%Y-%m-%d_%Hh%Mm%S')}.json"
+                else
+                  render json: output, root: false
+                end
+              end
+              format.xml do
+                output = @objects.to_xml(@schema)
+                if params[:send_data]
+                  send_data output, filename: "#{params[:model_name]}_#{DateTime.now.strftime('%Y-%m-%d_%Hh%Mm%S')}.xml"
+                else
+                  render xml: output
+                end
+              end
+              format.csv do
+                header, encoding, output = CSVConverter.new(@objects, @schema).to_csv(params[:csv_options].permit!.to_h)
+                if params[:send_data]
+                  send_data output,
+                            type: "text/csv; charset=#{encoding}; #{'header=present' if header}",
+                            disposition: "attachment; filename=#{params[:model_name]}_#{DateTime.now.strftime('%Y-%m-%d_%Hh%Mm%S')}.csv"
+                else
+                  render plain: output
+                end
+              end
+            end
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-th-list'
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/new.rb
@@ -0,0 +1,56 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class New < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :collection do
+          true
+        end
+        register_instance_option :http_methods do
+          %i[get post] # NEW / CREATE
+        end
+        register_instance_option :controller do
+          proc do
+            if request.get? # NEW
+              @object = @abstract_model.new
+              @action = @action.with(@action.bindings.merge(object: @object))
+              @authorization_adapter&.attributes_for(:new, @abstract_model)&.each do |name, value|
+                @object.send("#{name}=", value)
+              end
+              object_params = params[@abstract_model.param_key]
+              if object_params
+                sanitize_params_for!(request.xhr? ? :modal : :create)
+                @object.assign_attributes(@object.attributes.merge(object_params.to_h))
+              end
+              respond_to do |format|
+                format.html { render @action.template_name }
+                format.js   { render @action.template_name, layout: 'rails_admin/modal', content_type: Mime[:html].to_s }
+              end
+            elsif request.post? # CREATE
+              @modified_assoc = []
+              @object = @abstract_model.new
+              sanitize_params_for!(request.xhr? ? :modal : :create)
+              @object.assign_attributes(params[@abstract_model.param_key])
+              @authorization_adapter&.authorize(:create, @abstract_model, @object)
+              if @object.save
+                @auditing_adapter&.create_object(@object, @abstract_model, _current_user)
+                respond_to do |format|
+                  format.html { redirect_to_on_success }
+                  format.json { render json: {id: @object.id.to_s, label: @model_config.with(object: @object).object_label} }
+                end
+              else
+                handle_save_error
+              end
+            end
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-plus'
+        end
+        register_instance_option :writable? do
+          !(bindings[:object] && bindings[:object].readonly?)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/show.rb
@@ -0,0 +1,29 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class Show < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :member do
+          true
+        end
+        register_instance_option :route_fragment do
+          ''
+        end
+        register_instance_option :breadcrumb_parent do
+          [:index, bindings[:abstract_model]]
+        end
+        register_instance_option :controller do
+          proc do
+            respond_to do |format|
+              format.json { render json: @object }
+              format.html { render @action.template_name }
+            end
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-info-circle'
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/actions/show_in_app.rb
@@ -0,0 +1,30 @@
+module RailsAdmin
+  module Config
+    module Actions
+      class ShowInApp < RailsAdmin::Config::Actions::Base
+        RailsAdmin::Config::Actions.register(self)
+        register_instance_option :member do
+          true
+        end
+        register_instance_option :visible? do
+          authorized? && begin
+            bindings[:controller].main_app.url_for(bindings[:object])
+          rescue StandardError
+            false
+          end
+        end
+        register_instance_option :controller do
+          proc do
+            redirect_to main_app.url_for(@object)
+          end
+        end
+        register_instance_option :link_icon do
+          'fas fa-eye'
+        end
+        register_instance_option :turbo? do
+          false
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/configurable.rb
@@ -0,0 +1,77 @@
+module RailsAdmin
+  module Config
+    module Configurable
+      def self.included(base)
+        base.send :extend, ClassMethods
+      end
+      def has_option?(name) # rubocop:disable Naming/PredicateName
+        options = self.class.instance_variable_get('@config_options')
+        options&.key?(name)
+      end
+      def register_instance_option(option_name, &default)
+        scope = class << self; self; end
+        self.class.register_instance_option(option_name, scope, &default)
+      end
+      def register_deprecated_instance_option(option_name, replacement_option_name = nil, &custom_error)
+        scope = class << self; self; end
+        self.class.register_deprecated_instance_option(option_name, replacement_option_name, scope, &custom_error)
+      end
+    private
+      def with_recurring(option_name, value_proc, default_proc)
+        Thread.current[:rails_admin_recurring] ||= {}
+        Thread.current[:rails_admin_recurring][self] ||= {}
+        if Thread.current[:rails_admin_recurring][self][option_name]
+          instance_eval(&default_proc)
+        else
+          Thread.current[:rails_admin_recurring][self][option_name] = true
+          instance_eval(&value_proc)
+        end
+      ensure
+        Thread.current[:rails_admin_recurring].delete(self)
+      end
+      module ClassMethods
+        def register_instance_option(option_name, scope = self, &default)
+          options = scope.instance_variable_get('@config_options') ||
+                    scope.instance_variable_set('@config_options', {})
+          option_name = option_name.to_s
+          options[option_name] = nil
+          if option_name.end_with?('?')
+            scope.send(:define_method, "#{option_name.chop!}?") do
+              send(option_name)
+            end
+          end
+          scope.send(:define_method, option_name) do |*args, &block|
+            if !args[0].nil? || block
+              instance_variable_set("@#{option_name}_registered", args[0].nil? ? block : args[0])
+            else
+              value = instance_variable_get("@#{option_name}_registered")
+              case value
+              when Proc
+                value = with_recurring(option_name, value, default)
+              when nil
+                value = instance_eval(&default)
+              end
+              value
+            end
+          end
+        end
+        def register_deprecated_instance_option(option_name, replacement_option_name = nil, scope = self)
+          scope.send(:define_method, option_name) do |*args, &block|
+            if replacement_option_name
+              ActiveSupport::Deprecation.warn("The #{option_name} configuration option is deprecated, please use #{replacement_option_name}.")
+              send(replacement_option_name, *args, &block)
+            elsif block_given?
+              yield
+            else
+              raise "The #{option_name} configuration option is removed without replacement."
+            end
+          end
+        end
+        def register_class_option(option_name, &default)
+          scope = class << self; self; end
+          register_instance_option(option_name, scope, &default)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields.rb
@@ -0,0 +1,44 @@
+module RailsAdmin
+  module Config
+    module Fields
+      mattr_reader :default_factory
+      @@default_factory = proc do |parent, properties, fields|
+        if properties.association?
+          association = parent.abstract_model.associations.detect { |a| a.name.to_s == properties.name.to_s }
+          field = RailsAdmin::Config::Fields::Types.load("#{association.polymorphic? ? :polymorphic : properties.type}_association").new(parent, properties.name, association)
+        else
+          field = RailsAdmin::Config::Fields::Types.load(properties.type).new(parent, properties.name, properties)
+        end
+        fields << field
+        field
+      end
+      @@registry = [@@default_factory]
+      def self.factory(parent)
+        fields = []
+        parent.abstract_model.properties.each do |properties|
+          next if fields.detect { |f| f.name == properties.name }
+          @@registry.detect { |factory| factory.call(parent, properties, fields) }
+        end
+        parent.abstract_model.associations.reject { |a| a.type == :belongs_to }.each do |association| # :belongs_to are created by factory for belongs_to fields
+          next if fields.detect { |f| f.name == association.name }
+          @@registry.detect { |factory| factory.call(parent, association, fields) }
+        end
+        fields
+      end
+      def self.register_factory(&block)
+        @@registry.unshift(block)
+      end
+    end
+  end
+end
+require 'rails_admin/config/fields/types'
+require 'rails_admin/config/fields/factories/password'
+require 'rails_admin/config/fields/factories/enum'
+require 'rails_admin/config/fields/factories/devise'
+require 'rails_admin/config/fields/factories/paperclip'
+require 'rails_admin/config/fields/factories/dragonfly'
+require 'rails_admin/config/fields/factories/carrierwave'
+require 'rails_admin/config/fields/factories/active_storage'
+require 'rails_admin/config/fields/factories/shrine'
+require 'rails_admin/config/fields/factories/action_text'
+require 'rails_admin/config/fields/factories/association'

--- a//dev/null
+++ b/lib/rails_admin/config/fields/association.rb
@@ -0,0 +1,86 @@
+require 'rails_admin/config'
+require 'rails_admin/config/fields/base'
+module RailsAdmin
+  module Config
+    module Fields
+      class Association < RailsAdmin::Config::Fields::Base
+        def association
+          @properties
+        end
+        def method_name
+          association.key_accessor
+        end
+        register_instance_option :pretty_value do
+          v = bindings[:view]
+          [value].flatten.select(&:present?).collect do |associated|
+            amc = polymorphic? ? RailsAdmin.config(associated) : associated_model_config # perf optimization for non-polymorphic associations
+            am = amc.abstract_model
+            wording = associated.send(amc.object_label_method)
+            can_see = !am.embedded? && (show_action = v.action(:show, am, associated))
+            can_see ? v.link_to(wording, v.url_for(action: show_action.action_name, model_name: am.to_param, id: associated.id)) : ERB::Util.html_escape(wording)
+          end.to_sentence.html_safe.presence || '-'
+        end
+        register_instance_option :visible? do
+          @visible ||= !associated_model_config.excluded?
+        end
+        register_instance_option :label do
+          (@label ||= {})[::I18n.locale] ||= abstract_model.model.human_attribute_name association.name
+        end
+        register_instance_option :associated_collection_scope do
+          associated_collection_scope_limit = (associated_collection_cache_all ? nil : 30)
+          proc do |scope|
+            scope.limit(associated_collection_scope_limit)
+          end
+        end
+        register_instance_option :inverse_of do
+          association.inverse_of
+        end
+        register_instance_option :associated_collection_cache_all do
+          @associated_collection_cache_all ||= (associated_model_config.abstract_model.count < associated_model_limit)
+        end
+        register_instance_option :removable? do
+          association.foreign_key_nullable?
+        end
+        register_instance_option :eager_load do
+          !!searchable
+        end
+        register_instance_option :inline_add do
+          true
+        end
+        register_instance_option :inline_edit do
+          true
+        end
+        def associated_model_config
+          @associated_model_config ||= RailsAdmin.config(association.klass)
+        end
+        def associated_object_label_method
+          @associated_object_label_method ||= associated_model_config.object_label_method
+        end
+        def associated_primary_key
+          association.primary_key
+        end
+        def associated_prepopulate_params
+          {}
+        end
+        def polymorphic?
+          association.polymorphic?
+        end
+        register_instance_option :nested_form do
+          association.nested_options
+        end
+        def value
+          bindings[:object].send(association.name)
+        end
+        def multiple?
+          true
+        end
+        def virtual?
+          true
+        end
+        def associated_model_limit
+          RailsAdmin.config.default_associated_collection_limit
+        end
+      end
+    end
+  end
+end

--- a/lib/rails_admin/config/fields/base.rb
+++ b/lib/rails_admin/config/fields/base.rb
@@ -39,59 +39,31 @@
         end
         register_instance_option :column_width do
           nil
         end
         register_instance_option :sticky? do
           false
         end
         register_instance_option :sortable do
           !virtual? || children_fields.first || false
         end
-        def sort_column
-          if sortable == true
-            "#{abstract_model.table_name}.#{name}"
-          elsif (sortable.is_a?(String) || sortable.is_a?(Symbol)) && sortable.to_s.include?('.') # just provide sortable, don't do anything smart
-            sortable
-          elsif sortable.is_a?(Hash) # just join sortable hash, don't do anything smart
-            "#{sortable.keys.first}.#{sortable.values.first}"
-          elsif association # use column on target table
-            "#{associated_model_config.abstract_model.table_name}.#{sortable}"
-          else # use described column in the field conf.
-            "#{abstract_model.table_name}.#{sortable}"
-          end
-        end
         register_instance_option :searchable do
           !virtual? || children_fields.first || false
         end
-        register_instance_option :search_operator do
-          RailsAdmin::Config.default_search_operator
-        end
         register_instance_option :queryable? do
           !virtual?
         end
         register_instance_option :filterable? do
           !!searchable
         end
-        register_instance_option :filter_operators do
-          []
-        end
-        register_instance_option :default_filter_operator do
-          nil
-        end
-        def filter_options
-          {
-            label: label,
-            name: name,
-            operator: default_filter_operator,
-            operators: filter_operators,
-            type: type,
-          }
+        register_instance_option :search_operator do
+          @search_operator ||= RailsAdmin::Config.default_search_operator
         end
         register_instance_option :sort_reverse? do
           false
         end
         register_instance_option :searchable_columns do
           @searchable_columns ||=
             case searchable
             when true
               [{column: "#{abstract_model.table_name}.#{name}", type: type}]
             when false
@@ -188,20 +160,23 @@
           returned = true
           (RailsAdmin.config.default_hidden_fields || {}).each do |section, fields|
             next unless self.section.is_a?("RailsAdmin::Config::Sections::#{section.to_s.camelize}".constantize)
             returned = false if fields.include?(name)
           end
           returned
         end
         register_instance_option :children_fields do
           []
         end
+        register_instance_option :default_filter_operator do
+          nil
+        end
         register_instance_option :eager_load do
           false
         end
         register_deprecated_instance_option :eager_load?, :eager_load
         def eager_load_values
           case eager_load
           when true
             [name]
           when false, nil
             []
@@ -235,40 +210,40 @@
         end
         def optional=(state)
           optional(state)
         end
         def type
           @type ||= self.class.name.to_s.demodulize.underscore.to_sym
         end
         def value
           bindings[:object].safe_send(name)
         rescue NoMethodError => e
-          raise e.exception <<~ERROR
-            If you want to use a RailsAdmin virtual field(= a field without corresponding instance method),
-            you should declare 'formatted_value' in the field definition.
-              field :#{name} do
-                formatted_value{ bindings[:object].call_some_method }
-              end
+          raise e.exception <<-ERROR.gsub(/^\s{10}/, '')
+          If you want to use a RailsAdmin virtual field(= a field without corresponding instance method),
+          you should declare 'formatted_value' in the field definition.
+            field :#{name} do
+              formatted_value{ bindings[:object].call_some_method }
+            end
           ERROR
         end
         register_instance_option :nested_form do
           false
         end
         register_instance_option :allowed_methods do
           [method_name]
         end
         def generic_help
           "#{required? ? I18n.translate('admin.form.required') : I18n.translate('admin.form.optional')}. "
         end
         def generic_field_help
           model = abstract_model.model_name.underscore
-          model_lookup = :"admin.help.#{model}.#{name}"
+          model_lookup = "admin.help.#{model}.#{name}".to_sym
           translated = I18n.translate(model_lookup, help: generic_help, default: [generic_help])
           (translated.is_a?(Hash) ? translated.to_a.first[1] : translated).html_safe
         end
         def parse_value(value)
           value
         end
         def parse_input(_params)
         end
         def inverse_of
           nil

--- a/lib/rails_admin/config/fields/factories/active_storage.rb
+++ b/lib/rails_admin/config/fields/factories/active_storage.rb
@@ -3,23 +3,23 @@
 require 'rails_admin/config/fields/types/file_upload'
 RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
   if defined?(::ActiveStorage) && properties.try(:association?) && (match = /\A(.+)_attachments?\Z/.match properties.name) && properties.klass.to_s == 'ActiveStorage::Attachment'
     name = match[1]
     field = RailsAdmin::Config::Fields::Types.load(
       properties.type == :has_many ? :multiple_active_storage : :active_storage,
     ).new(parent, name, properties)
     fields << field
     associations =
       if properties.type == :has_many
-        [:"#{name}_attachments", :"#{name}_blobs"]
+        ["#{name}_attachments".to_sym, "#{name}_blobs".to_sym]
       else
-        [:"#{name}_attachment", :"#{name}_blob"]
+        ["#{name}_attachment".to_sym, "#{name}_blob".to_sym]
       end
     children_fields = associations.map do |child_name|
       child_association = parent.abstract_model.associations.detect { |p| p.name.to_sym == child_name }
       next unless child_association
       child_field = fields.detect { |f| f.name == child_name } || RailsAdmin::Config::Fields.default_factory.call(parent, child_association, fields)
       child_field.hide unless field == child_field
       child_field.filterable(false) unless field == child_field
       child_field.name
     end.flatten.compact
     field.children_fields(children_fields)

--- a//dev/null
+++ b/lib/rails_admin/config/fields/factories/association.rb
@@ -0,0 +1,26 @@
+require 'rails_admin/config/fields'
+require 'rails_admin/config/fields/types'
+require 'rails_admin/config/fields/types/belongs_to_association'
+RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
+  association = parent.abstract_model.associations.detect { |a| a.foreign_key == properties.name && %i[belongs_to has_and_belongs_to_many].include?(a.type) }
+  if association
+    field = RailsAdmin::Config::Fields::Types.load("#{association.polymorphic? ? :polymorphic : association.type}_association").new(parent, association.name, association)
+    fields << field
+    child_columns = []
+    possible_field_names = if association.polymorphic?
+                             %i[foreign_key foreign_type foreign_inverse_of]
+                           else
+                             [:foreign_key]
+                           end.collect { |k| association.send(k) }.compact
+    parent.abstract_model.properties.select { |p| possible_field_names.include? p.name }.each do |column|
+      child_field = fields.detect { |f| f.name.to_s == column.name.to_s }
+      child_field ||= RailsAdmin::Config::Fields.default_factory.call(parent, column, fields)
+      child_columns << child_field
+    end
+    child_columns.each do |child_column|
+      child_column.hide
+      child_column.filterable(false)
+    end
+    field.children_fields child_columns.collect(&:name)
+  end
+end

--- a/lib/rails_admin/config/fields/factories/carrierwave.rb
+++ b/lib/rails_admin/config/fields/factories/carrierwave.rb
@@ -1,17 +1,17 @@
 require 'rails_admin/config/fields'
 require 'rails_admin/config/fields/types'
 require 'rails_admin/config/fields/types/file_upload'
 RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
   model = parent.abstract_model.model
   if defined?(::CarrierWave) && model.is_a?(CarrierWave::Mount) && model.uploaders.include?(attachment_name = properties.name.to_s.chomp('_file_name').to_sym)
-    columns = [model.uploader_options[attachment_name][:mount_on] || attachment_name, :"#{attachment_name}_content_type", :"#{attachment_name}_file_size"]
+    columns = [model.uploader_options[attachment_name][:mount_on] || attachment_name, "#{attachment_name}_content_type".to_sym, "#{attachment_name}_file_size".to_sym]
     field = RailsAdmin::Config::Fields::Types.load(
       %i[serialized json].include?(properties.type) ? :multiple_carrierwave : :carrierwave,
     ).new(parent, attachment_name, properties)
     fields << field
     children_fields = []
     columns.each do |children_column_name|
       child_properties = parent.abstract_model.properties.detect { |p| p.name.to_s == children_column_name.to_s }
       next unless child_properties
       children_field = fields.detect { |f| f.name == children_column_name } || RailsAdmin::Config::Fields.default_factory.call(parent, child_properties, fields)
       children_field.hide unless field == children_field

--- a//dev/null
+++ b/lib/rails_admin/config/fields/factories/devise.rb
@@ -0,0 +1,23 @@
+require 'rails_admin/config/fields'
+require 'rails_admin/config/fields/types'
+require 'rails_admin/config/fields/types/password'
+RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
+  if properties.name == :encrypted_password
+    extensions = %i[password_salt reset_password_token remember_token]
+    fields << RailsAdmin::Config::Fields::Types.load(:password).new(parent, :password, properties)
+    fields << RailsAdmin::Config::Fields::Types.load(:password).new(parent, :password_confirmation, properties)
+    extensions.each do |ext|
+      properties = parent.abstract_model.properties.detect { |p| ext == p.name }
+      next unless properties
+      field = fields.detect { |f| f.name == ext }
+      unless field
+        RailsAdmin::Config::Fields.default_factory.call(parent, properties, fields)
+        field = fields.last
+      end
+      field.hide
+    end
+    true
+  else
+    false
+  end
+end

--- a/lib/rails_admin/config/fields/factories/dragonfly.rb
+++ b/lib/rails_admin/config/fields/factories/dragonfly.rb
@@ -1,20 +1,20 @@
 require 'rails_admin/config/fields'
 require 'rails_admin/config/fields/types'
 require 'rails_admin/config/fields/types/file_upload'
 RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
   extensions = %i[name uid]
   if (properties.name.to_s =~ /^(.+)_uid$/) && defined?(::Dragonfly) && parent.abstract_model.model.respond_to?(:dragonfly_attachment_classes) && parent.abstract_model.model.dragonfly_attachment_classes.collect(&:attribute).include?(attachment_name = Regexp.last_match[1].to_sym)
     field = RailsAdmin::Config::Fields::Types.load(:dragonfly).new(parent, attachment_name, properties)
     children_fields = []
     extensions.each do |ext|
-      children_column_name = :"#{attachment_name}_#{ext}"
+      children_column_name = "#{attachment_name}_#{ext}".to_sym
       child_properties = parent.abstract_model.properties.detect { |p| p.name.to_s == children_column_name.to_s }
       next unless child_properties
       children_field = fields.detect { |f| f.name == children_column_name } || RailsAdmin::Config::Fields.default_factory.call(parent, child_properties, fields)
       children_field.hide
       children_field.filterable(false)
       children_fields << children_field.name
     end
     field.children_fields(children_fields)
     fields << field
     true

--- a/lib/rails_admin/config/fields/factories/paperclip.rb
+++ b/lib/rails_admin/config/fields/factories/paperclip.rb
@@ -1,21 +1,21 @@
 require 'rails_admin/config/fields'
 require 'rails_admin/config/fields/types'
 require 'rails_admin/config/fields/types/file_upload'
 RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
   extensions = %i[file_name content_type file_size updated_at fingerprint]
   model = parent.abstract_model.model
   if (properties.name.to_s =~ /^(.+)_file_name$/) && defined?(::Paperclip) && model.try(:attachment_definitions) && model.attachment_definitions.key?(attachment_name = Regexp.last_match[1].to_sym)
     field = RailsAdmin::Config::Fields::Types.load(:paperclip).new(parent, attachment_name, properties)
     children_fields = []
     extensions.each do |ext|
-      children_column_name = :"#{attachment_name}_#{ext}"
+      children_column_name = "#{attachment_name}_#{ext}".to_sym
       child_properties = parent.abstract_model.properties.detect { |p| p.name.to_s == children_column_name.to_s }
       next unless child_properties
       children_field = fields.detect { |f| f.name == children_column_name } || RailsAdmin::Config::Fields.default_factory.call(parent, child_properties, fields)
       children_field.hide
       children_field.filterable(false)
       children_fields << children_field.name
     end
     field.children_fields(children_fields)
     fields << field
     true

--- a/lib/rails_admin/config/fields/factories/shrine.rb
+++ b/lib/rails_admin/config/fields/factories/shrine.rb
@@ -2,19 +2,19 @@
 require 'rails_admin/config/fields/types'
 require 'rails_admin/config/fields/types/file_upload'
 RailsAdmin::Config::Fields.register_factory do |parent, properties, fields|
   next false unless defined?(::Shrine)
   attachment_names = parent.abstract_model.model.ancestors.select { |m| m.is_a?(Shrine::Attachment) }.map { |a| a.instance_variable_get('@name') }
   next false if attachment_names.blank?
   attachment_name = attachment_names.detect { |a| a == properties.name.to_s.chomp('_data').to_sym }
   next false unless attachment_name
   field = RailsAdmin::Config::Fields::Types.load(:shrine).new(parent, attachment_name, properties)
   fields << field
-  data_field_name = :"#{attachment_name}_data"
+  data_field_name = "#{attachment_name}_data".to_sym
   child_properties = parent.abstract_model.properties.detect { |p| p.name == data_field_name }
   next true unless child_properties
   children_field = fields.detect { |f| f.name == data_field_name } || RailsAdmin::Config::Fields.default_factory.call(parent, child_properties, fields)
   children_field.hide unless field == children_field
   children_field.filterable(false) unless field == children_field
   field.children_fields([data_field_name])
   true
 end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/group.rb
@@ -0,0 +1,49 @@
+require 'active_support/core_ext/string/inflections'
+require 'rails_admin/config/proxyable'
+require 'rails_admin/config/configurable'
+require 'rails_admin/config/hideable'
+module RailsAdmin
+  module Config
+    module Fields
+      class Group
+        include RailsAdmin::Config::Proxyable
+        include RailsAdmin::Config::Configurable
+        include RailsAdmin::Config::Hideable
+        attr_reader :name, :abstract_model, :parent, :root
+        attr_accessor :section
+        def initialize(parent, name)
+          @parent = parent
+          @root = parent.root
+          @abstract_model = parent.abstract_model
+          @section = parent
+          @name = name.to_s.tr(' ', '_').downcase.to_sym
+        end
+        def field(name, type = nil, &block)
+          field = section.field(name, type, &block)
+          field.instance_variable_set('@group', self)
+          field
+        end
+        def fields
+          section.fields.select { |f| f.group == self }
+        end
+        def fields_of_type(type, &block)
+          selected = section.fields.select { |f| type == f.type }
+          selected.each { |f| f.instance_eval(&block) } if block
+          selected
+        end
+        def visible_fields
+          section.with(bindings).visible_fields.select { |f| f.group == self }
+        end
+        register_instance_option :active? do
+          true
+        end
+        register_instance_option :label do
+          (@label ||= {})[::I18n.locale] ||= (parent.fields.detect { |f| f.name == name }.try(:label) || name.to_s.humanize)
+        end
+        register_instance_option :help do
+          nil
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types.rb
@@ -0,0 +1,23 @@
+require 'active_support/core_ext/string/inflections'
+require 'rails_admin/config/fields'
+require 'rails_admin/config/fields/association'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        @@registry = {}
+        def self.load(type)
+          @@registry.fetch(type.to_sym) { raise "Unsupported field datatype: #{type}" }
+        end
+        def self.register(type, klass = nil)
+          if klass.nil? && type.is_a?(Class)
+            klass = type
+            type = klass.name.to_s.demodulize.underscore
+          end
+          @@registry[type.to_sym] = klass
+        end
+        require 'rails_admin/config/fields/types/all'
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/action_text.rb
@@ -0,0 +1,24 @@
+require 'rails_admin/config/fields/types/text'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class ActionText < Text
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :version do
+            '1.3.1'
+          end
+          register_instance_option :css_location do
+            "https://cdnjs.cloudflare.com/ajax/libs/trix/#{version}/trix.css"
+          end
+          register_instance_option :js_location do
+            "https://cdnjs.cloudflare.com/ajax/libs/trix/#{version}/trix.js"
+          end
+          register_instance_option :partial do
+            :form_action_text
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/active_record_enum.rb
@@ -0,0 +1,46 @@
+require 'rails_admin/config/fields/types/enum'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class ActiveRecordEnum < Enum
+          RailsAdmin::Config::Fields::Types.register(self)
+          def type
+            :enum
+          end
+          register_instance_option :enum do
+            abstract_model.model.defined_enums[name.to_s]
+          end
+          register_instance_option :pretty_value do
+            bindings[:object].send(name).presence || ' - '
+          end
+          register_instance_option :multiple? do
+            false
+          end
+          register_instance_option :queryable do
+            false
+          end
+          def parse_value(value)
+            return unless value.present?
+            abstract_model.model.attribute_types[name.to_s].serialize(value)
+          end
+          def parse_input(params)
+            value = params[name]
+            return unless value
+            params[name] = parse_input_value(value)
+          end
+          def form_value
+            enum[super] || super
+          end
+        private
+          def parse_input_value(value)
+            abstract_model.model.attribute_types[name.to_s].deserialize(value)
+          end
+          def type_cast_value(value)
+            abstract_model.model.column_types[name.to_s].type_cast_from_user(value)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/active_storage.rb
@@ -0,0 +1,43 @@
+require 'rails_admin/config/fields/types/file_upload'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class ActiveStorage < RailsAdmin::Config::Fields::Types::FileUpload
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :thumb_method do
+            {resize_to_limit: [100, 100]}
+          end
+          register_instance_option :delete_method do
+            "remove_#{name}" if bindings[:object].respond_to?("remove_#{name}")
+          end
+          register_instance_option :image? do
+            if value
+              mime_type = Mime::Type.lookup_by_extension(value.filename.extension_without_delimiter)
+              mime_type.to_s.match?(/^image/)
+            end
+          end
+          register_instance_option :eager_load do
+            {"#{name}_attachment": :blob}
+          end
+          def resource_url(thumb = false)
+            return nil unless value
+            if thumb && value.variable?
+              thumb = thumb_method if thumb == true
+              variant = value.variant(thumb)
+              Rails.application.routes.url_helpers.rails_blob_representation_path(
+                variant.blob.signed_id, variant.variation.key, variant.blob.filename, only_path: true
+              )
+            else
+              Rails.application.routes.url_helpers.rails_blob_path(value, only_path: true)
+            end
+          end
+          def value
+            attachment = super
+            attachment if attachment&.attached?
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/all.rb
@@ -0,0 +1,41 @@
+require 'rails_admin/config/fields/types/action_text'
+require 'rails_admin/config/fields/types/active_record_enum'
+require 'rails_admin/config/fields/types/active_storage'
+require 'rails_admin/config/fields/types/belongs_to_association'
+require 'rails_admin/config/fields/types/boolean'
+require 'rails_admin/config/fields/types/bson_object_id'
+require 'rails_admin/config/fields/types/date'
+require 'rails_admin/config/fields/types/datetime'
+require 'rails_admin/config/fields/types/decimal'
+require 'rails_admin/config/fields/types/dragonfly'
+require 'rails_admin/config/fields/types/enum'
+require 'rails_admin/config/fields/types/file_upload'
+require 'rails_admin/config/fields/types/paperclip'
+require 'rails_admin/config/fields/types/carrierwave'
+require 'rails_admin/config/fields/types/multiple_file_upload'
+require 'rails_admin/config/fields/types/multiple_active_storage'
+require 'rails_admin/config/fields/types/multiple_carrierwave'
+require 'rails_admin/config/fields/types/float'
+require 'rails_admin/config/fields/types/has_and_belongs_to_many_association'
+require 'rails_admin/config/fields/types/has_many_association'
+require 'rails_admin/config/fields/types/has_one_association'
+require 'rails_admin/config/fields/types/integer'
+require 'rails_admin/config/fields/types/password'
+require 'rails_admin/config/fields/types/polymorphic_association'
+require 'rails_admin/config/fields/types/string'
+require 'rails_admin/config/fields/types/hidden'
+require 'rails_admin/config/fields/types/text'
+require 'rails_admin/config/fields/types/serialized'
+require 'rails_admin/config/fields/types/shrine'
+require 'rails_admin/config/fields/types/time'
+require 'rails_admin/config/fields/types/timestamp'
+require 'rails_admin/config/fields/types/color'
+require 'rails_admin/config/fields/types/simple_mde'
+require 'rails_admin/config/fields/types/ck_editor'
+require 'rails_admin/config/fields/types/code_mirror'
+require 'rails_admin/config/fields/types/wysihtml5'
+require 'rails_admin/config/fields/types/froala'
+require 'rails_admin/config/fields/types/json'
+require 'rails_admin/config/fields/types/inet'
+require 'rails_admin/config/fields/types/uuid'
+require 'rails_admin/config/fields/types/citext'

--- a/lib/rails_admin/config/fields/types/belongs_to_association.rb
+++ b/lib/rails_admin/config/fields/types/belongs_to_association.rb
@@ -1,39 +1,39 @@
 require 'rails_admin/config/fields/association'
 module RailsAdmin
   module Config
     module Fields
       module Types
         class BelongsToAssociation < RailsAdmin::Config::Fields::Association
           RailsAdmin::Config::Fields::Types.register(self)
-          register_instance_option :filter_operators do
-            %w[_discard like not_like is starts_with ends_with] + (required? ? [] : %w[_separator _present _blank])
-          end
           register_instance_option :formatted_value do
             (o = value) && o.send(associated_model_config.object_label_method)
           end
           register_instance_option :sortable do
             @sortable ||= abstract_model.adapter_supports_joins? && associated_model_config.abstract_model.properties.collect(&:name).include?(associated_model_config.object_label_method) ? associated_model_config.object_label_method : {abstract_model.table_name => method_name}
           end
           register_instance_option :searchable do
             @searchable ||= associated_model_config.abstract_model.properties.collect(&:name).include?(associated_model_config.object_label_method) ? [associated_model_config.object_label_method, {abstract_model.model => method_name}] : {abstract_model.model => method_name}
           end
           register_instance_option :partial do
             nested_form ? :form_nested_one : :form_filtering_select
           end
           register_instance_option :eager_load do
             true
           end
+          def associated_primary_key
+            association.primary_key
+          end
           def selected_id
-            bindings[:object].safe_send(association.key_accessor)
+            bindings[:object].send(association.key_accessor)
           end
           def method_name
-            nested_form ? :"#{name}_attributes" : super
+            nested_form ? "#{name}_attributes".to_sym : super
           end
           def multiple?
             false
           end
         end
       end
     end
   end
 end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/boolean.rb
@@ -0,0 +1,52 @@
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Boolean < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :labels do
+            {
+              true => %(<span class="fas fa-check"></span>),
+              false => %(<span class="fas fa-times"></span>),
+              nil => %(<span class="fas fa-minus"></span>),
+            }
+          end
+          register_instance_option :css_classes do
+            {
+              true => 'success',
+              false => 'danger',
+              nil => 'default',
+            }
+          end
+          register_instance_option :nullable? do
+            properties&.nullable?
+          end
+          register_instance_option :view_helper do
+            :check_box
+          end
+          register_instance_option :pretty_value do
+            %(<span class="label label-#{css_classes[form_value]}">#{labels[form_value]}</span>).html_safe
+          end
+          register_instance_option :export_value do
+            value.inspect
+          end
+          register_instance_option :partial do
+            :form_boolean
+          end
+          def form_value
+            case value
+            when true, false
+              value
+            end
+          end
+          def generic_help
+            ''
+          end
+          def parse_input(params)
+            params[name] = params[name].presence if params.key?(name)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/carrierwave.rb
@@ -0,0 +1,26 @@
+require 'rails_admin/config/fields/base'
+require 'rails_admin/config/fields/types/file_upload'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Carrierwave < RailsAdmin::Config::Fields::Types::FileUpload
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :thumb_method do
+            @thumb_method ||= ((versions = bindings[:object].send(name).versions.keys).detect { |k| k.in?([:thumb, :thumbnail, 'thumb', 'thumbnail']) } || versions.first.to_s)
+          end
+          register_instance_option :delete_method do
+            "remove_#{name}"
+          end
+          register_instance_option :cache_method do
+            "#{name}_cache"
+          end
+          def resource_url(thumb = false)
+            return nil unless (uploader = bindings[:object].send(name)).present?
+            thumb.present? ? uploader.send(thumb).url : uploader.url
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/citext.rb
@@ -0,0 +1,12 @@
+require 'rails_admin/config/fields/types/text'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Citext < Text
+          RailsAdmin::Config::Fields::Types.register(:citext, self)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/color.rb
@@ -0,0 +1,35 @@
+require 'rails_admin/config/fields/types/string_like'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Color < StringLike
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :pretty_value do
+            bindings[:view].content_tag :strong, (value.presence || ' - '), style: "color: #{color}"
+          end
+          register_instance_option :partial do
+            :form_colorpicker
+          end
+          register_instance_option :view_helper do
+            :color_field
+          end
+          register_instance_option :color do
+            if value.present?
+              if /^[0-9a-fA-F]{3,6}$/.match?(value)
+                "##{value}"
+              else
+                value
+              end
+            else
+              'white'
+            end
+          end
+          register_instance_option :export_value do
+            formatted_value
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/date.rb
@@ -0,0 +1,33 @@
+require 'rails_admin/config/fields/types/datetime'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Date < RailsAdmin::Config::Fields::Types::Datetime
+          RailsAdmin::Config::Fields::Types.register(self)
+          def parse_value(value)
+            ::Date.parse(value) if value.present?
+          end
+          register_instance_option :date_format do
+            :long
+          end
+          register_instance_option :datepicker_options do
+            {
+              allowInput: true,
+              altFormat: flatpickr_format,
+            }
+          end
+          register_instance_option :i18n_scope do
+            %i[date formats]
+          end
+          register_instance_option :html_attributes do
+            {
+              required: required?,
+              size: 18,
+            }
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/datetime.rb
@@ -0,0 +1,69 @@
+require 'rails_admin/config/fields/base'
+require 'rails_admin/support/datetime'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Datetime < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          def parse_value(value)
+            ::Time.zone.parse(value)
+          end
+          def parse_input(params)
+            params[name] = parse_value(params[name]) if params[name]
+          end
+          register_instance_option :date_format do
+            :long
+          end
+          register_instance_option :i18n_scope do
+            %i[time formats]
+          end
+          register_instance_option :strftime_format do
+            ::I18n.t(date_format, scope: i18n_scope, raise: true)
+          rescue ::I18n::ArgumentError
+            '%B %d, %Y %H:%M'
+          end
+          register_instance_option :flatpickr_format do
+            RailsAdmin::Support::Datetime.to_flatpickr_format(strftime_format)
+          end
+          register_instance_option :datepicker_options do
+            {
+              allowInput: true,
+              enableTime: true,
+              altFormat: flatpickr_format,
+            }
+          end
+          register_instance_option :html_attributes do
+            {
+              required: required?,
+              size: 22,
+            }
+          end
+          register_instance_option :sort_reverse? do
+            true
+          end
+          register_instance_option :queryable? do
+            false
+          end
+          register_instance_option :formatted_value do
+            time = (value || default_value)
+            if time
+              ::I18n.l(time, format: strftime_format)
+            else
+              ''.html_safe
+            end
+          end
+          register_instance_option :partial do
+            :form_datetime
+          end
+          register_deprecated_instance_option :momentjs_format do
+            ActiveSupport::Deprecation.warn('The momentjs_format configuration option is deprecated, please use flatpickr_format with corresponding values here: https://flatpickr.js.org/formatting/')
+          end
+          def form_value
+            value&.in_time_zone&.strftime('%FT%T') || form_default_value
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/decimal.rb
@@ -0,0 +1,18 @@
+require 'rails_admin/config/fields/types/numeric'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Decimal < RailsAdmin::Config::Fields::Types::Numeric
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :html_attributes do
+            {
+              required: required?,
+              step: 'any',
+            }
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/dragonfly.rb
@@ -0,0 +1,35 @@
+require 'rails_admin/config/fields/base'
+require 'rails_admin/config/fields/types/file_upload'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Dragonfly < RailsAdmin::Config::Fields::Types::FileUpload
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :image? do
+            false unless value
+            if abstract_model.model.new.respond_to?("#{name}_name")
+              mime_type = Mime::Type.lookup_by_extension(bindings[:object].send("#{name}_name").to_s.split('.').last)
+              mime_type.to_s.match?(/^image/)
+            else
+              true # Dragonfly really is image oriented
+            end
+          end
+          register_instance_option :delete_method do
+            "remove_#{name}"
+          end
+          register_instance_option :cache_method do
+            "retained_#{name}"
+          end
+          register_instance_option :thumb_method do
+            '100x100>'
+          end
+          def resource_url(thumb = false)
+            return nil unless (v = value)
+            thumb ? v.thumb(thumb).try(:url) : v.url
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/enum.rb
@@ -0,0 +1,33 @@
+require 'rails_admin/config/fields/types/string'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Enum < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :partial do
+            :form_enumeration
+          end
+          register_instance_option :enum_method do
+            @enum_method ||= bindings[:object].class.respond_to?("#{name}_enum") || bindings[:object].respond_to?("#{name}_enum") ? "#{name}_enum" : name
+          end
+          register_instance_option :enum do
+            bindings[:object].class.respond_to?(enum_method) ? bindings[:object].class.send(enum_method) : bindings[:object].send(enum_method)
+          end
+          register_instance_option :pretty_value do
+            if enum.is_a?(::Hash)
+              enum.select { |_k, v| v.to_s == value.to_s }.keys.first.to_s.presence || value.presence || ' - '
+            elsif enum.is_a?(::Array) && enum.first.is_a?(::Array)
+              enum.detect { |e| e[1].to_s == value.to_s }.try(:first).to_s.presence || value.presence || ' - '
+            else
+              value.presence || ' - '
+            end
+          end
+          register_instance_option :multiple? do
+            properties && [:serialized].include?(properties.type)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/file_upload.rb
@@ -0,0 +1,64 @@
+require 'rails_admin/config/fields/types/string'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class FileUpload < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :partial do
+            :form_file_upload
+          end
+          register_instance_option :thumb_method do
+            nil
+          end
+          register_instance_option :delete_method do
+            nil
+          end
+          register_instance_option :cache_method do
+            nil
+          end
+          register_instance_option :cache_value do
+            bindings[:object].public_send(cache_method) if cache_method
+          end
+          register_instance_option :export_value do
+            resource_url.to_s
+          end
+          register_instance_option :link_name do
+            value
+          end
+          register_instance_option :pretty_value do
+            if value.presence
+              v = bindings[:view]
+              url = resource_url
+              if image
+                thumb_url = resource_url(thumb_method)
+                image_html = v.image_tag(thumb_url, class: 'img-thumbnail')
+                url == thumb_url ? image_html : v.link_to(image_html, url, target: '_blank', rel: 'noopener noreferrer')
+              else
+                v.link_to(link_name, url, target: '_blank', rel: 'noopener noreferrer')
+              end
+            end
+          end
+          register_instance_option :image? do
+            mime_type = Mime::Type.lookup_by_extension(resource_url.to_s.split('.').last)
+            mime_type.to_s.match?(/^image/)
+          end
+          register_instance_option :allowed_methods do
+            [method_name, delete_method, cache_method].compact
+          end
+          register_instance_option :html_attributes do
+            {
+              required: required? && !value.present?,
+            }
+          end
+          def resource_url
+            raise 'not implemented'
+          end
+          def virtual?
+            true
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/float.rb
@@ -0,0 +1,18 @@
+require 'rails_admin/config/fields/types/numeric'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Float < RailsAdmin::Config::Fields::Types::Numeric
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :html_attributes do
+            {
+              required: required?,
+              step: 'any',
+            }
+          end
+        end
+      end
+    end
+  end
+end

--- a/lib/rails_admin/config/fields/types/has_many_association.rb
+++ b/lib/rails_admin/config/fields/types/has_many_association.rb
@@ -5,21 +5,21 @@
       module Types
         class HasManyAssociation < RailsAdmin::Config::Fields::Association
           RailsAdmin::Config::Fields::Types.register(self)
           register_instance_option :partial do
             nested_form ? :form_nested_many : :form_filtering_multiselect
           end
           register_instance_option :orderable do
             false
           end
           def method_name
-            nested_form ? :"#{name}_attributes" : super
+            nested_form ? "#{name}_attributes".to_sym : super
           end
           def errors
             bindings[:object].errors[name]
           end
           def associated_prepopulate_params
             {associated_model_config.abstract_model.param_key => {association.foreign_key => bindings[:object].try(:id)}}
           end
         end
       end
     end

--- a/lib/rails_admin/config/fields/types/has_one_association.rb
+++ b/lib/rails_admin/config/fields/types/has_one_association.rb
@@ -1,31 +1,28 @@
 require 'rails_admin/config/fields/association'
 module RailsAdmin
   module Config
     module Fields
       module Types
         class HasOneAssociation < RailsAdmin::Config::Fields::Association
           RailsAdmin::Config::Fields::Types.register(self)
-          register_instance_option :filter_operators do
-            %w[_discard like not_like is starts_with ends_with] + (required? ? [] : %w[_separator _present _blank])
-          end
           register_instance_option :partial do
             nested_form ? :form_nested_one : :form_filtering_select
           end
           register_instance_option :formatted_value do
             (o = value) && o.send(associated_model_config.object_label_method)
           end
           def selected_id
-            value.try(:id).try(:to_s)
+            value.try :id
           end
           def method_name
-            nested_form ? :"#{name}_attributes" : super
+            nested_form ? "#{name}_attributes".to_sym : super
           end
           def multiple?
             false
           end
           def associated_prepopulate_params
             {associated_model_config.abstract_model.param_key => {association.foreign_key => bindings[:object].try(:id)}}
           end
         end
       end
     end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/integer.rb
@@ -0,0 +1,15 @@
+require 'rails_admin/config/fields/types/numeric'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Integer < RailsAdmin::Config::Fields::Types::Numeric
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :sort_reverse? do
+            serial?
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/multiple_active_storage.rb
@@ -0,0 +1,46 @@
+require 'rails_admin/config/fields/types/multiple_file_upload'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class MultipleActiveStorage < RailsAdmin::Config::Fields::Types::MultipleFileUpload
+          RailsAdmin::Config::Fields::Types.register(self)
+          class ActiveStorageAttachment < RailsAdmin::Config::Fields::Types::MultipleFileUpload::AbstractAttachment
+            register_instance_option :thumb_method do
+              {resize_to_limit: [100, 100]}
+            end
+            register_instance_option :delete_value do
+              value.id
+            end
+            register_instance_option :image? do
+              if value
+                mime_type = Mime::Type.lookup_by_extension(value.filename.extension_without_delimiter)
+                mime_type.to_s.match?(/^image/)
+              end
+            end
+            def resource_url(thumb = false)
+              return nil unless value
+              if thumb && value.variable?
+                variant = value.variant(thumb_method)
+                Rails.application.routes.url_helpers.rails_blob_representation_path(
+                  variant.blob.signed_id, variant.variation.key, variant.blob.filename, only_path: true
+                )
+              else
+                Rails.application.routes.url_helpers.rails_blob_path(value, only_path: true)
+              end
+            end
+          end
+          register_instance_option :attachment_class do
+            ActiveStorageAttachment
+          end
+          register_instance_option :delete_method do
+            "remove_#{name}" if bindings[:object].respond_to?("remove_#{name}")
+          end
+          register_instance_option :eager_load do
+            {"#{name}_attachments": :blob}
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/multiple_carrierwave.rb
@@ -0,0 +1,45 @@
+require 'rails_admin/config/fields/types/multiple_file_upload'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class MultipleCarrierwave < RailsAdmin::Config::Fields::Types::MultipleFileUpload
+          RailsAdmin::Config::Fields::Types.register(self)
+          class CarrierwaveAttachment < RailsAdmin::Config::Fields::Types::MultipleFileUpload::AbstractAttachment
+            register_instance_option :thumb_method do
+              @thumb_method ||= ((versions = value.versions.keys).detect { |k| k.in?([:thumb, :thumbnail, 'thumb', 'thumbnail']) } || versions.first.to_s)
+            end
+            register_instance_option :keep_value do
+              value.cache_name || value.identifier
+            end
+            register_instance_option :delete_value do
+              value.file.filename
+            end
+            def resource_url(thumb = false)
+              return nil unless value
+              thumb.present? ? value.send(thumb).url : value.url
+            end
+          end
+          register_instance_option :attachment_class do
+            CarrierwaveAttachment
+          end
+          register_instance_option :cache_method do
+            "#{name}_cache" unless ::CarrierWave::VERSION >= '2'
+          end
+          register_instance_option :keep_method do
+            name if ::CarrierWave::VERSION >= '2'
+          end
+          register_instance_option :reorderable? do
+            ::CarrierWave::VERSION >= '2'
+          end
+          register_instance_option :delete_method do
+            "delete_#{name}" if bindings[:object].respond_to?("delete_#{name}")
+          end
+          def value
+            bindings[:object].send(name)
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/multiple_file_upload.rb
@@ -0,0 +1,101 @@
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class MultipleFileUpload < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          class AbstractAttachment
+            include RailsAdmin::Config::Proxyable
+            include RailsAdmin::Config::Configurable
+            attr_reader :value
+            def initialize(value)
+              @value = value
+            end
+            register_instance_option :thumb_method do
+              nil
+            end
+            register_instance_option :keep_value do
+              nil
+            end
+            register_instance_option :delete_value do
+              nil
+            end
+            register_deprecated_instance_option :delete_key, :delete_value
+            register_instance_option :pretty_value do
+              if value.presence
+                v = bindings[:view]
+                url = resource_url
+                if image
+                  thumb_url = resource_url(thumb_method)
+                  image_html = v.image_tag(thumb_url, class: 'img-thumbnail')
+                  url == thumb_url ? image_html : v.link_to(image_html, url, target: '_blank', rel: 'noopener noreferrer')
+                else
+                  display_value = value.respond_to?(:filename) ? value.filename : value
+                  v.link_to(display_value, url, target: '_blank', rel: 'noopener noreferrer')
+                end
+              end
+            end
+            register_instance_option :image? do
+              mime_type = Mime::Type.lookup_by_extension(resource_url.to_s.split('.').last)
+              mime_type.to_s.match?(/^image/)
+            end
+            def resource_url(_thumb = false)
+              raise 'not implemented'
+            end
+          end
+          def initialize(*args)
+            super
+            @attachment_configurations = []
+          end
+          register_instance_option :attachment_class do
+            AbstractAttachment
+          end
+          register_instance_option :partial do
+            :form_multiple_file_upload
+          end
+          register_instance_option :cache_method do
+            nil
+          end
+          register_instance_option :delete_method do
+            nil
+          end
+          register_instance_option :keep_method do
+            nil
+          end
+          register_instance_option :reorderable? do
+            false
+          end
+          register_instance_option :export_value do
+            attachments.map(&:resource_url).map(&:to_s).join(',')
+          end
+          register_instance_option :pretty_value do
+            bindings[:view].safe_join attachments.map(&:pretty_value), ' '
+          end
+          register_instance_option :allowed_methods do
+            [method_name, cache_method, delete_method].compact
+          end
+          register_instance_option :html_attributes do
+            {
+              required: required? && !value.present?,
+            }
+          end
+          def attachment(&block)
+            @attachment_configurations << block
+          end
+          def attachments
+            Array(value).map do |attached|
+              attachment = attachment_class.new(attached)
+              @attachment_configurations.each do |config|
+                attachment.instance_eval(&config)
+              end
+              attachment.with(bindings)
+            end
+          end
+          def virtual?
+            true
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/numeric.rb
@@ -0,0 +1,15 @@
+require 'rails_admin/config/fields/base'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Numeric < RailsAdmin::Config::Fields::Base
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :view_helper do
+            :number_field
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/polymorphic_association.rb
@@ -0,0 +1,69 @@
+require 'rails_admin/config/fields/types/belongs_to_association'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class PolymorphicAssociation < RailsAdmin::Config::Fields::Types::BelongsToAssociation
+          RailsAdmin::Config::Fields::Types.register(self)
+          register_instance_option :partial do
+            :form_polymorphic_association
+          end
+          register_instance_option :visible? do
+            associated_model_config.any?
+          end
+          register_instance_option :formatted_value do
+            (o = value) && o.send(RailsAdmin.config(o).object_label_method)
+          end
+          register_instance_option :sortable do
+            false
+          end
+          register_instance_option :searchable do
+            false
+          end
+          register_instance_option :associated_collection_cache_all do
+            false
+          end
+          register_instance_option :associated_collection_scope do
+            nil
+          end
+          register_instance_option :allowed_methods do
+            [children_fields]
+          end
+          register_instance_option :eager_load do
+            false
+          end
+          def associated_collection(type)
+            return [] if type.blank?
+            config = RailsAdmin.config(type)
+            config.abstract_model.all.collect do |object|
+              [object.send(config.object_label_method), object.id]
+            end
+          end
+          def associated_model_config
+            @associated_model_config ||= association.klass.collect { |type| RailsAdmin.config(type) }.reject(&:excluded?)
+          end
+          def polymorphic_type_collection
+            associated_model_config.collect do |config|
+              [config.label, config.abstract_model.model.name]
+            end
+          end
+          def polymorphic_type_urls
+            types = associated_model_config.collect do |config|
+              [config.abstract_model.model.name, config.abstract_model.to_param]
+            end
+            ::Hash[*types.collect { |v| [v[0], bindings[:view].index_path(v[1])] }.flatten]
+          end
+          def value
+            bindings[:object].send(association.name)
+          end
+          def parse_input(params)
+            if (type_value = params[association.foreign_type.to_sym]).present?
+              config = associated_model_config.find { |c| type_value == c.abstract_model.model.name }
+              params[association.foreign_type.to_sym] = config.abstract_model.base_class.name if config
+            end
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/string.rb
@@ -0,0 +1,43 @@
+require 'rails_admin/config/fields/types/string_like'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class String < StringLike
+          RailsAdmin::Config::Fields::Types.register(self)
+          def input_size
+            [50, length.to_i].reject(&:zero?).min
+          end
+          register_instance_option :html_attributes do
+            {
+              required: required?,
+              maxlength: length,
+              size: input_size,
+            }
+          end
+          def generic_help
+            text = "#{required? ? I18n.translate('admin.form.required') : I18n.translate('admin.form.optional')}. "
+            if valid_length.present? && valid_length[:is].present?
+              text += "#{I18n.translate('admin.form.char_length_of').capitalize} #{valid_length[:is]}."
+            else
+              max_length = [length, valid_length[:maximum] || nil].compact.min
+              min_length = [0, valid_length[:minimum] || nil].compact.max
+              if max_length
+                text +=
+                  if min_length == 0
+                    "#{I18n.translate('admin.form.char_length_up_to').capitalize} #{max_length}."
+                  else
+                    "#{I18n.translate('admin.form.char_length_of').capitalize} #{min_length}-#{max_length}."
+                  end
+              end
+            end
+            text
+          end
+          register_instance_option :partial do
+            :form_field
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/time.rb
@@ -0,0 +1,26 @@
+require 'rails_admin/config/fields/types/datetime'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Time < RailsAdmin::Config::Fields::Types::Datetime
+          RailsAdmin::Config::Fields::Types.register(self)
+          def parse_value(value)
+            abstract_model.model.type_for_attribute(name.to_s).serialize(super)&.change(year: 2000, month: 1, day: 1)
+          end
+          register_instance_option :datepicker_options do
+            {
+              allowInput: true,
+              altFormat: flatpickr_format,
+              enableTime: true,
+              noCalendar: true,
+            }
+          end
+          register_instance_option :strftime_format do
+            '%H:%M'
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/fields/types/timestamp.rb
@@ -0,0 +1,12 @@
+require 'rails_admin/config/fields/types/datetime'
+module RailsAdmin
+  module Config
+    module Fields
+      module Types
+        class Timestamp < RailsAdmin::Config::Fields::Types::Datetime
+          RailsAdmin::Config::Fields::Types.register(self)
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/has_fields.rb
@@ -0,0 +1,95 @@
+module RailsAdmin
+  module Config
+    module HasFields
+      def field(name, type = nil, add_to_section = true, &block)
+        field = _fields.detect { |f| name == f.name }
+        field.show if field && !field.instance_variable_get("@#{field.name}_registered").is_a?(Proc)
+        if field.nil? && type.nil?
+          field = (_fields << RailsAdmin::Config::Fields::Types.load(:string).new(self, name, nil)).last
+        elsif type && type != (field.nil? ? nil : field.type)
+          if field
+            properties = field.properties
+            field = _fields[_fields.index(field)] = RailsAdmin::Config::Fields::Types.load(type).new(self, name, properties)
+          else
+            properties = abstract_model.properties.detect { |p| name == p.name }
+            field = (_fields << RailsAdmin::Config::Fields::Types.load(type).new(self, name, properties)).last
+          end
+        end
+        if add_to_section && !field.defined
+          field.defined = true
+          field.order = _fields.count(&:defined)
+        end
+        field.instance_eval(&block) if block
+        field
+      end
+      def configure(name, type = nil, &block)
+        [*name].each { |field_name| field(field_name, type, false, &block) }
+      end
+      def include_fields(*field_names, &block)
+        if field_names.empty?
+          _fields.select { |f| f.instance_eval(&block) }.each do |f|
+            next if f.defined
+            f.defined = true
+            f.order = _fields.count(&:defined)
+          end
+        else
+          fields(*field_names, &block)
+        end
+      end
+      def exclude_fields(*field_names, &block)
+        block ||= proc { |f| field_names.include?(f.name) }
+        _fields.each { |f| f.defined = true } if _fields.select(&:defined).empty?
+        _fields.select { |f| f.instance_eval(&block) }.each { |f| f.defined = false }
+      end
+      alias_method :exclude_fields_if, :exclude_fields
+      alias_method :include_fields_if, :include_fields
+      def include_all_fields
+        include_fields_if { true }
+      end
+      def fields(*field_names, &block)
+        return all_fields if field_names.empty? && !block
+        if field_names.empty?
+          defined = _fields.select(&:defined)
+          defined = _fields if defined.empty?
+        else
+          defined = field_names.collect { |field_name| _fields.detect { |f| f.name == field_name } }
+        end
+        defined.collect do |f|
+          unless f.defined
+            f.defined = true
+            f.order = _fields.count(&:defined)
+          end
+          f.instance_eval(&block) if block
+          f
+        end
+      end
+      def fields_of_type(type, &block)
+        _fields.select { |f| type == f.type }.map! { |f| f.instance_eval(&block) } if block
+      end
+      def all_fields
+        ((ro_fields = _fields(true)).select(&:defined).presence || ro_fields).collect do |f|
+          f.section = self
+          f
+        end
+      end
+      def visible_fields
+        i = 0
+        all_fields.collect { |f| f.with(bindings) }.select(&:visible?).sort_by { |f| [f.order, i += 1] } # stable sort, damn
+      end
+      def possible_fields
+        _fields(true)
+      end
+    protected
+      def _fields(readonly = false)
+        return @_fields if @_fields
+        return @_ro_fields if readonly && @_ro_fields
+        if instance_of?(RailsAdmin::Config::Sections::Base)
+          @_ro_fields = @_fields = RailsAdmin::Config::Fields.factory(self)
+        else
+          @_ro_fields ||= parent.send(self.class.superclass.to_s.underscore.split('/').last)._fields(true).clone.freeze
+        end
+        readonly ? @_ro_fields : (@_fields ||= @_ro_fields.collect(&:clone))
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/hideable.rb
@@ -0,0 +1,20 @@
+module RailsAdmin
+  module Config
+    module Hideable
+      def self.included(klass)
+        klass.register_instance_option :visible? do
+          !root.try :excluded?
+        end
+      end
+      def hidden?
+        !visible
+      end
+      def hide(&block)
+        visible block ? proc { instance_eval(&block) == false } : false
+      end
+      def show(&block)
+        visible block || true
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/inspectable.rb
@@ -0,0 +1,31 @@
+module RailsAdmin
+  module Config
+    module Inspectable
+      def inspect
+        set_named_instance_variables
+        instance_name = try(:name) || try(:abstract_model).try(:model).try(:name)
+        instance_name = instance_name ? "[#{instance_name}]" : ''
+        instance_vars = instance_variables.collect do |v|
+          instance_variable_name(v)
+        end.join(', ')
+        "#<#{self.class.name}#{instance_name} #{instance_vars}>"
+      end
+    private
+      def instance_variable_name(variable)
+        value = instance_variable_get(variable)
+        if self.class::NAMED_INSTANCE_VARIABLES.include?(variable)
+          if value.respond_to?(:name)
+            "#{variable}=#{value.name.inspect}"
+          else
+            "#{variable}=#{value.class.name}"
+          end
+        else
+          "#{variable}=#{value.inspect}"
+        end
+      end
+      def set_named_instance_variables
+        self.class.const_set('NAMED_INSTANCE_VARIABLES', []) unless defined?(self.class::NAMED_INSTANCE_VARIABLES)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/model.rb
@@ -0,0 +1,88 @@
+require 'rails_admin/config'
+require 'rails_admin/config/proxyable'
+require 'rails_admin/config/configurable'
+require 'rails_admin/config/hideable'
+require 'rails_admin/config/has_groups'
+require 'rails_admin/config/fields/group'
+require 'rails_admin/config/fields'
+require 'rails_admin/config/has_fields'
+require 'rails_admin/config/has_description'
+require 'rails_admin/config/sections'
+require 'rails_admin/config/actions'
+require 'rails_admin/config/inspectable'
+module RailsAdmin
+  module Config
+    class Model
+      include RailsAdmin::Config::Proxyable
+      include RailsAdmin::Config::Configurable
+      include RailsAdmin::Config::Hideable
+      include RailsAdmin::Config::Sections
+      include RailsAdmin::Config::Inspectable
+      attr_reader :abstract_model, :parent, :root
+      attr_accessor :groups
+      NAMED_INSTANCE_VARIABLES = %i[@parent @root].freeze
+      def initialize(entity)
+        @parent = nil
+        @root = self
+        @abstract_model =
+          case entity
+          when RailsAdmin::AbstractModel
+            entity
+          when Class, String, Symbol
+            RailsAdmin::AbstractModel.new(entity)
+          else
+            RailsAdmin::AbstractModel.new(entity.class)
+          end
+        @groups = [RailsAdmin::Config::Fields::Group.new(self, :default).tap { |g| g.label { I18n.translate('admin.form.basic_info') } }]
+      end
+      def excluded?
+        return @excluded if defined?(@excluded)
+        @excluded = !RailsAdmin::AbstractModel.all.collect(&:model_name).include?(abstract_model.try(:model_name))
+      end
+      def object_label
+        bindings[:object].send(object_label_method).presence ||
+          bindings[:object].send(:rails_admin_default_object_label_method)
+      end
+      register_instance_option :object_label_method do
+        @object_label_method ||= Config.label_methods.detect { |method| (@dummy_object ||= abstract_model.model.new).respond_to? method } || :rails_admin_default_object_label_method
+      end
+      register_instance_option :label do
+        (@label ||= {})[::I18n.locale] ||= abstract_model.model.model_name.human
+      end
+      register_instance_option :label_plural do
+        (@label_plural ||= {})[::I18n.locale] ||= abstract_model.model.model_name.human(count: Float::INFINITY, default: label.pluralize(::I18n.locale))
+      end
+      def pluralize(count)
+        count == 1 ? label : label_plural
+      end
+      register_instance_option :weight do
+        0
+      end
+      register_instance_option :parent do
+        @parent_model ||= begin
+          klass = abstract_model.model.superclass
+          klass = nil if klass.to_s.in?(%w[Object BasicObject ActiveRecord::Base])
+          klass
+        end
+      end
+      register_instance_option :navigation_label do
+        @navigation_label ||=
+          if (parent_module = abstract_model.model.try(:module_parent) || abstract_model.model.try!(:parent)) != Object
+            parent_module.to_s
+          end
+      end
+      register_instance_option :navigation_icon do
+        nil
+      end
+      register_instance_option :scope do
+        abstract_model.scoped
+      end
+      register_instance_option :last_created_at do
+        abstract_model.model.last.try(:created_at) if abstract_model.properties.detect { |c| c.name == :created_at }
+      end
+      def method_missing(method_name, *args, &block)
+        send(:base).send(method_name, *args, &block)
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/sections.rb
@@ -0,0 +1,28 @@
+require 'active_support/core_ext/string/inflections'
+require 'rails_admin/config/sections/base'
+require 'rails_admin/config/sections/edit'
+require 'rails_admin/config/sections/update'
+require 'rails_admin/config/sections/create'
+require 'rails_admin/config/sections/nested'
+require 'rails_admin/config/sections/modal'
+require 'rails_admin/config/sections/list'
+require 'rails_admin/config/sections/export'
+require 'rails_admin/config/sections/show'
+module RailsAdmin
+  module Config
+    module Sections
+      def self.included(klass)
+        constants.each do |name|
+          section = RailsAdmin::Config::Sections.const_get(name)
+          name = name.to_s.underscore.to_sym
+          klass.send(:define_method, name) do |&block|
+            @sections ||= {}
+            @sections[name] = section.new(self) unless @sections[name]
+            @sections[name].instance_eval(&block) if block
+            @sections[name]
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/sections/base.rb
@@ -0,0 +1,27 @@
+require 'rails_admin/config/proxyable'
+require 'rails_admin/config/configurable'
+require 'rails_admin/config/inspectable'
+require 'rails_admin/config/has_fields'
+require 'rails_admin/config/has_groups'
+require 'rails_admin/config/has_description'
+module RailsAdmin
+  module Config
+    module Sections
+      class Base
+        include RailsAdmin::Config::Proxyable
+        include RailsAdmin::Config::Configurable
+        include RailsAdmin::Config::Inspectable
+        include RailsAdmin::Config::HasFields
+        include RailsAdmin::Config::HasGroups
+        include RailsAdmin::Config::HasDescription
+        attr_reader :abstract_model, :parent, :root
+        NAMED_INSTANCE_VARIABLES = %i[@parent @root @abstract_model].freeze
+        def initialize(parent)
+          @parent = parent
+          @root = parent.root
+          @abstract_model = root.abstract_model
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/config/sections/list.rb
@@ -0,0 +1,42 @@
+require 'rails_admin/config/sections/base'
+module RailsAdmin
+  module Config
+    module Sections
+      class List < RailsAdmin::Config::Sections::Base
+        register_instance_option :checkboxes? do
+          true
+        end
+        register_instance_option :filters do
+          []
+        end
+        register_instance_option :items_per_page do
+          RailsAdmin::Config.default_items_per_page
+        end
+        register_instance_option :limited_pagination do
+          false
+        end
+        register_instance_option :search_by do
+          nil
+        end
+        register_instance_option :sort_by do
+          parent.abstract_model.primary_key
+        end
+        register_instance_option :scopes do
+          []
+        end
+        register_instance_option :row_css_class do
+          ''
+        end
+        register_deprecated_instance_option :sidescroll do
+          ActiveSupport::Deprecation.warn('The sidescroll configuration option was removed, it is always enabled now.')
+        end
+        def fields_for_table
+          visible_fields.partition(&:sticky?).flatten
+        end
+        register_deprecated_instance_option :sort_reverse do
+          ActiveSupport::Deprecation.warn('The sort_reverse configuration option is deprecated and has no effect.')
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/engine.rb
@@ -0,0 +1,60 @@
+require 'kaminari'
+require 'nested_form'
+require 'rails'
+require 'rails_admin'
+require 'rails_admin/version'
+require 'turbo-rails'
+module RailsAdmin
+  class Engine < Rails::Engine
+    isolate_namespace RailsAdmin
+    config.action_dispatch.rescue_responses['RailsAdmin::ActionNotAllowed'] = :forbidden
+    initializer 'RailsAdmin precompile hook', group: :all do |app|
+      if defined?(Sprockets)
+        app.config.assets.precompile += %w[
+          rails_admin/application.js
+          rails_admin/application.css
+        ]
+        app.config.assets.paths << RailsAdmin::Engine.root.join('src')
+        require 'rails_admin/support/esmodule_preprocessor'
+        Sprockets.register_preprocessor 'application/javascript', RailsAdmin::ESModulePreprocessor
+      end
+    end
+    initializer 'RailsAdmin reload config in development' do |app|
+      config.initializer_path = app.root.join('config/initializers/rails_admin.rb')
+      unless Rails.application.config.cache_classes
+        ActiveSupport::Reloader.before_class_unload do
+          RailsAdmin::Config.reload!
+        end
+        reloader = app.config.file_watcher.new([config.initializer_path], []) do
+        end
+        app.reloaders << reloader
+        app.reloader.to_run do
+          reloader.execute_if_updated { require_unload_lock! }
+        end
+        reloader.execute
+      end
+    end
+    config.after_initialize do |app|
+      has_session_store = app.config.middleware.to_a.any? do |m|
+        m.klass.try(:<=, ActionDispatch::Session::AbstractStore) ||
+          m.klass.try(:<=, ActionDispatch::Session::AbstractSecureStore) ||
+          m.klass.name =~ /^ActionDispatch::Session::/
+      end
+      loaded = app.config.middleware.to_a.map(&:name)
+      required = %w[ActionDispatch::Cookies ActionDispatch::Flash Rack::MethodOverride]
+      missing = required - loaded
+      unless missing.empty? && has_session_store
+        configs = missing.map { |m| "config.middleware.use #{m}" }
+        configs << "config.middleware.use #{app.config.session_store.try(:name) || 'ActionDispatch::Session::CookieStore'}, #{app.config.session_options}" unless has_session_store
+        raise <<~ERROR
+          Required middlewares for RailsAdmin are not added
+          To fix this, add
+          to config/application.rb.
+        ERROR
+      end
+      RailsAdmin::Config.initialize!
+      app.reload_routes!
+      RailsAdmin::Version.warn_with_js_version
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/extension.rb
@@ -0,0 +1,20 @@
+require 'rails_admin/extensions/controller_extension'
+module RailsAdmin
+  EXTENSIONS = [] # rubocop:disable Style/MutableConstant
+  AUTHORIZATION_ADAPTERS = {} # rubocop:disable Style/MutableConstant
+  AUDITING_ADAPTERS = {} # rubocop:disable Style/MutableConstant
+  CONFIGURATION_ADAPTERS = {} # rubocop:disable Style/MutableConstant
+  def self.add_extension(extension_key, extension_definition, options = {})
+    options.assert_valid_keys(:authorization, :configuration, :auditing)
+    EXTENSIONS << extension_key
+    AUTHORIZATION_ADAPTERS[extension_key] = extension_definition::AuthorizationAdapter if options[:authorization]
+    CONFIGURATION_ADAPTERS[extension_key] = extension_definition::ConfigurationAdapter if options[:configuration]
+    AUDITING_ADAPTERS[extension_key] = extension_definition::AuditingAdapter if options[:auditing]
+  end
+  def self.setup_all_extensions
+    (AUTHORIZATION_ADAPTERS.values + AUDITING_ADAPTERS.values).each do |klass|
+      klass.setup if klass.respond_to? :setup
+    rescue # rubocop:disable Style/RescueStandardError
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/extensions/cancancan/authorization_adapter.rb
@@ -0,0 +1,44 @@
+module RailsAdmin
+  module Extensions
+    module CanCanCan
+      class AuthorizationAdapter
+        module ControllerExtension
+          def current_ability
+            @current_ability ||= @ability.new(_current_user)
+          end
+        end
+        def initialize(controller, ability = ::Ability)
+          @controller = controller
+          @controller.instance_variable_set '@ability', ability
+          @controller.extend ControllerExtension
+          @controller.current_ability.authorize! :access, :rails_admin
+        end
+        def authorize(action, abstract_model = nil, model_object = nil)
+          return unless action
+          action, subject = resolve_action_and_subject(action, abstract_model, model_object)
+          @controller.current_ability.authorize!(action, subject)
+        end
+        def authorized?(action, abstract_model = nil, model_object = nil)
+          return unless action
+          action, subject = resolve_action_and_subject(action, abstract_model, model_object)
+          @controller.current_ability.can?(action, subject)
+        end
+        def query(action, abstract_model)
+          abstract_model.model.accessible_by(@controller.current_ability, action)
+        end
+        def attributes_for(action, abstract_model)
+          @controller.current_ability.attributes_for(action, abstract_model&.model)
+        end
+      private
+        def resolve_action_and_subject(action, abstract_model, model_object)
+          subject = model_object || abstract_model&.model
+          if subject
+            [action, subject]
+          else
+            [:read, action]
+          end
+        end
+      end
+    end
+  end
+end

--- a/lib/rails_admin/extensions/paper_trail/auditing_adapter.rb
+++ b/lib/rails_admin/extensions/paper_trail/auditing_adapter.rb
@@ -34,108 +34,94 @@
         end
       end
       class AuditingAdapter
         COLUMN_MAPPING = {
           table: :item_type,
           username: :whodunnit,
           item: :item_id,
           created_at: :created_at,
           message: :event,
         }.freeze
-        E_USER_CLASS_NOT_SET = <<~ERROR
-          Please set up PaperTrail's user class explicitly.
-              config.audit_with :paper_trail do
-                user_class { User }
-              end
-        ERROR
-        E_VERSION_MODEL_NOT_SET = <<~ERROR
+        E_VERSION_MODEL_NOT_SET = <<-ERROR.strip_heredoc.freeze
           Please set up PaperTrail's version model explicitly.
-              config.audit_with :paper_trail do
-                version_class { PaperTrail::Version }
-              end
+              config.audit_with :paper_trail, 'User', 'PaperTrail::Version'
           If you have configured a model to use a custom version class
           (https://github.com/paper-trail-gem/paper_trail#6a-custom-version-classes)
-          that configuration will take precedence over what you specify in `audit_with`.
+          that configuration will take precedence over what you specify in
+          `audit_with`.
         ERROR
-        include RailsAdmin::Config::Configurable
         def self.setup
           raise 'PaperTrail not found' unless defined?(::PaperTrail)
           RailsAdmin::Extensions::ControllerExtension.include ControllerExtension
         end
-        def initialize(controller, user_class_name = nil, version_class_name = nil, &block)
+        def initialize(controller, user_class = 'User', version_class = '::Version')
           @controller = controller
           @controller&.send(:set_paper_trail_whodunnit)
-          user_class { user_class_name.to_s.constantize } if user_class_name
-          version_class { version_class_name.to_s.constantize } if version_class_name
-          instance_eval(&block) if block
-        end
-        register_instance_option :user_class do
-          User
-        rescue NameError
-          raise E_USER_CLASS_NOT_SET
-        end
-        register_instance_option :version_class do
-          PaperTrail::Version
-        rescue NameError
-          raise E_VERSION_MODEL_NOT_SET
-        end
-        register_instance_option :sort_by do
-          {id: :desc}
+          begin
+            @user_class = user_class.to_s.constantize
+          rescue NameError
+            raise "Please set up Papertrail's user model explicitly. Ex: config.audit_with :paper_trail, 'User'"
+          end
+          begin
+            @version_class = version_class.to_s.constantize
+          rescue NameError
+            raise E_VERSION_MODEL_NOT_SET
+          end
         end
         def latest(count = 100)
-          version_class.
-            order(sort_by).includes(:item).limit(count).
-            collect { |version| VersionProxy.new(version, user_class) }
+          @version_class.
+            order(id: :desc).includes(:item).limit(count).
+            collect { |version| VersionProxy.new(version, @user_class) }
         end
         def delete_object(_object, _model, _user)
         end
         def update_object(_object, _model, _user, _changes)
         end
         def create_object(_object, _abstract_model, _user)
         end
         def listing_for_model(model, query, sort, sort_reverse, all, page, per_page = (RailsAdmin::Config.default_items_per_page || 20))
           listing_for_model_or_object(model, nil, query, sort, sort_reverse, all, page, per_page)
         end
         def listing_for_object(model, object, query, sort, sort_reverse, all, page, per_page = (RailsAdmin::Config.default_items_per_page || 20))
           listing_for_model_or_object(model, object, query, sort, sort_reverse, all, page, per_page)
         end
       protected
         def listing_for_model_or_object(model, object, query, sort, sort_reverse, all, page, per_page)
-          sort =
-            if sort.present?
-              {COLUMN_MAPPING[sort.to_sym] => sort_reverse ? :desc : :asc}
-            else
-              sort_by
-            end
+          if sort.present?
+            sort = COLUMN_MAPPING[sort.to_sym]
+          else
+            sort = :created_at
+            sort_reverse = 'true'
+          end
           current_page = page.presence || '1'
           versions = object.nil? ? versions_for_model(model) : object.public_send(model.model.versions_association_name)
           versions = versions.where('event LIKE ?', "%#{query}%") if query.present?
-          versions = versions.order(sort)
-          versions = versions.send(Kaminari.config.page_method_name, current_page).per(per_page) unless all
+          versions = versions.order(sort_reverse == 'true' ? "#{sort} DESC" : sort)
+          versions = all ? versions : versions.send(Kaminari.config.page_method_name, current_page).per(per_page)
           paginated_proxies = Kaminari.paginate_array([], total_count: versions.try(:total_count) || versions.count)
           paginated_proxies = paginated_proxies.send(
             paginated_proxies.respond_to?(Kaminari.config.page_method_name) ? Kaminari.config.page_method_name : :page,
             current_page,
           ).per(per_page)
           versions.each do |version|
-            paginated_proxies << VersionProxy.new(version, user_class)
+            paginated_proxies << VersionProxy.new(version, @user_class)
           end
           paginated_proxies
         end
         def versions_for_model(model)
           model_name = model.model.name
           base_class_name = model.model.base_class.name
           options =
             if base_class_name == model_name
               {item_type: model_name}
             else
               {item_type: base_class_name, item_id: model.model.all}
             end
           version_class_for(model.model).where(options)
         end
         def version_class_for(model)
-          model.paper_trail.version_class
+          model.paper_trail_options.dig(:versions, :class_name).try(:constantize) || @version_class
         end
       end
     end
   end
 end

--- a//dev/null
+++ b/lib/rails_admin/extensions/pundit/authorization_adapter.rb
@@ -0,0 +1,41 @@
+module RailsAdmin
+  module Extensions
+    module Pundit
+      class AuthorizationAdapter
+        def self.setup
+          RailsAdmin::Extensions::ControllerExtension.include defined?(::Pundit::Authorization) ? ::Pundit::Authorization : ::Pundit
+        end
+        def initialize(controller)
+          @controller = controller
+        end
+        def authorize(action, abstract_model = nil, model_object = nil)
+          record = model_object || abstract_model&.model
+          raise ::Pundit::NotAuthorizedError.new("not allowed to #{action} this #{record}") if action && !policy(record).send(action_for_pundit(action))
+          @controller.instance_variable_set(:@_pundit_policy_authorized, true)
+        end
+        def authorized?(action, abstract_model = nil, model_object = nil)
+          record = model_object || abstract_model&.model
+          policy(record).send(action_for_pundit(action)) if action
+        end
+        def query(_action, abstract_model)
+          @controller.send(:policy_scope, abstract_model.model.all)
+        rescue ::Pundit::NotDefinedError
+          abstract_model.model.all
+        end
+        def attributes_for(action, abstract_model)
+          record = abstract_model&.model
+          policy(record).try(:attributes_for, action) || {}
+        end
+      private
+        def policy(record)
+          @controller.send(:policy, record)
+        rescue ::Pundit::NotDefinedError
+          ::ApplicationPolicy.new(@controller.send(:pundit_user), record)
+        end
+        def action_for_pundit(action)
+          action[-1, 1] == '?' ? action : "#{action}?"
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/support/csv_converter.rb
@@ -0,0 +1,82 @@
+require 'csv'
+module RailsAdmin
+  class CSVConverter
+    def initialize(objects = [], schema = nil)
+      @fields = []
+      @associations = []
+      schema ||= {}
+      return self if (@objects = objects).blank?
+      @model = objects.dup.first.class
+      @abstract_model = RailsAdmin::AbstractModel.new(@model)
+      @model_config = @abstract_model.config
+      @methods = [(schema[:only] || []) + (schema[:methods] || [])].flatten.compact
+      @fields = @methods.collect { |m| export_field_for(m) }.compact
+      @empty = ::I18n.t('admin.export.empty_value_for_associated_objects')
+      schema_include = schema.delete(:include) || {}
+      @associations = schema_include.each_with_object({}) do |(key, values), hash|
+        association = export_field_for(key)
+        next unless association&.association?
+        model_config = association.associated_model_config
+        abstract_model = model_config.abstract_model
+        methods = [(values[:only] || []) + (values[:methods] || [])].flatten.compact
+        hash[key] = {
+          association: association,
+          model: abstract_model.model,
+          abstract_model: abstract_model,
+          model_config: model_config,
+          fields: methods.collect { |m| export_field_for(m, model_config) }.compact,
+        }
+        hash
+      end
+    end
+    def to_csv(options = {})
+      if CSV::VERSION == '3.0.2'
+        raise <<-MSG.gsub(/^\s+/, '')
+          CSV library bundled with Ruby 2.6.0 has encoding issue, please upgrade Ruby to 2.6.1 or later.
+          https://github.com/ruby/csv/issues/62
+        MSG
+      end
+      options = HashWithIndifferentAccess.new(options)
+      encoding_to = Encoding.find(options[:encoding_to]) if options[:encoding_to].present?
+      csv_string = generate_csv_string(options)
+      csv_string = csv_string.encode(encoding_to, invalid: :replace, undef: :replace, replace: '?') if encoding_to
+      csv_string = "\xEF\xBB\xBF#{csv_string}" if encoding_to == Encoding::UTF_8
+      [!options[:skip_header], (encoding_to || csv_string.encoding).to_s, csv_string]
+    end
+  private
+    def export_field_for(method, model_config = @model_config)
+      model_config.export.fields.detect { |f| f.name == method }
+    end
+    def generate_csv_string(options)
+      generator_options = (options[:generator] || {}).symbolize_keys.delete_if { |_, value| value.blank? }
+      method = @objects.respond_to?(:find_each) ? :find_each : :each
+      CSV.generate(**generator_options) do |csv|
+        csv << generate_csv_header unless options[:skip_header]
+        @objects.send(method) do |object|
+          csv << generate_csv_row(object)
+        end
+      end
+    end
+    def generate_csv_header
+      @fields.collect do |field|
+        ::I18n.t('admin.export.csv.header_for_root_methods', name: field.label, model: @abstract_model.pretty_name)
+      end +
+        @associations.flat_map do |_association_name, option_hash|
+          option_hash[:fields].collect do |field|
+            ::I18n.t('admin.export.csv.header_for_association_methods', name: field.label, association: option_hash[:association].label)
+          end
+        end
+    end
+    def generate_csv_row(object)
+      @fields.collect do |field|
+        field.with(object: object).export_value
+      end +
+        @associations.flat_map do |association_name, option_hash|
+          associated_objects = [object.send(association_name)].flatten.compact
+          option_hash[:fields].collect do |field|
+            associated_objects.collect { |ao| field.with(object: ao).export_value.presence || @empty }.join(',')
+          end
+        end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/support/datetime.rb
@@ -0,0 +1,60 @@
+module RailsAdmin
+  module Support
+    class Datetime
+      FLATPICKR_TRANSLATIONS = {
+        '%A' => 'l',       # The  full  weekday  name ("Sunday")
+        '%a' => 'D',       # The abbreviated weekday name ("Sun")
+        '%B' => 'F',       # The  full  month  name ("January")
+        '%b' => 'M',       # The abbreviated month name ("Jan")
+        '%D' => 'm/d/y',   # American date format mm/dd/yy
+        '%d' => 'd',       # Day of the month (01..31)
+        '%-d' => 'j',      # Day of the month (1..31)
+        '%e' => 'j',       # Day of the month (1..31)
+        '%F' => 'Y-m-d',   # ISO 8601 date format
+        '%H' => 'H',       # Hour of the day, 24-hour clock (00..23)
+        '%-H' => 'H',      # Hour of the day, 24-hour clock (0..23)
+        '%h' => 'M',       # Same as %b
+        '%I' => 'G',       # Hour of the day, 12-hour clock (01..12)
+        '%-I' => 'h',      # Hour of the day, 12-hour clock (1..12)
+        '%k' => 'H',       # Hour of the day, 24-hour clock (0..23)
+        '%l' => 'h',       # Hour of the day, 12-hour clock (1..12)
+        '%M' => 'i',       # Minute of the hour (00..59)
+        '%-M' => 'i',      # Minute of the hour (00..59)
+        '%m' => 'm',       # Month of the year (01..12)
+        '%-m' => 'n',      # Month of the year (1..12)
+        '%P' => 'K',       # Meridian indicator ('am' or 'pm')
+        '%p' => 'K',       # Meridian indicator ('AM' or 'PM')
+        '%R' => 'H:i',     # 24-hour time (%H:%M)
+        '%r' => 'G:i:S K', # 12-hour time (%I:%M:%S %p)
+        '%S' => 'S',       # Second of the minute (00..60)
+        '%-S' => 's',      # Second of the minute (0..60)
+        '%s' => 'U',       # Number of seconds since 1970-01-01 00:00:00 UTC.
+        '%T' => 'H:i:S',   # 24-hour time (%H:%M:%S)
+        '%U' => 'W',       # Week number of the year.  The week starts with Sunday.  (00..53)
+        '%w' => 'w',       # Day of the week (Sunday is 0, 0..6)
+        '%X' => 'H:i:S',   # Same as %T
+        '%x' => 'm/d/y',   # Same as %D
+        '%Y' => 'Y',       # Year with century
+        '%y' => 'y',       # Year without a century (00..99)
+        '%%' => '%',
+      }.freeze
+      class << self
+        def to_flatpickr_format(strftime_format)
+          strftime_format.gsub(/(?<!%)(?<![-0-9:])\w/, '\\\\\0').gsub(/%([-0-9:]?\w)/) do |match|
+            case match
+            when '%Z', '%:z' # Time zone as hour and minute offset from UTC with a colon (e.g. +09:00)
+              Time.zone.formatted_offset
+            when '%z' # Time zone as hour and minute offset from UTC (e.g. +0900)
+              Time.zone.formatted_offset(false)
+            else
+              FLATPICKR_TRANSLATIONS[match] or raise <<-MSG.gsub(/^\s{16}/, '')
+                Unsupported strftime directive '#{match}' was found. Please consider explicitly setting flatpickr_format instance option for the field.
+                  field(:name_of_field) { flatpickr_format '...' }
+              MSG
+            end
+          end
+        end
+      end
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/support/esmodule_preprocessor.rb
@@ -0,0 +1,28 @@
+module RailsAdmin
+  class ESModulePreprocessor
+    def self.instance
+      @instance ||= new
+    end
+    def self.call(input)
+      instance.call(input)
+    end
+    def initialize; end
+    def call(input)
+      data = input[:data]
+      if input[:filename].start_with? RailsAdmin::Engine.root.join('src').to_s
+        data.gsub!(/^(import .+)$/) { "// #{Regexp.last_match(1)}" }
+        data.gsub!(/^(export +default +{)$/) do
+          case File.basename(input[:filename])
+          when 'i18n.js'
+            "/* #{Regexp.last_match(1)} */ window.I18n = {"
+          else
+            raise "Unable to preprocess file: #{input[:filename]}"
+          end
+        end
+      elsif input[:filename] =~ %r{turbo-rails.+/turbo\.js$}
+        data.gsub!(/^(export .+)$/) { "// #{Regexp.last_match(1)}" }
+      end
+      {data: data}
+    end
+  end
+end

--- a//dev/null
+++ b/lib/rails_admin/support/hash_helper.rb
@@ -0,0 +1,29 @@
+module RailsAdmin
+  class HashHelper
+    def self.symbolize(obj)
+      case obj
+      when Array
+        obj.each_with_object([]) do |val, res|
+          res << case val
+                 when Hash, Array then symbolize(val)
+                 when String      then val.to_sym
+                 else val
+                 end
+        end
+      when Hash
+        obj.each_with_object({}) do |(key, val), res|
+          nkey = key.is_a?(String) ? key.to_sym : key
+          nval =
+            case val
+            when Hash, Array then symbolize(val)
+            when String      then val.to_sym
+            else val
+            end
+          res[nkey] = nval
+        end
+      else
+        obj
+      end
+    end
+  end
+end

--- a/lib/rails_admin/version.rb
+++ b/lib/rails_admin/version.rb
@@ -1,15 +1,15 @@
 module RailsAdmin
   class Version
     MAJOR = 3
-    MINOR = 1
-    PATCH = 3
+    MINOR = 0
+    PATCH = 0
     PRE = nil
     class << self
       def to_s
         [MAJOR, MINOR, PATCH, PRE].compact.join('.')
       end
       def js
         JSON.parse(File.read("#{__dir__}/../../package.json"))['version']
       end
       def actual_js_version
         case RailsAdmin.config.asset_source

--- a//dev/null
+++ b/spec/controllers/rails_admin/application_controller_spec.rb
@@ -0,0 +1,36 @@
+require 'spec_helper'
+RSpec.describe RailsAdmin::ApplicationController, type: :controller do
+  describe '#to_model_name' do
+    it 'works with modules' do
+      expect(controller.to_model_name('conversations~conversation')).to eq('Conversations::Conversation')
+    end
+  end
+  describe 'helper method _get_plugin_name' do
+    it 'works by default' do
+      expect(controller.send(:_get_plugin_name)).to eq(['Dummy App', 'Admin'])
+    end
+    it 'works for static names' do
+      RailsAdmin.config do |config|
+        config.main_app_name = %w[static value]
+      end
+      expect(controller.send(:_get_plugin_name)).to eq(%w[static value])
+    end
+    it 'works for dynamic names in the controller context' do
+      RailsAdmin.config do |config|
+        config.main_app_name = proc { |controller| [Rails.application.engine_name.try(:titleize), controller.params[:action].titleize] }
+      end
+      controller.params[:action] = 'dashboard'
+      expect(controller.send(:_get_plugin_name)).to eq(['Dummy App Application', 'Dashboard'])
+    end
+  end
+  describe '#_current_user' do
+    it 'is public' do
+      expect { controller._current_user }.not_to raise_error
+    end
+  end
+  describe '#rails_admin_controller?' do
+    it 'returns true' do
+      expect(controller.send(:rails_admin_controller?)).to be true
+    end
+  end
+end

--- a//dev/null
+++ b/spec/controllers/rails_admin/main_controller_spec.rb
@@ -0,0 +1,372 @@
+require 'spec_helper'
+RSpec.describe RailsAdmin::MainController, type: :controller do
+  routes { RailsAdmin::Engine.routes }
+  def get(action, params)
+    super action, params: params
+  end
+  describe '#check_for_cancel' do
+    before do
+      allow(controller).to receive(:back_or_index) { raise StandardError.new('redirected back') }
+    end
+    it 'redirects to back if params[:bulk_ids] is nil when params[:bulk_action] is present' do
+      expect { get :bulk_delete, model_name: 'player', bulk_action: 'bulk_delete' }.to raise_error('redirected back')
+    end
+    it 'does not redirect to back if params[:bulk_ids] and params[:bulk_action] is present' do
+      expect { get :bulk_delete, model_name: 'player', bulk_action: 'bulk_delete', bulk_ids: [1] }.not_to raise_error
+    end
+  end
+  describe '#get_sort_hash' do
+    context 'options sortable is a hash' do
+      before do
+        RailsAdmin.config('Player') do
+          configure :team do
+            sortable do
+              :'team.name'
+            end
+          end
+        end
+      end
+      it 'returns the option with no changes' do
+        controller.params = {sort: 'team', model_name: 'players'}
+        expect(controller.send(:get_sort_hash, RailsAdmin.config(Player))).to eq(sort: :'team.name', sort_reverse: true)
+      end
+    end
+    it 'works with belongs_to associations with label method virtual' do
+      controller.params = {sort: 'parent_category', model_name: 'categories'}
+      expect(controller.send(:get_sort_hash, RailsAdmin.config(Category))).to eq(sort: 'categories.parent_category_id', sort_reverse: true)
+    end
+    context 'using mongoid, not supporting joins', mongoid: true do
+      it 'gives back the remote table with label name' do
+        controller.params = {sort: 'team', model_name: 'players'}
+        expect(controller.send(:get_sort_hash, RailsAdmin.config(Player))).to eq(sort: 'players.team_id', sort_reverse: true)
+      end
+    end
+    context 'using active_record, supporting joins', active_record: true do
+      it 'gives back the local column' do
+        controller.params = {sort: 'team', model_name: 'players'}
+        expect(controller.send(:get_sort_hash, RailsAdmin.config(Player))).to eq(sort: 'teams.name', sort_reverse: true)
+      end
+    end
+  end
+  describe '#bulk_action' do
+    before do
+      RailsAdmin.config do |config|
+        config.actions do
+          dashboard
+          index do
+            visible do
+              raise # This shouldn't be invoked
+            end
+          end
+          bulk_delete
+        end
+      end
+    end
+    it 'retrieves actions using :bulkable scope' do
+      expect { post :bulk_action, params: {model_name: 'player', bulk_action: 'bulk_delete', bulk_ids: [1]} }.not_to raise_error
+    end
+  end
+  describe '#list_entries called from view' do
+    before do
+      @teams = FactoryBot.create_list(:team, 21)
+      controller.params = {model_name: 'teams'}
+    end
+    it 'paginates' do
+      expect(controller.list_entries(RailsAdmin.config(Team), :index, nil, false).to_a.length).to eq(21)
+      expect(controller.list_entries(RailsAdmin.config(Team), :index, nil, true).to_a.length).to eq(20)
+    end
+  end
+  describe '#list_entries called from view with kaminari custom param_name' do
+    before do
+      @teams = FactoryBot.create_list(:team, 21)
+      controller.params = {model_name: 'teams'}
+      Kaminari.config.param_name = :pagina
+    end
+    after do
+      Kaminari.config.param_name = :page
+    end
+    it 'paginates' do
+      expect(controller.list_entries(RailsAdmin.config(Team), :index, nil, false).to_a.length).to eq(21)
+      expect(controller.list_entries(RailsAdmin.config(Team), :index, nil, true).to_a.length).to eq(20)
+    end
+  end
+  describe '#list_entries called with bulk_ids' do
+    before do
+      @teams = FactoryBot.create_list(:team, 21)
+      controller.params = {model_name: 'teams', bulk_action: 'bulk_delete', bulk_ids: @teams.collect(&:id)}
+    end
+    it 'does not paginate' do
+      expect(controller.list_entries(RailsAdmin.config(Team), :bulk_delete).to_a.length).to eq(21)
+    end
+  end
+  describe '#list_entries for associated_collection' do
+    before do
+      @team = FactoryBot.create :team
+      controller.params = {associated_collection: 'players', current_action: 'update', source_abstract_model: 'team', source_object_id: @team.id, model_name: 'player', action: 'index'}
+      controller.get_model # set @model_config for Team
+    end
+    it "doesn't scope associated collection records when associated_collection_scope is nil" do
+      @players = FactoryBot.create_list(:player, 2)
+      RailsAdmin.config Team do
+        field :players do
+          associated_collection_scope false
+        end
+      end
+      expect(controller.list_entries.to_a.length).to eq(@players.size)
+    end
+    it 'scopes associated collection records according to associated_collection_scope' do
+      @players = FactoryBot.create_list(:player, 4)
+      RailsAdmin.config Team do
+        field :players do
+          associated_collection_scope do
+            proc { |scope| scope.limit(3) }
+          end
+        end
+      end
+      expect(controller.list_entries.to_a.length).to eq(3)
+    end
+    it 'scopes associated collection records according to bindings' do
+      @team.revenue = BigDecimal('3')
+      @team.save
+      @players = FactoryBot.create_list(:player, 5)
+      RailsAdmin.config Team do
+        field :players do
+          associated_collection_scope do
+            team = bindings[:object]
+            proc do |scope|
+              scope.limit(team.revenue)
+            end
+          end
+        end
+      end
+      expect(controller.list_entries.to_a.length).to eq(@team.revenue.to_i)
+    end
+    it 'limits associated collection records number to 30 if cache_all is false' do
+      @players = FactoryBot.create_list(:player, 40)
+      RailsAdmin.config Team do
+        field :players do
+          associated_collection_cache_all false
+        end
+      end
+      expect(controller.list_entries.to_a.length).to eq(30)
+    end
+    it "doesn't limit associated collection records number to 30 if cache_all is true" do
+      @players = FactoryBot.create_list(:player, 40)
+      RailsAdmin.config Team do
+        field :players do
+          associated_collection_cache_all true
+        end
+      end
+      expect(controller.list_entries.length).to eq(@players.size)
+    end
+    it 'orders associated collection records by id, descending' do
+      @players = FactoryBot.create_list(:player, 3)
+      expect(controller.list_entries.to_a).to eq(@players.sort_by(&:id).reverse)
+    end
+  end
+  describe '#action_missing' do
+    it 'raises error when action is not found' do
+      expect(RailsAdmin::Config::Actions).to receive(:find).and_return(nil)
+      expect { get :index, model_name: 'player' }.to raise_error AbstractController::ActionNotFound
+    end
+  end
+  describe '#respond_to_missing?' do
+    it 'returns the result based on existence of action' do
+      expect(controller.send(:respond_to_missing?, :index, false)).to be true
+      expect(controller.send(:respond_to_missing?, :invalid_action, false)).to be false
+    end
+  end
+  describe '#get_collection' do
+    let(:team) { FactoryBot.create :team }
+    let!(:player) { FactoryBot.create :player, team: team }
+    let(:model_config) { RailsAdmin.config(Team) }
+    let(:abstract_model) { model_config.abstract_model }
+    before do
+      controller.params = {model_name: 'team'}
+    end
+    it 'performs eager-loading with `eagar_load true`' do
+      RailsAdmin.config Team do
+        field :players do
+          eager_load true
+        end
+      end
+      expect(abstract_model).to receive(:all).with(hash_including(include: [:players]), nil).once.and_call_original
+      controller.send(:get_collection, model_config, nil, false).to_a
+    end
+    it 'performs eager-loading with custom eagar_load value' do
+      RailsAdmin.config Team do
+        field :players do
+          eager_load players: :draft
+        end
+      end
+      expect(abstract_model).to receive(:all).with(hash_including(include: [{players: :draft}]), nil).once.and_call_original
+      controller.send(:get_collection, model_config, nil, false).to_a
+    end
+  end
+  describe 'index' do
+    it "uses target model's primary key" do
+      @user = FactoryBot.create :managing_user
+      @team = FactoryBot.create :managed_team, user: @user
+      get :index, model_name: 'managing_user', source_object_id: @team.id, source_abstract_model: 'managing_user', associated_collection: 'teams', current_action: :create, compact: true, format: :json
+      expect(response.body).to match(/"id":"#{@user.id}"/)
+    end
+    context 'as JSON' do
+      it 'returns strings' do
+        FactoryBot.create :player, team: (FactoryBot.create :team)
+        get :index, model_name: 'player', source_object_id: Team.first.id, source_abstract_model: 'team', associated_collection: 'players', current_action: :create, compact: true, format: :json
+        expect(JSON.parse(response.body).first['id']).to be_a_kind_of String
+      end
+    end
+    context 'when authorizing requests with pundit' do
+      if defined?(Devise::Test)
+        include Devise::Test::ControllerHelpers
+      else
+        include Devise::TestHelpers
+      end
+      controller(RailsAdmin::MainController) do
+        include defined?(::Pundit::Authorization) ? ::Pundit::Authorization : ::Pundit
+        after_action :verify_authorized
+      end
+      it 'performs authorization' do
+        RailsAdmin.config do |c|
+          c.authorize_with(:pundit)
+          c.authenticate_with { warden.authenticate! scope: :user }
+          c.current_user_method(&:current_user)
+        end
+        login_as FactoryBot.create :user, roles: [:admin]
+        player = FactoryBot.create :player, team: (FactoryBot.create :team)
+        expect { get :show, model_name: 'player', id: player.id }.not_to raise_error
+      end
+    end
+  end
+  describe 'sanitize_params_for!' do
+    context 'with datetime' do
+      before do
+        ActionController::Parameters.permit_all_parameters = false
+        RailsAdmin.config Comment do
+          configure :created_at do
+            show
+          end
+        end
+        RailsAdmin.config NestedFieldTest do
+          configure :created_at do
+            show
+          end
+        end
+        controller.params = ActionController::Parameters.new(
+          'field_test' => {
+            'unallowed_field' => "I shouldn't be here",
+            'datetime_field' => '2010-08-01T00:00:00',
+            'nested_field_tests_attributes' => {
+              'new_1330520162002' => {
+                'comment_attributes' => {
+                  'unallowed_field' => "I shouldn't be here",
+                  'created_at' => '2010-08-02T00:00:00',
+                },
+                'created_at' => '2010-08-03T00:00:00',
+              },
+            },
+            'comment_attributes' => {
+              'unallowed_field' => "I shouldn't be here",
+              'created_at' => '2010-08-04T00:00:00',
+            },
+          },
+        )
+        controller.send(:sanitize_params_for!, :create, RailsAdmin.config(FieldTest), controller.params['field_test'])
+      end
+      after do
+        ActionController::Parameters.permit_all_parameters = true
+      end
+      it 'sanitize params recursively in nested forms' do
+        expect(controller.params[:field_test].to_h).to eq(
+          'datetime_field' => ::Time.zone.parse('Sun, 01 Aug 2010 00:00:00 UTC +00:00'),
+          'nested_field_tests_attributes' => {
+            'new_1330520162002' => {
+              'comment_attributes' => {
+                'created_at' => ::Time.zone.parse('Mon, 02 Aug 2010 00:00:00 UTC +00:00'),
+              },
+              'created_at' => ::Time.zone.parse('Tue, 03 Aug 2010 00:00:00 UTC +00:00'),
+            },
+          },
+          'comment_attributes' => {
+            'created_at' => ::Time.zone.parse('Wed, 04 Aug 2010 00:00:00 UTC +00:00'),
+          },
+        )
+      end
+      it 'enforces permit!' do
+        expect(controller.params['field_test'].permitted?).to be_truthy
+        expect(controller.params['field_test']['nested_field_tests_attributes'].values.first.permitted?).to be_truthy
+        expect(controller.params['field_test']['comment_attributes'].permitted?).to be_truthy
+      end
+    end
+    it 'allows for delete method with Carrierwave' do
+      RailsAdmin.config FieldTest do
+        field :carrierwave_asset
+        field :carrierwave_assets
+        field :dragonfly_asset
+        field :paperclip_asset do
+          delete_method :delete_paperclip_asset
+        end
+        if defined?(ActiveStorage)
+          field :active_storage_asset do
+            delete_method :remove_active_storage_asset
+          end
+        end
+        if defined?(ActiveStorage)
+          field :active_storage_assets do
+            delete_method :remove_active_storage_assets
+          end
+        end
+        if defined?(Shrine)
+          field :shrine_asset do
+            delete_method :remove_shrine_asset
+          end
+        end
+      end
+      controller.params = HashWithIndifferentAccess.new(
+        'field_test' => {
+          'carrierwave_asset' => 'test',
+          'carrierwave_asset_cache' => 'test',
+          'remove_carrierwave_asset' => 'test',
+          'carrierwave_assets' => 'test',
+          'dragonfly_asset' => 'test',
+          'remove_dragonfly_asset' => 'test',
+          'retained_dragonfly_asset' => 'test',
+          'paperclip_asset' => 'test',
+          'delete_paperclip_asset' => 'test',
+          'should_not_be_here' => 'test',
+        }.merge(defined?(ActiveStorage) ? {'active_storage_asset' => 'test', 'remove_active_storage_asset' => 'test', 'active_storage_assets' => 'test', 'remove_active_storage_assets' => 'test'} : {}).
+          merge(defined?(Shrine) ? {'shrine_asset' => 'test', 'remove_shrine_asset' => 'test'} : {}),
+      )
+      controller.send(:sanitize_params_for!, :create, RailsAdmin.config(FieldTest), controller.params['field_test'])
+      expect(controller.params[:field_test].to_h).to eq({
+        'carrierwave_asset' => 'test',
+        'remove_carrierwave_asset' => 'test',
+        'carrierwave_asset_cache' => 'test',
+        'carrierwave_assets' => 'test',
+        'dragonfly_asset' => 'test',
+        'remove_dragonfly_asset' => 'test',
+        'retained_dragonfly_asset' => 'test',
+        'paperclip_asset' => 'test',
+        'delete_paperclip_asset' => 'test',
+      }.merge(defined?(ActiveStorage) ? {'active_storage_asset' => 'test', 'remove_active_storage_asset' => 'test', 'active_storage_assets' => 'test', 'remove_active_storage_assets' => 'test'} : {}).
+        merge(defined?(Shrine) ? {'shrine_asset' => 'test', 'remove_shrine_asset' => 'test'} : {}))
+    end
+    it 'allows for polymorphic associations parameters' do
+      RailsAdmin.config Comment do
+        field :commentable
+      end
+      controller.params = HashWithIndifferentAccess.new(
+        'comment' => {
+          'commentable_id' => 'test',
+          'commentable_type' => 'test',
+        },
+      )
+      controller.send(:sanitize_params_for!, :create, RailsAdmin.config(Comment), controller.params['comment'])
+      expect(controller.params[:comment].to_h).to eq(
+        'commentable_id' => 'test',
+        'commentable_type' => 'test',
+      )
+    end
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/carrierwave_uploader.rb
@@ -0,0 +1,11 @@
+require 'mini_magick'
+class CarrierwaveUploader < CarrierWave::Uploader::Base
+  include CarrierWave::MiniMagick
+  storage :file
+  def store_dir
+    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
+  end
+  version :thumb do
+    process resize_to_fill: [100, 100]
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/eager_loaded/basketball.rb
@@ -0,0 +1,2 @@
+class Basketball < Ball
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/league.rb
@@ -0,0 +1,10 @@
+class League < ActiveRecord::Base
+  has_many :divisions, foreign_key: 'custom_league_id'
+  has_many :teams, -> { readonly }, through: :divisions
+  has_many :players, through: :teams
+  has_one :division, foreign_key: 'custom_league_id'
+  validates_presence_of(:name)
+  def custom_name
+    "League '#{name}'"
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/player.rb
@@ -0,0 +1,15 @@
+class Player < ActiveRecord::Base
+  belongs_to :team, optional: true, inverse_of: :players
+  has_one :draft, dependent: :destroy
+  has_many :comments, as: :commentable
+  validates_presence_of(:name)
+  validates_numericality_of(:number, only_integer: true)
+  validates_uniqueness_of(:number, scope: :team_id, message: 'There is already a player with that number on this team')
+  validates_each :name do |record, _attr, value|
+    record.errors.add(:base, 'Player is cheating') if /on steroids/.match?(value.to_s)
+  end
+  enum formation: {start: 'start', substitute: 'substitute'}
+  before_destroy :destroy_hook
+  scope :rails_admin_search, ->(query) { where(name: query.reverse) }
+  def destroy_hook; end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/read_only_comment.rb
@@ -0,0 +1,5 @@
+class ReadOnlyComment < Comment
+  def readonly?
+    true
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/restricted_team.rb
@@ -0,0 +1,3 @@
+class RestrictedTeam < Team
+  has_many :players, foreign_key: :team_id, dependent: :restrict_with_error
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/team.rb
@@ -0,0 +1,23 @@
+class Team < ActiveRecord::Base
+  has_many :players, -> { order :id }, inverse_of: :team
+  has_and_belongs_to_many :fans
+  has_many :comments, as: :commentable
+  validates_numericality_of :division_id, only_integer: true
+  validates_presence_of :manager
+  validates_numericality_of :founded, only_integer: true, allow_blank: true
+  validates_numericality_of :wins, only_integer: true
+  validates_numericality_of :losses, only_integer: true
+  validates_numericality_of :win_percentage
+  validates_numericality_of :revenue, allow_nil: true
+  belongs_to :division, optional: true
+  enum main_sponsor: %i[no_sponsor food_factory transportation_company bank energy_producer]
+  def player_names_truncated
+    players.collect(&:name).join(', ')[0..32]
+  end
+  def color_enum
+    ['white', 'black', 'red', 'green', 'blu<e>']
+  end
+  scope :green, -> { where(color: 'red') }
+  scope :red, -> { where(color: 'red') }
+  scope :white, -> { where(color: 'white') }
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/two_level/namespaced.rb
@@ -0,0 +1,7 @@
+module TwoLevel
+  module Namespaced
+    def self.table_name_prefix
+      'two_level_namespaced_'
+    end
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/active_record/user.rb
@@ -0,0 +1,13 @@
+class User < ActiveRecord::Base
+  devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable, :validatable
+  serialize :roles, Array
+  has_attached_file :avatar, styles: {medium: '300x300>', thumb: '100x100>'}
+  attr_accessor :delete_avatar
+  before_validation { self.avatar = nil if delete_avatar == '1' }
+  def attr_accessible_role
+    :custom_role
+  end
+  def roles_enum
+    %i[admin user]
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/javascript/packs/application.js
@@ -0,0 +1,2 @@
+/* eslint no-console:0 */
+console.log("Hello World from Webpacker");

--- a//dev/null
+++ b/spec/dummy_app/app/javascript/packs/rails_admin.js
@@ -0,0 +1,3 @@
+import "rails_admin/src/rails_admin/base";
+import "../stylesheets/rails_admin.scss";
+import "flatpickr/dist/l10n/fr";

--- a//dev/null
+++ b/spec/dummy_app/app/jobs/application_job.rb
@@ -0,0 +1,2 @@
+class ApplicationJob < ActiveJob::Base
+end

--- a//dev/null
+++ b/spec/dummy_app/app/jobs/null_job.rb
@@ -0,0 +1,5 @@
+class NullJob < ApplicationJob
+  queue_as :default
+  def perform(*args)
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/mongoid/carrierwave_uploader.rb
@@ -0,0 +1,11 @@
+require 'mini_magick'
+class CarrierwaveUploader < CarrierWave::Uploader::Base
+  include CarrierWave::MiniMagick
+  storage :file
+  def store_dir
+    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
+  end
+  version :thumb do
+    process resize_to_fill: [100, 100]
+  end
+end

--- a//dev/null
+++ b/spec/dummy_app/app/mongoid/eager_loaded/basketball.rb
@@ -0,0 +1,2 @@
+class Basketball < Ball
+end

--- a/spec/integration/actions/index_spec.rb
+++ b//dev/null
@@ -1,1110 +0,0 @@
-require 'spec_helper'
-RSpec.describe 'Index action', type: :request do
-  subject { page }
-  describe 'page' do
-    it 'shows "List of Models", should show filters and should show column headers' do
-      RailsAdmin.config.default_items_per_page = 1
-      2.times { FactoryBot.create :player } # two pages of players
-      visit index_path(model_name: 'player')
-      is_expected.to have_content('List of Players')
-      is_expected.to have_content('Created at')
-      is_expected.to have_content('Updated at')
-      is_expected.to have_selector("li[title='Show'] a")
-      is_expected.to have_selector("li[title='Edit'] a")
-      is_expected.to have_selector("li[title='Delete'] a")
-      is_expected.to have_selector("input[placeholder='Filter']")
-      is_expected.to have_selector("a[href*='all=true']") # make sure we're fully testing pagination
-      is_expected.to have_no_selector("a[href^='/rails_admin/main/list']")
-    end
-  end
-  describe 'css hooks' do
-    it 'is present' do
-      RailsAdmin.config Team do
-        list do
-          field :name
-        end
-      end
-      FactoryBot.create :team
-      visit index_path(model_name: 'team')
-      is_expected.to have_selector('th.header.string_type.name_field')
-      is_expected.to have_selector('td.string_type.name_field')
-    end
-  end
-  describe 'with querying and filtering' do
-    before do
-      @teams = Array.new(2) do
-        FactoryBot.create(:team)
-      end
-      @players = [
-        FactoryBot.create(:player, retired: true, injured: true, team: @teams[0]),
-        FactoryBot.create(:player, retired: true, injured: false, team: @teams[0]),
-        FactoryBot.create(:player, retired: false, injured: true, team: @teams[1]),
-        FactoryBot.create(:player, retired: false, injured: false, team: @teams[1]),
-      ]
-      @comment = FactoryBot.create(:comment, commentable: @players[2])
-    end
-    it 'allows to query on any attribute' do
-      RailsAdmin.config Player do
-        list do
-          field :name
-          field :team
-          field :injured
-          field :retired
-        end
-      end
-      visit index_path(model_name: 'player', query: @players[0].name)
-      is_expected.to have_content(@players[0].name)
-      (1..3).each do |i|
-        is_expected.to have_no_content(@players[i].name)
-      end
-    end
-    it 'allows to clear the search query box', js: true do
-      visit index_path(model_name: 'player', query: @players[0].name)
-      is_expected.not_to have_content(@players[1].name)
-      find_button('Reset filters').click
-      is_expected.to have_content(@players[1].name)
-    end
-    it 'allows to filter on one attribute' do
-      RailsAdmin.config Player do
-        list do
-          field :name
-          field :team
-          field :injured
-          field :retired
-        end
-      end
-      visit index_path(model_name: 'player', f: {injured: {'1' => {v: 'true'}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_no_content(@players[1].name)
-      is_expected.to have_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to combine filters on two different attributes' do
-      RailsAdmin.config Player do
-        list do
-          field :name
-          field :team
-          field :injured
-          field :retired
-        end
-      end
-      visit index_path(model_name: 'player', f: {retired: {'1' => {v: 'true'}}, injured: {'1' => {v: 'true'}}})
-      is_expected.to have_content(@players[0].name)
-      (1..3).each do |i|
-        is_expected.to have_no_content(@players[i].name)
-      end
-    end
-    it 'allows to filter on belongs_to relationships' do
-      RailsAdmin.config Player do
-        list do
-          field :name
-          field :team
-          field :injured
-          field :retired
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams[0].name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to filter on has_one relationships' do
-      @draft = FactoryBot.create(:draft, player: @players[1], college: 'University of Alabama')
-      RailsAdmin.config Player do
-        list do
-          field :name
-          field :draft do
-            searchable :college
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {draft: {'1' => {v: 'Alabama'}}})
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_css('tbody .name_field', count: 1)
-    end
-    it 'allows to disable search on attributes' do
-      RailsAdmin.config Player do
-        list do
-          field :position
-          field :name do
-            searchable false
-          end
-        end
-      end
-      visit index_path(model_name: 'player', query: @players[0].name)
-      is_expected.to have_no_content(@players[0].name)
-    end
-    it 'allows to search a belongs_to attribute over the base table' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable Player => :team_id
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.id}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a belongs_to attribute over the target table' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable Team => :name
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a belongs_to attribute over the target table with a table name specified as a hash' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable teams: :name
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a belongs_to attribute over the target table with a table name specified as a string' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable 'teams.name'
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a belongs_to attribute over the label method by default' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a belongs_to attribute over the target table when an attribute is specified' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable :name
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search over more than one attribute' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :team do
-            searchable [:name, {Player => :team_id}]
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}, '2' => {v: @teams.first.id, o: 'is'}}})
-      is_expected.to have_content(@players[0].name)
-      is_expected.to have_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-      visit index_path(model_name: 'player', f: {team: {'1' => {v: @teams.first.name}, '2' => {v: @teams.last.id, o: 'is'}}})
-      is_expected.to have_no_content(@players[0].name)
-      is_expected.to have_no_content(@players[1].name)
-      is_expected.to have_no_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'allows to search a has_many attribute over the target table' do
-      RailsAdmin.config Player do
-        list do
-          field PK_COLUMN
-          field :name
-          field :comments do
-            searchable :content
-          end
-        end
-      end
-      visit index_path(model_name: 'player', f: {comments: {'1' => {v: @comment.content}}})
-      is_expected.to have_no_content(@players[0].name)
-      is_expected.to have_no_content(@players[1].name)
-      is_expected.to have_content(@players[2].name)
-      is_expected.to have_no_content(@players[3].name)
-    end
-    it 'displays base filters when no filters are present in the params' do
-      RailsAdmin.config Player do
-        list { filters(%i[name team]) }
-        field :name do
-          default_filter_operator 'is'
-        end
-        field :team do
-          filterable true
-        end
-      end
-      visit index_path(model_name: 'player')
-      expect(JSON.parse(find('#filters_box')['data-options']).map(&:symbolize_keys)).to match_array [
-        {
-          index: 1,
-          label: 'Name',
-          name: 'name',
-          type: 'string',
-          value: '',
-          operator: 'is',
-          operators: %w[_discard like not_like is starts_with ends_with],
-        },
-        {
-          index: 2,
-          label: 'Team',
-          name: 'team',
-          type: 'belongs_to_association',
-          value: '',
-          operator: nil,
-          operators: %w[_discard like not_like is starts_with ends_with _separator _present _blank],
-        },
-      ]
-    end
-    it 'shows the help text below the search box' do
-      RailsAdmin.config Player do
-        list do
-          search_help 'Use this box to search!'
-        end
-      end
-      visit index_path(model_name: 'player')
-      is_expected.to have_css('.form-text', text: /Use this box/)
-    end
-  end
-  describe 'fields' do
-    before do
-      if defined?(CompositePrimaryKeys)
-        RailsAdmin.config Fan do
-          configure(:fanships) { hide }
-          configure(:fanship) { hide }
-        end
-      end
-    end
-    it 'shows all by default' do
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Created at', 'Updated at', 'Their Name', 'Teams']
-    end
-    it 'hides some fields on demand with a block' do
-      RailsAdmin.config Fan do
-        list do
-          exclude_fields_if do
-            type == :datetime
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Their Name', 'Teams']
-    end
-    it 'hides some fields on demand with fields list' do
-      RailsAdmin.config Fan do
-        list do
-          exclude_fields :created_at, :updated_at
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Their Name', 'Teams']
-    end
-    it 'adds some fields on demand with a block' do
-      RailsAdmin.config Fan do
-        list do
-          include_fields_if do
-            type != :datetime
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Their Name', 'Teams']
-    end
-    it 'shows some fields on demand with fields list, respect ordering and configure them' do
-      RailsAdmin.config Fan do
-        list do
-          fields :name, PK_COLUMN do
-            label do
-              "Modified #{label}"
-            end
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Modified Id', 'Modified Their Name']
-    end
-    it 'shows all fields if asked' do
-      RailsAdmin.config Fan do
-        list do
-          include_all_fields
-          field PK_COLUMN
-          field :name
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Created at', 'Updated at', 'Their Name', 'Teams']
-    end
-    it 'appears in order defined' do
-      RailsAdmin.config Fan do
-        list do
-          field :updated_at
-          field :name
-          field PK_COLUMN
-          field :created_at
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to eq(['Updated at', 'Their Name', 'Id', 'Created at'])
-    end
-    it 'only lists the defined fields if some fields are defined' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN
-          field :name
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to eq(['Id', 'Their Name'])
-      is_expected.to have_no_selector('th:nth-child(4).header')
-    end
-    it 'delegates the label option to the ActiveModel API' do
-      RailsAdmin.config Fan do
-        list do
-          field :name
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(find('th:nth-child(2)')).to have_content('Their Name')
-    end
-    it 'is renameable' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN do
-            label 'Identifier'
-          end
-          field :name
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(find('th:nth-child(2)')).to have_content('Identifier')
-      expect(find('th:nth-child(3)')).to have_content('Their Name')
-    end
-    it 'is renameable by type' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            label { "#{label} (datetime)" }
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Created at (datetime)', 'Updated at (datetime)', 'Their Name', 'Teams']
-    end
-    it 'is globally renameable by type' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            label { "#{label} (datetime)" }
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Created at (datetime)', 'Updated at (datetime)', 'Their Name', 'Teams']
-    end
-    it 'is sortable by default' do
-      visit index_path(model_name: 'fan')
-      is_expected.to have_selector('th:nth-child(2).header')
-      is_expected.to have_selector('th:nth-child(3).header')
-      is_expected.to have_selector('th:nth-child(4).header')
-      is_expected.to have_selector('th:nth-child(5).header')
-    end
-    it 'has option to disable sortability' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN do
-            sortable false
-          end
-          field :name
-        end
-      end
-      visit index_path(model_name: 'fan')
-      is_expected.to have_no_selector('th:nth-child(2).header')
-      is_expected.to have_selector('th:nth-child(3).header')
-    end
-    it 'has option to disable sortability by type' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            sortable false
-          end
-          field PK_COLUMN
-          field :name
-          field :created_at
-          field :updated_at
-        end
-      end
-      visit index_path(model_name: 'fan')
-      is_expected.to have_selector('th:nth-child(2).header')
-      is_expected.to have_selector('th:nth-child(3).header')
-      is_expected.to have_no_selector('th:nth-child(4).header')
-      is_expected.to have_no_selector('th:nth-child(5).header')
-    end
-    it 'has option to disable sortability by type globally' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            sortable false
-          end
-          field PK_COLUMN
-          field :name
-          field :created_at
-          field :updated_at
-        end
-      end
-      visit index_path(model_name: 'fan')
-      is_expected.to have_selector('th:nth-child(2).header')
-      is_expected.to have_selector('th:nth-child(3).header')
-      is_expected.to have_no_selector('th:nth-child(4).header')
-      is_expected.to have_no_selector('th:nth-child(5).header')
-    end
-    it 'has option to hide fields by type' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            hide
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Their Name', 'Teams']
-    end
-    it 'has option to hide fields by type globally' do
-      RailsAdmin.config Fan do
-        list do
-          fields_of_type :datetime do
-            hide
-          end
-        end
-      end
-      visit index_path(model_name: 'fan')
-      expect(all('th').collect(&:text).delete_if { |t| /^\n*$/ =~ t }).
-        to match_array ['Id', 'Their Name', 'Teams']
-    end
-    it 'has option to customize column width' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN do
-            column_width 200
-          end
-          field :name
-          field :created_at
-          field :updated_at
-        end
-      end
-      @fans = FactoryBot.create_list(:fan, 2)
-      visit index_path(model_name: 'fan')
-      expect(find('style').native.text).to include("#list th.#{PK_COLUMN}_field")
-      expect(find('style').native.text).to include("#list td.#{PK_COLUMN}_field")
-    end
-    it 'has option to customize output formatting' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN
-          field :name do
-            formatted_value do
-              value.to_s.upcase
-            end
-          end
-          field :created_at
-          field :updated_at
-        end
-      end
-      @fans = FactoryBot.create_list(:fan, 2).sort_by(&:id)
-      visit index_path(model_name: 'fan')
-      expect(find('tbody tr:nth-child(1) td:nth-child(3)')).to have_content(@fans[1].name.upcase)
-      expect(find('tbody tr:nth-child(2) td:nth-child(3)')).to have_content(@fans[0].name.upcase)
-    end
-    it 'has a simple option to customize output formatting of date fields' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN
-          field :name
-          field :created_at do
-            date_format :short
-          end
-          field :updated_at
-        end
-      end
-      @fans = FactoryBot.create_list(:fan, 2)
-      visit index_path(model_name: 'fan')
-      is_expected.to have_selector('tbody tr:nth-child(1) td:nth-child(4)', text: /\d{2} \w{3} \d{1,2}:\d{1,2}/)
-    end
-    it 'has option to customize output formatting of date fields' do
-      RailsAdmin.config Fan do
-        list do
-          field PK_COLUMN
-          field :name
-          field :created_at do
-            strftime_format '%Y-%m-%d'
-          end
-          field :updated_at
-        end
-      end
-      @fans = FactoryBot.create_list(:fan, 2)
-      visit index_path(model_name: 'fan')
-      is_expected.to have_selector('tbody tr:nth-child(1) td:nth-child(4)', text: /\d{4}-\d{2}-\d{2}/)
-    end
-    it 'allows addition of virtual fields (object methods)' do
-      RailsAdmin.config Team do
-        list do
-          field PK_COLUMN
-          field :name
-          field :player_names_truncated
-        end
-      end
-      @team = FactoryBot.create :team
-      @players = FactoryBot.create_list :player, 2, team: @team
-      visit index_path(model_name: 'team')
-      expect(find('tbody tr:nth-child(1) td:nth-child(4)')).to have_content(@players.sort_by(&:id).collect(&:name).join(', '))
-    end
-    it 'does not allow XSS for title attribute' do
-      RailsAdmin.config Team do
-        list do
-          field :name
-        end
-      end
-      @team = FactoryBot.create :team, name: '" onclick="alert()" "'
-      visit index_path(model_name: 'team')
-      expect(find('tbody tr:nth-child(1) td:nth-child(2)')['onclick']).to be_nil
-      expect(find('tbody tr:nth-child(1) td:nth-child(2)')['title']).to eq '" onclick="alert()" "'
-    end
-  end
-  context 'when no record exists' do
-    before do
-      visit index_path(model_name: 'player')
-    end
-    it 'shows "No records found" message' do
-      is_expected.to have_content('No records found')
-    end
-  end
-  context 'without pagination' do
-    before do
-      @players = FactoryBot.create_list(:player, 2)
-      visit index_path(model_name: 'player')
-    end
-    it 'shows "2 results"' do
-      is_expected.to have_content('2 players')
-    end
-  end
-  context 'with pagination' do
-    def visit_page(page)
-      visit index_path(model_name: 'player', page: page)
-    end
-    before do
-      FactoryBot.create_list :player, 3
-    end
-    describe 'with limited_pagination=false' do
-      before { RailsAdmin.config.default_items_per_page = 1 }
-      it 'page 1' do
-        visit_page(1)
-        within('ul.pagination') do
-          expect(find('li:first')).to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-          expect(find('li.active')).to have_content('1')
-        end
-      end
-      it 'page 2' do
-        visit_page(2)
-        within('ul.pagination') do
-          expect(find('li:first')).to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-          expect(find('li.active')).to have_content('2')
-        end
-      end
-      it 'page 3' do
-        visit_page(3)
-        within('ul.pagination') do
-          expect(find('li:first')).to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-          expect(find('li.active')).to have_content('3')
-        end
-      end
-    end
-    context 'with limited_pagination=true' do
-      before do
-        RailsAdmin.config.default_items_per_page = 1
-        allow(RailsAdmin::AbstractModel.new(Player).config.list).
-          to receive(:limited_pagination).
-          and_return(true)
-      end
-      it 'page 1' do
-        visit_page(1)
-        within('ul.pagination') do
-          expect(find('li:first')).not_to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-        end
-      end
-      it 'page 2' do
-        visit_page(2)
-        within('ul.pagination') do
-          expect(find('li:first')).to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-        end
-      end
-      it 'page 3' do
-        visit_page(3)
-        within('ul.pagination') do
-          expect(find('li:first')).to have_content(' Prev')
-          expect(find('li:last')).to have_content('Next ')
-        end
-      end
-    end
-    describe 'number of items per page' do
-      before do
-        FactoryBot.create_list :league, 2
-      end
-      it 'is configurable per model' do
-        RailsAdmin.config League do
-          list do
-            items_per_page 1
-          end
-        end
-        visit index_path(model_name: 'league')
-        is_expected.to have_selector('tbody tr', count: 1)
-        visit index_path(model_name: 'player')
-        is_expected.to have_selector('tbody tr', count: 3)
-      end
-    end
-  end
-  context 'on showing all' do
-    it 'responds successfully with a single model' do
-      FactoryBot.create :player
-      visit index_path(model_name: 'player', all: true)
-      expect(find('div.total-count')).to have_content('1 player')
-      expect(find('div.total-count')).not_to have_content('1 players')
-    end
-    it 'responds successfully with multiple models' do
-      FactoryBot.create_list(:player, 2)
-      visit index_path(model_name: 'player', all: true)
-      expect(find('div.total-count')).to have_content('2 players')
-    end
-  end
-  context 'with pagination disabled by :associated_collection' do
-    it 'responds successfully' do
-      @team = FactoryBot.create :team
-      Array.new(2) { FactoryBot.create :player, team: @team }
-      visit index_path(model_name: 'player', associated_collection: 'players', compact: true, current_action: 'update', source_abstract_model: 'team', source_object_id: @team.id)
-      expect(find('div.total-count')).to have_content('2 players')
-    end
-  end
-  describe 'sorting' do
-    let(:today) { Date.today }
-    let(:players) do
-      [{name: 'Jackie Robinson',  created_at: today,            team_id: rand(99_999), number: 42},
-       {name: 'Deibinson Romero', created_at: (today - 2.days), team_id: rand(99_999), number: 13},
-       {name: 'Sandy Koufax',     created_at: (today - 1.days), team_id: rand(99_999), number: 32}]
-    end
-    let(:leagues) do
-      [{name: 'American',      created_at: (today - 1.day)},
-       {name: 'Florida State', created_at: (today - 2.days)},
-       {name: 'National',      created_at: today}]
-    end
-    let(:player_names_by_date) { players.sort_by { |p| p[:created_at] }.collect { |p| p[:name] } }
-    let(:league_names_by_date) { leagues.sort_by { |l| l[:created_at] }.collect { |l| l[:name] } }
-    before { @players = players.collect { |h| Player.create(h) } }
-    it 'has reverse direction by default' do
-      RailsAdmin.config Player do
-        list do
-          sort_by :created_at
-          field :name
-        end
-      end
-      visit index_path(model_name: 'player')
-      player_names_by_date.reverse.each_with_index do |name, i|
-        expect(find("tbody tr:nth-child(#{i + 1})")).to have_content(name)
-      end
-    end
-    it 'allows change direction by using field configuration' do
-      RailsAdmin.config Player do
-        list do
-          sort_by :created_at
-          configure :created_at do
-            sort_reverse false
-          end
-          field :name
-        end
-      end
-      visit index_path(model_name: 'player')
-      player_names_by_date.each_with_index do |name, i|
-        expect(find("tbody tr:nth-child(#{i + 1})")).to have_content(name)
-      end
-    end
-    it 'can be activated by clicking the table header', js: true do
-      visit index_path(model_name: 'player')
-      find('th.header', text: 'Name').trigger('click')
-      is_expected.to have_css('th.name_field.headerSortDown')
-      expect(all('tbody td.name_field').map(&:text)).to eq @players.map(&:name).sort
-    end
-  end
-  context 'on listing as compact json' do
-    it 'has_content an array with 2 elements and contain an array of elements with keys id and label' do
-      FactoryBot.create_list(:player, 2)
-      get index_path(model_name: 'player', compact: true, format: :json)
-      expect(ActiveSupport::JSON.decode(response.body).length).to eq(2)
-      ActiveSupport::JSON.decode(response.body).each do |object|
-        expect(object).to have_key('id')
-        expect(object).to have_key('label')
-      end
-    end
-  end
-  describe 'with search operator' do
-    let(:player) { FactoryBot.create :player }
-    before do
-      expect(Player.count).to eq(0)
-    end
-    it 'finds the player if the query matches the default search operator' do
-      RailsAdmin.config do |config|
-        config.default_search_operator = 'ends_with'
-        config.model Player do
-          list { field :name }
-        end
-      end
-      visit index_path(model_name: 'player', query: player.name[2, -1])
-      is_expected.to have_content(player.name)
-    end
-    it 'does not find the player if the query does not match the default search operator' do
-      RailsAdmin.config do |config|
-        config.default_search_operator = 'ends_with'
-        config.model Player do
-          list { field :name }
-        end
-      end
-      visit index_path(model_name: 'player', query: player.name[0, 2])
-      is_expected.to have_no_content(player.name)
-    end
-    it 'finds the player if the query matches the specified search operator' do
-      RailsAdmin.config Player do
-        list do
-          field :name do
-            search_operator 'starts_with'
-          end
-        end
-      end
-      visit index_path(model_name: 'player', query: player.name[0, 2])
-      is_expected.to have_content(player.name)
-    end
-    it 'does not find the player if the query does not match the specified search operator' do
-      RailsAdmin.config Player do
-        list do
-          field :name do
-            search_operator 'starts_with'
-          end
-        end
-      end
-      visit index_path(model_name: 'player', query: player.name[1..])
-      is_expected.to have_no_content(player.name)
-    end
-  end
-  describe 'with custom search' do
-    before do
-      RailsAdmin.config do |config|
-        config.model Player do
-          list do
-            search_by :rails_admin_search
-          end
-        end
-      end
-    end
-    let!(:players) do
-      [FactoryBot.create(:player, name: 'Joe'),
-       FactoryBot.create(:player, name: 'George')]
-    end
-    it 'performs search using given scope' do
-      visit index_path(model_name: 'player', query: 'eoJ')
-      is_expected.to have_content(players[0].name)
-      is_expected.to have_no_content(players[1].name)
-    end
-  end
-  context 'with overridden to_param' do
-    before do
-      @ball = FactoryBot.create :ball
-      visit index_path(model_name: 'ball')
-    end
-    it 'shows the show, edit and delete links with valid url' do
-      is_expected.to have_selector("td a[href$='/admin/ball/#{@ball.id}']")
-      is_expected.to have_selector("td a[href$='/admin/ball/#{@ball.id}/edit']")
-      is_expected.to have_selector("td a[href$='/admin/ball/#{@ball.id}/delete']")
-    end
-  end
-  describe 'with model scope' do
-    context 'without default scope' do
-      let!(:teams) { %w[red yellow blue].map { |color| FactoryBot.create :team, color: color } }
-      it 'works', active_record: true do
-        RailsAdmin.config do |config|
-          config.model Team do
-            scope { Team.where(color: %w[red blue]) }
-          end
-        end
-        visit index_path(model_name: 'team')
-        expect(all(:css, 'td.color_field').map(&:text)).to match_array %w[red blue]
-      end
-      it 'works', mongoid: true do
-        RailsAdmin.config do |config|
-          config.model Team do
-            scope { Team.any_in(color: %w[red blue]) }
-          end
-        end
-        visit index_path(model_name: 'team')
-        expect(all(:css, 'td.color_field').map(&:text)).to match_array %w[red blue]
-      end
-    end
-    context 'with default_scope' do
-      let!(:comments) { %w[something anything].map { |content| FactoryBot.create :comment_confirmed, content: content } }
-      before do
-        RailsAdmin.config do |config|
-          config.model Comment::Confirmed do
-            scope { Comment::Confirmed.unscoped }
-          end
-        end
-      end
-      it 'can be overriden' do
-        visit index_path(model_name: 'comment~confirmed')
-        expect(all(:css, 'td.content_field').map(&:text)).to match_array %w[something anything]
-      end
-    end
-  end
-  describe 'with scopes' do
-    before do
-      RailsAdmin.config do |config|
-        config.model Team do
-          list do
-            scopes [nil, :red, :white]
-          end
-        end
-      end
-      @teams = [
-        FactoryBot.create(:team, color: 'red'),
-        FactoryBot.create(:team, color: 'red'),
-        FactoryBot.create(:team, color: 'white'),
-        FactoryBot.create(:team, color: 'black'),
-      ]
-    end
-    it 'displays configured scopes' do
-      visit index_path(model_name: 'team')
-      expect(find('#scope_selector li:first')).to have_content('All')
-      expect(find('#scope_selector li:nth-child(2)')).to have_content('Red')
-      expect(find('#scope_selector li:nth-child(3)')).to have_content('White')
-      expect(find('#scope_selector li:last')).to have_content('White')
-      expect(find('#scope_selector li a.active')).to have_content('All')
-    end
-    it 'shows only scoped records' do
-      visit index_path(model_name: 'team')
-      is_expected.to have_content(@teams[0].name)
-      is_expected.to have_content(@teams[1].name)
-      is_expected.to have_content(@teams[2].name)
-      is_expected.to have_content(@teams[3].name)
-      visit index_path(model_name: 'team', scope: 'red')
-      expect(find('#scope_selector li a.active')).to have_content('Red')
-      is_expected.to have_content(@teams[0].name)
-      is_expected.to have_content(@teams[1].name)
-      is_expected.to have_no_content(@teams[2].name)
-      is_expected.to have_no_content(@teams[3].name)
-      visit index_path(model_name: 'team', scope: 'white')
-      expect(find('#scope_selector li a.active')).to have_content('White')
-      is_expected.to have_no_content(@teams[0].name)
-      is_expected.to have_no_content(@teams[1].name)
-      is_expected.to have_content(@teams[2].name)
-      is_expected.to have_no_content(@teams[3].name)
-    end
-    it 'shows all records instead when scope not in list' do
-      visit index_path(model_name: 'team', scope: 'green')
-      is_expected.to have_content(@teams[0].name)
-      is_expected.to have_content(@teams[1].name)
-      is_expected.to have_content(@teams[2].name)
-      is_expected.to have_content(@teams[3].name)
-    end
-    describe 'i18n' do
-      before :each do
-        en = {admin: {scopes: {
-          _all: 'every',
-          red: 'krasnyj',
-        }}}
-        I18n.backend.store_translations(:en, en)
-      end
-      after { I18n.reload! }
-      context 'global' do
-        it 'displays configured scopes' do
-          visit index_path(model_name: 'team')
-          expect(find('#scope_selector li:first')).to have_content('every')
-          expect(find('#scope_selector li:nth-child(2)')).to have_content('krasnyj')
-          expect(find('#scope_selector li:nth-child(3)')).to have_content('White')
-          expect(find('#scope_selector li:last')).to have_content('White')
-          expect(find('#scope_selector li a.active')).to have_content('every')
-        end
-      end
-      context 'per model' do
-        before :each do
-          en = {admin: {scopes: {team: {
-            _all: 'any',
-            red: 'kr',
-          }}}}
-          I18n.backend.store_translations(:en, en)
-        end
-        after { I18n.reload! }
-        it 'displays configured scopes' do
-          visit index_path(model_name: 'team')
-          expect(find('#scope_selector li:first')).to have_content('any')
-          expect(find('#scope_selector li:nth-child(2)')).to have_content('kr')
-          expect(find('#scope_selector li:nth-child(3)')).to have_content('White')
-          expect(find('#scope_selector li:last')).to have_content('White')
-          expect(find('#scope_selector li a.active')).to have_content('any')
-        end
-      end
-    end
-  end
-  describe 'row CSS class' do
-    before do
-      RailsAdmin.config do |config|
-        config.model Team do
-          list do
-            row_css_class { 'my_class' }
-          end
-        end
-      end
-      @teams = [
-        FactoryBot.create(:team, color: 'red'),
-        FactoryBot.create(:team, color: 'red'),
-        FactoryBot.create(:team, color: 'white'),
-        FactoryBot.create(:team, color: 'black'),
-      ]
-    end
-    it 'appends the CSS class to the model row class' do
-      visit index_path(model_name: 'team')
-      expect(page).to have_css('tr.team_row.my_class')
-    end
-  end
-  describe 'checkboxes?' do
-    describe 'default is enabled' do
-      before do
-        RailsAdmin.config FieldTest do
-          list
-        end
-      end
-      it 'displays checkboxes on index' do
-        @records = FactoryBot.create_list :field_test, 3
-        visit index_path(model_name: 'field_test')
-        checkboxes = all(:xpath, './/form[@id="bulk_form"]//input[@type="checkbox"]')
-        expect(checkboxes.length).to be > 0
-        expect(page).to have_content('Selected items')
-      end
-    end
-    describe 'false' do
-      before do
-        RailsAdmin.config FieldTest do
-          list do
-            checkboxes false
-          end
-        end
-      end
-      it 'does not display any checkboxes on index' do
-        @records = FactoryBot.create_list :field_test, 3
-        visit index_path(model_name: 'field_test')
-        checkboxes = all(:xpath, './/form[@id="bulk_form"]//input[@type="checkbox"]')
-        expect(checkboxes.length).to eq 0
-        expect(page).not_to have_content('Selected items')
-      end
-    end
-  end
-  describe 'sidescroll' do
-    all_team_columns = ['', 'Id', 'Created at', 'Updated at', 'Division', 'Name', 'Logo url', 'Team Manager', 'Ballpark', 'Mascot', 'Founded', 'Wins', 'Losses', 'Win percentage', 'Revenue', 'Color', 'Custom field', 'Main Sponsor', 'Players', 'Some Fans', 'Comments', '']
-    it 'displays all fields on one page' do
-      FactoryBot.create_list :team, 3
-      visit index_path(model_name: 'team')
-      cols = all('th').collect(&:text)
-      expect(cols[0..4]).to eq(all_team_columns[0..4])
-      expect(cols).to contain_exactly(*all_team_columns)
-    end
-    it 'allows fields to be sticky' do
-      RailsAdmin.config Team do
-        list do
-          configure(:division) { sticky true }
-          configure(:name) { sticky true }
-        end
-      end
-      FactoryBot.create_list :team, 3
-      visit index_path(model_name: 'team')
-      cols = all('th').collect(&:text)
-      expect(cols[0..4]).to eq(['', 'Division', 'Name', 'Id', 'Created at'])
-      expect(cols).to contain_exactly(*all_team_columns)
-      expect(page).to have_selector('.name_field.sticky')
-      expect(page).to have_selector('.division_field.sticky')
-    end
-    it 'displays all fields with no checkboxes' do
-      RailsAdmin.config Team do
-        list do
-          checkboxes false
-        end
-      end
-      FactoryBot.create_list :team, 3
-      visit index_path(model_name: 'team')
-      cols = all('th').collect(&:text)
-      expect(cols[0..3]).to eq(all_team_columns[1..4])
-      expect(cols).to contain_exactly(*all_team_columns[1..])
-    end
-  end
-  context 'with composite_primary_keys', composite_primary_keys: true do
-    let!(:fanships) { FactoryBot.create_list(:fanship, 3) }
-    it 'shows the list' do
-      visit index_path(model_name: 'fanship')
-      expect(all('th').collect(&:text)[0..3]).to eq(['', 'Fan', 'Team', 'Since'])
-      fanships.each do |fanship|
-        is_expected.to have_content fanship.fan.name
-        is_expected.to have_content fanship.team.name
-      end
-      is_expected.to have_content '3 fanships'
-    end
-  end
-end

--- a/spec/integration/fields/multiple_file_upload_spec.rb
+++ b//dev/null
@@ -1,32 +0,0 @@
-require 'spec_helper'
-RSpec.describe 'MultipleFileUpload field', type: :request do
-  subject { page }
-  before do
-    RailsAdmin.config FieldTest do
-      field :string_field, :multiple_file_upload do
-        attachment do
-          delete_value { value }
-          def resource_url(_thumb = false)
-            value
-          end
-        end
-        delete_method 'boolean_field'
-        reorderable true
-        def value
-          bindings[:object].safe_send(name)&.split
-        end
-      end
-    end
-  end
-  let(:field_test) { FactoryBot.create :field_test, string_field: 'http://localhost/1.jpg http://localhost/2.jpg' }
-  it 'supports deletion', js: true do
-    visit edit_path(model_name: 'field_test', id: field_test.id)
-    click_link "Delete 'String field' #1"
-    expect(page.all(:css, '[name="field_test[boolean_field][]"]:checked', visible: false).map(&:value)).to eq %w[http://localhost/1.jpg]
-  end
-  it 'shows a inline preview', js: true do
-    visit new_path(model_name: 'field_test')
-    attach_file 'String field', file_path('test.jpg')
-    is_expected.to have_selector('#field_test_string_field_field img.preview')
-  end
-end

--- a/spec/rails_admin/config/fields/types/multiple_carrierwave_spec.rb
+++ b//dev/null
@@ -1,48 +0,0 @@
-require 'spec_helper'
-require 'base64'
-RSpec.describe RailsAdmin::Config::Fields::Types::MultipleCarrierwave do
-  it_behaves_like 'a generic field type', :string_field, :multiple_carrierwave
-  describe '#thumb_method' do
-    before do
-      RailsAdmin.config FieldTest do
-        field :carrierwave_assets, :multiple_carrierwave
-      end
-    end
-    let :rails_admin_field do
-      RailsAdmin.config('FieldTest').fields.detect do |f|
-        f.name == :carrierwave_assets
-      end.with(
-        object: FieldTest.new(carrierwave_assets: [File.open(file_path('test.jpg'))]),
-        view: ApplicationController.new.view_context,
-      )
-    end
-    it 'auto-detects thumb-like version name' do
-      expect(rails_admin_field.attachments.map(&:thumb_method)).to eq [:thumb]
-    end
-  end
-  describe '#delete_value', active_record: true do
-    before do
-      RailsAdmin.config FieldTest do
-        field :carrierwave_assets, :multiple_carrierwave
-      end
-    end
-    let :file do
-      CarrierWave::SanitizedFile.new(
-        tempfile: StringIO.new(Base64.decode64('R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=')),
-        filename: 'dummy.gif',
-      )
-    end
-    let :rails_admin_field do
-      RailsAdmin.config('FieldTest').fields.detect do |f|
-        f.name == :carrierwave_assets
-      end.with(
-        object: FieldTest.create(carrierwave_assets: [file]),
-        view: ApplicationController.new.view_context,
-      )
-    end
-    it 'does not use file.identifier, which is not available for Fog files' do
-      expect_any_instance_of(CarrierWave::SanitizedFile).not_to receive :identifier
-      expect(rails_admin_field.attachments.map(&:delete_value)).to eq ['dummy.gif']
-    end
-  end
-end

--- a/spec/spec_helper.rb
+++ b//dev/null
@@ -1,84 +0,0 @@
-ENV['RAILS_ENV'] = 'test'
-CI_ORM = (ENV['CI_ORM'] || :active_record).to_sym
-CI_TARGET_ORMS = %i[active_record mongoid].freeze
-PK_COLUMN = {active_record: :id, mongoid: :_id}[CI_ORM]
-if RUBY_ENGINE == 'jruby'
-  require 'i18n/backend'
-  require 'i18n/backend/simple'
-end
-require 'simplecov'
-require 'simplecov-lcov'
-SimpleCov.formatters = [SimpleCov::Formatter::HTMLFormatter, SimpleCov::Formatter::LcovFormatter]
-SimpleCov.start do
-  add_filter '/spec/'
-  add_filter '/vendor/bundle/'
-end
-SimpleCov::Formatter::LcovFormatter.config do |c|
-  c.report_with_single_file = true
-  c.single_report_path = 'coverage/lcov.info'
-end
-require File.expand_path('dummy_app/config/environment', __dir__)
-require 'rspec/rails'
-require 'factory_bot'
-require 'factories'
-require 'policies'
-require "database_cleaner/#{CI_ORM}"
-require "orm/#{CI_ORM}"
-require 'paper_trail/frameworks/rspec' if defined?(PaperTrail)
-Dir[File.expand_path('support/**/*.rb', __dir__),
-    File.expand_path('shared_examples/**/*.rb', __dir__)].sort.each { |f| require f }
-ActionMailer::Base.delivery_method = :test
-ActionMailer::Base.perform_deliveries = true
-ActionMailer::Base.default_url_options[:host] = 'example.com'
-Rails.backtrace_cleaner.remove_silencers!
-require 'capybara/cuprite'
-Capybara.javascript_driver = :cuprite
-Capybara.register_driver(:cuprite) do |app|
-  Capybara::Cuprite::Driver.new(app, js_errors: true, logger: ConsoleLogger)
-end
-Capybara.server = :webrick
-RailsAdmin.setup_all_extensions
-RSpec.configure do |config|
-  config.expect_with :rspec do |c|
-    c.syntax = :expect
-  end
-  config.disable_monkey_patching!
-  config.include RSpec::Matchers
-  config.include RailsAdmin::Engine.routes.url_helpers
-  config.include Warden::Test::Helpers
-  config.include Capybara::DSL, type: :request
-  config.verbose_retry = true
-  config.display_try_failure_messages = true
-  config.around :each, :js do |example|
-    example.run_with_retry retry: (ENV['CI'] && RUBY_ENGINE == 'jruby' ? 3 : 2)
-  end
-  config.retry_callback = proc do |example|
-    Capybara.reset! if example.metadata[:js]
-  end
-  config.before(:all) do
-    Webpacker.instance.compiler.compile if CI_ASSET == :webpacker
-  end
-  config.before do |example|
-    DatabaseCleaner.strategy =
-      if CI_ORM == :mongoid || example.metadata[:js]
-        :deletion
-      else
-        :transaction
-      end
-    DatabaseCleaner.start
-    RailsAdmin::Config.reset
-    RailsAdmin::Config.asset_source = CI_ASSET
-  end
-  config.after(:each) do
-    Warden.test_reset!
-    DatabaseCleaner.clean
-  end
-  CI_TARGET_ORMS.each do |orm|
-    if orm == CI_ORM
-      config.filter_run_excluding "skip_#{orm}": true
-    else
-      config.filter_run_excluding orm => true
-    end
-  end
-  config.filter_run_excluding composite_primary_keys: true unless defined?(CompositePrimaryKeys)
-end
